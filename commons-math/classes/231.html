<h3 style="margin:0px">Class: org.apache.commons.math4.linear.SparseFieldVectorTest (17 methods) </h3><br><pre style="padding:0"><code class="html"><div id="tags"><button id="4"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('4')" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value "><kbd id="tag-4"class="label-info"style="display: inline-block;font-size:7pt" >EqualityVerifier&nbsp;(12)</kbd></button>&nbsp;<button id="3"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('3')" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls"><kbd id="tag-3"class="label-info"style="display: inline-block;font-size:7pt" >InternalCallVerifier&nbsp;(9)</kbd></button>&nbsp;<button id="5"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('5')" data-toggle="tooltip" title="Verifies assertions in iterations"><kbd id="tag-5"class="label-info"style="display: inline-block;font-size:7pt" >IterativeVerifier&nbsp;(6)</kbd></button>&nbsp;<button id="6"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('6')" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes"><kbd id="tag-6"class="label-info"style="display: inline-block;font-size:7pt" >HybridVerifier&nbsp;(6)</kbd></button>&nbsp;<button id="10"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('10')" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure"><kbd id="tag-10"class="label-info"style="display: inline-block;font-size:7pt" >UtilityVerifier&nbsp;(5)</kbd></button>&nbsp;<button id="2"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('2')" data-toggle="tooltip" title="Verifies boolean conditions"><kbd id="tag-2"class="label-info"style="display: inline-block;font-size:7pt" >BooleanVerifier&nbsp;(5)</kbd></button>&nbsp;<button id="12"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('12')" data-toggle="tooltip" title="Verifies values related to public fields."><kbd id="tag-12"class="label-info"style="display: inline-block;font-size:7pt" >PublicFieldVerifier&nbsp;(4)</kbd></button>&nbsp;<button id="14"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('14')" data-toggle="tooltip" title="Verifies whether two objects/variables are the same"><kbd id="tag-14"class="label-info"style="display: inline-block;font-size:7pt" >IdentityVerifier&nbsp;(1)</kbd></button>&nbsp;</div></code></pre><center><button onclick="showBlocks()" style="margin:6px">Update filter <span class="glyphicon glyphicon-refresh" aria-hidden="true"></span> </button></center><br>
<pre class="type-10 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * Visiting an invalid subvector. 
 */
@Test public void testWalkInDefaultOrderPreservingVisitor2(){
  final SparseFieldVector<Fraction> v=create(5);
  final FieldVectorPreservingVisitor<Fraction> visitor;
  visitor=new FieldVectorPreservingVisitor<Fraction>(){
    public void visit(    int index,    Fraction value){
    }
    public void start(    int dimension,    int start,    int end){
    }
    public Fraction end(){
      return Fraction.ZERO;
    }
  }
;
  try {
    v.walkInDefaultOrder(visitor,-1,4);
    Assert.fail();
  }
 catch (  OutOfRangeException e) {
  }
  try {
    v.walkInDefaultOrder(visitor,5,4);
    Assert.fail();
  }
 catch (  OutOfRangeException e) {
  }
  try {
    v.walkInDefaultOrder(visitor,0,-1);
    Assert.fail();
  }
 catch (  OutOfRangeException e) {
  }
  try {
    v.walkInDefaultOrder(visitor,0,5);
    Assert.fail();
  }
 catch (  OutOfRangeException e) {
  }
  try {
    v.walkInDefaultOrder(visitor,4,0);
    Assert.fail();
  }
 catch (  NumberIsTooSmallException e) {
  }
}

</code></pre>

<pre class="type-3 type-14 type-4 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether two objects/variables are the same">IdentityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies whether two objects/variables are the same
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testPredicates(){
  SparseFieldVector<Fraction> v=new SparseFieldVector<Fraction>(field,new Fraction[]{new Fraction(0),new Fraction(1),new Fraction(2)});
  v.setEntry(0,field.getZero());
  Assert.assertEquals(v,new SparseFieldVector<Fraction>(field,new Fraction[]{new Fraction(0),new Fraction(1),new Fraction(2)}));
  Assert.assertNotSame(v,new SparseFieldVector<Fraction>(field,new Fraction[]{new Fraction(0),new Fraction(1),new Fraction(2),new Fraction(3)}));
}

</code></pre>

<pre class="type-5 type-2 type-4 type-12 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values related to public fields.">PublicFieldVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Verifies values related to public fields.
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Visiting a valid subvector. 
 */
@Test public void testWalkInOptimizedOrderPreservingVisitor3(){
  final Fraction[] data=new Fraction[]{Fraction.ZERO,Fraction.ONE,Fraction.ZERO,Fraction.ZERO,Fraction.TWO,Fraction.ZERO,Fraction.ZERO,Fraction.ZERO,new Fraction(3)};
  final SparseFieldVector<Fraction> v=new SparseFieldVector<Fraction>(field,data);
  final int expectedStart=2;
  final int expectedEnd=7;
  final FieldVectorPreservingVisitor<Fraction> visitor;
  visitor=new FieldVectorPreservingVisitor<Fraction>(){
    private final boolean[] visited=new boolean[data.length];
    public void visit(    final int actualIndex,    final Fraction actualValue){
      Assert.assertEquals(Integer.toString(actualIndex),data[actualIndex],actualValue);
      visited[actualIndex]=true;
    }
    public void start(    final int actualSize,    final int actualStart,    final int actualEnd){
      Assert.assertEquals(data.length,actualSize);
      Assert.assertEquals(expectedStart,actualStart);
      Assert.assertEquals(expectedEnd,actualEnd);
      Arrays.fill(visited,true);
    }
    public Fraction end(){
      for (int i=expectedStart; i <= expectedEnd; i++) {
        Assert.assertTrue("entry " + i + "has not been visited",visited[i]);
      }
      return Fraction.ZERO;
    }
  }
;
  v.walkInOptimizedOrder(visitor,expectedStart,expectedEnd);
}

</code></pre>

<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies whether objects/variable are equal to an expected value 
"></span><br>
/** 
 * Visiting a valid subvector. 
 */
@Test public void testWalkInDefaultOrderPreservingVisitor3(){
  final Fraction[] data=new Fraction[]{Fraction.ZERO,Fraction.ONE,Fraction.ZERO,Fraction.ZERO,Fraction.TWO,Fraction.ZERO,Fraction.ZERO,Fraction.ZERO,new Fraction(3)};
  final SparseFieldVector<Fraction> v=new SparseFieldVector<Fraction>(field,data);
  final int expectedStart=2;
  final int expectedEnd=7;
  final FieldVectorPreservingVisitor<Fraction> visitor;
  visitor=new FieldVectorPreservingVisitor<Fraction>(){
    private int expectedIndex;
    public void visit(    final int actualIndex,    final Fraction actualValue){
      Assert.assertEquals(expectedIndex,actualIndex);
      Assert.assertEquals(Integer.toString(actualIndex),data[actualIndex],actualValue);
      ++expectedIndex;
    }
    public void start(    final int actualSize,    final int actualStart,    final int actualEnd){
      Assert.assertEquals(data.length,actualSize);
      Assert.assertEquals(expectedStart,actualStart);
      Assert.assertEquals(expectedEnd,actualEnd);
      expectedIndex=expectedStart;
    }
    public Fraction end(){
      return Fraction.ZERO;
    }
  }
;
  v.walkInDefaultOrder(visitor,expectedStart,expectedEnd);
}

</code></pre>

<pre class="type-10 type-2 type-3 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testMisc(){
  SparseFieldVector<Fraction> v1=new SparseFieldVector<Fraction>(field,vec1);
  String out1=v1.toString();
  Assert.assertTrue("some output ",out1.length() != 0);
  try {
    v1.checkVectorDimensions(2);
    Assert.fail("MathIllegalArgumentException expected");
  }
 catch (  MathIllegalArgumentException ex) {
  }
}

</code></pre>

<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies whether objects/variable are equal to an expected value 
"></span><br>
/** 
 * The whole vector is visited. 
 */
@Test public void testWalkInDefaultOrderPreservingVisitor1(){
  final Fraction[] data=new Fraction[]{Fraction.ZERO,Fraction.ONE,Fraction.ZERO,Fraction.ZERO,Fraction.TWO,Fraction.ZERO,Fraction.ZERO,Fraction.ZERO,new Fraction(3)};
  final SparseFieldVector<Fraction> v=new SparseFieldVector<Fraction>(field,data);
  final FieldVectorPreservingVisitor<Fraction> visitor;
  visitor=new FieldVectorPreservingVisitor<Fraction>(){
    private int expectedIndex;
    public void visit(    final int actualIndex,    final Fraction actualValue){
      Assert.assertEquals(expectedIndex,actualIndex);
      Assert.assertEquals(Integer.toString(actualIndex),data[actualIndex],actualValue);
      ++expectedIndex;
    }
    public void start(    final int actualSize,    final int actualStart,    final int actualEnd){
      Assert.assertEquals(data.length,actualSize);
      Assert.assertEquals(0,actualStart);
      Assert.assertEquals(data.length - 1,actualEnd);
      expectedIndex=0;
    }
    public Fraction end(){
      return Fraction.ZERO;
    }
  }
;
  v.walkInDefaultOrder(visitor);
}

</code></pre>

<pre class="type-10 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * Visiting an invalid subvector. 
 */
@Test public void testWalkInOptimizedOrderChangingVisitor2(){
  final SparseFieldVector<Fraction> v=create(5);
  final FieldVectorChangingVisitor<Fraction> visitor;
  visitor=new FieldVectorChangingVisitor<Fraction>(){
    public Fraction visit(    int index,    Fraction value){
      return Fraction.ZERO;
    }
    public void start(    int dimension,    int start,    int end){
    }
    public Fraction end(){
      return Fraction.ZERO;
    }
  }
;
  try {
    v.walkInOptimizedOrder(visitor,-1,4);
    Assert.fail();
  }
 catch (  OutOfRangeException e) {
  }
  try {
    v.walkInOptimizedOrder(visitor,5,4);
    Assert.fail();
  }
 catch (  OutOfRangeException e) {
  }
  try {
    v.walkInOptimizedOrder(visitor,0,-1);
    Assert.fail();
  }
 catch (  OutOfRangeException e) {
  }
  try {
    v.walkInOptimizedOrder(visitor,0,5);
    Assert.fail();
  }
 catch (  OutOfRangeException e) {
  }
  try {
    v.walkInOptimizedOrder(visitor,4,0);
    Assert.fail();
  }
 catch (  NumberIsTooSmallException e) {
  }
}

</code></pre>

<pre class="type-5 type-2 type-3 type-4 type-12 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values related to public fields.">PublicFieldVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Verifies values related to public fields.
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * The whole vector is visited. 
 */
@Test public void testWalkInOptimizedOrderChangingVisitor1(){
  final Fraction[] data=new Fraction[]{Fraction.ZERO,Fraction.ONE,Fraction.ZERO,Fraction.ZERO,Fraction.TWO,Fraction.ZERO,Fraction.ZERO,Fraction.ZERO,new Fraction(3)};
  final SparseFieldVector<Fraction> v=new SparseFieldVector<Fraction>(field,data);
  final FieldVectorChangingVisitor<Fraction> visitor;
  visitor=new FieldVectorChangingVisitor<Fraction>(){
    private final boolean[] visited=new boolean[data.length];
    public Fraction visit(    final int actualIndex,    final Fraction actualValue){
      visited[actualIndex]=true;
      Assert.assertEquals(Integer.toString(actualIndex),data[actualIndex],actualValue);
      return actualValue.add(actualIndex);
    }
    public void start(    final int actualSize,    final int actualStart,    final int actualEnd){
      Assert.assertEquals(data.length,actualSize);
      Assert.assertEquals(0,actualStart);
      Assert.assertEquals(data.length - 1,actualEnd);
      Arrays.fill(visited,false);
    }
    public Fraction end(){
      for (int i=0; i < data.length; i++) {
        Assert.assertTrue("entry " + i + "has not been visited",visited[i]);
      }
      return Fraction.ZERO;
    }
  }
;
  v.walkInOptimizedOrder(visitor);
  for (int i=0; i < data.length; i++) {
    Assert.assertEquals("entry " + i,data[i].add(i),v.getEntry(i));
  }
}

</code></pre>

<pre class="type-5 type-2 type-3 type-4 type-12 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values related to public fields.">PublicFieldVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Verifies values related to public fields.
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Visiting a valid subvector. 
 */
@Test public void testWalkInOptimizedOrderChangingVisitor3(){
  final Fraction[] data=new Fraction[]{Fraction.ZERO,Fraction.ONE,Fraction.ZERO,Fraction.ZERO,Fraction.TWO,Fraction.ZERO,Fraction.ZERO,Fraction.ZERO,new Fraction(3)};
  final SparseFieldVector<Fraction> v=new SparseFieldVector<Fraction>(field,data);
  final int expectedStart=2;
  final int expectedEnd=7;
  final FieldVectorChangingVisitor<Fraction> visitor;
  visitor=new FieldVectorChangingVisitor<Fraction>(){
    private final boolean[] visited=new boolean[data.length];
    public Fraction visit(    final int actualIndex,    final Fraction actualValue){
      Assert.assertEquals(Integer.toString(actualIndex),data[actualIndex],actualValue);
      visited[actualIndex]=true;
      return actualValue.add(actualIndex);
    }
    public void start(    final int actualSize,    final int actualStart,    final int actualEnd){
      Assert.assertEquals(data.length,actualSize);
      Assert.assertEquals(expectedStart,actualStart);
      Assert.assertEquals(expectedEnd,actualEnd);
      Arrays.fill(visited,true);
    }
    public Fraction end(){
      for (int i=expectedStart; i <= expectedEnd; i++) {
        Assert.assertTrue("entry " + i + "has not been visited",visited[i]);
      }
      return Fraction.ZERO;
    }
  }
;
  v.walkInOptimizedOrder(visitor,expectedStart,expectedEnd);
  for (int i=expectedStart; i <= expectedEnd; i++) {
    Assert.assertEquals("entry " + i,data[i].add(i),v.getEntry(i));
  }
}

</code></pre>

<pre class="type-10 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * Visiting an invalid subvector. 
 */
@Test public void testWalkInOptimizedOrderPreservingVisitor2(){
  final SparseFieldVector<Fraction> v=create(5);
  final FieldVectorPreservingVisitor<Fraction> visitor;
  visitor=new FieldVectorPreservingVisitor<Fraction>(){
    public void visit(    int index,    Fraction value){
    }
    public void start(    int dimension,    int start,    int end){
    }
    public Fraction end(){
      return Fraction.ZERO;
    }
  }
;
  try {
    v.walkInOptimizedOrder(visitor,-1,4);
    Assert.fail();
  }
 catch (  OutOfRangeException e) {
  }
  try {
    v.walkInOptimizedOrder(visitor,5,4);
    Assert.fail();
  }
 catch (  OutOfRangeException e) {
  }
  try {
    v.walkInOptimizedOrder(visitor,0,-1);
    Assert.fail();
  }
 catch (  OutOfRangeException e) {
  }
  try {
    v.walkInOptimizedOrder(visitor,0,5);
    Assert.fail();
  }
 catch (  OutOfRangeException e) {
  }
  try {
    v.walkInOptimizedOrder(visitor,4,0);
    Assert.fail();
  }
 catch (  NumberIsTooSmallException e) {
  }
}

</code></pre>

<pre class="type-3 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
"></span><br>
@Test public void testOuterProduct(){
  final SparseFieldVector<Fraction> u=new SparseFieldVector<Fraction>(FractionField.getInstance(),new Fraction[]{new Fraction(1),new Fraction(2),new Fraction(-3)});
  final SparseFieldVector<Fraction> v=new SparseFieldVector<Fraction>(FractionField.getInstance(),new Fraction[]{new Fraction(4),new Fraction(-2)});
  final FieldMatrix<Fraction> uv=u.outerProduct(v);
  final double tol=Math.ulp(1d);
  Assert.assertEquals(new Fraction(4).doubleValue(),uv.getEntry(0,0).doubleValue(),tol);
  Assert.assertEquals(new Fraction(-2).doubleValue(),uv.getEntry(0,1).doubleValue(),tol);
  Assert.assertEquals(new Fraction(8).doubleValue(),uv.getEntry(1,0).doubleValue(),tol);
  Assert.assertEquals(new Fraction(-4).doubleValue(),uv.getEntry(1,1).doubleValue(),tol);
  Assert.assertEquals(new Fraction(-12).doubleValue(),uv.getEntry(2,0).doubleValue(),tol);
  Assert.assertEquals(new Fraction(6).doubleValue(),uv.getEntry(2,1).doubleValue(),tol);
}

</code></pre>

<pre class="type-5 type-3 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
"></span><br>
/** 
 * Visiting a valid subvector. 
 */
@Test public void testWalkInDefaultOrderChangingVisitor3(){
  final Fraction[] data=new Fraction[]{Fraction.ZERO,Fraction.ONE,Fraction.ZERO,Fraction.ZERO,Fraction.TWO,Fraction.ZERO,Fraction.ZERO,Fraction.ZERO,new Fraction(3)};
  final SparseFieldVector<Fraction> v=new SparseFieldVector<Fraction>(field,data);
  final int expectedStart=2;
  final int expectedEnd=7;
  final FieldVectorChangingVisitor<Fraction> visitor;
  visitor=new FieldVectorChangingVisitor<Fraction>(){
    private int expectedIndex;
    public Fraction visit(    final int actualIndex,    final Fraction actualValue){
      Assert.assertEquals(expectedIndex,actualIndex);
      Assert.assertEquals(Integer.toString(actualIndex),data[actualIndex],actualValue);
      ++expectedIndex;
      return actualValue.add(actualIndex);
    }
    public void start(    final int actualSize,    final int actualStart,    final int actualEnd){
      Assert.assertEquals(data.length,actualSize);
      Assert.assertEquals(expectedStart,actualStart);
      Assert.assertEquals(expectedEnd,actualEnd);
      expectedIndex=expectedStart;
    }
    public Fraction end(){
      return Fraction.ZERO;
    }
  }
;
  v.walkInDefaultOrder(visitor,expectedStart,expectedEnd);
  for (int i=expectedStart; i <= expectedEnd; i++) {
    Assert.assertEquals("entry " + i,data[i].add(i),v.getEntry(i));
  }
}

</code></pre>

<pre class="type-3 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
"></span><br>
@Test public void testBasicFunctions() throws FractionConversionException {
  SparseFieldVector<Fraction> v1=new SparseFieldVector<Fraction>(field,vec1);
  SparseFieldVector<Fraction> v2=new SparseFieldVector<Fraction>(field,vec2);
  FieldVector<Fraction> v2_t=new ArrayFieldVectorTest.FieldVectorTestImpl<Fraction>(vec2);
  FieldVector<Fraction> v_add=v1.add(v2);
  Fraction[] result_add={new Fraction(5),new Fraction(7),new Fraction(9)};
  Assert.assertArrayEquals("compare vect",v_add.toArray(),result_add);
  FieldVector<Fraction> vt2=new ArrayFieldVectorTest.FieldVectorTestImpl<Fraction>(vec2);
  FieldVector<Fraction> v_add_i=v1.add(vt2);
  Fraction[] result_add_i={new Fraction(5),new Fraction(7),new Fraction(9)};
  Assert.assertArrayEquals("compare vect",v_add_i.toArray(),result_add_i);
  SparseFieldVector<Fraction> v_subtract=v1.subtract(v2);
  Fraction[] result_subtract={new Fraction(-3),new Fraction(-3),new Fraction(-3)};
  assertClose("compare vect",v_subtract.toArray(),result_subtract,normTolerance);
  FieldVector<Fraction> v_subtract_i=v1.subtract(vt2);
  Fraction[] result_subtract_i={new Fraction(-3),new Fraction(-3),new Fraction(-3)};
  assertClose("compare vect",v_subtract_i.toArray(),result_subtract_i,normTolerance);
  FieldVector<Fraction> v_ebeMultiply=v1.ebeMultiply(v2);
  Fraction[] result_ebeMultiply={new Fraction(4),new Fraction(10),new Fraction(18)};
  assertClose("compare vect",v_ebeMultiply.toArray(),result_ebeMultiply,normTolerance);
  FieldVector<Fraction> v_ebeMultiply_2=v1.ebeMultiply(v2_t);
  Fraction[] result_ebeMultiply_2={new Fraction(4),new Fraction(10),new Fraction(18)};
  assertClose("compare vect",v_ebeMultiply_2.toArray(),result_ebeMultiply_2,normTolerance);
  FieldVector<Fraction> v_ebeDivide=v1.ebeDivide(v2);
  Fraction[] result_ebeDivide={new Fraction(0.25d),new Fraction(0.4d),new Fraction(0.5d)};
  assertClose("compare vect",v_ebeDivide.toArray(),result_ebeDivide,normTolerance);
  FieldVector<Fraction> v_ebeDivide_2=v1.ebeDivide(v2_t);
  Fraction[] result_ebeDivide_2={new Fraction(0.25d),new Fraction(0.4d),new Fraction(0.5d)};
  assertClose("compare vect",v_ebeDivide_2.toArray(),result_ebeDivide_2,normTolerance);
  Fraction dot=v1.dotProduct(v2);
  Assert.assertEquals("compare val ",new Fraction(32),dot);
  Fraction dot_2=v1.dotProduct(v2_t);
  Assert.assertEquals("compare val ",new Fraction(32),dot_2);
  FieldMatrix<Fraction> m_outerProduct=v1.outerProduct(v2);
  Assert.assertEquals("compare val ",new Fraction(4),m_outerProduct.getEntry(0,0));
  FieldMatrix<Fraction> m_outerProduct_2=v1.outerProduct(v2_t);
  Assert.assertEquals("compare val ",new Fraction(4),m_outerProduct_2.getEntry(0,0));
}

</code></pre>

<pre class="type-10 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * Visiting an invalid subvector. 
 */
@Test public void testWalkInDefaultOrderChangingVisitor2(){
  final SparseFieldVector<Fraction> v=create(5);
  final FieldVectorChangingVisitor<Fraction> visitor;
  visitor=new FieldVectorChangingVisitor<Fraction>(){
    public Fraction visit(    int index,    Fraction value){
      return Fraction.ZERO;
    }
    public void start(    int dimension,    int start,    int end){
    }
    public Fraction end(){
      return Fraction.ZERO;
    }
  }
;
  try {
    v.walkInDefaultOrder(visitor,-1,4);
    Assert.fail();
  }
 catch (  OutOfRangeException e) {
  }
  try {
    v.walkInDefaultOrder(visitor,5,4);
    Assert.fail();
  }
 catch (  OutOfRangeException e) {
  }
  try {
    v.walkInDefaultOrder(visitor,0,-1);
    Assert.fail();
  }
 catch (  OutOfRangeException e) {
  }
  try {
    v.walkInDefaultOrder(visitor,0,5);
    Assert.fail();
  }
 catch (  OutOfRangeException e) {
  }
  try {
    v.walkInDefaultOrder(visitor,4,0);
    Assert.fail();
  }
 catch (  NumberIsTooSmallException e) {
  }
}

</code></pre>

<pre class="type-3 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
"></span><br>
@Test public void testMapFunctions() throws FractionConversionException {
  SparseFieldVector<Fraction> v1=new SparseFieldVector<Fraction>(field,vec1);
  FieldVector<Fraction> v_mapAdd=v1.mapAdd(new Fraction(2));
  Fraction[] result_mapAdd={new Fraction(3),new Fraction(4),new Fraction(5)};
  Assert.assertArrayEquals("compare vectors",result_mapAdd,v_mapAdd.toArray());
  FieldVector<Fraction> v_mapAddToSelf=v1.copy();
  v_mapAddToSelf.mapAddToSelf(new Fraction(2));
  Fraction[] result_mapAddToSelf={new Fraction(3),new Fraction(4),new Fraction(5)};
  Assert.assertArrayEquals("compare vectors",result_mapAddToSelf,v_mapAddToSelf.toArray());
  FieldVector<Fraction> v_mapSubtract=v1.mapSubtract(new Fraction(2));
  Fraction[] result_mapSubtract={new Fraction(-1),new Fraction(0),new Fraction(1)};
  Assert.assertArrayEquals("compare vectors",result_mapSubtract,v_mapSubtract.toArray());
  FieldVector<Fraction> v_mapSubtractToSelf=v1.copy();
  v_mapSubtractToSelf.mapSubtractToSelf(new Fraction(2));
  Fraction[] result_mapSubtractToSelf={new Fraction(-1),new Fraction(0),new Fraction(1)};
  Assert.assertArrayEquals("compare vectors",result_mapSubtractToSelf,v_mapSubtractToSelf.toArray());
  FieldVector<Fraction> v_mapMultiply=v1.mapMultiply(new Fraction(2));
  Fraction[] result_mapMultiply={new Fraction(2),new Fraction(4),new Fraction(6)};
  Assert.assertArrayEquals("compare vectors",result_mapMultiply,v_mapMultiply.toArray());
  FieldVector<Fraction> v_mapMultiplyToSelf=v1.copy();
  v_mapMultiplyToSelf.mapMultiplyToSelf(new Fraction(2));
  Fraction[] result_mapMultiplyToSelf={new Fraction(2),new Fraction(4),new Fraction(6)};
  Assert.assertArrayEquals("compare vectors",result_mapMultiplyToSelf,v_mapMultiplyToSelf.toArray());
  FieldVector<Fraction> v_mapDivide=v1.mapDivide(new Fraction(2));
  Fraction[] result_mapDivide={new Fraction(.5d),new Fraction(1),new Fraction(1.5d)};
  Assert.assertArrayEquals("compare vectors",result_mapDivide,v_mapDivide.toArray());
  FieldVector<Fraction> v_mapDivideToSelf=v1.copy();
  v_mapDivideToSelf.mapDivideToSelf(new Fraction(2));
  Fraction[] result_mapDivideToSelf={new Fraction(.5d),new Fraction(1),new Fraction(1.5d)};
  Assert.assertArrayEquals("compare vectors",result_mapDivideToSelf,v_mapDivideToSelf.toArray());
  FieldVector<Fraction> v_mapInv=v1.mapInv();
  Fraction[] result_mapInv={new Fraction(1),new Fraction(0.5d),new Fraction(3.333333333333333e-01d)};
  Assert.assertArrayEquals("compare vectors",result_mapInv,v_mapInv.toArray());
  FieldVector<Fraction> v_mapInvToSelf=v1.copy();
  v_mapInvToSelf.mapInvToSelf();
  Fraction[] result_mapInvToSelf={new Fraction(1),new Fraction(0.5d),new Fraction(3.333333333333333e-01d)};
  Assert.assertArrayEquals("compare vectors",result_mapInvToSelf,v_mapInvToSelf.toArray());
}

</code></pre>

<pre class="type-5 type-2 type-4 type-12 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values related to public fields.">PublicFieldVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Verifies values related to public fields.
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * The whole vector is visited. 
 */
@Test public void testWalkInOptimizedOrderPreservingVisitor1(){
  final Fraction[] data=new Fraction[]{Fraction.ZERO,Fraction.ONE,Fraction.ZERO,Fraction.ZERO,Fraction.TWO,Fraction.ZERO,Fraction.ZERO,Fraction.ZERO,new Fraction(3)};
  final SparseFieldVector<Fraction> v=new SparseFieldVector<Fraction>(field,data);
  final FieldVectorPreservingVisitor<Fraction> visitor;
  visitor=new FieldVectorPreservingVisitor<Fraction>(){
    private final boolean[] visited=new boolean[data.length];
    public void visit(    final int actualIndex,    final Fraction actualValue){
      visited[actualIndex]=true;
      Assert.assertEquals(Integer.toString(actualIndex),data[actualIndex],actualValue);
    }
    public void start(    final int actualSize,    final int actualStart,    final int actualEnd){
      Assert.assertEquals(data.length,actualSize);
      Assert.assertEquals(0,actualStart);
      Assert.assertEquals(data.length - 1,actualEnd);
      Arrays.fill(visited,false);
    }
    public Fraction end(){
      for (int i=0; i < data.length; i++) {
        Assert.assertTrue("entry " + i + "has not been visited",visited[i]);
      }
      return Fraction.ZERO;
    }
  }
;
  v.walkInOptimizedOrder(visitor);
}

</code></pre>

<pre class="type-5 type-3 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
"></span><br>
/** 
 * The whole vector is visited. 
 */
@Test public void testWalkInDefaultOrderChangingVisitor1(){
  final Fraction[] data=new Fraction[]{Fraction.ZERO,Fraction.ONE,Fraction.ZERO,Fraction.ZERO,Fraction.TWO,Fraction.ZERO,Fraction.ZERO,Fraction.ZERO,new Fraction(3)};
  final SparseFieldVector<Fraction> v=new SparseFieldVector<Fraction>(field,data);
  final FieldVectorChangingVisitor<Fraction> visitor;
  visitor=new FieldVectorChangingVisitor<Fraction>(){
    private int expectedIndex;
    public Fraction visit(    final int actualIndex,    final Fraction actualValue){
      Assert.assertEquals(expectedIndex,actualIndex);
      Assert.assertEquals(Integer.toString(actualIndex),data[actualIndex],actualValue);
      ++expectedIndex;
      return actualValue.add(actualIndex);
    }
    public void start(    final int actualSize,    final int actualStart,    final int actualEnd){
      Assert.assertEquals(data.length,actualSize);
      Assert.assertEquals(0,actualStart);
      Assert.assertEquals(data.length - 1,actualEnd);
      expectedIndex=0;
    }
    public Fraction end(){
      return Fraction.ZERO;
    }
  }
;
  v.walkInDefaultOrder(visitor);
  for (int i=0; i < data.length; i++) {
    Assert.assertEquals("entry " + i,data[i].add(i),v.getEntry(i));
  }
}

</code></pre>

<script>$(document).ready(function() {
  $('pre code').each(function(i, block) {
    hljs.highlightBlock(block);
  });
});</script>
