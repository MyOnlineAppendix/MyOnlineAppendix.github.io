<h3 style="margin:0px">Class: org.apache.commons.math4.stat.regression.MillerUpdatingRegressionTest (17 methods) </h3><br><pre style="padding:0"><code class="html"><div id="tags"><button id="4"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('4')" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value "><kbd id="tag-4"class="label-info"style="display: inline-block;font-size:7pt" >EqualityVerifier&nbsp;(12)</kbd></button>&nbsp;<button id="3"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('3')" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls"><kbd id="tag-3"class="label-info"style="display: inline-block;font-size:7pt" >InternalCallVerifier&nbsp;(12)</kbd></button>&nbsp;<button id="10"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('10')" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure"><kbd id="tag-10"class="label-info"style="display: inline-block;font-size:7pt" >UtilityVerifier&nbsp;(9)</kbd></button>&nbsp;<button id="11"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('11')" data-toggle="tooltip" title="Verifies assertions inside branch conditions"><kbd id="tag-11"class="label-info"style="display: inline-block;font-size:7pt" >BranchVerifier&nbsp;(5)</kbd></button>&nbsp;<button id="15"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('15')" data-toggle="tooltip" title="Verifies whether objects are null"><kbd id="tag-15"class="label-info"style="display: inline-block;font-size:7pt" >NullVerifier&nbsp;(4)</kbd></button>&nbsp;<button id="5"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('5')" data-toggle="tooltip" title="Verifies assertions in iterations"><kbd id="tag-5"class="label-info"style="display: inline-block;font-size:7pt" >IterativeVerifier&nbsp;(4)</kbd></button>&nbsp;<button id="6"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('6')" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes"><kbd id="tag-6"class="label-info"style="display: inline-block;font-size:7pt" >HybridVerifier&nbsp;(4)</kbd></button>&nbsp;</div></code></pre><center><button onclick="showBlocks()" style="margin:6px">Update filter <span class="glyphicon glyphicon-refresh" aria-hidden="true"></span> </button></center><br>
<pre class="type-5 type-11 type-10 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testPCorr(){
  MillerUpdatingRegression instance=new MillerUpdatingRegression(4,false);
  double[][] x=new double[airdata[0].length][];
  double[] y=new double[airdata[0].length];
  double[] cp=new double[10];
  double[] yxcorr=new double[4];
  double[] diag=new double[4];
  double sumysq=0.0;
  int off=0;
  for (int i=0; i < airdata[0].length; i++) {
    x[i]=new double[4];
    x[i][0]=1.0;
    x[i][1]=FastMath.log(airdata[3][i]);
    x[i][2]=FastMath.log(airdata[4][i]);
    x[i][3]=airdata[5][i];
    y[i]=FastMath.log(airdata[2][i]);
    off=0;
    for (int j=0; j < 4; j++) {
      double tmp=x[i][j];
      for (int k=0; k <= j; k++, off++) {
        cp[off]+=tmp * x[i][k];
      }
      yxcorr[j]+=tmp * y[i];
    }
    sumysq+=y[i] * y[i];
  }
  PearsonsCorrelation pearson=new PearsonsCorrelation(x);
  RealMatrix corr=pearson.getCorrelationMatrix();
  off=0;
  for (int i=0; i < 4; i++, off+=(i + 1)) {
    diag[i]=FastMath.sqrt(cp[off]);
  }
  instance.addObservations(x,y);
  double[] pc=instance.getPartialCorrelations(0);
  int idx=0;
  off=0;
  int off2=6;
  for (int i=0; i < 4; i++) {
    for (int j=0; j < i; j++) {
      if (FastMath.abs(pc[idx] - cp[off] / (diag[i] * diag[j])) > 1.0e-8) {
        Assert.fail("Failed cross products... i = " + i + " j = "+ j);
      }
      ++idx;
      ++off;
    }
    ++off;
    if (FastMath.abs(pc[i + off2] - yxcorr[i] / (FastMath.sqrt(sumysq) * diag[i])) > 1.0e-8) {
      Assert.fail("Assert.failed cross product i = " + i + " y");
    }
  }
  double[] pc2=instance.getPartialCorrelations(1);
  idx=0;
  for (int i=1; i < 4; i++) {
    for (int j=1; j < i; j++) {
      if (FastMath.abs(pc2[idx] - corr.getEntry(j,i)) > 1.0e-8) {
        Assert.fail("Failed cross products... i = " + i + " j = "+ j);
      }
      ++idx;
    }
  }
  double[] pc3=instance.getPartialCorrelations(2);
  if (pc3 == null) {
    Assert.fail("Should not be null");
  }
  return;
}

</code></pre>

<pre class="type-11 type-10 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * Test of hasIntercept method, of class MillerUpdatingRegression.
 */
@Test public void testHasIntercept(){
  MillerUpdatingRegression instance=new MillerUpdatingRegression(10,false);
  if (instance.hasIntercept()) {
    Assert.fail("Should not have intercept");
  }
  instance=new MillerUpdatingRegression(10,true);
  if (!instance.hasIntercept()) {
    Assert.fail("Should have intercept");
  }
}

</code></pre>

<pre class="type-3 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
"></span><br>
@Test public void testWampler2(){
  double[] data=new double[]{1.00000,0,1.11111,1,1.24992,2,1.42753,3,1.65984,4,1.96875,5,2.38336,6,2.94117,7,3.68928,8,4.68559,9,6.00000,10,7.71561,11,9.92992,12,12.75603,13,16.32384,14,20.78125,15,26.29536,16,33.05367,17,41.26528,18,51.16209,19,63.00000,20};
  MillerUpdatingRegression model=new MillerUpdatingRegression(5,true);
  int off=0;
  double[] tmp=new double[5];
  int nobs=21;
  for (int i=0; i < nobs; i++) {
    tmp[0]=data[off + 1];
    tmp[1]=tmp[0] * tmp[0];
    tmp[2]=tmp[0] * tmp[1];
    tmp[3]=tmp[0] * tmp[2];
    tmp[4]=tmp[0] * tmp[3];
    model.addObservation(tmp,data[off]);
    off+=2;
  }
  RegressionResults result=model.regress();
  double[] betaHat=result.getParameterEstimates();
  TestUtils.assertEquals(betaHat,new double[]{1.0,1.0e-1,1.0e-2,1.0e-3,1.0e-4,1.0e-5},1E-8);
  double[] se=result.getStdErrorOfEstimates();
  TestUtils.assertEquals(se,new double[]{0.0,0.0,0.0,0.0,0.0,0.0},1E-8);
  TestUtils.assertEquals(1.0,result.getRSquared(),1.0e-10);
  TestUtils.assertEquals(0,result.getMeanSquareError(),1.0e-7);
  TestUtils.assertEquals(0.00,result.getErrorSumSquares(),1.0e-6);
  return;
}

</code></pre>

<pre class="type-5 type-3 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
"></span><br>
@Test public void testHdiagConstant(){
  MillerUpdatingRegression instance=new MillerUpdatingRegression(3,true);
  double[][] x=new double[airdata[0].length][];
  double[] y=new double[airdata[0].length];
  for (int i=0; i < airdata[0].length; i++) {
    x[i]=new double[3];
    x[i][0]=FastMath.log(airdata[3][i]);
    x[i][1]=FastMath.log(airdata[4][i]);
    x[i][2]=airdata[5][i];
    y[i]=FastMath.log(airdata[2][i]);
  }
  instance.addObservations(x,y);
  OLSMultipleLinearRegression ols=new OLSMultipleLinearRegression();
  ols.setNoIntercept(false);
  ols.newSampleData(y,x);
  RealMatrix rm=ols.calculateHat();
  for (int i=0; i < x.length; i++) {
    TestUtils.assertEquals(instance.getDiagonalOfHatMatrix(x[i]),rm.getEntry(i,i),1.0e-8);
  }
  return;
}

</code></pre>

<pre class="type-10 type-3 type-4 type-15 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testRegressAirlineConstantExternal(){
  MillerUpdatingRegression instance=new MillerUpdatingRegression(4,false);
  double[][] x=new double[airdata[0].length][];
  double[] y=new double[airdata[0].length];
  for (int i=0; i < airdata[0].length; i++) {
    x[i]=new double[4];
    x[i][0]=1.0;
    x[i][1]=FastMath.log(airdata[3][i]);
    x[i][2]=FastMath.log(airdata[4][i]);
    x[i][3]=airdata[5][i];
    y[i]=FastMath.log(airdata[2][i]);
  }
  instance.addObservations(x,y);
  try {
    RegressionResults result=instance.regress();
    Assert.assertNotNull("The test case is a prototype.",result);
    TestUtils.assertEquals(new double[]{9.5169,0.8827,0.4540,-1.6275},result.getParameterEstimates(),1e-4);
    TestUtils.assertEquals(new double[]{.2292445,.0132545,.0203042,.345302},result.getStdErrorOfEstimates(),1.0e-4);
    TestUtils.assertEquals(0.01552839,result.getMeanSquareError(),1.0e-8);
  }
 catch (  Exception e) {
    Assert.fail("Should not throw exception but does");
  }
}

</code></pre>

<pre class="type-3 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
"></span><br>
@Test public void testWampler1(){
  double[] data=new double[]{1,0,6,1,63,2,364,3,1365,4,3906,5,9331,6,19608,7,37449,8,66430,9,111111,10,177156,11,271453,12,402234,13,579195,14,813616,15,1118481,16,1508598,17,2000719,18,2613660,19,3368421,20};
  MillerUpdatingRegression model=new MillerUpdatingRegression(5,true);
  int off=0;
  double[] tmp=new double[5];
  int nobs=21;
  for (int i=0; i < nobs; i++) {
    tmp[0]=data[off + 1];
    tmp[1]=tmp[0] * tmp[0];
    tmp[2]=tmp[0] * tmp[1];
    tmp[3]=tmp[0] * tmp[2];
    tmp[4]=tmp[0] * tmp[3];
    model.addObservation(tmp,data[off]);
    off+=2;
  }
  RegressionResults result=model.regress();
  double[] betaHat=result.getParameterEstimates();
  TestUtils.assertEquals(betaHat,new double[]{1.0,1.0,1.0,1.0,1.0,1.0},1E-8);
  double[] se=result.getStdErrorOfEstimates();
  TestUtils.assertEquals(se,new double[]{0.0,0.0,0.0,0.0,0.0,0.0},1E-8);
  TestUtils.assertEquals(1.0,result.getRSquared(),1.0e-10);
  TestUtils.assertEquals(0,result.getMeanSquareError(),1.0e-7);
  TestUtils.assertEquals(0.00,result.getErrorSumSquares(),1.0e-6);
  return;
}

</code></pre>

<pre class="type-11 type-10 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * Test of getN method, of class MillerUpdatingRegression.
 */
@Test public void testAddObsGetNClear(){
  MillerUpdatingRegression instance=new MillerUpdatingRegression(3,true);
  double[][] xAll=new double[airdata[0].length][];
  double[] y=new double[airdata[0].length];
  for (int i=0; i < airdata[0].length; i++) {
    xAll[i]=new double[3];
    xAll[i][0]=FastMath.log(airdata[3][i]);
    xAll[i][1]=FastMath.log(airdata[4][i]);
    xAll[i][2]=airdata[5][i];
    y[i]=FastMath.log(airdata[2][i]);
  }
  instance.addObservations(xAll,y);
  if (instance.getN() != xAll.length) {
    Assert.fail("Number of observations not correct in bulk addition");
  }
  instance.clear();
  for (int i=0; i < xAll.length; i++) {
    instance.addObservation(xAll[i],y[i]);
  }
  if (instance.getN() != xAll.length) {
    Assert.fail("Number of observations not correct in drip addition");
  }
  return;
}

</code></pre>

<pre class="type-3 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
"></span><br>
@Test public void testFilippelli(){
  double[] data=new double[]{0.8116,-6.860120914,0.9072,-4.324130045,0.9052,-4.358625055,0.9039,-4.358426747,0.8053,-6.955852379,0.8377,-6.661145254,0.8667,-6.355462942,0.8809,-6.118102026,0.7975,-7.115148017,0.8162,-6.815308569,0.8515,-6.519993057,0.8766,-6.204119983,0.8885,-5.853871964,0.8859,-6.109523091,0.8959,-5.79832982,0.8913,-5.482672118,0.8959,-5.171791386,0.8971,-4.851705903,0.9021,-4.517126416,0.909,-4.143573228,0.9139,-3.709075441,0.9199,-3.499489089,0.8692,-6.300769497,0.8872,-5.953504836,0.89,-5.642065153,0.891,-5.031376979,0.8977,-4.680685696,0.9035,-4.329846955,0.9078,-3.928486195,0.7675,-8.56735134,0.7705,-8.363211311,0.7713,-8.107682739,0.7736,-7.823908741,0.7775,-7.522878745,0.7841,-7.218819279,0.7971,-6.920818754,0.8329,-6.628932138,0.8641,-6.323946875,0.8804,-5.991399828,0.7668,-8.781464495,0.7633,-8.663140179,0.7678,-8.473531488,0.7697,-8.247337057,0.77,-7.971428747,0.7749,-7.676129393,0.7796,-7.352812702,0.7897,-7.072065318,0.8131,-6.774174009,0.8498,-6.478861916,0.8741,-6.159517513,0.8061,-6.835647144,0.846,-6.53165267,0.8751,-6.224098421,0.8856,-5.910094889,0.8919,-5.598599459,0.8934,-5.290645224,0.894,-4.974284616,0.8957,-4.64454848,0.9047,-4.290560426,0.9129,-3.885055584,0.9209,-3.408378962,0.9219,-3.13200249,0.7739,-8.726767166,0.7681,-8.66695597,0.7665,-8.511026475,0.7703,-8.165388579,0.7702,-7.886056648,0.7761,-7.588043762,0.7809,-7.283412422,0.7961,-6.995678626,0.8253,-6.691862621,0.8602,-6.392544977,0.8809,-6.067374056,0.8301,-6.684029655,0.8664,-6.378719832,0.8834,-6.065855188,0.8898,-5.752272167,0.8964,-5.132414673,0.8963,-4.811352704,0.9074,-4.098269308,0.9119,-3.66174277,0.9228,-3.2644011};
  MillerUpdatingRegression model=new MillerUpdatingRegression(10,true);
  int off=0;
  double[] tmp=new double[10];
  int nobs=82;
  for (int i=0; i < nobs; i++) {
    tmp[0]=data[off + 1];
    tmp[1]=tmp[0] * tmp[0];
    tmp[2]=tmp[0] * tmp[1];
    tmp[3]=tmp[0] * tmp[2];
    tmp[4]=tmp[0] * tmp[3];
    tmp[5]=tmp[0] * tmp[4];
    tmp[6]=tmp[0] * tmp[5];
    tmp[7]=tmp[0] * tmp[6];
    tmp[8]=tmp[0] * tmp[7];
    tmp[9]=tmp[0] * tmp[8];
    model.addObservation(tmp,data[off]);
    off+=2;
  }
  RegressionResults result=model.regress();
  double[] betaHat=result.getParameterEstimates();
  TestUtils.assertEquals(betaHat,new double[]{-1467.48961422980,-2772.17959193342,-2316.37108160893,-1127.97394098372,-354.478233703349,-75.1242017393757,-10.8753180355343,-1.06221498588947,-0.670191154593408E-01,-0.246781078275479E-02,-0.402962525080404E-04},1E-5);
  double[] se=result.getStdErrorOfEstimates();
  TestUtils.assertEquals(se,new double[]{298.084530995537,559.779865474950,466.477572127796,227.204274477751,71.6478660875927,15.2897178747400,2.23691159816033,0.221624321934227,0.142363763154724E-01,0.535617408889821E-03,0.896632837373868E-05},1E-5);
  TestUtils.assertEquals(0.996727416185620,result.getRSquared(),1.0e-8);
  TestUtils.assertEquals(0.112091743968020E-04,result.getMeanSquareError(),1.0e-10);
  TestUtils.assertEquals(0.795851382172941E-03,result.getErrorSumSquares(),1.0e-10);
}

</code></pre>

<pre class="type-3 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
"></span><br>
@Test public void testSubsetRegression(){
  MillerUpdatingRegression instance=new MillerUpdatingRegression(3,true);
  MillerUpdatingRegression redRegression=new MillerUpdatingRegression(2,true);
  double[][] x=new double[airdata[0].length][];
  double[][] xReduced=new double[airdata[0].length][];
  double[] y=new double[airdata[0].length];
  for (int i=0; i < airdata[0].length; i++) {
    x[i]=new double[3];
    x[i][0]=FastMath.log(airdata[3][i]);
    x[i][1]=FastMath.log(airdata[4][i]);
    x[i][2]=airdata[5][i];
    xReduced[i]=new double[2];
    xReduced[i][0]=FastMath.log(airdata[3][i]);
    xReduced[i][1]=FastMath.log(airdata[4][i]);
    y[i]=FastMath.log(airdata[2][i]);
  }
  instance.addObservations(x,y);
  redRegression.addObservations(xReduced,y);
  RegressionResults resultsInstance=instance.regress(new int[]{0,1,2});
  RegressionResults resultsReduced=redRegression.regress();
  TestUtils.assertEquals(resultsInstance.getParameterEstimates(),resultsReduced.getParameterEstimates(),1.0e-12);
  TestUtils.assertEquals(resultsInstance.getStdErrorOfEstimates(),resultsReduced.getStdErrorOfEstimates(),1.0e-12);
}

</code></pre>

<pre class="type-11 type-10 type-3 type-4 type-15 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testThreeRedundantColumn(){
  MillerUpdatingRegression instance=new MillerUpdatingRegression(4,false);
  MillerUpdatingRegression instance2=new MillerUpdatingRegression(7,false);
  double[][] x=new double[airdata[0].length][];
  double[][] x2=new double[airdata[0].length][];
  double[] y=new double[airdata[0].length];
  for (int i=0; i < airdata[0].length; i++) {
    x[i]=new double[4];
    x2[i]=new double[7];
    x[i][0]=1.0;
    x[i][1]=FastMath.log(airdata[3][i]);
    x[i][2]=FastMath.log(airdata[4][i]);
    x[i][3]=airdata[5][i];
    x2[i][0]=x[i][0];
    x2[i][1]=x[i][0];
    x2[i][2]=x[i][1];
    x2[i][3]=x[i][2];
    x2[i][4]=x[i][1];
    x2[i][5]=x[i][3];
    x2[i][6]=x[i][2];
    y[i]=FastMath.log(airdata[2][i]);
  }
  instance.addObservations(x,y);
  RegressionResults result=instance.regress();
  Assert.assertNotNull("Could not estimate initial regression",result);
  instance2.addObservations(x2,y);
  RegressionResults resultRedundant=instance2.regress();
  Assert.assertNotNull("Could not estimate redundant regression",resultRedundant);
  double[] beta=result.getParameterEstimates();
  double[] betar=resultRedundant.getParameterEstimates();
  double[] se=result.getStdErrorOfEstimates();
  double[] ser=resultRedundant.getStdErrorOfEstimates();
  if (FastMath.abs(beta[0] - betar[0]) > 1.0e-8) {
    Assert.fail("Parameters not correct after reorder (0,3)");
  }
  if (FastMath.abs(beta[1] - betar[2]) > 1.0e-8) {
    Assert.fail("Parameters not correct after reorder (1,2)");
  }
  if (FastMath.abs(beta[2] - betar[3]) > 1.0e-8) {
    Assert.fail("Parameters not correct after reorder (2,1)");
  }
  if (FastMath.abs(beta[3] - betar[5]) > 1.0e-8) {
    Assert.fail("Parameters not correct after reorder (3,0)");
  }
  if (FastMath.abs(se[0] - ser[0]) > 1.0e-8) {
    Assert.fail("Se not correct after reorder (0,3)");
  }
  if (FastMath.abs(se[1] - ser[2]) > 1.0e-8) {
    Assert.fail("Se not correct after reorder (1,2)");
  }
  if (FastMath.abs(se[2] - ser[3]) > 1.0e-8) {
    Assert.fail("Se not correct after reorder (2,1)");
  }
  if (FastMath.abs(se[3] - ser[5]) > 1.0e-8) {
    Assert.fail("Se not correct after reorder (3,0)");
  }
  if (FastMath.abs(result.getCovarianceOfParameters(0,0) - resultRedundant.getCovarianceOfParameters(0,0)) > 1.0e-8) {
    Assert.fail("VCV not correct after reorder (0,0)");
  }
  if (FastMath.abs(result.getCovarianceOfParameters(0,1) - resultRedundant.getCovarianceOfParameters(0,2)) > 1.0e-8) {
    Assert.fail("VCV not correct after reorder (0,1)<->(0,2)");
  }
  if (FastMath.abs(result.getCovarianceOfParameters(0,2) - resultRedundant.getCovarianceOfParameters(0,3)) > 1.0e-8) {
    Assert.fail("VCV not correct after reorder (0,2)<->(0,1)");
  }
  if (FastMath.abs(result.getCovarianceOfParameters(0,3) - resultRedundant.getCovarianceOfParameters(0,5)) > 1.0e-8) {
    Assert.fail("VCV not correct after reorder (0,3)<->(0,3)");
  }
  if (FastMath.abs(result.getCovarianceOfParameters(1,0) - resultRedundant.getCovarianceOfParameters(2,0)) > 1.0e-8) {
    Assert.fail("VCV not correct after reorder (1,0)<->(2,0)");
  }
  if (FastMath.abs(result.getCovarianceOfParameters(1,1) - resultRedundant.getCovarianceOfParameters(2,2)) > 1.0e-8) {
    Assert.fail("VCV not correct  (1,1)<->(2,1)");
  }
  if (FastMath.abs(result.getCovarianceOfParameters(1,2) - resultRedundant.getCovarianceOfParameters(2,3)) > 1.0e-8) {
    Assert.fail("VCV not correct  (1,2)<->(2,2)");
  }
  if (FastMath.abs(result.getCovarianceOfParameters(2,0) - resultRedundant.getCovarianceOfParameters(3,0)) > 1.0e-8) {
    Assert.fail("VCV not correct  (2,0)<->(1,0)");
  }
  if (FastMath.abs(result.getCovarianceOfParameters(2,1) - resultRedundant.getCovarianceOfParameters(3,2)) > 1.0e-8) {
    Assert.fail("VCV not correct  (2,1)<->(1,2)");
  }
  if (FastMath.abs(result.getCovarianceOfParameters(3,3) - resultRedundant.getCovarianceOfParameters(5,5)) > 1.0e-8) {
    Assert.fail("VCV not correct  (3,3)<->(3,2)");
  }
  TestUtils.assertEquals(result.getAdjustedRSquared(),resultRedundant.getAdjustedRSquared(),1.0e-8);
  TestUtils.assertEquals(result.getErrorSumSquares(),resultRedundant.getErrorSumSquares(),1.0e-8);
  TestUtils.assertEquals(result.getMeanSquareError(),resultRedundant.getMeanSquareError(),1.0e-8);
  TestUtils.assertEquals(result.getRSquared(),resultRedundant.getRSquared(),1.0e-8);
  return;
}

</code></pre>

<pre class="type-5 type-3 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
"></span><br>
@Test public void testHdiag(){
  MillerUpdatingRegression instance=new MillerUpdatingRegression(4,false);
  double[][] x=new double[airdata[0].length][];
  double[] y=new double[airdata[0].length];
  for (int i=0; i < airdata[0].length; i++) {
    x[i]=new double[4];
    x[i][0]=1.0;
    x[i][1]=FastMath.log(airdata[3][i]);
    x[i][2]=FastMath.log(airdata[4][i]);
    x[i][3]=airdata[5][i];
    y[i]=FastMath.log(airdata[2][i]);
  }
  instance.addObservations(x,y);
  OLSMultipleLinearRegression ols=new OLSMultipleLinearRegression();
  ols.setNoIntercept(true);
  ols.newSampleData(y,x);
  RealMatrix rm=ols.calculateHat();
  for (int i=0; i < x.length; i++) {
    TestUtils.assertEquals(instance.getDiagonalOfHatMatrix(x[i]),rm.getEntry(i,i),1.0e-8);
  }
  return;
}

</code></pre>

<pre class="type-5 type-11 type-10 type-3 type-4 type-15 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testOneRedundantColumn(){
  MillerUpdatingRegression instance=new MillerUpdatingRegression(4,false);
  MillerUpdatingRegression instance2=new MillerUpdatingRegression(5,false);
  double[][] x=new double[airdata[0].length][];
  double[][] x2=new double[airdata[0].length][];
  double[] y=new double[airdata[0].length];
  for (int i=0; i < airdata[0].length; i++) {
    x[i]=new double[4];
    x2[i]=new double[5];
    x[i][0]=1.0;
    x[i][1]=FastMath.log(airdata[3][i]);
    x[i][2]=FastMath.log(airdata[4][i]);
    x[i][3]=airdata[5][i];
    x2[i][0]=x[i][0];
    x2[i][1]=x[i][1];
    x2[i][2]=x[i][2];
    x2[i][3]=x[i][3];
    x2[i][4]=x[i][3];
    y[i]=FastMath.log(airdata[2][i]);
  }
  instance.addObservations(x,y);
  RegressionResults result=instance.regress();
  Assert.assertNotNull("Could not estimate initial regression",result);
  instance2.addObservations(x2,y);
  RegressionResults resultRedundant=instance2.regress();
  Assert.assertNotNull("Could not estimate redundant regression",resultRedundant);
  double[] beta=result.getParameterEstimates();
  double[] betar=resultRedundant.getParameterEstimates();
  double[] se=result.getStdErrorOfEstimates();
  double[] ser=resultRedundant.getStdErrorOfEstimates();
  for (int i=0; i < beta.length; i++) {
    if (FastMath.abs(beta[i] - betar[i]) > 1.0e-8) {
      Assert.fail("Parameters not correctly estimated");
    }
    if (FastMath.abs(se[i] - ser[i]) > 1.0e-8) {
      Assert.fail("Standard errors not correctly estimated");
    }
    for (int j=0; j < i; j++) {
      if (FastMath.abs(result.getCovarianceOfParameters(i,j) - resultRedundant.getCovarianceOfParameters(i,j)) > 1.0e-8) {
        Assert.fail("Variance Covariance not correct");
      }
    }
  }
  TestUtils.assertEquals(result.getAdjustedRSquared(),resultRedundant.getAdjustedRSquared(),1.0e-8);
  TestUtils.assertEquals(result.getErrorSumSquares(),resultRedundant.getErrorSumSquares(),1.0e-8);
  TestUtils.assertEquals(result.getMeanSquareError(),resultRedundant.getMeanSquareError(),1.0e-8);
  TestUtils.assertEquals(result.getRSquared(),resultRedundant.getRSquared(),1.0e-8);
  return;
}

</code></pre>

<pre class="type-10 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testNegativeTestAddObs(){
  MillerUpdatingRegression instance=new MillerUpdatingRegression(3,true);
  try {
    instance.addObservation(new double[]{1.0},0.0);
    Assert.fail("Should throw MathIllegalArgumentException");
  }
 catch (  MathIllegalArgumentException iae) {
  }
catch (  Exception e) {
    Assert.fail("Should throw MathIllegalArgumentException");
  }
  try {
    instance.addObservation(new double[]{1.0,1.0,1.0,1.0,1.0,1.0,1.0},0.0);
    Assert.fail("Should throw MathIllegalArgumentException");
  }
 catch (  MathIllegalArgumentException iae) {
  }
catch (  Exception e) {
    Assert.fail("Should throw MathIllegalArgumentException");
  }
  try {
    instance.addObservation(new double[]{1.0,1.0,1.0},0.0);
  }
 catch (  Exception e) {
    Assert.fail("Should throw MathIllegalArgumentException");
  }
  instance=new MillerUpdatingRegression(3,false);
  try {
    instance.addObservation(new double[]{1.0},0.0);
    Assert.fail("Should throw MathIllegalArgumentException [NOINTERCEPT]");
  }
 catch (  MathIllegalArgumentException iae) {
  }
catch (  Exception e) {
    Assert.fail("Should throw MathIllegalArgumentException [NOINTERCEPT]");
  }
  try {
    instance.addObservation(new double[]{1.0,1.0,1.0,1.0,1.0,1.0,1.0},0.0);
    Assert.fail("Should throw MathIllegalArgumentException [NOINTERCEPT]");
  }
 catch (  MathIllegalArgumentException iae) {
  }
catch (  Exception e) {
    Assert.fail("Should throw MathIllegalArgumentException [NOINTERCEPT]");
  }
  try {
    instance.addObservation(new double[]{1.0,1.0,1.0},0.0);
  }
 catch (  Exception e) {
    Assert.fail("Should throw MathIllegalArgumentException [NOINTERCEPT]");
  }
}

</code></pre>

<pre class="type-3 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
"></span><br>
/** 
 * Test Longley dataset against certified values provided by NIST.
 * Data Source: J. Longley (1967) "An Appraisal of Least Squares
 * Programs for the Electronic Computer from the Point of View of the User"
 * Journal of the American Statistical Association, vol. 62. September,
 * pp. 819-841.
 * Certified values (and data) are from NIST:
 * http://www.itl.nist.gov/div898/strd/lls/data/LINKS/DATA/Longley.dat
 */
@Test public void testLongly(){
  double[] design=new double[]{60323,83.0,234289,2356,1590,107608,1947,61122,88.5,259426,2325,1456,108632,1948,60171,88.2,258054,3682,1616,109773,1949,61187,89.5,284599,3351,1650,110929,1950,63221,96.2,328975,2099,3099,112075,1951,63639,98.1,346999,1932,3594,113270,1952,64989,99.0,365385,1870,3547,115094,1953,63761,100.0,363112,3578,3350,116219,1954,66019,101.2,397469,2904,3048,117388,1955,67857,104.6,419180,2822,2857,118734,1956,68169,108.4,442769,2936,2798,120445,1957,66513,110.8,444546,4681,2637,121950,1958,68655,112.6,482704,3813,2552,123366,1959,69564,114.2,502601,3931,2514,125368,1960,69331,115.7,518173,4806,2572,127852,1961,70551,116.9,554894,4007,2827,130081,1962};
  final int nobs=16;
  final int nvars=6;
  MillerUpdatingRegression model=new MillerUpdatingRegression(6,true);
  int off=0;
  double[] tmp=new double[6];
  for (int i=0; i < nobs; i++) {
    System.arraycopy(design,off + 1,tmp,0,nvars);
    model.addObservation(tmp,design[off]);
    off+=nvars + 1;
  }
  RegressionResults result=model.regress();
  double[] betaHat=result.getParameterEstimates();
  TestUtils.assertEquals(betaHat,new double[]{-3482258.63459582,15.0618722713733,-0.358191792925910E-01,-2.02022980381683,-1.03322686717359,-0.511041056535807E-01,1829.15146461355},1E-8);
  double[] errors=result.getStdErrorOfEstimates();
  TestUtils.assertEquals(new double[]{890420.383607373,84.9149257747669,0.334910077722432E-01,0.488399681651699,0.214274163161675,0.226073200069370,455.478499142212},errors,1E-6);
  TestUtils.assertEquals(0.995479004577296,result.getRSquared(),1E-12);
  TestUtils.assertEquals(0.992465007628826,result.getAdjustedRSquared(),1E-12);
  model=new MillerUpdatingRegression(6,false);
  off=0;
  for (int i=0; i < nobs; i++) {
    System.arraycopy(design,off + 1,tmp,0,nvars);
    model.addObservation(tmp,design[off]);
    off+=nvars + 1;
  }
  result=model.regress();
  betaHat=result.getParameterEstimates();
  TestUtils.assertEquals(betaHat,new double[]{-52.99357013868291,0.07107319907358,-0.42346585566399,-0.57256866841929,-0.41420358884978,48.41786562001326},1E-11);
  errors=result.getStdErrorOfEstimates();
  TestUtils.assertEquals(new double[]{129.54486693117232,0.03016640003786,0.41773654056612,0.27899087467676,0.32128496193363,17.68948737819961},errors,1E-11);
  TestUtils.assertEquals(0.9999670130706,result.getRSquared(),1E-12);
  TestUtils.assertEquals(0.999947220913,result.getAdjustedRSquared(),1E-12);
}

</code></pre>

<pre class="type-10 type-3 type-4 type-15 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testRegressAirlineConstantInternal(){
  MillerUpdatingRegression instance=new MillerUpdatingRegression(3,true);
  double[][] x=new double[airdata[0].length][];
  double[] y=new double[airdata[0].length];
  for (int i=0; i < airdata[0].length; i++) {
    x[i]=new double[3];
    x[i][0]=FastMath.log(airdata[3][i]);
    x[i][1]=FastMath.log(airdata[4][i]);
    x[i][2]=airdata[5][i];
    y[i]=FastMath.log(airdata[2][i]);
  }
  instance.addObservations(x,y);
  try {
    RegressionResults result=instance.regress();
    Assert.assertNotNull("The test case is a prototype.",result);
    TestUtils.assertEquals(new double[]{9.5169,0.8827,0.4540,-1.6275},result.getParameterEstimates(),1e-4);
    TestUtils.assertEquals(new double[]{.2292445,.0132545,.0203042,.345302},result.getStdErrorOfEstimates(),1.0e-4);
    TestUtils.assertEquals(0.9883,result.getRSquared(),1.0e-4);
    TestUtils.assertEquals(0.01552839,result.getMeanSquareError(),1.0e-8);
  }
 catch (  Exception e) {
    Assert.fail("Should not throw exception but does");
  }
}

</code></pre>

<pre class="type-10 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testNegativeTestAddMultipleObs(){
  MillerUpdatingRegression instance=new MillerUpdatingRegression(3,true);
  try {
    double[][] tst={{1.0,1.0,1.0},{1.20,2.0,2.1}};
    double[] y={1.0};
    instance.addObservations(tst,y);
    Assert.fail("Should throw MathIllegalArgumentException");
  }
 catch (  MathIllegalArgumentException iae) {
  }
catch (  Exception e) {
    Assert.fail("Should throw MathIllegalArgumentException");
  }
  try {
    double[][] tst={{1.0,1.0,1.0},{1.20,2.0,2.1}};
    double[] y={1.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0};
    instance.addObservations(tst,y);
    Assert.fail("Should throw MathIllegalArgumentException");
  }
 catch (  MathIllegalArgumentException iae) {
  }
catch (  Exception e) {
    Assert.fail("Should throw MathIllegalArgumentException");
  }
}

</code></pre>

<pre class="type-3 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
"></span><br>
@Test public void testWampler3(){
  double[] data=new double[]{760,0,-2042,1,2111,2,-1684,3,3888,4,1858,5,11379,6,17560,7,39287,8,64382,9,113159,10,175108,11,273291,12,400186,13,581243,14,811568,15,1121004,16,1506550,17,2002767,18,2611612,19,3369180,20};
  MillerUpdatingRegression model=new MillerUpdatingRegression(5,true);
  int off=0;
  double[] tmp=new double[5];
  int nobs=21;
  for (int i=0; i < nobs; i++) {
    tmp[0]=data[off + 1];
    tmp[1]=tmp[0] * tmp[0];
    tmp[2]=tmp[0] * tmp[1];
    tmp[3]=tmp[0] * tmp[2];
    tmp[4]=tmp[0] * tmp[3];
    model.addObservation(tmp,data[off]);
    off+=2;
  }
  RegressionResults result=model.regress();
  double[] betaHat=result.getParameterEstimates();
  TestUtils.assertEquals(betaHat,new double[]{1.0,1.0,1.0,1.0,1.0,1.0},1E-8);
  double[] se=result.getStdErrorOfEstimates();
  TestUtils.assertEquals(se,new double[]{2152.32624678170,2363.55173469681,779.343524331583,101.475507550350,5.64566512170752,0.112324854679312},1E-8);
  TestUtils.assertEquals(.999995559025820,result.getRSquared(),1.0e-10);
  TestUtils.assertEquals(5570284.53333333,result.getMeanSquareError(),1.0e-7);
  TestUtils.assertEquals(83554268.0000000,result.getErrorSumSquares(),1.0e-6);
  return;
}

</code></pre>

<script>$(document).ready(function() {
  $('pre code').each(function(i, block) {
    hljs.highlightBlock(block);
  });
});</script>
