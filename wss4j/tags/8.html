<h3><span class=" glyphicon glyphicon-tag"/>&nbspUtilityVerifier</h3><kbd>Verifies (un)successful execution of the test case by reporting explicitly a failure</kbd><br><br><br><h4 style="margin:0px">Class: org.apache.wss4j.common.crypto.AuthorityKeyIdentifierTest </h4><pre class="type-3 type-8 type-7 type-6 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testMerlinAKI() throws Exception {
  KeyStore keyStore=loadKeyStore("keys/wss40.jks","security");
  assertNotNull(keyStore);
  X509Certificate cert=(X509Certificate)keyStore.getCertificate("wss40");
  assertNotNull(cert);
  KeyStore caKeyStore=loadKeyStore("keys/wss40CA.jks","security");
  assertNotNull(caKeyStore);
  MerlinAKI crypto=new MerlinAKI();
  crypto.setTrustStore(caKeyStore);
  crypto.verifyTrust(new X509Certificate[]{cert},false,null);
  KeyStore badKeyStore=loadKeyStore("keys/wss86.keystore","security");
  assertNotNull(badKeyStore);
  X509Certificate badCert=(X509Certificate)badKeyStore.getCertificate("wss86");
  assertNotNull(badCert);
  try {
    crypto.verifyTrust(new X509Certificate[]{badCert},false,null);
    fail("Failure expected on trying to validate an untrusted cert");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.FAILURE);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.wss4j.dom.components.crypto.CertificateStoreTest </h4><pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test signing a SOAP message using a BST. The certificate is not known to the
 * CertificateStore and so should throw an exception.
 */
@Test public void testSignatureDirectReferenceUntrusted() throws Exception {
  WSSecSignature sign=new WSSecSignature();
  sign.setUserInfo("16c73ab6-b892-458f-abf5-2f875f74882e","security");
  sign.setKeyIdentifierType(WSConstants.BST_DIRECT_REFERENCE);
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  Document signedDoc=sign.build(doc,CryptoFactory.getInstance(),secHeader);
  if (LOG.isDebugEnabled()) {
    String outputString=XMLUtils.prettyDocumentToString(signedDoc);
    LOG.debug(outputString);
  }
  try {
    verify(signedDoc,receiverCrypto);
    fail("Failure expected on an unknown certificate");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.FAILURE);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.wss4j.dom.components.crypto.CryptoProviderTest </h4><pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test loading a certificate using BouncyCastle, and using it to encrypt a message, but
 * decrypt the message using the Java Keystore provider. In this case though the cert doesn't
 * correspond with the cert in wss86.keystore.
 */
@Test public void testBadInterop() throws Exception {
  byte[] certBytes=Base64.decode("MIIDNDCCAp2gAwIBAgIBEDANBgkqhkiG9w0BAQQFADBmMQswCQYDVQQGEwJERTEPMA0GA1UECBMG" + "QmF5ZXJuMQ8wDQYDVQQHEwZNdW5pY2gxDTALBgNVBAoTBEhvbWUxFTATBgNVBAsTDEFwYWNoZSBX" + "U1M0SjEPMA0GA1UEAxMGV2VybmVyMB4XDTA4MDQwNDE5MzIxOFoXDTEwMDQwNDE5MzIxOFowYTEL"+ "MAkGA1UEBhMCREUxDzANBgNVBAgTBkJheWVybjEPMA0GA1UEBxMGTXVuaWNoMQ8wDQYDVQQKEwZB"+ "cGFjaGUxDjAMBgNVBAsTBVdTUzRKMQ8wDQYDVQQDEwZXZXJuZXIwgZ8wDQYJKoZIhvcNAQEBBQAD"+ "gY0AMIGJAoGBAINlL3/k0H/zvknpBtLo8jzXwx/IJU/CGSv6MsqJZ2fyZ6kpLlXCuSBUZ/tfkdxp"+ "uzhYq/Sc7A8csIk9gDf9RUbrhK0qKw0VP6DoCIJjS5IeN+NeJkx8YjmzLPmZqLYbNPXr/hy8CRrR"+ "6CqLTTSkBwoEJ+cDkfZrdH2/bND0FEIZAgMBAAGjgfYwgfMwCQYDVR0TBAIwADAsBglghkgBhvhC"+ "AQ0EHxYdT3BlblNTTCBHZW5lcmF0ZWQgQ2VydGlmaWNhdGUwHQYDVR0OBBYEFFSZXv0I5bG7XPEw"+ "jylwG3lmZGdiMIGYBgNVHSMEgZAwgY2AFL/FsHHolGIMacU1TZW/88Bd2EL6oWqkaDBmMQswCQYD"+ "VQQGEwJERTEPMA0GA1UECBMGQmF5ZXJuMQ8wDQYDVQQHEwZNdW5pY2gxDTALBgNVBAoTBEhvbWUx"+ "FTATBgNVBAsTDEFwYWNoZSBXU1M0SjEPMA0GA1UEAxMGV2VybmVyggkAuBIOAWJ19mwwDQYJKoZI"+ "hvcNAQEEBQADgYEAUiUh/wORVcQYXxIh13h3w2Btg6Kj2g6V6YO0Utc/gEYWwT310C2OuroKAwwo"+ "HapMIIWiJRclIAiA8Hnb0Sv/puuHYD4G4NWFdiVjRord90eZJe40NMGruRmlqIRIGGKCv+wv3E6U"+ "x1cWW862f5H9Eyrcocke2P+3GNAGy83vghA=");
  try {
    Security.addProvider(new BouncyCastleProvider());
    CertificateFactory factory=CertificateFactory.getInstance("X.509","BC");
    X509Certificate cert=(X509Certificate)factory.generateCertificate(new ByteArrayInputStream(certBytes));
    WSSecEncrypt encrypt=new WSSecEncrypt();
    encrypt.setUseThisCert(cert);
    Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
    WSSecHeader secHeader=new WSSecHeader(doc);
    secHeader.insertSecurityHeader();
    Document encryptedDoc=encrypt.build(doc,crypto,secHeader);
    if (LOG.isDebugEnabled()) {
      String outputString=XMLUtils.prettyDocumentToString(encryptedDoc);
      LOG.debug(outputString);
    }
    try {
      verify(encryptedDoc);
      fail("Failure expected on encryption with a key that does not exist in the keystore");
    }
 catch (    WSSecurityException ex) {
      assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.FAILURE);
    }
  }
  finally {
    Security.removeProvider(BouncyCastleProvider.PROVIDER_NAME);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.wss4j.dom.components.crypto.CryptoTest </h4><pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test that we can sign and verify a signature using dynamically loaded keystores/truststore
 */
@Test public void testDynamicCrypto() throws Exception {
  WSSecSignature builder=new WSSecSignature();
  builder.setUserInfo("wss40","security");
  builder.setKeyIdentifierType(WSConstants.BST_DIRECT_REFERENCE);
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  Crypto crypto=new Merlin();
  KeyStore keyStore=KeyStore.getInstance(KeyStore.getDefaultType());
  ClassLoader loader=Loader.getClassLoader(CryptoTest.class);
  InputStream input=Merlin.loadInputStream(loader,"keys/wss40.jks");
  keyStore.load(input,"security".toCharArray());
  ((Merlin)crypto).setKeyStore(keyStore);
  Document signedDoc=builder.build(doc,crypto,secHeader);
  Crypto processCrypto=new Merlin();
  KeyStore trustStore=KeyStore.getInstance(KeyStore.getDefaultType());
  input=Merlin.loadInputStream(loader,"keys/wss40CA.jks");
  trustStore.load(input,"security".toCharArray());
  ((Merlin)processCrypto).setTrustStore(trustStore);
  WSSecurityEngine secEngine=new WSSecurityEngine();
  secEngine.processSecurityHeader(signedDoc,null,null,processCrypto);
  processCrypto=new Merlin();
  trustStore=KeyStore.getInstance(KeyStore.getDefaultType());
  input=Merlin.loadInputStream(loader,"keys/wss40badca.jks");
  trustStore.load(input,"security".toCharArray());
  ((Merlin)processCrypto).setTrustStore(trustStore);
  try {
    secEngine.processSecurityHeader(signedDoc,null,null,processCrypto);
    fail("Expected failure on a bad trust store");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.FAILURE);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.wss4j.dom.handler.CustomActionProcessorTest </h4><pre class="type-8 type-7 type-5 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test to see that a custom action can be configured via WSSecurityUtil.decodeAction.
 * A standard Timestamp action is also configured.
 */
@Test public void testDecodeCustomAction() throws Exception {
  final WSSConfig cfg=WSSConfig.getNewInstance();
  final int customAction=0xDEADF000;
  String actionString=WSHandlerConstants.TIMESTAMP + " " + Integer.valueOf(customAction).toString();
  try {
    WSSecurityUtil.decodeHandlerAction(actionString,cfg);
    fail("Failure expected on unknown action");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.FAILURE);
  }
  try {
    String badActionString=WSHandlerConstants.TIMESTAMP + " " + "NewCustomAction";
    WSSecurityUtil.decodeHandlerAction(badActionString,cfg);
    fail("Failure expected on unknown action");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.FAILURE);
  }
  cfg.setAction(customAction,CustomAction.class);
  List<HandlerAction> actionList=WSSecurityUtil.decodeHandlerAction(actionString,cfg);
  final RequestData reqData=new RequestData();
  reqData.setWssConfig(cfg);
  final Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  CustomHandler handler=new CustomHandler();
  reqData.setMsgContext("bread");
  assertEquals(reqData.getMsgContext(),"bread");
  handler.send(doc,reqData,actionList,true);
  assertEquals(reqData.getMsgContext(),"crumb");
  if (LOG.isDebugEnabled()) {
    LOG.debug("Message:");
    String outputString=XMLUtils.prettyDocumentToString(doc);
    LOG.debug(outputString);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.wss4j.dom.handler.SignatureConfirmationTest </h4><pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test to see that a signature confirmation response that does not contain a wsu:Id fails
 * the BSP compliance is enabled.
 */
@Test public void testWsuId() throws Exception {
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  byte[] randomBytes=WSSecurityUtil.generateNonce(20);
  SignatureConfirmation sigConf=new SignatureConfirmation(doc,randomBytes);
  Element sigConfElement=sigConf.getElement();
  secHeader.getSecurityHeader().appendChild(sigConfElement);
  if (LOG.isDebugEnabled()) {
    String outputString=XMLUtils.prettyDocumentToString(doc);
    LOG.debug(outputString);
  }
  WSSecurityEngine newEngine=new WSSecurityEngine();
  try {
    newEngine.processSecurityHeader(doc,null,callbackHandler,crypto);
    fail("Failure expected on a request with no wsu:Id");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.INVALID_SECURITY);
  }
  RequestData data=new RequestData();
  data.setCallbackHandler(callbackHandler);
  data.setSigVerCrypto(crypto);
  data.setIgnoredBSPRules(Collections.singletonList(BSPRule.R5441));
  newEngine.processSecurityHeader(doc,data);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.wss4j.dom.message.AttachmentTest </h4><pre class="type-8 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testInvalidXMLAttachmentContentSignature() throws Exception {
  WSSecSignature builder=new WSSecSignature();
  builder.setUserInfo("16c73ab6-b892-458f-abf5-2f875f74882e","security");
  builder.getParts().add(new WSEncryptionPart("Body","http://schemas.xmlsoap.org/soap/envelope/","Content"));
  builder.getParts().add(new WSEncryptionPart("cid:Attachments","Content"));
  final String attachmentId=UUID.randomUUID().toString();
  final Attachment attachment=new Attachment();
  attachment.setMimeType("text/xml");
  attachment.addHeaders(getHeaders(attachmentId));
  attachment.setId(attachmentId);
  attachment.setSourceStream(new ByteArrayInputStream(SOAPUtil.SAMPLE_SOAP_MSG.getBytes(StandardCharsets.UTF_8)));
  AttachmentCallbackHandler attachmentCallbackHandler=new AttachmentCallbackHandler(Collections.singletonList(attachment));
  builder.setAttachmentCallbackHandler(attachmentCallbackHandler);
  LOG.info("Before Signing....");
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  Document signedDoc=builder.build(doc,crypto,secHeader);
  if (LOG.isDebugEnabled()) {
    LOG.debug("After Signing....");
    String outputString=XMLUtils.prettyDocumentToString(signedDoc);
    LOG.debug(outputString);
  }
  try {
    verify(signedDoc,new CallbackHandler(){
      @Override public void handle(      Callback[] callbacks) throws IOException, UnsupportedCallbackException {
        if (callbacks[0] instanceof AttachmentRequestCallback) {
          AttachmentRequestCallback attachmentRequestCallback=(AttachmentRequestCallback)callbacks[0];
          if (!attachment.getId().equals(attachmentRequestCallback.getAttachmentId())) {
            throw new RuntimeException("wrong attachment requested");
          }
          List<Attachment> attachments=new ArrayList<>();
          attachment.setSourceStream(new ByteArrayInputStream(SOAPUtil.SAMPLE_SOAP_MSG.replace("15","16").getBytes(StandardCharsets.UTF_8)));
          attachments.add(attachment);
          attachmentRequestCallback.setAttachments(attachments);
        }
      }
    }
);
    Assert.fail();
  }
 catch (  WSSecurityException e) {
    Assert.assertEquals(e.getMessage(),"The signature or decryption was invalid");
  }
}

</code></pre>

<br>
<pre class="type-8 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testInvalidXMLAttachmentCmplSignCmplEnc() throws Exception {
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  WSSecSignature signature=new WSSecSignature();
  signature.setUserInfo("16c73ab6-b892-458f-abf5-2f875f74882e","security");
  signature.getParts().add(new WSEncryptionPart("Body","http://schemas.xmlsoap.org/soap/envelope/","Content"));
  signature.getParts().add(new WSEncryptionPart("cid:Attachments","Element"));
  String attachmentId=UUID.randomUUID().toString();
  final Attachment[] attachment=new Attachment[1];
  attachment[0]=new Attachment();
  attachment[0].setMimeType("text/xml");
  attachment[0].addHeaders(getHeaders(attachmentId));
  attachment[0].setId(attachmentId);
  attachment[0].setSourceStream(new ByteArrayInputStream(SOAPUtil.SAMPLE_SOAP_MSG.getBytes(StandardCharsets.UTF_8)));
  signature.setAttachmentCallbackHandler(new CallbackHandler(){
    @Override public void handle(    Callback[] callbacks) throws IOException, UnsupportedCallbackException {
      if (callbacks[0] instanceof AttachmentRequestCallback) {
        AttachmentRequestCallback attachmentRequestCallback=(AttachmentRequestCallback)callbacks[0];
        List<Attachment> attachments=new ArrayList<>();
        attachments.add(attachment[0]);
        attachmentRequestCallback.setAttachments(attachments);
      }
 else {
        AttachmentResultCallback attachmentResultCallback=(AttachmentResultCallback)callbacks[0];
        attachment[0]=attachmentResultCallback.getAttachment();
      }
    }
  }
);
  doc=signature.build(doc,crypto,secHeader);
  WSSecEncrypt encrypt=new WSSecEncrypt();
  encrypt.setUserInfo("16c73ab6-b892-458f-abf5-2f875f74882e","security");
  encrypt.setKeyIdentifierType(WSConstants.ISSUER_SERIAL);
  encrypt.getParts().addAll(signature.getParts());
  encrypt.setAttachmentCallbackHandler(new CallbackHandler(){
    @Override public void handle(    Callback[] callbacks) throws IOException, UnsupportedCallbackException {
      if (callbacks[0] instanceof AttachmentRequestCallback) {
        AttachmentRequestCallback attachmentRequestCallback=(AttachmentRequestCallback)callbacks[0];
        List<Attachment> attachments=new ArrayList<>();
        attachments.add(attachment[0]);
        attachmentRequestCallback.setAttachments(attachments);
      }
 else {
        AttachmentResultCallback attachmentResultCallback=(AttachmentResultCallback)callbacks[0];
        attachment[0]=attachmentResultCallback.getAttachment();
      }
    }
  }
);
  Document encryptedDoc=encrypt.build(doc,crypto,secHeader);
  if (LOG.isDebugEnabled()) {
    String outputString=XMLUtils.prettyDocumentToString(encryptedDoc);
    LOG.debug(outputString);
  }
  try {
    verify(encryptedDoc,new CallbackHandler(){
      @Override public void handle(      Callback[] callbacks) throws IOException, UnsupportedCallbackException {
        if (callbacks[0] instanceof AttachmentRequestCallback) {
          AttachmentRequestCallback attachmentRequestCallback=(AttachmentRequestCallback)callbacks[0];
          if (!attachment[0].getId().equals(attachmentRequestCallback.getAttachmentId())) {
            throw new RuntimeException("wrong attachment requested");
          }
          List<Attachment> attachments=new ArrayList<>();
          attachments.add(attachment[0]);
          if (attachment[0].getHeaders().size() == 6) {
            attachment[0].addHeader(AttachmentUtils.MIME_HEADER_CONTENT_DESCRIPTION,"Kaputt");
          }
          attachmentRequestCallback.setAttachments(attachments);
        }
 else {
          AttachmentResultCallback attachmentResultCallback=(AttachmentResultCallback)callbacks[0];
          attachment[0]=attachmentResultCallback.getAttachment();
        }
      }
    }
);
    Assert.fail();
  }
 catch (  WSSecurityException e) {
    Assert.assertEquals(e.getMessage(),"The signature or decryption was invalid");
  }
}

</code></pre>

<br>
<pre class="type-8 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testInvalidXMLAttachmentCmplEncCmplSign() throws Exception {
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  WSSecEncrypt encrypt=new WSSecEncrypt();
  encrypt.setUserInfo("16c73ab6-b892-458f-abf5-2f875f74882e","security");
  encrypt.setKeyIdentifierType(WSConstants.ISSUER_SERIAL);
  encrypt.getParts().add(new WSEncryptionPart("Body","http://schemas.xmlsoap.org/soap/envelope/","Content"));
  encrypt.getParts().add(new WSEncryptionPart("cid:Attachments","Element"));
  String attachmentId=UUID.randomUUID().toString();
  final Attachment[] attachment=new Attachment[1];
  attachment[0]=new Attachment();
  attachment[0].setMimeType("text/xml");
  attachment[0].addHeaders(getHeaders(attachmentId));
  attachment[0].setId(attachmentId);
  attachment[0].setSourceStream(new ByteArrayInputStream(SOAPUtil.SAMPLE_SOAP_MSG.getBytes(StandardCharsets.UTF_8)));
  encrypt.setAttachmentCallbackHandler(new CallbackHandler(){
    @Override public void handle(    Callback[] callbacks) throws IOException, UnsupportedCallbackException {
      if (callbacks[0] instanceof AttachmentRequestCallback) {
        AttachmentRequestCallback attachmentRequestCallback=(AttachmentRequestCallback)callbacks[0];
        List<Attachment> attachments=new ArrayList<>();
        attachments.add(attachment[0]);
        attachmentRequestCallback.setAttachments(attachments);
      }
 else {
        AttachmentResultCallback attachmentResultCallback=(AttachmentResultCallback)callbacks[0];
        attachment[0]=attachmentResultCallback.getAttachment();
      }
    }
  }
);
  doc=encrypt.build(doc,crypto,secHeader);
  WSSecSignature signature=new WSSecSignature();
  signature.setUserInfo("16c73ab6-b892-458f-abf5-2f875f74882e","security");
  signature.getParts().addAll(encrypt.getParts());
  signature.setAttachmentCallbackHandler(new CallbackHandler(){
    @Override public void handle(    Callback[] callbacks) throws IOException, UnsupportedCallbackException {
      if (callbacks[0] instanceof AttachmentRequestCallback) {
        AttachmentRequestCallback attachmentRequestCallback=(AttachmentRequestCallback)callbacks[0];
        List<Attachment> attachments=new ArrayList<>();
        attachments.add(attachment[0]);
        attachmentRequestCallback.setAttachments(attachments);
      }
 else {
        AttachmentResultCallback attachmentResultCallback=(AttachmentResultCallback)callbacks[0];
        attachment[0]=attachmentResultCallback.getAttachment();
      }
    }
  }
);
  doc=signature.build(doc,crypto,secHeader);
  if (LOG.isDebugEnabled()) {
    String outputString=XMLUtils.prettyDocumentToString(doc);
    LOG.debug(outputString);
  }
  final PushbackInputStream pis=new PushbackInputStream(attachment[0].getSourceStream(),1);
  pis.unread('K');
  attachment[0].setSourceStream(pis);
  try {
    verify(doc,new CallbackHandler(){
      @Override public void handle(      Callback[] callbacks) throws IOException, UnsupportedCallbackException {
        if (callbacks[0] instanceof AttachmentRequestCallback) {
          AttachmentRequestCallback attachmentRequestCallback=(AttachmentRequestCallback)callbacks[0];
          if (!attachment[0].getId().equals(attachmentRequestCallback.getAttachmentId())) {
            throw new RuntimeException("wrong attachment requested");
          }
          List<Attachment> attachmentList=new ArrayList<>();
          attachmentList.add(attachment[0]);
          attachmentRequestCallback.setAttachments(attachmentList);
        }
 else {
          AttachmentResultCallback attachmentResultCallback=(AttachmentResultCallback)callbacks[0];
          attachment[0]=attachmentResultCallback.getAttachment();
        }
      }
    }
);
    Assert.fail();
  }
 catch (  WSSecurityException e) {
    Assert.assertEquals(e.getMessage(),"The signature or decryption was invalid");
  }
}

</code></pre>

<br>
<pre class="type-8 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testInvalidXMLAttachmentCompleteSignature() throws Exception {
  WSSecSignature builder=new WSSecSignature();
  builder.setUserInfo("16c73ab6-b892-458f-abf5-2f875f74882e","security");
  builder.getParts().add(new WSEncryptionPart("Body","http://schemas.xmlsoap.org/soap/envelope/","Content"));
  builder.getParts().add(new WSEncryptionPart("cid:Attachments","Element"));
  final String attachmentId=UUID.randomUUID().toString();
  final Attachment attachment=new Attachment();
  attachment.setMimeType("text/xml");
  attachment.addHeaders(getHeaders(attachmentId));
  attachment.setId(attachmentId);
  attachment.setSourceStream(new ByteArrayInputStream(SOAPUtil.SAMPLE_SOAP_MSG.getBytes(StandardCharsets.UTF_8)));
  AttachmentCallbackHandler attachmentCallbackHandler=new AttachmentCallbackHandler(Collections.singletonList(attachment));
  builder.setAttachmentCallbackHandler(attachmentCallbackHandler);
  LOG.info("Before Signing....");
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  Document signedDoc=builder.build(doc,crypto,secHeader);
  if (LOG.isDebugEnabled()) {
    LOG.debug("After Signing....");
    String outputString=XMLUtils.prettyDocumentToString(signedDoc);
    LOG.debug(outputString);
  }
  try {
    attachment.addHeader(AttachmentUtils.MIME_HEADER_CONTENT_DESCRIPTION,"Kaputt");
    verify(signedDoc,new CallbackHandler(){
      @Override public void handle(      Callback[] callbacks) throws IOException, UnsupportedCallbackException {
        if (callbacks[0] instanceof AttachmentRequestCallback) {
          AttachmentRequestCallback attachmentRequestCallback=(AttachmentRequestCallback)callbacks[0];
          if (!attachment.getId().equals(attachmentRequestCallback.getAttachmentId())) {
            throw new RuntimeException("wrong attachment requested");
          }
          List<Attachment> attachments=new ArrayList<>();
          attachments.add(attachment);
          attachmentRequestCallback.setAttachments(attachments);
        }
      }
    }
);
    Assert.fail();
  }
 catch (  WSSecurityException e) {
    Assert.assertEquals(e.getMessage(),"The signature or decryption was invalid");
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.wss4j.dom.message.CertErrorTest </h4><pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test for when a bad certificate is used for Signature
 */
@Test public void testX509Signature() throws Exception {
  WSSecSignature builder=new WSSecSignature();
  builder.setUserInfo("bob","security");
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  try {
    builder.build(doc,CryptoFactory.getInstance(),secHeader);
    fail("Expected failure on a bad username");
  }
 catch (  WSSecurityException ex) {
    String expectedError="No certificates for user bob were found for signature";
    assertTrue(ex.getMessage().contains(expectedError));
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test for when a bad certificate is used for Encryption
 */
@Test public void testEncryption() throws Exception {
  WSSecEncrypt builder=new WSSecEncrypt();
  builder.setUserInfo("alice");
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  try {
    builder.build(doc,CryptoFactory.getInstance(),secHeader);
    fail("Expected failure on a bad username");
  }
 catch (  WSSecurityException ex) {
    String expectedError="No certificates for user alice were found for encryption";
    assertTrue(ex.getMessage().contains(expectedError));
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.wss4j.dom.message.EncryptionAlgorithmSuiteTest </h4><pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testEncryption() throws Exception {
  WSSecEncrypt builder=new WSSecEncrypt();
  builder.setUserInfo("wss40");
  builder.setKeyIdentifierType(WSConstants.BST_DIRECT_REFERENCE);
  builder.setSymmetricEncAlgorithm(WSConstants.TRIPLE_DES);
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  Document encryptedDoc=builder.build(doc,crypto,secHeader);
  if (LOG.isDebugEnabled()) {
    String outputString=XMLUtils.prettyDocumentToString(encryptedDoc);
    LOG.debug(outputString);
  }
  Element securityHeader=WSSecurityUtil.getSecurityHeader(encryptedDoc,null);
  AlgorithmSuite algorithmSuite=createAlgorithmSuite();
  verify(securityHeader,algorithmSuite,crypto);
  algorithmSuite.setMinimumAsymmetricKeyLength(1024);
  try {
    verify(securityHeader,algorithmSuite,crypto);
    fail("Expected failure as 512-bit keys are not allowed");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.INVALID_SECURITY);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testEncryptionKeyTransportRSA15NoAlgorithmSuite() throws Exception {
  Crypto wssCrypto=CryptoFactory.getInstance("wss40.properties");
  WSSecEncrypt builder=new WSSecEncrypt();
  builder.setUserInfo("wss40");
  builder.setKeyIdentifierType(WSConstants.BST_DIRECT_REFERENCE);
  builder.setSymmetricEncAlgorithm(WSConstants.TRIPLE_DES);
  builder.setKeyEncAlgo(WSConstants.KEYTRANSPORT_RSA15);
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  Document encryptedDoc=builder.build(doc,wssCrypto,secHeader);
  if (LOG.isDebugEnabled()) {
    String outputString=XMLUtils.prettyDocumentToString(encryptedDoc);
    LOG.debug(outputString);
  }
  Element securityHeader=WSSecurityUtil.getSecurityHeader(encryptedDoc,null);
  try {
    verify(securityHeader,null,wssCrypto);
    fail("Expected failure as RSA 15 is not allowed");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.INVALID_SECURITY);
  }
  WSSecurityEngine secEngine=new WSSecurityEngine();
  RequestData data=new RequestData();
  data.setDecCrypto(wssCrypto);
  data.setAllowRSA15KeyTransportAlgorithm(true);
  data.setCallbackHandler(new KeystoreCallbackHandler());
  secEngine.processSecurityHeader(securityHeader,data);
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testEncryptionMethodAES128() throws Exception {
  Crypto wssCrypto=CryptoFactory.getInstance("wss40.properties");
  WSSecEncrypt builder=new WSSecEncrypt();
  builder.setUserInfo("wss40");
  builder.setKeyIdentifierType(WSConstants.BST_DIRECT_REFERENCE);
  builder.setSymmetricEncAlgorithm(WSConstants.AES_128);
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  Document encryptedDoc=builder.build(doc,wssCrypto,secHeader);
  if (LOG.isDebugEnabled()) {
    String outputString=XMLUtils.prettyDocumentToString(encryptedDoc);
    LOG.debug(outputString);
  }
  Element securityHeader=WSSecurityUtil.getSecurityHeader(encryptedDoc,null);
  AlgorithmSuite algorithmSuite=createAlgorithmSuite();
  try {
    verify(securityHeader,algorithmSuite,wssCrypto);
    fail("Expected failure as AES 128 is not allowed");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.INVALID_SECURITY);
  }
  algorithmSuite.addEncryptionMethod(WSConstants.AES_128);
  verify(securityHeader,algorithmSuite,wssCrypto);
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testEncryptionKeyTransportRSA15() throws Exception {
  Crypto wssCrypto=CryptoFactory.getInstance("wss40.properties");
  WSSecEncrypt builder=new WSSecEncrypt();
  builder.setUserInfo("wss40");
  builder.setKeyIdentifierType(WSConstants.BST_DIRECT_REFERENCE);
  builder.setSymmetricEncAlgorithm(WSConstants.TRIPLE_DES);
  builder.setKeyEncAlgo(WSConstants.KEYTRANSPORT_RSA15);
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  Document encryptedDoc=builder.build(doc,wssCrypto,secHeader);
  if (LOG.isDebugEnabled()) {
    String outputString=XMLUtils.prettyDocumentToString(encryptedDoc);
    LOG.debug(outputString);
  }
  Element securityHeader=WSSecurityUtil.getSecurityHeader(encryptedDoc,null);
  AlgorithmSuite algorithmSuite=createAlgorithmSuite();
  try {
    verify(securityHeader,algorithmSuite,wssCrypto);
    fail("Expected failure as RSA 15 is not allowed");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.INVALID_SECURITY);
  }
  algorithmSuite.addKeyWrapAlgorithm(WSConstants.KEYTRANSPORT_RSA15);
  verify(securityHeader,algorithmSuite,wssCrypto);
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testSymmetricEncryption() throws Exception {
  KeyGenerator keyGen=KeyGenerator.getInstance("AES");
  keyGen.init(128);
  SecretKey key=keyGen.generateKey();
  byte[] keyData=key.getEncoded();
  WSSecEncrypt builder=new WSSecEncrypt();
  builder.setKeyIdentifierType(WSConstants.ENCRYPTED_KEY_SHA1_IDENTIFIER);
  builder.setSymmetricKey(key);
  builder.setEncryptSymmKey(false);
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  Document encryptedDoc=builder.build(doc,crypto,secHeader);
  if (LOG.isDebugEnabled()) {
    String outputString=XMLUtils.prettyDocumentToString(encryptedDoc);
    LOG.debug(outputString);
  }
  byte[] encodedBytes=KeyUtils.generateDigest(keyData);
  String identifier=Base64.encode(encodedBytes);
  SecretKeyCallbackHandler secretKeyCallbackHandler=new SecretKeyCallbackHandler();
  secretKeyCallbackHandler.addSecretKey(identifier,keyData);
  Element securityHeader=WSSecurityUtil.getSecurityHeader(encryptedDoc,null);
  AlgorithmSuite algorithmSuite=createAlgorithmSuite();
  WSSecurityEngine secEngine=new WSSecurityEngine();
  RequestData data=new RequestData();
  data.setDecCrypto(crypto);
  data.setCallbackHandler(secretKeyCallbackHandler);
  data.setAlgorithmSuite(algorithmSuite);
  algorithmSuite.addEncryptionMethod(WSConstants.AES_128);
  secEngine.processSecurityHeader(securityHeader,data);
  algorithmSuite.setMinimumSymmetricKeyLength(256);
  try {
    secEngine.processSecurityHeader(securityHeader,data);
    fail("Expected failure as a 128 bit key is not allowed");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.INVALID_SECURITY);
  }
  algorithmSuite.setMinimumSymmetricKeyLength(64);
  algorithmSuite.setMaximumSymmetricKeyLength(120);
  try {
    secEngine.processSecurityHeader(securityHeader,data);
    fail("Expected failure as a 128 bit key is not allowed");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.INVALID_SECURITY);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.wss4j.dom.message.EncryptionCRLTest </h4><pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test that encrypts with certificate revocation check
 * so it should fail
 * @throws java.lang.Exception Thrown when there is any problem in encryption or decryption
 * TODO Re-enable once CRL issue fixed
 */
@Test @org.junit.Ignore public void testEncryptionWithRevocationCheck() throws Exception {
  final WSSConfig cfg=WSSConfig.getNewInstance();
  final RequestData reqData=new RequestData();
  reqData.setWssConfig(cfg);
  EncryptionActionToken actionToken=new EncryptionActionToken();
  actionToken.setUser("wss40rev");
  actionToken.setKeyIdentifierId(WSConstants.BST_DIRECT_REFERENCE);
  actionToken.setSymmetricAlgorithm(WSConstants.TRIPLE_DES);
  actionToken.setCrypto(crypto);
  reqData.setEncryptionToken(actionToken);
  java.util.Map<String,Object> messageContext=new java.util.TreeMap<String,Object>();
  messageContext.put(WSHandlerConstants.PW_CALLBACK_REF,keystoreCallbackHandler);
  reqData.setMsgContext(messageContext);
  reqData.setUsername("wss40rev");
  final Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  CustomHandler handler=new CustomHandler();
  handler.setOption(WSHandlerConstants.ENABLE_REVOCATION,"true");
  try {
    handler.send(doc,reqData,Collections.singletonList(new HandlerAction(WSConstants.ENCR)),true);
    fail("Failure expected on a revoked certificate");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.FAILURE);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.wss4j.dom.message.EncryptionPartsTest </h4><pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testRequiredSOAPHeaderNotPresent() throws Exception {
  WSSecEncrypt encrypt=new WSSecEncrypt();
  encrypt.setUserInfo("16c73ab6-b892-458f-abf5-2f875f74882e","security");
  encrypt.setKeyIdentifierType(WSConstants.ISSUER_SERIAL);
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  WSEncryptionPart encP=new WSEncryptionPart("foobar","urn:foo.bar","");
  encrypt.getParts().add(encP);
  String soapNamespace=WSSecurityUtil.getSOAPNamespace(doc.getDocumentElement());
  encP=new WSEncryptionPart(WSConstants.ELEM_BODY,soapNamespace,"Content");
  encrypt.getParts().add(encP);
  try {
    encrypt.build(doc,crypto,secHeader);
    fail("Failure expected on not encrypting a required element");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.FAILURE);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test encrypting a custom SOAP header with a bad localname
 */
@Test public void testBadLocalname() throws Exception {
  WSSecEncrypt encrypt=new WSSecEncrypt();
  encrypt.setUserInfo("16c73ab6-b892-458f-abf5-2f875f74882e","security");
  encrypt.setKeyIdentifierType(WSConstants.ISSUER_SERIAL);
  Document doc=SOAPUtil.toSOAPPart(SOAPMSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  WSEncryptionPart encP=new WSEncryptionPart("foobar2","urn:foo.bar","");
  encrypt.getParts().add(encP);
  try {
    encrypt.build(doc,crypto,secHeader);
    fail("Failure expected on a bad localname");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.FAILURE);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test encrypting a custom SOAP header with a bad namespace
 */
@Test public void testBadNamespace() throws Exception {
  WSSecEncrypt encrypt=new WSSecEncrypt();
  encrypt.setUserInfo("16c73ab6-b892-458f-abf5-2f875f74882e","security");
  encrypt.setKeyIdentifierType(WSConstants.ISSUER_SERIAL);
  Document doc=SOAPUtil.toSOAPPart(SOAPMSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  WSEncryptionPart encP=new WSEncryptionPart("foobar","urn:foo.bar2","");
  encrypt.getParts().add(encP);
  try {
    encrypt.build(doc,crypto,secHeader);
    fail("Failure expected on a bad namespace");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.FAILURE);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.wss4j.dom.message.EncryptionTest </h4><pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testBadAttribute() throws Exception {
  WSSecEncrypt builder=new WSSecEncrypt();
  builder.setUserInfo("wss40");
  builder.setKeyIdentifierType(WSConstants.BST_DIRECT_REFERENCE);
  builder.setSymmetricEncAlgorithm(WSConstants.TRIPLE_DES);
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  builder.prepare(doc,crypto);
  SOAPConstants soapConstants=WSSecurityUtil.getSOAPConstants(doc.getDocumentElement());
  java.util.List<WSEncryptionPart> parts=new ArrayList<>();
  WSEncryptionPart encP=new WSEncryptionPart(soapConstants.getBodyQName().getLocalPart(),soapConstants.getEnvelopeURI(),"Content");
  parts.add(encP);
  Element refs=builder.encrypt();
  builder.addExternalRefElement(refs,secHeader);
  Element encryptedKeyElement=builder.getEncryptedKeyElement();
  encryptedKeyElement.setAttributeNS(null,"Type","SomeType");
  WSSecurityUtil.prependChildElement(secHeader.getSecurityHeader(),encryptedKeyElement);
  builder.prependBSTElementToHeader(secHeader);
  Document encryptedDoc=doc;
  String outputString=XMLUtils.prettyDocumentToString(encryptedDoc);
  if (LOG.isDebugEnabled()) {
    LOG.debug(outputString);
  }
  WSSecurityEngine newEngine=new WSSecurityEngine();
  try {
    newEngine.processSecurityHeader(encryptedDoc,null,keystoreCallbackHandler,crypto);
    fail("Failure expected on a bad attribute type");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.INVALID_SECURITY);
  }
  RequestData data=new RequestData();
  data.setCallbackHandler(keystoreCallbackHandler);
  data.setDecCrypto(crypto);
  data.setIgnoredBSPRules(Collections.singletonList(BSPRule.R3209));
  newEngine.processSecurityHeader(encryptedDoc,data);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.wss4j.dom.message.ModifiedRequestTest </h4><pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test for when a Signature is received with a certificate that is not trusted
 */
@Test public void testUntrustedSignature() throws Exception {
  WSSecSignature builder=new WSSecSignature();
  builder.setUserInfo("wss40","security");
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  Crypto wss40Crypto=CryptoFactory.getInstance("wss40.properties");
  Document signedDoc=builder.build(doc,wss40Crypto,secHeader);
  if (LOG.isDebugEnabled()) {
    String outputString=XMLUtils.prettyDocumentToString(signedDoc);
    LOG.debug(outputString);
  }
  try {
    verify(signedDoc);
    fail("Failure expected on an untrusted Certificate");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.FAILED_CHECK);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test a duplicated signed SAML Assertion.
 */
@Test public void testDuplicatedSignedSAMLAssertion() throws Exception {
  SAML1CallbackHandler callbackHandler=new SAML1CallbackHandler();
  callbackHandler.setStatement(SAML1CallbackHandler.Statement.AUTHN);
  callbackHandler.setConfirmationMethod(SAML1Constants.CONF_SENDER_VOUCHES);
  callbackHandler.setIssuer("www.example.com");
  SAMLCallback samlCallback=new SAMLCallback();
  SAMLUtil.doSAMLCallback(callbackHandler,samlCallback);
  SamlAssertionWrapper samlAssertion=new SamlAssertionWrapper(samlCallback);
  WSSecSignatureSAML wsSign=new WSSecSignatureSAML();
  wsSign.setKeyIdentifierType(WSConstants.BST_DIRECT_REFERENCE);
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  Document signedDoc=wsSign.build(doc,null,samlAssertion,crypto,"16c73ab6-b892-458f-abf5-2f875f74882e","security",secHeader);
  Element assertionElement=(Element)samlAssertion.getElement().cloneNode(true);
  assertionElement.removeChild(assertionElement.getFirstChild());
  secHeader.getSecurityHeader().appendChild(assertionElement);
  if (LOG.isDebugEnabled()) {
    LOG.debug("SAML 1.1 Authn Assertion (sender vouches):");
    String outputString=XMLUtils.prettyDocumentToString(signedDoc);
    LOG.debug(outputString);
  }
  try {
    verify(signedDoc);
    fail("Failure expected on duplicate tokens");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getMessage().contains("Multiple security tokens with the same Id have been detected"));
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test for when some EncryptedData CipherValue data is modified
 * (in the security header)
 */
@Test public void testModifiedSecurityHeaderEncryptedDataCipherValue() throws Exception {
  WSSecEncrypt builder=new WSSecEncrypt();
  builder.setUserInfo("wss40");
  builder.setKeyIdentifierType(WSConstants.BST_DIRECT_REFERENCE);
  builder.setSymmetricEncAlgorithm(WSConstants.TRIPLE_DES);
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  Crypto wssCrypto=CryptoFactory.getInstance("wss40.properties");
  WSSecTimestamp timestamp=new WSSecTimestamp();
  timestamp.setTimeToLive(300);
  timestamp.build(doc,secHeader);
  WSEncryptionPart encP=new WSEncryptionPart("Timestamp",WSConstants.WSU_NS,"");
  builder.getParts().add(encP);
  Document encryptedDoc=builder.build(doc,wssCrypto,secHeader);
  Element securityHeader=WSSecurityUtil.getSecurityHeader(encryptedDoc,"");
  Element encryptedTimestamp=XMLUtils.findElement(securityHeader,"EncryptedData",WSConstants.ENC_NS);
  Element cipherValue=XMLUtils.findElement(encryptedTimestamp,"CipherValue",WSConstants.ENC_NS);
  String cipherText=cipherValue.getTextContent();
  StringBuilder stringBuilder=new StringBuilder(cipherText);
  int index=stringBuilder.length() / 2;
  char ch=stringBuilder.charAt(index);
  if (ch != 'A') {
    ch='A';
  }
 else {
    ch='B';
  }
  stringBuilder.setCharAt(index,ch);
  cipherValue.setTextContent(stringBuilder.toString());
  String outputString=XMLUtils.prettyDocumentToString(encryptedDoc);
  if (LOG.isDebugEnabled()) {
    LOG.debug(outputString);
  }
  WSSecurityEngine newEngine=new WSSecurityEngine();
  try {
    newEngine.processSecurityHeader(doc,null,new KeystoreCallbackHandler(),wssCrypto);
    fail("Failure expected on a modified EncryptedData CipherValue");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.FAILED_CHECK);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test for when an element that a Signature Reference points to is modified
 */
@Test public void testModifiedSignatureReference() throws Exception {
  WSSecSignature builder=new WSSecSignature();
  builder.setUserInfo("16c73ab6-b892-458f-abf5-2f875f74882e","security");
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  WSSecTimestamp timestamp=new WSSecTimestamp();
  timestamp.setTimeToLive(300);
  Document createdDoc=timestamp.build(doc,secHeader);
  WSEncryptionPart encP=new WSEncryptionPart("Timestamp",WSConstants.WSU_NS,"");
  builder.getParts().add(encP);
  Document signedDoc=builder.build(createdDoc,crypto,secHeader);
  Element timestampElement=timestamp.getElement();
  Element createdValue=XMLUtils.findElement(timestampElement,"Created",WSConstants.WSU_NS);
  DateFormat zulu=new XmlSchemaDateFormat();
  XMLGregorianCalendar createdCalendar=WSSConfig.DATATYPE_FACTORY.newXMLGregorianCalendar(createdValue.getTextContent());
  Duration duration=WSSConfig.DATATYPE_FACTORY.newDuration(5000L);
  createdCalendar.add(duration);
  Date createdDate=createdCalendar.toGregorianCalendar().getTime();
  createdValue.setTextContent(zulu.format(createdDate));
  if (LOG.isDebugEnabled()) {
    String outputString=XMLUtils.prettyDocumentToString(signedDoc);
    LOG.debug(outputString);
  }
  try {
    verify(signedDoc);
    fail("Failure expected on a modified Signature Reference");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.FAILED_CHECK);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test that signs a SOAP body element "value". The SOAP request is then modified
 * so that the signed "value" element is put in the header, and the value of the
 * original element is changed. The wsu:Id value of the original element is also
 * changed. Signature verification will pass, so we need to check the Elements.
 */
@Test public void testMovedElementChangedId() throws Exception {
  WSSecSignature builder=new WSSecSignature();
  builder.setUserInfo("16c73ab6-b892-458f-abf5-2f875f74882e","security");
  LOG.info("Before Signing....");
  Document doc=SOAPUtil.toSOAPPart(SOAPMSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  WSEncryptionPart encP=new WSEncryptionPart("value","http://blah.com","");
  builder.getParts().add(encP);
  Document signedDoc=builder.build(doc,crypto,secHeader);
  Element secHeaderElement=secHeader.getSecurityHeader();
  Element envelopeElement=signedDoc.getDocumentElement();
  Node valueNode=envelopeElement.getElementsByTagNameNS("http://blah.com","value").item(0);
  Node clonedValueNode=valueNode.cloneNode(true);
  secHeaderElement.appendChild(clonedValueNode);
  valueNode.getFirstChild().setNodeValue("250");
  ((Element)valueNode).setAttributeNS(WSConstants.WSU_NS,"wsu:Id","id-250");
  if (LOG.isDebugEnabled()) {
    LOG.debug("After Signing....");
    String outputString=XMLUtils.prettyDocumentToString(signedDoc);
    LOG.debug(outputString);
  }
  WSHandlerResult results=verify(signedDoc);
  envelopeElement=signedDoc.getDocumentElement();
  Node bodyNode=envelopeElement.getElementsByTagNameNS(WSConstants.URI_SOAP11_ENV,"Body").item(0);
  valueNode=((Element)bodyNode).getElementsByTagNameNS("http://blah.com","value").item(0);
  List<WSSecurityEngineResult> signedResults=results.getActionResults().get(WSConstants.SIGN);
  try {
    SignatureUtils.verifySignedElement((Element)valueNode,signedResults);
    fail("Failure expected on the required element not being signed");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.FAILED_CHECK);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test for when the Signature element is modified
 */
@Test public void testModifiedSignature() throws Exception {
  WSSecSignature builder=new WSSecSignature();
  builder.setUserInfo("16c73ab6-b892-458f-abf5-2f875f74882e","security");
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  Document signedDoc=builder.build(doc,crypto,secHeader);
  Element signatureElement=builder.getSignatureElement();
  Node firstChild=signatureElement.getFirstChild();
  while (!(firstChild instanceof Element) && firstChild != null) {
    firstChild=signatureElement.getNextSibling();
  }
  ((Element)firstChild).setAttributeNS(null,"Id","xyz");
  if (LOG.isDebugEnabled()) {
    String outputString=XMLUtils.prettyDocumentToString(signedDoc);
    LOG.debug(outputString);
  }
  try {
    verify(signedDoc);
    fail("Failure expected on a modified Signature element");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.FAILED_CHECK);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test a duplicated signed UsernameToken
 */
@Test public void testDuplicatedSignedUsernameToken() throws Exception {
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  WSSecUsernameToken usernameToken=new WSSecUsernameToken();
  usernameToken.setUserInfo("wss86","security");
  Document createdDoc=usernameToken.build(doc,secHeader);
  WSSecSignature builder=new WSSecSignature();
  builder.setUserInfo("16c73ab6-b892-458f-abf5-2f875f74882e","security");
  WSEncryptionPart encP=new WSEncryptionPart("UsernameToken",WSConstants.WSSE_NS,"");
  builder.getParts().add(encP);
  builder.prepare(createdDoc,crypto,secHeader);
  List<javax.xml.crypto.dsig.Reference> referenceList=builder.addReferencesToSign(builder.getParts(),secHeader);
  builder.computeSignature(referenceList,false,null);
  secHeader.getSecurityHeader().appendChild(usernameToken.getUsernameTokenElement().cloneNode(true));
  if (LOG.isDebugEnabled()) {
    LOG.debug("Signed Timestamp");
    String outputString=XMLUtils.prettyDocumentToString(doc);
    LOG.debug(outputString);
  }
  try {
    verify(doc);
    fail("Failure expected on duplicate tokens");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getMessage().contains("Multiple security tokens with the same Id have been detected"));
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-5 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test that signs a SOAP body element "value". The SOAP request is then modified
 * so that the signed "value" element is put in the header, and the value of the
 * original element is changed. This test will fail as the request will contain
 * multiple elements with the same wsu:Id.
 */
@Test public void testMovedElement() throws Exception {
  WSSecSignature builder=new WSSecSignature();
  builder.setUserInfo("16c73ab6-b892-458f-abf5-2f875f74882e","security");
  LOG.info("Before Signing....");
  Document doc=SOAPUtil.toSOAPPart(SOAPMSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  WSEncryptionPart encP=new WSEncryptionPart("value","http://blah.com","");
  builder.getParts().add(encP);
  Document signedDoc=builder.build(doc,crypto,secHeader);
  Element secHeaderElement=secHeader.getSecurityHeader();
  Element envelopeElement=signedDoc.getDocumentElement();
  Node valueNode=envelopeElement.getElementsByTagNameNS("http://blah.com","value").item(0);
  Node clonedValueNode=valueNode.cloneNode(true);
  secHeaderElement.appendChild(clonedValueNode);
  valueNode.getFirstChild().setNodeValue("250");
  if (LOG.isDebugEnabled()) {
    LOG.debug("After Signing....");
    String outputString=XMLUtils.prettyDocumentToString(signedDoc);
    LOG.debug(outputString);
  }
  try {
    verify(signedDoc);
    fail("Failure expected on multiple elements with the same wsu:Id");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.FAILED_CHECK);
    assertTrue(ex.getMessage().startsWith("javax.xml.crypto.URIReferenceException: " + "org.apache.xml.security.utils.resolver.ResourceResolverException: "));
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test for when an EncryptedData structure is modified
 */
@Test public void testModifiedEncryptedDataStructure() throws Exception {
  WSSecEncrypt builder=new WSSecEncrypt();
  builder.setUserInfo("wss40");
  builder.setKeyIdentifierType(WSConstants.BST_DIRECT_REFERENCE);
  builder.setSymmetricEncAlgorithm(WSConstants.TRIPLE_DES);
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  Crypto wssCrypto=CryptoFactory.getInstance("wss40.properties");
  Document encryptedDoc=builder.build(doc,wssCrypto,secHeader);
  Element body=WSSecurityUtil.findBodyElement(doc);
  Element encryptionMethod=XMLUtils.findElement(body,"EncryptionMethod",WSConstants.ENC_NS);
  encryptionMethod.setAttributeNS(null,"Algorithm","http://new-algorithm");
  String outputString=XMLUtils.prettyDocumentToString(encryptedDoc);
  if (LOG.isDebugEnabled()) {
    LOG.debug(outputString);
  }
  WSSecurityEngine newEngine=new WSSecurityEngine();
  try {
    newEngine.processSecurityHeader(doc,null,new KeystoreCallbackHandler(),wssCrypto);
    fail("Failure expected on a modified EncryptedData structure");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.INVALID_SECURITY);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test for when some EncryptedData CipherValue data is modified.
 */
@Test public void testModifiedEncryptedDataCipherValue() throws Exception {
  WSSecEncrypt builder=new WSSecEncrypt();
  builder.setUserInfo("wss40");
  builder.setKeyIdentifierType(WSConstants.BST_DIRECT_REFERENCE);
  builder.setSymmetricEncAlgorithm(WSConstants.TRIPLE_DES);
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  Crypto wssCrypto=CryptoFactory.getInstance("wss40.properties");
  Document encryptedDoc=builder.build(doc,wssCrypto,secHeader);
  Element body=WSSecurityUtil.findBodyElement(doc);
  Element cipherValue=XMLUtils.findElement(body,"CipherValue",WSConstants.ENC_NS);
  String cipherText=cipherValue.getTextContent();
  StringBuilder stringBuilder=new StringBuilder(cipherText);
  int index=stringBuilder.length() / 2;
  char ch=stringBuilder.charAt(index);
  if (ch != 'A') {
    ch='A';
  }
 else {
    ch='B';
  }
  stringBuilder.setCharAt(index,ch);
  cipherValue.setTextContent(stringBuilder.toString());
  String outputString=XMLUtils.prettyDocumentToString(encryptedDoc);
  if (LOG.isDebugEnabled()) {
    LOG.debug(outputString);
  }
  WSSecurityEngine newEngine=new WSSecurityEngine();
  try {
    newEngine.processSecurityHeader(doc,null,new KeystoreCallbackHandler(),wssCrypto);
    fail("Failure expected on a modified EncryptedData CipherValue");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.FAILED_CHECK);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test for when some EncryptedKey CipherValue data is modified.
 */
@Test public void testModifiedEncryptedKeyCipherValue() throws Exception {
  WSSecEncrypt builder=new WSSecEncrypt();
  builder.setUserInfo("wss40");
  builder.setKeyIdentifierType(WSConstants.BST_DIRECT_REFERENCE);
  builder.setSymmetricEncAlgorithm(WSConstants.TRIPLE_DES);
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  Crypto wssCrypto=CryptoFactory.getInstance("wss40.properties");
  Document encryptedDoc=builder.build(doc,wssCrypto,secHeader);
  Element encryptedKey=XMLUtils.findElement(doc.getDocumentElement(),"EncryptedKey",WSConstants.ENC_NS);
  Element cipherValue=XMLUtils.findElement(encryptedKey,"CipherValue",WSConstants.ENC_NS);
  String cipherText=cipherValue.getTextContent();
  StringBuilder stringBuilder=new StringBuilder(cipherText);
  int index=stringBuilder.length() / 2;
  char ch=stringBuilder.charAt(index);
  if (ch != 'A') {
    ch='A';
  }
 else {
    ch='B';
  }
  stringBuilder.setCharAt(index,ch);
  cipherValue.setTextContent(stringBuilder.toString());
  String outputString=XMLUtils.prettyDocumentToString(encryptedDoc);
  if (LOG.isDebugEnabled()) {
    LOG.debug(outputString);
  }
  WSSecurityEngine newEngine=new WSSecurityEngine();
  try {
    newEngine.processSecurityHeader(doc,null,new KeystoreCallbackHandler(),wssCrypto);
    fail("Failure expected on a modified EncryptedData CipherValue");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.FAILED_CHECK);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.wss4j.dom.message.PasswordTypeTest </h4><pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test that adds a UserNameToken with password Digest to a WS-Security envelope
 */
@Test public void testPasswordDigest() throws Exception {
  WSSecUsernameToken builder=new WSSecUsernameToken();
  builder.setUserInfo("wernerd","verySecret");
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  Document signedDoc=builder.build(doc,secHeader);
  if (LOG.isDebugEnabled()) {
    LOG.debug("Message with UserNameToken PW Digest:");
    String outputString=XMLUtils.prettyDocumentToString(signedDoc);
    LOG.debug(outputString);
  }
  WSSecurityEngine secEngine=new WSSecurityEngine();
  RequestData requestData=new RequestData();
  requestData.setCallbackHandler(callbackHandler);
  requestData.setRequiredPasswordType(WSConstants.PASSWORD_DIGEST);
  secEngine.processSecurityHeader(doc,requestData);
  requestData=new RequestData();
  requestData.setCallbackHandler(callbackHandler);
  requestData.setRequiredPasswordType(null);
  secEngine.processSecurityHeader(doc,requestData);
  try {
    requestData=new RequestData();
    requestData.setCallbackHandler(callbackHandler);
    requestData.setRequiredPasswordType(WSConstants.PASSWORD_TEXT);
    secEngine.processSecurityHeader(doc,requestData);
    fail("Expected failure on the wrong password type");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.FAILED_AUTHENTICATION);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test that adds a UserNameToken with password text to a WS-Security envelope
 */
@Test public void testUsernameTokenText() throws Exception {
  WSSecUsernameToken builder=new WSSecUsernameToken();
  builder.setPasswordType(WSConstants.PASSWORD_TEXT);
  builder.setUserInfo("wernerd","verySecret");
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  Document signedDoc=builder.build(doc,secHeader);
  if (LOG.isDebugEnabled()) {
    LOG.debug("Message with UserNameToken PW Text:");
    String outputString=XMLUtils.prettyDocumentToString(signedDoc);
    LOG.debug(outputString);
  }
  WSSecurityEngine secEngine=new WSSecurityEngine();
  RequestData requestData=new RequestData();
  requestData.setCallbackHandler(callbackHandler);
  requestData.setRequiredPasswordType(WSConstants.PASSWORD_TEXT);
  secEngine.processSecurityHeader(doc,requestData);
  requestData=new RequestData();
  requestData.setCallbackHandler(callbackHandler);
  requestData.setRequiredPasswordType(null);
  secEngine.processSecurityHeader(doc,requestData);
  try {
    requestData=new RequestData();
    requestData.setCallbackHandler(callbackHandler);
    requestData.setRequiredPasswordType(WSConstants.PASSWORD_DIGEST);
    secEngine.processSecurityHeader(doc,requestData);
    fail("Expected failure on the wrong password type");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.FAILED_AUTHENTICATION);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test that adds a UserNameToken via WSHandler
 */
@Test public void testUsernameTokenWSHandler() throws Exception {
  CustomHandler handler=new CustomHandler();
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  RequestData reqData=new RequestData();
  java.util.Map<String,Object> config=new java.util.TreeMap<String,Object>();
  config.put("password","verySecret");
  config.put(WSHandlerConstants.PASSWORD_TYPE,WSConstants.PW_TEXT);
  reqData.setUsername("wernerd");
  reqData.setMsgContext(config);
  HandlerAction action=new HandlerAction(WSConstants.UT);
  handler.send(doc,reqData,Collections.singletonList(action),true);
  if (LOG.isDebugEnabled()) {
    LOG.debug("Username Token via WSHandler");
    String outputString=XMLUtils.prettyDocumentToString(doc);
    LOG.debug(outputString);
  }
  config.put(WSHandlerConstants.PASSWORD_TYPE,WSConstants.PW_DIGEST);
  reqData.setMsgContext(config);
  handler.receive(Collections.singletonList(WSConstants.UT),reqData);
  WSSecurityEngine secEngine=new WSSecurityEngine();
  reqData.setCallbackHandler(callbackHandler);
  try {
    secEngine.processSecurityHeader(doc,reqData);
    fail("Expected failure on the wrong password type");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.FAILED_AUTHENTICATION);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.wss4j.dom.message.ReplayTest </h4><pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testReplayedTimestampNoExpires() throws Exception {
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  WSSecTimestamp timestamp=new WSSecTimestamp();
  timestamp.setTimeToLive(0);
  Document createdDoc=timestamp.build(doc,secHeader);
  WSSecSignature builder=new WSSecSignature();
  builder.setUserInfo("16c73ab6-b892-458f-abf5-2f875f74882e","security");
  builder.setKeyIdentifierType(WSConstants.ISSUER_SERIAL);
  WSEncryptionPart encP=new WSEncryptionPart("Timestamp",WSConstants.WSU_NS,"");
  builder.getParts().add(encP);
  builder.prepare(createdDoc,crypto,secHeader);
  List<javax.xml.crypto.dsig.Reference> referenceList=builder.addReferencesToSign(builder.getParts(),secHeader);
  builder.computeSignature(referenceList,false,null);
  if (LOG.isDebugEnabled()) {
    String outputString=XMLUtils.prettyDocumentToString(createdDoc);
    LOG.debug(outputString);
  }
  WSSConfig wssConfig=WSSConfig.getNewInstance();
  RequestData data=new RequestData();
  data.setWssConfig(wssConfig);
  data.setCallbackHandler(callbackHandler);
  data.setTimestampReplayCache(new MemoryReplayCache());
  verify(createdDoc,wssConfig,data);
  try {
    verify(createdDoc,wssConfig,data);
    fail("Expected failure on a replay attack");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.INVALID_SECURITY);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testReplayedUsernameToken() throws Exception {
  WSSecUsernameToken builder=new WSSecUsernameToken();
  builder.setUserInfo("wernerd","verySecret");
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  Document signedDoc=builder.build(doc,secHeader);
  if (LOG.isDebugEnabled()) {
    String outputString=XMLUtils.prettyDocumentToString(signedDoc);
    LOG.debug(outputString);
  }
  WSSConfig wssConfig=WSSConfig.getNewInstance();
  RequestData data=new RequestData();
  data.setCallbackHandler(new UsernamePasswordCallbackHandler());
  data.setWssConfig(wssConfig);
  data.setNonceReplayCache(new MemoryReplayCache());
  verify(signedDoc,wssConfig,data);
  try {
    verify(signedDoc,wssConfig,data);
    fail("Expected failure on a replay attack");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.INVALID_SECURITY);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testEhCacheReplayedTimestampBelowSignature() throws Exception {
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  WSSecTimestamp timestamp=new WSSecTimestamp();
  timestamp.setTimeToLive(300);
  Document createdDoc=timestamp.build(doc,secHeader);
  WSSecSignature builder=new WSSecSignature();
  builder.setUserInfo("16c73ab6-b892-458f-abf5-2f875f74882e","security");
  builder.setKeyIdentifierType(WSConstants.ISSUER_SERIAL);
  WSEncryptionPart encP=new WSEncryptionPart("Timestamp",WSConstants.WSU_NS,"");
  builder.getParts().add(encP);
  builder.build(createdDoc,crypto,secHeader);
  if (LOG.isDebugEnabled()) {
    String outputString=XMLUtils.prettyDocumentToString(createdDoc);
    LOG.debug(outputString);
  }
  WSSConfig wssConfig=WSSConfig.getNewInstance();
  RequestData data=new RequestData();
  data.setWssConfig(wssConfig);
  data.setCallbackHandler(callbackHandler);
  verify(createdDoc,wssConfig,data);
  try {
    verify(createdDoc,wssConfig,data);
    fail("Expected failure on a replay attack");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.INVALID_SECURITY);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testEhCacheReplayedUsernameToken() throws Exception {
  WSSecUsernameToken builder=new WSSecUsernameToken();
  builder.setUserInfo("wernerd","verySecret");
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  Document signedDoc=builder.build(doc,secHeader);
  if (LOG.isDebugEnabled()) {
    String outputString=XMLUtils.prettyDocumentToString(signedDoc);
    LOG.debug(outputString);
  }
  WSSConfig wssConfig=WSSConfig.getNewInstance();
  RequestData data=new RequestData();
  data.setCallbackHandler(new UsernamePasswordCallbackHandler());
  data.setWssConfig(wssConfig);
  verify(signedDoc,wssConfig,data);
  try {
    verify(signedDoc,wssConfig,data);
    fail("Expected failure on a replay attack");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.INVALID_SECURITY);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testEhCacheReplayedTimestampNoExpires() throws Exception {
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  WSSecTimestamp timestamp=new WSSecTimestamp();
  timestamp.setTimeToLive(0);
  Document createdDoc=timestamp.build(doc,secHeader);
  WSSecSignature builder=new WSSecSignature();
  builder.setUserInfo("16c73ab6-b892-458f-abf5-2f875f74882e","security");
  builder.setKeyIdentifierType(WSConstants.ISSUER_SERIAL);
  WSEncryptionPart encP=new WSEncryptionPart("Timestamp",WSConstants.WSU_NS,"");
  builder.getParts().add(encP);
  builder.prepare(createdDoc,crypto,secHeader);
  List<javax.xml.crypto.dsig.Reference> referenceList=builder.addReferencesToSign(builder.getParts(),secHeader);
  builder.computeSignature(referenceList,false,null);
  if (LOG.isDebugEnabled()) {
    String outputString=XMLUtils.prettyDocumentToString(createdDoc);
    LOG.debug(outputString);
  }
  WSSConfig wssConfig=WSSConfig.getNewInstance();
  RequestData data=new RequestData();
  data.setWssConfig(wssConfig);
  data.setCallbackHandler(callbackHandler);
  verify(createdDoc,wssConfig,data);
  try {
    verify(createdDoc,wssConfig,data);
    fail("Expected failure on a replay attack");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.INVALID_SECURITY);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testReplayedTimestamp() throws Exception {
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  WSSecTimestamp timestamp=new WSSecTimestamp();
  timestamp.setTimeToLive(300);
  Document createdDoc=timestamp.build(doc,secHeader);
  WSSecSignature builder=new WSSecSignature();
  builder.setUserInfo("16c73ab6-b892-458f-abf5-2f875f74882e","security");
  builder.setKeyIdentifierType(WSConstants.ISSUER_SERIAL);
  WSEncryptionPart encP=new WSEncryptionPart("Timestamp",WSConstants.WSU_NS,"");
  builder.getParts().add(encP);
  builder.prepare(createdDoc,crypto,secHeader);
  List<javax.xml.crypto.dsig.Reference> referenceList=builder.addReferencesToSign(builder.getParts(),secHeader);
  builder.computeSignature(referenceList,false,null);
  if (LOG.isDebugEnabled()) {
    String outputString=XMLUtils.prettyDocumentToString(createdDoc);
    LOG.debug(outputString);
  }
  WSSConfig wssConfig=WSSConfig.getNewInstance();
  RequestData data=new RequestData();
  data.setWssConfig(wssConfig);
  data.setCallbackHandler(callbackHandler);
  data.setTimestampReplayCache(new MemoryReplayCache());
  verify(createdDoc,wssConfig,data);
  try {
    verify(createdDoc,wssConfig,data);
    fail("Expected failure on a replay attack");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.INVALID_SECURITY);
  }
}

</code></pre>

<br>
<pre class="type-3 type-8 type-7 type-5 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test that creates, sends and processes an unsigned SAML 2 authentication assertion
 * with a OneTimeUse Element
 */
@Test public void testEhCacheReplayedSAML2OneTimeUse() throws Exception {
  SAML2CallbackHandler callbackHandler=new SAML2CallbackHandler();
  callbackHandler.setStatement(SAML2CallbackHandler.Statement.AUTHN);
  callbackHandler.setIssuer("www.example.com");
  callbackHandler.setConfirmationMethod(SAML2Constants.CONF_BEARER);
  ConditionsBean conditions=new ConditionsBean();
  conditions.setTokenPeriodMinutes(5);
  conditions.setOneTimeUse(true);
  callbackHandler.setConditions(conditions);
  SAMLCallback samlCallback=new SAMLCallback();
  SAMLUtil.doSAMLCallback(callbackHandler,samlCallback);
  SamlAssertionWrapper samlAssertion=new SamlAssertionWrapper(samlCallback);
  WSSecSAMLToken wsSign=new WSSecSAMLToken();
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  Document unsignedDoc=wsSign.build(doc,samlAssertion,secHeader);
  String outputString=XMLUtils.prettyDocumentToString(unsignedDoc);
  assertTrue(outputString.contains("OneTimeUse"));
  if (LOG.isDebugEnabled()) {
    LOG.debug(outputString);
  }
  WSSConfig wssConfig=WSSConfig.getNewInstance();
  SamlAssertionValidator assertionValidator=new SamlAssertionValidator();
  assertionValidator.setRequireBearerSignature(false);
  wssConfig.setValidator(WSConstants.SAML_TOKEN,assertionValidator);
  wssConfig.setValidator(WSConstants.SAML2_TOKEN,assertionValidator);
  RequestData data=new RequestData();
  data.setWssConfig(wssConfig);
  data.setCallbackHandler(callbackHandler);
  verify(unsignedDoc,wssConfig,data);
  try {
    verify(unsignedDoc,wssConfig,data);
    fail("Expected failure on a replay attack");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.INVALID_SECURITY);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testReplayedTimestampBelowSignature() throws Exception {
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  WSSecTimestamp timestamp=new WSSecTimestamp();
  timestamp.setTimeToLive(300);
  Document createdDoc=timestamp.build(doc,secHeader);
  WSSecSignature builder=new WSSecSignature();
  builder.setUserInfo("16c73ab6-b892-458f-abf5-2f875f74882e","security");
  builder.setKeyIdentifierType(WSConstants.ISSUER_SERIAL);
  WSEncryptionPart encP=new WSEncryptionPart("Timestamp",WSConstants.WSU_NS,"");
  builder.getParts().add(encP);
  builder.build(createdDoc,crypto,secHeader);
  if (LOG.isDebugEnabled()) {
    String outputString=XMLUtils.prettyDocumentToString(createdDoc);
    LOG.debug(outputString);
  }
  WSSConfig wssConfig=WSSConfig.getNewInstance();
  RequestData data=new RequestData();
  data.setWssConfig(wssConfig);
  data.setCallbackHandler(callbackHandler);
  data.setTimestampReplayCache(new MemoryReplayCache());
  verify(createdDoc,wssConfig,data);
  try {
    verify(createdDoc,wssConfig,data);
    fail("Expected failure on a replay attack");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.INVALID_SECURITY);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testEhCacheReplayedTimestamp() throws Exception {
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  WSSecTimestamp timestamp=new WSSecTimestamp();
  timestamp.setTimeToLive(300);
  Document createdDoc=timestamp.build(doc,secHeader);
  WSSecSignature builder=new WSSecSignature();
  builder.setUserInfo("16c73ab6-b892-458f-abf5-2f875f74882e","security");
  builder.setKeyIdentifierType(WSConstants.ISSUER_SERIAL);
  WSEncryptionPart encP=new WSEncryptionPart("Timestamp",WSConstants.WSU_NS,"");
  builder.getParts().add(encP);
  builder.prepare(createdDoc,crypto,secHeader);
  List<javax.xml.crypto.dsig.Reference> referenceList=builder.addReferencesToSign(builder.getParts(),secHeader);
  builder.computeSignature(referenceList,false,null);
  if (LOG.isDebugEnabled()) {
    String outputString=XMLUtils.prettyDocumentToString(createdDoc);
    LOG.debug(outputString);
  }
  WSSConfig wssConfig=WSSConfig.getNewInstance();
  RequestData data=new RequestData();
  data.setWssConfig(wssConfig);
  data.setCallbackHandler(callbackHandler);
  verify(createdDoc,wssConfig,data);
  try {
    verify(createdDoc,wssConfig,data);
    fail("Expected failure on a replay attack");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.INVALID_SECURITY);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.wss4j.dom.message.RequireSignedEncryptedDataElementsTest </h4><pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testReferenceListAndDuplicatedEncDataInWsseHeader() throws Exception {
  Document encryptedSignedDoc=getRequestDocument();
  RequestData reqData=getRequestData(true);
  verify(encryptedSignedDoc,reqData);
  encryptedSignedDoc=getRequestDocument();
  reqData=getRequestData(false);
  TestMessageTransformer.duplicateEncryptedDataInWsseHeader(encryptedSignedDoc.getDocumentElement(),true);
  verify(encryptedSignedDoc,reqData);
  encryptedSignedDoc=getRequestDocument();
  reqData=getRequestData(true);
  Element newEncData=TestMessageTransformer.duplicateEncryptedDataInWsseHeader(encryptedSignedDoc.getDocumentElement(),true);
  try {
    verify(encryptedSignedDoc,reqData);
    fail("WSSecurityException expected");
  }
 catch (  WSSecurityException e) {
    checkFailure(newEncData,e);
  }
}

</code></pre>

<br>
<pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testAdditionalEncryptedDataWithEmbeddedEncryptedKeyInWsseHeader() throws Exception {
  Document encryptedSignedDoc=getRequestDocument();
  RequestData reqData=getRequestData(true);
  verify(encryptedSignedDoc,reqData);
  encryptedSignedDoc=getRequestDocument();
  reqData=getRequestData(true);
  Element newEncData=TestMessageTransformer.addEncryptedDataWithEmbeddedEncryptedKeyInWsseHeader(encryptedSignedDoc.getDocumentElement());
  try {
    verify(encryptedSignedDoc,reqData);
    fail("WSSecurityException expected");
  }
 catch (  WSSecurityException e) {
    checkFailure(newEncData,e);
  }
}

</code></pre>

<br>
<pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testEncryptedKeyRefAndDuplicatedEncDataInExternalWrapperElement() throws Exception {
  Document encryptedSignedDoc=getRequestDocument();
  RequestData reqData=getRequestData(true);
  verify(encryptedSignedDoc,reqData);
  encryptedSignedDoc=getRequestDocument();
  reqData=getRequestData(false);
  TestMessageTransformer.duplicateEncryptedDataInExternalWrapperElement(encryptedSignedDoc.getDocumentElement(),false);
  verify(encryptedSignedDoc,reqData);
  encryptedSignedDoc=getRequestDocument();
  reqData=getRequestData(true);
  Element newEncData=TestMessageTransformer.duplicateEncryptedDataInExternalWrapperElement(encryptedSignedDoc.getDocumentElement(),false);
  try {
    verify(encryptedSignedDoc,reqData);
    fail("WSSecurityException expected");
  }
 catch (  WSSecurityException e) {
    checkFailure(newEncData,e);
  }
}

</code></pre>

<br>
<pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testReferenceListAndDuplicatedEncDataInExternalWrapperElement() throws Exception {
  Document encryptedSignedDoc=getRequestDocument();
  RequestData reqData=getRequestData(true);
  verify(encryptedSignedDoc,reqData);
  encryptedSignedDoc=getRequestDocument();
  reqData=getRequestData(false);
  TestMessageTransformer.duplicateEncryptedDataInExternalWrapperElement(encryptedSignedDoc.getDocumentElement(),true);
  verify(encryptedSignedDoc,reqData);
  encryptedSignedDoc=getRequestDocument();
  reqData=getRequestData(true);
  Element newEncData=TestMessageTransformer.duplicateEncryptedDataInExternalWrapperElement(encryptedSignedDoc.getDocumentElement(),true);
  try {
    verify(encryptedSignedDoc,reqData);
    fail("WSSecurityException expected");
  }
 catch (  WSSecurityException e) {
    checkFailure(newEncData,e);
  }
}

</code></pre>

<br>
<pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testEncryptedKeyRefAndDuplicatedEncDataInWsseHeader() throws Exception {
  Document encryptedSignedDoc=getRequestDocument();
  RequestData reqData=getRequestData(true);
  verify(encryptedSignedDoc,reqData);
  encryptedSignedDoc=getRequestDocument();
  reqData=getRequestData(false);
  TestMessageTransformer.duplicateEncryptedDataInWsseHeader(encryptedSignedDoc.getDocumentElement(),false);
  verify(encryptedSignedDoc,reqData);
  encryptedSignedDoc=getRequestDocument();
  reqData=getRequestData(true);
  Element newEncData=TestMessageTransformer.duplicateEncryptedDataInWsseHeader(encryptedSignedDoc.getDocumentElement(),false);
  try {
    verify(encryptedSignedDoc,reqData);
    fail("WSSecurityException expected");
  }
 catch (  WSSecurityException e) {
    checkFailure(newEncData,e);
  }
}

</code></pre>

<br>
<pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testReferenceListAndDuplicatedEncDataInWsseWrapperHeader() throws Exception {
  Document encryptedSignedDoc=getRequestDocument();
  RequestData reqData=getRequestData(true);
  verify(encryptedSignedDoc,reqData);
  encryptedSignedDoc=getRequestDocument();
  reqData=getRequestData(false);
  TestMessageTransformer.duplicateEncryptedDataInWsseWrapperHeader(encryptedSignedDoc.getDocumentElement(),true);
  verify(encryptedSignedDoc,reqData);
  encryptedSignedDoc=getRequestDocument();
  reqData=getRequestData(true);
  Element newEncData=TestMessageTransformer.duplicateEncryptedDataInWsseWrapperHeader(encryptedSignedDoc.getDocumentElement(),true);
  try {
    verify(encryptedSignedDoc,reqData);
    fail("WSSecurityException expected");
  }
 catch (  WSSecurityException e) {
    checkFailure(newEncData,e);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testEncryptedKeyRefAndDuplicatedEncDataAfterWsseWrapperBody() throws Exception {
  Document encryptedSignedDoc=getRequestDocumentEncryptionFirst();
  TestMessageTransformer.duplicateEncryptedDataAfterWrapperBody(encryptedSignedDoc.getDocumentElement());
  RequestData reqData=getRequestData(true);
  try {
    verify(encryptedSignedDoc,reqData);
    fail("WSSecurityException expected");
  }
 catch (  WSSecurityException e) {
    assertTrue(e.getMessage().contains("is not signed"));
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testEncryptedKeyRefAndDuplicatedEncDataInWsseWrapperBody() throws Exception {
  Document encryptedSignedDoc=getRequestDocumentEncryptionFirst();
  RequestData reqData=getRequestData(false);
  TestMessageTransformer.duplicateEncryptedDataInWrapperBody(encryptedSignedDoc.getDocumentElement());
  try {
    verify(encryptedSignedDoc,reqData);
    fail("WSSecurityException expected");
  }
 catch (  WSSecurityException e) {
    assertTrue(e.getMessage().contains("The signature or decryption was invalid"));
  }
  encryptedSignedDoc=getRequestDocumentEncryptionFirst();
  TestMessageTransformer.duplicateEncryptedDataInWrapperBody(encryptedSignedDoc.getDocumentElement());
  reqData=getRequestData(true);
  try {
    verify(encryptedSignedDoc,reqData);
    fail("WSSecurityException expected");
  }
 catch (  WSSecurityException e) {
    assertTrue(e.getMessage().contains("is not signed"));
  }
}

</code></pre>

<br>
<pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testEncryptedKeyRefAndDuplicatedEncDataInWsseWrapperHeader() throws Exception {
  Document encryptedSignedDoc=getRequestDocument();
  RequestData reqData=getRequestData(true);
  verify(encryptedSignedDoc,reqData);
  encryptedSignedDoc=getRequestDocument();
  reqData=getRequestData(false);
  TestMessageTransformer.duplicateEncryptedDataInWsseWrapperHeader(encryptedSignedDoc.getDocumentElement(),false);
  verify(encryptedSignedDoc,reqData);
  encryptedSignedDoc=getRequestDocument();
  reqData=getRequestData(true);
  Element newEncData=TestMessageTransformer.duplicateEncryptedDataInWsseWrapperHeader(encryptedSignedDoc.getDocumentElement(),false);
  try {
    verify(encryptedSignedDoc,reqData);
    fail("WSSecurityException expected");
  }
 catch (  WSSecurityException e) {
    checkFailure(newEncData,e);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.wss4j.dom.message.SecurityContextTokenTest </h4><pre class="type-3 type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testBuild(){
  try {
    Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
    WSSecHeader secHeader=new WSSecHeader(doc);
    secHeader.insertSecurityHeader();
    WSSecSecurityContextToken sctBuilder=new WSSecSecurityContextToken();
    sctBuilder.prepare(doc,crypto);
    sctBuilder.prependSCTElementToHeader(doc,secHeader);
    String out=XMLUtils.prettyDocumentToString(doc);
    if (LOG.isDebugEnabled()) {
      LOG.debug(out);
    }
    assertTrue("SecurityContextToken missing",out.indexOf(ConversationConstants.SECURITY_CONTEXT_TOKEN_LN) > 0);
    assertTrue("wsc:Identifier missing",out.indexOf(ConversationConstants.IDENTIFIER_LN) > 0);
  }
 catch (  Exception e) {
    e.printStackTrace();
    fail(e.getMessage());
  }
}

</code></pre>

<br>
<pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testSCTKDKTSignEncrypt(){
  try {
    Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
    WSSecHeader secHeader=new WSSecHeader(doc);
    secHeader.insertSecurityHeader();
    WSSecSecurityContextToken sctBuilder=new WSSecSecurityContextToken();
    sctBuilder.prepare(doc,crypto);
    byte[] tempSecret=WSSecurityUtil.generateNonce(16);
    callbackHandler.addSecretKey(sctBuilder.getIdentifier(),tempSecret);
    String tokenId=sctBuilder.getSctId();
    WSSecDKSign sigBuilder=new WSSecDKSign();
    sigBuilder.setExternalKey(tempSecret,tokenId);
    sigBuilder.setSignatureAlgorithm(WSConstants.HMAC_SHA1);
    sigBuilder.build(doc,secHeader);
    WSSecDKEncrypt encrBuilder=new WSSecDKEncrypt();
    encrBuilder.setSymmetricEncAlgorithm(WSConstants.AES_128);
    encrBuilder.setExternalKey(tempSecret,tokenId);
    encrBuilder.build(doc,secHeader);
    sctBuilder.prependSCTElementToHeader(doc,secHeader);
    if (LOG.isDebugEnabled()) {
      String out=XMLUtils.prettyDocumentToString(doc);
      LOG.debug(out);
    }
    verify(doc);
  }
 catch (  Exception e) {
    e.printStackTrace();
    fail(e.getMessage());
  }
}

</code></pre>

<br>
<pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testSCTKDKTEncryptSign(){
  try {
    Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
    WSSecHeader secHeader=new WSSecHeader(doc);
    secHeader.insertSecurityHeader();
    WSSecSecurityContextToken sctBuilder=new WSSecSecurityContextToken();
    sctBuilder.prepare(doc,crypto);
    byte[] tempSecret=WSSecurityUtil.generateNonce(16);
    callbackHandler.addSecretKey(sctBuilder.getIdentifier(),tempSecret);
    String tokenId=sctBuilder.getSctId();
    WSSecDKEncrypt encrBuilder=new WSSecDKEncrypt();
    encrBuilder.setSymmetricEncAlgorithm(WSConstants.AES_128);
    encrBuilder.setExternalKey(tempSecret,tokenId);
    encrBuilder.build(doc,secHeader);
    WSSecDKSign sigBuilder=new WSSecDKSign();
    sigBuilder.setExternalKey(tempSecret,tokenId);
    sigBuilder.setSignatureAlgorithm(WSConstants.HMAC_SHA1);
    sigBuilder.build(doc,secHeader);
    sctBuilder.prependSCTElementToHeader(doc,secHeader);
    if (LOG.isDebugEnabled()) {
      String out=XMLUtils.prettyDocumentToString(doc);
      LOG.debug(out);
    }
    verify(doc);
  }
 catch (  Exception e) {
    e.printStackTrace();
    fail(e.getMessage());
  }
}

</code></pre>

<br>
<pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * Test signature and verification using a SecurityContextToken directly,
 * rather than using a DerivedKeyToken to point to a SecurityContextToken.
 * See WSS-216 - https://issues.apache.org/jira/browse/WSS-216
 */
@Test public void testSCTSign(){
  try {
    Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
    WSSecHeader secHeader=new WSSecHeader(doc);
    secHeader.insertSecurityHeader();
    WSSecSecurityContextToken sctBuilder=new WSSecSecurityContextToken();
    sctBuilder.prepare(doc,crypto);
    byte[] tempSecret=WSSecurityUtil.generateNonce(16);
    callbackHandler.addSecretKey(sctBuilder.getIdentifier(),tempSecret);
    String tokenId=sctBuilder.getSctId();
    WSSecSignature builder=new WSSecSignature();
    builder.setSecretKey(tempSecret);
    builder.setKeyIdentifierType(WSConstants.CUSTOM_SYMM_SIGNING);
    builder.setCustomTokenValueType(WSConstants.WSC_SCT);
    builder.setCustomTokenId(tokenId);
    builder.setSignatureAlgorithm(SignatureMethod.HMAC_SHA1);
    builder.build(doc,crypto,secHeader);
    sctBuilder.prependSCTElementToHeader(doc,secHeader);
    if (LOG.isDebugEnabled()) {
      LOG.debug("SCT sign");
      String outputString=XMLUtils.prettyDocumentToString(doc);
      LOG.debug(outputString);
    }
    verify(doc);
  }
 catch (  Exception e) {
    e.printStackTrace();
    fail(e.getMessage());
  }
}

</code></pre>

<br>
<pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * Test for WSS-217:
 * "Add ability to specify a reference to an absolute URI in the derived key functionality".
 */
@Test public void testSCTKDKTSignAbsolute(){
  try {
    Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
    WSSecHeader secHeader=new WSSecHeader(doc);
    secHeader.insertSecurityHeader();
    WSSecSecurityContextToken sctBuilder=new WSSecSecurityContextToken();
    sctBuilder.prepare(doc,crypto);
    byte[] tempSecret=WSSecurityUtil.generateNonce(16);
    callbackHandler.addSecretKey(sctBuilder.getIdentifier(),tempSecret);
    WSSecDKSign sigBuilder=new WSSecDKSign();
    sigBuilder.setExternalKey(tempSecret,sctBuilder.getIdentifier());
    sigBuilder.setTokenIdDirectId(true);
    sigBuilder.setSignatureAlgorithm(WSConstants.HMAC_SHA1);
    sigBuilder.build(doc,secHeader);
    sctBuilder.prependSCTElementToHeader(doc,secHeader);
    if (LOG.isDebugEnabled()) {
      LOG.debug("DKT Absolute");
      String outputString=XMLUtils.prettyDocumentToString(doc);
      LOG.debug(outputString);
    }
    verify(doc);
  }
 catch (  Exception e) {
    e.printStackTrace();
    fail(e.getMessage());
  }
}

</code></pre>

<br>
<pre class="type-3 type-8 type-7 type-5 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test encryption using a derived key which is based on a secret associated
 * with a security context token
 */
@Test public void testSCTDKTEncrypt(){
  try {
    Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
    WSSecHeader secHeader=new WSSecHeader(doc);
    secHeader.insertSecurityHeader();
    WSSecSecurityContextToken sctBuilder=new WSSecSecurityContextToken();
    sctBuilder.prepare(doc,crypto);
    byte[] tempSecret=WSSecurityUtil.generateNonce(16);
    callbackHandler.addSecretKey(sctBuilder.getIdentifier(),tempSecret);
    String tokenId=sctBuilder.getSctId();
    WSSecDKEncrypt encrBuilder=new WSSecDKEncrypt();
    encrBuilder.setSymmetricEncAlgorithm(WSConstants.AES_128);
    encrBuilder.setExternalKey(tempSecret,tokenId);
    encrBuilder.build(doc,secHeader);
    sctBuilder.prependSCTElementToHeader(doc,secHeader);
    if (LOG.isDebugEnabled()) {
      String out=XMLUtils.prettyDocumentToString(doc);
      LOG.debug(out);
    }
    WSHandlerResult results=verify(doc);
    WSSecurityEngineResult actionResult=results.getActionResults().get(WSConstants.SCT).get(0);
    SecurityContextToken receivedToken=(SecurityContextToken)actionResult.get(WSSecurityEngineResult.TAG_SECURITY_CONTEXT_TOKEN);
    assertTrue(receivedToken != null);
    assertTrue(WSConstants.WSC_SCT_05_12.equals(receivedToken.getTokenType()));
    SecurityContextToken clone=new SecurityContextToken(receivedToken.getElement());
    assertTrue(clone.equals(receivedToken));
    assertTrue(clone.hashCode() == receivedToken.hashCode());
  }
 catch (  Exception e) {
    e.printStackTrace();
    fail(e.getMessage());
  }
}

</code></pre>

<br>
<pre class="type-3 type-8 type-7 type-5 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testSCTKDKTSign(){
  try {
    Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
    WSSecHeader secHeader=new WSSecHeader(doc);
    secHeader.insertSecurityHeader();
    WSSecSecurityContextToken sctBuilder=new WSSecSecurityContextToken();
    sctBuilder.setWscVersion(ConversationConstants.VERSION_05_12);
    sctBuilder.prepare(doc,crypto);
    byte[] tempSecret=WSSecurityUtil.generateNonce(16);
    callbackHandler.addSecretKey(sctBuilder.getIdentifier(),tempSecret);
    String tokenId=sctBuilder.getSctId();
    WSSecDKSign sigBuilder=new WSSecDKSign();
    sigBuilder.setExternalKey(tempSecret,tokenId);
    sigBuilder.setSignatureAlgorithm(WSConstants.HMAC_SHA1);
    sigBuilder.build(doc,secHeader);
    sctBuilder.prependSCTElementToHeader(doc,secHeader);
    if (LOG.isDebugEnabled()) {
      String out=XMLUtils.prettyDocumentToString(doc);
      LOG.debug(out);
    }
    WSHandlerResult results=verify(doc);
    WSSecurityEngineResult actionResult=results.getActionResults().get(WSConstants.SCT).get(0);
    SecurityContextToken receivedToken=(SecurityContextToken)actionResult.get(WSSecurityEngineResult.TAG_SECURITY_CONTEXT_TOKEN);
    assertTrue(receivedToken != null);
    assertTrue(WSConstants.WSC_SCT_05_12.equals(receivedToken.getTokenType()));
  }
 catch (  Exception e) {
    e.printStackTrace();
    fail(e.getMessage());
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.wss4j.dom.message.SignatureAlgorithmSuiteTest </h4><pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testSymmetricKey() throws Exception {
  KeyGenerator keyGen=KeyGenerator.getInstance("AES");
  keyGen.init(128);
  SecretKey key=keyGen.generateKey();
  byte[] keyData=key.getEncoded();
  WSSecSignature builder=new WSSecSignature();
  builder.setKeyIdentifierType(WSConstants.ENCRYPTED_KEY_SHA1_IDENTIFIER);
  builder.setSecretKey(keyData);
  builder.setSignatureAlgorithm(SignatureMethod.HMAC_SHA1);
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  Document signedDoc=builder.build(doc,crypto,secHeader);
  if (LOG.isDebugEnabled()) {
    String outputString=XMLUtils.prettyDocumentToString(signedDoc);
    LOG.debug(outputString);
  }
  byte[] encodedBytes=KeyUtils.generateDigest(keyData);
  String identifier=Base64.encode(encodedBytes);
  SecretKeyCallbackHandler secretKeyCallbackHandler=new SecretKeyCallbackHandler();
  secretKeyCallbackHandler.addSecretKey(identifier,keyData);
  Element securityHeader=WSSecurityUtil.getSecurityHeader(signedDoc,null);
  AlgorithmSuite algorithmSuite=createAlgorithmSuite();
  WSSecurityEngine secEngine=new WSSecurityEngine();
  RequestData data=new RequestData();
  SignatureActionToken actionToken=new SignatureActionToken();
  actionToken.setCrypto(crypto);
  data.setSignatureToken(actionToken);
  data.setCallbackHandler(secretKeyCallbackHandler);
  data.setAlgorithmSuite(algorithmSuite);
  try {
    secEngine.processSecurityHeader(securityHeader,data);
    fail("Expected failure as HMAC-SHA1 is not allowed");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.INVALID_SECURITY);
  }
  algorithmSuite.addSignatureMethod(WSConstants.HMAC_SHA1);
  secEngine.processSecurityHeader(securityHeader,data);
  algorithmSuite.setMinimumSymmetricKeyLength(256);
  try {
    secEngine.processSecurityHeader(securityHeader,data);
    fail("Expected failure as a 128 bit key is not allowed");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.INVALID_SECURITY);
  }
  algorithmSuite.setMinimumSymmetricKeyLength(64);
  algorithmSuite.setMaximumSymmetricKeyLength(120);
  try {
    secEngine.processSecurityHeader(securityHeader,data);
    fail("Expected failure as a 128 bit key is not allowed");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.INVALID_SECURITY);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testSignature() throws Exception {
  WSSecSignature builder=new WSSecSignature();
  builder.setUserInfo("16c73ab6-b892-458f-abf5-2f875f74882e","security");
  builder.setKeyIdentifierType(WSConstants.ISSUER_SERIAL);
  builder.setSignatureAlgorithm(WSConstants.RSA_SHA1);
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  Document signedDoc=builder.build(doc,crypto,secHeader);
  if (LOG.isDebugEnabled()) {
    String outputString=XMLUtils.prettyDocumentToString(signedDoc);
    LOG.debug(outputString);
  }
  Element securityHeader=WSSecurityUtil.getSecurityHeader(signedDoc,null);
  AlgorithmSuite algorithmSuite=createAlgorithmSuite();
  verify(securityHeader,algorithmSuite,crypto);
  algorithmSuite.setMinimumAsymmetricKeyLength(1024);
  try {
    verify(securityHeader,algorithmSuite,crypto);
    fail("Expected failure as 512-bit keys are not allowed");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.INVALID_SECURITY);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testSignatureMethodDSA() throws Exception {
  Crypto dsaCrypto=CryptoFactory.getInstance("wss40.properties");
  WSSecSignature builder=new WSSecSignature();
  builder.setUserInfo("wss40DSA","security");
  builder.setKeyIdentifierType(WSConstants.ISSUER_SERIAL);
  builder.setSignatureAlgorithm(WSConstants.DSA);
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  Document signedDoc=builder.build(doc,dsaCrypto,secHeader);
  if (LOG.isDebugEnabled()) {
    String outputString=XMLUtils.prettyDocumentToString(signedDoc);
    LOG.debug(outputString);
  }
  Element securityHeader=WSSecurityUtil.getSecurityHeader(signedDoc,null);
  AlgorithmSuite algorithmSuite=createAlgorithmSuite();
  try {
    verify(securityHeader,algorithmSuite,dsaCrypto);
    fail("Expected failure as DSA is not allowed");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.INVALID_SECURITY);
  }
  algorithmSuite.addSignatureMethod(WSConstants.DSA);
  verify(securityHeader,algorithmSuite,dsaCrypto);
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testC14nMethod() throws Exception {
  WSSecSignature builder=new WSSecSignature();
  builder.setUserInfo("16c73ab6-b892-458f-abf5-2f875f74882e","security");
  builder.setKeyIdentifierType(WSConstants.ISSUER_SERIAL);
  builder.setSignatureAlgorithm(WSConstants.RSA_SHA1);
  builder.setSigCanonicalization(WSConstants.C14N_EXCL_WITH_COMMENTS);
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  Document signedDoc=builder.build(doc,crypto,secHeader);
  if (LOG.isDebugEnabled()) {
    String outputString=XMLUtils.prettyDocumentToString(signedDoc);
    LOG.debug(outputString);
  }
  Element securityHeader=WSSecurityUtil.getSecurityHeader(signedDoc,null);
  AlgorithmSuite algorithmSuite=createAlgorithmSuite();
  try {
    verify(securityHeader,algorithmSuite,crypto);
    fail("Expected failure as C14n algorithm is not allowed");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.INVALID_SECURITY);
  }
  algorithmSuite.addC14nAlgorithm(WSConstants.C14N_EXCL_WITH_COMMENTS);
  verify(securityHeader,algorithmSuite,crypto);
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testDigestMethod() throws Exception {
  WSSecSignature builder=new WSSecSignature();
  builder.setUserInfo("16c73ab6-b892-458f-abf5-2f875f74882e","security");
  builder.setKeyIdentifierType(WSConstants.ISSUER_SERIAL);
  builder.setSignatureAlgorithm(WSConstants.RSA_SHA1);
  builder.setDigestAlgo(WSConstants.SHA256);
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  Document signedDoc=builder.build(doc,crypto,secHeader);
  if (LOG.isDebugEnabled()) {
    String outputString=XMLUtils.prettyDocumentToString(signedDoc);
    LOG.debug(outputString);
  }
  Element securityHeader=WSSecurityUtil.getSecurityHeader(signedDoc,null);
  AlgorithmSuite algorithmSuite=createAlgorithmSuite();
  try {
    verify(securityHeader,algorithmSuite,crypto);
    fail("Expected failure as Digest algorithm is not allowed");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.INVALID_SECURITY);
  }
  algorithmSuite.addDigestAlgorithm(WSConstants.SHA256);
  verify(securityHeader,algorithmSuite,crypto);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.wss4j.dom.message.SignatureCRLTest </h4><pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test signing a SOAP message using a BST. Revocation is enabled and so the test
 * should fail. The trust store that is used is the keystore that contains the revoked
 * certificate. See WSS-341:
 * https://issues.apache.org/jira/browse/WSS-341
 * TODO Re-enable once CRL issue fixed
 */
@Test @org.junit.Ignore public void testSignatureDirectReferenceRevocationKeyStore() throws Exception {
  WSSecSignature sign=new WSSecSignature();
  sign.setUserInfo("wss40rev","security");
  sign.setKeyIdentifierType(WSConstants.BST_DIRECT_REFERENCE);
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  Document signedDoc=sign.build(doc,crypto,secHeader);
  if (LOG.isDebugEnabled()) {
    String outputString=XMLUtils.prettyDocumentToString(signedDoc);
    LOG.debug(outputString);
  }
  try {
    verify(signedDoc,crypto,true);
    fail("Failure expected on a revoked certificate");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.FAILED_AUTHENTICATION);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test signing a SOAP message using a BST. Revocation is enabled and so the test
 * should fail.
 * TODO Re-enable once CRL issue fixed
 */
@Test @org.junit.Ignore public void testSignatureDirectReferenceRevocation() throws Exception {
  WSSecSignature sign=new WSSecSignature();
  sign.setUserInfo("wss40rev","security");
  sign.setKeyIdentifierType(WSConstants.BST_DIRECT_REFERENCE);
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  Document signedDoc=sign.build(doc,crypto,secHeader);
  if (LOG.isDebugEnabled()) {
    String outputString=XMLUtils.prettyDocumentToString(signedDoc);
    LOG.debug(outputString);
  }
  try {
    verify(signedDoc,cryptoCA,true);
    fail("Failure expected on a revoked certificate");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.FAILED_AUTHENTICATION);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.wss4j.dom.message.SignatureCertConstraintsTest </h4><pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * The test uses the BinarySecurityToken key identifier type.
 */
@Test public void testBSTSignaturePKIPath() throws Exception {
  WSSecSignature builder=new WSSecSignature();
  builder.setUserInfo("wss40","security");
  builder.setKeyIdentifierType(WSConstants.BST_DIRECT_REFERENCE);
  builder.setUseSingleCertificate(false);
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  Document signedDoc=builder.build(doc,crypto,secHeader);
  if (LOG.isDebugEnabled()) {
    LOG.debug("Signed message with BST key identifier:");
    String outputString=XMLUtils.prettyDocumentToString(signedDoc);
    LOG.debug(outputString);
  }
  Element securityHeader=WSSecurityUtil.getSecurityHeader(signedDoc,null);
  String certConstraint=".*CN=Colm.*O=Apache.*";
  verify(securityHeader,cryptoCA,certConstraint);
  certConstraint=".*CN=Colm2.*O=Apache.*";
  try {
    verify(securityHeader,cryptoCA,certConstraint);
    fail("Failure expected on a bad cert constraint");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.FAILED_AUTHENTICATION);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * The test uses the BinarySecurityToken key identifier type.
 */
@Test public void testBSTSignature() throws Exception {
  WSSecSignature builder=new WSSecSignature();
  builder.setUserInfo("wss40","security");
  builder.setKeyIdentifierType(WSConstants.BST_DIRECT_REFERENCE);
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  Document signedDoc=builder.build(doc,crypto,secHeader);
  if (LOG.isDebugEnabled()) {
    LOG.debug("Signed message with BST key identifier:");
    String outputString=XMLUtils.prettyDocumentToString(signedDoc);
    LOG.debug(outputString);
  }
  Element securityHeader=WSSecurityUtil.getSecurityHeader(signedDoc,null);
  String certConstraint=".*CN=Colm.*O=Apache.*";
  verify(securityHeader,cryptoCA,certConstraint);
  certConstraint=".*CN=Colm2.*O=Apache.*";
  try {
    verify(securityHeader,cryptoCA,certConstraint);
    fail("Failure expected on a bad cert constraint");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.FAILED_AUTHENTICATION);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.wss4j.dom.message.SignatureCertTest </h4><pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test signing a SOAP message using Issuer Serial. Note that this should fail, as the
 * trust-store does not contain the cert corresponding to wss40, only the CA cert
 * wss40CA.
 */
@Test public void testSignatureIssuerSerial() throws Exception {
  WSSecSignature sign=new WSSecSignature();
  sign.setUserInfo("wss40","security");
  sign.setKeyIdentifierType(WSConstants.ISSUER_SERIAL);
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  Document signedDoc=sign.build(doc,crypto,secHeader);
  if (LOG.isDebugEnabled()) {
    String outputString=XMLUtils.prettyDocumentToString(signedDoc);
    LOG.debug(outputString);
  }
  try {
    verify(signedDoc,cryptoCA);
    fail("Failure expected on issuer serial");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.FAILED_CHECK);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test signing a SOAP message using a BST. The signature verification passes, but the trust
 * verification will fail as the CA cert is out of date.
 */
@Test public void testSignatureBadCACert() throws Exception {
  WSSecSignature sign=new WSSecSignature();
  sign.setUserInfo("wss4jcertdsa","security");
  sign.setKeyIdentifierType(WSConstants.BST_DIRECT_REFERENCE);
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  Document signedDoc=sign.build(doc,CryptoFactory.getInstance("wss40badca.properties"),secHeader);
  if (LOG.isDebugEnabled()) {
    String outputString=XMLUtils.prettyDocumentToString(signedDoc);
    LOG.debug(outputString);
  }
  try {
    verify(signedDoc,CryptoFactory.getInstance("wss40badcatrust.properties"));
    fail("Failure expected on bad CA cert!");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.FAILURE);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testExpiredCertInKeystore() throws Exception {
  Properties clientProperties=new Properties();
  clientProperties.put("org.apache.wss4j.crypto.provider","org.apache.wss4j.common.crypto.Merlin");
  clientProperties.put("org.apache.wss4j.crypto.merlin.keystore.type","jks");
  clientProperties.put("org.apache.wss4j.crypto.merlin.keystore.password","security");
  clientProperties.put("org.apache.wss4j.crypto.merlin.keystore.alias","wss40exp");
  clientProperties.put("org.apache.wss4j.crypto.merlin.keystore.file","keys/wss40exp.jks");
  Crypto clientCrypto=new Merlin(clientProperties,this.getClass().getClassLoader(),null);
  WSSecSignature sign=new WSSecSignature();
  sign.setUserInfo("wss40exp","security");
  sign.setKeyIdentifierType(WSConstants.BST_DIRECT_REFERENCE);
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  Document signedDoc=sign.build(doc,clientCrypto,secHeader);
  if (LOG.isDebugEnabled()) {
    String outputString=XMLUtils.prettyDocumentToString(signedDoc);
    LOG.debug(outputString);
  }
  WSSecurityEngine newEngine=new WSSecurityEngine();
  try {
    newEngine.processSecurityHeader(doc,null,null,clientCrypto);
    fail("Failure expected on an expired cert");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.FAILED_CHECK);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testExpiredCert() throws Exception {
  Properties clientProperties=new Properties();
  clientProperties.put("org.apache.wss4j.crypto.provider","org.apache.wss4j.common.crypto.Merlin");
  clientProperties.put("org.apache.wss4j.crypto.merlin.keystore.type","jks");
  clientProperties.put("org.apache.wss4j.crypto.merlin.keystore.password","security");
  clientProperties.put("org.apache.wss4j.crypto.merlin.keystore.alias","wss40exp");
  clientProperties.put("org.apache.wss4j.crypto.merlin.keystore.file","keys/wss40exp.jks");
  Crypto clientCrypto=new Merlin(clientProperties,this.getClass().getClassLoader(),null);
  WSSecSignature sign=new WSSecSignature();
  sign.setUserInfo("wss40exp","security");
  sign.setKeyIdentifierType(WSConstants.BST_DIRECT_REFERENCE);
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  Document signedDoc=sign.build(doc,clientCrypto,secHeader);
  if (LOG.isDebugEnabled()) {
    String outputString=XMLUtils.prettyDocumentToString(signedDoc);
    LOG.debug(outputString);
  }
  WSSecurityEngine newEngine=new WSSecurityEngine();
  try {
    newEngine.processSecurityHeader(doc,null,null,cryptoCA);
    fail("Failure expected on an expired cert");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.FAILURE);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.wss4j.dom.message.SignatureKeyValueTest </h4><pre class="type-3 type-8 type-7 type-5 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Failed RSAKeyValue test, where a message is signed using a key-pair which doesn't
 * correspond to the public key in the "trust"-store.
 */
@Test public void testBadRSAKeyValue() throws Exception {
  WSSecSignature builder=new WSSecSignature();
  builder.setUserInfo("wss86","security");
  builder.setKeyIdentifierType(WSConstants.KEY_VALUE);
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  Document signedDoc=builder.build(doc,CryptoFactory.getInstance("wss86.properties"),secHeader);
  String outputString=XMLUtils.prettyDocumentToString(signedDoc);
  if (LOG.isDebugEnabled()) {
    LOG.debug(outputString);
  }
  assertTrue(outputString.contains("RSAKeyValue"));
  try {
    WSSecurityEngine secEngine=new WSSecurityEngine();
    RequestData data=new RequestData();
    data.setSigVerCrypto(crypto);
    data.setIgnoredBSPRules(Collections.singletonList(BSPRule.R5417));
    secEngine.processSecurityHeader(signedDoc,data);
    fail("Failure expected on bad public key");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.FAILED_AUTHENTICATION);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.wss4j.dom.message.SignaturePartsTest </h4><pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testRequiredSOAPHeaderNotPresent() throws Exception {
  WSSecSignature sign=new WSSecSignature();
  sign.setUserInfo("16c73ab6-b892-458f-abf5-2f875f74882e","security");
  sign.setKeyIdentifierType(WSConstants.ISSUER_SERIAL);
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  WSEncryptionPart encP=new WSEncryptionPart("foobar","urn:foo.bar","");
  sign.getParts().add(encP);
  String soapNamespace=WSSecurityUtil.getSOAPNamespace(doc.getDocumentElement());
  encP=new WSEncryptionPart(WSConstants.ELEM_BODY,soapNamespace,"Content");
  sign.getParts().add(encP);
  try {
    sign.build(doc,crypto,secHeader);
    fail("Failure expected on not signing a required element");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.FAILED_SIGNATURE);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test signing a custom SOAP header with a bad localname
 */
@Test public void testBadLocalname() throws Exception {
  WSSecSignature sign=new WSSecSignature();
  sign.setUserInfo("16c73ab6-b892-458f-abf5-2f875f74882e","security");
  sign.setKeyIdentifierType(WSConstants.ISSUER_SERIAL);
  Document doc=SOAPUtil.toSOAPPart(SOAPMSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  WSEncryptionPart encP=new WSEncryptionPart("foobar2","urn:foo.bar","");
  sign.getParts().add(encP);
  try {
    sign.build(doc,crypto,secHeader);
    fail("Failure expected on a bad localname");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.FAILED_SIGNATURE);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test signing a custom SOAP header with a bad namespace
 */
@Test public void testBadNamespace() throws Exception {
  WSSecSignature sign=new WSSecSignature();
  sign.setUserInfo("16c73ab6-b892-458f-abf5-2f875f74882e","security");
  sign.setKeyIdentifierType(WSConstants.ISSUER_SERIAL);
  Document doc=SOAPUtil.toSOAPPart(SOAPMSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  WSEncryptionPart encP=new WSEncryptionPart("foobar","urn:foo.bar2","");
  sign.getParts().add(encP);
  try {
    sign.build(doc,crypto,secHeader);
    fail("Failure expected on a bad namespace");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.FAILED_SIGNATURE);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.wss4j.dom.message.SignatureTest </h4><pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test that signs and verifies a WS-Security envelope
 * <p/>
 * @throws java.lang.Exception Thrown when there is any problem in signing or verification
 */
@Test public void testSignatureInclusiveC14N() throws Exception {
  WSSecSignature builder=new WSSecSignature();
  builder.setSigCanonicalization(WSConstants.C14N_OMIT_COMMENTS);
  builder.setUserInfo("16c73ab6-b892-458f-abf5-2f875f74882e","security");
  LOG.info("Before Signing....");
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  Document signedDoc=builder.build(doc,crypto,secHeader);
  if (LOG.isDebugEnabled()) {
    LOG.debug("After Signing....");
    String outputString=XMLUtils.prettyDocumentToString(signedDoc);
    LOG.debug(outputString);
  }
  WSSecurityEngine newEngine=new WSSecurityEngine();
  try {
    newEngine.processSecurityHeader(doc,null,null,crypto);
    fail("Failure expected on a bad c14n algorithm");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.INVALID_SECURITY);
  }
  RequestData data=new RequestData();
  data.setSigVerCrypto(crypto);
  List<BSPRule> ignoredRules=new ArrayList<>();
  ignoredRules.add(BSPRule.R5404);
  ignoredRules.add(BSPRule.R5406);
  data.setIgnoredBSPRules(ignoredRules);
  newEngine.processSecurityHeader(doc,data);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.wss4j.dom.message.TimestampTest </h4><pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * This is a test for processing multiple Timestamps in the security header
 */
@Test public void testMultipleTimestamps() throws Exception {
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  WSSecTimestamp timestamp=new WSSecTimestamp();
  timestamp.setTimeToLive(300);
  Document createdDoc=timestamp.build(doc,secHeader);
  timestamp=new WSSecTimestamp();
  timestamp.setTimeToLive(60);
  createdDoc=timestamp.build(doc,secHeader);
  if (LOG.isDebugEnabled()) {
    String outputString=XMLUtils.prettyDocumentToString(createdDoc);
    LOG.debug(outputString);
  }
  try {
    verify(createdDoc);
    fail("Expected failure on multiple timestamps");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.INVALID_SECURITY);
  }
  verify(createdDoc,Collections.singletonList(BSPRule.R3227));
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * This is a test to create a "Spoofed" Timestamp (see WSS-441)
 */
@Test public void testSpoofedTimestamp() throws Exception {
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  WSSecTimestamp timestamp=new WSSecTimestamp();
  timestamp.setTimeToLive(300);
  WSTimeSource spoofedTimeSource=new WSTimeSource(){
    public Date now(){
      Date currentTime=new Date();
      currentTime.setTime(currentTime.getTime() - (500L * 1000L));
      return currentTime;
    }
  }
;
  timestamp.setWsTimeSource(spoofedTimeSource);
  Document createdDoc=timestamp.build(doc,secHeader);
  if (LOG.isDebugEnabled()) {
    String outputString=XMLUtils.prettyDocumentToString(createdDoc);
    LOG.debug(outputString);
  }
  try {
    verify(createdDoc);
    fail("Expected failure on an expired timestamp");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.MESSAGE_EXPIRED);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * This is a test for processing an "old" Timestamp, i.e. one with a "Created" element that is
 * out of date
 */
@Test public void testOldTimestamp() throws Exception {
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  WSSecTimestamp timestamp=new WSSecTimestamp();
  Document createdDoc=timestamp.build(doc,secHeader);
  if (LOG.isDebugEnabled()) {
    String outputString=XMLUtils.prettyDocumentToString(createdDoc);
    LOG.debug(outputString);
  }
  RequestData requestData=new RequestData();
  requestData.setWssConfig(WSSConfig.getNewInstance());
  requestData.setTimeStampTTL(-1);
  try {
    verify(createdDoc,requestData);
    fail("The timestamp validation should have failed");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.MESSAGE_EXPIRED);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * This is a test for processing an Timestamp where it contains multiple "Expires" elements.
 * This Timestamp should be rejected.
 */
@Test public void testMultipleExpires() throws Exception {
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  Element timestampElement=doc.createElementNS(WSConstants.WSU_NS,WSConstants.WSU_PREFIX + ":" + WSConstants.TIMESTAMP_TOKEN_LN);
  DateFormat zulu=new XmlSchemaDateFormat();
  Element elementCreated=doc.createElementNS(WSConstants.WSU_NS,WSConstants.WSU_PREFIX + ":" + WSConstants.CREATED_LN);
  Date createdDate=new Date();
  long currentTime=createdDate.getTime();
  createdDate.setTime(currentTime);
  elementCreated.appendChild(doc.createTextNode(zulu.format(createdDate)));
  timestampElement.appendChild(elementCreated);
  zulu=new XmlSchemaDateFormat();
  Element elementExpires=doc.createElementNS(WSConstants.WSU_NS,WSConstants.WSU_PREFIX + ":" + WSConstants.EXPIRES_LN);
  createdDate.setTime(currentTime + 300000);
  elementExpires.appendChild(doc.createTextNode(zulu.format(createdDate)));
  timestampElement.appendChild(elementExpires);
  timestampElement.appendChild(elementExpires.cloneNode(true));
  secHeader.getSecurityHeader().appendChild(timestampElement);
  if (LOG.isDebugEnabled()) {
    String outputString=XMLUtils.prettyDocumentToString(doc);
    LOG.debug(outputString);
  }
  try {
    verify(doc);
    fail("The timestamp validation should have failed on multiple Expires elements");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.INVALID_SECURITY);
  }
  verify(doc,Collections.singletonList(BSPRule.R3224));
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * This is a test for processing an Timestamp where the "Created" element is in the (near)
 * future. It should be accepted by default when it is created 30 seconds in the future,
 * and then rejected once we configure "0 seconds" for future-time-to-live.
 */
@Test public void testNearFutureCreated() throws Exception {
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  Element timestampElement=doc.createElementNS(WSConstants.WSU_NS,WSConstants.WSU_PREFIX + ":" + WSConstants.TIMESTAMP_TOKEN_LN);
  DateFormat zulu=new XmlSchemaDateFormat();
  Element elementCreated=doc.createElementNS(WSConstants.WSU_NS,WSConstants.WSU_PREFIX + ":" + WSConstants.CREATED_LN);
  Date createdDate=new Date();
  long currentTime=createdDate.getTime() + 30000;
  createdDate.setTime(currentTime);
  elementCreated.appendChild(doc.createTextNode(zulu.format(createdDate)));
  timestampElement.appendChild(elementCreated);
  secHeader.getSecurityHeader().appendChild(timestampElement);
  if (LOG.isDebugEnabled()) {
    String outputString=XMLUtils.prettyDocumentToString(doc);
    LOG.debug(outputString);
  }
  RequestData requestData=new RequestData();
  requestData.setWssConfig(WSSConfig.getNewInstance());
  requestData.setTimeStampFutureTTL(0);
  try {
    verify(doc,requestData);
    fail("The timestamp validation should have failed");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.MESSAGE_EXPIRED);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * This is a test for processing an Timestamp where it contains a CustomElement. This should
 * be rejected as per the BSP spec.
 */
@Test public void testCustomElement() throws Exception {
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  Element timestampElement=doc.createElementNS(WSConstants.WSU_NS,WSConstants.WSU_PREFIX + ":" + WSConstants.TIMESTAMP_TOKEN_LN);
  DateFormat zulu=new XmlSchemaDateFormat();
  Element elementCreated=doc.createElementNS(WSConstants.WSU_NS,WSConstants.WSU_PREFIX + ":" + WSConstants.CREATED_LN);
  Date createdDate=new Date();
  elementCreated.appendChild(doc.createTextNode(zulu.format(createdDate)));
  timestampElement.appendChild(elementCreated);
  Element elementExpires=doc.createElementNS(WSConstants.WSU_NS,WSConstants.WSU_PREFIX + ":" + WSConstants.EXPIRES_LN);
  createdDate.setTime(createdDate.getTime() + 300000);
  elementExpires.appendChild(doc.createTextNode(zulu.format(createdDate)));
  timestampElement.appendChild(elementExpires);
  Element elementCustom=doc.createElementNS(WSConstants.WSU_NS,WSConstants.WSU_PREFIX + ":" + "Custom");
  timestampElement.appendChild(elementCustom);
  secHeader.getSecurityHeader().appendChild(timestampElement);
  if (LOG.isDebugEnabled()) {
    String outputString=XMLUtils.prettyDocumentToString(doc);
    LOG.debug(outputString);
  }
  try {
    verify(doc);
    fail("The timestamp validation should have failed");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.INVALID_SECURITY);
  }
  verify(doc,Collections.singletonList(BSPRule.R3222));
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * This is a test for processing an Timestamp where it contains no "Created" element.
 * This Timestamp should be rejected.
 */
@Test public void testNoCreated() throws Exception {
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  Element timestampElement=doc.createElementNS(WSConstants.WSU_NS,WSConstants.WSU_PREFIX + ":" + WSConstants.TIMESTAMP_TOKEN_LN);
  DateFormat zulu=new XmlSchemaDateFormat();
  Element elementCreated=doc.createElementNS(WSConstants.WSU_NS,WSConstants.WSU_PREFIX + ":" + WSConstants.EXPIRES_LN);
  Date createdDate=new Date();
  long currentTime=createdDate.getTime() + 300000;
  createdDate.setTime(currentTime);
  elementCreated.appendChild(doc.createTextNode(zulu.format(createdDate)));
  timestampElement.appendChild(elementCreated);
  secHeader.getSecurityHeader().appendChild(timestampElement);
  if (LOG.isDebugEnabled()) {
    String outputString=XMLUtils.prettyDocumentToString(doc);
    LOG.debug(outputString);
  }
  try {
    verify(doc);
    fail("The timestamp validation should have failed on no Created element");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.INVALID_SECURITY);
  }
  List<BSPRule> rules=new ArrayList<>();
  rules.add(BSPRule.R3203);
  rules.add(BSPRule.R3221);
  verify(doc,rules);
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * This is a test for processing an expired Timestamp.
 */
@Test public void testExpiredTimestamp() throws Exception {
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  WSSecTimestamp timestamp=new WSSecTimestamp();
  timestamp.setTimeToLive(-1);
  Document createdDoc=timestamp.build(doc,secHeader);
  if (LOG.isDebugEnabled()) {
    String outputString=XMLUtils.prettyDocumentToString(createdDoc);
    LOG.debug(outputString);
  }
  try {
    verify(createdDoc);
    fail("Expected failure on an expired timestamp");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.MESSAGE_EXPIRED);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * This is a test for processing an Timestamp where the "Created" element is in the future.
 * A Timestamp that is 120 seconds in the future should be rejected by default.
 */
@Test public void testFutureCreated() throws Exception {
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  Element timestampElement=doc.createElementNS(WSConstants.WSU_NS,WSConstants.WSU_PREFIX + ":" + WSConstants.TIMESTAMP_TOKEN_LN);
  DateFormat zulu=new XmlSchemaDateFormat();
  Element elementCreated=doc.createElementNS(WSConstants.WSU_NS,WSConstants.WSU_PREFIX + ":" + WSConstants.CREATED_LN);
  Date createdDate=new Date();
  long currentTime=createdDate.getTime() + 120000;
  createdDate.setTime(currentTime);
  elementCreated.appendChild(doc.createTextNode(zulu.format(createdDate)));
  timestampElement.appendChild(elementCreated);
  secHeader.getSecurityHeader().appendChild(timestampElement);
  if (LOG.isDebugEnabled()) {
    String outputString=XMLUtils.prettyDocumentToString(doc);
    LOG.debug(outputString);
  }
  try {
    verify(doc);
    fail("The timestamp validation should have failed");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.MESSAGE_EXPIRED);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * This is a test for processing an Timestamp where it contains an "Expires" element before
 * the Created element. This Timestamp should be rejected as per the BSP spec.
 */
@Test public void testExpiresInFrontOfCreated() throws Exception {
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  Element timestampElement=doc.createElementNS(WSConstants.WSU_NS,WSConstants.WSU_PREFIX + ":" + WSConstants.TIMESTAMP_TOKEN_LN);
  DateFormat zulu=new XmlSchemaDateFormat();
  Element elementCreated=doc.createElementNS(WSConstants.WSU_NS,WSConstants.WSU_PREFIX + ":" + WSConstants.EXPIRES_LN);
  Date expiresDate=new Date();
  long currentTime=expiresDate.getTime() + 300000;
  expiresDate.setTime(currentTime);
  elementCreated.appendChild(doc.createTextNode(zulu.format(expiresDate)));
  timestampElement.appendChild(elementCreated);
  Element elementExpires=doc.createElementNS(WSConstants.WSU_NS,WSConstants.WSU_PREFIX + ":" + WSConstants.CREATED_LN);
  elementExpires.appendChild(doc.createTextNode(zulu.format(new Date())));
  timestampElement.appendChild(elementExpires);
  secHeader.getSecurityHeader().appendChild(timestampElement);
  if (LOG.isDebugEnabled()) {
    String outputString=XMLUtils.prettyDocumentToString(doc);
    LOG.debug(outputString);
  }
  try {
    verify(doc);
    fail("The timestamp validation should have failed");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.INVALID_SECURITY);
  }
  verify(doc,Collections.singletonList(BSPRule.R3221));
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * This is a test for processing an Timestamp where it contains multiple "Created" elements.
 * This Timestamp should be rejected.
 */
@Test public void testMultipleCreated() throws Exception {
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  Element timestampElement=doc.createElementNS(WSConstants.WSU_NS,WSConstants.WSU_PREFIX + ":" + WSConstants.TIMESTAMP_TOKEN_LN);
  DateFormat zulu=new XmlSchemaDateFormat();
  Element elementCreated=doc.createElementNS(WSConstants.WSU_NS,WSConstants.WSU_PREFIX + ":" + WSConstants.CREATED_LN);
  Date createdDate=new Date();
  elementCreated.appendChild(doc.createTextNode(zulu.format(createdDate)));
  timestampElement.appendChild(elementCreated);
  timestampElement.appendChild(elementCreated.cloneNode(true));
  secHeader.getSecurityHeader().appendChild(timestampElement);
  if (LOG.isDebugEnabled()) {
    String outputString=XMLUtils.prettyDocumentToString(doc);
    LOG.debug(outputString);
  }
  try {
    verify(doc);
    fail("The timestamp validation should have failed on multiple Created elements");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.INVALID_SECURITY);
  }
  verify(doc,Collections.singletonList(BSPRule.R3203));
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * This is a test for processing an Timestamp where it contains a Created element with
 * seconds > 60. This should be rejected as per the BSP spec.
 */
@Test public void testCreatedSeconds() throws Exception {
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  Element timestampElement=doc.createElementNS(WSConstants.WSU_NS,WSConstants.WSU_PREFIX + ":" + WSConstants.TIMESTAMP_TOKEN_LN);
  Element elementCreated=doc.createElementNS(WSConstants.WSU_NS,WSConstants.WSU_PREFIX + ":" + WSConstants.CREATED_LN);
  elementCreated.appendChild(doc.createTextNode("2011-02-08T13:13:84.535Z"));
  timestampElement.appendChild(elementCreated);
  secHeader.getSecurityHeader().appendChild(timestampElement);
  if (LOG.isDebugEnabled()) {
    String outputString=XMLUtils.prettyDocumentToString(doc);
    LOG.debug(outputString);
  }
  WSSConfig wssConfig=WSSConfig.getNewInstance();
  wssConfig.setValidator(WSConstants.TIMESTAMP,new NoOpValidator());
  try {
    verify(doc,wssConfig,new ArrayList<BSPRule>());
    fail("The timestamp validation should have failed");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.INVALID_SECURITY);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * This is a test for processing an Timestamp where the "Created" element is greater than
 * the expiration time.
 */
@Test public void testExpiresBeforeCreated() throws Exception {
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  Element timestampElement=doc.createElementNS(WSConstants.WSU_NS,WSConstants.WSU_PREFIX + ":" + WSConstants.TIMESTAMP_TOKEN_LN);
  DateFormat zulu=new XmlSchemaDateFormat();
  Element elementCreated=doc.createElementNS(WSConstants.WSU_NS,WSConstants.WSU_PREFIX + ":" + WSConstants.CREATED_LN);
  Date createdDate=new Date();
  long currentTime=createdDate.getTime();
  createdDate.setTime(currentTime);
  elementCreated.appendChild(doc.createTextNode(zulu.format(createdDate)));
  timestampElement.appendChild(elementCreated);
  Date expiresDate=new Date();
  expiresDate.setTime(expiresDate.getTime() - 300000);
  Element elementExpires=doc.createElementNS(WSConstants.WSU_NS,WSConstants.WSU_PREFIX + ":" + WSConstants.EXPIRES_LN);
  elementExpires.appendChild(doc.createTextNode(zulu.format(expiresDate)));
  timestampElement.appendChild(elementExpires);
  secHeader.getSecurityHeader().appendChild(timestampElement);
  if (LOG.isDebugEnabled()) {
    String outputString=XMLUtils.prettyDocumentToString(doc);
    LOG.debug(outputString);
  }
  try {
    verify(doc);
    fail("The timestamp validation should have failed");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.MESSAGE_EXPIRED);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * This is a test for processing an Timestamp where it contains a Created element with
 * a ValueType. This should be rejected as per the BSP spec.
 */
@Test public void testCreatedValueType() throws Exception {
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  Element timestampElement=doc.createElementNS(WSConstants.WSU_NS,WSConstants.WSU_PREFIX + ":" + WSConstants.TIMESTAMP_TOKEN_LN);
  DateFormat zulu=new XmlSchemaDateFormat();
  Element elementCreated=doc.createElementNS(WSConstants.WSU_NS,WSConstants.WSU_PREFIX + ":" + WSConstants.CREATED_LN);
  Date createdDate=new Date();
  long currentTime=createdDate.getTime() + 300000;
  createdDate.setTime(currentTime);
  elementCreated.appendChild(doc.createTextNode(zulu.format(createdDate)));
  elementCreated.setAttributeNS(null,"ValueType",WSConstants.WSS_SAML_KI_VALUE_TYPE);
  timestampElement.appendChild(elementCreated);
  secHeader.getSecurityHeader().appendChild(timestampElement);
  if (LOG.isDebugEnabled()) {
    String outputString=XMLUtils.prettyDocumentToString(doc);
    LOG.debug(outputString);
  }
  try {
    verify(doc);
    fail("The timestamp validation should have failed");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.INVALID_SECURITY);
  }
  WSSConfig wssConfig=WSSConfig.getNewInstance();
  wssConfig.setValidator(WSConstants.TIMESTAMP,new NoOpValidator());
  verify(doc,wssConfig,Collections.singletonList(BSPRule.R3225));
}

</code></pre>

<br>
<pre class="type-8 type-7 type-5 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testInvalidTimestampNoExpires() throws Exception {
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  WSSecTimestamp timestamp=new WSSecTimestamp();
  timestamp.setTimeToLive(0);
  Document createdDoc=timestamp.build(doc,secHeader);
  if (LOG.isDebugEnabled()) {
    String outputString=XMLUtils.prettyDocumentToString(createdDoc);
    LOG.debug(outputString);
  }
  WSSecurityEngine secEngine=new WSSecurityEngine();
  RequestData requestData=new RequestData();
  requestData.setWssConfig(WSSConfig.getNewInstance());
  requestData.setRequireTimestampExpires(true);
  try {
    secEngine.processSecurityHeader(doc,requestData);
    fail("Failure expected on no Expires Element");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.SECURITY_ERROR);
  }
  requestData.setWssConfig(WSSConfig.getNewInstance());
  requestData.setRequireTimestampExpires(false);
  WSHandlerResult wsResult=secEngine.processSecurityHeader(doc,requestData);
  WSSecurityEngineResult actionResult=wsResult.getActionResults().get(WSConstants.TS).get(0);
  assertTrue(actionResult != null);
  Timestamp receivedTimestamp=(Timestamp)actionResult.get(WSSecurityEngineResult.TAG_TIMESTAMP);
  assertTrue(receivedTimestamp != null);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.wss4j.dom.message.UTDerivedKeyTest </h4><pre class="type-3 type-8 type-7 type-5 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test using a UsernameToken derived key for encrypting a SOAP body. In this test the
 * derived key is modified before encryption, and so decryption should fail.
 */
@Test public void testDerivedKeyChangedEncryption() throws Exception {
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  WSSecUsernameToken builder=new WSSecUsernameToken();
  builder.setUserInfo("bob","security");
  builder.addDerivedKey(false,null,1000);
  builder.prepare(doc);
  byte[] derivedKey=builder.getDerivedKey();
  derivedKey[5]='z';
  derivedKey[6]='a';
  assertTrue(derivedKey.length == 20);
  String tokenIdentifier=builder.getId();
  WSSecDKEncrypt encrBuilder=new WSSecDKEncrypt();
  encrBuilder.setSymmetricEncAlgorithm(WSConstants.AES_128);
  encrBuilder.setExternalKey(derivedKey,tokenIdentifier);
  encrBuilder.setCustomValueType(WSConstants.WSS_USERNAME_TOKEN_VALUE_TYPE);
  Document encryptedDoc=encrBuilder.build(doc,secHeader);
  builder.prependToHeader(secHeader);
  String outputString=XMLUtils.prettyDocumentToString(encryptedDoc);
  assertTrue(outputString.contains("wsse:Username"));
  assertFalse(outputString.contains("wsse:Password"));
  assertTrue(outputString.contains("wsse11:Salt"));
  assertTrue(outputString.contains("wsse11:Iteration"));
  assertFalse(outputString.contains("testMethod"));
  if (LOG.isDebugEnabled()) {
    LOG.debug(outputString);
  }
  try {
    verify(encryptedDoc);
    fail("Failure expected on a bad derived encryption");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.FAILED_CHECK);
  }
}

</code></pre>

<br>
<pre class="type-3 type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Unit test for creating a Username Token with an iteration value < 1000 that is used for
 * deriving a key for encryption.
 */
@Test public void testLowIterationEncryption() throws Exception {
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  UsernameToken usernameToken=new UsernameToken(true,doc,null);
  usernameToken.setName("bob");
  WSSConfig config=WSSConfig.getNewInstance();
  usernameToken.setID(config.getIdAllocator().createId("UsernameToken-",usernameToken));
  usernameToken.addIteration(doc,500);
  byte[] salt=usernameToken.addSalt(doc,null,false);
  byte[] derivedKey=UsernameTokenUtil.generateDerivedKey("security",salt,500);
  WSSecDKEncrypt encrBuilder=new WSSecDKEncrypt();
  encrBuilder.setSymmetricEncAlgorithm(WSConstants.AES_128);
  encrBuilder.setExternalKey(derivedKey,usernameToken.getID());
  encrBuilder.setCustomValueType(WSConstants.WSS_USERNAME_TOKEN_VALUE_TYPE);
  Document encryptedDoc=encrBuilder.build(doc,secHeader);
  WSSecurityUtil.prependChildElement(secHeader.getSecurityHeader(),usernameToken.getElement());
  String outputString=XMLUtils.prettyDocumentToString(doc);
  assertTrue(outputString.contains("wsse:Username"));
  assertFalse(outputString.contains("wsse:Password"));
  assertTrue(outputString.contains("wsse11:Salt"));
  assertTrue(outputString.contains("wsse11:Iteration"));
  if (LOG.isDebugEnabled()) {
    LOG.debug(outputString);
  }
  try {
    verify(encryptedDoc);
    fail("Failure expected on a low iteration value");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.INVALID_SECURITY);
  }
  RequestData data=new RequestData();
  data.setCallbackHandler(callbackHandler);
  data.setDecCrypto(crypto);
  data.setIgnoredBSPRules(Collections.singletonList(BSPRule.R4218));
  data.setAllowUsernameTokenNoPassword(true);
  WSSecurityEngine engine=new WSSecurityEngine();
  engine.setWssConfig(config);
  engine.processSecurityHeader(doc,data);
}

</code></pre>

<br>
<pre class="type-8 type-7 type-5 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test using a UsernameToken derived key for signing a SOAP body. In this test the
 * user is "colm" rather than "bob", and so signature verification should fail.
 */
@Test public void testDerivedKeyBadUserSignature() throws Exception {
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  WSSecUsernameToken builder=new WSSecUsernameToken();
  builder.setUserInfo("colm","security");
  builder.addDerivedKey(true,null,1000);
  builder.prepare(doc);
  byte[] derivedKey=builder.getDerivedKey();
  assertTrue(derivedKey.length == 20);
  String tokenIdentifier=builder.getId();
  WSSecDKSign sigBuilder=new WSSecDKSign();
  sigBuilder.setExternalKey(derivedKey,tokenIdentifier);
  sigBuilder.setSignatureAlgorithm(WSConstants.HMAC_SHA1);
  sigBuilder.setCustomValueType(WSConstants.WSS_USERNAME_TOKEN_VALUE_TYPE);
  Document signedDoc=sigBuilder.build(doc,secHeader);
  builder.prependToHeader(secHeader);
  String outputString=XMLUtils.prettyDocumentToString(signedDoc);
  if (LOG.isDebugEnabled()) {
    LOG.debug(outputString);
  }
  try {
    verify(signedDoc);
    fail("Failure expected on a bad derived signature");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.FAILED_AUTHENTICATION);
  }
}

</code></pre>

<br>
<pre class="type-3 type-8 type-7 type-5 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test using a UsernameToken derived key for encrypting a SOAP body. The Reference to the
 * UsernameToken contains a non-standard value type, which is rejected when the corresponding
 * BSP rule is turned on.
 */
@Test public void testBadValueType() throws Exception {
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  WSSecUsernameToken builder=new WSSecUsernameToken();
  builder.setUserInfo("bob","security");
  builder.addDerivedKey(false,null,1000);
  builder.prepare(doc);
  byte[] derivedKey=builder.getDerivedKey();
  assertTrue(derivedKey.length == 20);
  String tokenIdentifier=builder.getId();
  WSSecDKEncrypt encrBuilder=new WSSecDKEncrypt();
  encrBuilder.setSymmetricEncAlgorithm(WSConstants.AES_128);
  encrBuilder.setExternalKey(derivedKey,tokenIdentifier);
  encrBuilder.setCustomValueType(WSConstants.WSS_SAML_TOKEN_TYPE);
  Document encryptedDoc=encrBuilder.build(doc,secHeader);
  builder.prependToHeader(secHeader);
  String outputString=XMLUtils.prettyDocumentToString(encryptedDoc);
  assertTrue(outputString.contains("wsse:Username"));
  assertFalse(outputString.contains("wsse:Password"));
  assertTrue(outputString.contains("wsse11:Salt"));
  assertTrue(outputString.contains("wsse11:Iteration"));
  assertFalse(outputString.contains("testMethod"));
  if (LOG.isDebugEnabled()) {
    LOG.debug(outputString);
  }
  try {
    verify(encryptedDoc);
    fail("Failure expected on a bad value type");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.INVALID_SECURITY);
  }
  RequestData data=new RequestData();
  data.setCallbackHandler(callbackHandler);
  data.setDecCrypto(crypto);
  data.setAllowUsernameTokenNoPassword(true);
  WSSConfig config=WSSConfig.getNewInstance();
  WSSecurityEngine newEngine=new WSSecurityEngine();
  newEngine.setWssConfig(config);
  data.setIgnoredBSPRules(Collections.singletonList(BSPRule.R4214));
  newEngine.processSecurityHeader(encryptedDoc,data);
}

</code></pre>

<br>
<pre class="type-3 type-8 type-7 type-5 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test using a UsernameToken derived key for encrypting a SOAP body. In this test the
 * user is "colm" rather than "bob", and so decryption should fail.
 */
@Test public void testDerivedKeyBadUserEncryption() throws Exception {
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  WSSecUsernameToken builder=new WSSecUsernameToken();
  builder.setUserInfo("colm","security");
  builder.addDerivedKey(false,null,1000);
  builder.prepare(doc);
  byte[] derivedKey=builder.getDerivedKey();
  assertTrue(derivedKey.length == 20);
  String tokenIdentifier=builder.getId();
  WSSecDKEncrypt encrBuilder=new WSSecDKEncrypt();
  encrBuilder.setSymmetricEncAlgorithm(WSConstants.AES_128);
  encrBuilder.setExternalKey(derivedKey,tokenIdentifier);
  encrBuilder.setCustomValueType(WSConstants.WSS_USERNAME_TOKEN_VALUE_TYPE);
  Document encryptedDoc=encrBuilder.build(doc,secHeader);
  builder.prependToHeader(secHeader);
  String outputString=XMLUtils.prettyDocumentToString(encryptedDoc);
  assertTrue(outputString.contains("wsse:Username"));
  assertFalse(outputString.contains("wsse:Password"));
  assertTrue(outputString.contains("wsse11:Salt"));
  assertTrue(outputString.contains("wsse11:Iteration"));
  assertFalse(outputString.contains("testMethod"));
  if (LOG.isDebugEnabled()) {
    LOG.debug(outputString);
  }
  try {
    verify(encryptedDoc);
    fail("Failure expected on a bad derived encryption");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.FAILED_AUTHENTICATION);
  }
}

</code></pre>

<br>
<pre class="type-3 type-8 type-7 type-5 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test using a UsernameToken derived key for encrypting a SOAP body
 */
@Test public void testDerivedKeyEncryption() throws Exception {
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  WSSecUsernameToken builder=new WSSecUsernameToken();
  builder.setUserInfo("bob","security");
  builder.addDerivedKey(false,null,1000);
  builder.prepare(doc);
  byte[] derivedKey=builder.getDerivedKey();
  assertTrue(derivedKey.length == 20);
  String tokenIdentifier=builder.getId();
  WSSecDKEncrypt encrBuilder=new WSSecDKEncrypt();
  encrBuilder.setSymmetricEncAlgorithm(WSConstants.AES_128);
  encrBuilder.setExternalKey(derivedKey,tokenIdentifier);
  encrBuilder.setCustomValueType(WSConstants.WSS_USERNAME_TOKEN_VALUE_TYPE);
  Document encryptedDoc=encrBuilder.build(doc,secHeader);
  builder.prependToHeader(secHeader);
  String outputString=XMLUtils.prettyDocumentToString(encryptedDoc);
  assertTrue(outputString.contains("wsse:Username"));
  assertFalse(outputString.contains("wsse:Password"));
  assertTrue(outputString.contains("wsse11:Salt"));
  assertTrue(outputString.contains("wsse11:Iteration"));
  assertFalse(outputString.contains("testMethod"));
  if (LOG.isDebugEnabled()) {
    LOG.debug(outputString);
  }
  verify(encryptedDoc);
  try {
    verify(encryptedDoc,false);
    fail("Failure expected on deriving keys from a UsernameToken not allowed");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.FAILED_AUTHENTICATION);
  }
}

</code></pre>

<br>
<pre class="type-3 type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Unit test for creating a Username Token with no iteration element that is used for
 * deriving a key for encryption.
 */
@Test public void testNoIterationEncryption() throws Exception {
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  UsernameToken usernameToken=new UsernameToken(true,doc,null);
  usernameToken.setName("bob");
  WSSConfig config=WSSConfig.getNewInstance();
  usernameToken.setID(config.getIdAllocator().createId("UsernameToken-",usernameToken));
  byte[] salt=usernameToken.addSalt(doc,null,false);
  byte[] derivedKey=UsernameTokenUtil.generateDerivedKey("security",salt,1000);
  WSSecDKEncrypt encrBuilder=new WSSecDKEncrypt();
  encrBuilder.setSymmetricEncAlgorithm(WSConstants.AES_128);
  encrBuilder.setExternalKey(derivedKey,usernameToken.getID());
  encrBuilder.setCustomValueType(WSConstants.WSS_USERNAME_TOKEN_VALUE_TYPE);
  Document encryptedDoc=encrBuilder.build(doc,secHeader);
  WSSecurityUtil.prependChildElement(secHeader.getSecurityHeader(),usernameToken.getElement());
  String outputString=XMLUtils.prettyDocumentToString(doc);
  assertTrue(outputString.contains("wsse:Username"));
  assertFalse(outputString.contains("wsse:Password"));
  assertTrue(outputString.contains("wsse11:Salt"));
  assertFalse(outputString.contains("wsse11:Iteration"));
  if (LOG.isDebugEnabled()) {
    LOG.debug(outputString);
  }
  try {
    verify(encryptedDoc);
    fail("Failure expected on no iteration element");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.INVALID_SECURITY_TOKEN);
  }
}

</code></pre>

<br>
<pre class="type-3 type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Unit test for creating a Username Token with no salt element that is used for
 * deriving a key for encryption.
 */
@Test public void testNoSaltEncryption() throws Exception {
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  UsernameToken usernameToken=new UsernameToken(true,doc,null);
  usernameToken.setName("bob");
  WSSConfig config=WSSConfig.getNewInstance();
  usernameToken.setID(config.getIdAllocator().createId("UsernameToken-",usernameToken));
  byte[] salt=UsernameTokenUtil.generateSalt(false);
  usernameToken.addIteration(doc,1000);
  byte[] derivedKey=UsernameTokenUtil.generateDerivedKey("security",salt,1000);
  WSSecDKEncrypt encrBuilder=new WSSecDKEncrypt();
  encrBuilder.setSymmetricEncAlgorithm(WSConstants.AES_128);
  encrBuilder.setExternalKey(derivedKey,usernameToken.getID());
  encrBuilder.setCustomValueType(WSConstants.WSS_USERNAME_TOKEN_VALUE_TYPE);
  Document encryptedDoc=encrBuilder.build(doc,secHeader);
  WSSecurityUtil.prependChildElement(secHeader.getSecurityHeader(),usernameToken.getElement());
  String outputString=XMLUtils.prettyDocumentToString(doc);
  assertTrue(outputString.contains("wsse:Username"));
  assertFalse(outputString.contains("wsse:Password"));
  assertFalse(outputString.contains("wsse11:Salt"));
  assertTrue(outputString.contains("wsse11:Iteration"));
  if (LOG.isDebugEnabled()) {
    LOG.debug(outputString);
  }
  try {
    verify(encryptedDoc);
    fail("Failure expected on no salt element");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.FAILURE);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test using a UsernameToken derived key for signing a SOAP body. In this test the
 * derived key is modified before signature, and so signature verification should
 * fail.
 */
@Test public void testDerivedKeyChangedSignature() throws Exception {
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  WSSecUsernameToken builder=new WSSecUsernameToken();
  builder.setUserInfo("bob","security");
  builder.addDerivedKey(true,null,1000);
  builder.prepare(doc);
  byte[] derivedKey=builder.getDerivedKey();
  if (derivedKey[5] != 12) {
    derivedKey[5]=12;
  }
 else {
    derivedKey[5]=13;
  }
  assertTrue(derivedKey.length == 20);
  String tokenIdentifier=builder.getId();
  WSSecDKSign sigBuilder=new WSSecDKSign();
  sigBuilder.setExternalKey(derivedKey,tokenIdentifier);
  sigBuilder.setSignatureAlgorithm(WSConstants.HMAC_SHA1);
  sigBuilder.setCustomValueType(WSConstants.WSS_USERNAME_TOKEN_VALUE_TYPE);
  Document signedDoc=sigBuilder.build(doc,secHeader);
  builder.prependToHeader(secHeader);
  String outputString=XMLUtils.prettyDocumentToString(signedDoc);
  if (LOG.isDebugEnabled()) {
    LOG.debug(outputString);
  }
  try {
    verify(signedDoc);
    fail("Failure expected on a bad derived signature");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.FAILED_CHECK);
  }
}

</code></pre>

<br>
<pre class="type-3 type-8 type-7 type-5 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test using a UsernameToken derived key for encrypting a SOAP body. A KeyIdentifier is
 * used to refer to the UsernameToken, which is forbidden by the BSP.
 */
@Test public void testKeyIdentifier() throws Exception {
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  WSSecUsernameToken builder=new WSSecUsernameToken();
  builder.setUserInfo("bob","security");
  builder.addDerivedKey(false,null,1000);
  builder.prepare(doc);
  byte[] derivedKey=builder.getDerivedKey();
  assertTrue(derivedKey.length == 20);
  String tokenIdentifier=builder.getId();
  WSSecDKEncrypt encrBuilder=new WSSecDKEncrypt();
  encrBuilder.setSymmetricEncAlgorithm(WSConstants.AES_128);
  SecurityTokenReference strEncKey=new SecurityTokenReference(doc);
  strEncKey.setKeyIdentifier(WSConstants.WSS_USERNAME_TOKEN_VALUE_TYPE,tokenIdentifier,true);
  encrBuilder.setExternalKey(derivedKey,strEncKey.getElement());
  Document encryptedDoc=encrBuilder.build(doc,secHeader);
  builder.prependToHeader(secHeader);
  String outputString=XMLUtils.prettyDocumentToString(encryptedDoc);
  assertTrue(outputString.contains("wsse:Username"));
  assertFalse(outputString.contains("wsse:Password"));
  assertTrue(outputString.contains("wsse11:Salt"));
  assertTrue(outputString.contains("wsse11:Iteration"));
  assertFalse(outputString.contains("testMethod"));
  if (LOG.isDebugEnabled()) {
    LOG.debug(outputString);
  }
  try {
    verify(encryptedDoc);
    fail("Failure expected on a key identifier");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.INVALID_SECURITY);
  }
  WSSecurityEngine newEngine=new WSSecurityEngine();
  RequestData data=new RequestData();
  data.setCallbackHandler(callbackHandler);
  data.setDecCrypto(crypto);
  data.setIgnoredBSPRules(Collections.singletonList(BSPRule.R4215));
  data.setAllowUsernameTokenNoPassword(true);
  WSSConfig config=WSSConfig.getNewInstance();
  newEngine.setWssConfig(config);
  newEngine.processSecurityHeader(encryptedDoc,data);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.wss4j.dom.message.UTSignatureTest </h4><pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test using a UsernameToken derived key for signing a SOAP body. In this test the
 * user is "colm" rather than "bob", and so signature verification should fail.
 */
@Test public void testBadUserSignature() throws Exception {
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  WSSecUsernameToken builder=new WSSecUsernameToken();
  builder.setUserInfo("colm","security");
  builder.addDerivedKey(true,null,1000);
  builder.prepare(doc);
  WSSecSignature sign=new WSSecSignature();
  sign.setCustomTokenValueType(WSConstants.USERNAMETOKEN_NS + "#UsernameToken");
  sign.setCustomTokenId(builder.getId());
  sign.setSecretKey(builder.getDerivedKey());
  sign.setKeyIdentifierType(WSConstants.CUSTOM_SYMM_SIGNING);
  sign.setSignatureAlgorithm(WSConstants.HMAC_SHA1);
  Document signedDoc=sign.build(doc,null,secHeader);
  builder.prependToHeader(secHeader);
  String outputString=XMLUtils.prettyDocumentToString(signedDoc);
  if (LOG.isDebugEnabled()) {
    LOG.debug(outputString);
  }
  try {
    verify(signedDoc);
    fail("Failure expected on a bad derived signature");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.FAILED_AUTHENTICATION);
  }
}

</code></pre>

<br>
<pre class="type-3 type-8 type-7 type-5 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test using a UsernameToken derived key for signing a SOAP body
 */
@Test public void testSignature() throws Exception {
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  WSSecUsernameToken builder=new WSSecUsernameToken();
  builder.setUserInfo("bob","security");
  builder.addDerivedKey(true,null,1000);
  builder.prepare(doc);
  WSSecSignature sign=new WSSecSignature();
  sign.setCustomTokenValueType(WSConstants.USERNAMETOKEN_NS + "#UsernameToken");
  sign.setCustomTokenId(builder.getId());
  sign.setSecretKey(builder.getDerivedKey());
  sign.setKeyIdentifierType(WSConstants.CUSTOM_SYMM_SIGNING);
  sign.setSignatureAlgorithm(WSConstants.HMAC_SHA1);
  Document signedDoc=sign.build(doc,null,secHeader);
  builder.prependToHeader(secHeader);
  String outputString=XMLUtils.prettyDocumentToString(signedDoc);
  assertTrue(outputString.contains("wsse:Username"));
  assertFalse(outputString.contains("wsse:Password"));
  assertTrue(outputString.contains("wsse11:Salt"));
  assertTrue(outputString.contains("wsse11:Iteration"));
  if (LOG.isDebugEnabled()) {
    LOG.debug(outputString);
  }
  WSHandlerResult results=verify(signedDoc);
  WSSecurityEngineResult actionResult=results.getActionResults().get(WSConstants.UT_SIGN).get(0);
  java.security.Principal principal=(java.security.Principal)actionResult.get(WSSecurityEngineResult.TAG_PRINCIPAL);
  assertTrue(principal.getName().contains("bob"));
  try {
    verify(signedDoc,false);
    fail("Failure expected on deriving keys from a UsernameToken not allowed");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.FAILED_AUTHENTICATION);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.wss4j.dom.message.UsernameTokenTest </h4><pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * This is a test for processing a UsernameToken where the "Created" element is in the (near)
 * future. It should be accepted by default when it is created 30 seconds in the future,
 * and then rejected once we configure "0 seconds" for future-time-to-live.
 */
@Test public void testNearFutureCreated() throws Exception {
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  Element usernameTokenElement=doc.createElementNS(WSConstants.WSSE_NS,WSConstants.WSSE_PREFIX + ":" + WSConstants.USERNAME_TOKEN_LN);
  Element usernameElement=doc.createElementNS(WSConstants.WSSE_NS,WSConstants.WSSE_PREFIX + ":" + WSConstants.USERNAME_LN);
  usernameElement.appendChild(doc.createTextNode("wernerd"));
  usernameTokenElement.appendChild(usernameElement);
  Element passwordElement=doc.createElementNS(WSConstants.WSSE_NS,WSConstants.WSSE_PREFIX + ":" + WSConstants.PASSWORD_LN);
  passwordElement.setAttributeNS(null,"Type",WSConstants.PASSWORD_TEXT);
  passwordElement.appendChild(doc.createTextNode("verySecret"));
  usernameTokenElement.appendChild(passwordElement);
  Element elementCreated=doc.createElementNS(WSConstants.WSU_NS,WSConstants.WSU_PREFIX + ":" + WSConstants.CREATED_LN);
  DateFormat zulu=new XmlSchemaDateFormat();
  Date createdDate=new Date();
  long currentTime=createdDate.getTime() + 30000;
  createdDate.setTime(currentTime);
  elementCreated.appendChild(doc.createTextNode(zulu.format(createdDate)));
  usernameTokenElement.appendChild(elementCreated);
  secHeader.getSecurityHeader().appendChild(usernameTokenElement);
  if (LOG.isDebugEnabled()) {
    String outputString=XMLUtils.prettyDocumentToString(doc);
    LOG.debug(outputString);
  }
  WSSecurityEngine secEngine=new WSSecurityEngine();
  secEngine.processSecurityHeader(doc,null,callbackHandler,null);
  try {
    RequestData requestData=new RequestData();
    requestData.setUtFutureTTL(0);
    requestData.setCallbackHandler(callbackHandler);
    secEngine.processSecurityHeader(doc,requestData);
    fail("The UsernameToken validation should have failed");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.MESSAGE_EXPIRED);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test that adds a UserNameToken with a bad password Digest to a WS-Security envelope
 */
@Test public void testUsernameTokenBadDigest() throws Exception {
  WSSecUsernameToken builder=new WSSecUsernameToken();
  builder.setUserInfo("wernerd","verySecre");
  LOG.info("Before adding UsernameToken PW Digest....");
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  Document signedDoc=builder.build(doc,secHeader);
  if (LOG.isDebugEnabled()) {
    LOG.debug("Message with UserNameToken PW Digest:");
    String outputString=XMLUtils.prettyDocumentToString(signedDoc);
    LOG.debug(outputString);
  }
  LOG.info("After adding UsernameToken PW Digest....");
  try {
    verify(signedDoc);
    fail("Failure expected on a bad password digest");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.FAILED_AUTHENTICATION);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test that adds a UserNameToken with no password type to a WS-Security envelope
 * See WSS-152 - https://issues.apache.org/jira/browse/WSS-152
 * "Problem with processing Username Tokens with no password type"
 * The 1.1 spec states that the password type is optional and defaults to password text,
 * and so we should handle an incoming Username Token accordingly.
 */
@Test public void testUsernameTokenNoPasswordType() throws Exception {
  Document doc=SOAPUtil.toSOAPPart(SOAPUTMSG);
  if (LOG.isDebugEnabled()) {
    String outputString=XMLUtils.prettyDocumentToString(doc);
    LOG.debug(outputString);
  }
  WSSecurityEngine newEngine=new WSSecurityEngine();
  try {
    newEngine.processSecurityHeader(doc,null,callbackHandler,null);
    fail("Expected failure as it is not BSP compliant");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.INVALID_SECURITY);
  }
  RequestData data=new RequestData();
  data.setCallbackHandler(callbackHandler);
  data.setIgnoredBSPRules(Collections.singletonList(BSPRule.R4201));
  newEngine.processSecurityHeader(doc,data);
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * A test for WSS-66 - the created string is null
 * http://issues.apache.org/jira/browse/WSS-66
 * "Possible security hole when PasswordDigest is used by client."
 */
@Test public void testNullCreated() throws Exception {
  WSSecUsernameToken builder=new WSSecUsernameToken();
  builder.setPasswordType(WSConstants.PASSWORD_DIGEST);
  builder.setUserInfo("wernerd","BAD_PASSWORD");
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  Document utDoc=builder.build(doc,secHeader);
  Element elem=builder.getUsernameTokenElement();
  NodeList list=elem.getElementsByTagNameNS(WSConstants.WSU_NS,"Created");
  Node nonceNode=list.item(0);
  Node childNode=nonceNode.getFirstChild();
  childNode.setNodeValue("");
  if (LOG.isDebugEnabled()) {
    String outputString=XMLUtils.prettyDocumentToString(utDoc);
    LOG.debug(outputString);
  }
  try {
    verify(utDoc);
    fail("Expected failure due to a bad password");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.FAILED_AUTHENTICATION);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-5 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test that a bad username with password digest does not leak whether the username
 * is valid or not - see WSS-141.
 */
@Test public void testUsernameTokenBadUsername() throws Exception {
  WSSecUsernameToken builder=new WSSecUsernameToken();
  builder.setUserInfo("badusername","verySecret");
  LOG.info("Before adding UsernameToken PW Digest....");
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  Document signedDoc=builder.build(doc,secHeader);
  if (LOG.isDebugEnabled()) {
    LOG.debug("Message with UserNameToken PW Digest:");
    String outputString=XMLUtils.prettyDocumentToString(signedDoc);
    LOG.debug(outputString);
  }
  LOG.info("After adding UsernameToken PW Digest....");
  try {
    verify(signedDoc);
    fail("Failure expected on a bad username");
  }
 catch (  WSSecurityException ex) {
    String message=ex.getMessage();
    assertFalse(message.contains("badusername"));
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.FAILED_AUTHENTICATION);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test that adds a UserNameToken with no user (or password) to a WS-Security envelope
 * See WSS-185 - https://issues.apache.org/jira/browse/WSS-185
 * "NullPointerException on empty UsernameToken"
 */
@Test public void testUsernameTokenNoUser() throws Exception {
  Document doc=SOAPUtil.toSOAPPart(SOAPUTNOUSERMSG);
  if (LOG.isDebugEnabled()) {
    String outputString=XMLUtils.prettyDocumentToString(doc);
    LOG.debug(outputString);
  }
  try {
    verify(doc);
    fail("Failure expected on no password");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.FAILED_AUTHENTICATION);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test that adds a UserNameToken with (bad) password text to a WS-Security envelope
 */
@Test public void testUsernameTokenBadText() throws Exception {
  WSSecUsernameToken builder=new WSSecUsernameToken();
  builder.setPasswordType(WSConstants.PASSWORD_TEXT);
  builder.setUserInfo("wernerd","verySecre");
  LOG.info("Before adding UsernameToken PW Text....");
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  Document signedDoc=builder.build(doc,secHeader);
  if (LOG.isDebugEnabled()) {
    LOG.debug("Message with UserNameToken PW Text:");
    String outputString=XMLUtils.prettyDocumentToString(signedDoc);
    LOG.debug(outputString);
  }
  LOG.info("After adding UsernameToken PW Text....");
  try {
    verify(signedDoc);
    fail("Failure expected on a bad password text");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.FAILED_AUTHENTICATION);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * A test for sending multiple passwords in the UsernameToken
 */
@Test public void testMultiplePassword() throws Exception {
  WSSecUsernameToken builder=new WSSecUsernameToken();
  builder.setPasswordType(WSConstants.PASSWORD_DIGEST);
  builder.setUserInfo("wernerd","verySecret");
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  Document utDoc=builder.build(doc,secHeader);
  Element elem=builder.getUsernameTokenElement();
  NodeList list=elem.getElementsByTagNameNS(WSConstants.WSSE_NS,"Password");
  Node passwordNode=list.item(0);
  Node passwordCopy=passwordNode.cloneNode(true);
  passwordNode.getParentNode().insertBefore(passwordCopy,passwordNode);
  if (LOG.isDebugEnabled()) {
    String outputString=XMLUtils.prettyDocumentToString(utDoc);
    LOG.debug(outputString);
  }
  WSSecurityEngine newEngine=new WSSecurityEngine();
  try {
    newEngine.processSecurityHeader(doc,null,callbackHandler,null);
    fail("Expected failure as it is not BSP compliant");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.INVALID_SECURITY);
  }
  RequestData data=new RequestData();
  data.setCallbackHandler(callbackHandler);
  data.setIgnoredBSPRules(Collections.singletonList(BSPRule.R4222));
  newEngine.processSecurityHeader(doc,data);
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * This is a test to create a "Spoofed" UsernameToken (see WSS-441)
 */
@Test public void testSpoofedUsernameToken() throws Exception {
  WSSecUsernameToken builder=new WSSecUsernameToken();
  builder.setUserInfo("wernerd","verySecret");
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  WSTimeSource spoofedTimeSource=new WSTimeSource(){
    public Date now(){
      Date currentTime=new Date();
      currentTime.setTime(currentTime.getTime() - (500L * 1000L));
      return currentTime;
    }
  }
;
  builder.setWsTimeSource(spoofedTimeSource);
  Document signedDoc=builder.build(doc,secHeader);
  if (LOG.isDebugEnabled()) {
    String outputString=XMLUtils.prettyDocumentToString(signedDoc);
    LOG.debug(outputString);
  }
  try {
    WSSecurityEngine secEngine=new WSSecurityEngine();
    secEngine.processSecurityHeader(doc,null,callbackHandler,null);
    fail("The UsernameToken validation should have failed");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.MESSAGE_EXPIRED);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * A test for sending multiple nonces in the UsernameToken
 */
@Test public void testMultipleNonce() throws Exception {
  WSSecUsernameToken builder=new WSSecUsernameToken();
  builder.setPasswordType(WSConstants.PASSWORD_DIGEST);
  builder.setUserInfo("wernerd","verySecret");
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  Document utDoc=builder.build(doc,secHeader);
  Element elem=builder.getUsernameTokenElement();
  NodeList list=elem.getElementsByTagNameNS(WSConstants.WSSE_NS,"Nonce");
  Node nonceNode=list.item(0);
  Node nonceCopy=nonceNode.cloneNode(true);
  nonceNode.getParentNode().insertBefore(nonceCopy,nonceNode);
  if (LOG.isDebugEnabled()) {
    String outputString=XMLUtils.prettyDocumentToString(utDoc);
    LOG.debug(outputString);
  }
  WSSecurityEngine newEngine=new WSSecurityEngine();
  try {
    newEngine.processSecurityHeader(doc,null,callbackHandler,null);
    fail("Expected failure as it is not BSP compliant");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.INVALID_SECURITY);
  }
  RequestData data=new RequestData();
  data.setCallbackHandler(callbackHandler);
  data.setIgnoredBSPRules(Collections.singletonList(BSPRule.R4225));
  newEngine.processSecurityHeader(doc,data);
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * A test for sending multiple Created elements in the UsernameToken
 */
@Test public void testMultipleCreated() throws Exception {
  WSSecUsernameToken builder=new WSSecUsernameToken();
  builder.setPasswordType(WSConstants.PASSWORD_DIGEST);
  builder.setUserInfo("wernerd","verySecret");
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  Document utDoc=builder.build(doc,secHeader);
  Element elem=builder.getUsernameTokenElement();
  NodeList list=elem.getElementsByTagNameNS(WSConstants.WSU_NS,"Created");
  Node createdNode=list.item(0);
  Node createdCopy=createdNode.cloneNode(true);
  createdNode.getParentNode().insertBefore(createdCopy,createdNode);
  if (LOG.isDebugEnabled()) {
    String outputString=XMLUtils.prettyDocumentToString(utDoc);
    LOG.debug(outputString);
  }
  WSSecurityEngine newEngine=new WSSecurityEngine();
  try {
    newEngine.processSecurityHeader(doc,null,callbackHandler,null);
    fail("Expected failure as it is not BSP compliant");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.INVALID_SECURITY);
  }
  RequestData data=new RequestData();
  data.setCallbackHandler(callbackHandler);
  data.setIgnoredBSPRules(Collections.singletonList(BSPRule.R4223));
  newEngine.processSecurityHeader(doc,data);
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * A test for WSS-66 - the nonce string is null
 * http://issues.apache.org/jira/browse/WSS-66
 * "Possible security hole when PasswordDigest is used by client."
 */
@Test public void testNullNonce() throws Exception {
  WSSecUsernameToken builder=new WSSecUsernameToken();
  builder.setPasswordType(WSConstants.PASSWORD_DIGEST);
  builder.setUserInfo("wernerd","BAD_PASSWORD");
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  Document utDoc=builder.build(doc,secHeader);
  Element elem=builder.getUsernameTokenElement();
  NodeList list=elem.getElementsByTagNameNS(WSConstants.WSSE_NS,"Nonce");
  Node nonceNode=list.item(0);
  Node childNode=nonceNode.getFirstChild();
  childNode.setNodeValue("");
  if (LOG.isDebugEnabled()) {
    String outputString=XMLUtils.prettyDocumentToString(utDoc);
    LOG.debug(outputString);
  }
  try {
    verify(utDoc);
    fail("Expected failure due to a bad password");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.FAILED_AUTHENTICATION);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * This is a test for processing a UsernameToken where the "Created" element is in the future.
 * A UsernameToken that is 120 seconds in the future should be rejected by default.
 */
@Test public void testFutureCreated() throws Exception {
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  Element usernameTokenElement=doc.createElementNS(WSConstants.WSSE_NS,WSConstants.WSSE_PREFIX + ":" + WSConstants.USERNAME_TOKEN_LN);
  Element usernameElement=doc.createElementNS(WSConstants.WSSE_NS,WSConstants.WSSE_PREFIX + ":" + WSConstants.USERNAME_LN);
  usernameElement.appendChild(doc.createTextNode("wernerd"));
  usernameTokenElement.appendChild(usernameElement);
  Element passwordElement=doc.createElementNS(WSConstants.WSSE_NS,WSConstants.WSSE_PREFIX + ":" + WSConstants.PASSWORD_LN);
  passwordElement.setAttributeNS(null,"Type",WSConstants.PASSWORD_TEXT);
  passwordElement.appendChild(doc.createTextNode("verySecret"));
  usernameTokenElement.appendChild(passwordElement);
  Element elementCreated=doc.createElementNS(WSConstants.WSU_NS,WSConstants.WSU_PREFIX + ":" + WSConstants.CREATED_LN);
  DateFormat zulu=new XmlSchemaDateFormat();
  Date createdDate=new Date();
  long currentTime=createdDate.getTime() + 120000;
  createdDate.setTime(currentTime);
  elementCreated.appendChild(doc.createTextNode(zulu.format(createdDate)));
  usernameTokenElement.appendChild(elementCreated);
  secHeader.getSecurityHeader().appendChild(usernameTokenElement);
  if (LOG.isDebugEnabled()) {
    String outputString=XMLUtils.prettyDocumentToString(doc);
    LOG.debug(outputString);
  }
  try {
    WSSecurityEngine secEngine=new WSSecurityEngine();
    secEngine.processSecurityHeader(doc,null,callbackHandler,null);
    fail("The UsernameToken validation should have failed");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.MESSAGE_EXPIRED);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * A test for sending a nonce with a bad encoding type in the UsernameToken
 */
@Test public void testNonceBadEncodingType() throws Exception {
  WSSecUsernameToken builder=new WSSecUsernameToken();
  builder.setPasswordType(WSConstants.PASSWORD_DIGEST);
  builder.setUserInfo("wernerd","verySecret");
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  Document utDoc=builder.build(doc,secHeader);
  Element elem=builder.getUsernameTokenElement();
  NodeList list=elem.getElementsByTagNameNS(WSConstants.WSSE_NS,"Nonce");
  Node nonceNode=list.item(0);
  ((Element)nonceNode).setAttributeNS(null,"EncodingType","http://bad_encoding_type");
  if (LOG.isDebugEnabled()) {
    String outputString=XMLUtils.prettyDocumentToString(utDoc);
    LOG.debug(outputString);
  }
  WSSecurityEngine newEngine=new WSSecurityEngine();
  try {
    newEngine.processSecurityHeader(doc,null,callbackHandler,null);
    fail("Expected failure as it is not BSP compliant");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.INVALID_SECURITY);
  }
  RequestData data=new RequestData();
  data.setCallbackHandler(callbackHandler);
  data.setIgnoredBSPRules(Collections.singletonList(BSPRule.R4221));
  newEngine.processSecurityHeader(doc,data);
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * This is a test for processing an "old" UsernameToken, i.e. one with a "Created" element that is
 * out of date
 */
@Test public void testOldUsernameToken() throws Exception {
  WSSecUsernameToken builder=new WSSecUsernameToken();
  builder.setUserInfo("wernerd","verySecret");
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  Document signedDoc=builder.build(doc,secHeader);
  if (LOG.isDebugEnabled()) {
    String outputString=XMLUtils.prettyDocumentToString(signedDoc);
    LOG.debug(outputString);
  }
  RequestData requestData=new RequestData();
  requestData.setUtTTL(-1);
  requestData.setCallbackHandler(callbackHandler);
  try {
    WSSecurityEngine secEngine=new WSSecurityEngine();
    secEngine.processSecurityHeader(doc,requestData);
    fail("The UsernameToken validation should have failed");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.MESSAGE_EXPIRED);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test with a non-standard token type. This will fail as the default is to reject custom
 * token types.
 */
@Test public void testUsernameTokenCustomFail() throws Exception {
  WSSecUsernameToken builder=new WSSecUsernameToken();
  builder.setPasswordType("RandomType");
  builder.setUserInfo("wernerd","verySecret");
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  Document signedDoc=builder.build(doc,secHeader);
  if (LOG.isDebugEnabled()) {
    LOG.debug("Message with UserNameToken PW Text:");
    String outputString=XMLUtils.prettyDocumentToString(signedDoc);
    LOG.debug(outputString);
  }
  try {
    WSSecurityEngine secEngine=new WSSecurityEngine();
    secEngine.processSecurityHeader(signedDoc,null,this,null);
    fail("Custom token types are not permitted");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.FAILED_AUTHENTICATION);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.wss4j.dom.message.token.BSTKerberosTest </h4><pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test Validating a Kerberos BinarySecurityToken using a custom Validator instance.
 */
@Test public void testProcessTokenCustomValidator() throws Exception {
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  BinarySecurity bst=new BinarySecurity(doc);
  bst.setValueType(AP_REQ);
  bst.setEncodingType(BASE64_NS);
  bst.setToken("12345678".getBytes());
  WSSecurityUtil.prependChildElement(secHeader.getSecurityHeader(),bst.getElement());
  if (LOG.isDebugEnabled()) {
    String outputString=XMLUtils.prettyDocumentToString(doc);
    LOG.debug(outputString);
  }
  WSSecurityEngine customEngine=new WSSecurityEngine();
  WSSConfig wssConfig=WSSConfig.getNewInstance();
  wssConfig.setValidator(WSConstants.BINARY_TOKEN,new KerberosValidator());
  customEngine.setWssConfig(wssConfig);
  customEngine.processSecurityHeader(doc,null,callbackHandler,crypto);
  bst.setToken("12345679".getBytes());
  try {
    customEngine.processSecurityHeader(doc,null,callbackHandler,crypto);
    fail("Failure expected on a bad token");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.FAILED_AUTHENTICATION);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.wss4j.dom.message.token.BinarySecurityTokenTest </h4><pre class="type-8 type-7 type-5 type-6 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * A unit test for a custom BinarySecurityToken
 */
@Test public void testCustomToken() throws Exception {
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  BinarySecurity bst=new BinarySecurity(doc);
  bst.setToken("12435677".getBytes());
  WSSecurityUtil.prependChildElement(secHeader.getSecurityHeader(),bst.getElement());
  if (LOG.isDebugEnabled()) {
    LOG.debug("Custom Token output");
    String outputString=XMLUtils.prettyDocumentToString(doc);
    LOG.debug(outputString);
  }
  WSSecurityEngine secEngine=new WSSecurityEngine();
  secEngine.setWssConfig(WSSConfig.getNewInstance());
  try {
    secEngine.processSecurityHeader(doc,null,null,crypto);
    fail("Expected failure on no ValueType");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.INVALID_SECURITY);
  }
  doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  bst=new BinarySecurity(doc);
  bst.setToken("12435677".getBytes());
  bst.setValueType("http://custom_value_Type");
  secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  WSSecurityUtil.prependChildElement(secHeader.getSecurityHeader(),bst.getElement());
  WSHandlerResult results=secEngine.processSecurityHeader(doc,null,null,crypto);
  WSSecurityEngineResult actionResult=results.getActionResults().get(WSConstants.BST).get(0);
  BinarySecurity token=(BinarySecurity)actionResult.get(WSSecurityEngineResult.TAG_BINARY_SECURITY_TOKEN);
  assertNotNull(token);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.wss4j.dom.message.token.ReferenceTest </h4><pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testConstructor() throws Exception {
  try {
    new Reference((org.w3c.dom.Element)null);
    fail("Expected failure on null Element passed to ctor");
  }
 catch (  final WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.INVALID_SECURITY);
  }
  try {
    new Reference(createReferenceDocument(BOGUS_REFERENCE_TEMPLATE,"foo","bar").getDocumentElement());
    fail("Expected failure on bogus template");
  }
 catch (  final WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.FAILURE);
  }
  new Reference(createReferenceDocument(TEST_REFERENCE_TEMPLATE,"foo","bar"));
  new Reference(createReferenceDocument(TEST_REFERENCE_TEMPLATE,"foo","bar").getDocumentElement());
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.wss4j.dom.message.token.SecurityTokenReferenceTest </h4><pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test for a SecurityTokenReference having an Embedded Child, which in turn has a
 * SecurityTokenReference child.
 */
@Test public void testEmbeddedSTRChild() throws Exception {
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  SecurityTokenReference str=new SecurityTokenReference(doc);
  str.addWSSENamespace();
  Element strElement=str.getElement();
  Element embedded=doc.createElementNS(WSConstants.WSSE_NS,"wsse:Embedded");
  str=new SecurityTokenReference(doc);
  str.addWSSENamespace();
  embedded.appendChild(str.getElement());
  strElement.appendChild(embedded);
  if (LOG.isDebugEnabled()) {
    LOG.debug(DOM2Writer.nodeToString(strElement));
  }
  BSPEnforcer bspEnforcer=new BSPEnforcer();
  try {
    new SecurityTokenReference(strElement,bspEnforcer);
    fail("Failure expected on an Embedded Child with a SecurityTokenReference child");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.INVALID_SECURITY);
  }
  bspEnforcer.setIgnoredBSPRules(Collections.singletonList(BSPRule.R3056));
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test for a SecurityTokenReference having a Key Identifier with a bad EncodingType
 */
@Test public void testKeyIdentifierBadEncodingType() throws Exception {
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  SecurityTokenReference str=new SecurityTokenReference(doc);
  str.addWSSENamespace();
  Element strElement=str.getElement();
  Element keyId=doc.createElementNS(WSConstants.WSSE_NS,"wsse:KeyIdentifier");
  keyId.setAttributeNS(null,"ValueType",SecurityTokenReference.ENC_KEY_SHA1_URI);
  keyId.setAttributeNS(null,"EncodingType","http://bad_encoding");
  keyId.appendChild(doc.createTextNode("#123"));
  strElement.appendChild(keyId);
  if (LOG.isDebugEnabled()) {
    LOG.debug(str.toString());
  }
  BSPEnforcer bspEnforcer=new BSPEnforcer();
  try {
    new SecurityTokenReference(strElement,bspEnforcer);
    fail("Failure expected on a Key Identifier with a Bad EncodingType");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.INVALID_SECURITY);
  }
  bspEnforcer.setIgnoredBSPRules(Collections.singletonList(BSPRule.R3071));
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test for a SecurityTokenReference having a Key Identifier with no EncodingType
 */
@Test public void testKeyIdentifierNoEncodingType() throws Exception {
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  SecurityTokenReference str=new SecurityTokenReference(doc);
  str.addWSSENamespace();
  Element strElement=str.getElement();
  Element keyId=doc.createElementNS(WSConstants.WSSE_NS,"wsse:KeyIdentifier");
  keyId.setAttributeNS(null,"ValueType",SecurityTokenReference.ENC_KEY_SHA1_URI);
  keyId.appendChild(doc.createTextNode("#123"));
  strElement.appendChild(keyId);
  if (LOG.isDebugEnabled()) {
    LOG.debug(str.toString());
  }
  BSPEnforcer bspEnforcer=new BSPEnforcer();
  try {
    new SecurityTokenReference(strElement,bspEnforcer);
    fail("Failure expected on a Key Identifier with no EncodingType");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.INVALID_SECURITY);
  }
  bspEnforcer.setIgnoredBSPRules(Collections.singletonList(BSPRule.R3070));
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test for a Reference with no URI
 */
@Test public void testReferenceNoURI() throws Exception {
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  SecurityTokenReference str=new SecurityTokenReference(doc);
  str.addWSSENamespace();
  Reference ref=new Reference(doc);
  ref.setValueType(WSConstants.WSS_ENC_KEY_VALUE_TYPE);
  ref.setURI(null);
  str.setReference(ref);
  if (LOG.isDebugEnabled()) {
    LOG.debug(str.toString());
  }
  Element strElement=str.getElement();
  try {
    new SecurityTokenReference(strElement,new BSPEnforcer(true));
    fail("Failure expected on a reference with no URI");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getMessage().contains("Reference URI is null"));
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test for a SecurityTokenReference having a Key Identifier with no ValueType
 */
@Test public void testKeyIdentifierNoValueType() throws Exception {
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  SecurityTokenReference str=new SecurityTokenReference(doc);
  str.addWSSENamespace();
  str.setKeyIdentifier(null,"#123");
  Element strElement=str.getElement();
  if (LOG.isDebugEnabled()) {
    LOG.debug(str.toString());
  }
  BSPEnforcer bspEnforcer=new BSPEnforcer();
  try {
    new SecurityTokenReference(strElement,bspEnforcer);
    fail("Failure expected on a Key Identifier with no ValueType");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.INVALID_SECURITY);
  }
  bspEnforcer.setIgnoredBSPRules(Collections.singletonList(BSPRule.R3054));
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test for a SecurityTokenReference having an Embedded Child, which has multiple
 * children.
 */
@Test public void testMultipleEmbeddedChildren() throws Exception {
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  SecurityTokenReference str=new SecurityTokenReference(doc);
  str.addWSSENamespace();
  Element strElement=str.getElement();
  Element embedded=doc.createElementNS(WSConstants.WSSE_NS,"wsse:Embedded");
  Element embedded1=doc.createElementNS(WSConstants.WSSE_NS,"wsse:Reference");
  Element embedded2=doc.createElementNS(WSConstants.WSSE_NS,"wsse:Reference");
  embedded.appendChild(embedded1);
  embedded.appendChild(embedded2);
  strElement.appendChild(embedded);
  if (LOG.isDebugEnabled()) {
    LOG.debug(DOM2Writer.nodeToString(strElement));
  }
  BSPEnforcer bspEnforcer=new BSPEnforcer();
  try {
    new SecurityTokenReference(strElement,bspEnforcer);
    fail("Failure expected on an Embedded Child with multiple children");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.INVALID_SECURITY);
  }
  bspEnforcer.setIgnoredBSPRules(Collections.singletonList(BSPRule.R3060));
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test for a SecurityTokenReference having multiple data references
 */
@Test public void testMultipleChildren() throws Exception {
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  SecurityTokenReference str=new SecurityTokenReference(doc);
  str.addWSSENamespace();
  str.setKeyIdentifierEncKeySHA1("123456");
  Element strElement=str.getElement();
  Reference ref=new Reference(doc);
  ref.setValueType(WSConstants.WSS_ENC_KEY_VALUE_TYPE);
  ref.setURI("#123");
  strElement.appendChild(ref.getElement());
  if (LOG.isDebugEnabled()) {
    LOG.debug(str.toString());
  }
  BSPEnforcer bspEnforcer=new BSPEnforcer();
  try {
    new SecurityTokenReference(strElement,bspEnforcer);
    fail("Failure expected on multiple data references");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.INVALID_SECURITY);
  }
  bspEnforcer.setIgnoredBSPRules(Collections.singletonList(BSPRule.R3061));
  new SecurityTokenReference(strElement,bspEnforcer);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.wss4j.dom.message.token.WCFUsernameTokenTest </h4><pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test that adds a UserNameToken with a namespace qualified type. This should fail
 * as WSS4J rejects these tokens by default.
 */
@Test public void testNamespaceQualifiedTypeRejected() throws Exception {
  Document doc=SOAPUtil.toSOAPPart(SOAPUTMSG);
  if (LOG.isDebugEnabled()) {
    LOG.debug("Message with UserNameToken PW Digest:");
    String outputString=XMLUtils.prettyDocumentToString(doc);
    LOG.debug(outputString);
  }
  try {
    verify(doc);
    fail("Failure expected on a bad password type");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.INVALID_SECURITY);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.wss4j.dom.misc.FaultCodeTest </h4><pre class="type-8 type-7 type-5 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test for the wsse:FailedAuthentication faultcode. This will fail due to a bad password in
 * the callback handler.
 */
@Test public void testFailedAuthentication() throws Exception {
  WSSecUsernameToken builder=new WSSecUsernameToken();
  builder.addCreated();
  builder.addNonce();
  builder.setUserInfo("16c73ab6-b892-458f-abf5-2f875f74882e","security");
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  Document timestampedDoc=builder.build(doc,secHeader);
  try {
    verify(timestampedDoc);
    fail("Failure expected on a bad password");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.FAILED_AUTHENTICATION);
    assertEquals("The security token could not be authenticated or authorized",ex.getMessage());
    QName faultCode=new QName(WSConstants.WSSE_NS,"FailedAuthentication");
    assertTrue(ex.getFaultCode().equals(faultCode));
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-5 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test for the wsse:InvalidSecurity faultcode.
 */
@Test public void testInvalidSecurity() throws Exception {
  try {
    new Reference((org.w3c.dom.Element)null);
    fail("Failure expected on processing the security header");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.INVALID_SECURITY);
    assertEquals("<Reference> token could not be retrieved",ex.getMessage());
    QName faultCode=new QName(WSConstants.WSSE_NS,"InvalidSecurity");
    assertTrue(ex.getFaultCode().equals(faultCode));
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-5 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test for the wsse:MessageExpired faultcode. This will fail due to the argument
 * passed to setTimeToLive.
 */
@Test public void testMessageExpired() throws Exception {
  WSSecTimestamp builder=new WSSecTimestamp();
  builder.setTimeToLive(-1);
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  Document timestampedDoc=builder.build(doc,secHeader);
  try {
    verify(timestampedDoc);
    fail("Failure expected on an expired message");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.MESSAGE_EXPIRED);
    assertEquals("Invalid timestamp: The message timestamp has expired",ex.getMessage());
    QName faultCode=new QName(WSConstants.WSSE_NS,"MessageExpired");
    assertTrue(ex.getFaultCode().equals(faultCode));
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-5 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test for the wsse:FailedCheck faultcode. This will fail due to a bad password in
 * the callback handler.
 */
@Test public void testFailedCheck() throws Exception {
  WSSecEncrypt builder=new WSSecEncrypt();
  builder.setUserInfo("wss40","security");
  builder.setKeyIdentifierType(WSConstants.BST_DIRECT_REFERENCE);
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  Document encryptedDoc=builder.build(doc,crypto,secHeader);
  try {
    verify(encryptedDoc);
    fail("Failure expected with a bad password");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.FAILED_CHECK);
    assertEquals("The private key for the supplied alias does not exist in the keystore",ex.getMessage());
    QName faultCode=new QName(WSConstants.WSSE_NS,"FailedCheck");
    assertTrue(ex.getFaultCode().equals(faultCode));
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-5 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test for the wsse:UnsupportedAlgorithm faultcode. This will fail due to the argument
 * passed to getCipherInstance.
 */
@Test public void testUnsupportedAlgorithm() throws Exception {
  try {
    secEngine.getWssConfig();
    KeyUtils.getCipherInstance("Bad Algorithm");
    fail("Failure expected on an unsupported algorithm");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.UNSUPPORTED_ALGORITHM);
    assertEquals("unsupported key transport encryption algorithm: No such algorithm: Bad Algorithm",ex.getMessage());
    QName faultCode=new QName(WSConstants.WSSE_NS,"UnsupportedAlgorithm");
    assertTrue(ex.getFaultCode().equals(faultCode));
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-5 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test for the wsse:InvalidSecurityToken faultcode. This will fail due to the fact
 * that a null username is used.
 */
@Test public void testInvalidSecurityToken() throws Exception {
  WSSecUsernameToken builder=new WSSecUsernameToken();
  builder.addCreated();
  builder.addNonce();
  builder.setUserInfo(null,"security");
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  builder.build(doc,secHeader);
  try {
    new UsernameToken(doc.getDocumentElement(),false,new BSPEnforcer());
    fail("Failure expected on an invalid security token");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.INVALID_SECURITY_TOKEN);
    assertEquals("Bad element, expected \"{http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd}UsernameToken\" while got \"{http://schemas.xmlsoap.org/soap/envelope/}Envelope\"",ex.getMessage());
    QName faultCode=new QName(WSConstants.WSSE_NS,"InvalidSecurityToken");
    assertTrue(ex.getFaultCode().equals(faultCode));
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.wss4j.dom.misc.SecurityHeaderTest </h4><pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test for processing multiple security headers with the same actor
 */
@Test public void testDuplicateActor() throws Exception {
  Document doc=SOAPUtil.toSOAPPart(DUPLICATE_ACTOR_MSG);
  try {
    secEngine.processSecurityHeader(doc,"user",null,null);
    fail("Failure expected on a duplicate actor");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.INVALID_SECURITY);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test for processing multiple security headers with the same (null) actor
 */
@Test public void testDuplicateNullActor() throws Exception {
  Document doc=SOAPUtil.toSOAPPart(DUPLICATE_NULL_ACTOR_MSG);
  try {
    secEngine.processSecurityHeader(doc,null,null,null);
    fail("Failure expected on a null actor");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.INVALID_SECURITY);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.wss4j.dom.saml.SamlAlgorithmSuiteTest </h4><pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testC14nMethod() throws Exception {
  SAML1CallbackHandler callbackHandler=new SAML1CallbackHandler();
  callbackHandler.setStatement(SAML1CallbackHandler.Statement.AUTHN);
  callbackHandler.setConfirmationMethod(SAML1Constants.CONF_HOLDER_KEY);
  callbackHandler.setIssuer("www.example.com");
  SAMLCallback samlCallback=new SAMLCallback();
  SAMLUtil.doSAMLCallback(callbackHandler,samlCallback);
  SamlAssertionWrapper samlAssertion=new SamlAssertionWrapper(samlCallback);
  samlAssertion.signAssertion("16c73ab6-b892-458f-abf5-2f875f74882e","security",crypto,false,WSConstants.C14N_EXCL_WITH_COMMENTS,WSConstants.RSA_SHA1);
  WSSecSAMLToken wsSign=new WSSecSAMLToken();
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  Document signedDoc=wsSign.build(doc,samlAssertion,secHeader);
  if (LOG.isDebugEnabled()) {
    String outputString=XMLUtils.prettyDocumentToString(signedDoc);
    LOG.debug(outputString);
  }
  Element securityHeader=WSSecurityUtil.getSecurityHeader(signedDoc,null);
  AlgorithmSuite algorithmSuite=createAlgorithmSuite();
  try {
    verify(securityHeader,algorithmSuite,crypto);
    fail("Expected failure as C14n algorithm is not allowed");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.INVALID_SECURITY);
  }
  algorithmSuite.addC14nAlgorithm(WSConstants.C14N_EXCL_WITH_COMMENTS);
  verify(securityHeader,algorithmSuite,crypto);
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testSignedSAML11Assertion() throws Exception {
  SAML1CallbackHandler callbackHandler=new SAML1CallbackHandler();
  callbackHandler.setStatement(SAML1CallbackHandler.Statement.AUTHN);
  callbackHandler.setConfirmationMethod(SAML1Constants.CONF_HOLDER_KEY);
  callbackHandler.setIssuer("www.example.com");
  SAMLCallback samlCallback=new SAMLCallback();
  SAMLUtil.doSAMLCallback(callbackHandler,samlCallback);
  SamlAssertionWrapper samlAssertion=new SamlAssertionWrapper(samlCallback);
  samlAssertion.signAssertion("16c73ab6-b892-458f-abf5-2f875f74882e","security",crypto,false);
  WSSecSAMLToken wsSign=new WSSecSAMLToken();
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  Document signedDoc=wsSign.build(doc,samlAssertion,secHeader);
  if (LOG.isDebugEnabled()) {
    String outputString=XMLUtils.prettyDocumentToString(signedDoc);
    LOG.debug(outputString);
  }
  Element securityHeader=WSSecurityUtil.getSecurityHeader(signedDoc,null);
  AlgorithmSuite algorithmSuite=createAlgorithmSuite();
  verify(securityHeader,algorithmSuite,crypto);
  algorithmSuite.setMinimumAsymmetricKeyLength(1024);
  try {
    verify(securityHeader,algorithmSuite,crypto);
    fail("Expected failure as 512-bit keys are not allowed");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.INVALID_SECURITY);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testDSASignedSAML11Assertion() throws Exception {
  Crypto dsaCrypto=CryptoFactory.getInstance("wss40.properties");
  SAML1CallbackHandler callbackHandler=new SAML1CallbackHandler();
  callbackHandler.setStatement(SAML1CallbackHandler.Statement.AUTHN);
  callbackHandler.setConfirmationMethod(SAML1Constants.CONF_HOLDER_KEY);
  callbackHandler.setIssuer("www.example.com");
  SAMLCallback samlCallback=new SAMLCallback();
  SAMLUtil.doSAMLCallback(callbackHandler,samlCallback);
  SamlAssertionWrapper samlAssertion=new SamlAssertionWrapper(samlCallback);
  samlAssertion.signAssertion("wss40DSA","security",dsaCrypto,false);
  WSSecSAMLToken wsSign=new WSSecSAMLToken();
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  Document signedDoc=wsSign.build(doc,samlAssertion,secHeader);
  if (LOG.isDebugEnabled()) {
    String outputString=XMLUtils.prettyDocumentToString(signedDoc);
    LOG.debug(outputString);
  }
  Element securityHeader=WSSecurityUtil.getSecurityHeader(signedDoc,null);
  AlgorithmSuite algorithmSuite=createAlgorithmSuite();
  try {
    verify(securityHeader,algorithmSuite,dsaCrypto);
    fail("Expected failure as DSA is not allowed");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.INVALID_SECURITY);
  }
  algorithmSuite.addSignatureMethod(WSConstants.DSA);
  verify(securityHeader,algorithmSuite,dsaCrypto);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.wss4j.dom.saml.SamlConditionsTest </h4><pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testSAML2StaleIssueInstant() throws Exception {
  SAML2CallbackHandler callbackHandler=new SAML2CallbackHandler();
  callbackHandler.setStatement(SAML2CallbackHandler.Statement.AUTHN);
  callbackHandler.setIssuer("www.example.com");
  SAMLCallback samlCallback=new SAMLCallback();
  SAMLUtil.doSAMLCallback(callbackHandler,samlCallback);
  SamlAssertionWrapper samlAssertion=new SamlAssertionWrapper(samlCallback);
  DateTime issueInstant=new DateTime();
  issueInstant=issueInstant.minusMinutes(31);
  samlAssertion.getSaml2().setIssueInstant(issueInstant);
  samlAssertion.getSaml2().getConditions().setNotOnOrAfter(null);
  WSSecSAMLToken wsSign=new WSSecSAMLToken();
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  Document unsignedDoc=wsSign.build(doc,samlAssertion,secHeader);
  if (LOG.isDebugEnabled()) {
    LOG.debug("SAML 2 Authn Assertion (sender vouches):");
    String outputString=XMLUtils.prettyDocumentToString(unsignedDoc);
    LOG.debug(outputString);
  }
  try {
    verify(unsignedDoc);
    fail("Failure expected in processing a stale SAML Assertion");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getMessage().contains("SAML token security failure"));
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testSAML1StaleIssueInstant() throws Exception {
  SAML1CallbackHandler callbackHandler=new SAML1CallbackHandler();
  callbackHandler.setStatement(SAML1CallbackHandler.Statement.AUTHN);
  callbackHandler.setIssuer("www.example.com");
  SAMLCallback samlCallback=new SAMLCallback();
  SAMLUtil.doSAMLCallback(callbackHandler,samlCallback);
  SamlAssertionWrapper samlAssertion=new SamlAssertionWrapper(samlCallback);
  DateTime issueInstant=new DateTime();
  issueInstant=issueInstant.minusMinutes(31);
  samlAssertion.getSaml1().setIssueInstant(issueInstant);
  samlAssertion.getSaml1().getConditions().setNotOnOrAfter(null);
  WSSecSAMLToken wsSign=new WSSecSAMLToken();
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  Document unsignedDoc=wsSign.build(doc,samlAssertion,secHeader);
  if (LOG.isDebugEnabled()) {
    LOG.debug("SAML 1 Authn Assertion (sender vouches):");
    String outputString=XMLUtils.prettyDocumentToString(unsignedDoc);
    LOG.debug(outputString);
  }
  try {
    verify(unsignedDoc);
    fail("Failure expected in processing a stale SAML Assertion");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getMessage().contains("SAML token security failure"));
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testSAML2FutureIssueInstant() throws Exception {
  SAML2CallbackHandler callbackHandler=new SAML2CallbackHandler();
  callbackHandler.setStatement(SAML2CallbackHandler.Statement.AUTHN);
  callbackHandler.setIssuer("www.example.com");
  SAMLCallback samlCallback=new SAMLCallback();
  SAMLUtil.doSAMLCallback(callbackHandler,samlCallback);
  SamlAssertionWrapper samlAssertion=new SamlAssertionWrapper(samlCallback);
  DateTime issueInstant=new DateTime();
  issueInstant=issueInstant.plusMinutes(60);
  samlAssertion.getSaml2().setIssueInstant(issueInstant);
  WSSecSAMLToken wsSign=new WSSecSAMLToken();
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  Document unsignedDoc=wsSign.build(doc,samlAssertion,secHeader);
  if (LOG.isDebugEnabled()) {
    LOG.debug("SAML 2 Authn Assertion (sender vouches):");
    String outputString=XMLUtils.prettyDocumentToString(unsignedDoc);
    LOG.debug(outputString);
  }
  try {
    verify(unsignedDoc);
    fail("Failure expected in processing the SAML Conditions element");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getMessage().contains("SAML token security failure"));
  }
}

</code></pre>

<br>
<pre class="type-3 type-8 type-7 type-5 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testSAML2AudienceRestrictionSeparateRestrictionsValidation() throws Exception {
  SAML2CallbackHandler callbackHandler=new SAML2CallbackHandler();
  callbackHandler.setStatement(SAML2CallbackHandler.Statement.AUTHN);
  callbackHandler.setIssuer("www.example.com");
  ConditionsBean conditions=new ConditionsBean();
  conditions.setTokenPeriodMinutes(5);
  List<AudienceRestrictionBean> audiencesRestrictions=new ArrayList<>();
  AudienceRestrictionBean audienceRestrictionBean=new AudienceRestrictionBean();
  audienceRestrictionBean.setAudienceURIs(Collections.singletonList("http://apache.org/one"));
  audiencesRestrictions.add(audienceRestrictionBean);
  audienceRestrictionBean=new AudienceRestrictionBean();
  audienceRestrictionBean.setAudienceURIs(Collections.singletonList("http://apache.org/two"));
  audiencesRestrictions.add(audienceRestrictionBean);
  conditions.setAudienceRestrictions(audiencesRestrictions);
  callbackHandler.setConditions(conditions);
  SAMLCallback samlCallback=new SAMLCallback();
  SAMLUtil.doSAMLCallback(callbackHandler,samlCallback);
  SamlAssertionWrapper samlAssertion=new SamlAssertionWrapper(samlCallback);
  WSSecSAMLToken wsSign=new WSSecSAMLToken();
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  Document unsignedDoc=wsSign.build(doc,samlAssertion,secHeader);
  String outputString=XMLUtils.prettyDocumentToString(unsignedDoc);
  assertTrue(outputString.contains("AudienceRestriction"));
  if (LOG.isDebugEnabled()) {
    LOG.debug(outputString);
  }
  List<String> audiences=new ArrayList<>();
  audiences.add("http://apache.org/three");
  WSSecurityEngine newEngine=new WSSecurityEngine();
  RequestData data=new RequestData();
  data.setAudienceRestrictions(audiences);
  data.setValidateSamlSubjectConfirmation(false);
  try {
    newEngine.processSecurityHeader(doc,data);
    fail("Failure expected on a bad audience restriction");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getMessage().contains("SAML token security failure"));
  }
  audiences.add("http://apache.org/one");
  data.setAudienceRestrictions(audiences);
  newEngine.processSecurityHeader(doc,data);
}

</code></pre>

<br>
<pre class="type-3 type-8 type-7 type-5 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testSAML1AudienceRestrictionVerification() throws Exception {
  SAML1CallbackHandler callbackHandler=new SAML1CallbackHandler();
  callbackHandler.setStatement(SAML1CallbackHandler.Statement.AUTHN);
  callbackHandler.setIssuer("www.example.com");
  ConditionsBean conditions=new ConditionsBean();
  conditions.setTokenPeriodMinutes(5);
  List<String> audiences=new ArrayList<>();
  audiences.add("http://apache.org/one");
  audiences.add("http://apache.org/two");
  AudienceRestrictionBean audienceRestrictionBean=new AudienceRestrictionBean();
  audienceRestrictionBean.setAudienceURIs(audiences);
  conditions.setAudienceRestrictions(Collections.singletonList(audienceRestrictionBean));
  callbackHandler.setConditions(conditions);
  SAMLCallback samlCallback=new SAMLCallback();
  SAMLUtil.doSAMLCallback(callbackHandler,samlCallback);
  SamlAssertionWrapper samlAssertion=new SamlAssertionWrapper(samlCallback);
  WSSecSAMLToken wsSign=new WSSecSAMLToken();
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  Document unsignedDoc=wsSign.build(doc,samlAssertion,secHeader);
  String outputString=XMLUtils.prettyDocumentToString(unsignedDoc);
  assertTrue(outputString.contains("AudienceRestriction"));
  if (LOG.isDebugEnabled()) {
    LOG.debug(outputString);
  }
  audiences.clear();
  audiences.add("http://apache.org/three");
  WSSecurityEngine newEngine=new WSSecurityEngine();
  RequestData data=new RequestData();
  data.setAudienceRestrictions(audiences);
  data.setValidateSamlSubjectConfirmation(false);
  try {
    newEngine.processSecurityHeader(doc,data);
    fail("Failure expected on a bad audience restriction");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getMessage().contains("SAML token security failure"));
  }
  audiences.add("http://apache.org/one");
  data.setAudienceRestrictions(audiences);
  newEngine.processSecurityHeader(doc,data);
}

</code></pre>

<br>
<pre class="type-3 type-8 type-7 type-5 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testSAML2AudienceRestrictionVerification() throws Exception {
  SAML2CallbackHandler callbackHandler=new SAML2CallbackHandler();
  callbackHandler.setStatement(SAML2CallbackHandler.Statement.AUTHN);
  callbackHandler.setIssuer("www.example.com");
  ConditionsBean conditions=new ConditionsBean();
  conditions.setTokenPeriodMinutes(5);
  List<String> audiences=new ArrayList<>();
  audiences.add("http://apache.org/one");
  audiences.add("http://apache.org/two");
  AudienceRestrictionBean audienceRestrictionBean=new AudienceRestrictionBean();
  audienceRestrictionBean.setAudienceURIs(audiences);
  conditions.setAudienceRestrictions(Collections.singletonList(audienceRestrictionBean));
  callbackHandler.setConditions(conditions);
  SAMLCallback samlCallback=new SAMLCallback();
  SAMLUtil.doSAMLCallback(callbackHandler,samlCallback);
  SamlAssertionWrapper samlAssertion=new SamlAssertionWrapper(samlCallback);
  WSSecSAMLToken wsSign=new WSSecSAMLToken();
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  Document unsignedDoc=wsSign.build(doc,samlAssertion,secHeader);
  String outputString=XMLUtils.prettyDocumentToString(unsignedDoc);
  assertTrue(outputString.contains("AudienceRestriction"));
  if (LOG.isDebugEnabled()) {
    LOG.debug(outputString);
  }
  audiences.clear();
  audiences.add("http://apache.org/three");
  WSSecurityEngine newEngine=new WSSecurityEngine();
  RequestData data=new RequestData();
  data.setAudienceRestrictions(audiences);
  data.setValidateSamlSubjectConfirmation(false);
  try {
    newEngine.processSecurityHeader(doc,data);
    fail("Failure expected on a bad audience restriction");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getMessage().contains("SAML token security failure"));
  }
  audiences.add("http://apache.org/one");
  data.setAudienceRestrictions(audiences);
  newEngine.processSecurityHeader(doc,data);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.wss4j.dom.saml.SamlNegativeTest </h4><pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test that creates a signed SAML 1.1 authentication assertion that uses holder-of-key, but
 * does not include a KeyInfo in the Subject, and hence will fail processing.
 */
@Test public void testHOKNoKeyInfo() throws Exception {
  SAML1HOKNoKeyInfoCallbackHandler callbackHandler=new SAML1HOKNoKeyInfoCallbackHandler();
  callbackHandler.setStatement(SAML1CallbackHandler.Statement.AUTHN);
  callbackHandler.setIssuer("www.example.com");
  SAMLCallback samlCallback=new SAMLCallback();
  SAMLUtil.doSAMLCallback(callbackHandler,samlCallback);
  SamlAssertionWrapper samlAssertion=new SamlAssertionWrapper(samlCallback);
  samlAssertion.signAssertion("wss40_server","security",issuerCrypto,false);
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  WSSecSAMLToken wsSign=new WSSecSAMLToken();
  Document signedDoc=wsSign.build(doc,samlAssertion,secHeader);
  String outputString=XMLUtils.prettyDocumentToString(signedDoc);
  if (LOG.isDebugEnabled()) {
    LOG.debug("SAML 1.1 Authn Assertion (key holder):");
    LOG.debug(outputString);
  }
  try {
    verify(signedDoc,trustCrypto);
    fail("Expected failure on a holder-of-key confirmation method with no KeyInfo");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.FAILURE);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test that creates a SAML 1.1 authentication assertion that uses holder-of-key, but is
 * not signed, and hence will fail processing.
 */
@Test public void testHOKNotSigned() throws Exception {
  SAML1CallbackHandler callbackHandler=new SAML1CallbackHandler();
  callbackHandler.setStatement(SAML1CallbackHandler.Statement.AUTHN);
  callbackHandler.setConfirmationMethod(SAML1Constants.CONF_HOLDER_KEY);
  SAMLCallback samlCallback=new SAMLCallback();
  SAMLUtil.doSAMLCallback(callbackHandler,samlCallback);
  SamlAssertionWrapper samlAssertion=new SamlAssertionWrapper(samlCallback);
  samlCallback.setIssuer("www.example.com");
  samlCallback.setIssuerCrypto(issuerCrypto);
  samlCallback.setIssuerKeyName("wss40_server");
  samlCallback.setIssuerKeyPassword("security");
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  WSSecSAMLToken wsSign=new WSSecSAMLToken();
  Document signedDoc=wsSign.build(doc,samlAssertion,secHeader);
  String outputString=XMLUtils.prettyDocumentToString(signedDoc);
  if (LOG.isDebugEnabled()) {
    LOG.debug("SAML 1.1 Authn Assertion (unsigned key holder):");
    LOG.debug(outputString);
  }
  try {
    verify(signedDoc,trustCrypto);
    fail("Expected failure on an unsigned assertion with holder-of-key confirmation method");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getMessage().contains("SAML token security failure"));
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test that creates, sends and processes a signed SAML 2 sender-vouches
 * authentication assertion. The assertion is altered and so the signature validation
 * should fail.
 */
@Test public void testSAML2AuthnAssertionModified() throws Exception {
  SAML2CallbackHandler callbackHandler=new SAML2CallbackHandler();
  callbackHandler.setStatement(SAML2CallbackHandler.Statement.AUTHN);
  callbackHandler.setConfirmationMethod(SAML2Constants.CONF_SENDER_VOUCHES);
  callbackHandler.setIssuer("www.example.com");
  SAMLCallback samlCallback=new SAMLCallback();
  SAMLUtil.doSAMLCallback(callbackHandler,samlCallback);
  SamlAssertionWrapper samlAssertion=new SamlAssertionWrapper(samlCallback);
  WSSecSignatureSAML wsSign=new WSSecSignatureSAML();
  wsSign.setKeyIdentifierType(WSConstants.BST_DIRECT_REFERENCE);
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  Document signedDoc=wsSign.build(doc,null,samlAssertion,userCrypto,"wss40","security",secHeader);
  Element envelope=signedDoc.getDocumentElement();
  NodeList list=envelope.getElementsByTagNameNS(WSConstants.SAML2_NS,"Assertion");
  Element assertionElement=(Element)list.item(0);
  assertionElement.setAttributeNS(null,"MinorVersion","5");
  if (LOG.isDebugEnabled()) {
    LOG.debug("SAML 2 Authn Assertion (sender vouches):");
    String outputString=XMLUtils.prettyDocumentToString(signedDoc);
    LOG.debug(outputString);
  }
  try {
    verify(signedDoc,trustCrypto);
    fail("Failure expected on a modified SAML Assertion");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.FAILED_CHECK);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test that creates a signed SAML 1.1 Assertion using HOK, but then modifies the signature
 * object by replacing the enveloped transform with the exclusive c14n transform.
 * The signature validation should then fail - the enveloped transform is mandatory for
 * a signed assertion.
 */
@Test public void testSAML1SignedKeyHolderSigModified() throws Exception {
  SAML1CallbackHandler callbackHandler=new SAML1CallbackHandler();
  callbackHandler.setStatement(SAML1CallbackHandler.Statement.AUTHN);
  callbackHandler.setConfirmationMethod(SAML1Constants.CONF_HOLDER_KEY);
  callbackHandler.setIssuer("www.example.com");
  SAMLCallback samlCallback=new SAMLCallback();
  SAMLUtil.doSAMLCallback(callbackHandler,samlCallback);
  SamlAssertionWrapper samlAssertion=new SamlAssertionWrapper(samlCallback);
  samlAssertion.signAssertion("wss40_server","security",issuerCrypto,false);
  WSSecSAMLToken wsSign=new WSSecSAMLToken();
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  Document signedDoc=wsSign.build(doc,samlAssertion,secHeader);
  Element envelope=signedDoc.getDocumentElement();
  NodeList list=envelope.getElementsByTagNameNS(WSConstants.SAML_NS,"Assertion");
  Element assertionElement=(Element)list.item(0);
  list=assertionElement.getElementsByTagNameNS(WSConstants.SIG_NS,"Signature");
  Element sigElement=(Element)list.item(0);
  list=sigElement.getElementsByTagNameNS(WSConstants.SIG_NS,"Transform");
  Element transformElement=(Element)list.item(0);
  transformElement.setAttributeNS(null,"Algorithm",WSConstants.C14N_EXCL_OMIT_COMMENTS);
  if (LOG.isDebugEnabled()) {
    LOG.debug("Signed (modified) SAML message (key holder):");
    String outputString=XMLUtils.prettyDocumentToString(signedDoc);
    LOG.debug(outputString);
  }
  try {
    verify(signedDoc,trustCrypto);
    fail("Expected failure on a modified signature");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.FAILURE);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test that creates, sends and processes a signed SAML 2 authentication assertion, but it
 * is rejected in processing as the signature on the assertion is not trusted.
 */
@Test public void testSAML2TrustFailure() throws Exception {
  SAML2CallbackHandler callbackHandler=new SAML2CallbackHandler();
  callbackHandler.setStatement(SAML2CallbackHandler.Statement.AUTHN);
  callbackHandler.setConfirmationMethod(SAML2Constants.CONF_HOLDER_KEY);
  callbackHandler.setIssuer("www.example.com");
  SAMLCallback samlCallback=new SAMLCallback();
  SAMLUtil.doSAMLCallback(callbackHandler,samlCallback);
  SamlAssertionWrapper samlAssertion=new SamlAssertionWrapper(samlCallback);
  samlAssertion.signAssertion("16c73ab6-b892-458f-abf5-2f875f74882e","security",CryptoFactory.getInstance("crypto.properties"),false);
  WSSecSignatureSAML wsSign=new WSSecSignatureSAML();
  wsSign.setUserInfo("wss40","security");
  wsSign.setDigestAlgo("http://www.w3.org/2001/04/xmlenc#sha256");
  wsSign.setSignatureAlgorithm("http://www.w3.org/2001/04/xmldsig-more#rsa-sha256");
  wsSign.setKeyIdentifierType(WSConstants.BST_DIRECT_REFERENCE);
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  Document signedDoc=wsSign.build(doc,userCrypto,samlAssertion,null,null,null,secHeader);
  String outputString=XMLUtils.prettyDocumentToString(signedDoc);
  if (LOG.isDebugEnabled()) {
    LOG.debug("Untrusted signed SAML 2 Authn Assertion (key holder):");
    LOG.debug(outputString);
  }
  try {
    verify(signedDoc,trustCrypto);
    fail("Failure expected on an untrusted signed assertion");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.FAILURE);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test that creates a signed SAML 2 Assertion using HOK, but then modifies the assertion.
 * The signature verification should then fail.
 */
@Test public void testSAML2SignedKeyHolderKeyModified() throws Exception {
  SAML2CallbackHandler callbackHandler=new SAML2CallbackHandler();
  callbackHandler.setStatement(SAML2CallbackHandler.Statement.AUTHN);
  callbackHandler.setConfirmationMethod(SAML2Constants.CONF_HOLDER_KEY);
  callbackHandler.setIssuer("www.example.com");
  SAMLCallback samlCallback=new SAMLCallback();
  SAMLUtil.doSAMLCallback(callbackHandler,samlCallback);
  SamlAssertionWrapper samlAssertion=new SamlAssertionWrapper(samlCallback);
  samlAssertion.signAssertion("wss40_server","security",issuerCrypto,false);
  WSSecSAMLToken wsSign=new WSSecSAMLToken();
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  Document signedDoc=wsSign.build(doc,samlAssertion,secHeader);
  Element envelope=signedDoc.getDocumentElement();
  NodeList list=envelope.getElementsByTagNameNS(WSConstants.SAML2_NS,"Assertion");
  Element assertionElement=(Element)list.item(0);
  assertionElement.setAttributeNS(null,"MinorVersion","5");
  if (LOG.isDebugEnabled()) {
    LOG.debug("Signed (modified) SAML message (key holder):");
    String outputString=XMLUtils.prettyDocumentToString(signedDoc);
    LOG.debug(outputString);
  }
  try {
    verify(signedDoc,trustCrypto);
    fail("Expected failure on a modified signature");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.FAILURE);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.wss4j.dom.saml.SamlTokenCustomSignatureTest </h4><pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test that creates, sends and processes a signed SAML 2.0 authentication assertion.
 */
@Test public void testSAML2AuthnAssertion() throws Exception {
  SAML2CallbackHandler callbackHandler=new SAML2CallbackHandler();
  callbackHandler.setStatement(SAML2CallbackHandler.Statement.AUTHN);
  callbackHandler.setConfirmationMethod(SAML2Constants.CONF_BEARER);
  callbackHandler.setIssuer("www.example.com");
  SAMLCallback samlCallback=new SAMLCallback();
  SAMLUtil.doSAMLCallback(callbackHandler,samlCallback);
  SamlAssertionWrapper samlAssertion=new SamlAssertionWrapper(samlCallback);
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  Element assertionElement=samlAssertion.toDOM(doc);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  secHeader.getSecurityHeader().appendChild(assertionElement);
  signAssertion(doc,assertionElement);
  if (LOG.isDebugEnabled()) {
    LOG.debug("SAML 2.0 Authn Assertion (Bearer):");
    String outputString=XMLUtils.prettyDocumentToString(doc);
    LOG.debug(outputString);
  }
  try {
    verify(doc);
    fail("Failure expected on a signature that doesn't conform with the signature profile");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.FAILURE);
  }
  verifyWithoutProfile(doc);
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test that creates, sends and processes a signed SAML 1.1 authentication assertion.
 */
@Test public void testSAML1AuthnAssertion() throws Exception {
  SAML1CallbackHandler callbackHandler=new SAML1CallbackHandler();
  callbackHandler.setStatement(SAML1CallbackHandler.Statement.AUTHN);
  callbackHandler.setConfirmationMethod(SAML1Constants.CONF_BEARER);
  callbackHandler.setIssuer("www.example.com");
  SAMLCallback samlCallback=new SAMLCallback();
  SAMLUtil.doSAMLCallback(callbackHandler,samlCallback);
  SamlAssertionWrapper samlAssertion=new SamlAssertionWrapper(samlCallback);
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  Element assertionElement=samlAssertion.toDOM(doc);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  secHeader.getSecurityHeader().appendChild(assertionElement);
  signAssertion(doc,assertionElement);
  if (LOG.isDebugEnabled()) {
    LOG.debug("SAML 1.1 Authn Assertion (Bearer):");
    String outputString=XMLUtils.prettyDocumentToString(doc);
    LOG.debug(outputString);
  }
  try {
    verify(doc);
    fail("Failure expected on a signature that doesn't conform with the signature profile");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.FAILURE);
  }
  verifyWithoutProfile(doc);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.wss4j.dom.saml.SamlTokenTest </h4><pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testUnsignedBearer() throws Exception {
  SAML2CallbackHandler callbackHandler=new SAML2CallbackHandler();
  callbackHandler.setStatement(SAML2CallbackHandler.Statement.AUTHN);
  callbackHandler.setIssuer("www.example.com");
  callbackHandler.setConfirmationMethod(SAML2Constants.CONF_BEARER);
  SAMLCallback samlCallback=new SAMLCallback();
  SAMLUtil.doSAMLCallback(callbackHandler,samlCallback);
  SamlAssertionWrapper samlAssertion=new SamlAssertionWrapper(samlCallback);
  WSSecSAMLToken wsSign=new WSSecSAMLToken();
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  Document unsignedDoc=wsSign.build(doc,samlAssertion,secHeader);
  WSSecurityEngine newEngine=new WSSecurityEngine();
  try {
    newEngine.processSecurityHeader(unsignedDoc,null,null,null);
    fail("Failure expected on an unsigned bearer token");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.FAILURE);
  }
  WSSConfig config=WSSConfig.getNewInstance();
  SamlAssertionValidator assertionValidator=new SamlAssertionValidator();
  assertionValidator.setRequireBearerSignature(false);
  config.setValidator(WSConstants.SAML_TOKEN,assertionValidator);
  config.setValidator(WSConstants.SAML2_TOKEN,assertionValidator);
  newEngine.setWssConfig(config);
  RequestData requestData=new RequestData();
  requestData.setValidateSamlSubjectConfirmation(false);
  newEngine.processSecurityHeader(doc,requestData);
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testStandardSubjectConfirmationMethod() throws Exception {
  SAML2CallbackHandler callbackHandler=new SAML2CallbackHandler();
  callbackHandler.setStatement(SAML2CallbackHandler.Statement.AUTHN);
  callbackHandler.setIssuer("www.example.com");
  callbackHandler.setConfirmationMethod("urn:oasis:names:tc:SAML:2.0:cm:custom");
  SAMLCallback samlCallback=new SAMLCallback();
  SAMLUtil.doSAMLCallback(callbackHandler,samlCallback);
  SamlAssertionWrapper samlAssertion=new SamlAssertionWrapper(samlCallback);
  WSSecSAMLToken wsSign=new WSSecSAMLToken();
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  Document unsignedDoc=wsSign.build(doc,samlAssertion,secHeader);
  WSSecurityEngine newEngine=new WSSecurityEngine();
  try {
    newEngine.processSecurityHeader(unsignedDoc,null,null,null);
    fail("Failure expected on an unknown subject confirmation method");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.FAILURE);
  }
  WSSConfig config=WSSConfig.getNewInstance();
  SamlAssertionValidator assertionValidator=new SamlAssertionValidator();
  assertionValidator.setRequireStandardSubjectConfirmationMethod(false);
  config.setValidator(WSConstants.SAML_TOKEN,assertionValidator);
  config.setValidator(WSConstants.SAML2_TOKEN,assertionValidator);
  newEngine.setWssConfig(config);
  RequestData requestData=new RequestData();
  requestData.setValidateSamlSubjectConfirmation(false);
  newEngine.processSecurityHeader(doc,requestData);
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testRequiredSubjectConfirmationMethod() throws Exception {
  SAML2CallbackHandler callbackHandler=new SAML2CallbackHandler();
  callbackHandler.setStatement(SAML2CallbackHandler.Statement.AUTHN);
  callbackHandler.setIssuer("www.example.com");
  SAMLCallback samlCallback=new SAMLCallback();
  SAMLUtil.doSAMLCallback(callbackHandler,samlCallback);
  SamlAssertionWrapper samlAssertion=new SamlAssertionWrapper(samlCallback);
  WSSecSAMLToken wsSign=new WSSecSAMLToken();
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  Document unsignedDoc=wsSign.build(doc,samlAssertion,secHeader);
  WSSConfig config=WSSConfig.getNewInstance();
  SamlAssertionValidator assertionValidator=new SamlAssertionValidator();
  assertionValidator.setRequiredSubjectConfirmationMethod(SAML2Constants.CONF_SENDER_VOUCHES);
  config.setValidator(WSConstants.SAML_TOKEN,assertionValidator);
  config.setValidator(WSConstants.SAML2_TOKEN,assertionValidator);
  WSSecurityEngine newEngine=new WSSecurityEngine();
  newEngine.setWssConfig(config);
  RequestData requestData=new RequestData();
  requestData.setValidateSamlSubjectConfirmation(false);
  newEngine.processSecurityHeader(doc,requestData);
  callbackHandler.setConfirmationMethod(SAML2Constants.CONF_BEARER);
  samlCallback=new SAMLCallback();
  SAMLUtil.doSAMLCallback(callbackHandler,samlCallback);
  samlAssertion=new SamlAssertionWrapper(samlCallback);
  wsSign=new WSSecSAMLToken();
  doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  unsignedDoc=wsSign.build(doc,samlAssertion,secHeader);
  try {
    newEngine.processSecurityHeader(unsignedDoc,null,null,null);
    fail("Failure expected on an incorrect subject confirmation method");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.FAILURE);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.wss4j.dom.validate.ValidatorTest </h4><pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * This is a test for processing an expired Timestamp.
 */
@Test public void testExpiredTimestamp() throws Exception {
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  WSSecTimestamp timestamp=new WSSecTimestamp();
  timestamp.setTimeToLive(-1);
  Document createdDoc=timestamp.build(doc,secHeader);
  if (LOG.isDebugEnabled()) {
    String outputString=XMLUtils.prettyDocumentToString(createdDoc);
    LOG.debug(outputString);
  }
  WSSConfig wssConfig=WSSConfig.getNewInstance();
  try {
    verify(createdDoc,wssConfig,null,null);
    fail("Expected failure on an expired timestamp");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.MESSAGE_EXPIRED);
  }
  wssConfig.setValidator(WSConstants.TIMESTAMP,NoOpValidator.class);
  verify(createdDoc,wssConfig,null,null);
}

</code></pre>

<br>
<pre class="type-3 type-8 type-7 type-5 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * In this test, a SOAP request is constructed where the SOAP body is signed via a
 * BinarySecurityToken. The receiving side does not trust the BST, and so the test fails.
 * The second time, a custom Validator (NoOpValidator for this case) is installed for the
 * BST, and so trust verification passes on the Signature.
 */
@Test public void testValidatedBSTSignature() throws Exception {
  WSSecSignature builder=new WSSecSignature();
  builder.setUserInfo("16c73ab6-b892-458f-abf5-2f875f74882e","security");
  builder.setKeyIdentifierType(WSConstants.BST_DIRECT_REFERENCE);
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  Document signedDoc=builder.build(doc,CryptoFactory.getInstance(),secHeader);
  if (LOG.isDebugEnabled()) {
    String outputString=XMLUtils.prettyDocumentToString(signedDoc);
    LOG.debug(outputString);
  }
  Crypto crypto=CryptoFactory.getInstance("wss40.properties");
  WSSConfig config=WSSConfig.getNewInstance();
  WSSecurityEngine secEngine=new WSSecurityEngine();
  secEngine.setWssConfig(config);
  try {
    secEngine.processSecurityHeader(doc,null,null,crypto);
    fail("Expected failure on untrusted signature");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.FAILURE);
  }
  config.setValidator(WSConstants.BINARY_TOKEN,new BSTValidator());
  WSHandlerResult results=secEngine.processSecurityHeader(doc,null,null,crypto);
  List<WSSecurityEngineResult> bstResults=results.getActionResults().get(WSConstants.BST);
  WSSecurityEngineResult actionResult=bstResults.get(0);
  BinarySecurity token=(BinarySecurity)actionResult.get(WSSecurityEngineResult.TAG_BINARY_SECURITY_TOKEN);
  assertTrue(token != null);
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test for processing an untrusted signature
 */
@Test public void testUntrustedSignature() throws Exception {
  WSSecSignature sign=new WSSecSignature();
  sign.setUserInfo("wss40","security");
  sign.setKeyIdentifierType(WSConstants.X509_KEY_IDENTIFIER);
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  Crypto crypto=CryptoFactory.getInstance("wss40.properties");
  Document signedDoc=sign.build(doc,crypto,secHeader);
  if (LOG.isDebugEnabled()) {
    String outputString=XMLUtils.prettyDocumentToString(signedDoc);
    LOG.debug(outputString);
  }
  Crypto cryptoCA=CryptoFactory.getInstance("crypto.properties");
  WSSecurityEngine newEngine=new WSSecurityEngine();
  RequestData data=new RequestData();
  data.setSigVerCrypto(cryptoCA);
  data.setIgnoredBSPRules(Collections.singletonList(BSPRule.R3063));
  try {
    newEngine.processSecurityHeader(signedDoc,data);
    fail("Failure expected on issuer serial");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.FAILURE);
  }
  WSSConfig config=WSSConfig.getNewInstance();
  config.setValidator(WSConstants.SIGNATURE,NoOpValidator.class);
  newEngine.setWssConfig(config);
  data.setWssConfig(config);
  newEngine.processSecurityHeader(signedDoc,data);
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test that adds a UserNameToken with (bad) password text to a WS-Security envelope
 */
@Test public void testUsernameTokenBadText() throws Exception {
  WSSecUsernameToken builder=new WSSecUsernameToken();
  builder.setPasswordType(WSConstants.PASSWORD_TEXT);
  builder.setUserInfo("wernerd","verySecre");
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  WSSecHeader secHeader=new WSSecHeader(doc);
  secHeader.insertSecurityHeader();
  Document signedDoc=builder.build(doc,secHeader);
  if (LOG.isDebugEnabled()) {
    String outputString=XMLUtils.prettyDocumentToString(signedDoc);
    LOG.debug(outputString);
  }
  WSSConfig wssConfig=WSSConfig.getNewInstance();
  try {
    verify(signedDoc,wssConfig,new UsernamePasswordCallbackHandler(),null);
    fail("Failure expected on a bad password text");
  }
 catch (  WSSecurityException ex) {
    assertTrue(ex.getErrorCode() == WSSecurityException.ErrorCode.FAILED_AUTHENTICATION);
  }
  wssConfig.setValidator(WSConstants.USERNAME_TOKEN,NoOpValidator.class);
  verify(signedDoc,wssConfig,new UsernamePasswordCallbackHandler(),null);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.wss4j.integration.test.kerberos.KerberosTest </h4><pre class="type-8 type-7 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Various unit tests for a kerberos client
 */
@Test public void testKerberosClient() throws Exception {
  if (!runTests) {
    System.out.println("Skipping test because kerberos server could not be started");
    return;
  }
  Document doc=SOAPUtil.toSOAPPart(SOAPUtil.SAMPLE_SOAP_MSG);
  CallbackHandler callbackHandler=new CallbackHandler(){
    @Override public void handle(    Callback[] callbacks) throws IOException, UnsupportedCallbackException {
      PasswordCallback passwordCallback=(PasswordCallback)callbacks[0];
      if (passwordCallback.getPrompt().contains("alice")) {
        passwordCallback.setPassword("alice".toCharArray());
      }
 else       if (passwordCallback.getPrompt().contains("bob")) {
        passwordCallback.setPassword("bob".toCharArray());
      }
    }
  }
;
  try {
    KerberosSecurity bst=new KerberosSecurity(doc);
    bst.retrieveServiceTicket("alice2",callbackHandler,"bob@service");
    Assert.fail("Failure expected on an unknown user");
  }
 catch (  WSSecurityException ex) {
    Assert.assertTrue(ex.getMessage().startsWith("An error occurred in trying to obtain a TGT:"));
  }
  try {
    KerberosSecurity bst=new KerberosSecurity(doc);
    bst.retrieveServiceTicket("alice",callbackHandler,"bob2@service");
    Assert.fail("Failure expected on an unknown user");
  }
 catch (  WSSecurityException ex) {
    Assert.assertEquals(ex.getMessage(),"An error occurred in trying to obtain a service ticket");
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.wss4j.policy.stax.test.AlgorithmSuiteTest </h4><pre class="type-8 type-7 type-5 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testAlgorithmSuitePolicyNegative() throws Exception {
  String policyString="<sp:AlgorithmSuite xmlns:sp=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702\">\n" + "<wsp:Policy xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\">\n" + "<sp:TripleDesRsa15/>\n"+ "</wsp:Policy>\n"+ "</sp:AlgorithmSuite>";
  PolicyEnforcer policyEnforcer=buildAndStartPolicyEngine(policyString);
  OperationSecurityEvent operationSecurityEvent=new OperationSecurityEvent();
  operationSecurityEvent.setOperation(new QName("definitions"));
  policyEnforcer.registerSecurityEvent(operationSecurityEvent);
  AlgorithmSuiteSecurityEvent algorithmSuiteSecurityEvent=new AlgorithmSuiteSecurityEvent();
  algorithmSuiteSecurityEvent.setAlgorithmURI("http://www.w3.org/2001/04/xmlenc#aes128-cbc");
  algorithmSuiteSecurityEvent.setKeyLength(128);
  algorithmSuiteSecurityEvent.setAlgorithmUsage(WSSConstants.Enc);
  try {
    policyEnforcer.registerSecurityEvent(algorithmSuiteSecurityEvent);
    Assert.fail("Exception expected");
  }
 catch (  WSSecurityException e) {
    Assert.assertTrue(e.getCause() instanceof PolicyViolationException);
    Assert.assertEquals(e.getCause().getMessage(),"Encryption algorithm http://www.w3.org/2001/04/xmlenc#aes128-cbc does not meet policy\n" + "Symmetric encryption algorithm key length 128 does not meet policy");
    Assert.assertEquals(e.getFaultCode(),WSSecurityException.INVALID_SECURITY);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-5 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testAlgorithmSuitePolicyMultipleAssertionEventsNegative() throws Exception {
  String policyString="<sp:AlgorithmSuite xmlns:sp=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702\">\n" + "<wsp:Policy xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\">\n" + "<sp:TripleDesRsa15/>\n"+ "</wsp:Policy>\n"+ "</sp:AlgorithmSuite>";
  PolicyEnforcer policyEnforcer=buildAndStartPolicyEngine(policyString);
  OperationSecurityEvent operationSecurityEvent=new OperationSecurityEvent();
  operationSecurityEvent.setOperation(new QName("definitions"));
  policyEnforcer.registerSecurityEvent(operationSecurityEvent);
  AlgorithmSuiteSecurityEvent algorithmSuiteSecurityEvent=new AlgorithmSuiteSecurityEvent();
  algorithmSuiteSecurityEvent.setAlgorithmURI("http://www.w3.org/2001/04/xmlenc#tripledes-cbc");
  algorithmSuiteSecurityEvent.setKeyLength(192);
  algorithmSuiteSecurityEvent.setAlgorithmUsage(WSSConstants.Enc);
  policyEnforcer.registerSecurityEvent(algorithmSuiteSecurityEvent);
  algorithmSuiteSecurityEvent.setAlgorithmURI("http://www.w3.org/2001/04/xmlenc#sha256");
  algorithmSuiteSecurityEvent.setAlgorithmUsage(WSSConstants.SigDig);
  try {
    policyEnforcer.registerSecurityEvent(algorithmSuiteSecurityEvent);
    Assert.fail("Exception expected");
  }
 catch (  WSSecurityException e) {
    Assert.assertTrue(e.getCause() instanceof PolicyViolationException);
    Assert.assertEquals(e.getCause().getMessage(),"Digest algorithm http://www.w3.org/2001/04/xmlenc#sha256 does not meet policy");
    Assert.assertEquals(e.getFaultCode(),WSSecurityException.INVALID_SECURITY);
  }
}

</code></pre>

<br>
<pre class="type-8 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testAES256GCMAlgorithmSuitePolicy() throws Exception {
  String policyString="<sp:AlgorithmSuite xmlns:sp=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702\">\n" + "<wsp:Policy xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\">\n" + "<cxf:Basic256GCM xmlns:cxf=\"http://cxf.apache.org/custom/security-policy\"/>\n"+ "</wsp:Policy>\n"+ "</sp:AlgorithmSuite>";
class GCMAlgorithmSuite extends AlgorithmSuite {
    GCMAlgorithmSuite(    SPConstants.SPVersion version,    Policy nestedPolicy){
      super(version,nestedPolicy);
    }
    @Override protected AbstractSecurityAssertion cloneAssertion(    Policy nestedPolicy){
      return new GCMAlgorithmSuite(getVersion(),nestedPolicy);
    }
    @Override protected void parseCustomAssertion(    Assertion assertion){
      String assertionName=assertion.getName().getLocalPart();
      String assertionNamespace=assertion.getName().getNamespaceURI();
      if (!"http://cxf.apache.org/custom/security-policy".equals(assertionNamespace)) {
        return;
      }
      if ("Basic128GCM".equals(assertionName)) {
        setAlgorithmSuiteType(new AlgorithmSuiteType("Basic128GCM",SPConstants.SHA1,WSSConstants.NS_XENC11_AES128_GCM,SPConstants.KW_AES128,SPConstants.KW_RSA_OAEP,SPConstants.P_SHA1_L128,SPConstants.P_SHA1_L128,128,128,128,256,1024,4096));
      }
 else       if ("Basic192GCM".equals(assertionName)) {
        setAlgorithmSuiteType(new AlgorithmSuiteType("Basic192GCM",SPConstants.SHA1,WSSConstants.NS_XENC11_AES192_GCM,SPConstants.KW_AES192,SPConstants.KW_RSA_OAEP,SPConstants.P_SHA1_L192,SPConstants.P_SHA1_L192,192,192,192,256,1024,4096));
      }
 else       if ("Basic256GCM".equals(assertionName)) {
        setAlgorithmSuiteType(new AlgorithmSuiteType("Basic256GCM",SPConstants.SHA1,WSSConstants.NS_XENC11_AES256_GCM,SPConstants.KW_AES256,SPConstants.KW_RSA_OAEP,SPConstants.P_SHA1_L256,SPConstants.P_SHA1_L192,256,192,256,256,1024,4096));
      }
    }
  }
class GCMAlgorithmSuiteBuilder extends AlgorithmSuiteBuilder {
    @Override protected AlgorithmSuite createAlgorithmSuite(    SPConstants.SPVersion version,    Policy nestedPolicy){
      return new GCMAlgorithmSuite(version,nestedPolicy);
    }
  }
  List<AssertionBuilder<Element>> customAssertionBuilders=new ArrayList<>();
  customAssertionBuilders.add(new GCMAlgorithmSuiteBuilder());
  PolicyEnforcer policyEnforcer=buildAndStartPolicyEngine(policyString,false,customAssertionBuilders);
  OperationSecurityEvent operationSecurityEvent=new OperationSecurityEvent();
  operationSecurityEvent.setOperation(new QName("definitions"));
  policyEnforcer.registerSecurityEvent(operationSecurityEvent);
  AlgorithmSuiteSecurityEvent algorithmSuiteSecurityEvent=new AlgorithmSuiteSecurityEvent();
  algorithmSuiteSecurityEvent.setAlgorithmURI(WSSConstants.NS_XENC11_AES256_GCM);
  algorithmSuiteSecurityEvent.setKeyLength(256);
  algorithmSuiteSecurityEvent.setAlgorithmUsage(WSSConstants.Enc);
  policyEnforcer.registerSecurityEvent(algorithmSuiteSecurityEvent);
  algorithmSuiteSecurityEvent=new AlgorithmSuiteSecurityEvent();
  algorithmSuiteSecurityEvent.setAlgorithmURI(WSSConstants.NS_XENC_AES256);
  algorithmSuiteSecurityEvent.setKeyLength(256);
  algorithmSuiteSecurityEvent.setAlgorithmUsage(WSSConstants.Enc);
  try {
    policyEnforcer.registerSecurityEvent(algorithmSuiteSecurityEvent);
    Assert.fail("Exception expected");
  }
 catch (  Exception e) {
    Assert.assertEquals(e.getCause().getMessage(),"Encryption algorithm http://www.w3.org/2001/04/xmlenc#aes256-cbc does not meet policy");
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-5 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testAlgorithmSuitePolicyAlternativesNegative() throws Exception {
  String policyString="<sp:AlgorithmSuite xmlns:sp=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702\">\n" + "<wsp:Policy xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\">\n" + "<wsp:ExactlyOne>\n"+ "<sp:Basic256/>\n"+ "<sp:TripleDesRsa15/>\n"+ "</wsp:ExactlyOne>\n"+ "</wsp:Policy>\n"+ "</sp:AlgorithmSuite>";
  PolicyEnforcer policyEnforcer=buildAndStartPolicyEngine(policyString);
  OperationSecurityEvent operationSecurityEvent=new OperationSecurityEvent();
  operationSecurityEvent.setOperation(new QName("definitions"));
  policyEnforcer.registerSecurityEvent(operationSecurityEvent);
  AlgorithmSuiteSecurityEvent algorithmSuiteSecurityEvent=new AlgorithmSuiteSecurityEvent();
  algorithmSuiteSecurityEvent.setAlgorithmURI("http://www.w3.org/2001/04/xmlenc#aes128-cbc");
  algorithmSuiteSecurityEvent.setKeyLength(128);
  algorithmSuiteSecurityEvent.setAlgorithmUsage(WSSConstants.Enc);
  try {
    policyEnforcer.registerSecurityEvent(algorithmSuiteSecurityEvent);
    Assert.fail("Exception expected");
  }
 catch (  WSSecurityException e) {
    Assert.assertTrue(e.getCause() instanceof PolicyViolationException);
    Assert.assertEquals(e.getCause().getMessage(),"Encryption algorithm http://www.w3.org/2001/04/xmlenc#aes128-cbc does not meet policy\n" + "Symmetric encryption algorithm key length 128 does not meet policy");
    Assert.assertEquals(e.getFaultCode(),WSSecurityException.INVALID_SECURITY);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.wss4j.policy.stax.test.AsymmetricBindingIntegrationTest </h4><pre class="type-8 type-7 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testEntireHeaderAndBodySignatureNegative() throws Exception {
  String policyString="<wsp:ExactlyOne xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\" " + "xmlns:sp=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702\">\n" + "            <wsp:All>\n"+ "                <sp:AsymmetricBinding>\n"+ "                    <wsp:Policy>\n"+ "                        <sp:InitiatorToken>\n"+ "                            <wsp:Policy>\n"+ "                                <sp:X509Token sp:IncludeToken=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702/IncludeToken/Never\">\n"+ "                                    <sp:IssuerName>CN=transmitter,OU=swssf,C=CH</sp:IssuerName>\n"+ "                                    <wsp:Policy>\n"+ "                                        <sp:WssX509V3Token11/>\n"+ "                                    </wsp:Policy>\n"+ "                                </sp:X509Token>\n"+ "                            </wsp:Policy>\n"+ "                        </sp:InitiatorToken>\n"+ "                        <sp:RecipientToken>\n"+ "                            <wsp:Policy>\n"+ "                              <sp:X509Token sp:IncludeToken=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702/IncludeToken/Never\">\n"+ "                                  <sp:IssuerName>CN=receiver,OU=swssf,C=CH</sp:IssuerName>\n"+ "                                  <wsp:Policy>\n"+ "                                      <sp:WssX509V3Token11/>\n"+ "                                  </wsp:Policy>\n"+ "                              </sp:X509Token>\n"+ "                            </wsp:Policy>\n"+ "                         </sp:RecipientToken>\n"+ "                        <sp:AlgorithmSuite>\n"+ "                            <wsp:Policy>\n"+ "                                <sp:Basic256/>\n"+ "                            </wsp:Policy>\n"+ "                        </sp:AlgorithmSuite>\n"+ "                        <sp:Layout>\n"+ "                            <wsp:Policy>\n"+ "                                <sp:Lax/>\n"+ "                            </wsp:Policy>\n"+ "                        </sp:Layout>\n"+ "                        <sp:IncludeTimestamp/>\n"+ "                        <sp:OnlySignEntireHeadersAndBody/>\n"+ "                    </wsp:Policy>\n"+ "                </sp:AsymmetricBinding>\n"+ "                <sp:EncryptedParts>\n"+ "                    <sp:Body/>\n"+ "                    <sp:Header Name=\"Header2\" Namespace=\"...\"/>\n"+ "                    <sp:Header Namespace=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\"/>\n"+ "                </sp:EncryptedParts>\n"+ "                <sp:EncryptedElements>\n"+ "                    <sp:XPath xmlns:wsu=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\">wsu:Created</sp:XPath>\n"+ "                </sp:EncryptedElements>\n"+ "                <sp:ContentEncryptedElements>\n"+ "                    <sp:XPath xmlns:wsu=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\">wsu:Expires</sp:XPath>\n"+ "                </sp:ContentEncryptedElements>\n"+ "            </wsp:All>\n"+ "        </wsp:ExactlyOne>";
  WSSSecurityProperties outSecurityProperties=new WSSSecurityProperties();
  outSecurityProperties.setCallbackHandler(new CallbackHandlerImpl());
  outSecurityProperties.setEncryptionUser("receiver");
  outSecurityProperties.loadEncryptionKeystore(this.getClass().getClassLoader().getResource("transmitter.jks"),"default".toCharArray());
  outSecurityProperties.setSignatureUser("transmitter");
  outSecurityProperties.loadSignatureKeyStore(this.getClass().getClassLoader().getResource("transmitter.jks"),"default".toCharArray());
  outSecurityProperties.addSignaturePart(new SecurePart(WSSConstants.TAG_WSU_TIMESTAMP,SecurePart.Modifier.Element));
  outSecurityProperties.addSignaturePart(new SecurePart(new QName("http://schemas.xmlsoap.org/wsdl/","definitions"),SecurePart.Modifier.Element));
  outSecurityProperties.addEncryptionPart(new SecurePart(WSSConstants.TAG_WSU_CREATED,SecurePart.Modifier.Element));
  outSecurityProperties.addEncryptionPart(new SecurePart(WSSConstants.TAG_WSU_EXPIRES,SecurePart.Modifier.Content));
  outSecurityProperties.addEncryptionPart(new SecurePart(WSSConstants.TAG_SOAP11_BODY,SecurePart.Modifier.Content));
  List<WSSConstants.Action> actions=new ArrayList<>();
  actions.add(WSSConstants.TIMESTAMP);
  actions.add(WSSConstants.SIGNATURE);
  actions.add(WSSConstants.ENCRYPT);
  outSecurityProperties.setActions(actions);
  InputStream sourceDocument=this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml");
  ByteArrayOutputStream baos=doOutboundSecurity(outSecurityProperties,sourceDocument);
  WSSSecurityProperties inSecurityProperties=new WSSSecurityProperties();
  inSecurityProperties.setCallbackHandler(new CallbackHandlerImpl());
  inSecurityProperties.loadSignatureVerificationKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
  inSecurityProperties.loadDecryptionKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
  PolicyEnforcer policyEnforcer=buildAndStartPolicyEngine(policyString);
  inSecurityProperties.addInputProcessor(new PolicyInputProcessor(policyEnforcer,inSecurityProperties));
  try {
    Document document=doInboundSecurity(inSecurityProperties,new ByteArrayInputStream(baos.toByteArray()),policyEnforcer);
    Transformer transformer=TransformerFactory.newInstance().newTransformer();
    transformer.transform(new DOMSource(document),new StreamResult(new OutputStream(){
      @Override public void write(      int b) throws IOException {
      }
    }
));
    Assert.fail("Exception expected");
  }
 catch (  XMLStreamException e) {
    Assert.assertTrue(e.getCause() instanceof WSSecurityException);
    Assert.assertEquals(e.getCause().getMessage(),"OnlySignEntireHeadersAndBody not fulfilled, offending element: " + "/{http://schemas.xmlsoap.org/soap/envelope/}Envelope/{http://schemas.xmlsoap.org/soap/envelope/}Body/{http://schemas.xmlsoap.org/wsdl/}definitions");
    Assert.assertEquals(((WSSecurityException)e.getCause()).getFaultCode(),WSSecurityException.INVALID_SECURITY);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testRecipientTokenInclusionAlwaysToRecipientPolicy() throws Exception {
  String policyString="<wsp:ExactlyOne xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\" " + "xmlns:sp=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702\">\n" + "            <wsp:All>\n"+ "                <sp:AsymmetricBinding>\n"+ "                    <wsp:Policy>\n"+ "                        <sp:InitiatorToken>\n"+ "                            <wsp:Policy>\n"+ "                                <sp:X509Token sp:IncludeToken=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702/IncludeToken/Never\">\n"+ "                                    <sp:IssuerName>CN=transmitter,OU=swssf,C=CH</sp:IssuerName>\n"+ "                                    <wsp:Policy>\n"+ "                                        <sp:WssX509V3Token11/>\n"+ "                                    </wsp:Policy>\n"+ "                                </sp:X509Token>\n"+ "                            </wsp:Policy>\n"+ "                        </sp:InitiatorToken>\n"+ "                        <sp:RecipientToken>\n"+ "                            <wsp:Policy>\n"+ "                              <sp:X509Token sp:IncludeToken=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702/IncludeToken/AlwaysToRecipient\">\n"+ "                                  <sp:IssuerName>CN=receiver,OU=swssf,C=CH</sp:IssuerName>\n"+ "                                  <wsp:Policy>\n"+ "                                      <sp:WssX509V3Token11/>\n"+ "                                  </wsp:Policy>\n"+ "                              </sp:X509Token>\n"+ "                            </wsp:Policy>\n"+ "                         </sp:RecipientToken>\n"+ "                        <sp:AlgorithmSuite>\n"+ "                            <wsp:Policy>\n"+ "                                <sp:Basic256/>\n"+ "                            </wsp:Policy>\n"+ "                        </sp:AlgorithmSuite>\n"+ "                        <sp:Layout>\n"+ "                            <wsp:Policy>\n"+ "                                <sp:Lax/>\n"+ "                            </wsp:Policy>\n"+ "                        </sp:Layout>\n"+ "                        <sp:IncludeTimestamp/>\n"+ "                    </wsp:Policy>\n"+ "                </sp:AsymmetricBinding>\n"+ "                <sp:SignedParts>\n"+ "                    <sp:Body/>\n"+ "                    <sp:Header Name=\"Header1\" Namespace=\"...\"/>\n"+ "                    <sp:Header Namespace=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\"/>\n"+ "                </sp:SignedParts>\n"+ "                <sp:SignedElements>\n"+ "                    <sp:XPath xmlns:wsu=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\">wsu:Created</sp:XPath>\n"+ "                </sp:SignedElements>\n"+ "                <sp:EncryptedParts>\n"+ "                    <sp:Body/>\n"+ "                    <sp:Header Name=\"Header2\" Namespace=\"...\"/>\n"+ "                    <sp:Header Namespace=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\"/>\n"+ "                </sp:EncryptedParts>\n"+ "                <sp:EncryptedElements>\n"+ "                    <sp:XPath xmlns:wsu=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\">wsu:Created</sp:XPath>\n"+ "                </sp:EncryptedElements>\n"+ "                <sp:ContentEncryptedElements>\n"+ "                    <sp:XPath xmlns:wsu=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\">wsu:Expires</sp:XPath>\n"+ "                </sp:ContentEncryptedElements>\n"+ "            </wsp:All>\n"+ "        </wsp:ExactlyOne>";
  WSSSecurityProperties outSecurityProperties=new WSSSecurityProperties();
  outSecurityProperties.setCallbackHandler(new CallbackHandlerImpl());
  outSecurityProperties.setEncryptionUser("receiver");
  outSecurityProperties.loadEncryptionKeystore(this.getClass().getClassLoader().getResource("transmitter.jks"),"default".toCharArray());
  outSecurityProperties.setSignatureUser("transmitter");
  outSecurityProperties.loadSignatureKeyStore(this.getClass().getClassLoader().getResource("transmitter.jks"),"default".toCharArray());
  outSecurityProperties.addSignaturePart(new SecurePart(WSSConstants.TAG_WSU_TIMESTAMP,SecurePart.Modifier.Element));
  outSecurityProperties.addSignaturePart(new SecurePart(WSSConstants.TAG_SOAP11_BODY,SecurePart.Modifier.Element));
  outSecurityProperties.addEncryptionPart(new SecurePart(WSSConstants.TAG_WSU_CREATED,SecurePart.Modifier.Element));
  outSecurityProperties.addEncryptionPart(new SecurePart(WSSConstants.TAG_WSU_EXPIRES,SecurePart.Modifier.Content));
  outSecurityProperties.addEncryptionPart(new SecurePart(WSSConstants.TAG_SOAP11_BODY,SecurePart.Modifier.Content));
  List<WSSConstants.Action> actions=new ArrayList<>();
  actions.add(WSSConstants.TIMESTAMP);
  actions.add(WSSConstants.SIGNATURE);
  actions.add(WSSConstants.ENCRYPT);
  outSecurityProperties.setActions(actions);
  InputStream sourceDocument=this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml");
  ByteArrayOutputStream baos=doOutboundSecurity(outSecurityProperties,sourceDocument);
  WSSSecurityProperties inSecurityProperties=new WSSSecurityProperties();
  inSecurityProperties.setCallbackHandler(new CallbackHandlerImpl());
  inSecurityProperties.loadSignatureVerificationKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
  inSecurityProperties.loadDecryptionKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
  PolicyEnforcer policyEnforcer=buildAndStartPolicyEngine(policyString);
  inSecurityProperties.addInputProcessor(new PolicyInputProcessor(policyEnforcer,inSecurityProperties));
  try {
    Document document=doInboundSecurity(inSecurityProperties,new ByteArrayInputStream(baos.toByteArray()),policyEnforcer);
    Transformer transformer=TransformerFactory.newInstance().newTransformer();
    transformer.transform(new DOMSource(document),new StreamResult(new OutputStream(){
      @Override public void write(      int b) throws IOException {
      }
    }
));
    Assert.fail("Exception expected");
  }
 catch (  XMLStreamException e) {
    Assert.assertTrue(e.getCause() instanceof WSSecurityException);
    Assert.assertEquals(e.getCause().getMessage(),"Token must be included");
    Assert.assertEquals(((WSSecurityException)e.getCause()).getFaultCode(),WSSecurityException.INVALID_SECURITY);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testEncryptionAlgorithmSuiteNegative() throws Exception {
  String policyString="<wsp:ExactlyOne xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\" " + "xmlns:sp=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702\">\n" + "            <wsp:All>\n"+ "                <sp:AsymmetricBinding>\n"+ "                    <wsp:Policy>\n"+ "                        <sp:InitiatorToken>\n"+ "                            <wsp:Policy>\n"+ "                                <sp:X509Token sp:IncludeToken=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702/IncludeToken/AlwaysToRecipient\">\n"+ "                                    <sp:IssuerName>CN=transmitter,OU=swssf,C=CH</sp:IssuerName>\n"+ "                                    <wsp:Policy>\n"+ "                                        <sp:WssX509V3Token11/>\n"+ "                                    </wsp:Policy>\n"+ "                                </sp:X509Token>\n"+ "                            </wsp:Policy>\n"+ "                        </sp:InitiatorToken>\n"+ "                        <sp:RecipientToken>\n"+ "                            <wsp:Policy>\n"+ "                              <sp:X509Token sp:IncludeToken=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702/IncludeToken/AlwaysToRecipient\">\n"+ "                                  <sp:IssuerName>CN=receiver,OU=swssf,C=CH</sp:IssuerName>\n"+ "                                  <wsp:Policy>\n"+ "                                      <sp:WssX509V3Token11/>\n"+ "                                  </wsp:Policy>\n"+ "                              </sp:X509Token>\n"+ "                            </wsp:Policy>\n"+ "                         </sp:RecipientToken>\n"+ "                        <sp:AlgorithmSuite>\n"+ "                            <wsp:Policy>\n"+ "                                <sp:Basic256/>\n"+ "                            </wsp:Policy>\n"+ "                        </sp:AlgorithmSuite>\n"+ "                        <sp:Layout>\n"+ "                            <wsp:Policy>\n"+ "                                <sp:Lax/>\n"+ "                            </wsp:Policy>\n"+ "                        </sp:Layout>\n"+ "                        <sp:IncludeTimestamp/>\n"+ "                        <sp:ProtectTokens/>\n"+ "                    </wsp:Policy>\n"+ "                </sp:AsymmetricBinding>\n"+ "                <sp:SignedParts>\n"+ "                    <sp:Body/>\n"+ "                    <sp:Header Name=\"Header1\" Namespace=\"...\"/>\n"+ "                    <sp:Header Namespace=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\"/>\n"+ "                </sp:SignedParts>\n"+ "                <sp:SignedElements>\n"+ "                    <sp:XPath xmlns:wsu=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\">wsu:Created</sp:XPath>\n"+ "                </sp:SignedElements>\n"+ "                <sp:EncryptedParts>\n"+ "                    <sp:Body/>\n"+ "                    <sp:Header Name=\"Header2\" Namespace=\"...\"/>\n"+ "                    <sp:Header Namespace=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\"/>\n"+ "                </sp:EncryptedParts>\n"+ "                <sp:EncryptedElements>\n"+ "                    <sp:XPath xmlns:wsu=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\">wsu:Created</sp:XPath>\n"+ "                </sp:EncryptedElements>\n"+ "                <sp:ContentEncryptedElements>\n"+ "                    <sp:XPath xmlns:wsu=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\">wsu:Expires</sp:XPath>\n"+ "                </sp:ContentEncryptedElements>\n"+ "            </wsp:All>\n"+ "        </wsp:ExactlyOne>";
  WSSSecurityProperties outSecurityProperties=new WSSSecurityProperties();
  outSecurityProperties.setCallbackHandler(new CallbackHandlerImpl());
  outSecurityProperties.setEncryptionUser("receiver");
  outSecurityProperties.loadEncryptionKeystore(this.getClass().getClassLoader().getResource("transmitter.jks"),"default".toCharArray());
  outSecurityProperties.setEncryptionSymAlgorithm("http://www.w3.org/2001/04/xmlenc#tripledes-cbc");
  outSecurityProperties.setSignatureUser("transmitter");
  outSecurityProperties.loadSignatureKeyStore(this.getClass().getClassLoader().getResource("transmitter.jks"),"default".toCharArray());
  outSecurityProperties.addSignaturePart(new SecurePart(WSSConstants.TAG_WSU_TIMESTAMP,SecurePart.Modifier.Element));
  outSecurityProperties.addSignaturePart(new SecurePart(WSSConstants.TAG_SOAP11_BODY,SecurePart.Modifier.Element));
  outSecurityProperties.addEncryptionPart(new SecurePart(WSSConstants.TAG_WSU_CREATED,SecurePart.Modifier.Element));
  outSecurityProperties.addEncryptionPart(new SecurePart(WSSConstants.TAG_WSU_EXPIRES,SecurePart.Modifier.Content));
  outSecurityProperties.addEncryptionPart(new SecurePart(WSSConstants.TAG_SOAP11_BODY,SecurePart.Modifier.Content));
  List<WSSConstants.Action> actions=new ArrayList<>();
  actions.add(WSSConstants.TIMESTAMP);
  actions.add(WSSConstants.SIGNATURE);
  actions.add(WSSConstants.ENCRYPT);
  outSecurityProperties.setActions(actions);
  InputStream sourceDocument=this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml");
  ByteArrayOutputStream baos=doOutboundSecurity(outSecurityProperties,sourceDocument);
  WSSSecurityProperties inSecurityProperties=new WSSSecurityProperties();
  inSecurityProperties.setCallbackHandler(new CallbackHandlerImpl());
  inSecurityProperties.loadSignatureVerificationKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
  inSecurityProperties.loadDecryptionKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
  PolicyEnforcer policyEnforcer=buildAndStartPolicyEngine(policyString);
  inSecurityProperties.addInputProcessor(new PolicyInputProcessor(policyEnforcer,inSecurityProperties));
  try {
    Document document=doInboundSecurity(inSecurityProperties,new ByteArrayInputStream(baos.toByteArray()),policyEnforcer);
    Transformer transformer=TransformerFactory.newInstance().newTransformer();
    transformer.transform(new DOMSource(document),new StreamResult(new OutputStream(){
      @Override public void write(      int b) throws IOException {
      }
    }
));
    Assert.fail("Exception expected");
  }
 catch (  XMLStreamException e) {
    Assert.assertTrue(e.getCause() instanceof WSSecurityException);
    Assert.assertEquals(e.getCause().getMessage(),"Encryption algorithm http://www.w3.org/2001/04/xmlenc#tripledes-cbc does not meet policy\n" + "Symmetric encryption algorithm key length 192 does not meet policy");
    Assert.assertEquals(((WSSecurityException)e.getCause()).getFaultCode(),WSSecurityException.INVALID_SECURITY);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testIncludeTimestampAndSignedUsernameSupportingTokenPolicyNegativeTest2() throws Exception {
  String policyString="<wsp:ExactlyOne xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\" " + "xmlns:sp=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702\">\n" + "            <wsp:All>\n"+ "                <sp:AsymmetricBinding>\n"+ "                    <wsp:Policy>\n"+ "                        <sp:InitiatorToken>\n"+ "                            <wsp:Policy>\n"+ "                                <sp:X509Token sp:IncludeToken=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702/IncludeToken/Never\">\n"+ "                                    <sp:IssuerName>CN=transmitter,OU=swssf,C=CH</sp:IssuerName>\n"+ "                                    <wsp:Policy>\n"+ "                                        <sp:WssX509V3Token11/>\n"+ "                                    </wsp:Policy>\n"+ "                                </sp:X509Token>\n"+ "                            </wsp:Policy>\n"+ "                        </sp:InitiatorToken>\n"+ "                        <sp:RecipientToken>\n"+ "                            <wsp:Policy>\n"+ "                              <sp:X509Token sp:IncludeToken=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702/IncludeToken/Never\">\n"+ "                                  <sp:IssuerName>CN=receiver,OU=swssf,C=CH</sp:IssuerName>\n"+ "                                  <wsp:Policy>\n"+ "                                      <sp:WssX509V3Token11/>\n"+ "                                  </wsp:Policy>\n"+ "                              </sp:X509Token>\n"+ "                            </wsp:Policy>\n"+ "                         </sp:RecipientToken>\n"+ "                        <sp:AlgorithmSuite>\n"+ "                            <wsp:Policy>\n"+ "                                <sp:Basic256/>\n"+ "                            </wsp:Policy>\n"+ "                        </sp:AlgorithmSuite>\n"+ "                        <sp:Layout>\n"+ "                            <wsp:Policy>\n"+ "                                <sp:Lax/>\n"+ "                            </wsp:Policy>\n"+ "                        </sp:Layout>\n"+ "                        <sp:IncludeTimestamp/>\n"+ "                    </wsp:Policy>\n"+ "                </sp:AsymmetricBinding>\n"+ "                <sp:SignedParts>\n"+ "                    <sp:Body/>\n"+ "                    <sp:Header Name=\"Header1\" Namespace=\"...\"/>\n"+ "                    <sp:Header Namespace=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\"/>\n"+ "                </sp:SignedParts>\n"+ "                <sp:SignedElements>\n"+ "                    <sp:XPath xmlns:wsu=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\">wsu:Created</sp:XPath>\n"+ "                </sp:SignedElements>\n"+ "                <sp:EncryptedParts>\n"+ "                    <sp:Body/>\n"+ "                    <sp:Header Name=\"Header2\" Namespace=\"...\"/>\n"+ "                    <sp:Header Namespace=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\"/>\n"+ "                </sp:EncryptedParts>\n"+ "                <sp:EncryptedElements>\n"+ "                    <sp:XPath xmlns:wsu=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\">wsu:Created</sp:XPath>\n"+ "                </sp:EncryptedElements>\n"+ "                <sp:ContentEncryptedElements>\n"+ "                    <sp:XPath xmlns:wsu=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\">wsu:Expires</sp:XPath>\n"+ "                </sp:ContentEncryptedElements>\n"+ "                <sp:SignedSupportingTokens>\n"+ "                    <wsp:Policy>\n"+ "                        <sp:UsernameToken sp:IncludeToken=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702/IncludeToken/AlwaysToRecipient\">\n"+ "                            <wsp:Policy>\n"+ "                                <sp:NoPassword/>\n"+ "                            </wsp:Policy>\n"+ "                        </sp:UsernameToken>\n"+ "                    </wsp:Policy>\n"+ "                </sp:SignedSupportingTokens>\n"+ "            </wsp:All>\n"+ "        </wsp:ExactlyOne>";
  WSSSecurityProperties outSecurityProperties=new WSSSecurityProperties();
  outSecurityProperties.setCallbackHandler(new CallbackHandlerImpl());
  outSecurityProperties.setEncryptionUser("receiver");
  outSecurityProperties.loadEncryptionKeystore(this.getClass().getClassLoader().getResource("transmitter.jks"),"default".toCharArray());
  outSecurityProperties.setSignatureUser("transmitter");
  outSecurityProperties.setTokenUser("transmitter");
  outSecurityProperties.setUsernameTokenPasswordType(WSSConstants.UsernameTokenPasswordType.PASSWORD_NONE);
  outSecurityProperties.loadSignatureKeyStore(this.getClass().getClassLoader().getResource("transmitter.jks"),"default".toCharArray());
  outSecurityProperties.addSignaturePart(new SecurePart(WSSConstants.TAG_WSU_TIMESTAMP,SecurePart.Modifier.Element));
  outSecurityProperties.addSignaturePart(new SecurePart(WSSConstants.TAG_SOAP11_BODY,SecurePart.Modifier.Element));
  outSecurityProperties.addEncryptionPart(new SecurePart(WSSConstants.TAG_WSU_CREATED,SecurePart.Modifier.Element));
  outSecurityProperties.addEncryptionPart(new SecurePart(WSSConstants.TAG_WSU_EXPIRES,SecurePart.Modifier.Content));
  outSecurityProperties.addEncryptionPart(new SecurePart(WSSConstants.TAG_SOAP11_BODY,SecurePart.Modifier.Content));
  List<WSSConstants.Action> actions=new ArrayList<>();
  actions.add(WSSConstants.USERNAMETOKEN);
  actions.add(WSSConstants.TIMESTAMP);
  actions.add(WSSConstants.SIGNATURE);
  actions.add(WSSConstants.ENCRYPT);
  outSecurityProperties.setActions(actions);
  InputStream sourceDocument=this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml");
  ByteArrayOutputStream baos=doOutboundSecurity(outSecurityProperties,sourceDocument);
  WSSSecurityProperties inSecurityProperties=new WSSSecurityProperties();
  inSecurityProperties.setCallbackHandler(new CallbackHandlerImpl());
  inSecurityProperties.loadSignatureVerificationKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
  inSecurityProperties.loadDecryptionKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
  PolicyEnforcer policyEnforcer=buildAndStartPolicyEngine(policyString);
  inSecurityProperties.addInputProcessor(new PolicyInputProcessor(policyEnforcer,inSecurityProperties));
  try {
    Document document=doInboundSecurity(inSecurityProperties,new ByteArrayInputStream(baos.toByteArray()),policyEnforcer);
    Transformer transformer=TransformerFactory.newInstance().newTransformer();
    transformer.transform(new DOMSource(document),new StreamResult(new OutputStream(){
      @Override public void write(      int b) throws IOException {
      }
    }
));
    Assert.fail("Exception expected");
  }
 catch (  XMLStreamException e) {
    Assert.assertTrue(e.getCause() instanceof WSSecurityException);
    Assert.assertEquals(e.getCause().getMessage(),"Assertion {http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702}UsernameToken not satisfied");
    Assert.assertEquals(((WSSecurityException)e.getCause()).getFaultCode(),WSSecurityException.INVALID_SECURITY);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testEncryptBeforeSigningNegativeTest() throws Exception {
  String policyString="<wsp:ExactlyOne xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\" " + "xmlns:sp=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702\">\n" + "            <wsp:All>\n"+ "                <sp:AsymmetricBinding>\n"+ "                    <wsp:Policy>\n"+ "                        <sp:InitiatorToken>\n"+ "                            <wsp:Policy>\n"+ "                                <sp:X509Token sp:IncludeToken=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702/IncludeToken/Never\">\n"+ "                                    <sp:IssuerName>CN=transmitter,OU=swssf,C=CH</sp:IssuerName>\n"+ "                                    <wsp:Policy>\n"+ "                                        <sp:WssX509V3Token11/>\n"+ "                                    </wsp:Policy>\n"+ "                                </sp:X509Token>\n"+ "                            </wsp:Policy>\n"+ "                        </sp:InitiatorToken>\n"+ "                        <sp:RecipientToken>\n"+ "                            <wsp:Policy>\n"+ "                              <sp:X509Token sp:IncludeToken=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702/IncludeToken/Never\">\n"+ "                                  <sp:IssuerName>CN=receiver,OU=swssf,C=CH</sp:IssuerName>\n"+ "                                  <wsp:Policy>\n"+ "                                      <sp:WssX509V3Token11/>\n"+ "                                  </wsp:Policy>\n"+ "                              </sp:X509Token>\n"+ "                            </wsp:Policy>\n"+ "                         </sp:RecipientToken>\n"+ "                        <sp:AlgorithmSuite>\n"+ "                            <wsp:Policy>\n"+ "                                <sp:Basic256/>\n"+ "                            </wsp:Policy>\n"+ "                        </sp:AlgorithmSuite>\n"+ "                        <sp:Layout>\n"+ "                            <wsp:Policy>\n"+ "                                <sp:Lax/>\n"+ "                            </wsp:Policy>\n"+ "                        </sp:Layout>\n"+ "                        <sp:EncryptBeforeSigning/>\n"+ "                        <sp:IncludeTimestamp/>\n"+ "                    </wsp:Policy>\n"+ "                </sp:AsymmetricBinding>\n"+ "                <sp:SignedParts>\n"+ "                    <sp:Body/>\n"+ "                    <sp:Header Name=\"Header1\" Namespace=\"...\"/>\n"+ "                    <sp:Header Namespace=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\"/>\n"+ "                </sp:SignedParts>\n"+ "                <sp:SignedElements>\n"+ "                    <sp:XPath xmlns:wsu=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\">wsu:Created</sp:XPath>\n"+ "                </sp:SignedElements>\n"+ "                <sp:EncryptedParts>\n"+ "                    <sp:Body/>\n"+ "                    <sp:Header Name=\"Header2\" Namespace=\"...\"/>\n"+ "                    <sp:Header Namespace=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\"/>\n"+ "                </sp:EncryptedParts>\n"+ "                <sp:EncryptedElements>\n"+ "                    <sp:XPath xmlns:wsu=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\">wsu:Created</sp:XPath>\n"+ "                </sp:EncryptedElements>\n"+ "                <sp:ContentEncryptedElements>\n"+ "                    <sp:XPath xmlns:wsu=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\">wsu:Expires</sp:XPath>\n"+ "                </sp:ContentEncryptedElements>\n"+ "            </wsp:All>\n"+ "        </wsp:ExactlyOne>";
  WSSSecurityProperties outSecurityProperties=new WSSSecurityProperties();
  outSecurityProperties.setCallbackHandler(new CallbackHandlerImpl());
  outSecurityProperties.setEncryptionUser("receiver");
  outSecurityProperties.loadEncryptionKeystore(this.getClass().getClassLoader().getResource("transmitter.jks"),"default".toCharArray());
  outSecurityProperties.setSignatureUser("transmitter");
  outSecurityProperties.loadSignatureKeyStore(this.getClass().getClassLoader().getResource("transmitter.jks"),"default".toCharArray());
  outSecurityProperties.addSignaturePart(new SecurePart(WSSConstants.TAG_WSU_TIMESTAMP,SecurePart.Modifier.Element));
  outSecurityProperties.addSignaturePart(new SecurePart(WSSConstants.TAG_SOAP11_BODY,SecurePart.Modifier.Element));
  outSecurityProperties.addEncryptionPart(new SecurePart(WSSConstants.TAG_SOAP11_BODY,SecurePart.Modifier.Content));
  List<WSSConstants.Action> actions=new ArrayList<>();
  actions.add(WSSConstants.TIMESTAMP);
  actions.add(WSSConstants.SIGNATURE);
  actions.add(WSSConstants.ENCRYPT);
  outSecurityProperties.setActions(actions);
  InputStream sourceDocument=this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml");
  ByteArrayOutputStream baos=doOutboundSecurity(outSecurityProperties,sourceDocument);
  WSSSecurityProperties inSecurityProperties=new WSSSecurityProperties();
  inSecurityProperties.setCallbackHandler(new CallbackHandlerImpl());
  inSecurityProperties.loadSignatureVerificationKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
  inSecurityProperties.loadDecryptionKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
  PolicyEnforcer policyEnforcer=buildAndStartPolicyEngine(policyString);
  inSecurityProperties.addInputProcessor(new PolicyInputProcessor(policyEnforcer,inSecurityProperties));
  try {
    Document document=doInboundSecurity(inSecurityProperties,new ByteArrayInputStream(baos.toByteArray()),policyEnforcer);
    Transformer transformer=TransformerFactory.newInstance().newTransformer();
    transformer.transform(new DOMSource(document),new StreamResult(new OutputStream(){
      @Override public void write(      int b) throws IOException {
      }
    }
));
    Assert.fail("Exception expected");
  }
 catch (  XMLStreamException e) {
    Assert.assertTrue(e.getCause() instanceof WSSecurityException);
    Assert.assertEquals(e.getCause().getMessage(),"Policy enforces EncryptBeforeSigning but the /{http://schemas.xmlsoap.org/soap/envelope/}Envelope/{http://schemas.xmlsoap.org/soap/envelope/}Body was signed and then encrypted");
    Assert.assertEquals(((WSSecurityException)e.getCause()).getFaultCode(),WSSecurityException.INVALID_SECURITY);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testSignBeforeEncryptNegativeTest() throws Exception {
  String policyString="<wsp:ExactlyOne xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\" " + "xmlns:sp=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702\">\n" + "            <wsp:All>\n"+ "                <sp:AsymmetricBinding>\n"+ "                    <wsp:Policy>\n"+ "                        <sp:InitiatorToken>\n"+ "                            <wsp:Policy>\n"+ "                                <sp:X509Token sp:IncludeToken=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702/IncludeToken/Never\">\n"+ "                                    <sp:IssuerName>CN=transmitter,OU=swssf,C=CH</sp:IssuerName>\n"+ "                                    <wsp:Policy>\n"+ "                                        <sp:WssX509V3Token11/>\n"+ "                                    </wsp:Policy>\n"+ "                                </sp:X509Token>\n"+ "                            </wsp:Policy>\n"+ "                        </sp:InitiatorToken>\n"+ "                        <sp:RecipientToken>\n"+ "                            <wsp:Policy>\n"+ "                              <sp:X509Token sp:IncludeToken=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702/IncludeToken/Never\">\n"+ "                                  <sp:IssuerName>CN=receiver,OU=swssf,C=CH</sp:IssuerName>\n"+ "                                  <wsp:Policy>\n"+ "                                      <sp:WssX509V3Token11/>\n"+ "                                  </wsp:Policy>\n"+ "                              </sp:X509Token>\n"+ "                            </wsp:Policy>\n"+ "                         </sp:RecipientToken>\n"+ "                        <sp:AlgorithmSuite>\n"+ "                            <wsp:Policy>\n"+ "                                <sp:Basic256/>\n"+ "                            </wsp:Policy>\n"+ "                        </sp:AlgorithmSuite>\n"+ "                        <sp:Layout>\n"+ "                            <wsp:Policy>\n"+ "                                <sp:Lax/>\n"+ "                            </wsp:Policy>\n"+ "                        </sp:Layout>\n"+ "                        <sp:SignBeforeEncrypting/>\n"+ "                        <sp:IncludeTimestamp/>\n"+ "                    </wsp:Policy>\n"+ "                </sp:AsymmetricBinding>\n"+ "                <sp:SignedParts>\n"+ "                    <sp:Body/>\n"+ "                    <sp:Header Name=\"Header1\" Namespace=\"...\"/>\n"+ "                    <sp:Header Namespace=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\"/>\n"+ "                </sp:SignedParts>\n"+ "                <sp:SignedElements>\n"+ "                    <sp:XPath xmlns:wsu=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\">wsu:Created</sp:XPath>\n"+ "                </sp:SignedElements>\n"+ "                <sp:EncryptedParts>\n"+ "                    <sp:Body/>\n"+ "                    <sp:Header Name=\"Header2\" Namespace=\"...\"/>\n"+ "                    <sp:Header Namespace=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\"/>\n"+ "                </sp:EncryptedParts>\n"+ "                <sp:EncryptedElements>\n"+ "                    <sp:XPath xmlns:wsu=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\">wsu:Created</sp:XPath>\n"+ "                </sp:EncryptedElements>\n"+ "                <sp:ContentEncryptedElements>\n"+ "                    <sp:XPath xmlns:wsu=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\">wsu:Expires</sp:XPath>\n"+ "                </sp:ContentEncryptedElements>\n"+ "            </wsp:All>\n"+ "        </wsp:ExactlyOne>";
  WSSSecurityProperties outSecurityProperties=new WSSSecurityProperties();
  outSecurityProperties.setCallbackHandler(new CallbackHandlerImpl());
  outSecurityProperties.setEncryptionUser("receiver");
  outSecurityProperties.loadEncryptionKeystore(this.getClass().getClassLoader().getResource("transmitter.jks"),"default".toCharArray());
  outSecurityProperties.setSignatureUser("transmitter");
  outSecurityProperties.loadSignatureKeyStore(this.getClass().getClassLoader().getResource("transmitter.jks"),"default".toCharArray());
  outSecurityProperties.addSignaturePart(new SecurePart(WSSConstants.TAG_WSU_TIMESTAMP,SecurePart.Modifier.Element));
  outSecurityProperties.addSignaturePart(new SecurePart(WSSConstants.TAG_SOAP11_BODY,SecurePart.Modifier.Element));
  outSecurityProperties.addEncryptionPart(new SecurePart(WSSConstants.TAG_SOAP11_BODY,SecurePart.Modifier.Content));
  List<WSSConstants.Action> actions=new ArrayList<>();
  actions.add(WSSConstants.TIMESTAMP);
  actions.add(WSSConstants.ENCRYPT);
  actions.add(WSSConstants.SIGNATURE);
  outSecurityProperties.setActions(actions);
  InputStream sourceDocument=this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml");
  ByteArrayOutputStream baos=doOutboundSecurity(outSecurityProperties,sourceDocument);
  WSSSecurityProperties inSecurityProperties=new WSSSecurityProperties();
  inSecurityProperties.setCallbackHandler(new CallbackHandlerImpl());
  inSecurityProperties.loadSignatureVerificationKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
  inSecurityProperties.loadDecryptionKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
  PolicyEnforcer policyEnforcer=buildAndStartPolicyEngine(policyString);
  inSecurityProperties.addInputProcessor(new PolicyInputProcessor(policyEnforcer,inSecurityProperties));
  try {
    Document document=doInboundSecurity(inSecurityProperties,new ByteArrayInputStream(baos.toByteArray()),policyEnforcer);
    Transformer transformer=TransformerFactory.newInstance().newTransformer();
    transformer.transform(new DOMSource(document),new StreamResult(new OutputStream(){
      @Override public void write(      int b) throws IOException {
      }
    }
));
    Assert.fail("Exception expected");
  }
 catch (  XMLStreamException e) {
    Assert.assertTrue(e.getCause() instanceof WSSecurityException);
    Assert.assertEquals(e.getCause().getMessage(),"Policy enforces SignBeforeEncrypting but the /{http://schemas.xmlsoap.org/soap/envelope/}Envelope/{http://schemas.xmlsoap.org/soap/envelope/}Body was encrypted and then signed");
    Assert.assertEquals(((WSSecurityException)e.getCause()).getFaultCode(),WSSecurityException.INVALID_SECURITY);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testSignatureProtectionPolicyNegative2() throws Exception {
  String policyString="<wsp:ExactlyOne xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\" " + "xmlns:sp=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702\">\n" + "            <wsp:All>\n"+ "                <sp:AsymmetricBinding>\n"+ "                    <wsp:Policy>\n"+ "                        <sp:InitiatorToken>\n"+ "                            <wsp:Policy>\n"+ "                                <sp:X509Token sp:IncludeToken=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702/IncludeToken/Never\">\n"+ "                                    <sp:IssuerName>CN=transmitter,OU=swssf,C=CH</sp:IssuerName>\n"+ "                                    <wsp:Policy>\n"+ "                                        <sp:WssX509V3Token11/>\n"+ "                                    </wsp:Policy>\n"+ "                                </sp:X509Token>\n"+ "                            </wsp:Policy>\n"+ "                        </sp:InitiatorToken>\n"+ "                        <sp:RecipientToken>\n"+ "                            <wsp:Policy>\n"+ "                              <sp:X509Token sp:IncludeToken=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702/IncludeToken/Never\">\n"+ "                                  <sp:IssuerName>CN=receiver,OU=swssf,C=CH</sp:IssuerName>\n"+ "                                  <wsp:Policy>\n"+ "                                      <sp:WssX509V3Token11/>\n"+ "                                  </wsp:Policy>\n"+ "                              </sp:X509Token>\n"+ "                            </wsp:Policy>\n"+ "                         </sp:RecipientToken>\n"+ "                        <sp:AlgorithmSuite>\n"+ "                            <wsp:Policy>\n"+ "                                <sp:Basic256/>\n"+ "                            </wsp:Policy>\n"+ "                        </sp:AlgorithmSuite>\n"+ "                        <sp:Layout>\n"+ "                            <wsp:Policy>\n"+ "                                <sp:Lax/>\n"+ "                            </wsp:Policy>\n"+ "                        </sp:Layout>\n"+ "                        <sp:IncludeTimestamp/>\n"+ "                    </wsp:Policy>\n"+ "                </sp:AsymmetricBinding>\n"+ "                <sp:SignedParts>\n"+ "                    <sp:Body/>\n"+ "                    <sp:Header Name=\"Header1\" Namespace=\"...\"/>\n"+ "                    <sp:Header Namespace=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\"/>\n"+ "                </sp:SignedParts>\n"+ "                <sp:SignedElements>\n"+ "                    <sp:XPath xmlns:wsu=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\">wsu:Created</sp:XPath>\n"+ "                </sp:SignedElements>\n"+ "                <sp:EncryptedParts>\n"+ "                    <sp:Body/>\n"+ "                    <sp:Header Name=\"Header2\" Namespace=\"...\"/>\n"+ "                    <sp:Header Namespace=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\"/>\n"+ "                </sp:EncryptedParts>\n"+ "                <sp:EncryptedElements>\n"+ "                    <sp:XPath xmlns:wsu=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\">wsu:Created</sp:XPath>\n"+ "                </sp:EncryptedElements>\n"+ "                <sp:ContentEncryptedElements>\n"+ "                    <sp:XPath xmlns:wsu=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\">wsu:Expires</sp:XPath>\n"+ "                </sp:ContentEncryptedElements>\n"+ "            </wsp:All>\n"+ "        </wsp:ExactlyOne>";
  WSSSecurityProperties outSecurityProperties=new WSSSecurityProperties();
  outSecurityProperties.setCallbackHandler(new CallbackHandlerImpl());
  outSecurityProperties.setEncryptionUser("receiver");
  outSecurityProperties.loadEncryptionKeystore(this.getClass().getClassLoader().getResource("transmitter.jks"),"default".toCharArray());
  outSecurityProperties.setSignatureUser("transmitter");
  outSecurityProperties.loadSignatureKeyStore(this.getClass().getClassLoader().getResource("transmitter.jks"),"default".toCharArray());
  outSecurityProperties.addSignaturePart(new SecurePart(WSSConstants.TAG_WSU_TIMESTAMP,SecurePart.Modifier.Element));
  outSecurityProperties.addSignaturePart(new SecurePart(WSSConstants.TAG_SOAP11_BODY,SecurePart.Modifier.Element));
  outSecurityProperties.addEncryptionPart(new SecurePart(WSSConstants.TAG_dsig_Signature,SecurePart.Modifier.Element));
  outSecurityProperties.addEncryptionPart(new SecurePart(WSSConstants.TAG_WSU_CREATED,SecurePart.Modifier.Element));
  outSecurityProperties.addEncryptionPart(new SecurePart(WSSConstants.TAG_WSU_EXPIRES,SecurePart.Modifier.Content));
  outSecurityProperties.addEncryptionPart(new SecurePart(WSSConstants.TAG_SOAP11_BODY,SecurePart.Modifier.Content));
  List<WSSConstants.Action> actions=new ArrayList<>();
  actions.add(WSSConstants.TIMESTAMP);
  actions.add(WSSConstants.SIGNATURE);
  actions.add(WSSConstants.ENCRYPT);
  outSecurityProperties.setActions(actions);
  InputStream sourceDocument=this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml");
  ByteArrayOutputStream baos=doOutboundSecurity(outSecurityProperties,sourceDocument);
  WSSSecurityProperties inSecurityProperties=new WSSSecurityProperties();
  inSecurityProperties.setCallbackHandler(new CallbackHandlerImpl());
  inSecurityProperties.loadSignatureVerificationKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
  inSecurityProperties.loadDecryptionKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
  PolicyEnforcer policyEnforcer=buildAndStartPolicyEngine(policyString);
  inSecurityProperties.addInputProcessor(new PolicyInputProcessor(policyEnforcer,inSecurityProperties));
  try {
    Document document=doInboundSecurity(inSecurityProperties,new ByteArrayInputStream(baos.toByteArray()),policyEnforcer);
    Transformer transformer=TransformerFactory.newInstance().newTransformer();
    transformer.transform(new DOMSource(document),new StreamResult(new OutputStream(){
      @Override public void write(      int b) throws IOException {
      }
    }
));
    Assert.fail("Exception expected");
  }
 catch (  XMLStreamException e) {
    Assert.assertTrue(e.getCause() instanceof WSSecurityException);
    Assert.assertEquals(e.getCause().getMessage(),"Element /{http://schemas.xmlsoap.org/soap/envelope/}Envelope/{http://schemas.xmlsoap.org/soap/envelope/}Header/{http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd}Security/{http://www.w3.org/2000/09/xmldsig#}Signature must not be encrypted");
    Assert.assertEquals(((WSSecurityException)e.getCause()).getFaultCode(),WSSecurityException.INVALID_SECURITY);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testSignatureAlgorithmSuiteNegative() throws Exception {
  String policyString="<wsp:ExactlyOne xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\" " + "xmlns:sp=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702\">\n" + "            <wsp:All>\n"+ "                <sp:AsymmetricBinding>\n"+ "                    <wsp:Policy>\n"+ "                        <sp:InitiatorToken>\n"+ "                            <wsp:Policy>\n"+ "                                <sp:X509Token sp:IncludeToken=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702/IncludeToken/AlwaysToRecipient\">\n"+ "                                    <sp:IssuerName>CN=transmitter,OU=swssf,C=CH</sp:IssuerName>\n"+ "                                    <wsp:Policy>\n"+ "                                        <sp:WssX509V3Token11/>\n"+ "                                    </wsp:Policy>\n"+ "                                </sp:X509Token>\n"+ "                            </wsp:Policy>\n"+ "                        </sp:InitiatorToken>\n"+ "                        <sp:RecipientToken>\n"+ "                            <wsp:Policy>\n"+ "                              <sp:X509Token sp:IncludeToken=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702/IncludeToken/AlwaysToRecipient\">\n"+ "                                  <sp:IssuerName>CN=receiver,OU=swssf,C=CH</sp:IssuerName>\n"+ "                                  <wsp:Policy>\n"+ "                                      <sp:WssX509V3Token11/>\n"+ "                                  </wsp:Policy>\n"+ "                              </sp:X509Token>\n"+ "                            </wsp:Policy>\n"+ "                         </sp:RecipientToken>\n"+ "                        <sp:AlgorithmSuite>\n"+ "                            <wsp:Policy>\n"+ "                                <sp:Basic256/>\n"+ "                            </wsp:Policy>\n"+ "                        </sp:AlgorithmSuite>\n"+ "                        <sp:Layout>\n"+ "                            <wsp:Policy>\n"+ "                                <sp:Lax/>\n"+ "                            </wsp:Policy>\n"+ "                        </sp:Layout>\n"+ "                        <sp:IncludeTimestamp/>\n"+ "                        <sp:ProtectTokens/>\n"+ "                    </wsp:Policy>\n"+ "                </sp:AsymmetricBinding>\n"+ "                <sp:SignedParts>\n"+ "                    <sp:Body/>\n"+ "                    <sp:Header Name=\"Header1\" Namespace=\"...\"/>\n"+ "                    <sp:Header Namespace=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\"/>\n"+ "                </sp:SignedParts>\n"+ "                <sp:SignedElements>\n"+ "                    <sp:XPath xmlns:wsu=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\">wsu:Created</sp:XPath>\n"+ "                </sp:SignedElements>\n"+ "                <sp:EncryptedParts>\n"+ "                    <sp:Body/>\n"+ "                    <sp:Header Name=\"Header2\" Namespace=\"...\"/>\n"+ "                    <sp:Header Namespace=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\"/>\n"+ "                </sp:EncryptedParts>\n"+ "                <sp:EncryptedElements>\n"+ "                    <sp:XPath xmlns:wsu=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\">wsu:Created</sp:XPath>\n"+ "                </sp:EncryptedElements>\n"+ "                <sp:ContentEncryptedElements>\n"+ "                    <sp:XPath xmlns:wsu=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\">wsu:Expires</sp:XPath>\n"+ "                </sp:ContentEncryptedElements>\n"+ "            </wsp:All>\n"+ "        </wsp:ExactlyOne>";
  WSSSecurityProperties outSecurityProperties=new WSSSecurityProperties();
  outSecurityProperties.setCallbackHandler(new CallbackHandlerImpl());
  outSecurityProperties.setEncryptionUser("receiver");
  outSecurityProperties.loadEncryptionKeystore(this.getClass().getClassLoader().getResource("transmitter.jks"),"default".toCharArray());
  outSecurityProperties.setSignatureUser("transmitter");
  outSecurityProperties.loadSignatureKeyStore(this.getClass().getClassLoader().getResource("transmitter.jks"),"default".toCharArray());
  outSecurityProperties.setSignatureAlgorithm("http://www.w3.org/2001/04/xmldsig-more#rsa-sha512");
  outSecurityProperties.addSignaturePart(new SecurePart(WSSConstants.TAG_WSU_TIMESTAMP,SecurePart.Modifier.Element));
  outSecurityProperties.addSignaturePart(new SecurePart(WSSConstants.TAG_SOAP11_BODY,SecurePart.Modifier.Element));
  outSecurityProperties.addEncryptionPart(new SecurePart(WSSConstants.TAG_WSU_CREATED,SecurePart.Modifier.Element));
  outSecurityProperties.addEncryptionPart(new SecurePart(WSSConstants.TAG_WSU_EXPIRES,SecurePart.Modifier.Content));
  outSecurityProperties.addEncryptionPart(new SecurePart(WSSConstants.TAG_SOAP11_BODY,SecurePart.Modifier.Content));
  List<WSSConstants.Action> actions=new ArrayList<>();
  actions.add(WSSConstants.TIMESTAMP);
  actions.add(WSSConstants.SIGNATURE);
  actions.add(WSSConstants.ENCRYPT);
  outSecurityProperties.setActions(actions);
  InputStream sourceDocument=this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml");
  ByteArrayOutputStream baos=doOutboundSecurity(outSecurityProperties,sourceDocument);
  WSSSecurityProperties inSecurityProperties=new WSSSecurityProperties();
  inSecurityProperties.setCallbackHandler(new CallbackHandlerImpl());
  inSecurityProperties.loadSignatureVerificationKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
  inSecurityProperties.loadDecryptionKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
  inSecurityProperties.addIgnoreBSPRule(BSPRule.R5421);
  inSecurityProperties.addIgnoreBSPRule(BSPRule.R5420);
  PolicyEnforcer policyEnforcer=buildAndStartPolicyEngine(policyString);
  inSecurityProperties.addInputProcessor(new PolicyInputProcessor(policyEnforcer,inSecurityProperties));
  try {
    Document document=doInboundSecurity(inSecurityProperties,new ByteArrayInputStream(baos.toByteArray()),policyEnforcer);
    Transformer transformer=TransformerFactory.newInstance().newTransformer();
    transformer.transform(new DOMSource(document),new StreamResult(new OutputStream(){
      @Override public void write(      int b) throws IOException {
      }
    }
));
    Assert.fail("Exception expected");
  }
 catch (  XMLStreamException e) {
    Assert.assertTrue(e.getCause() instanceof WSSecurityException);
    Assert.assertEquals(e.getCause().getMessage(),"Asymmetric algorithm http://www.w3.org/2001/04/xmldsig-more#rsa-sha512 does not meet policy");
    Assert.assertEquals(((WSSecurityException)e.getCause()).getFaultCode(),WSSecurityException.INVALID_SECURITY);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testInitiatorTokenInclusionAlwaysToRecipientPolicy() throws Exception {
  String policyString="<wsp:ExactlyOne xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\" " + "xmlns:sp=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702\">\n" + "            <wsp:All>\n"+ "                <sp:AsymmetricBinding>\n"+ "                    <wsp:Policy>\n"+ "                        <sp:InitiatorToken>\n"+ "                            <wsp:Policy>\n"+ "                                <sp:X509Token sp:IncludeToken=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702/IncludeToken/AlwaysToRecipient\">\n"+ "                                    <sp:IssuerName>CN=transmitter,OU=swssf,C=CH</sp:IssuerName>\n"+ "                                    <wsp:Policy>\n"+ "                                        <sp:WssX509V3Token11/>\n"+ "                                    </wsp:Policy>\n"+ "                                </sp:X509Token>\n"+ "                            </wsp:Policy>\n"+ "                        </sp:InitiatorToken>\n"+ "                        <sp:RecipientToken>\n"+ "                            <wsp:Policy>\n"+ "                              <sp:X509Token sp:IncludeToken=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702/IncludeToken/Never\">\n"+ "                                  <sp:IssuerName>CN=receiver,OU=swssf,C=CH</sp:IssuerName>\n"+ "                                  <wsp:Policy>\n"+ "                                      <sp:WssX509V3Token11/>\n"+ "                                  </wsp:Policy>\n"+ "                              </sp:X509Token>\n"+ "                            </wsp:Policy>\n"+ "                         </sp:RecipientToken>\n"+ "                        <sp:AlgorithmSuite>\n"+ "                            <wsp:Policy>\n"+ "                                <sp:Basic256/>\n"+ "                            </wsp:Policy>\n"+ "                        </sp:AlgorithmSuite>\n"+ "                        <sp:Layout>\n"+ "                            <wsp:Policy>\n"+ "                                <sp:Lax/>\n"+ "                            </wsp:Policy>\n"+ "                        </sp:Layout>\n"+ "                        <sp:IncludeTimestamp/>\n"+ "                    </wsp:Policy>\n"+ "                </sp:AsymmetricBinding>\n"+ "                <sp:SignedParts>\n"+ "                    <sp:Body/>\n"+ "                    <sp:Header Name=\"Header1\" Namespace=\"...\"/>\n"+ "                    <sp:Header Namespace=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\"/>\n"+ "                </sp:SignedParts>\n"+ "                <sp:SignedElements>\n"+ "                    <sp:XPath xmlns:wsu=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\">wsu:Created</sp:XPath>\n"+ "                </sp:SignedElements>\n"+ "                <sp:EncryptedParts>\n"+ "                    <sp:Body/>\n"+ "                    <sp:Header Name=\"Header2\" Namespace=\"...\"/>\n"+ "                    <sp:Header Namespace=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\"/>\n"+ "                </sp:EncryptedParts>\n"+ "                <sp:EncryptedElements>\n"+ "                    <sp:XPath xmlns:wsu=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\">wsu:Created</sp:XPath>\n"+ "                </sp:EncryptedElements>\n"+ "                <sp:ContentEncryptedElements>\n"+ "                    <sp:XPath xmlns:wsu=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\">wsu:Expires</sp:XPath>\n"+ "                </sp:ContentEncryptedElements>\n"+ "            </wsp:All>\n"+ "        </wsp:ExactlyOne>";
  WSSSecurityProperties outSecurityProperties=new WSSSecurityProperties();
  outSecurityProperties.setCallbackHandler(new CallbackHandlerImpl());
  outSecurityProperties.setEncryptionUser("receiver");
  outSecurityProperties.loadEncryptionKeystore(this.getClass().getClassLoader().getResource("transmitter.jks"),"default".toCharArray());
  outSecurityProperties.setSignatureUser("transmitter");
  outSecurityProperties.loadSignatureKeyStore(this.getClass().getClassLoader().getResource("transmitter.jks"),"default".toCharArray());
  outSecurityProperties.addSignaturePart(new SecurePart(WSSConstants.TAG_WSU_TIMESTAMP,SecurePart.Modifier.Element));
  outSecurityProperties.addSignaturePart(new SecurePart(WSSConstants.TAG_SOAP11_BODY,SecurePart.Modifier.Element));
  outSecurityProperties.addEncryptionPart(new SecurePart(WSSConstants.TAG_WSU_CREATED,SecurePart.Modifier.Element));
  outSecurityProperties.addEncryptionPart(new SecurePart(WSSConstants.TAG_WSU_EXPIRES,SecurePart.Modifier.Content));
  outSecurityProperties.addEncryptionPart(new SecurePart(WSSConstants.TAG_SOAP11_BODY,SecurePart.Modifier.Content));
  List<WSSConstants.Action> actions=new ArrayList<>();
  actions.add(WSSConstants.TIMESTAMP);
  actions.add(WSSConstants.SIGNATURE);
  actions.add(WSSConstants.ENCRYPT);
  outSecurityProperties.setActions(actions);
  InputStream sourceDocument=this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml");
  ByteArrayOutputStream baos=doOutboundSecurity(outSecurityProperties,sourceDocument);
  WSSSecurityProperties inSecurityProperties=new WSSSecurityProperties();
  inSecurityProperties.setCallbackHandler(new CallbackHandlerImpl());
  inSecurityProperties.loadSignatureVerificationKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
  inSecurityProperties.loadDecryptionKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
  PolicyEnforcer policyEnforcer=buildAndStartPolicyEngine(policyString);
  inSecurityProperties.addInputProcessor(new PolicyInputProcessor(policyEnforcer,inSecurityProperties));
  try {
    Document document=doInboundSecurity(inSecurityProperties,new ByteArrayInputStream(baos.toByteArray()),policyEnforcer);
    Transformer transformer=TransformerFactory.newInstance().newTransformer();
    transformer.transform(new DOMSource(document),new StreamResult(new OutputStream(){
      @Override public void write(      int b) throws IOException {
      }
    }
));
    Assert.fail("Exception expected");
  }
 catch (  XMLStreamException e) {
    Assert.assertTrue(e.getCause() instanceof WSSecurityException);
    Assert.assertEquals(e.getCause().getMessage(),"Token must be included");
    Assert.assertEquals(((WSSecurityException)e.getCause()).getFaultCode(),WSSecurityException.INVALID_SECURITY);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testIncludeTimestampPolicyNegativeTest() throws Exception {
  String policyString="<wsp:ExactlyOne xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\" " + "xmlns:sp=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702\">\n" + "            <wsp:All>\n"+ "                <sp:AsymmetricBinding>\n"+ "                    <wsp:Policy>\n"+ "                        <sp:InitiatorToken>\n"+ "                            <wsp:Policy>\n"+ "                                <sp:X509Token sp:IncludeToken=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702/IncludeToken/Never\">\n"+ "                                    <sp:IssuerName>CN=transmitter,OU=swssf,C=CH</sp:IssuerName>\n"+ "                                    <wsp:Policy>\n"+ "                                        <sp:WssX509V3Token11/>\n"+ "                                    </wsp:Policy>\n"+ "                                </sp:X509Token>\n"+ "                            </wsp:Policy>\n"+ "                        </sp:InitiatorToken>\n"+ "                        <sp:RecipientToken>\n"+ "                            <wsp:Policy>\n"+ "                              <sp:X509Token sp:IncludeToken=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702/IncludeToken/Never\">\n"+ "                                  <sp:IssuerName>CN=receiver,OU=swssf,C=CH</sp:IssuerName>\n"+ "                                  <wsp:Policy>\n"+ "                                      <sp:WssX509V3Token11/>\n"+ "                                  </wsp:Policy>\n"+ "                              </sp:X509Token>\n"+ "                            </wsp:Policy>\n"+ "                         </sp:RecipientToken>\n"+ "                        <sp:AlgorithmSuite>\n"+ "                            <wsp:Policy>\n"+ "                                <sp:Basic256/>\n"+ "                            </wsp:Policy>\n"+ "                        </sp:AlgorithmSuite>\n"+ "                        <sp:Layout>\n"+ "                            <wsp:Policy>\n"+ "                                <sp:Lax/>\n"+ "                            </wsp:Policy>\n"+ "                        </sp:Layout>\n"+ "                    </wsp:Policy>\n"+ "                </sp:AsymmetricBinding>\n"+ "                <sp:SignedParts>\n"+ "                    <sp:Body/>\n"+ "                    <sp:Header Name=\"Header1\" Namespace=\"...\"/>\n"+ "                    <sp:Header Namespace=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\"/>\n"+ "                </sp:SignedParts>\n"+ "                <sp:SignedElements>\n"+ "                    <sp:XPath xmlns:wsu=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\">wsu:Created</sp:XPath>\n"+ "                </sp:SignedElements>\n"+ "                <sp:EncryptedParts>\n"+ "                    <sp:Body/>\n"+ "                    <sp:Header Name=\"Header2\" Namespace=\"...\"/>\n"+ "                    <sp:Header Namespace=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\"/>\n"+ "                </sp:EncryptedParts>\n"+ "                <sp:EncryptedElements>\n"+ "                    <sp:XPath xmlns:wsu=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\">wsu:Created</sp:XPath>\n"+ "                </sp:EncryptedElements>\n"+ "                <sp:ContentEncryptedElements>\n"+ "                    <sp:XPath xmlns:wsu=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\">wsu:Expires</sp:XPath>\n"+ "                </sp:ContentEncryptedElements>\n"+ "            </wsp:All>\n"+ "        </wsp:ExactlyOne>";
  WSSSecurityProperties outSecurityProperties=new WSSSecurityProperties();
  outSecurityProperties.setCallbackHandler(new CallbackHandlerImpl());
  outSecurityProperties.setEncryptionUser("receiver");
  outSecurityProperties.loadEncryptionKeystore(this.getClass().getClassLoader().getResource("transmitter.jks"),"default".toCharArray());
  outSecurityProperties.setSignatureUser("transmitter");
  outSecurityProperties.loadSignatureKeyStore(this.getClass().getClassLoader().getResource("transmitter.jks"),"default".toCharArray());
  outSecurityProperties.addSignaturePart(new SecurePart(WSSConstants.TAG_WSU_TIMESTAMP,SecurePart.Modifier.Element));
  outSecurityProperties.addSignaturePart(new SecurePart(WSSConstants.TAG_SOAP11_BODY,SecurePart.Modifier.Element));
  outSecurityProperties.addEncryptionPart(new SecurePart(WSSConstants.TAG_WSU_CREATED,SecurePart.Modifier.Element));
  outSecurityProperties.addEncryptionPart(new SecurePart(WSSConstants.TAG_WSU_EXPIRES,SecurePart.Modifier.Content));
  outSecurityProperties.addEncryptionPart(new SecurePart(WSSConstants.TAG_SOAP11_BODY,SecurePart.Modifier.Content));
  List<WSSConstants.Action> actions=new ArrayList<>();
  actions.add(WSSConstants.TIMESTAMP);
  actions.add(WSSConstants.SIGNATURE);
  actions.add(WSSConstants.ENCRYPT);
  outSecurityProperties.setActions(actions);
  InputStream sourceDocument=this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml");
  ByteArrayOutputStream baos=doOutboundSecurity(outSecurityProperties,sourceDocument);
  WSSSecurityProperties inSecurityProperties=new WSSSecurityProperties();
  inSecurityProperties.setCallbackHandler(new CallbackHandlerImpl());
  inSecurityProperties.loadSignatureVerificationKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
  inSecurityProperties.loadDecryptionKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
  PolicyEnforcer policyEnforcer=buildAndStartPolicyEngine(policyString);
  inSecurityProperties.addInputProcessor(new PolicyInputProcessor(policyEnforcer,inSecurityProperties));
  try {
    Document document=doInboundSecurity(inSecurityProperties,new ByteArrayInputStream(baos.toByteArray()),policyEnforcer);
    Transformer transformer=TransformerFactory.newInstance().newTransformer();
    transformer.transform(new DOMSource(document),new StreamResult(new OutputStream(){
      @Override public void write(      int b) throws IOException {
      }
    }
));
    Assert.fail("Exception expected");
  }
 catch (  XMLStreamException e) {
    Assert.assertTrue(e.getCause() instanceof WSSecurityException);
    Assert.assertEquals(e.getCause().getMessage(),"Timestamp must not be present");
    Assert.assertEquals(((WSSecurityException)e.getCause()).getFaultCode(),WSSecurityException.INVALID_SECURITY);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testC14NAlgorithmSuiteNegative() throws Exception {
  String policyString="<wsp:ExactlyOne xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\" " + "xmlns:sp=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702\">\n" + "            <wsp:All>\n"+ "                <sp:AsymmetricBinding>\n"+ "                    <wsp:Policy>\n"+ "                        <sp:InitiatorToken>\n"+ "                            <wsp:Policy>\n"+ "                                <sp:X509Token sp:IncludeToken=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702/IncludeToken/AlwaysToRecipient\">\n"+ "                                    <sp:IssuerName>CN=transmitter,OU=swssf,C=CH</sp:IssuerName>\n"+ "                                    <wsp:Policy>\n"+ "                                        <sp:WssX509V3Token11/>\n"+ "                                    </wsp:Policy>\n"+ "                                </sp:X509Token>\n"+ "                            </wsp:Policy>\n"+ "                        </sp:InitiatorToken>\n"+ "                        <sp:RecipientToken>\n"+ "                            <wsp:Policy>\n"+ "                              <sp:X509Token sp:IncludeToken=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702/IncludeToken/AlwaysToRecipient\">\n"+ "                                  <sp:IssuerName>CN=receiver,OU=swssf,C=CH</sp:IssuerName>\n"+ "                                  <wsp:Policy>\n"+ "                                      <sp:WssX509V3Token11/>\n"+ "                                  </wsp:Policy>\n"+ "                              </sp:X509Token>\n"+ "                            </wsp:Policy>\n"+ "                         </sp:RecipientToken>\n"+ "                        <sp:AlgorithmSuite>\n"+ "                            <wsp:Policy>\n"+ "                                <sp:Basic256/>\n"+ "                            </wsp:Policy>\n"+ "                        </sp:AlgorithmSuite>\n"+ "                        <sp:Layout>\n"+ "                            <wsp:Policy>\n"+ "                                <sp:Lax/>\n"+ "                            </wsp:Policy>\n"+ "                        </sp:Layout>\n"+ "                        <sp:IncludeTimestamp/>\n"+ "                        <sp:ProtectTokens/>\n"+ "                    </wsp:Policy>\n"+ "                </sp:AsymmetricBinding>\n"+ "                <sp:SignedParts>\n"+ "                    <sp:Body/>\n"+ "                    <sp:Header Name=\"Header1\" Namespace=\"...\"/>\n"+ "                    <sp:Header Namespace=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\"/>\n"+ "                </sp:SignedParts>\n"+ "                <sp:SignedElements>\n"+ "                    <sp:XPath xmlns:wsu=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\">wsu:Created</sp:XPath>\n"+ "                </sp:SignedElements>\n"+ "                <sp:EncryptedParts>\n"+ "                    <sp:Body/>\n"+ "                    <sp:Header Name=\"Header2\" Namespace=\"...\"/>\n"+ "                    <sp:Header Namespace=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\"/>\n"+ "                </sp:EncryptedParts>\n"+ "                <sp:EncryptedElements>\n"+ "                    <sp:XPath xmlns:wsu=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\">wsu:Created</sp:XPath>\n"+ "                </sp:EncryptedElements>\n"+ "                <sp:ContentEncryptedElements>\n"+ "                    <sp:XPath xmlns:wsu=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\">wsu:Expires</sp:XPath>\n"+ "                </sp:ContentEncryptedElements>\n"+ "            </wsp:All>\n"+ "        </wsp:ExactlyOne>";
  WSSSecurityProperties outSecurityProperties=new WSSSecurityProperties();
  outSecurityProperties.setCallbackHandler(new CallbackHandlerImpl());
  outSecurityProperties.setEncryptionUser("receiver");
  outSecurityProperties.loadEncryptionKeystore(this.getClass().getClassLoader().getResource("transmitter.jks"),"default".toCharArray());
  outSecurityProperties.setSignatureUser("transmitter");
  outSecurityProperties.loadSignatureKeyStore(this.getClass().getClassLoader().getResource("transmitter.jks"),"default".toCharArray());
  outSecurityProperties.setSignatureCanonicalizationAlgorithm("http://www.w3.org/2006/12/xml-c14n11");
  outSecurityProperties.addSignaturePart(new SecurePart(WSSConstants.TAG_WSU_TIMESTAMP,SecurePart.Modifier.Element));
  outSecurityProperties.addSignaturePart(new SecurePart(WSSConstants.TAG_SOAP11_BODY,SecurePart.Modifier.Element));
  outSecurityProperties.addEncryptionPart(new SecurePart(WSSConstants.TAG_WSU_CREATED,SecurePart.Modifier.Element));
  outSecurityProperties.addEncryptionPart(new SecurePart(WSSConstants.TAG_WSU_EXPIRES,SecurePart.Modifier.Content));
  outSecurityProperties.addEncryptionPart(new SecurePart(WSSConstants.TAG_SOAP11_BODY,SecurePart.Modifier.Content));
  List<WSSConstants.Action> actions=new ArrayList<>();
  actions.add(WSSConstants.TIMESTAMP);
  actions.add(WSSConstants.SIGNATURE);
  actions.add(WSSConstants.ENCRYPT);
  outSecurityProperties.setActions(actions);
  InputStream sourceDocument=this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml");
  ByteArrayOutputStream baos=doOutboundSecurity(outSecurityProperties,sourceDocument);
  WSSSecurityProperties inSecurityProperties=new WSSSecurityProperties();
  inSecurityProperties.setCallbackHandler(new CallbackHandlerImpl());
  inSecurityProperties.loadSignatureVerificationKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
  inSecurityProperties.loadDecryptionKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
  inSecurityProperties.addIgnoreBSPRule(BSPRule.R5404);
  inSecurityProperties.addIgnoreBSPRule(BSPRule.R5423);
  inSecurityProperties.addIgnoreBSPRule(BSPRule.R5412);
  PolicyEnforcer policyEnforcer=buildAndStartPolicyEngine(policyString);
  inSecurityProperties.addInputProcessor(new PolicyInputProcessor(policyEnforcer,inSecurityProperties));
  try {
    Document document=doInboundSecurity(inSecurityProperties,new ByteArrayInputStream(baos.toByteArray()),policyEnforcer);
    Transformer transformer=TransformerFactory.newInstance().newTransformer();
    transformer.transform(new DOMSource(document),new StreamResult(new OutputStream(){
      @Override public void write(      int b) throws IOException {
      }
    }
));
    Assert.fail("Exception expected");
  }
 catch (  XMLStreamException e) {
    Assert.assertTrue(e.getCause() instanceof WSSecurityException);
    Assert.assertEquals(e.getCause().getMessage(),"C14N algorithm http://www.w3.org/2006/12/xml-c14n11 does not meet policy");
    Assert.assertEquals(((WSSecurityException)e.getCause()).getFaultCode(),WSSecurityException.INVALID_SECURITY);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testIncludeTimestampAndSignedUsernameSupportingTokenPolicyNegativeTest() throws Exception {
  String policyString="<wsp:ExactlyOne xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\" " + "xmlns:sp=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702\">\n" + "            <wsp:All>\n"+ "                <sp:AsymmetricBinding>\n"+ "                    <wsp:Policy>\n"+ "                        <sp:InitiatorToken>\n"+ "                            <wsp:Policy>\n"+ "                                <sp:X509Token sp:IncludeToken=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702/IncludeToken/AlwaysToRecipient\">\n"+ "                                    <sp:IssuerName>CN=transmitter,OU=swssf,C=CH</sp:IssuerName>\n"+ "                                    <wsp:Policy>\n"+ "                                        <sp:WssX509V3Token11/>\n"+ "                                    </wsp:Policy>\n"+ "                                </sp:X509Token>\n"+ "                            </wsp:Policy>\n"+ "                        </sp:InitiatorToken>\n"+ "                        <sp:RecipientToken>\n"+ "                            <wsp:Policy>\n"+ "                              <sp:X509Token sp:IncludeToken=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702/IncludeToken/AlwaysToRecipient\">\n"+ "                                  <sp:IssuerName>CN=receiver,OU=swssf,C=CH</sp:IssuerName>\n"+ "                                  <wsp:Policy>\n"+ "                                      <sp:WssX509V3Token11/>\n"+ "                                  </wsp:Policy>\n"+ "                              </sp:X509Token>\n"+ "                            </wsp:Policy>\n"+ "                         </sp:RecipientToken>\n"+ "                        <sp:AlgorithmSuite>\n"+ "                            <wsp:Policy>\n"+ "                                <sp:Basic256/>\n"+ "                            </wsp:Policy>\n"+ "                        </sp:AlgorithmSuite>\n"+ "                        <sp:Layout>\n"+ "                            <wsp:Policy>\n"+ "                                <sp:Lax/>\n"+ "                            </wsp:Policy>\n"+ "                        </sp:Layout>\n"+ "                        <sp:IncludeTimestamp/>\n"+ "                    </wsp:Policy>\n"+ "                </sp:AsymmetricBinding>\n"+ "                <sp:SignedParts>\n"+ "                    <sp:Body/>\n"+ "                    <sp:Header Name=\"Header1\" Namespace=\"...\"/>\n"+ "                    <sp:Header Namespace=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\"/>\n"+ "                </sp:SignedParts>\n"+ "                <sp:SignedElements>\n"+ "                    <sp:XPath xmlns:wsu=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\">wsu:Created</sp:XPath>\n"+ "                </sp:SignedElements>\n"+ "                <sp:EncryptedParts>\n"+ "                    <sp:Body/>\n"+ "                    <sp:Header Name=\"Header2\" Namespace=\"...\"/>\n"+ "                    <sp:Header Namespace=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\"/>\n"+ "                </sp:EncryptedParts>\n"+ "                <sp:EncryptedElements>\n"+ "                    <sp:XPath xmlns:wsu=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\">wsu:Created</sp:XPath>\n"+ "                </sp:EncryptedElements>\n"+ "                <sp:ContentEncryptedElements>\n"+ "                    <sp:XPath xmlns:wsu=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\">wsu:Expires</sp:XPath>\n"+ "                </sp:ContentEncryptedElements>\n"+ "                <sp:SignedSupportingTokens>\n"+ "                    <wsp:Policy>\n"+ "                        <sp:UsernameToken sp:IncludeToken=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702/IncludeToken/AlwaysToRecipient\">\n"+ "                            <wsp:Policy>\n"+ "                                <sp:NoPassword/>\n"+ "                            </wsp:Policy>\n"+ "                        </sp:UsernameToken>\n"+ "                    </wsp:Policy>\n"+ "                </sp:SignedSupportingTokens>\n"+ "            </wsp:All>\n"+ "        </wsp:ExactlyOne>";
  WSSSecurityProperties outSecurityProperties=new WSSSecurityProperties();
  outSecurityProperties.setCallbackHandler(new CallbackHandlerImpl());
  outSecurityProperties.setEncryptionUser("receiver");
  outSecurityProperties.loadEncryptionKeystore(this.getClass().getClassLoader().getResource("transmitter.jks"),"default".toCharArray());
  outSecurityProperties.setSignatureUser("transmitter");
  outSecurityProperties.setTokenUser("transmitter");
  outSecurityProperties.setUsernameTokenPasswordType(WSSConstants.UsernameTokenPasswordType.PASSWORD_NONE);
  outSecurityProperties.loadSignatureKeyStore(this.getClass().getClassLoader().getResource("transmitter.jks"),"default".toCharArray());
  outSecurityProperties.addSignaturePart(new SecurePart(WSSConstants.TAG_SOAP11_BODY,SecurePart.Modifier.Element));
  outSecurityProperties.addEncryptionPart(new SecurePart(WSSConstants.TAG_WSU_CREATED,SecurePart.Modifier.Element));
  outSecurityProperties.addEncryptionPart(new SecurePart(WSSConstants.TAG_WSU_EXPIRES,SecurePart.Modifier.Content));
  outSecurityProperties.addEncryptionPart(new SecurePart(WSSConstants.TAG_SOAP11_BODY,SecurePart.Modifier.Content));
  List<WSSConstants.Action> actions=new ArrayList<>();
  actions.add(WSSConstants.USERNAMETOKEN);
  actions.add(WSSConstants.TIMESTAMP);
  actions.add(WSSConstants.SIGNATURE);
  actions.add(WSSConstants.ENCRYPT);
  outSecurityProperties.setActions(actions);
  InputStream sourceDocument=this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml");
  ByteArrayOutputStream baos=doOutboundSecurity(outSecurityProperties,sourceDocument);
  WSSSecurityProperties inSecurityProperties=new WSSSecurityProperties();
  inSecurityProperties.setCallbackHandler(new CallbackHandlerImpl());
  inSecurityProperties.loadSignatureVerificationKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
  inSecurityProperties.loadDecryptionKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
  PolicyEnforcer policyEnforcer=buildAndStartPolicyEngine(policyString);
  inSecurityProperties.addInputProcessor(new PolicyInputProcessor(policyEnforcer,inSecurityProperties));
  try {
    Document document=doInboundSecurity(inSecurityProperties,new ByteArrayInputStream(baos.toByteArray()),policyEnforcer);
    Transformer transformer=TransformerFactory.newInstance().newTransformer();
    transformer.transform(new DOMSource(document),new StreamResult(new OutputStream(){
      @Override public void write(      int b) throws IOException {
      }
    }
));
    Assert.fail("Exception expected");
  }
 catch (  XMLStreamException e) {
    Assert.assertTrue(e.getCause() instanceof WSSecurityException);
    Assert.assertEquals(e.getCause().getMessage(),"Element /{http://schemas.xmlsoap.org/soap/envelope/}Envelope/{http://schemas.xmlsoap.org/soap/envelope/}Header/{http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd}Security/{http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd}Timestamp must be signed");
    Assert.assertEquals(((WSSecurityException)e.getCause()).getFaultCode(),WSSecurityException.INVALID_SECURITY);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testSignatureDigestAlgorithmSuiteNegative() throws Exception {
  String policyString="<wsp:ExactlyOne xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\" " + "xmlns:sp=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702\">\n" + "            <wsp:All>\n"+ "                <sp:AsymmetricBinding>\n"+ "                    <wsp:Policy>\n"+ "                        <sp:InitiatorToken>\n"+ "                            <wsp:Policy>\n"+ "                                <sp:X509Token sp:IncludeToken=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702/IncludeToken/AlwaysToRecipient\">\n"+ "                                    <sp:IssuerName>CN=transmitter,OU=swssf,C=CH</sp:IssuerName>\n"+ "                                    <wsp:Policy>\n"+ "                                        <sp:WssX509V3Token11/>\n"+ "                                    </wsp:Policy>\n"+ "                                </sp:X509Token>\n"+ "                            </wsp:Policy>\n"+ "                        </sp:InitiatorToken>\n"+ "                        <sp:RecipientToken>\n"+ "                            <wsp:Policy>\n"+ "                              <sp:X509Token sp:IncludeToken=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702/IncludeToken/AlwaysToRecipient\">\n"+ "                                  <sp:IssuerName>CN=receiver,OU=swssf,C=CH</sp:IssuerName>\n"+ "                                  <wsp:Policy>\n"+ "                                      <sp:WssX509V3Token11/>\n"+ "                                  </wsp:Policy>\n"+ "                              </sp:X509Token>\n"+ "                            </wsp:Policy>\n"+ "                         </sp:RecipientToken>\n"+ "                        <sp:AlgorithmSuite>\n"+ "                            <wsp:Policy>\n"+ "                                <sp:Basic256/>\n"+ "                            </wsp:Policy>\n"+ "                        </sp:AlgorithmSuite>\n"+ "                        <sp:Layout>\n"+ "                            <wsp:Policy>\n"+ "                                <sp:Lax/>\n"+ "                            </wsp:Policy>\n"+ "                        </sp:Layout>\n"+ "                        <sp:IncludeTimestamp/>\n"+ "                        <sp:ProtectTokens/>\n"+ "                    </wsp:Policy>\n"+ "                </sp:AsymmetricBinding>\n"+ "                <sp:SignedParts>\n"+ "                    <sp:Body/>\n"+ "                    <sp:Header Name=\"Header1\" Namespace=\"...\"/>\n"+ "                    <sp:Header Namespace=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\"/>\n"+ "                </sp:SignedParts>\n"+ "                <sp:SignedElements>\n"+ "                    <sp:XPath xmlns:wsu=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\">wsu:Created</sp:XPath>\n"+ "                </sp:SignedElements>\n"+ "                <sp:EncryptedParts>\n"+ "                    <sp:Body/>\n"+ "                    <sp:Header Name=\"Header2\" Namespace=\"...\"/>\n"+ "                    <sp:Header Namespace=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\"/>\n"+ "                </sp:EncryptedParts>\n"+ "                <sp:EncryptedElements>\n"+ "                    <sp:XPath xmlns:wsu=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\">wsu:Created</sp:XPath>\n"+ "                </sp:EncryptedElements>\n"+ "                <sp:ContentEncryptedElements>\n"+ "                    <sp:XPath xmlns:wsu=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\">wsu:Expires</sp:XPath>\n"+ "                </sp:ContentEncryptedElements>\n"+ "            </wsp:All>\n"+ "        </wsp:ExactlyOne>";
  WSSSecurityProperties outSecurityProperties=new WSSSecurityProperties();
  outSecurityProperties.setCallbackHandler(new CallbackHandlerImpl());
  outSecurityProperties.setEncryptionUser("receiver");
  outSecurityProperties.loadEncryptionKeystore(this.getClass().getClassLoader().getResource("transmitter.jks"),"default".toCharArray());
  outSecurityProperties.setSignatureUser("transmitter");
  outSecurityProperties.loadSignatureKeyStore(this.getClass().getClassLoader().getResource("transmitter.jks"),"default".toCharArray());
  outSecurityProperties.setSignatureDigestAlgorithm("http://www.w3.org/2001/04/xmldsig-more#rsa-md5");
  outSecurityProperties.addSignaturePart(new SecurePart(WSSConstants.TAG_WSU_TIMESTAMP,SecurePart.Modifier.Element,new String[]{WSSConstants.NS_C14N_EXCL},"http://www.w3.org/2001/04/xmldsig-more#md5"));
  outSecurityProperties.addSignaturePart(new SecurePart(WSSConstants.TAG_SOAP11_BODY,SecurePart.Modifier.Element,new String[]{WSSConstants.NS_C14N_EXCL},"http://www.w3.org/2001/04/xmldsig-more#md5"));
  outSecurityProperties.addEncryptionPart(new SecurePart(WSSConstants.TAG_WSU_CREATED,SecurePart.Modifier.Element));
  outSecurityProperties.addEncryptionPart(new SecurePart(WSSConstants.TAG_WSU_EXPIRES,SecurePart.Modifier.Content));
  outSecurityProperties.addEncryptionPart(new SecurePart(WSSConstants.TAG_SOAP11_BODY,SecurePart.Modifier.Content));
  List<WSSConstants.Action> actions=new ArrayList<>();
  actions.add(WSSConstants.TIMESTAMP);
  actions.add(WSSConstants.SIGNATURE);
  actions.add(WSSConstants.ENCRYPT);
  outSecurityProperties.setActions(actions);
  InputStream sourceDocument=this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml");
  ByteArrayOutputStream baos=doOutboundSecurity(outSecurityProperties,sourceDocument);
  WSSSecurityProperties inSecurityProperties=new WSSSecurityProperties();
  inSecurityProperties.setCallbackHandler(new CallbackHandlerImpl());
  inSecurityProperties.loadSignatureVerificationKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
  inSecurityProperties.loadDecryptionKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
  inSecurityProperties.addIgnoreBSPRule(BSPRule.R5420);
  PolicyEnforcer policyEnforcer=buildAndStartPolicyEngine(policyString);
  inSecurityProperties.addInputProcessor(new PolicyInputProcessor(policyEnforcer,inSecurityProperties));
  try {
    Init.init(WSSec.class.getClassLoader().getResource("wss/wss-config.xml").toURI(),WSSec.class);
    switchAllowMD5Algorithm(true);
    Document document=doInboundSecurity(inSecurityProperties,new ByteArrayInputStream(baos.toByteArray()),policyEnforcer);
    Transformer transformer=TransformerFactory.newInstance().newTransformer();
    transformer.transform(new DOMSource(document),new StreamResult(new OutputStream(){
      @Override public void write(      int b) throws IOException {
      }
    }
));
    Assert.fail("Exception expected");
  }
 catch (  XMLStreamException e) {
    Assert.assertTrue(e.getCause() instanceof WSSecurityException);
  }
 finally {
    switchAllowMD5Algorithm(false);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testEntireHeaderAndBodySignatureNegative2() throws Exception {
  String policyString="<wsp:ExactlyOne xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\" " + "xmlns:sp=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702\">\n" + "            <wsp:All>\n"+ "                <sp:AsymmetricBinding>\n"+ "                    <wsp:Policy>\n"+ "                        <sp:InitiatorToken>\n"+ "                            <wsp:Policy>\n"+ "                                <sp:X509Token sp:IncludeToken=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702/IncludeToken/Never\">\n"+ "                                    <sp:IssuerName>CN=transmitter,OU=swssf,C=CH</sp:IssuerName>\n"+ "                                    <wsp:Policy>\n"+ "                                        <sp:WssX509V3Token11/>\n"+ "                                    </wsp:Policy>\n"+ "                                </sp:X509Token>\n"+ "                            </wsp:Policy>\n"+ "                        </sp:InitiatorToken>\n"+ "                        <sp:RecipientToken>\n"+ "                            <wsp:Policy>\n"+ "                              <sp:X509Token sp:IncludeToken=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702/IncludeToken/Never\">\n"+ "                                  <sp:IssuerName>CN=receiver,OU=swssf,C=CH</sp:IssuerName>\n"+ "                                  <wsp:Policy>\n"+ "                                      <sp:WssX509V3Token11/>\n"+ "                                  </wsp:Policy>\n"+ "                              </sp:X509Token>\n"+ "                            </wsp:Policy>\n"+ "                         </sp:RecipientToken>\n"+ "                        <sp:AlgorithmSuite>\n"+ "                            <wsp:Policy>\n"+ "                                <sp:Basic256/>\n"+ "                            </wsp:Policy>\n"+ "                        </sp:AlgorithmSuite>\n"+ "                        <sp:Layout>\n"+ "                            <wsp:Policy>\n"+ "                                <sp:Lax/>\n"+ "                            </wsp:Policy>\n"+ "                        </sp:Layout>\n"+ "                        <sp:IncludeTimestamp/>\n"+ "                        <sp:OnlySignEntireHeadersAndBody/>\n"+ "                    </wsp:Policy>\n"+ "                </sp:AsymmetricBinding>\n"+ "                <sp:EncryptedParts>\n"+ "                    <sp:Body/>\n"+ "                    <sp:Header Name=\"Header2\" Namespace=\"...\"/>\n"+ "                    <sp:Header Namespace=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\"/>\n"+ "                </sp:EncryptedParts>\n"+ "                <sp:EncryptedElements>\n"+ "                    <sp:XPath xmlns:wsu=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\">wsu:Created</sp:XPath>\n"+ "                </sp:EncryptedElements>\n"+ "                <sp:ContentEncryptedElements>\n"+ "                    <sp:XPath xmlns:wsu=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\">wsu:Expires</sp:XPath>\n"+ "                </sp:ContentEncryptedElements>\n"+ "            </wsp:All>\n"+ "        </wsp:ExactlyOne>";
  WSSSecurityProperties outSecurityProperties=new WSSSecurityProperties();
  outSecurityProperties.setCallbackHandler(new CallbackHandlerImpl());
  outSecurityProperties.setEncryptionUser("receiver");
  outSecurityProperties.loadEncryptionKeystore(this.getClass().getClassLoader().getResource("transmitter.jks"),"default".toCharArray());
  outSecurityProperties.setSignatureUser("transmitter");
  outSecurityProperties.loadSignatureKeyStore(this.getClass().getClassLoader().getResource("transmitter.jks"),"default".toCharArray());
  outSecurityProperties.addSignaturePart(new SecurePart(WSSConstants.TAG_WSU_TIMESTAMP,SecurePart.Modifier.Element));
  outSecurityProperties.addSignaturePart(new SecurePart(new QName("http://schemas.xmlsoap.org/wsdl/","service"),SecurePart.Modifier.Element));
  outSecurityProperties.addEncryptionPart(new SecurePart(WSSConstants.TAG_WSU_CREATED,SecurePart.Modifier.Element));
  outSecurityProperties.addEncryptionPart(new SecurePart(WSSConstants.TAG_WSU_EXPIRES,SecurePart.Modifier.Content));
  outSecurityProperties.addEncryptionPart(new SecurePart(WSSConstants.TAG_SOAP11_BODY,SecurePart.Modifier.Content));
  List<WSSConstants.Action> actions=new ArrayList<>();
  actions.add(WSSConstants.TIMESTAMP);
  actions.add(WSSConstants.SIGNATURE);
  actions.add(WSSConstants.ENCRYPT);
  outSecurityProperties.setActions(actions);
  InputStream sourceDocument=this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml");
  ByteArrayOutputStream baos=doOutboundSecurity(outSecurityProperties,sourceDocument);
  WSSSecurityProperties inSecurityProperties=new WSSSecurityProperties();
  inSecurityProperties.setCallbackHandler(new CallbackHandlerImpl());
  inSecurityProperties.loadSignatureVerificationKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
  inSecurityProperties.loadDecryptionKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
  PolicyEnforcer policyEnforcer=buildAndStartPolicyEngine(policyString);
  inSecurityProperties.addInputProcessor(new PolicyInputProcessor(policyEnforcer,inSecurityProperties));
  try {
    Document document=doInboundSecurity(inSecurityProperties,new ByteArrayInputStream(baos.toByteArray()),policyEnforcer);
    Transformer transformer=TransformerFactory.newInstance().newTransformer();
    transformer.transform(new DOMSource(document),new StreamResult(new OutputStream(){
      @Override public void write(      int b) throws IOException {
      }
    }
));
    Assert.fail("Exception expected");
  }
 catch (  XMLStreamException e) {
    Assert.assertTrue(e.getCause() instanceof WSSecurityException);
    Assert.assertEquals(e.getCause().getMessage(),"OnlySignEntireHeadersAndBody not fulfilled, offending element: " + "/{http://schemas.xmlsoap.org/soap/envelope/}Envelope/{http://schemas.xmlsoap.org/soap/envelope/}Header/{http://schemas.xmlsoap.org/wsdl/}definitions/{http://schemas.xmlsoap.org/wsdl/}service");
    Assert.assertEquals(((WSSecurityException)e.getCause()).getFaultCode(),WSSecurityException.INVALID_SECURITY);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testSignatureProtectionPolicyNegative1() throws Exception {
  String policyString="<wsp:ExactlyOne xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\" " + "xmlns:sp=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702\">\n" + "            <wsp:All>\n"+ "                <sp:AsymmetricBinding>\n"+ "                    <wsp:Policy>\n"+ "                        <sp:InitiatorToken>\n"+ "                            <wsp:Policy>\n"+ "                                <sp:X509Token sp:IncludeToken=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702/IncludeToken/AlwaysToRecipient\">\n"+ "                                    <sp:IssuerName>CN=transmitter,OU=swssf,C=CH</sp:IssuerName>\n"+ "                                    <wsp:Policy>\n"+ "                                        <sp:WssX509V3Token11/>\n"+ "                                    </wsp:Policy>\n"+ "                                </sp:X509Token>\n"+ "                            </wsp:Policy>\n"+ "                        </sp:InitiatorToken>\n"+ "                        <sp:RecipientToken>\n"+ "                            <wsp:Policy>\n"+ "                              <sp:X509Token sp:IncludeToken=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702/IncludeToken/AlwaysToRecipient\">\n"+ "                                  <sp:IssuerName>CN=receiver,OU=swssf,C=CH</sp:IssuerName>\n"+ "                                  <wsp:Policy>\n"+ "                                      <sp:WssX509V3Token11/>\n"+ "                                  </wsp:Policy>\n"+ "                              </sp:X509Token>\n"+ "                            </wsp:Policy>\n"+ "                         </sp:RecipientToken>\n"+ "                        <sp:AlgorithmSuite>\n"+ "                            <wsp:Policy>\n"+ "                                <sp:Basic256/>\n"+ "                            </wsp:Policy>\n"+ "                        </sp:AlgorithmSuite>\n"+ "                        <sp:Layout>\n"+ "                            <wsp:Policy>\n"+ "                                <sp:Lax/>\n"+ "                            </wsp:Policy>\n"+ "                        </sp:Layout>\n"+ "                        <sp:IncludeTimestamp/>\n"+ "                        <sp:EncryptSignature/>\n"+ "                    </wsp:Policy>\n"+ "                </sp:AsymmetricBinding>\n"+ "                <sp:SignedParts>\n"+ "                    <sp:Body/>\n"+ "                    <sp:Header Name=\"Header1\" Namespace=\"...\"/>\n"+ "                    <sp:Header Namespace=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\"/>\n"+ "                </sp:SignedParts>\n"+ "                <sp:SignedElements>\n"+ "                    <sp:XPath xmlns:wsu=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\">wsu:Created</sp:XPath>\n"+ "                </sp:SignedElements>\n"+ "                <sp:EncryptedParts>\n"+ "                    <sp:Body/>\n"+ "                    <sp:Header Name=\"Header2\" Namespace=\"...\"/>\n"+ "                    <sp:Header Namespace=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\"/>\n"+ "                </sp:EncryptedParts>\n"+ "                <sp:EncryptedElements>\n"+ "                    <sp:XPath xmlns:wsu=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\">wsu:Created</sp:XPath>\n"+ "                </sp:EncryptedElements>\n"+ "                <sp:ContentEncryptedElements>\n"+ "                    <sp:XPath xmlns:wsu=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\">wsu:Expires</sp:XPath>\n"+ "                </sp:ContentEncryptedElements>\n"+ "            </wsp:All>\n"+ "        </wsp:ExactlyOne>";
  WSSSecurityProperties outSecurityProperties=new WSSSecurityProperties();
  outSecurityProperties.setCallbackHandler(new CallbackHandlerImpl());
  outSecurityProperties.setEncryptionUser("receiver");
  outSecurityProperties.loadEncryptionKeystore(this.getClass().getClassLoader().getResource("transmitter.jks"),"default".toCharArray());
  outSecurityProperties.setSignatureUser("transmitter");
  outSecurityProperties.loadSignatureKeyStore(this.getClass().getClassLoader().getResource("transmitter.jks"),"default".toCharArray());
  outSecurityProperties.addSignaturePart(new SecurePart(WSSConstants.TAG_WSU_TIMESTAMP,SecurePart.Modifier.Element));
  outSecurityProperties.addSignaturePart(new SecurePart(WSSConstants.TAG_SOAP11_BODY,SecurePart.Modifier.Element));
  outSecurityProperties.addEncryptionPart(new SecurePart(WSSConstants.TAG_WSU_CREATED,SecurePart.Modifier.Element));
  outSecurityProperties.addEncryptionPart(new SecurePart(WSSConstants.TAG_WSU_EXPIRES,SecurePart.Modifier.Content));
  outSecurityProperties.addEncryptionPart(new SecurePart(WSSConstants.TAG_SOAP11_BODY,SecurePart.Modifier.Content));
  List<WSSConstants.Action> actions=new ArrayList<>();
  actions.add(WSSConstants.TIMESTAMP);
  actions.add(WSSConstants.SIGNATURE);
  actions.add(WSSConstants.ENCRYPT);
  outSecurityProperties.setActions(actions);
  InputStream sourceDocument=this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml");
  ByteArrayOutputStream baos=doOutboundSecurity(outSecurityProperties,sourceDocument);
  WSSSecurityProperties inSecurityProperties=new WSSSecurityProperties();
  inSecurityProperties.setCallbackHandler(new CallbackHandlerImpl());
  inSecurityProperties.loadSignatureVerificationKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
  inSecurityProperties.loadDecryptionKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
  PolicyEnforcer policyEnforcer=buildAndStartPolicyEngine(policyString);
  inSecurityProperties.addInputProcessor(new PolicyInputProcessor(policyEnforcer,inSecurityProperties));
  try {
    Document document=doInboundSecurity(inSecurityProperties,new ByteArrayInputStream(baos.toByteArray()),policyEnforcer);
    Transformer transformer=TransformerFactory.newInstance().newTransformer();
    transformer.transform(new DOMSource(document),new StreamResult(new OutputStream(){
      @Override public void write(      int b) throws IOException {
      }
    }
));
    Assert.fail("Exception expected");
  }
 catch (  XMLStreamException e) {
    Assert.assertTrue(e.getCause() instanceof WSSecurityException);
    Assert.assertEquals(((WSSecurityException)e.getCause()).getFaultCode(),WSSecurityException.INVALID_SECURITY);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.wss4j.policy.stax.test.AsymmetricBindingTest </h4><pre class="type-8 type-7 type-5 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testPolicyNotWholeBodySigned() throws Exception {
  String policyString="<sp:AsymmetricBinding xmlns:sp=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702\" xmlns:sp3=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200802\">\n" + "<wsp:Policy xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\">\n" + "   <sp:AlgorithmSuite>\n"+ "       <wsp:Policy>\n"+ "           <sp:Basic256/>\n"+ "       </wsp:Policy>\n"+ "   </sp:AlgorithmSuite>\n"+ "<sp:IncludeTimestamp/>\n"+ "<sp:EncryptSignature/>\n"+ "<sp:ProtectTokens/>\n"+ "<sp:OnlySignEntireHeadersAndBody/>\n"+ "</wsp:Policy>\n"+ "</sp:AsymmetricBinding>";
  PolicyEnforcer policyEnforcer=buildAndStartPolicyEngine(policyString);
  TimestampSecurityEvent timestampSecurityEvent=new TimestampSecurityEvent();
  policyEnforcer.registerSecurityEvent(timestampSecurityEvent);
  X509TokenSecurityEvent x509TokenSecurityEvent=new X509TokenSecurityEvent();
  X509SecurityTokenImpl securityToken=getX509Token(WSSecurityTokenConstants.X509V3Token);
  securityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_MAIN_SIGNATURE);
  x509TokenSecurityEvent.setSecurityToken(securityToken);
  policyEnforcer.registerSecurityEvent(x509TokenSecurityEvent);
  x509TokenSecurityEvent=new X509TokenSecurityEvent();
  securityToken=getX509Token(WSSecurityTokenConstants.X509V3Token);
  securityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_MAIN_ENCRYPTION);
  x509TokenSecurityEvent.setSecurityToken(securityToken);
  policyEnforcer.registerSecurityEvent(x509TokenSecurityEvent);
  List<XMLSecurityConstants.ContentType> protectionOrder=new LinkedList<>();
  protectionOrder.add(XMLSecurityConstants.ContentType.SIGNATURE);
  protectionOrder.add(XMLSecurityConstants.ContentType.ENCRYPTION);
  EncryptedElementSecurityEvent encryptedElementSecurityEvent=new EncryptedElementSecurityEvent(null,true,protectionOrder);
  List<QName> headerPath=new ArrayList<>();
  headerPath.addAll(WSSConstants.WSSE_SECURITY_HEADER_PATH);
  headerPath.add(WSSConstants.TAG_dsig_Signature);
  encryptedElementSecurityEvent.setElementPath(headerPath);
  policyEnforcer.registerSecurityEvent(encryptedElementSecurityEvent);
  encryptedElementSecurityEvent=new EncryptedElementSecurityEvent(null,true,protectionOrder);
  headerPath=new ArrayList<>();
  headerPath.addAll(WSSConstants.WSSE_SECURITY_HEADER_PATH);
  headerPath.add(WSSConstants.TAG_WSSE11_SIG_CONF);
  encryptedElementSecurityEvent.setElementPath(headerPath);
  policyEnforcer.registerSecurityEvent(encryptedElementSecurityEvent);
  SignedPartSecurityEvent signedPartSecurityEvent=new SignedPartSecurityEvent(null,true,protectionOrder);
  QName elementName=new QName("http://www.example.com","bodyChildElement");
  signedPartSecurityEvent.setXmlSecEvent(XMLSecEventFactory.createXmlSecStartElement(elementName,null,null));
  List<QName> elementPath=new ArrayList<>();
  elementPath.addAll(WSSConstants.SOAP_11_BODY_PATH);
  elementPath.add(elementName);
  signedPartSecurityEvent.setElementPath(elementPath);
  policyEnforcer.registerSecurityEvent(signedPartSecurityEvent);
  OperationSecurityEvent operationSecurityEvent=new OperationSecurityEvent();
  operationSecurityEvent.setOperation(new QName("definitions"));
  try {
    policyEnforcer.registerSecurityEvent(operationSecurityEvent);
    Assert.fail("Exception expected");
  }
 catch (  WSSecurityException e) {
    Assert.assertTrue(e.getCause() instanceof PolicyViolationException);
    Assert.assertEquals(e.getCause().getMessage(),"OnlySignEntireHeadersAndBody not fulfilled, offending element: " + "/{http://schemas.xmlsoap.org/soap/envelope/}Envelope/{http://schemas.xmlsoap.org/soap/envelope/}Body/{http://www.example.com}bodyChildElement");
    Assert.assertEquals(e.getFaultCode(),WSSecurityException.INVALID_SECURITY);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-5 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testPolicySignatureNotEncrypted() throws Exception {
  String policyString="<sp:AsymmetricBinding xmlns:sp=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702\" xmlns:sp3=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200802\">\n" + "<wsp:Policy xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\">\n" + "   <sp:AlgorithmSuite>\n"+ "       <wsp:Policy>\n"+ "           <sp:Basic256/>\n"+ "       </wsp:Policy>\n"+ "   </sp:AlgorithmSuite>\n"+ "<sp:IncludeTimestamp/>\n"+ "<sp:EncryptSignature/>\n"+ "<sp:ProtectTokens/>\n"+ "<sp:OnlySignEntireHeadersAndBody/>\n"+ "</wsp:Policy>\n"+ "</sp:AsymmetricBinding>";
  PolicyEnforcer policyEnforcer=buildAndStartPolicyEngine(policyString);
  TimestampSecurityEvent timestampSecurityEvent=new TimestampSecurityEvent();
  policyEnforcer.registerSecurityEvent(timestampSecurityEvent);
  X509TokenSecurityEvent x509TokenSecurityEvent=new X509TokenSecurityEvent();
  X509SecurityTokenImpl securityToken=getX509Token(WSSecurityTokenConstants.X509V3Token);
  securityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_MAIN_SIGNATURE);
  x509TokenSecurityEvent.setSecurityToken(securityToken);
  policyEnforcer.registerSecurityEvent(x509TokenSecurityEvent);
  x509TokenSecurityEvent=new X509TokenSecurityEvent();
  securityToken=getX509Token(WSSecurityTokenConstants.X509V3Token);
  securityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_MAIN_ENCRYPTION);
  x509TokenSecurityEvent.setSecurityToken(securityToken);
  policyEnforcer.registerSecurityEvent(x509TokenSecurityEvent);
  List<XMLSecurityConstants.ContentType> protectionOrder=new LinkedList<>();
  protectionOrder.add(XMLSecurityConstants.ContentType.SIGNATURE);
  protectionOrder.add(XMLSecurityConstants.ContentType.ENCRYPTION);
  EncryptedElementSecurityEvent encryptedElementSecurityEvent=new EncryptedElementSecurityEvent(null,false,protectionOrder);
  List<QName> headerPath=new ArrayList<>();
  headerPath.addAll(WSSConstants.WSSE_SECURITY_HEADER_PATH);
  headerPath.add(WSSConstants.TAG_dsig_Signature);
  encryptedElementSecurityEvent.setElementPath(headerPath);
  policyEnforcer.registerSecurityEvent(encryptedElementSecurityEvent);
  OperationSecurityEvent operationSecurityEvent=new OperationSecurityEvent();
  operationSecurityEvent.setOperation(new QName("definitions"));
  try {
    policyEnforcer.registerSecurityEvent(operationSecurityEvent);
    Assert.fail("Exception expected");
  }
 catch (  WSSecurityException e) {
    Assert.assertTrue(e.getCause() instanceof PolicyViolationException);
    Assert.assertEquals(e.getFaultCode(),WSSecurityException.INVALID_SECURITY);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-5 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testPolicyNotIncludeTimestamp() throws Exception {
  String policyString="<sp:AsymmetricBinding xmlns:sp=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702\" xmlns:sp3=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200802\">\n" + "<wsp:Policy xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\">\n" + "   <sp:AlgorithmSuite>\n"+ "       <wsp:Policy>\n"+ "           <sp:Basic256/>\n"+ "       </wsp:Policy>\n"+ "   </sp:AlgorithmSuite>\n"+ "<sp:EncryptSignature/>\n"+ "<sp:ProtectTokens/>\n"+ "<sp:OnlySignEntireHeadersAndBody/>\n"+ "</wsp:Policy>\n"+ "</sp:AsymmetricBinding>";
  PolicyEnforcer policyEnforcer=buildAndStartPolicyEngine(policyString);
  X509TokenSecurityEvent x509TokenSecurityEvent=new X509TokenSecurityEvent();
  X509SecurityTokenImpl securityToken=getX509Token(WSSecurityTokenConstants.X509V3Token);
  securityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_MAIN_SIGNATURE);
  x509TokenSecurityEvent.setSecurityToken(securityToken);
  policyEnforcer.registerSecurityEvent(x509TokenSecurityEvent);
  x509TokenSecurityEvent=new X509TokenSecurityEvent();
  securityToken=getX509Token(WSSecurityTokenConstants.X509V3Token);
  securityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_MAIN_ENCRYPTION);
  x509TokenSecurityEvent.setSecurityToken(securityToken);
  policyEnforcer.registerSecurityEvent(x509TokenSecurityEvent);
  TimestampSecurityEvent timestampSecurityEvent=new TimestampSecurityEvent();
  policyEnforcer.registerSecurityEvent(timestampSecurityEvent);
  OperationSecurityEvent operationSecurityEvent=new OperationSecurityEvent();
  operationSecurityEvent.setOperation(new QName("definitions"));
  try {
    policyEnforcer.registerSecurityEvent(operationSecurityEvent);
    Assert.fail("Exception expected");
  }
 catch (  WSSecurityException e) {
    Assert.assertTrue(e.getCause() instanceof PolicyViolationException);
    Assert.assertEquals(e.getCause().getMessage(),"Timestamp must not be present");
    Assert.assertEquals(e.getFaultCode(),WSSecurityException.INVALID_SECURITY);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-5 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testPolicyNotWholeSecurityHeaderChildSigned() throws Exception {
  String policyString="<sp:AsymmetricBinding xmlns:sp=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702\" xmlns:sp3=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200802\">\n" + "<wsp:Policy xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\">\n" + "   <sp:AlgorithmSuite>\n"+ "       <wsp:Policy>\n"+ "           <sp:Basic256/>\n"+ "       </wsp:Policy>\n"+ "   </sp:AlgorithmSuite>\n"+ "<sp:IncludeTimestamp/>\n"+ "<sp:EncryptSignature/>\n"+ "<sp:ProtectTokens/>\n"+ "<sp:OnlySignEntireHeadersAndBody/>\n"+ "</wsp:Policy>\n"+ "</sp:AsymmetricBinding>";
  PolicyEnforcer policyEnforcer=buildAndStartPolicyEngine(policyString);
  TimestampSecurityEvent timestampSecurityEvent=new TimestampSecurityEvent();
  policyEnforcer.registerSecurityEvent(timestampSecurityEvent);
  X509TokenSecurityEvent x509TokenSecurityEvent=new X509TokenSecurityEvent();
  X509SecurityTokenImpl securityToken=getX509Token(WSSecurityTokenConstants.X509V3Token);
  securityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_MAIN_SIGNATURE);
  x509TokenSecurityEvent.setSecurityToken(securityToken);
  policyEnforcer.registerSecurityEvent(x509TokenSecurityEvent);
  x509TokenSecurityEvent=new X509TokenSecurityEvent();
  securityToken=getX509Token(WSSecurityTokenConstants.X509V3Token);
  securityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_MAIN_ENCRYPTION);
  x509TokenSecurityEvent.setSecurityToken(securityToken);
  policyEnforcer.registerSecurityEvent(x509TokenSecurityEvent);
  List<XMLSecurityConstants.ContentType> protectionOrder=new LinkedList<>();
  protectionOrder.add(XMLSecurityConstants.ContentType.SIGNATURE);
  protectionOrder.add(XMLSecurityConstants.ContentType.ENCRYPTION);
  EncryptedElementSecurityEvent encryptedElementSecurityEvent=new EncryptedElementSecurityEvent(null,true,protectionOrder);
  List<QName> headerPath=new ArrayList<>();
  headerPath.addAll(WSSConstants.WSSE_SECURITY_HEADER_PATH);
  headerPath.add(WSSConstants.TAG_dsig_Signature);
  encryptedElementSecurityEvent.setElementPath(headerPath);
  policyEnforcer.registerSecurityEvent(encryptedElementSecurityEvent);
  encryptedElementSecurityEvent=new EncryptedElementSecurityEvent(null,true,protectionOrder);
  headerPath=new ArrayList<>();
  headerPath.addAll(WSSConstants.WSSE_SECURITY_HEADER_PATH);
  headerPath.add(WSSConstants.TAG_WSSE11_SIG_CONF);
  encryptedElementSecurityEvent.setElementPath(headerPath);
  policyEnforcer.registerSecurityEvent(encryptedElementSecurityEvent);
  SignedPartSecurityEvent signedPartSecurityEvent=new SignedPartSecurityEvent(null,true,protectionOrder);
  QName elementName=WSSConstants.TAG_WSSE_USERNAME;
  signedPartSecurityEvent.setXmlSecEvent(XMLSecEventFactory.createXmlSecStartElement(elementName,null,null));
  List<QName> elementPath=new ArrayList<>();
  elementPath.addAll(WSSConstants.WSSE_SECURITY_HEADER_PATH);
  elementPath.add(WSSConstants.TAG_WSSE_USERNAME_TOKEN);
  elementPath.add(elementName);
  signedPartSecurityEvent.setElementPath(elementPath);
  policyEnforcer.registerSecurityEvent(signedPartSecurityEvent);
  OperationSecurityEvent operationSecurityEvent=new OperationSecurityEvent();
  operationSecurityEvent.setOperation(new QName("definitions"));
  try {
    policyEnforcer.registerSecurityEvent(operationSecurityEvent);
    Assert.fail("Exception expected");
  }
 catch (  WSSecurityException e) {
    Assert.assertTrue(e.getCause() instanceof PolicyViolationException);
    Assert.assertEquals(e.getCause().getMessage(),"OnlySignEntireHeadersAndBody not fulfilled, offending element: " + "/{http://schemas.xmlsoap.org/soap/envelope/}Envelope/{http://schemas.xmlsoap.org/soap/envelope/}Header/{http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd}Security/{http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd}UsernameToken/{http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd}Username");
    Assert.assertEquals(e.getFaultCode(),WSSecurityException.INVALID_SECURITY);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-5 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testPolicyWrongProtectionOrder() throws Exception {
  String policyString="<sp:AsymmetricBinding xmlns:sp=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702\" xmlns:sp3=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200802\">\n" + "<wsp:Policy xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\">\n" + "   <sp:AlgorithmSuite>\n"+ "       <wsp:Policy>\n"+ "           <sp:Basic256/>\n"+ "       </wsp:Policy>\n"+ "   </sp:AlgorithmSuite>\n"+ "<sp:IncludeTimestamp/>\n"+ "<sp:EncryptBeforeSigning/>\n"+ "<sp:EncryptSignature/>\n"+ "<sp:ProtectTokens/>\n"+ "<sp:OnlySignEntireHeadersAndBody/>\n"+ "</wsp:Policy>\n"+ "</sp:AsymmetricBinding>";
  PolicyEnforcer policyEnforcer=buildAndStartPolicyEngine(policyString);
  X509TokenSecurityEvent x509TokenSecurityEvent=new X509TokenSecurityEvent();
  X509SecurityTokenImpl securityToken=getX509Token(WSSecurityTokenConstants.X509V3Token);
  securityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_MAIN_ENCRYPTION);
  x509TokenSecurityEvent.setSecurityToken(securityToken);
  policyEnforcer.registerSecurityEvent(x509TokenSecurityEvent);
  List<XMLSecurityConstants.ContentType> protectionOrder=new LinkedList<>();
  protectionOrder.add(XMLSecurityConstants.ContentType.SIGNATURE);
  protectionOrder.add(XMLSecurityConstants.ContentType.ENCRYPTION);
  SignedPartSecurityEvent signedPartSecurityEvent=new SignedPartSecurityEvent(null,true,protectionOrder);
  signedPartSecurityEvent.setElementPath(WSSConstants.SOAP_11_BODY_PATH);
  policyEnforcer.registerSecurityEvent(signedPartSecurityEvent);
  OperationSecurityEvent operationSecurityEvent=new OperationSecurityEvent();
  operationSecurityEvent.setOperation(new QName("definitions"));
  try {
    policyEnforcer.registerSecurityEvent(operationSecurityEvent);
    Assert.fail("Exception expected");
  }
 catch (  WSSecurityException e) {
    Assert.assertTrue(e.getCause() instanceof PolicyViolationException);
    Assert.assertEquals(e.getCause().getMessage(),"Policy enforces EncryptBeforeSigning but the /{http://schemas.xmlsoap.org/soap/envelope/}Envelope/{http://schemas.xmlsoap.org/soap/envelope/}Body was signed and then encrypted");
    Assert.assertEquals(e.getFaultCode(),WSSecurityException.INVALID_SECURITY);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.wss4j.policy.stax.test.ContentEncryptedElementsTest </h4><pre class="type-8 type-7 type-5 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testPolicyMultipleAssertionEventsNegative() throws Exception {
  String policyString="<sp:ContentEncryptedElements xmlns:sp=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702\" xmlns:sp3=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200802\">\n" + "<sp:XPath xmlns:b=\"http://example.org\">/b:a</sp:XPath>\n" + "</sp:ContentEncryptedElements>";
  PolicyEnforcer policyEnforcer=buildAndStartPolicyEngine(policyString);
  OperationSecurityEvent operationSecurityEvent=new OperationSecurityEvent();
  operationSecurityEvent.setOperation(new QName("definitions"));
  policyEnforcer.registerSecurityEvent(operationSecurityEvent);
  List<XMLSecurityConstants.ContentType> protectionOrder=new LinkedList<>();
  protectionOrder.add(XMLSecurityConstants.ContentType.SIGNATURE);
  protectionOrder.add(XMLSecurityConstants.ContentType.ENCRYPTION);
  ContentEncryptedElementSecurityEvent contentEncryptedElementSecurityEvent=new ContentEncryptedElementSecurityEvent(null,true,protectionOrder);
  contentEncryptedElementSecurityEvent.setElementPath(WSSConstants.SOAP_11_BODY_PATH);
  policyEnforcer.registerSecurityEvent(contentEncryptedElementSecurityEvent);
  contentEncryptedElementSecurityEvent=new ContentEncryptedElementSecurityEvent(null,false,null);
  List<QName> headerPath=new ArrayList<>();
  headerPath.add(new QName("http://example.org","a"));
  contentEncryptedElementSecurityEvent.setElementPath(headerPath);
  try {
    policyEnforcer.registerSecurityEvent(contentEncryptedElementSecurityEvent);
    Assert.fail("Exception expected");
  }
 catch (  WSSecurityException e) {
    Assert.assertTrue(e.getCause() instanceof PolicyViolationException);
    Assert.assertEquals(e.getCause().getMessage(),"Content of element /{http://example.org}a must be encrypted");
    Assert.assertEquals(e.getFaultCode(),WSSecurityException.INVALID_SECURITY);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.wss4j.policy.stax.test.DerivedKeyTests </h4><pre class="type-8 type-5 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testDerivedKeyInitiatorTokenPolicyNegative() throws Exception {
  String policyString="<sp:AsymmetricBinding xmlns:sp=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702\" xmlns:sp3=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200802\">\n" + "<wsp:Policy xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\">\n" + "<sp:InitiatorToken>\n"+ "   <wsp:Policy>\n"+ "       <sp:X509Token>\n"+ "           <sp:IssuerName>CN=transmitter,OU=swssf,C=CH</sp:IssuerName>\n"+ "           <wsp:Policy xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\">\n"+ "               <sp:RequireDerivedKeys/>\n"+ "           </wsp:Policy>\n"+ "       </sp:X509Token>\n"+ "   </wsp:Policy>\n"+ "</sp:InitiatorToken>\n"+ "<sp:RecipientToken>\n"+ "   <wsp:Policy>\n"+ "       <sp:X509Token>\n"+ "           <sp:IssuerName>CN=transmitter,OU=swssf,C=CH</sp:IssuerName>\n"+ "           <wsp:Policy xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\">\n"+ "               <sp:RequireDerivedKeys/>\n"+ "           </wsp:Policy>\n"+ "       </sp:X509Token>\n"+ "   </wsp:Policy>\n"+ "</sp:RecipientToken>\n"+ "   <sp:AlgorithmSuite>\n"+ "       <wsp:Policy>\n"+ "           <sp:Basic256/>\n"+ "       </wsp:Policy>\n"+ "   </sp:AlgorithmSuite>\n"+ "</wsp:Policy>\n"+ "</sp:AsymmetricBinding>";
  PolicyEnforcer policyEnforcer=buildAndStartPolicyEngine(policyString);
  X509TokenSecurityEvent initiatorX509TokenSecurityEvent=new X509TokenSecurityEvent();
  X509SecurityTokenImpl securityToken=getX509Token(WSSecurityTokenConstants.X509V3Token);
  securityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_MAIN_SIGNATURE);
  initiatorX509TokenSecurityEvent.setSecurityToken(securityToken);
  policyEnforcer.registerSecurityEvent(initiatorX509TokenSecurityEvent);
  X509TokenSecurityEvent recipientX509TokenSecurityEvent=new X509TokenSecurityEvent();
  securityToken=getX509Token(WSSecurityTokenConstants.X509V3Token);
  securityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_MAIN_ENCRYPTION);
  recipientX509TokenSecurityEvent.setSecurityToken(securityToken);
  DerivedKeyTokenSecurityEvent derivedKeyTokenSecurityEvent=new DerivedKeyTokenSecurityEvent();
  derivedKeyTokenSecurityEvent.setSecurityToken(getX509Token(WSSecurityTokenConstants.DerivedKeyToken));
  securityToken.addWrappedToken((InboundSecurityToken)derivedKeyTokenSecurityEvent.getSecurityToken());
  policyEnforcer.registerSecurityEvent(recipientX509TokenSecurityEvent);
  List<XMLSecurityConstants.ContentType> protectionOrder=new LinkedList<>();
  protectionOrder.add(XMLSecurityConstants.ContentType.SIGNATURE);
  protectionOrder.add(XMLSecurityConstants.ContentType.ENCRYPTION);
  SignedPartSecurityEvent signedPartSecurityEvent=new SignedPartSecurityEvent((InboundSecurityToken)recipientX509TokenSecurityEvent.getSecurityToken(),true,protectionOrder);
  signedPartSecurityEvent.setElementPath(WSSConstants.SOAP_11_BODY_PATH);
  policyEnforcer.registerSecurityEvent(signedPartSecurityEvent);
  ContentEncryptedElementSecurityEvent contentEncryptedElementSecurityEvent=new ContentEncryptedElementSecurityEvent((InboundSecurityToken)recipientX509TokenSecurityEvent.getSecurityToken(),true,protectionOrder);
  contentEncryptedElementSecurityEvent.setElementPath(WSSConstants.SOAP_11_BODY_PATH);
  policyEnforcer.registerSecurityEvent(contentEncryptedElementSecurityEvent);
  OperationSecurityEvent operationSecurityEvent=new OperationSecurityEvent();
  operationSecurityEvent.setOperation(new QName("definitions"));
  try {
    policyEnforcer.registerSecurityEvent(operationSecurityEvent);
    Assert.fail("Exception expected");
  }
 catch (  WSSecurityException e) {
    Assert.assertEquals(e.getMessage(),"Derived key must be used");
    Assert.assertEquals(e.getFaultCode(),WSSecurityException.INVALID_SECURITY);
  }
}

</code></pre>

<br>
<pre class="type-8 type-5 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testDerivedKeyRecipientTokenPolicyNegative() throws Exception {
  String policyString="<sp:AsymmetricBinding xmlns:sp=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702\" xmlns:sp3=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200802\">\n" + "<wsp:Policy xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\">\n" + "<sp:InitiatorToken>\n"+ "   <wsp:Policy>\n"+ "       <sp:X509Token>\n"+ "           <sp:IssuerName>CN=transmitter,OU=swssf,C=CH</sp:IssuerName>\n"+ "           <wsp:Policy xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\">\n"+ "               <sp:RequireDerivedKeys/>\n"+ "           </wsp:Policy>\n"+ "       </sp:X509Token>\n"+ "   </wsp:Policy>\n"+ "</sp:InitiatorToken>\n"+ "<sp:RecipientToken>\n"+ "   <wsp:Policy>\n"+ "       <sp:X509Token>\n"+ "           <sp:IssuerName>CN=transmitter,OU=swssf,C=CH</sp:IssuerName>\n"+ "           <wsp:Policy xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\">\n"+ "               <sp:RequireDerivedKeys/>\n"+ "           </wsp:Policy>\n"+ "       </sp:X509Token>\n"+ "   </wsp:Policy>\n"+ "</sp:RecipientToken>\n"+ "   <sp:AlgorithmSuite>\n"+ "       <wsp:Policy>\n"+ "           <sp:Basic256/>\n"+ "       </wsp:Policy>\n"+ "   </sp:AlgorithmSuite>\n"+ "</wsp:Policy>\n"+ "</sp:AsymmetricBinding>";
  PolicyEnforcer policyEnforcer=buildAndStartPolicyEngine(policyString);
  X509TokenSecurityEvent initiatorX509TokenSecurityEvent=new X509TokenSecurityEvent();
  X509SecurityTokenImpl securityToken=getX509Token(WSSecurityTokenConstants.X509V3Token);
  securityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_MAIN_SIGNATURE);
  initiatorX509TokenSecurityEvent.setSecurityToken(securityToken);
  DerivedKeyTokenSecurityEvent derivedKeyTokenSecurityEvent=new DerivedKeyTokenSecurityEvent();
  derivedKeyTokenSecurityEvent.setSecurityToken(getX509Token(WSSecurityTokenConstants.DerivedKeyToken));
  securityToken.addWrappedToken((InboundSecurityToken)derivedKeyTokenSecurityEvent.getSecurityToken());
  policyEnforcer.registerSecurityEvent(initiatorX509TokenSecurityEvent);
  X509TokenSecurityEvent recipientX509TokenSecurityEvent=new X509TokenSecurityEvent();
  securityToken=getX509Token(WSSecurityTokenConstants.X509V3Token);
  securityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_MAIN_ENCRYPTION);
  recipientX509TokenSecurityEvent.setSecurityToken(securityToken);
  policyEnforcer.registerSecurityEvent(recipientX509TokenSecurityEvent);
  List<XMLSecurityConstants.ContentType> protectionOrder=new LinkedList<>();
  protectionOrder.add(XMLSecurityConstants.ContentType.SIGNATURE);
  protectionOrder.add(XMLSecurityConstants.ContentType.ENCRYPTION);
  SignedPartSecurityEvent signedPartSecurityEvent=new SignedPartSecurityEvent((InboundSecurityToken)recipientX509TokenSecurityEvent.getSecurityToken(),true,protectionOrder);
  signedPartSecurityEvent.setElementPath(WSSConstants.SOAP_11_BODY_PATH);
  policyEnforcer.registerSecurityEvent(signedPartSecurityEvent);
  ContentEncryptedElementSecurityEvent contentEncryptedElementSecurityEvent=new ContentEncryptedElementSecurityEvent((InboundSecurityToken)recipientX509TokenSecurityEvent.getSecurityToken(),true,protectionOrder);
  contentEncryptedElementSecurityEvent.setElementPath(WSSConstants.SOAP_11_BODY_PATH);
  policyEnforcer.registerSecurityEvent(contentEncryptedElementSecurityEvent);
  OperationSecurityEvent operationSecurityEvent=new OperationSecurityEvent();
  operationSecurityEvent.setOperation(new QName("definitions"));
  try {
    policyEnforcer.registerSecurityEvent(operationSecurityEvent);
    Assert.fail("Exception expected");
  }
 catch (  WSSecurityException e) {
    Assert.assertEquals(e.getMessage(),"Derived key must be used");
    Assert.assertEquals(e.getFaultCode(),WSSecurityException.INVALID_SECURITY);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testDerivedKeySupportingTokenPolicyAdditionalTokenNegative() throws Exception {
  String policyString="<sp:SupportingTokens xmlns:sp=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702\" xmlns:sp3=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200802\">\n" + "<wsp:Policy xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\">\n" + "       <sp:X509Token>\n"+ "           <sp:IssuerName>CN=transmitter,OU=swssf,C=CH</sp:IssuerName>\n"+ "           <wsp:Policy xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\">\n"+ "               <sp:RequireDerivedKeys/>\n"+ "           </wsp:Policy>\n"+ "       </sp:X509Token>\n"+ "   </wsp:Policy>\n"+ "</sp:SupportingTokens>";
  PolicyEnforcer policyEnforcer=buildAndStartPolicyEngine(policyString);
  X509TokenSecurityEvent x509TokenSecurityEvent=new X509TokenSecurityEvent();
  X509SecurityTokenImpl securityToken=getX509Token(WSSecurityTokenConstants.X509V1Token);
  securityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_SUPPORTING_TOKENS);
  x509TokenSecurityEvent.setSecurityToken(securityToken);
  policyEnforcer.registerSecurityEvent(x509TokenSecurityEvent);
  x509TokenSecurityEvent=new X509TokenSecurityEvent();
  securityToken=getX509Token(WSSecurityTokenConstants.X509V1Token);
  securityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_SUPPORTING_TOKENS);
  x509TokenSecurityEvent.setSecurityToken(securityToken);
  policyEnforcer.registerSecurityEvent(x509TokenSecurityEvent);
  OperationSecurityEvent operationSecurityEvent=new OperationSecurityEvent();
  operationSecurityEvent.setOperation(new QName("definitions"));
  try {
    policyEnforcer.registerSecurityEvent(operationSecurityEvent);
    Assert.fail("Exception expected");
  }
 catch (  WSSecurityException e) {
    Assert.assertTrue(e.getCause() instanceof WSSPolicyException);
  }
}

</code></pre>

<br>
<pre class="type-8 type-5 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testDerivedKeySupportingTokenPolicyNegative() throws Exception {
  String policyString="<sp:SupportingTokens xmlns:sp=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702\" xmlns:sp3=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200802\">\n" + "<wsp:Policy xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\">\n" + "       <sp:X509Token>\n"+ "           <sp:IssuerName>CN=transmitter,OU=swssf,C=CH</sp:IssuerName>\n"+ "           <wsp:Policy xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\">\n"+ "               <sp:RequireDerivedKeys/>\n"+ "           </wsp:Policy>\n"+ "       </sp:X509Token>\n"+ "   </wsp:Policy>\n"+ "</sp:SupportingTokens>";
  PolicyEnforcer policyEnforcer=buildAndStartPolicyEngine(policyString);
  X509TokenSecurityEvent x509TokenSecurityEvent=new X509TokenSecurityEvent();
  X509SecurityTokenImpl securityToken=getX509Token(WSSecurityTokenConstants.X509V1Token);
  securityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_SUPPORTING_TOKENS);
  x509TokenSecurityEvent.setSecurityToken(securityToken);
  policyEnforcer.registerSecurityEvent(x509TokenSecurityEvent);
  OperationSecurityEvent operationSecurityEvent=new OperationSecurityEvent();
  operationSecurityEvent.setOperation(new QName("definitions"));
  try {
    policyEnforcer.registerSecurityEvent(operationSecurityEvent);
    Assert.fail("Exception expected");
  }
 catch (  WSSecurityException e) {
    Assert.assertEquals(e.getMessage(),"Derived key must be used");
    Assert.assertEquals(e.getFaultCode(),WSSecurityException.INVALID_SECURITY);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.wss4j.policy.stax.test.EncryptedElementsTest </h4><pre class="type-8 type-7 type-5 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testPolicyMultipleAssertionEventsNegative() throws Exception {
  String policyString="<sp:EncryptedElements xmlns:sp=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702\" xmlns:sp3=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200802\">\n" + "<sp:XPath xmlns:b=\"http://example.org\">/b:a</sp:XPath>\n" + "</sp:EncryptedElements>";
  PolicyEnforcer policyEnforcer=buildAndStartPolicyEngine(policyString);
  OperationSecurityEvent operationSecurityEvent=new OperationSecurityEvent();
  operationSecurityEvent.setOperation(new QName("definitions"));
  policyEnforcer.registerSecurityEvent(operationSecurityEvent);
  List<XMLSecurityConstants.ContentType> protectionOrder=new LinkedList<>();
  protectionOrder.add(XMLSecurityConstants.ContentType.SIGNATURE);
  protectionOrder.add(XMLSecurityConstants.ContentType.ENCRYPTION);
  EncryptedElementSecurityEvent encryptedElementSecurityEvent=new EncryptedElementSecurityEvent(null,true,protectionOrder);
  encryptedElementSecurityEvent.setElementPath(WSSConstants.SOAP_11_BODY_PATH);
  policyEnforcer.registerSecurityEvent(encryptedElementSecurityEvent);
  encryptedElementSecurityEvent=new EncryptedElementSecurityEvent(null,false,null);
  List<QName> headerPath=new ArrayList<>();
  headerPath.add(new QName("http://example.org","a"));
  encryptedElementSecurityEvent.setElementPath(headerPath);
  try {
    policyEnforcer.registerSecurityEvent(encryptedElementSecurityEvent);
    Assert.fail("Exception expected");
  }
 catch (  WSSecurityException e) {
    Assert.assertTrue(e.getCause() instanceof PolicyViolationException);
    Assert.assertEquals(e.getCause().getMessage(),"Element /{http://example.org}a must be encrypted");
    Assert.assertEquals(e.getFaultCode(),WSSecurityException.INVALID_SECURITY);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.wss4j.policy.stax.test.EncryptedPartsTest </h4><pre class="type-8 type-7 type-5 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testPolicyWildcardHeaderNegative() throws Exception {
  String policyString="<sp:EncryptedParts xmlns:sp=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702\" xmlns:sp3=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200802\">\n" + "<sp:Body/>\n" + "<sp:Header Namespace=\"http://example.org\"/>\n"+ "<sp:Attachments/>\n"+ "</sp:EncryptedParts>";
  PolicyEnforcer policyEnforcer=buildAndStartPolicyEngine(policyString);
  OperationSecurityEvent operationSecurityEvent=new OperationSecurityEvent();
  operationSecurityEvent.setOperation(new QName("definitions"));
  policyEnforcer.registerSecurityEvent(operationSecurityEvent);
  List<XMLSecurityConstants.ContentType> protectionOrder=new LinkedList<>();
  protectionOrder.add(XMLSecurityConstants.ContentType.SIGNATURE);
  protectionOrder.add(XMLSecurityConstants.ContentType.ENCRYPTION);
  EncryptedPartSecurityEvent encryptedPartSecurityEvent=new EncryptedPartSecurityEvent(null,true,protectionOrder);
  encryptedPartSecurityEvent.setElementPath(WSSConstants.SOAP_11_BODY_PATH);
  policyEnforcer.registerSecurityEvent(encryptedPartSecurityEvent);
  encryptedPartSecurityEvent=new EncryptedPartSecurityEvent(null,false,null);
  List<QName> headerPath=new ArrayList<>();
  headerPath.addAll(WSSConstants.SOAP_11_HEADER_PATH);
  headerPath.add(new QName("http://example.org","a"));
  encryptedPartSecurityEvent.setElementPath(headerPath);
  try {
    policyEnforcer.registerSecurityEvent(encryptedPartSecurityEvent);
    Assert.fail("Exception expected");
  }
 catch (  WSSecurityException e) {
    Assert.assertTrue(e.getCause() instanceof PolicyViolationException);
    Assert.assertEquals(e.getCause().getMessage(),"Element /{http://schemas.xmlsoap.org/soap/envelope/}Envelope/{http://schemas.xmlsoap.org/soap/envelope/}Header/{http://example.org}a must be encrypted");
    Assert.assertEquals(e.getFaultCode(),WSSecurityException.INVALID_SECURITY);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-5 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testPolicyMultipleAssertionEventsNegative() throws Exception {
  String policyString="<sp:EncryptedParts xmlns:sp=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702\" xmlns:sp3=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200802\">\n" + "<sp:Body/>\n" + "<sp:Header Name=\"a\" Namespace=\"http://example.org\"/>\n"+ "<sp:Attachments/>\n"+ "</sp:EncryptedParts>";
  PolicyEnforcer policyEnforcer=buildAndStartPolicyEngine(policyString);
  OperationSecurityEvent operationSecurityEvent=new OperationSecurityEvent();
  operationSecurityEvent.setOperation(new QName("definitions"));
  policyEnforcer.registerSecurityEvent(operationSecurityEvent);
  List<XMLSecurityConstants.ContentType> protectionOrder=new LinkedList<>();
  protectionOrder.add(XMLSecurityConstants.ContentType.SIGNATURE);
  protectionOrder.add(XMLSecurityConstants.ContentType.ENCRYPTION);
  EncryptedPartSecurityEvent encryptedPartSecurityEvent=new EncryptedPartSecurityEvent(null,true,protectionOrder);
  encryptedPartSecurityEvent.setElementPath(WSSConstants.SOAP_11_BODY_PATH);
  policyEnforcer.registerSecurityEvent(encryptedPartSecurityEvent);
  encryptedPartSecurityEvent=new EncryptedPartSecurityEvent(null,false,null);
  List<QName> headerPath=new ArrayList<>();
  headerPath.addAll(WSSConstants.SOAP_11_HEADER_PATH);
  headerPath.add(new QName("http://example.org","a"));
  encryptedPartSecurityEvent.setElementPath(headerPath);
  try {
    policyEnforcer.registerSecurityEvent(encryptedPartSecurityEvent);
    Assert.fail("Exception expected");
  }
 catch (  WSSecurityException e) {
    Assert.assertTrue(e.getCause() instanceof PolicyViolationException);
    Assert.assertEquals(e.getCause().getMessage(),"Element /{http://schemas.xmlsoap.org/soap/envelope/}Envelope/{http://schemas.xmlsoap.org/soap/envelope/}Header/{http://example.org}a must be encrypted");
    Assert.assertEquals(e.getFaultCode(),WSSecurityException.INVALID_SECURITY);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.wss4j.policy.stax.test.HttpsTokenTest </h4><pre class="type-8 type-7 type-5 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testPolicyNegative() throws Exception {
  String policyString="<sp:TransportBinding xmlns:sp=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702\" xmlns:sp3=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200802\">\n" + "<wsp:Policy xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\">\n" + "<sp:TransportToken>\n"+ "   <wsp:Policy>\n"+ "       <sp:HttpsToken>\n"+ "       <sp:IssuerName>xs:anyURI</sp:IssuerName>\n"+ "       <wsp:Policy xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\">\n"+ "           <sp:RequireClientCertificate/>\n"+ "       </wsp:Policy>\n"+ "       </sp:HttpsToken>"+ "   </wsp:Policy>\n"+ "</sp:TransportToken>\n"+ "   <sp:AlgorithmSuite>\n"+ "       <wsp:Policy>\n"+ "           <sp:Basic256/>\n"+ "       </wsp:Policy>\n"+ "   </sp:AlgorithmSuite>\n"+ "</wsp:Policy>\n"+ "</sp:TransportBinding>";
  PolicyEnforcer policyEnforcer=buildAndStartPolicyEngine(policyString);
  HttpsTokenSecurityEvent httpsTokenSecurityEvent=new HttpsTokenSecurityEvent();
  HttpsSecurityTokenImpl securityToken=getHttpsSecurityToken(WSSecurityTokenConstants.X509V3Token);
  securityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_MAIN_ENCRYPTION);
  httpsTokenSecurityEvent.setSecurityToken(securityToken);
  httpsTokenSecurityEvent.setAuthenticationType(HttpsTokenSecurityEvent.AuthenticationType.HttpBasicAuthentication);
  httpsTokenSecurityEvent.setIssuerName("xs:anyURI");
  policyEnforcer.registerSecurityEvent(httpsTokenSecurityEvent);
  OperationSecurityEvent operationSecurityEvent=new OperationSecurityEvent();
  operationSecurityEvent.setOperation(new QName("definitions"));
  try {
    policyEnforcer.registerSecurityEvent(operationSecurityEvent);
    Assert.fail("Exception expected");
  }
 catch (  WSSecurityException e) {
    Assert.assertTrue(e.getCause() instanceof PolicyViolationException);
    Assert.assertEquals(e.getCause().getMessage(),"Policy enforces HttpClientCertificateAuthentication but we got HttpBasicAuthentication");
    Assert.assertEquals(e.getFaultCode(),WSSecurityException.INVALID_SECURITY);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.wss4j.policy.stax.test.IssuedTokenTest </h4><pre class="type-8 type-7 type-5 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testPolicyWithSAMLTokenMissingClaimType() throws Exception {
  PolicyEnforcer policyEnforcer=buildAndStartPolicyEngine(samlPolicyString);
  SAMLCallback samlCallback=new SAMLCallback();
  samlCallback.setSamlVersion(Version.SAML_20);
  samlCallback.setIssuer("http://initiatorTokenIssuer.com");
  SubjectBean subjectBean=new SubjectBean();
  samlCallback.setSubject(subjectBean);
  List<AttributeStatementBean> attributeStatementBeans=new ArrayList<>();
  List<AttributeBean> attributeBeans=new ArrayList<>();
  List attributeValues=new ArrayList<>();
  attributeValues.add("test@example.com");
  attributeBeans.add(new AttributeBean("email","http://schemas.xmlsoap.org/ws/2005/05/identity/claims/email",attributeValues));
  attributeStatementBeans.add(new AttributeStatementBean(subjectBean,attributeBeans));
  samlCallback.setAttributeStatementData(attributeStatementBeans);
  SamlAssertionWrapper samlAssertionWrapper=createSamlAssertionWrapper(samlCallback);
  SamlTokenSecurityEvent initiatorTokenSecurityEvent=new SamlTokenSecurityEvent();
  SamlSecurityTokenImpl securityToken=new SamlSecurityTokenImpl(samlAssertionWrapper,getX509Token(WSSecurityTokenConstants.X509V3Token),null,null,WSSecurityTokenConstants.KEYIDENTIFIER_SECURITY_TOKEN_DIRECT_REFERENCE,null);
  securityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_MAIN_SIGNATURE);
  initiatorTokenSecurityEvent.setSecurityToken(securityToken);
  policyEnforcer.registerSecurityEvent(initiatorTokenSecurityEvent);
  samlCallback.setIssuer("http://recipientTokenIssuer.com");
  samlAssertionWrapper=createSamlAssertionWrapper(samlCallback);
  SamlTokenSecurityEvent recipientTokenSecurityEvent=new SamlTokenSecurityEvent();
  securityToken=new SamlSecurityTokenImpl(samlAssertionWrapper,getX509Token(WSSecurityTokenConstants.X509V3Token),null,null,WSSecurityTokenConstants.KEYIDENTIFIER_SECURITY_TOKEN_DIRECT_REFERENCE,null);
  securityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_MAIN_ENCRYPTION);
  recipientTokenSecurityEvent.setSecurityToken(securityToken);
  policyEnforcer.registerSecurityEvent(recipientTokenSecurityEvent);
  List<XMLSecurityConstants.ContentType> protectionOrder=new LinkedList<>();
  protectionOrder.add(XMLSecurityConstants.ContentType.SIGNATURE);
  protectionOrder.add(XMLSecurityConstants.ContentType.ENCRYPTION);
  SignedPartSecurityEvent signedPartSecurityEvent=new SignedPartSecurityEvent((InboundSecurityToken)recipientTokenSecurityEvent.getSecurityToken(),true,protectionOrder);
  signedPartSecurityEvent.setElementPath(WSSConstants.SOAP_11_BODY_PATH);
  policyEnforcer.registerSecurityEvent(signedPartSecurityEvent);
  ContentEncryptedElementSecurityEvent contentEncryptedElementSecurityEvent=new ContentEncryptedElementSecurityEvent((InboundSecurityToken)recipientTokenSecurityEvent.getSecurityToken(),true,protectionOrder);
  contentEncryptedElementSecurityEvent.setElementPath(WSSConstants.SOAP_11_BODY_PATH);
  policyEnforcer.registerSecurityEvent(contentEncryptedElementSecurityEvent);
  OperationSecurityEvent operationSecurityEvent=new OperationSecurityEvent();
  operationSecurityEvent.setOperation(new QName("definitions"));
  try {
    policyEnforcer.registerSecurityEvent(operationSecurityEvent);
    Assert.fail("Exception expected");
  }
 catch (  WSSecurityException e) {
    Assert.assertTrue(e.getCause() instanceof PolicyViolationException);
    Assert.assertEquals(e.getCause().getMessage(),"Attribute http://schemas.xmlsoap.org/ws/2005/05/identity/claims/surname not found in the SAMLAssertion");
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-5 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testPolicyWithSAMLTokenWrongKeyType() throws Exception {
  PolicyEnforcer policyEnforcer=buildAndStartPolicyEngine(samlPolicyString.replaceFirst("PublicKey","SymmetricKey"));
  SAMLCallback samlCallback=new SAMLCallback();
  samlCallback.setSamlVersion(Version.SAML_20);
  samlCallback.setIssuer("http://initiatorTokenIssuer.com");
  SubjectBean subjectBean=new SubjectBean();
  samlCallback.setSubject(subjectBean);
  List<AttributeStatementBean> attributeStatementBeans=new ArrayList<>();
  List<AttributeBean> attributeBeans=new ArrayList<>();
  List attributeValues=new ArrayList<>();
  attributeValues.add("test@example.com");
  attributeBeans.add(new AttributeBean("email","http://schemas.xmlsoap.org/ws/2005/05/identity/claims/email",attributeValues));
  attributeValues.clear();
  attributeValues.add("Proper");
  attributeBeans.add(new AttributeBean("surname","http://schemas.xmlsoap.org/ws/2005/05/identity/claims/surname",attributeValues));
  attributeStatementBeans.add(new AttributeStatementBean(subjectBean,attributeBeans));
  samlCallback.setAttributeStatementData(attributeStatementBeans);
  SamlAssertionWrapper samlAssertionWrapper=createSamlAssertionWrapper(samlCallback);
  SamlTokenSecurityEvent initiatorTokenSecurityEvent=new SamlTokenSecurityEvent();
  SamlSecurityTokenImpl securityToken=new SamlSecurityTokenImpl(samlAssertionWrapper,getX509Token(WSSecurityTokenConstants.X509V3Token),null,null,WSSecurityTokenConstants.KEYIDENTIFIER_SECURITY_TOKEN_DIRECT_REFERENCE,null);
  securityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_MAIN_SIGNATURE);
  initiatorTokenSecurityEvent.setSecurityToken(securityToken);
  policyEnforcer.registerSecurityEvent(initiatorTokenSecurityEvent);
  samlCallback.setIssuer("http://recipientTokenIssuer.com");
  samlAssertionWrapper=createSamlAssertionWrapper(samlCallback);
  SamlTokenSecurityEvent recipientTokenSecurityEvent=new SamlTokenSecurityEvent();
  securityToken=new SamlSecurityTokenImpl(samlAssertionWrapper,getX509Token(WSSecurityTokenConstants.X509V3Token),null,null,WSSecurityTokenConstants.KEYIDENTIFIER_SECURITY_TOKEN_DIRECT_REFERENCE,null);
  securityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_MAIN_ENCRYPTION);
  recipientTokenSecurityEvent.setSecurityToken(securityToken);
  policyEnforcer.registerSecurityEvent(recipientTokenSecurityEvent);
  List<XMLSecurityConstants.ContentType> protectionOrder=new LinkedList<>();
  protectionOrder.add(XMLSecurityConstants.ContentType.SIGNATURE);
  protectionOrder.add(XMLSecurityConstants.ContentType.ENCRYPTION);
  SignedPartSecurityEvent signedPartSecurityEvent=new SignedPartSecurityEvent((InboundSecurityToken)recipientTokenSecurityEvent.getSecurityToken(),true,protectionOrder);
  signedPartSecurityEvent.setElementPath(WSSConstants.SOAP_11_BODY_PATH);
  policyEnforcer.registerSecurityEvent(signedPartSecurityEvent);
  ContentEncryptedElementSecurityEvent contentEncryptedElementSecurityEvent=new ContentEncryptedElementSecurityEvent((InboundSecurityToken)recipientTokenSecurityEvent.getSecurityToken(),true,protectionOrder);
  contentEncryptedElementSecurityEvent.setElementPath(WSSConstants.SOAP_11_BODY_PATH);
  policyEnforcer.registerSecurityEvent(contentEncryptedElementSecurityEvent);
  OperationSecurityEvent operationSecurityEvent=new OperationSecurityEvent();
  operationSecurityEvent.setOperation(new QName("definitions"));
  try {
    policyEnforcer.registerSecurityEvent(operationSecurityEvent);
    Assert.fail("Exception expected");
  }
 catch (  WSSecurityException e) {
    Assert.assertTrue(e.getCause() instanceof PolicyViolationException);
    Assert.assertEquals(e.getCause().getMessage(),"Policy enforces SAML token with a symmetric key");
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-5 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testPolicyWithSAMLTokenWrongIssuer() throws Exception {
  PolicyEnforcer policyEnforcer=buildAndStartPolicyEngine(samlPolicyString);
  SAMLCallback samlCallback=new SAMLCallback();
  samlCallback.setSamlVersion(Version.SAML_20);
  samlCallback.setIssuer("http://initiatorTokenIssuer.com");
  SubjectBean subjectBean=new SubjectBean();
  samlCallback.setSubject(subjectBean);
  List<AttributeStatementBean> attributeStatementBeans=new ArrayList<>();
  List<AttributeBean> attributeBeans=new ArrayList<>();
  List attributeValues=new ArrayList<>();
  attributeValues.add("test@example.com");
  attributeBeans.add(new AttributeBean("email","http://schemas.xmlsoap.org/ws/2005/05/identity/claims/email",attributeValues));
  attributeValues.clear();
  attributeValues.add("Proper");
  attributeBeans.add(new AttributeBean("surname","http://schemas.xmlsoap.org/ws/2005/05/identity/claims/surname",attributeValues));
  attributeStatementBeans.add(new AttributeStatementBean(subjectBean,attributeBeans));
  samlCallback.setAttributeStatementData(attributeStatementBeans);
  SamlAssertionWrapper samlAssertionWrapper=createSamlAssertionWrapper(samlCallback);
  SamlTokenSecurityEvent initiatorTokenSecurityEvent=new SamlTokenSecurityEvent();
  SamlSecurityTokenImpl securityToken=new SamlSecurityTokenImpl(samlAssertionWrapper,getX509Token(WSSecurityTokenConstants.X509V3Token),null,null,WSSecurityTokenConstants.KEYIDENTIFIER_SECURITY_TOKEN_DIRECT_REFERENCE,null);
  securityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_MAIN_SIGNATURE);
  initiatorTokenSecurityEvent.setSecurityToken(securityToken);
  policyEnforcer.registerSecurityEvent(initiatorTokenSecurityEvent);
  SamlTokenSecurityEvent recipientTokenSecurityEvent=new SamlTokenSecurityEvent();
  securityToken=new SamlSecurityTokenImpl(samlAssertionWrapper,getX509Token(WSSecurityTokenConstants.X509V3Token),null,null,WSSecurityTokenConstants.KEYIDENTIFIER_SECURITY_TOKEN_DIRECT_REFERENCE,null);
  securityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_MAIN_ENCRYPTION);
  recipientTokenSecurityEvent.setSecurityToken(securityToken);
  policyEnforcer.registerSecurityEvent(recipientTokenSecurityEvent);
  List<XMLSecurityConstants.ContentType> protectionOrder=new LinkedList<>();
  protectionOrder.add(XMLSecurityConstants.ContentType.SIGNATURE);
  protectionOrder.add(XMLSecurityConstants.ContentType.ENCRYPTION);
  SignedPartSecurityEvent signedPartSecurityEvent=new SignedPartSecurityEvent((InboundSecurityToken)recipientTokenSecurityEvent.getSecurityToken(),true,protectionOrder);
  signedPartSecurityEvent.setElementPath(WSSConstants.SOAP_11_BODY_PATH);
  policyEnforcer.registerSecurityEvent(signedPartSecurityEvent);
  ContentEncryptedElementSecurityEvent contentEncryptedElementSecurityEvent=new ContentEncryptedElementSecurityEvent((InboundSecurityToken)recipientTokenSecurityEvent.getSecurityToken(),true,protectionOrder);
  contentEncryptedElementSecurityEvent.setElementPath(WSSConstants.SOAP_11_BODY_PATH);
  policyEnforcer.registerSecurityEvent(contentEncryptedElementSecurityEvent);
  OperationSecurityEvent operationSecurityEvent=new OperationSecurityEvent();
  operationSecurityEvent.setOperation(new QName("definitions"));
  try {
    policyEnforcer.registerSecurityEvent(operationSecurityEvent);
    Assert.fail("Exception expected");
  }
 catch (  WSSecurityException e) {
    Assert.assertTrue(e.getCause() instanceof PolicyViolationException);
    Assert.assertEquals(e.getCause().getMessage(),"IssuerName in Policy (http://recipientTokenIssuer.com) didn't match with the one in the IssuedToken (http://initiatorTokenIssuer.com)");
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-5 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testPolicyWithSAMLTokenWrongTokenType() throws Exception {
  PolicyEnforcer policyEnforcer=buildAndStartPolicyEngine(samlPolicyString);
  SAMLCallback samlCallback=new SAMLCallback();
  samlCallback.setSamlVersion(Version.SAML_11);
  samlCallback.setIssuer("http://initiatorTokenIssuer.com");
  SubjectBean subjectBean=new SubjectBean();
  samlCallback.setSubject(subjectBean);
  List<AttributeStatementBean> attributeStatementBeans=new ArrayList<>();
  List<AttributeBean> attributeBeans=new ArrayList<>();
  List attributeValues=new ArrayList<>();
  attributeValues.add("test@example.com");
  attributeBeans.add(new AttributeBean("email","http://schemas.xmlsoap.org/ws/2005/05/identity/claims/email",attributeValues));
  attributeValues.clear();
  attributeValues.add("Proper");
  attributeBeans.add(new AttributeBean("surname","http://schemas.xmlsoap.org/ws/2005/05/identity/claims/surname",attributeValues));
  attributeStatementBeans.add(new AttributeStatementBean(subjectBean,attributeBeans));
  samlCallback.setAttributeStatementData(attributeStatementBeans);
  SamlAssertionWrapper samlAssertionWrapper=createSamlAssertionWrapper(samlCallback);
  SamlTokenSecurityEvent initiatorTokenSecurityEvent=new SamlTokenSecurityEvent();
  SamlSecurityTokenImpl securityToken=new SamlSecurityTokenImpl(samlAssertionWrapper,getX509Token(WSSecurityTokenConstants.X509V3Token),null,null,WSSecurityTokenConstants.KEYIDENTIFIER_SECURITY_TOKEN_DIRECT_REFERENCE,null);
  securityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_MAIN_SIGNATURE);
  initiatorTokenSecurityEvent.setSecurityToken(securityToken);
  policyEnforcer.registerSecurityEvent(initiatorTokenSecurityEvent);
  samlCallback.setIssuer("http://recipientTokenIssuer.com");
  samlAssertionWrapper=createSamlAssertionWrapper(samlCallback);
  SamlTokenSecurityEvent recipientTokenSecurityEvent=new SamlTokenSecurityEvent();
  securityToken=new SamlSecurityTokenImpl(samlAssertionWrapper,getX509Token(WSSecurityTokenConstants.X509V3Token),null,null,WSSecurityTokenConstants.KEYIDENTIFIER_SECURITY_TOKEN_DIRECT_REFERENCE,null);
  securityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_MAIN_ENCRYPTION);
  recipientTokenSecurityEvent.setSecurityToken(securityToken);
  policyEnforcer.registerSecurityEvent(recipientTokenSecurityEvent);
  List<XMLSecurityConstants.ContentType> protectionOrder=new LinkedList<>();
  protectionOrder.add(XMLSecurityConstants.ContentType.SIGNATURE);
  protectionOrder.add(XMLSecurityConstants.ContentType.ENCRYPTION);
  SignedPartSecurityEvent signedPartSecurityEvent=new SignedPartSecurityEvent((InboundSecurityToken)recipientTokenSecurityEvent.getSecurityToken(),true,protectionOrder);
  signedPartSecurityEvent.setElementPath(WSSConstants.SOAP_11_BODY_PATH);
  policyEnforcer.registerSecurityEvent(signedPartSecurityEvent);
  ContentEncryptedElementSecurityEvent contentEncryptedElementSecurityEvent=new ContentEncryptedElementSecurityEvent((InboundSecurityToken)recipientTokenSecurityEvent.getSecurityToken(),true,protectionOrder);
  contentEncryptedElementSecurityEvent.setElementPath(WSSConstants.SOAP_11_BODY_PATH);
  policyEnforcer.registerSecurityEvent(contentEncryptedElementSecurityEvent);
  OperationSecurityEvent operationSecurityEvent=new OperationSecurityEvent();
  operationSecurityEvent.setOperation(new QName("definitions"));
  try {
    policyEnforcer.registerSecurityEvent(operationSecurityEvent);
    Assert.fail("Exception expected");
  }
 catch (  WSSecurityException e) {
    Assert.assertTrue(e.getCause() instanceof PolicyViolationException);
    Assert.assertEquals(e.getCause().getMessage(),"Policy enforces SAML V2.0 token but got 1.1");
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-5 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testPolicyWithKerberosTokenWrongTokenType() throws Exception {
  PolicyEnforcer policyEnforcer=buildAndStartPolicyEngine(kerberosPolicyString);
  KerberosTokenSecurityEvent initiatorTokenSecurityEvent=new KerberosTokenSecurityEvent();
  initiatorTokenSecurityEvent.setIssuerName("http://initiatorTokenIssuer.com");
  KerberosServiceSecurityTokenImpl securityToken=new KerberosServiceSecurityTokenImpl(null,null,null,"http://docs.oasisopen.org/wss/oasiswss-kerberos-tokenprofile-1.1#GSS_Kerberosv5_AP_REQ","1",WSSecurityTokenConstants.KEYIDENTIFIER_EMBEDDED_KEY_IDENTIFIER_REF);
  securityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_MAIN_SIGNATURE);
  initiatorTokenSecurityEvent.setSecurityToken(securityToken);
  policyEnforcer.registerSecurityEvent(initiatorTokenSecurityEvent);
  KerberosTokenSecurityEvent recipientTokenSecurityEvent=new KerberosTokenSecurityEvent();
  recipientTokenSecurityEvent.setIssuerName("http://recipientTokenIssuer.com");
  securityToken=new KerberosServiceSecurityTokenImpl(null,null,null,"http://docs.oasisopen.org/wss/oasiswss-kerberos-tokenprofile-1.1#Kerberosv5APREQSHA1","1",WSSecurityTokenConstants.KEYIDENTIFIER_EMBEDDED_KEY_IDENTIFIER_REF);
  securityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_MAIN_ENCRYPTION);
  recipientTokenSecurityEvent.setSecurityToken(securityToken);
  policyEnforcer.registerSecurityEvent(recipientTokenSecurityEvent);
  List<XMLSecurityConstants.ContentType> protectionOrder=new LinkedList<>();
  protectionOrder.add(XMLSecurityConstants.ContentType.SIGNATURE);
  protectionOrder.add(XMLSecurityConstants.ContentType.ENCRYPTION);
  SignedPartSecurityEvent signedPartSecurityEvent=new SignedPartSecurityEvent((InboundSecurityToken)recipientTokenSecurityEvent.getSecurityToken(),true,protectionOrder);
  signedPartSecurityEvent.setElementPath(WSSConstants.SOAP_11_BODY_PATH);
  policyEnforcer.registerSecurityEvent(signedPartSecurityEvent);
  ContentEncryptedElementSecurityEvent contentEncryptedElementSecurityEvent=new ContentEncryptedElementSecurityEvent((InboundSecurityToken)recipientTokenSecurityEvent.getSecurityToken(),true,protectionOrder);
  contentEncryptedElementSecurityEvent.setElementPath(WSSConstants.SOAP_11_BODY_PATH);
  policyEnforcer.registerSecurityEvent(contentEncryptedElementSecurityEvent);
  OperationSecurityEvent operationSecurityEvent=new OperationSecurityEvent();
  operationSecurityEvent.setOperation(new QName("definitions"));
  try {
    policyEnforcer.registerSecurityEvent(operationSecurityEvent);
    Assert.fail("Exception expected");
  }
 catch (  WSSecurityException e) {
    Assert.assertTrue(e.getCause() instanceof PolicyViolationException);
    Assert.assertEquals(e.getCause().getMessage(),"Policy enforces Kerberos token of type http://docs.oasisopen.org/wss/oasiswss-kerberos-tokenprofile-1.1#Kerberosv5APREQSHA1 but got http://docs.oasisopen.org/wss/oasiswss-kerberos-tokenprofile-1.1#GSS_Kerberosv5_AP_REQ");
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.wss4j.policy.stax.test.KerberosTokenTest </h4><pre class="type-8 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testPolicyNegative() throws Exception {
  String policyString="<sp:SymmetricBinding xmlns:sp=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702\" xmlns:sp3=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200802\">\n" + "<wsp:Policy xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\">\n" + "<sp:EncryptionToken>\n"+ "   <wsp:Policy>\n"+ "       <sp:KerberosToken>\n"+ "           <sp:IssuerName>xs:anyURI</sp:IssuerName>\n"+ "           <wsp:Policy xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\">\n"+ "               <sp:WssKerberosV5ApReqToken11/>\n"+ "           </wsp:Policy>\n"+ "       </sp:KerberosToken>\n"+ "   </wsp:Policy>\n"+ "</sp:EncryptionToken>\n"+ "<sp:SignatureToken>\n"+ "   <wsp:Policy>\n"+ "       <sp:KerberosToken>\n"+ "           <sp:IssuerName>xs:anyURI</sp:IssuerName>\n"+ "           <wsp:Policy xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\">\n"+ "               <sp:WssKerberosV5ApReqToken11/>\n"+ "           </wsp:Policy>\n"+ "       </sp:KerberosToken>\n"+ "   </wsp:Policy>\n"+ "</sp:SignatureToken>\n"+ "   <sp:AlgorithmSuite>\n"+ "       <wsp:Policy>\n"+ "           <sp:Basic256/>\n"+ "       </wsp:Policy>\n"+ "   </sp:AlgorithmSuite>\n"+ "</wsp:Policy>\n"+ "</sp:SymmetricBinding>";
  PolicyEnforcer policyEnforcer=buildAndStartPolicyEngine(policyString);
  KerberosTokenSecurityEvent initiatorTokenSecurityEvent=new KerberosTokenSecurityEvent();
  initiatorTokenSecurityEvent.setIssuerName("xs:anyURI");
  KerberosServiceSecurityTokenImpl kerberosServiceSecurityToken=new KerberosServiceSecurityTokenImpl(null,null,null,WSSConstants.NS_GSS_KERBEROS5_AP_REQ,IDGenerator.generateID(null),WSSecurityTokenConstants.KEYIDENTIFIER_THUMBPRINT_IDENTIFIER);
  kerberosServiceSecurityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_MAIN_SIGNATURE);
  initiatorTokenSecurityEvent.setSecurityToken(kerberosServiceSecurityToken);
  policyEnforcer.registerSecurityEvent(initiatorTokenSecurityEvent);
  KerberosTokenSecurityEvent recipientTokenSecurityEvent=new KerberosTokenSecurityEvent();
  recipientTokenSecurityEvent.setIssuerName("xs:anyURI");
  kerberosServiceSecurityToken=new KerberosServiceSecurityTokenImpl(null,null,null,WSSConstants.NS_KERBEROS5_AP_REQ,IDGenerator.generateID(null),WSSecurityTokenConstants.KEYIDENTIFIER_THUMBPRINT_IDENTIFIER);
  kerberosServiceSecurityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_MAIN_ENCRYPTION);
  recipientTokenSecurityEvent.setSecurityToken(kerberosServiceSecurityToken);
  policyEnforcer.registerSecurityEvent(recipientTokenSecurityEvent);
  List<XMLSecurityConstants.ContentType> protectionOrder=new LinkedList<>();
  protectionOrder.add(XMLSecurityConstants.ContentType.SIGNATURE);
  protectionOrder.add(XMLSecurityConstants.ContentType.ENCRYPTION);
  SignedPartSecurityEvent signedPartSecurityEvent=new SignedPartSecurityEvent((InboundSecurityToken)recipientTokenSecurityEvent.getSecurityToken(),true,protectionOrder);
  signedPartSecurityEvent.setElementPath(WSSConstants.SOAP_11_BODY_PATH);
  policyEnforcer.registerSecurityEvent(signedPartSecurityEvent);
  ContentEncryptedElementSecurityEvent contentEncryptedElementSecurityEvent=new ContentEncryptedElementSecurityEvent((InboundSecurityToken)recipientTokenSecurityEvent.getSecurityToken(),true,protectionOrder);
  contentEncryptedElementSecurityEvent.setElementPath(WSSConstants.SOAP_11_BODY_PATH);
  policyEnforcer.registerSecurityEvent(contentEncryptedElementSecurityEvent);
  OperationSecurityEvent operationSecurityEvent=new OperationSecurityEvent();
  operationSecurityEvent.setOperation(new QName("definitions"));
  try {
    policyEnforcer.registerSecurityEvent(operationSecurityEvent);
    Assert.fail("Exception expected");
  }
 catch (  WSSecurityException e) {
    Assert.assertEquals(e.getMessage(),"Policy enforces WssKerberosV5ApReqToken11");
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.wss4j.policy.stax.test.KeyValueTokenTest </h4><pre class="type-8 type-7 type-5 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testPolicyNegative() throws Exception {
  String policyString="<sp:AsymmetricBinding xmlns:sp=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702\" xmlns:sp3=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200802\">\n" + "<wsp:Policy xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\">\n" + "<sp:InitiatorToken>\n"+ "   <wsp:Policy>\n"+ "       <sp:KeyValueToken>\n"+ "           <wsp:Policy xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\">\n"+ "               <sp:RsaKeyValue/>\n"+ "           </wsp:Policy>\n"+ "       </sp:KeyValueToken>\n"+ "   </wsp:Policy>\n"+ "</sp:InitiatorToken>\n"+ "<sp:RecipientToken>\n"+ "   <wsp:Policy>\n"+ "       <sp:KeyValueToken>\n"+ "           <wsp:Policy xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\">\n"+ "               <sp:RsaKeyValue/>\n"+ "           </wsp:Policy>\n"+ "       </sp:KeyValueToken>\n"+ "   </wsp:Policy>\n"+ "</sp:RecipientToken>\n"+ "   <sp:AlgorithmSuite>\n"+ "       <wsp:Policy>\n"+ "           <sp:Basic256/>\n"+ "       </wsp:Policy>\n"+ "   </sp:AlgorithmSuite>\n"+ "</wsp:Policy>\n"+ "</sp:AsymmetricBinding>";
  PolicyEnforcer policyEnforcer=buildAndStartPolicyEngine(policyString);
  KeyValueTokenSecurityEvent initiatorTokenSecurityEvent=new KeyValueTokenSecurityEvent();
  ECKeyValueSecurityTokenImpl securityToken=getECKeyValueSecurityToken();
  securityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_MAIN_SIGNATURE);
  initiatorTokenSecurityEvent.setSecurityToken(securityToken);
  policyEnforcer.registerSecurityEvent(initiatorTokenSecurityEvent);
  KeyValueTokenSecurityEvent recipientTokenSecurityEvent=new KeyValueTokenSecurityEvent();
  securityToken=getECKeyValueSecurityToken();
  securityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_MAIN_ENCRYPTION);
  recipientTokenSecurityEvent.setSecurityToken(securityToken);
  policyEnforcer.registerSecurityEvent(recipientTokenSecurityEvent);
  List<XMLSecurityConstants.ContentType> protectionOrder=new LinkedList<>();
  protectionOrder.add(XMLSecurityConstants.ContentType.SIGNATURE);
  protectionOrder.add(XMLSecurityConstants.ContentType.ENCRYPTION);
  SignedPartSecurityEvent signedPartSecurityEvent=new SignedPartSecurityEvent((InboundSecurityToken)recipientTokenSecurityEvent.getSecurityToken(),true,protectionOrder);
  signedPartSecurityEvent.setElementPath(WSSConstants.SOAP_11_BODY_PATH);
  policyEnforcer.registerSecurityEvent(signedPartSecurityEvent);
  ContentEncryptedElementSecurityEvent contentEncryptedElementSecurityEvent=new ContentEncryptedElementSecurityEvent((InboundSecurityToken)recipientTokenSecurityEvent.getSecurityToken(),true,protectionOrder);
  contentEncryptedElementSecurityEvent.setElementPath(WSSConstants.SOAP_11_BODY_PATH);
  policyEnforcer.registerSecurityEvent(contentEncryptedElementSecurityEvent);
  OperationSecurityEvent operationSecurityEvent=new OperationSecurityEvent();
  operationSecurityEvent.setOperation(new QName("definitions"));
  try {
    policyEnforcer.registerSecurityEvent(operationSecurityEvent);
    Assert.fail("Exception expected");
  }
 catch (  WSSecurityException e) {
    Assert.assertTrue(e.getCause() instanceof PolicyViolationException);
    Assert.assertEquals(e.getCause().getMessage(),"Policy enforces that a RsaKeyValue must be present in the KeyValueToken but we got a ECKeyValueSecurityTokenImpl");
    Assert.assertEquals(e.getFaultCode(),WSSecurityException.INVALID_SECURITY);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.wss4j.policy.stax.test.ProtectionOrderTest </h4><pre class="type-8 type-7 type-5 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testPolicyEncryptBeforeSignNegative() throws Exception {
  String policyString="<sp:AsymmetricBinding  xmlns:sp=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702\">\n" + "   <wsp:Policy xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\">\n" + "   <sp:AlgorithmSuite>\n"+ "       <wsp:Policy>\n"+ "           <sp:Basic256/>\n"+ "       </wsp:Policy>\n"+ "   </sp:AlgorithmSuite>\n"+ "       <sp:EncryptBeforeSigning/>\n"+ "   </wsp:Policy>\n"+ "</sp:AsymmetricBinding>\n";
  PolicyEnforcer policyEnforcer=buildAndStartPolicyEngine(policyString);
  OperationSecurityEvent operationSecurityEvent=new OperationSecurityEvent();
  operationSecurityEvent.setOperation(new QName("definitions"));
  policyEnforcer.registerSecurityEvent(operationSecurityEvent);
  List<XMLSecurityConstants.ContentType> protectionOrder=new LinkedList<>();
  protectionOrder.add(XMLSecurityConstants.ContentType.SIGNATURE);
  protectionOrder.add(XMLSecurityConstants.ContentType.ENCRYPTION);
  EncryptedPartSecurityEvent encryptedPartSecurityEvent=new EncryptedPartSecurityEvent(null,true,protectionOrder);
  encryptedPartSecurityEvent.setElementPath(WSSConstants.SOAP_11_BODY_PATH);
  try {
    policyEnforcer.registerSecurityEvent(encryptedPartSecurityEvent);
    Assert.fail("Exception expected");
  }
 catch (  WSSecurityException e) {
    Assert.assertTrue(e.getCause() instanceof PolicyViolationException);
    Assert.assertEquals(e.getCause().getMessage(),"Policy enforces EncryptBeforeSigning but the /{http://schemas.xmlsoap.org/soap/envelope/}Envelope/{http://schemas.xmlsoap.org/soap/envelope/}Body was signed and then encrypted");
    Assert.assertEquals(e.getFaultCode(),WSSecurityException.INVALID_SECURITY);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-5 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testPolicySignBeforeEncryptNegative() throws Exception {
  String policyString="<sp:AsymmetricBinding  xmlns:sp=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702\">\n" + "   <wsp:Policy xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\">\n" + "   <sp:AlgorithmSuite>\n"+ "       <wsp:Policy>\n"+ "           <sp:Basic256/>\n"+ "       </wsp:Policy>\n"+ "   </sp:AlgorithmSuite>\n"+ "   </wsp:Policy>\n"+ "</sp:AsymmetricBinding>\n";
  PolicyEnforcer policyEnforcer=buildAndStartPolicyEngine(policyString);
  OperationSecurityEvent operationSecurityEvent=new OperationSecurityEvent();
  operationSecurityEvent.setOperation(new QName("definitions"));
  policyEnforcer.registerSecurityEvent(operationSecurityEvent);
  List<XMLSecurityConstants.ContentType> protectionOrder=new LinkedList<>();
  protectionOrder.add(XMLSecurityConstants.ContentType.ENCRYPTION);
  protectionOrder.add(XMLSecurityConstants.ContentType.SIGNATURE);
  SignedPartSecurityEvent signedPartSecurityEvent=new SignedPartSecurityEvent(null,true,protectionOrder);
  signedPartSecurityEvent.setElementPath(WSSConstants.SOAP_11_BODY_PATH);
  try {
    policyEnforcer.registerSecurityEvent(signedPartSecurityEvent);
    Assert.fail("Exception expected");
  }
 catch (  WSSecurityException e) {
    Assert.assertTrue(e.getCause() instanceof PolicyViolationException);
    Assert.assertEquals(e.getCause().getMessage(),"Policy enforces SignBeforeEncrypting but the /{http://schemas.xmlsoap.org/soap/envelope/}Envelope/{http://schemas.xmlsoap.org/soap/envelope/}Body was encrypted and then signed");
    Assert.assertEquals(e.getFaultCode(),WSSecurityException.INVALID_SECURITY);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.wss4j.policy.stax.test.RequiredElementsTest </h4><pre class="type-8 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testPolicyMultipleAssertionEventsNegative() throws Exception {
  String policyString="<sp:RequiredElements xmlns:sp=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702\" xmlns:sp3=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200802\">\n" + "<sp:XPath xmlns:b=\"http://example.org\">/b:a</sp:XPath>\n" + "</sp:RequiredElements>";
  PolicyEnforcer policyEnforcer=buildAndStartPolicyEngine(policyString);
  OperationSecurityEvent operationSecurityEvent=new OperationSecurityEvent();
  operationSecurityEvent.setOperation(new QName("definitions"));
  policyEnforcer.registerSecurityEvent(operationSecurityEvent);
  RequiredElementSecurityEvent requiredElementSecurityEvent=new RequiredElementSecurityEvent();
  requiredElementSecurityEvent.setElementPath(WSSConstants.SOAP_11_BODY_PATH);
  policyEnforcer.registerSecurityEvent(requiredElementSecurityEvent);
  try {
    policyEnforcer.doFinal();
    Assert.fail("Exception expected");
  }
 catch (  WSSPolicyException e) {
    Assert.assertEquals(e.getMessage(),"Element /{http://example.org}a must be present");
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.wss4j.policy.stax.test.RequiredPartsTest </h4><pre class="type-8 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testPolicyMultipleAssertionEventsNegative() throws Exception {
  String policyString="<sp:RequiredParts xmlns:sp=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702\" xmlns:sp3=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200802\">\n" + "<sp:Header Name=\"a\" Namespace=\"http://example.org\"/>\n" + "</sp:RequiredParts>";
  PolicyEnforcer policyEnforcer=buildAndStartPolicyEngine(policyString);
  RequiredPartSecurityEvent requiredPartSecurityEvent=new RequiredPartSecurityEvent();
  List<QName> headerPath=new ArrayList<>();
  headerPath.addAll(WSSConstants.SOAP_11_HEADER_PATH);
  headerPath.add(new QName("http://example.org","b"));
  requiredPartSecurityEvent.setElementPath(headerPath);
  policyEnforcer.registerSecurityEvent(requiredPartSecurityEvent);
  OperationSecurityEvent operationSecurityEvent=new OperationSecurityEvent();
  operationSecurityEvent.setOperation(new QName("definitions"));
  try {
    policyEnforcer.registerSecurityEvent(operationSecurityEvent);
    Assert.fail("Exception expected");
  }
 catch (  WSSecurityException e) {
    Assert.assertEquals(e.getMessage(),"Element {http://example.org}a must be present");
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.wss4j.policy.stax.test.SamlTokenTest </h4><pre class="type-8 type-7 type-5 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testPolicyNegative() throws Exception {
  String policyString="<sp:AsymmetricBinding xmlns:sp=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702\" xmlns:sp3=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200802\">\n" + "<wsp:Policy xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\">\n" + "<sp:InitiatorToken>\n"+ "   <wsp:Policy>\n"+ "       <sp:SamlToken>\n"+ "           <sp:IssuerName>xs:anyURI</sp:IssuerName>\n"+ "           <wsp:Policy xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\">\n"+ "               <sp:WssSamlV20Token11/>\n"+ "           </wsp:Policy>\n"+ "       </sp:SamlToken>\n"+ "   </wsp:Policy>\n"+ "</sp:InitiatorToken>\n"+ "<sp:RecipientToken>\n"+ "   <wsp:Policy>\n"+ "       <sp:SamlToken>\n"+ "           <sp:IssuerName>xs:anyURI</sp:IssuerName>\n"+ "           <wsp:Policy xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\">\n"+ "               <sp:WssSamlV20Token11/>\n"+ "           </wsp:Policy>\n"+ "       </sp:SamlToken>\n"+ "   </wsp:Policy>\n"+ "</sp:RecipientToken>\n"+ "   <sp:AlgorithmSuite>\n"+ "       <wsp:Policy>\n"+ "           <sp:Basic256/>\n"+ "       </wsp:Policy>\n"+ "   </sp:AlgorithmSuite>\n"+ "</wsp:Policy>\n"+ "</sp:AsymmetricBinding>";
  PolicyEnforcer policyEnforcer=buildAndStartPolicyEngine(policyString);
  SAMLCallback samlCallback=new SAMLCallback();
  samlCallback.setSamlVersion(Version.SAML_20);
  samlCallback.setIssuer("xs:anyURI");
  SubjectBean subjectBean=new SubjectBean();
  samlCallback.setSubject(subjectBean);
  SamlAssertionWrapper samlAssertionWrapper=createSamlAssertionWrapper(samlCallback);
  SamlTokenSecurityEvent initiatorTokenSecurityEvent=new SamlTokenSecurityEvent();
  SamlSecurityTokenImpl securityToken=new SamlSecurityTokenImpl(samlAssertionWrapper,getX509Token(WSSecurityTokenConstants.X509V3Token),null,null,WSSecurityTokenConstants.KEYIDENTIFIER_SECURITY_TOKEN_DIRECT_REFERENCE,null);
  securityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_MAIN_SIGNATURE);
  initiatorTokenSecurityEvent.setSecurityToken(securityToken);
  policyEnforcer.registerSecurityEvent(initiatorTokenSecurityEvent);
  samlCallback.setIssuer("xs:otherURI");
  samlAssertionWrapper=createSamlAssertionWrapper(samlCallback);
  SamlTokenSecurityEvent recipientTokenSecurityEvent=new SamlTokenSecurityEvent();
  securityToken=new SamlSecurityTokenImpl(samlAssertionWrapper,getX509Token(WSSecurityTokenConstants.X509V3Token),null,null,WSSecurityTokenConstants.KEYIDENTIFIER_SECURITY_TOKEN_DIRECT_REFERENCE,null);
  securityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_MAIN_ENCRYPTION);
  recipientTokenSecurityEvent.setSecurityToken(securityToken);
  policyEnforcer.registerSecurityEvent(recipientTokenSecurityEvent);
  List<XMLSecurityConstants.ContentType> protectionOrder=new LinkedList<>();
  protectionOrder.add(XMLSecurityConstants.ContentType.SIGNATURE);
  protectionOrder.add(XMLSecurityConstants.ContentType.ENCRYPTION);
  SignedPartSecurityEvent signedPartSecurityEvent=new SignedPartSecurityEvent((InboundSecurityToken)recipientTokenSecurityEvent.getSecurityToken(),true,protectionOrder);
  signedPartSecurityEvent.setElementPath(WSSConstants.SOAP_11_BODY_PATH);
  policyEnforcer.registerSecurityEvent(signedPartSecurityEvent);
  ContentEncryptedElementSecurityEvent contentEncryptedElementSecurityEvent=new ContentEncryptedElementSecurityEvent((InboundSecurityToken)recipientTokenSecurityEvent.getSecurityToken(),true,protectionOrder);
  contentEncryptedElementSecurityEvent.setElementPath(WSSConstants.SOAP_11_BODY_PATH);
  policyEnforcer.registerSecurityEvent(contentEncryptedElementSecurityEvent);
  OperationSecurityEvent operationSecurityEvent=new OperationSecurityEvent();
  operationSecurityEvent.setOperation(new QName("definitions"));
  try {
    policyEnforcer.registerSecurityEvent(operationSecurityEvent);
    Assert.fail("Exception expected");
  }
 catch (  WSSecurityException e) {
    Assert.assertTrue(e.getCause() instanceof PolicyViolationException);
    Assert.assertEquals(e.getCause().getMessage(),"IssuerName in Policy (xs:anyURI) didn't match with the one in the SamlToken (xs:otherURI)");
    Assert.assertEquals(e.getFaultCode(),WSSecurityException.INVALID_SECURITY);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.wss4j.policy.stax.test.SecureConversationTokenTest </h4><pre class="type-8 type-7 type-5 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testPolicyNegative() throws Exception {
  String policyString="<sp:SymmetricBinding xmlns:sp=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702\" xmlns:sp3=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200802\">\n" + "<wsp:Policy xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\">\n" + "<sp:EncryptionToken>\n"+ "   <wsp:Policy>\n"+ "       <sp:SecureConversationToken>\n"+ "           <sp:IssuerName>xs:anyURI</sp:IssuerName>\n"+ "           <wsp:Policy xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\">\n"+ "               <sp:RequireExternalUriReference/>\n"+ "           </wsp:Policy>\n"+ "       </sp:SecureConversationToken>\n"+ "   </wsp:Policy>\n"+ "</sp:EncryptionToken>\n"+ "<sp:SignatureToken>\n"+ "   <wsp:Policy>\n"+ "       <sp:SecureConversationToken>\n"+ "           <sp:IssuerName>xs:anyURI</sp:IssuerName>\n"+ "           <wsp:Policy xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\">\n"+ "               <sp:RequireExternalUriReference/>\n"+ "           </wsp:Policy>\n"+ "       </sp:SecureConversationToken>\n"+ "   </wsp:Policy>\n"+ "</sp:SignatureToken>\n"+ "   <sp:AlgorithmSuite>\n"+ "       <wsp:Policy>\n"+ "           <sp:Basic256/>\n"+ "       </wsp:Policy>\n"+ "   </sp:AlgorithmSuite>\n"+ "</wsp:Policy>\n"+ "</sp:SymmetricBinding>";
  PolicyEnforcer policyEnforcer=buildAndStartPolicyEngine(policyString);
  SecurityContextTokenSecurityEvent initiatorTokenSecurityEvent=new SecurityContextTokenSecurityEvent();
  initiatorTokenSecurityEvent.setIssuerName("sss");
  initiatorTokenSecurityEvent.setExternalUriRef(true);
  InboundSecurityToken securityToken=getX509Token(WSSecurityTokenConstants.X509V3Token);
  securityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_MAIN_SIGNATURE);
  initiatorTokenSecurityEvent.setSecurityToken(securityToken);
  policyEnforcer.registerSecurityEvent(initiatorTokenSecurityEvent);
  SecurityContextTokenSecurityEvent recipientTokenSecurityEvent=new SecurityContextTokenSecurityEvent();
  recipientTokenSecurityEvent.setIssuerName("sss");
  recipientTokenSecurityEvent.setExternalUriRef(true);
  securityToken=getX509Token(WSSecurityTokenConstants.X509V3Token);
  securityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_MAIN_ENCRYPTION);
  initiatorTokenSecurityEvent.setSecurityToken(securityToken);
  policyEnforcer.registerSecurityEvent(recipientTokenSecurityEvent);
  List<XMLSecurityConstants.ContentType> protectionOrder=new LinkedList<>();
  protectionOrder.add(XMLSecurityConstants.ContentType.SIGNATURE);
  protectionOrder.add(XMLSecurityConstants.ContentType.ENCRYPTION);
  SignedPartSecurityEvent signedPartSecurityEvent=new SignedPartSecurityEvent((InboundSecurityToken)recipientTokenSecurityEvent.getSecurityToken(),true,protectionOrder);
  signedPartSecurityEvent.setElementPath(WSSConstants.SOAP_11_BODY_PATH);
  policyEnforcer.registerSecurityEvent(signedPartSecurityEvent);
  ContentEncryptedElementSecurityEvent contentEncryptedElementSecurityEvent=new ContentEncryptedElementSecurityEvent((InboundSecurityToken)recipientTokenSecurityEvent.getSecurityToken(),true,protectionOrder);
  contentEncryptedElementSecurityEvent.setElementPath(WSSConstants.SOAP_11_BODY_PATH);
  policyEnforcer.registerSecurityEvent(contentEncryptedElementSecurityEvent);
  OperationSecurityEvent operationSecurityEvent=new OperationSecurityEvent();
  operationSecurityEvent.setOperation(new QName("definitions"));
  try {
    policyEnforcer.registerSecurityEvent(operationSecurityEvent);
    Assert.fail("Exception expected");
  }
 catch (  WSSecurityException e) {
    Assert.assertTrue(e.getCause() instanceof PolicyViolationException);
    Assert.assertEquals(e.getCause().getMessage(),"IssuerName in Policy (xs:anyURI) didn't match with the one in the SecurityContextToken (sss)");
    Assert.assertEquals(e.getFaultCode(),WSSecurityException.INVALID_SECURITY);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.wss4j.policy.stax.test.SecurityContextTokenTest </h4><pre class="type-8 type-7 type-5 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testPolicyNegative() throws Exception {
  String policyString="<sp:SymmetricBinding xmlns:sp=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702\" xmlns:sp3=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200802\">\n" + "<wsp:Policy xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\">\n" + "<sp:EncryptionToken>\n"+ "   <wsp:Policy>\n"+ "       <sp:SecurityContextToken>\n"+ "           <sp:IssuerName>xs:anyURI</sp:IssuerName>\n"+ "           <wsp:Policy xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\">\n"+ "               <sp:RequireExternalUriReference/>\n"+ "           </wsp:Policy>\n"+ "       </sp:SecurityContextToken>\n"+ "   </wsp:Policy>\n"+ "</sp:EncryptionToken>\n"+ "<sp:SignatureToken>\n"+ "   <wsp:Policy>\n"+ "       <sp:SecurityContextToken>\n"+ "           <sp:IssuerName>xs:anyURI</sp:IssuerName>\n"+ "           <wsp:Policy xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\">\n"+ "               <sp:RequireExternalUriReference/>\n"+ "           </wsp:Policy>\n"+ "       </sp:SecurityContextToken>\n"+ "   </wsp:Policy>\n"+ "</sp:SignatureToken>\n"+ "   <sp:AlgorithmSuite>\n"+ "       <wsp:Policy>\n"+ "           <sp:Basic256/>\n"+ "       </wsp:Policy>\n"+ "   </sp:AlgorithmSuite>\n"+ "</wsp:Policy>\n"+ "</sp:SymmetricBinding>";
  PolicyEnforcer policyEnforcer=buildAndStartPolicyEngine(policyString);
  SecurityContextTokenSecurityEvent initiatorTokenSecurityEvent=new SecurityContextTokenSecurityEvent();
  initiatorTokenSecurityEvent.setIssuerName("sss");
  initiatorTokenSecurityEvent.setExternalUriRef(true);
  X509SecurityTokenImpl securityToken=getX509Token(WSSecurityTokenConstants.X509V3Token);
  securityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_MAIN_SIGNATURE);
  initiatorTokenSecurityEvent.setSecurityToken(securityToken);
  policyEnforcer.registerSecurityEvent(initiatorTokenSecurityEvent);
  SecurityContextTokenSecurityEvent recipientTokenSecurityEvent=new SecurityContextTokenSecurityEvent();
  recipientTokenSecurityEvent.setIssuerName("sss");
  recipientTokenSecurityEvent.setExternalUriRef(true);
  securityToken=getX509Token(WSSecurityTokenConstants.X509V3Token);
  securityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_MAIN_ENCRYPTION);
  recipientTokenSecurityEvent.setSecurityToken(securityToken);
  policyEnforcer.registerSecurityEvent(recipientTokenSecurityEvent);
  List<XMLSecurityConstants.ContentType> protectionOrder=new LinkedList<>();
  protectionOrder.add(XMLSecurityConstants.ContentType.SIGNATURE);
  protectionOrder.add(XMLSecurityConstants.ContentType.ENCRYPTION);
  SignedPartSecurityEvent signedPartSecurityEvent=new SignedPartSecurityEvent((InboundSecurityToken)recipientTokenSecurityEvent.getSecurityToken(),true,protectionOrder);
  signedPartSecurityEvent.setElementPath(WSSConstants.SOAP_11_BODY_PATH);
  policyEnforcer.registerSecurityEvent(signedPartSecurityEvent);
  ContentEncryptedElementSecurityEvent contentEncryptedElementSecurityEvent=new ContentEncryptedElementSecurityEvent((InboundSecurityToken)recipientTokenSecurityEvent.getSecurityToken(),true,protectionOrder);
  contentEncryptedElementSecurityEvent.setElementPath(WSSConstants.SOAP_11_BODY_PATH);
  policyEnforcer.registerSecurityEvent(contentEncryptedElementSecurityEvent);
  OperationSecurityEvent operationSecurityEvent=new OperationSecurityEvent();
  operationSecurityEvent.setOperation(new QName("definitions"));
  try {
    policyEnforcer.registerSecurityEvent(operationSecurityEvent);
    Assert.fail("Exception expected");
  }
 catch (  WSSecurityException e) {
    Assert.assertTrue(e.getCause() instanceof PolicyViolationException);
    Assert.assertEquals(e.getCause().getMessage(),"IssuerName in Policy (xs:anyURI) didn't match with the one in the SecurityContextToken (sss)");
    Assert.assertEquals(e.getFaultCode(),WSSecurityException.INVALID_SECURITY);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.wss4j.policy.stax.test.SignedElementsTest </h4><pre class="type-8 type-7 type-5 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testPolicyMultipleAssertionEventsNegative() throws Exception {
  String policyString="<sp:SignedElements xmlns:sp=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702\" xmlns:sp3=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200802\">\n" + "<sp:XPath xmlns:b=\"http://example.org\">/b:a</sp:XPath>\n" + "</sp:SignedElements>";
  PolicyEnforcer policyEnforcer=buildAndStartPolicyEngine(policyString);
  OperationSecurityEvent operationSecurityEvent=new OperationSecurityEvent();
  operationSecurityEvent.setOperation(new QName("definitions"));
  policyEnforcer.registerSecurityEvent(operationSecurityEvent);
  List<XMLSecurityConstants.ContentType> protectionOrder=new LinkedList<>();
  protectionOrder.add(XMLSecurityConstants.ContentType.SIGNATURE);
  protectionOrder.add(XMLSecurityConstants.ContentType.ENCRYPTION);
  SignedElementSecurityEvent signedElementSecurityEvent=new SignedElementSecurityEvent(null,true,protectionOrder);
  signedElementSecurityEvent.setElementPath(WSSConstants.SOAP_11_BODY_PATH);
  policyEnforcer.registerSecurityEvent(signedElementSecurityEvent);
  signedElementSecurityEvent=new SignedElementSecurityEvent(null,false,null);
  List<QName> headerPath=new ArrayList<>();
  headerPath.add(new QName("http://example.org","a"));
  signedElementSecurityEvent.setElementPath(headerPath);
  try {
    policyEnforcer.registerSecurityEvent(signedElementSecurityEvent);
    Assert.fail("Exception expected");
  }
 catch (  WSSecurityException e) {
    Assert.assertTrue(e.getCause() instanceof PolicyViolationException);
    Assert.assertEquals(e.getCause().getMessage(),"Element /{http://example.org}a must be signed");
    Assert.assertEquals(e.getFaultCode(),WSSecurityException.INVALID_SECURITY);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.wss4j.policy.stax.test.SignedPartsTest </h4><pre class="type-8 type-7 type-5 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testPolicyMultipleAssertionEventsNegative() throws Exception {
  String policyString="<sp:SignedParts xmlns:sp=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702\" xmlns:sp3=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200802\">\n" + "<sp:Body/>\n" + "<sp:Header Name=\"a\" Namespace=\"http://example.org\"/>\n"+ "<sp:Attachments>\n"+ "<sp3:ContentSignatureTransform/>\n"+ "<sp3:AttachmentCompleteSignatureTransform/>\n"+ "</sp:Attachments>\n"+ "</sp:SignedParts>";
  PolicyEnforcer policyEnforcer=buildAndStartPolicyEngine(policyString);
  OperationSecurityEvent operationSecurityEvent=new OperationSecurityEvent();
  operationSecurityEvent.setOperation(new QName("definitions"));
  policyEnforcer.registerSecurityEvent(operationSecurityEvent);
  List<XMLSecurityConstants.ContentType> protectionOrder=new LinkedList<>();
  protectionOrder.add(XMLSecurityConstants.ContentType.SIGNATURE);
  protectionOrder.add(XMLSecurityConstants.ContentType.ENCRYPTION);
  SignedPartSecurityEvent signedPartSecurityEvent=new SignedPartSecurityEvent(null,true,protectionOrder);
  signedPartSecurityEvent.setElementPath(WSSConstants.SOAP_11_BODY_PATH);
  policyEnforcer.registerSecurityEvent(signedPartSecurityEvent);
  signedPartSecurityEvent=new SignedPartSecurityEvent(null,false,null);
  List<QName> headerPath=new ArrayList<>();
  headerPath.addAll(WSSConstants.SOAP_11_HEADER_PATH);
  headerPath.add(new QName("http://example.org","a"));
  signedPartSecurityEvent.setElementPath(headerPath);
  try {
    policyEnforcer.registerSecurityEvent(signedPartSecurityEvent);
    Assert.fail("Exception expected");
  }
 catch (  WSSecurityException e) {
    Assert.assertTrue(e.getCause() instanceof PolicyViolationException);
    Assert.assertEquals(e.getCause().getMessage(),"Element /{http://schemas.xmlsoap.org/soap/envelope/}Envelope/{http://schemas.xmlsoap.org/soap/envelope/}Header/{http://example.org}a must be signed");
    Assert.assertEquals(e.getFaultCode(),WSSecurityException.INVALID_SECURITY);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-5 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testPolicyWildcardHeaderNegative() throws Exception {
  String policyString="<sp:SignedParts xmlns:sp=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702\" xmlns:sp3=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200802\">\n" + "<sp:Body/>\n" + "<sp:Header Namespace=\"http://example.org\"/>\n"+ "<sp:Attachments>\n"+ "<sp3:ContentSignatureTransform/>\n"+ "<sp3:AttachmentCompleteSignatureTransform/>\n"+ "</sp:Attachments>\n"+ "</sp:SignedParts>";
  PolicyEnforcer policyEnforcer=buildAndStartPolicyEngine(policyString);
  OperationSecurityEvent operationSecurityEvent=new OperationSecurityEvent();
  operationSecurityEvent.setOperation(new QName("definitions"));
  policyEnforcer.registerSecurityEvent(operationSecurityEvent);
  List<XMLSecurityConstants.ContentType> protectionOrder=new LinkedList<>();
  protectionOrder.add(XMLSecurityConstants.ContentType.SIGNATURE);
  protectionOrder.add(XMLSecurityConstants.ContentType.ENCRYPTION);
  SignedPartSecurityEvent signedPartSecurityEvent=new SignedPartSecurityEvent(null,true,protectionOrder);
  signedPartSecurityEvent.setElementPath(WSSConstants.SOAP_11_BODY_PATH);
  policyEnforcer.registerSecurityEvent(signedPartSecurityEvent);
  signedPartSecurityEvent=new SignedPartSecurityEvent(null,false,null);
  List<QName> headerPath=new ArrayList<>();
  headerPath.addAll(WSSConstants.SOAP_11_HEADER_PATH);
  headerPath.add(new QName("http://example.org","a"));
  signedPartSecurityEvent.setElementPath(headerPath);
  try {
    policyEnforcer.registerSecurityEvent(signedPartSecurityEvent);
    Assert.fail("Exception expected");
  }
 catch (  WSSecurityException e) {
    Assert.assertTrue(e.getCause() instanceof PolicyViolationException);
    Assert.assertEquals(e.getCause().getMessage(),"Element /{http://schemas.xmlsoap.org/soap/envelope/}Envelope/{http://schemas.xmlsoap.org/soap/envelope/}Header/{http://example.org}a must be signed");
    Assert.assertEquals(e.getFaultCode(),WSSecurityException.INVALID_SECURITY);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.wss4j.policy.stax.test.SupportingTokensTest </h4><pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testSecurityContextTokenSupportingTokenPolicyAdditionalTokenNegative() throws Exception {
  String policyString="<sp:SupportingTokens xmlns:sp=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702\" xmlns:sp3=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200802\">\n" + "<wsp:Policy xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\">\n" + "       <sp:SecurityContextToken>\n"+ "           <sp:IssuerName>CN=transmitter,OU=swssf,C=CH</sp:IssuerName>\n"+ "           <wsp:Policy/>\n"+ "       </sp:SecurityContextToken>\n"+ "   </wsp:Policy>\n"+ "</sp:SupportingTokens>";
  PolicyEnforcer policyEnforcer=buildAndStartPolicyEngine(policyString);
  SecurityContextTokenSecurityEvent tokenSecurityEvent=new SecurityContextTokenSecurityEvent();
  tokenSecurityEvent.setIssuerName("test");
  X509SecurityTokenImpl x509SecurityToken=getX509Token(WSSecurityTokenConstants.X509V3Token);
  x509SecurityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_SUPPORTING_TOKENS);
  tokenSecurityEvent.setSecurityToken(x509SecurityToken);
  policyEnforcer.registerSecurityEvent(tokenSecurityEvent);
  tokenSecurityEvent=new SecurityContextTokenSecurityEvent();
  tokenSecurityEvent.setIssuerName("test");
  x509SecurityToken=getX509Token(WSSecurityTokenConstants.X509V3Token);
  x509SecurityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_SUPPORTING_TOKENS);
  tokenSecurityEvent.setSecurityToken(x509SecurityToken);
  policyEnforcer.registerSecurityEvent(tokenSecurityEvent);
  OperationSecurityEvent operationSecurityEvent=new OperationSecurityEvent();
  operationSecurityEvent.setOperation(new QName("definitions"));
  try {
    policyEnforcer.registerSecurityEvent(operationSecurityEvent);
    Assert.fail("Exception expected");
  }
 catch (  WSSecurityException e) {
    Assert.assertTrue(e.getCause() instanceof WSSPolicyException);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testKeyValueTokenSupportingTokenPolicyAdditionalTokenNegative() throws Exception {
  String policyString="<sp:SupportingTokens xmlns:sp=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702\" xmlns:sp3=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200802\">\n" + "<wsp:Policy xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\">\n" + "       <sp:KeyValueToken>\n"+ "           <wsp:Policy xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\">\n"+ "               <sp:RsaKeyValue/>\n"+ "           </wsp:Policy>\n"+ "       </sp:KeyValueToken>\n"+ "   </wsp:Policy>\n"+ "</sp:SupportingTokens>";
  PolicyEnforcer policyEnforcer=buildAndStartPolicyEngine(policyString);
  KeyValueTokenSecurityEvent tokenSecurityEvent=new KeyValueTokenSecurityEvent();
  DsaKeyValueSecurityTokenImpl dsaKeyValueSecurityToken=getDsaKeyValueSecurityToken();
  dsaKeyValueSecurityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_SUPPORTING_TOKENS);
  tokenSecurityEvent.setSecurityToken(dsaKeyValueSecurityToken);
  policyEnforcer.registerSecurityEvent(tokenSecurityEvent);
  tokenSecurityEvent=new KeyValueTokenSecurityEvent();
  dsaKeyValueSecurityToken=getDsaKeyValueSecurityToken();
  dsaKeyValueSecurityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_SUPPORTING_TOKENS);
  tokenSecurityEvent.setSecurityToken(dsaKeyValueSecurityToken);
  policyEnforcer.registerSecurityEvent(tokenSecurityEvent);
  OperationSecurityEvent operationSecurityEvent=new OperationSecurityEvent();
  operationSecurityEvent.setOperation(new QName("definitions"));
  try {
    policyEnforcer.registerSecurityEvent(operationSecurityEvent);
    Assert.fail("Exception expected");
  }
 catch (  WSSecurityException e) {
    Assert.assertTrue(e.getCause() instanceof WSSPolicyException);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testSamlTokenSupportingTokenPolicyAdditionalTokenNegative() throws Exception {
  String policyString="<sp:SupportingTokens xmlns:sp=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702\" xmlns:sp3=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200802\">\n" + "<wsp:Policy xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\">\n" + "       <sp:SamlToken>\n"+ "           <sp:IssuerName>CN=transmitter,OU=swssf,C=CH</sp:IssuerName>\n"+ "           <wsp:Policy/>\n"+ "       </sp:SamlToken>\n"+ "   </wsp:Policy>\n"+ "</sp:SupportingTokens>";
  PolicyEnforcer policyEnforcer=buildAndStartPolicyEngine(policyString);
  SAMLCallback samlCallback=new SAMLCallback();
  samlCallback.setSamlVersion(Version.SAML_20);
  samlCallback.setIssuer("xs:anyURI");
  SubjectBean subjectBean=new SubjectBean();
  samlCallback.setSubject(subjectBean);
  SamlAssertionWrapper samlAssertionWrapper=createSamlAssertionWrapper(samlCallback);
  SamlTokenSecurityEvent tokenSecurityEvent=new SamlTokenSecurityEvent();
  SamlSecurityTokenImpl samlSecurityToken=new SamlSecurityTokenImpl(samlAssertionWrapper,getX509Token(WSSecurityTokenConstants.X509V3Token),null,null,WSSecurityTokenConstants.KEYIDENTIFIER_SECURITY_TOKEN_DIRECT_REFERENCE,null);
  samlSecurityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_SUPPORTING_TOKENS);
  tokenSecurityEvent.setSecurityToken(samlSecurityToken);
  policyEnforcer.registerSecurityEvent(tokenSecurityEvent);
  tokenSecurityEvent=new SamlTokenSecurityEvent();
  samlSecurityToken=new SamlSecurityTokenImpl(samlAssertionWrapper,getX509Token(WSSecurityTokenConstants.X509V3Token),null,null,WSSecurityTokenConstants.KEYIDENTIFIER_SECURITY_TOKEN_DIRECT_REFERENCE,null);
  samlSecurityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_SUPPORTING_TOKENS);
  tokenSecurityEvent.setSecurityToken(samlSecurityToken);
  policyEnforcer.registerSecurityEvent(tokenSecurityEvent);
  OperationSecurityEvent operationSecurityEvent=new OperationSecurityEvent();
  operationSecurityEvent.setOperation(new QName("definitions"));
  try {
    policyEnforcer.registerSecurityEvent(operationSecurityEvent);
    Assert.fail("Exception expected");
  }
 catch (  WSSecurityException e) {
    Assert.assertTrue(e.getCause() instanceof WSSPolicyException);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testRelTokenSupportingTokenPolicyAdditionalTokenNegative() throws Exception {
  String policyString="<sp:SupportingTokens xmlns:sp=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702\" xmlns:sp3=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200802\">\n" + "<wsp:Policy xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\">\n" + "       <sp:RelToken>\n"+ "           <sp:IssuerName>CN=transmitter,OU=swssf,C=CH</sp:IssuerName>\n"+ "       </sp:RelToken>\n"+ "   </wsp:Policy>\n"+ "</sp:SupportingTokens>";
  PolicyEnforcer policyEnforcer=buildAndStartPolicyEngine(policyString);
  RelTokenSecurityEvent tokenSecurityEvent=new RelTokenSecurityEvent();
  tokenSecurityEvent.setIssuerName("test");
  X509SecurityTokenImpl x509SecurityToken=getX509Token(WSSecurityTokenConstants.X509V3Token);
  x509SecurityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_SUPPORTING_TOKENS);
  tokenSecurityEvent.setSecurityToken(x509SecurityToken);
  policyEnforcer.registerSecurityEvent(tokenSecurityEvent);
  tokenSecurityEvent=new RelTokenSecurityEvent();
  tokenSecurityEvent.setIssuerName("test");
  x509SecurityToken=getX509Token(WSSecurityTokenConstants.X509V3Token);
  x509SecurityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_SUPPORTING_TOKENS);
  tokenSecurityEvent.setSecurityToken(x509SecurityToken);
  policyEnforcer.registerSecurityEvent(tokenSecurityEvent);
  OperationSecurityEvent operationSecurityEvent=new OperationSecurityEvent();
  operationSecurityEvent.setOperation(new QName("definitions"));
  try {
    policyEnforcer.registerSecurityEvent(operationSecurityEvent);
    Assert.fail("Exception expected");
  }
 catch (  WSSecurityException e) {
    Assert.assertTrue(e.getCause() instanceof WSSPolicyException);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testX509SupportingTokenPolicyAdditionalTokenNegative() throws Exception {
  String policyString="<sp:SupportingTokens xmlns:sp=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702\" xmlns:sp3=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200802\">\n" + "<wsp:Policy xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\">\n" + "       <sp:X509Token>\n"+ "           <sp:IssuerName>CN=transmitter,OU=swssf,C=CH</sp:IssuerName>\n"+ "           <wsp:Policy xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\">\n"+ "               <sp:RequireThumbprintReference/>\n"+ "               <sp:WssX509V3Token11/>\n"+ "           </wsp:Policy>\n"+ "       </sp:X509Token>\n"+ "   </wsp:Policy>\n"+ "</sp:SupportingTokens>";
  PolicyEnforcer policyEnforcer=buildAndStartPolicyEngine(policyString);
  X509TokenSecurityEvent x509TokenSecurityEvent=new X509TokenSecurityEvent();
  X509SecurityTokenImpl x509SecurityToken=getX509Token(WSSecurityTokenConstants.X509V1Token);
  x509SecurityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_SUPPORTING_TOKENS);
  x509TokenSecurityEvent.setSecurityToken(x509SecurityToken);
  policyEnforcer.registerSecurityEvent(x509TokenSecurityEvent);
  x509TokenSecurityEvent=new X509TokenSecurityEvent();
  x509SecurityToken=getX509Token(WSSecurityTokenConstants.X509V1Token);
  x509SecurityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_SUPPORTING_TOKENS);
  x509TokenSecurityEvent.setSecurityToken(x509SecurityToken);
  policyEnforcer.registerSecurityEvent(x509TokenSecurityEvent);
  OperationSecurityEvent operationSecurityEvent=new OperationSecurityEvent();
  operationSecurityEvent.setOperation(new QName("definitions"));
  try {
    policyEnforcer.registerSecurityEvent(operationSecurityEvent);
    Assert.fail("Exception expected");
  }
 catch (  WSSecurityException e) {
    Assert.assertTrue(e.getCause() instanceof WSSPolicyException);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testSecureConversationTokenSupportingTokenPolicyAdditionalTokenNegative() throws Exception {
  String policyString="<sp:SupportingTokens xmlns:sp=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702\" xmlns:sp3=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200802\">\n" + "<wsp:Policy xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\">\n" + "       <sp:SecureConversationToken>\n"+ "           <sp:IssuerName>CN=transmitter,OU=swssf,C=CH</sp:IssuerName>\n"+ "           <wsp:Policy/>\n"+ "       </sp:SecureConversationToken>\n"+ "   </wsp:Policy>\n"+ "</sp:SupportingTokens>";
  PolicyEnforcer policyEnforcer=buildAndStartPolicyEngine(policyString);
  SecurityContextTokenSecurityEvent tokenSecurityEvent=new SecurityContextTokenSecurityEvent();
  tokenSecurityEvent.setIssuerName("test");
  X509SecurityTokenImpl x509SecurityToken=getX509Token(WSSecurityTokenConstants.X509V3Token);
  x509SecurityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_SUPPORTING_TOKENS);
  tokenSecurityEvent.setSecurityToken(x509SecurityToken);
  policyEnforcer.registerSecurityEvent(tokenSecurityEvent);
  tokenSecurityEvent=new SecurityContextTokenSecurityEvent();
  tokenSecurityEvent.setIssuerName("test");
  x509SecurityToken=getX509Token(WSSecurityTokenConstants.X509V3Token);
  x509SecurityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_SUPPORTING_TOKENS);
  tokenSecurityEvent.setSecurityToken(x509SecurityToken);
  policyEnforcer.registerSecurityEvent(tokenSecurityEvent);
  OperationSecurityEvent operationSecurityEvent=new OperationSecurityEvent();
  operationSecurityEvent.setOperation(new QName("definitions"));
  try {
    policyEnforcer.registerSecurityEvent(operationSecurityEvent);
    Assert.fail("Exception expected");
  }
 catch (  WSSecurityException e) {
    Assert.assertTrue(e.getCause() instanceof WSSPolicyException);
  }
}

</code></pre>

<br>
<pre class="type-8 type-5 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testSupportingTokenPolicyNegative() throws Exception {
  String policyString="<sp:SupportingTokens xmlns:sp=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702\" xmlns:sp3=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200802\">\n" + "<wsp:Policy xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\">\n" + "       <sp:X509Token>\n"+ "           <sp:IssuerName>CN=transmitter,OU=swssf,C=CH</sp:IssuerName>\n"+ "           <wsp:Policy xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\">\n"+ "               <sp:RequireThumbprintReference/>\n"+ "               <sp:WssX509V3Token11/>\n"+ "           </wsp:Policy>\n"+ "       </sp:X509Token>\n"+ "   </wsp:Policy>\n"+ "</sp:SupportingTokens>";
  PolicyEnforcer policyEnforcer=buildAndStartPolicyEngine(policyString);
  X509TokenSecurityEvent x509TokenSecurityEvent=new X509TokenSecurityEvent();
  X509SecurityTokenImpl x509SecurityToken=getX509Token(WSSecurityTokenConstants.X509V1Token);
  x509SecurityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_SUPPORTING_TOKENS);
  x509TokenSecurityEvent.setSecurityToken(x509SecurityToken);
  policyEnforcer.registerSecurityEvent(x509TokenSecurityEvent);
  OperationSecurityEvent operationSecurityEvent=new OperationSecurityEvent();
  operationSecurityEvent.setOperation(new QName("definitions"));
  try {
    policyEnforcer.registerSecurityEvent(operationSecurityEvent);
    Assert.fail("Exception expected");
  }
 catch (  WSSecurityException e) {
    Assert.assertEquals(e.getMessage(),"X509Certificate Version 3 mismatch; Policy enforces WssX509V3Token11");
    Assert.assertEquals(e.getFaultCode(),WSSecurityException.INVALID_SECURITY);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testKerberosSupportingTokenPolicyAdditionalTokenNegative() throws Exception {
  String policyString="<sp:SupportingTokens xmlns:sp=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702\" xmlns:sp3=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200802\">\n" + "<wsp:Policy xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\">\n" + "       <sp:KerberosToken>\n"+ "           <sp:IssuerName>CN=transmitter,OU=swssf,C=CH</sp:IssuerName>\n"+ "           <wsp:Policy/>\n"+ "       </sp:KerberosToken>\n"+ "   </wsp:Policy>\n"+ "</sp:SupportingTokens>";
  PolicyEnforcer policyEnforcer=buildAndStartPolicyEngine(policyString);
  KerberosTokenSecurityEvent tokenSecurityEvent=new KerberosTokenSecurityEvent();
  tokenSecurityEvent.setIssuerName("test");
  KerberosServiceSecurityTokenImpl kerberosServiceSecurityToken=getKerberosServiceSecurityToken(WSSecurityTokenConstants.KERBEROS_TOKEN);
  kerberosServiceSecurityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_SUPPORTING_TOKENS);
  tokenSecurityEvent.setSecurityToken(kerberosServiceSecurityToken);
  policyEnforcer.registerSecurityEvent(tokenSecurityEvent);
  tokenSecurityEvent=new KerberosTokenSecurityEvent();
  tokenSecurityEvent.setIssuerName("test");
  kerberosServiceSecurityToken=getKerberosServiceSecurityToken(WSSecurityTokenConstants.KERBEROS_TOKEN);
  kerberosServiceSecurityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_SUPPORTING_TOKENS);
  tokenSecurityEvent.setSecurityToken(kerberosServiceSecurityToken);
  policyEnforcer.registerSecurityEvent(tokenSecurityEvent);
  OperationSecurityEvent operationSecurityEvent=new OperationSecurityEvent();
  operationSecurityEvent.setOperation(new QName("definitions"));
  try {
    policyEnforcer.registerSecurityEvent(operationSecurityEvent);
    Assert.fail("Exception expected");
  }
 catch (  WSSecurityException e) {
    Assert.assertTrue(e.getCause() instanceof WSSPolicyException);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testIssuedSupportingTokenPolicyAdditionalTokenNegative() throws Exception {
  String policyString="<sp:SupportingTokens xmlns:sp=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702\" xmlns:sp3=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200802\">\n" + "<wsp:Policy xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\">\n" + "       <sp:IssuedToken>\n"+ "           <sp:IssuerName>CN=transmitter,OU=swssf,C=CH</sp:IssuerName>\n"+ "           <sp:RequestSecurityTokenTemplate/>\n"+ "           <wsp:Policy/>\n"+ "       </sp:IssuedToken>\n"+ "   </wsp:Policy>\n"+ "</sp:SupportingTokens>";
  PolicyEnforcer policyEnforcer=buildAndStartPolicyEngine(policyString);
  SecurityContextTokenSecurityEvent securityContextTokenSecurityEvent=new SecurityContextTokenSecurityEvent();
  securityContextTokenSecurityEvent.setIssuerName("test");
  X509SecurityTokenImpl x509SecurityToken=getX509Token(WSSecurityTokenConstants.X509V3Token);
  x509SecurityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_SUPPORTING_TOKENS);
  securityContextTokenSecurityEvent.setSecurityToken(x509SecurityToken);
  policyEnforcer.registerSecurityEvent(securityContextTokenSecurityEvent);
  securityContextTokenSecurityEvent=new SecurityContextTokenSecurityEvent();
  securityContextTokenSecurityEvent.setIssuerName("test");
  x509SecurityToken=getX509Token(WSSecurityTokenConstants.X509V3Token);
  x509SecurityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_SUPPORTING_TOKENS);
  securityContextTokenSecurityEvent.setSecurityToken(x509SecurityToken);
  policyEnforcer.registerSecurityEvent(securityContextTokenSecurityEvent);
  OperationSecurityEvent operationSecurityEvent=new OperationSecurityEvent();
  operationSecurityEvent.setOperation(new QName("definitions"));
  try {
    policyEnforcer.registerSecurityEvent(operationSecurityEvent);
    Assert.fail("Exception expected");
  }
 catch (  WSSecurityException e) {
    Assert.assertTrue(e.getCause() instanceof WSSPolicyException);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testUsernameSupportingTokenPolicyAdditionalTokenNegative() throws Exception {
  String policyString="<sp:SupportingTokens xmlns:sp=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702\" xmlns:sp3=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200802\">\n" + "<wsp:Policy xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\">\n" + "       <sp:UsernameToken>\n"+ "           <wsp:Policy xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\">\n"+ "               <sp:NoPassword/>\n"+ "           </wsp:Policy>\n"+ "       </sp:UsernameToken>\n"+ "   </wsp:Policy>\n"+ "</sp:SupportingTokens>";
  PolicyEnforcer policyEnforcer=buildAndStartPolicyEngine(policyString);
  UsernameTokenSecurityEvent usernameTokenSecurityEvent=new UsernameTokenSecurityEvent();
  usernameTokenSecurityEvent.setUsernameTokenProfile(WSSConstants.NS_USERNAMETOKEN_PROFILE11);
  UsernameSecurityTokenImpl securityToken=new UsernameSecurityTokenImpl(WSSConstants.UsernameTokenPasswordType.PASSWORD_DIGEST,"username",null,new Date().toString(),null,new byte[10],10L,null,IDGenerator.generateID(null),WSSecurityTokenConstants.KEYIDENTIFIER_SECURITY_TOKEN_DIRECT_REFERENCE);
  securityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_SUPPORTING_TOKENS);
  usernameTokenSecurityEvent.setSecurityToken(securityToken);
  policyEnforcer.registerSecurityEvent(usernameTokenSecurityEvent);
  usernameTokenSecurityEvent=new UsernameTokenSecurityEvent();
  usernameTokenSecurityEvent.setUsernameTokenProfile(WSSConstants.NS_USERNAMETOKEN_PROFILE11);
  securityToken=new UsernameSecurityTokenImpl(WSSConstants.UsernameTokenPasswordType.PASSWORD_DIGEST,"username",null,new Date().toString(),null,new byte[10],10L,null,IDGenerator.generateID(null),WSSecurityTokenConstants.KEYIDENTIFIER_SECURITY_TOKEN_DIRECT_REFERENCE);
  securityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_SUPPORTING_TOKENS);
  usernameTokenSecurityEvent.setSecurityToken(securityToken);
  policyEnforcer.registerSecurityEvent(usernameTokenSecurityEvent);
  OperationSecurityEvent operationSecurityEvent=new OperationSecurityEvent();
  operationSecurityEvent.setOperation(new QName("definitions"));
  try {
    policyEnforcer.registerSecurityEvent(operationSecurityEvent);
    Assert.fail("Exception expected");
  }
 catch (  WSSecurityException e) {
    Assert.assertTrue(e.getCause() instanceof WSSPolicyException);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testSpnegoSupportingTokenPolicyAdditionalTokenNegative() throws Exception {
  String policyString="<sp:SupportingTokens xmlns:sp=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702\" xmlns:sp3=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200802\">\n" + "<wsp:Policy xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\">\n" + "       <sp:SpnegoContextToken>\n"+ "           <sp:IssuerName>CN=transmitter,OU=swssf,C=CH</sp:IssuerName>\n"+ "           <wsp:Policy/>\n"+ "       </sp:SpnegoContextToken>\n"+ "   </wsp:Policy>\n"+ "</sp:SupportingTokens>";
  PolicyEnforcer policyEnforcer=buildAndStartPolicyEngine(policyString);
  SecurityContextTokenSecurityEvent tokenSecurityEvent=new SecurityContextTokenSecurityEvent();
  tokenSecurityEvent.setIssuerName("test");
  X509SecurityTokenImpl x509SecurityToken=getX509Token(WSSecurityTokenConstants.X509V3Token);
  x509SecurityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_SUPPORTING_TOKENS);
  tokenSecurityEvent.setSecurityToken(x509SecurityToken);
  policyEnforcer.registerSecurityEvent(tokenSecurityEvent);
  tokenSecurityEvent=new SecurityContextTokenSecurityEvent();
  tokenSecurityEvent.setIssuerName("test");
  x509SecurityToken=getX509Token(WSSecurityTokenConstants.X509V3Token);
  x509SecurityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_SUPPORTING_TOKENS);
  tokenSecurityEvent.setSecurityToken(x509SecurityToken);
  policyEnforcer.registerSecurityEvent(tokenSecurityEvent);
  OperationSecurityEvent operationSecurityEvent=new OperationSecurityEvent();
  operationSecurityEvent.setOperation(new QName("definitions"));
  try {
    policyEnforcer.registerSecurityEvent(operationSecurityEvent);
    Assert.fail("Exception expected");
  }
 catch (  WSSecurityException e) {
    Assert.assertTrue(e.getCause() instanceof WSSPolicyException);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.wss4j.policy.stax.test.SymmetricBindingTest </h4><pre class="type-8 type-5 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testPolicySignatureNotEncrypted() throws Exception {
  String policyString="<sp:SymmetricBinding xmlns:sp=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702\" xmlns:sp3=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200802\">\n" + "<wsp:Policy xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\">\n" + "   <sp:AlgorithmSuite>\n"+ "       <wsp:Policy>\n"+ "           <sp:Basic256/>\n"+ "       </wsp:Policy>\n"+ "   </sp:AlgorithmSuite>\n"+ "<sp:IncludeTimestamp/>\n"+ "<sp:EncryptSignature/>\n"+ "<sp:ProtectTokens/>\n"+ "<sp:OnlySignEntireHeadersAndBody/>\n"+ "</wsp:Policy>\n"+ "</sp:SymmetricBinding>";
  PolicyEnforcer policyEnforcer=buildAndStartPolicyEngine(policyString);
  TimestampSecurityEvent timestampSecurityEvent=new TimestampSecurityEvent();
  policyEnforcer.registerSecurityEvent(timestampSecurityEvent);
  SecurityContextTokenSecurityEvent initiatorTokenSecurityEvent=new SecurityContextTokenSecurityEvent();
  SecureConversationSecurityTokenImpl securityToken=new SecureConversationSecurityTokenImpl(null,"1",WSSecurityTokenConstants.KEYIDENTIFIER_SECURITY_TOKEN_DIRECT_REFERENCE);
  securityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_MAIN_SIGNATURE);
  initiatorTokenSecurityEvent.setSecurityToken(securityToken);
  policyEnforcer.registerSecurityEvent(initiatorTokenSecurityEvent);
  SecurityContextTokenSecurityEvent recipientTokenSecurityEvent=new SecurityContextTokenSecurityEvent();
  securityToken=new SecureConversationSecurityTokenImpl(null,"1",WSSecurityTokenConstants.KEYIDENTIFIER_SECURITY_TOKEN_DIRECT_REFERENCE);
  securityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_MAIN_ENCRYPTION);
  recipientTokenSecurityEvent.setSecurityToken(securityToken);
  policyEnforcer.registerSecurityEvent(recipientTokenSecurityEvent);
  List<XMLSecurityConstants.ContentType> protectionOrder=new LinkedList<>();
  protectionOrder.add(XMLSecurityConstants.ContentType.SIGNATURE);
  protectionOrder.add(XMLSecurityConstants.ContentType.ENCRYPTION);
  EncryptedElementSecurityEvent encryptedElementSecurityEvent=new EncryptedElementSecurityEvent(null,false,protectionOrder);
  List<QName> headerPath=new ArrayList<>();
  headerPath.addAll(WSSConstants.WSSE_SECURITY_HEADER_PATH);
  headerPath.add(WSSConstants.TAG_dsig_Signature);
  encryptedElementSecurityEvent.setElementPath(headerPath);
  policyEnforcer.registerSecurityEvent(encryptedElementSecurityEvent);
  OperationSecurityEvent operationSecurityEvent=new OperationSecurityEvent();
  operationSecurityEvent.setOperation(new QName("definitions"));
  try {
    policyEnforcer.registerSecurityEvent(operationSecurityEvent);
    Assert.fail("Exception expected");
  }
 catch (  WSSecurityException e) {
    Assert.assertEquals(e.getCause().getMessage(),"Element /{http://schemas.xmlsoap.org/soap/envelope/}Envelope/{http://schemas.xmlsoap.org/soap/envelope/}Header/{http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd}Security/{http://www.w3.org/2000/09/xmldsig#}Signature must be encrypted");
    Assert.assertEquals(e.getFaultCode(),WSSecurityException.INVALID_SECURITY);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-5 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testPolicyWrongProtectionOrder() throws Exception {
  String policyString="<sp:SymmetricBinding xmlns:sp=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702\" xmlns:sp3=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200802\">\n" + "<wsp:Policy xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\">\n" + "   <sp:AlgorithmSuite>\n"+ "       <wsp:Policy>\n"+ "           <sp:Basic256/>\n"+ "       </wsp:Policy>\n"+ "   </sp:AlgorithmSuite>\n"+ "<sp:IncludeTimestamp/>\n"+ "<sp:EncryptBeforeSigning/>\n"+ "<sp:EncryptSignature/>\n"+ "<sp:ProtectTokens/>\n"+ "<sp:OnlySignEntireHeadersAndBody/>\n"+ "</wsp:Policy>\n"+ "</sp:SymmetricBinding>";
  PolicyEnforcer policyEnforcer=buildAndStartPolicyEngine(policyString);
  SecurityContextTokenSecurityEvent SecurityContextTokenSecurityEvent=new SecurityContextTokenSecurityEvent();
  SecureConversationSecurityTokenImpl securityToken=new SecureConversationSecurityTokenImpl(null,"1",WSSecurityTokenConstants.KEYIDENTIFIER_SECURITY_TOKEN_DIRECT_REFERENCE);
  securityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_MAIN_ENCRYPTION);
  SecurityContextTokenSecurityEvent.setSecurityToken(securityToken);
  policyEnforcer.registerSecurityEvent(SecurityContextTokenSecurityEvent);
  List<XMLSecurityConstants.ContentType> protectionOrder=new LinkedList<>();
  protectionOrder.add(XMLSecurityConstants.ContentType.SIGNATURE);
  protectionOrder.add(XMLSecurityConstants.ContentType.ENCRYPTION);
  SignedPartSecurityEvent signedPartSecurityEvent=new SignedPartSecurityEvent(null,true,protectionOrder);
  signedPartSecurityEvent.setElementPath(WSSConstants.SOAP_11_BODY_PATH);
  policyEnforcer.registerSecurityEvent(signedPartSecurityEvent);
  OperationSecurityEvent operationSecurityEvent=new OperationSecurityEvent();
  operationSecurityEvent.setOperation(new QName("definitions"));
  try {
    policyEnforcer.registerSecurityEvent(operationSecurityEvent);
    Assert.fail("Exception expected");
  }
 catch (  WSSecurityException e) {
    Assert.assertTrue(e.getCause() instanceof PolicyViolationException);
    Assert.assertEquals(e.getCause().getMessage(),"Policy enforces EncryptBeforeSigning but the /{http://schemas.xmlsoap.org/soap/envelope/}Envelope/{http://schemas.xmlsoap.org/soap/envelope/}Body was signed and then encrypted");
    Assert.assertEquals(e.getFaultCode(),WSSecurityException.INVALID_SECURITY);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-5 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testPolicyNotWholeBodySigned() throws Exception {
  String policyString="<sp:SymmetricBinding xmlns:sp=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702\" xmlns:sp3=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200802\">\n" + "<wsp:Policy xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\">\n" + "   <sp:AlgorithmSuite>\n"+ "       <wsp:Policy>\n"+ "           <sp:Basic256/>\n"+ "       </wsp:Policy>\n"+ "   </sp:AlgorithmSuite>\n"+ "<sp:IncludeTimestamp/>\n"+ "<sp:EncryptSignature/>\n"+ "<sp:OnlySignEntireHeadersAndBody/>\n"+ "</wsp:Policy>\n"+ "</sp:SymmetricBinding>";
  PolicyEnforcer policyEnforcer=buildAndStartPolicyEngine(policyString);
  TimestampSecurityEvent timestampSecurityEvent=new TimestampSecurityEvent();
  policyEnforcer.registerSecurityEvent(timestampSecurityEvent);
  SecurityContextTokenSecurityEvent initiatorTokenSecurityEvent=new SecurityContextTokenSecurityEvent();
  SecureConversationSecurityTokenImpl securityToken=new SecureConversationSecurityTokenImpl(null,"1",WSSecurityTokenConstants.KEYIDENTIFIER_SECURITY_TOKEN_DIRECT_REFERENCE);
  securityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_MAIN_SIGNATURE);
  initiatorTokenSecurityEvent.setSecurityToken(securityToken);
  policyEnforcer.registerSecurityEvent(initiatorTokenSecurityEvent);
  SecurityContextTokenSecurityEvent recipientTokenSecurityEvent=new SecurityContextTokenSecurityEvent();
  securityToken=new SecureConversationSecurityTokenImpl(null,"1",WSSecurityTokenConstants.KEYIDENTIFIER_SECURITY_TOKEN_DIRECT_REFERENCE);
  securityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_MAIN_ENCRYPTION);
  recipientTokenSecurityEvent.setSecurityToken(securityToken);
  policyEnforcer.registerSecurityEvent(recipientTokenSecurityEvent);
  List<XMLSecurityConstants.ContentType> protectionOrder=new LinkedList<>();
  protectionOrder.add(XMLSecurityConstants.ContentType.SIGNATURE);
  protectionOrder.add(XMLSecurityConstants.ContentType.ENCRYPTION);
  EncryptedElementSecurityEvent encryptedElementSecurityEvent=new EncryptedElementSecurityEvent(null,true,protectionOrder);
  List<QName> headerPath=new ArrayList<>();
  headerPath.addAll(WSSConstants.WSSE_SECURITY_HEADER_PATH);
  headerPath.add(WSSConstants.TAG_dsig_Signature);
  encryptedElementSecurityEvent.setElementPath(headerPath);
  policyEnforcer.registerSecurityEvent(encryptedElementSecurityEvent);
  encryptedElementSecurityEvent=new EncryptedElementSecurityEvent(null,true,protectionOrder);
  headerPath=new ArrayList<>();
  headerPath.addAll(WSSConstants.WSSE_SECURITY_HEADER_PATH);
  headerPath.add(WSSConstants.TAG_WSSE11_SIG_CONF);
  encryptedElementSecurityEvent.setElementPath(headerPath);
  policyEnforcer.registerSecurityEvent(encryptedElementSecurityEvent);
  OperationSecurityEvent operationSecurityEvent=new OperationSecurityEvent();
  operationSecurityEvent.setOperation(new QName("definitions"));
  policyEnforcer.registerSecurityEvent(operationSecurityEvent);
  SignedPartSecurityEvent signedPartSecurityEvent=new SignedPartSecurityEvent(null,true,protectionOrder);
  QName elementName=new QName("http://www.example.com","bodyChildElement");
  signedPartSecurityEvent.setXmlSecEvent(XMLSecEventFactory.createXmlSecStartElement(elementName,null,null));
  List<QName> elementPath=new ArrayList<>();
  elementPath.addAll(WSSConstants.SOAP_11_BODY_PATH);
  elementPath.add(elementName);
  signedPartSecurityEvent.setElementPath(elementPath);
  try {
    policyEnforcer.registerSecurityEvent(signedPartSecurityEvent);
    Assert.fail("Exception expected");
  }
 catch (  WSSecurityException e) {
    Assert.assertTrue(e.getCause() instanceof PolicyViolationException);
    Assert.assertEquals(e.getCause().getMessage(),"OnlySignEntireHeadersAndBody not fulfilled, offending element: " + "/{http://schemas.xmlsoap.org/soap/envelope/}Envelope/{http://schemas.xmlsoap.org/soap/envelope/}Body/{http://www.example.com}bodyChildElement");
    Assert.assertEquals(e.getFaultCode(),WSSecurityException.INVALID_SECURITY);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-5 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testPolicyNotIncludeTimestamp() throws Exception {
  String policyString="<sp:SymmetricBinding xmlns:sp=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702\" xmlns:sp3=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200802\">\n" + "<wsp:Policy xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\">\n" + "   <sp:AlgorithmSuite>\n"+ "       <wsp:Policy>\n"+ "           <sp:Basic256/>\n"+ "       </wsp:Policy>\n"+ "   </sp:AlgorithmSuite>\n"+ "<sp:EncryptSignature/>\n"+ "<sp:ProtectTokens/>\n"+ "<sp:OnlySignEntireHeadersAndBody/>\n"+ "</wsp:Policy>\n"+ "</sp:SymmetricBinding>";
  PolicyEnforcer policyEnforcer=buildAndStartPolicyEngine(policyString);
  SecurityContextTokenSecurityEvent initiatorTokenSecurityEvent=new SecurityContextTokenSecurityEvent();
  SecureConversationSecurityTokenImpl securityToken=new SecureConversationSecurityTokenImpl(null,"1",WSSecurityTokenConstants.KEYIDENTIFIER_SECURITY_TOKEN_DIRECT_REFERENCE);
  securityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_MAIN_SIGNATURE);
  initiatorTokenSecurityEvent.setSecurityToken(securityToken);
  policyEnforcer.registerSecurityEvent(initiatorTokenSecurityEvent);
  SecurityContextTokenSecurityEvent recipientTokenSecurityEvent=new SecurityContextTokenSecurityEvent();
  securityToken=new SecureConversationSecurityTokenImpl(null,"1",WSSecurityTokenConstants.KEYIDENTIFIER_SECURITY_TOKEN_DIRECT_REFERENCE);
  securityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_MAIN_ENCRYPTION);
  recipientTokenSecurityEvent.setSecurityToken(securityToken);
  policyEnforcer.registerSecurityEvent(recipientTokenSecurityEvent);
  TimestampSecurityEvent timestampSecurityEvent=new TimestampSecurityEvent();
  policyEnforcer.registerSecurityEvent(timestampSecurityEvent);
  OperationSecurityEvent operationSecurityEvent=new OperationSecurityEvent();
  operationSecurityEvent.setOperation(new QName("definitions"));
  try {
    policyEnforcer.registerSecurityEvent(operationSecurityEvent);
    Assert.fail("Exception expected");
  }
 catch (  WSSecurityException e) {
    Assert.assertTrue(e.getCause() instanceof PolicyViolationException);
    Assert.assertEquals(e.getCause().getMessage(),"Timestamp must not be present");
    Assert.assertEquals(e.getFaultCode(),WSSecurityException.INVALID_SECURITY);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.wss4j.policy.stax.test.TokenProtectionTest </h4><pre class="type-8 type-7 type-5 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testPolicyElementSignedByOtherSignature() throws Exception {
  String policyString="<sp:AsymmetricBinding xmlns:sp=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702\" xmlns:sp3=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200802\">\n" + "<wsp:Policy xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\">\n" + "   <sp:AlgorithmSuite>\n"+ "       <wsp:Policy>\n"+ "           <sp:Basic256/>\n"+ "       </wsp:Policy>\n"+ "   </sp:AlgorithmSuite>\n"+ "<sp:ProtectTokens/>\n"+ "</wsp:Policy>\n"+ "</sp:AsymmetricBinding>";
  PolicyEnforcer policyEnforcer=buildAndStartPolicyEngine(policyString);
  X509TokenSecurityEvent x509TokenSecurityEvent=new X509TokenSecurityEvent();
  X509SecurityTokenImpl securityToken=getX509Token(WSSecurityTokenConstants.X509V3Token);
  List<QName> path=new ArrayList<>();
  path.addAll(WSSConstants.WSSE_SECURITY_HEADER_PATH);
  path.add(WSSConstants.TAG_WSSE_BINARY_SECURITY_TOKEN);
  securityToken.setElementPath(path);
  securityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_MAIN_SIGNATURE);
  x509TokenSecurityEvent.setSecurityToken(securityToken);
  policyEnforcer.registerSecurityEvent(x509TokenSecurityEvent);
  List<XMLSecurityConstants.ContentType> protectionOrder=new LinkedList<>();
  protectionOrder.add(XMLSecurityConstants.ContentType.SIGNATURE);
  SignedElementSecurityEvent signedElementSecurityEvent=new SignedElementSecurityEvent(getX509Token(WSSecurityTokenConstants.X509V3Token),false,protectionOrder);
  signedElementSecurityEvent.setElementPath(path);
  policyEnforcer.registerSecurityEvent(signedElementSecurityEvent);
  OperationSecurityEvent operationSecurityEvent=new OperationSecurityEvent();
  operationSecurityEvent.setOperation(new QName("definitions"));
  try {
    policyEnforcer.registerSecurityEvent(operationSecurityEvent);
    Assert.fail("Exception expected");
  }
 catch (  WSSecurityException e) {
    Assert.assertTrue(e.getCause() instanceof PolicyViolationException);
    Assert.assertEquals(e.getCause().getMessage(),"Token /{http://schemas.xmlsoap.org/soap/envelope/}Envelope/{http://schemas.xmlsoap.org/soap/envelope/}Header/{http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd}Security/{http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd}BinarySecurityToken must be signed by its signature.");
    Assert.assertEquals(e.getFaultCode(),WSSecurityException.INVALID_SECURITY);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-5 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testPolicyElementNotSigned() throws Exception {
  String policyString="<sp:AsymmetricBinding xmlns:sp=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702\" xmlns:sp3=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200802\">\n" + "<wsp:Policy xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\">\n" + "   <sp:AlgorithmSuite>\n"+ "       <wsp:Policy>\n"+ "           <sp:Basic256/>\n"+ "       </wsp:Policy>\n"+ "   </sp:AlgorithmSuite>\n"+ "<sp:ProtectTokens/>\n"+ "</wsp:Policy>\n"+ "</sp:AsymmetricBinding>";
  PolicyEnforcer policyEnforcer=buildAndStartPolicyEngine(policyString);
  X509TokenSecurityEvent x509TokenSecurityEvent=new X509TokenSecurityEvent();
  X509SecurityTokenImpl securityToken=getX509Token(WSSecurityTokenConstants.X509V3Token);
  List<QName> path=new ArrayList<>();
  path.addAll(WSSConstants.WSSE_SECURITY_HEADER_PATH);
  path.add(WSSConstants.TAG_WSSE_BINARY_SECURITY_TOKEN);
  securityToken.setElementPath(path);
  securityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_MAIN_SIGNATURE);
  x509TokenSecurityEvent.setSecurityToken(securityToken);
  policyEnforcer.registerSecurityEvent(x509TokenSecurityEvent);
  List<XMLSecurityConstants.ContentType> protectionOrder=new LinkedList<>();
  protectionOrder.add(XMLSecurityConstants.ContentType.SIGNATURE);
  SignedElementSecurityEvent signedElementSecurityEvent=new SignedElementSecurityEvent(securityToken,false,protectionOrder);
  signedElementSecurityEvent.setElementPath(path);
  policyEnforcer.registerSecurityEvent(signedElementSecurityEvent);
  OperationSecurityEvent operationSecurityEvent=new OperationSecurityEvent();
  operationSecurityEvent.setOperation(new QName("definitions"));
  try {
    policyEnforcer.registerSecurityEvent(operationSecurityEvent);
    Assert.fail("Exception expected");
  }
 catch (  WSSecurityException e) {
    Assert.assertTrue(e.getCause() instanceof PolicyViolationException);
    Assert.assertEquals(e.getCause().getMessage(),"Token /{http://schemas.xmlsoap.org/soap/envelope/}Envelope/{http://schemas.xmlsoap.org/soap/envelope/}Header/{http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd}Security/{http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd}BinarySecurityToken must be signed by its signature.");
    Assert.assertEquals(e.getFaultCode(),WSSecurityException.INVALID_SECURITY);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-5 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testPolicyElementSignedByOtherSignatureReverseSecurityEventOrder() throws Exception {
  String policyString="<sp:AsymmetricBinding xmlns:sp=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702\" xmlns:sp3=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200802\">\n" + "<wsp:Policy xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\">\n" + "   <sp:AlgorithmSuite>\n"+ "       <wsp:Policy>\n"+ "           <sp:Basic256/>\n"+ "       </wsp:Policy>\n"+ "   </sp:AlgorithmSuite>\n"+ "<sp:ProtectTokens/>\n"+ "</wsp:Policy>\n"+ "</sp:AsymmetricBinding>";
  PolicyEnforcer policyEnforcer=buildAndStartPolicyEngine(policyString);
  X509TokenSecurityEvent x509TokenSecurityEvent=new X509TokenSecurityEvent();
  X509SecurityTokenImpl securityToken=getX509Token(WSSecurityTokenConstants.X509V3Token);
  List<QName> path=new ArrayList<>();
  path.addAll(WSSConstants.WSSE_SECURITY_HEADER_PATH);
  path.add(WSSConstants.TAG_WSSE_BINARY_SECURITY_TOKEN);
  securityToken.setElementPath(path);
  securityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_MAIN_SIGNATURE);
  x509TokenSecurityEvent.setSecurityToken(securityToken);
  List<XMLSecurityConstants.ContentType> protectionOrder=new LinkedList<>();
  protectionOrder.add(XMLSecurityConstants.ContentType.SIGNATURE);
  SignedElementSecurityEvent signedElementSecurityEvent=new SignedElementSecurityEvent(getX509Token(WSSecurityTokenConstants.X509V3Token),false,protectionOrder);
  signedElementSecurityEvent.setElementPath(path);
  policyEnforcer.registerSecurityEvent(signedElementSecurityEvent);
  policyEnforcer.registerSecurityEvent(x509TokenSecurityEvent);
  OperationSecurityEvent operationSecurityEvent=new OperationSecurityEvent();
  operationSecurityEvent.setOperation(new QName("definitions"));
  try {
    policyEnforcer.registerSecurityEvent(operationSecurityEvent);
    Assert.fail("Exception expected");
  }
 catch (  WSSecurityException e) {
    Assert.assertTrue(e.getCause() instanceof PolicyViolationException);
    Assert.assertEquals(e.getCause().getMessage(),"Token /{http://schemas.xmlsoap.org/soap/envelope/}Envelope/{http://schemas.xmlsoap.org/soap/envelope/}Header/{http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd}Security/{http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd}BinarySecurityToken must be signed by its signature.");
    Assert.assertEquals(e.getFaultCode(),WSSecurityException.INVALID_SECURITY);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.wss4j.policy.stax.test.TransportBindingIntegrationTest </h4><pre class="type-8 type-7 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testIncludeTimestampPolicyNegativeTest() throws Exception {
  String policyString="<wsp:ExactlyOne xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\" " + "xmlns:sp=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702\">\n" + "            <wsp:All>\n"+ "                <sp:TransportBinding>\n"+ "                    <wsp:Policy>\n"+ "                        <sp:TransportToken>\n"+ "                            <wsp:Policy>\n"+ "                                <sp:HttpsToken>\n"+ "                                    <!--<sp:Issuer>wsa:EndpointReferenceType</sp:Issuer>-->\n"+ "                                    <sp:IssuerName>transmitter</sp:IssuerName>\n"+ "                                    <wsp:Policy>\n"+ "                                        <sp:HttpBasicAuthentication/>\n"+ "                                    </wsp:Policy>\n"+ "                                </sp:HttpsToken>\n"+ "                            </wsp:Policy>\n"+ "                        </sp:TransportToken>\n"+ "                        <sp:AlgorithmSuite>\n"+ "                            <wsp:Policy>\n"+ "                                <sp:Basic256/>\n"+ "                            </wsp:Policy>\n"+ "                        </sp:AlgorithmSuite>\n"+ "                        <sp:Layout>\n"+ "                            <wsp:Policy>\n"+ "                                <sp:Lax/>\n"+ "                            </wsp:Policy>\n"+ "                        </sp:Layout>\n"+ "                        <sp:IncludeTimestamp/>\n"+ "                    </wsp:Policy>\n"+ "                </sp:TransportBinding>\n"+ "                <sp:SignedParts>\n"+ "                    <sp:Body/>\n"+ "                    <sp:Header Name=\"Header1\" Namespace=\"...\"/>\n"+ "                    <sp:Header Namespace=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\"/>\n"+ "                </sp:SignedParts>\n"+ "                <sp:SignedElements>\n"+ "                    <sp:XPath xmlns:wsu=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\">wsu:Created</sp:XPath>\n"+ "                </sp:SignedElements>\n"+ "                <sp:EncryptedParts>\n"+ "                    <sp:Body/>\n"+ "                    <sp:Header Name=\"Header2\" Namespace=\"...\"/>\n"+ "                    <sp:Header Namespace=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\"/>\n"+ "                </sp:EncryptedParts>\n"+ "                <sp:EncryptedElements>\n"+ "                    <sp:XPath xmlns:wsu=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\">wsu:Created</sp:XPath>\n"+ "                </sp:EncryptedElements>\n"+ "                <sp:ContentEncryptedElements>\n"+ "                    <sp:XPath xmlns:wsu=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\">wsu:Expires</sp:XPath>\n"+ "                </sp:ContentEncryptedElements>\n"+ "            </wsp:All>\n"+ "        </wsp:ExactlyOne>";
  WSSSecurityProperties outSecurityProperties=new WSSSecurityProperties();
  outSecurityProperties.setCallbackHandler(new CallbackHandlerImpl());
  outSecurityProperties.setEncryptionUser("receiver");
  outSecurityProperties.loadEncryptionKeystore(this.getClass().getClassLoader().getResource("transmitter.jks"),"default".toCharArray());
  outSecurityProperties.setSignatureUser("transmitter");
  outSecurityProperties.loadSignatureKeyStore(this.getClass().getClassLoader().getResource("transmitter.jks"),"default".toCharArray());
  List<WSSConstants.Action> actions=new ArrayList<>();
  actions.add(WSSConstants.SIGNATURE);
  actions.add(WSSConstants.ENCRYPT);
  outSecurityProperties.setActions(actions);
  InputStream sourceDocument=this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml");
  ByteArrayOutputStream baos=doOutboundSecurity(outSecurityProperties,sourceDocument);
  WSSSecurityProperties inSecurityProperties=new WSSSecurityProperties();
  inSecurityProperties.setCallbackHandler(new CallbackHandlerImpl());
  inSecurityProperties.loadSignatureVerificationKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
  inSecurityProperties.loadDecryptionKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
  PolicyEnforcer policyEnforcer=buildAndStartPolicyEngine(policyString);
  inSecurityProperties.addInputProcessor(new PolicyInputProcessor(policyEnforcer,null));
  HttpsTokenSecurityEvent httpsTokenSecurityEvent=new HttpsTokenSecurityEvent();
  httpsTokenSecurityEvent.setIssuerName("transmitter");
  httpsTokenSecurityEvent.setAuthenticationType(HttpsTokenSecurityEvent.AuthenticationType.HttpBasicAuthentication);
  HttpsSecurityTokenImpl httpsSecurityToken=new HttpsSecurityTokenImpl(true,"transmitter");
  httpsSecurityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_MAIN_SIGNATURE);
  httpsTokenSecurityEvent.setSecurityToken(httpsSecurityToken);
  List<SecurityEvent> securityEventList=new ArrayList<>();
  securityEventList.add(httpsTokenSecurityEvent);
  try {
    Document document=doInboundSecurity(inSecurityProperties,new ByteArrayInputStream(baos.toByteArray()),securityEventList,policyEnforcer);
    Transformer transformer=TransformerFactory.newInstance().newTransformer();
    transformer.transform(new DOMSource(document),new StreamResult(new OutputStream(){
      @Override public void write(      int b) throws IOException {
      }
    }
));
    Assert.fail("Exception expected");
  }
 catch (  XMLStreamException e) {
    Assert.assertTrue(e.getCause() instanceof WSSecurityException);
    Assert.assertEquals(e.getCause().getMessage(),"Element /{http://schemas.xmlsoap.org/soap/envelope/}Envelope/{http://schemas.xmlsoap.org/soap/envelope/}Header/{http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd}Security/{http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd}Timestamp must be present");
    Assert.assertEquals(((WSSecurityException)e.getCause()).getFaultCode(),WSSecurityException.INVALID_SECURITY);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testC14NAlgorithmSuiteNegative() throws Exception {
  String policyString="<wsp:ExactlyOne xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\" " + "xmlns:sp=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702\">\n" + "            <wsp:All>\n"+ "                <sp:TransportBinding>\n"+ "                    <wsp:Policy>\n"+ "                        <sp:TransportToken>\n"+ "                            <wsp:Policy>\n"+ "                                <sp:HttpsToken>\n"+ "                                    <!--<sp:Issuer>wsa:EndpointReferenceType</sp:Issuer>-->\n"+ "                                    <sp:IssuerName>transmitter</sp:IssuerName>\n"+ "                                    <wsp:Policy>\n"+ "                                        <sp:HttpBasicAuthentication/>\n"+ "                                    </wsp:Policy>\n"+ "                                </sp:HttpsToken>\n"+ "                            </wsp:Policy>\n"+ "                        </sp:TransportToken>\n"+ "                        <sp:AlgorithmSuite>\n"+ "                            <wsp:Policy>\n"+ "                                <sp:Basic256/>\n"+ "                            </wsp:Policy>\n"+ "                        </sp:AlgorithmSuite>\n"+ "                        <sp:Layout>\n"+ "                            <wsp:Policy>\n"+ "                                <sp:Lax/>\n"+ "                            </wsp:Policy>\n"+ "                        </sp:Layout>\n"+ "                        <sp:IncludeTimestamp/>\n"+ "                    </wsp:Policy>\n"+ "                </sp:TransportBinding>\n"+ "                <sp:SignedParts>\n"+ "                    <sp:Body/>\n"+ "                    <sp:Header Name=\"Header1\" Namespace=\"...\"/>\n"+ "                    <sp:Header Namespace=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\"/>\n"+ "                </sp:SignedParts>\n"+ "                <sp:SignedElements>\n"+ "                    <sp:XPath xmlns:wsu=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\">wsu:Created</sp:XPath>\n"+ "                </sp:SignedElements>\n"+ "                <sp:EncryptedParts>\n"+ "                    <sp:Body/>\n"+ "                    <sp:Header Name=\"Header2\" Namespace=\"...\"/>\n"+ "                    <sp:Header Namespace=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\"/>\n"+ "                </sp:EncryptedParts>\n"+ "                <sp:EncryptedElements>\n"+ "                    <sp:XPath xmlns:wsu=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\">wsu:Created</sp:XPath>\n"+ "                </sp:EncryptedElements>\n"+ "                <sp:ContentEncryptedElements>\n"+ "                    <sp:XPath xmlns:wsu=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\">wsu:Expires</sp:XPath>\n"+ "                </sp:ContentEncryptedElements>\n"+ "            </wsp:All>\n"+ "        </wsp:ExactlyOne>";
  WSSSecurityProperties outSecurityProperties=new WSSSecurityProperties();
  outSecurityProperties.setCallbackHandler(new CallbackHandlerImpl());
  outSecurityProperties.setEncryptionUser("receiver");
  outSecurityProperties.loadEncryptionKeystore(this.getClass().getClassLoader().getResource("transmitter.jks"),"default".toCharArray());
  outSecurityProperties.setSignatureUser("transmitter");
  outSecurityProperties.loadSignatureKeyStore(this.getClass().getClassLoader().getResource("transmitter.jks"),"default".toCharArray());
  outSecurityProperties.setSignatureCanonicalizationAlgorithm("http://www.w3.org/2006/12/xml-c14n11");
  outSecurityProperties.addSignaturePart(new SecurePart(new QName(WSSConstants.TAG_WSU_TIMESTAMP.getNamespaceURI(),WSSConstants.TAG_WSU_TIMESTAMP.getLocalPart()),SecurePart.Modifier.Element));
  outSecurityProperties.addSignaturePart(new SecurePart(WSSConstants.TAG_SOAP11_BODY,SecurePart.Modifier.Element));
  outSecurityProperties.addEncryptionPart(new SecurePart(new QName(WSSConstants.TAG_WSU_CREATED.getNamespaceURI(),WSSConstants.TAG_WSU_CREATED.getLocalPart()),SecurePart.Modifier.Element));
  outSecurityProperties.addEncryptionPart(new SecurePart(new QName(WSSConstants.TAG_WSU_EXPIRES.getNamespaceURI(),WSSConstants.TAG_WSU_EXPIRES.getLocalPart()),SecurePart.Modifier.Content));
  outSecurityProperties.addEncryptionPart(new SecurePart(WSSConstants.TAG_SOAP11_BODY,SecurePart.Modifier.Content));
  List<WSSConstants.Action> actions=new ArrayList<>();
  actions.add(WSSConstants.TIMESTAMP);
  actions.add(WSSConstants.SIGNATURE);
  actions.add(WSSConstants.ENCRYPT);
  outSecurityProperties.setActions(actions);
  InputStream sourceDocument=this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml");
  ByteArrayOutputStream baos=doOutboundSecurity(outSecurityProperties,sourceDocument);
  WSSSecurityProperties inSecurityProperties=new WSSSecurityProperties();
  inSecurityProperties.setCallbackHandler(new CallbackHandlerImpl());
  inSecurityProperties.loadSignatureVerificationKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
  inSecurityProperties.loadDecryptionKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
  inSecurityProperties.addIgnoreBSPRule(BSPRule.R5404);
  inSecurityProperties.addIgnoreBSPRule(BSPRule.R5423);
  inSecurityProperties.addIgnoreBSPRule(BSPRule.R5412);
  PolicyEnforcer policyEnforcer=buildAndStartPolicyEngine(policyString);
  inSecurityProperties.addInputProcessor(new PolicyInputProcessor(policyEnforcer,null));
  HttpsTokenSecurityEvent httpsTokenSecurityEvent=new HttpsTokenSecurityEvent();
  httpsTokenSecurityEvent.setIssuerName("transmitter");
  httpsTokenSecurityEvent.setAuthenticationType(HttpsTokenSecurityEvent.AuthenticationType.HttpBasicAuthentication);
  HttpsSecurityTokenImpl httpsSecurityToken=new HttpsSecurityTokenImpl(true,"transmitter");
  httpsSecurityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_MAIN_SIGNATURE);
  httpsTokenSecurityEvent.setSecurityToken(httpsSecurityToken);
  List<SecurityEvent> securityEventList=new ArrayList<>();
  securityEventList.add(httpsTokenSecurityEvent);
  try {
    Document document=doInboundSecurity(inSecurityProperties,new ByteArrayInputStream(baos.toByteArray()),securityEventList,policyEnforcer);
    Transformer transformer=TransformerFactory.newInstance().newTransformer();
    transformer.transform(new DOMSource(document),new StreamResult(new OutputStream(){
      @Override public void write(      int b) throws IOException {
      }
    }
));
    Assert.fail("Exception expected");
  }
 catch (  XMLStreamException e) {
    Assert.assertTrue(e.getCause() instanceof WSSecurityException);
    Assert.assertEquals(e.getCause().getMessage(),"C14N algorithm http://www.w3.org/2006/12/xml-c14n11 does not meet policy");
    Assert.assertEquals(((WSSecurityException)e.getCause()).getFaultCode(),WSSecurityException.INVALID_SECURITY);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testHttpsClientAuthenticationPolicyNegative() throws Exception {
  String policyString="<wsp:ExactlyOne xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\" " + "xmlns:sp=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702\">\n" + "            <wsp:All>\n"+ "                <sp:TransportBinding>\n"+ "                    <wsp:Policy>\n"+ "                        <sp:TransportToken>\n"+ "                            <wsp:Policy>\n"+ "                                <sp:HttpsToken>\n"+ "                                    <!--<sp:Issuer>wsa:EndpointReferenceType</sp:Issuer>-->\n"+ "                                    <sp:IssuerName>CN=transmitter,OU=swssf,C=CH</sp:IssuerName>\n"+ "                                    <wsp:Policy>\n"+ "                                        <sp:RequireClientCertificate/>\n"+ "                                    </wsp:Policy>\n"+ "                                </sp:HttpsToken>\n"+ "                            </wsp:Policy>\n"+ "                        </sp:TransportToken>\n"+ "                        <sp:AlgorithmSuite>\n"+ "                            <wsp:Policy>\n"+ "                                <sp:Basic256/>\n"+ "                            </wsp:Policy>\n"+ "                        </sp:AlgorithmSuite>\n"+ "                        <sp:Layout>\n"+ "                            <wsp:Policy>\n"+ "                                <sp:Lax/>\n"+ "                            </wsp:Policy>\n"+ "                        </sp:Layout>\n"+ "                        <sp:IncludeTimestamp/>\n"+ "                    </wsp:Policy>\n"+ "                </sp:TransportBinding>\n"+ "                <sp:SignedParts>\n"+ "                    <sp:Body/>\n"+ "                    <sp:Header Name=\"Header1\" Namespace=\"...\"/>\n"+ "                    <sp:Header Namespace=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\"/>\n"+ "                </sp:SignedParts>\n"+ "                <sp:SignedElements>\n"+ "                    <sp:XPath xmlns:wsu=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\">wsu:Created</sp:XPath>\n"+ "                </sp:SignedElements>\n"+ "                <sp:EncryptedParts>\n"+ "                    <sp:Body/>\n"+ "                    <sp:Header Name=\"Header2\" Namespace=\"...\"/>\n"+ "                    <sp:Header Namespace=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\"/>\n"+ "                </sp:EncryptedParts>\n"+ "                <sp:EncryptedElements>\n"+ "                    <sp:XPath xmlns:wsu=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\">wsu:Created</sp:XPath>\n"+ "                </sp:EncryptedElements>\n"+ "                <sp:ContentEncryptedElements>\n"+ "                    <sp:XPath xmlns:wsu=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\">wsu:Expires</sp:XPath>\n"+ "                </sp:ContentEncryptedElements>\n"+ "                <sp:SignedSupportingTokens>\n"+ "                    <wsp:Policy>\n"+ "                        <sp:UsernameToken sp:IncludeToken=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702/IncludeToken/AlwaysToRecipient\">\n"+ "                            <wsp:Policy>\n"+ "                                <!--<sp:HashPassword/>-->\n"+ "                                <sp:NoPassword/>\n"+ "                                <!--<sp:Created/>\n"+ "                                <sp:Nonce/>-->\n"+ "                            </wsp:Policy>\n"+ "                        </sp:UsernameToken>\n"+ "                    </wsp:Policy>\n"+ "                </sp:SignedSupportingTokens>\n"+ "            </wsp:All>\n"+ "        </wsp:ExactlyOne>";
  WSSSecurityProperties outSecurityProperties=new WSSSecurityProperties();
  outSecurityProperties.setCallbackHandler(new CallbackHandlerImpl());
  outSecurityProperties.setEncryptionUser("receiver");
  outSecurityProperties.loadEncryptionKeystore(this.getClass().getClassLoader().getResource("transmitter.jks"),"default".toCharArray());
  outSecurityProperties.setSignatureUser("transmitter");
  outSecurityProperties.setTokenUser("transmitter");
  outSecurityProperties.setUsernameTokenPasswordType(WSSConstants.UsernameTokenPasswordType.PASSWORD_NONE);
  outSecurityProperties.loadSignatureKeyStore(this.getClass().getClassLoader().getResource("transmitter.jks"),"default".toCharArray());
  outSecurityProperties.addSignaturePart(new SecurePart(WSSConstants.TAG_SOAP11_BODY,SecurePart.Modifier.Element));
  outSecurityProperties.addEncryptionPart(new SecurePart(WSSConstants.TAG_SOAP11_BODY,SecurePart.Modifier.Content));
  List<WSSConstants.Action> actions=new ArrayList<>();
  actions.add(WSSConstants.USERNAMETOKEN);
  actions.add(WSSConstants.TIMESTAMP);
  actions.add(WSSConstants.SIGNATURE);
  actions.add(WSSConstants.ENCRYPT);
  outSecurityProperties.setActions(actions);
  InputStream sourceDocument=this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml");
  ByteArrayOutputStream baos=doOutboundSecurity(outSecurityProperties,sourceDocument);
  WSSSecurityProperties inSecurityProperties=new WSSSecurityProperties();
  inSecurityProperties.setCallbackHandler(new CallbackHandlerImpl());
  inSecurityProperties.loadSignatureVerificationKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
  inSecurityProperties.loadDecryptionKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
  PolicyEnforcer policyEnforcer=buildAndStartPolicyEngine(policyString);
  inSecurityProperties.addInputProcessor(new PolicyInputProcessor(policyEnforcer,null));
  HttpsTokenSecurityEvent httpsTokenSecurityEvent=new HttpsTokenSecurityEvent();
  httpsTokenSecurityEvent.setIssuerName("CN=example,OU=swssf,C=CH");
  httpsTokenSecurityEvent.setAuthenticationType(HttpsTokenSecurityEvent.AuthenticationType.HttpsClientCertificateAuthentication);
  HttpsSecurityTokenImpl httpsSecurityToken=new HttpsSecurityTokenImpl(true,"CN=example,OU=swssf,C=CH");
  httpsSecurityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_MAIN_SIGNATURE);
  httpsTokenSecurityEvent.setSecurityToken(httpsSecurityToken);
  List<SecurityEvent> securityEventList=new ArrayList<>();
  securityEventList.add(httpsTokenSecurityEvent);
  try {
    Document document=doInboundSecurity(inSecurityProperties,new ByteArrayInputStream(baos.toByteArray()),securityEventList,policyEnforcer);
    Transformer transformer=TransformerFactory.newInstance().newTransformer();
    transformer.transform(new DOMSource(document),new StreamResult(new OutputStream(){
      @Override public void write(      int b) throws IOException {
      }
    }
));
    Assert.fail("Exception expected");
  }
 catch (  XMLStreamException e) {
    Assert.assertTrue(e.getCause() instanceof WSSecurityException);
    Assert.assertEquals(e.getCause().getMessage(),"IssuerName in Policy (CN=transmitter,OU=swssf,C=CH) didn't match with the one in the HttpsToken (CN=example,OU=swssf,C=CH)");
    Assert.assertEquals(((WSSecurityException)e.getCause()).getFaultCode(),WSSecurityException.INVALID_SECURITY);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testIncludeTimestampAndSignedUsernameSupportingTokenPolicyNegativeTest_2() throws Exception {
  String policyString="<wsp:ExactlyOne xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\" " + "xmlns:sp=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702\">\n" + "            <wsp:All>\n"+ "                <sp:TransportBinding>\n"+ "                    <wsp:Policy>\n"+ "                        <sp:TransportToken>\n"+ "                            <wsp:Policy>\n"+ "                                <sp:HttpsToken>\n"+ "                                    <!--<sp:Issuer>wsa:EndpointReferenceType</sp:Issuer>-->\n"+ "                                    <sp:IssuerName>transmitter</sp:IssuerName>\n"+ "                                    <wsp:Policy>\n"+ "                                        <sp:HttpBasicAuthentication/>\n"+ "                                    </wsp:Policy>\n"+ "                                </sp:HttpsToken>\n"+ "                            </wsp:Policy>\n"+ "                        </sp:TransportToken>\n"+ "                        <sp:AlgorithmSuite>\n"+ "                            <wsp:Policy>\n"+ "                                <sp:Basic256/>\n"+ "                            </wsp:Policy>\n"+ "                        </sp:AlgorithmSuite>\n"+ "                        <sp:Layout>\n"+ "                            <wsp:Policy>\n"+ "                                <sp:Lax/>\n"+ "                            </wsp:Policy>\n"+ "                        </sp:Layout>\n"+ "                    </wsp:Policy>\n"+ "                </sp:TransportBinding>\n"+ "                <sp:SignedSupportingTokens>\n"+ "                    <wsp:Policy>\n"+ "                        <sp:UsernameToken sp:IncludeToken=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702/IncludeToken/AlwaysToRecipient\">\n"+ "                            <wsp:Policy>\n"+ "                                <sp:NoPassword/>\n"+ "                            </wsp:Policy>\n"+ "                        </sp:UsernameToken>\n"+ "                    </wsp:Policy>\n"+ "                </sp:SignedSupportingTokens>\n"+ "            </wsp:All>\n"+ "        </wsp:ExactlyOne>";
  WSSSecurityProperties outSecurityProperties=new WSSSecurityProperties();
  outSecurityProperties.setCallbackHandler(new CallbackHandlerImpl());
  outSecurityProperties.setEncryptionUser("receiver");
  outSecurityProperties.loadEncryptionKeystore(this.getClass().getClassLoader().getResource("transmitter.jks"),"default".toCharArray());
  outSecurityProperties.setSignatureUser("transmitter");
  outSecurityProperties.setTokenUser("transmitter");
  outSecurityProperties.setUsernameTokenPasswordType(WSSConstants.UsernameTokenPasswordType.PASSWORD_NONE);
  outSecurityProperties.loadSignatureKeyStore(this.getClass().getClassLoader().getResource("transmitter.jks"),"default".toCharArray());
  List<WSSConstants.Action> actions=new ArrayList<>();
  actions.add(WSSConstants.SIGNATURE);
  actions.add(WSSConstants.ENCRYPT);
  outSecurityProperties.setActions(actions);
  InputStream sourceDocument=this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml");
  ByteArrayOutputStream baos=doOutboundSecurity(outSecurityProperties,sourceDocument);
  WSSSecurityProperties inSecurityProperties=new WSSSecurityProperties();
  inSecurityProperties.setCallbackHandler(new CallbackHandlerImpl());
  inSecurityProperties.loadSignatureVerificationKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
  inSecurityProperties.loadDecryptionKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
  PolicyEnforcer policyEnforcer=buildAndStartPolicyEngine(policyString);
  inSecurityProperties.addInputProcessor(new PolicyInputProcessor(policyEnforcer,inSecurityProperties));
  HttpsTokenSecurityEvent httpsTokenSecurityEvent=new HttpsTokenSecurityEvent();
  httpsTokenSecurityEvent.setIssuerName("transmitter");
  httpsTokenSecurityEvent.setAuthenticationType(HttpsTokenSecurityEvent.AuthenticationType.HttpBasicAuthentication);
  HttpsSecurityTokenImpl httpsSecurityToken=new HttpsSecurityTokenImpl(true,"transmitter");
  httpsSecurityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_MAIN_SIGNATURE);
  httpsTokenSecurityEvent.setSecurityToken(httpsSecurityToken);
  List<SecurityEvent> securityEventList=new ArrayList<>();
  securityEventList.add(httpsTokenSecurityEvent);
  try {
    Document document=doInboundSecurity(inSecurityProperties,new ByteArrayInputStream(baos.toByteArray()),securityEventList,policyEnforcer);
    Transformer transformer=TransformerFactory.newInstance().newTransformer();
    transformer.transform(new DOMSource(document),new StreamResult(new OutputStream(){
      @Override public void write(      int b) throws IOException {
      }
    }
));
    Assert.fail("Exception expected");
  }
 catch (  XMLStreamException e) {
    Assert.assertTrue(e.getCause() instanceof WSSecurityException);
    Assert.assertEquals(e.getCause().getMessage(),"Assertion {http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702}UsernameToken not satisfied");
    Assert.assertEquals(((WSSecurityException)e.getCause()).getFaultCode(),WSSecurityException.INVALID_SECURITY);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testSignatureDigestAlgorithmSuiteNegative() throws Exception {
  String policyString="<wsp:ExactlyOne xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\" " + "xmlns:sp=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702\">\n" + "            <wsp:All>\n"+ "                <sp:TransportBinding>\n"+ "                    <wsp:Policy>\n"+ "                        <sp:TransportToken>\n"+ "                            <wsp:Policy>\n"+ "                                <sp:HttpsToken>\n"+ "                                    <!--<sp:Issuer>wsa:EndpointReferenceType</sp:Issuer>-->\n"+ "                                    <sp:IssuerName>transmitter</sp:IssuerName>\n"+ "                                    <wsp:Policy>\n"+ "                                        <sp:HttpBasicAuthentication/>\n"+ "                                    </wsp:Policy>\n"+ "                                </sp:HttpsToken>\n"+ "                            </wsp:Policy>\n"+ "                        </sp:TransportToken>\n"+ "                        <sp:AlgorithmSuite>\n"+ "                            <wsp:Policy>\n"+ "                                <sp:Basic256/>\n"+ "                            </wsp:Policy>\n"+ "                        </sp:AlgorithmSuite>\n"+ "                        <sp:Layout>\n"+ "                            <wsp:Policy>\n"+ "                                <sp:Lax/>\n"+ "                            </wsp:Policy>\n"+ "                        </sp:Layout>\n"+ "                        <sp:IncludeTimestamp/>\n"+ "                    </wsp:Policy>\n"+ "                </sp:TransportBinding>\n"+ "                <sp:SignedParts>\n"+ "                    <sp:Body/>\n"+ "                    <sp:Header Name=\"Header1\" Namespace=\"...\"/>\n"+ "                    <sp:Header Namespace=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\"/>\n"+ "                </sp:SignedParts>\n"+ "                <sp:SignedElements>\n"+ "                    <sp:XPath xmlns:wsu=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\">wsu:Created</sp:XPath>\n"+ "                </sp:SignedElements>\n"+ "                <sp:EncryptedParts>\n"+ "                    <sp:Body/>\n"+ "                    <sp:Header Name=\"Header2\" Namespace=\"...\"/>\n"+ "                    <sp:Header Namespace=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\"/>\n"+ "                </sp:EncryptedParts>\n"+ "                <sp:EncryptedElements>\n"+ "                    <sp:XPath xmlns:wsu=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\">wsu:Created</sp:XPath>\n"+ "                </sp:EncryptedElements>\n"+ "                <sp:ContentEncryptedElements>\n"+ "                    <sp:XPath xmlns:wsu=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\">wsu:Expires</sp:XPath>\n"+ "                </sp:ContentEncryptedElements>\n"+ "            </wsp:All>\n"+ "        </wsp:ExactlyOne>";
  WSSSecurityProperties outSecurityProperties=new WSSSecurityProperties();
  outSecurityProperties.setCallbackHandler(new CallbackHandlerImpl());
  outSecurityProperties.setEncryptionUser("receiver");
  outSecurityProperties.loadEncryptionKeystore(this.getClass().getClassLoader().getResource("transmitter.jks"),"default".toCharArray());
  outSecurityProperties.setSignatureUser("transmitter");
  outSecurityProperties.loadSignatureKeyStore(this.getClass().getClassLoader().getResource("transmitter.jks"),"default".toCharArray());
  outSecurityProperties.setSignatureDigestAlgorithm("http://www.w3.org/2001/04/xmldsig-more#rsa-md5");
  outSecurityProperties.addSignaturePart(new SecurePart(new QName(WSSConstants.TAG_WSU_TIMESTAMP.getNamespaceURI(),WSSConstants.TAG_WSU_TIMESTAMP.getLocalPart()),SecurePart.Modifier.Element,new String[]{WSSConstants.NS_C14N_EXCL},"http://www.w3.org/2001/04/xmldsig-more#md5"));
  outSecurityProperties.addSignaturePart(new SecurePart(WSSConstants.TAG_SOAP11_BODY,SecurePart.Modifier.Element,new String[]{WSSConstants.NS_C14N_EXCL},"http://www.w3.org/2001/04/xmldsig-more#md5"));
  outSecurityProperties.addEncryptionPart(new SecurePart(new QName(WSSConstants.TAG_WSU_CREATED.getNamespaceURI(),WSSConstants.TAG_WSU_CREATED.getLocalPart()),SecurePart.Modifier.Element));
  outSecurityProperties.addEncryptionPart(new SecurePart(new QName(WSSConstants.TAG_WSU_EXPIRES.getNamespaceURI(),WSSConstants.TAG_WSU_EXPIRES.getLocalPart()),SecurePart.Modifier.Content));
  outSecurityProperties.addEncryptionPart(new SecurePart(WSSConstants.TAG_SOAP11_BODY,SecurePart.Modifier.Content));
  List<WSSConstants.Action> actions=new ArrayList<>();
  actions.add(WSSConstants.TIMESTAMP);
  actions.add(WSSConstants.SIGNATURE);
  actions.add(WSSConstants.ENCRYPT);
  outSecurityProperties.setActions(actions);
  InputStream sourceDocument=this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml");
  ByteArrayOutputStream baos=doOutboundSecurity(outSecurityProperties,sourceDocument);
  WSSSecurityProperties inSecurityProperties=new WSSSecurityProperties();
  inSecurityProperties.setCallbackHandler(new CallbackHandlerImpl());
  inSecurityProperties.loadSignatureVerificationKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
  inSecurityProperties.loadDecryptionKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
  inSecurityProperties.addIgnoreBSPRule(BSPRule.R5420);
  PolicyEnforcer policyEnforcer=buildAndStartPolicyEngine(policyString);
  inSecurityProperties.addInputProcessor(new PolicyInputProcessor(policyEnforcer,null));
  HttpsTokenSecurityEvent httpsTokenSecurityEvent=new HttpsTokenSecurityEvent();
  httpsTokenSecurityEvent.setIssuerName("transmitter");
  httpsTokenSecurityEvent.setAuthenticationType(HttpsTokenSecurityEvent.AuthenticationType.HttpBasicAuthentication);
  HttpsSecurityTokenImpl httpsSecurityToken=new HttpsSecurityTokenImpl(true,"transmitter");
  httpsSecurityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_MAIN_SIGNATURE);
  httpsTokenSecurityEvent.setSecurityToken(httpsSecurityToken);
  List<SecurityEvent> securityEventList=new ArrayList<>();
  securityEventList.add(httpsTokenSecurityEvent);
  try {
    Init.init(WSSec.class.getClassLoader().getResource("wss/wss-config.xml").toURI(),WSSec.class);
    switchAllowMD5Algorithm(true);
    Document document=doInboundSecurity(inSecurityProperties,new ByteArrayInputStream(baos.toByteArray()),securityEventList,policyEnforcer);
    Transformer transformer=TransformerFactory.newInstance().newTransformer();
    transformer.transform(new DOMSource(document),new StreamResult(new OutputStream(){
      @Override public void write(      int b) throws IOException {
      }
    }
));
    Assert.fail("Exception expected");
  }
 catch (  XMLStreamException e) {
    Assert.assertTrue(e.getCause() instanceof WSSecurityException);
  }
 finally {
    switchAllowMD5Algorithm(false);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testSignatureAlgorithmSuiteNegative() throws Exception {
  String policyString="<wsp:ExactlyOne xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\" " + "xmlns:sp=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702\">\n" + "            <wsp:All>\n"+ "                <sp:TransportBinding>\n"+ "                    <wsp:Policy>\n"+ "                        <sp:TransportToken>\n"+ "                            <wsp:Policy>\n"+ "                                <sp:HttpsToken>\n"+ "                                    <!--<sp:Issuer>wsa:EndpointReferenceType</sp:Issuer>-->\n"+ "                                    <sp:IssuerName>transmitter</sp:IssuerName>\n"+ "                                    <wsp:Policy>\n"+ "                                        <sp:HttpBasicAuthentication/>\n"+ "                                    </wsp:Policy>\n"+ "                                </sp:HttpsToken>\n"+ "                            </wsp:Policy>\n"+ "                        </sp:TransportToken>\n"+ "                        <sp:AlgorithmSuite>\n"+ "                            <wsp:Policy>\n"+ "                                <sp:Basic256/>\n"+ "                            </wsp:Policy>\n"+ "                        </sp:AlgorithmSuite>\n"+ "                        <sp:Layout>\n"+ "                            <wsp:Policy>\n"+ "                                <sp:Lax/>\n"+ "                            </wsp:Policy>\n"+ "                        </sp:Layout>\n"+ "                        <sp:IncludeTimestamp/>\n"+ "                    </wsp:Policy>\n"+ "                </sp:TransportBinding>\n"+ "                <sp:SignedParts>\n"+ "                    <sp:Body/>\n"+ "                    <sp:Header Name=\"Header1\" Namespace=\"...\"/>\n"+ "                    <sp:Header Namespace=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\"/>\n"+ "                </sp:SignedParts>\n"+ "                <sp:SignedElements>\n"+ "                    <sp:XPath xmlns:wsu=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\">wsu:Created</sp:XPath>\n"+ "                </sp:SignedElements>\n"+ "                <sp:EncryptedParts>\n"+ "                    <sp:Body/>\n"+ "                    <sp:Header Name=\"Header2\" Namespace=\"...\"/>\n"+ "                    <sp:Header Namespace=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\"/>\n"+ "                </sp:EncryptedParts>\n"+ "                <sp:EncryptedElements>\n"+ "                    <sp:XPath xmlns:wsu=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\">wsu:Created</sp:XPath>\n"+ "                </sp:EncryptedElements>\n"+ "                <sp:ContentEncryptedElements>\n"+ "                    <sp:XPath xmlns:wsu=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\">wsu:Expires</sp:XPath>\n"+ "                </sp:ContentEncryptedElements>\n"+ "            </wsp:All>\n"+ "        </wsp:ExactlyOne>";
  WSSSecurityProperties outSecurityProperties=new WSSSecurityProperties();
  outSecurityProperties.setCallbackHandler(new CallbackHandlerImpl());
  outSecurityProperties.setEncryptionUser("receiver");
  outSecurityProperties.loadEncryptionKeystore(this.getClass().getClassLoader().getResource("transmitter.jks"),"default".toCharArray());
  outSecurityProperties.setSignatureUser("transmitter");
  outSecurityProperties.loadSignatureKeyStore(this.getClass().getClassLoader().getResource("transmitter.jks"),"default".toCharArray());
  outSecurityProperties.setSignatureAlgorithm("http://www.w3.org/2001/04/xmldsig-more#rsa-sha512");
  outSecurityProperties.addSignaturePart(new SecurePart(new QName(WSSConstants.TAG_WSU_TIMESTAMP.getNamespaceURI(),WSSConstants.TAG_WSU_TIMESTAMP.getLocalPart()),SecurePart.Modifier.Element));
  outSecurityProperties.addSignaturePart(new SecurePart(WSSConstants.TAG_SOAP11_BODY,SecurePart.Modifier.Element));
  outSecurityProperties.addEncryptionPart(new SecurePart(new QName(WSSConstants.TAG_WSU_CREATED.getNamespaceURI(),WSSConstants.TAG_WSU_CREATED.getLocalPart()),SecurePart.Modifier.Element));
  outSecurityProperties.addEncryptionPart(new SecurePart(new QName(WSSConstants.TAG_WSU_EXPIRES.getNamespaceURI(),WSSConstants.TAG_WSU_EXPIRES.getLocalPart()),SecurePart.Modifier.Content));
  outSecurityProperties.addEncryptionPart(new SecurePart(WSSConstants.TAG_SOAP11_BODY,SecurePart.Modifier.Content));
  List<WSSConstants.Action> actions=new ArrayList<>();
  actions.add(WSSConstants.TIMESTAMP);
  actions.add(WSSConstants.SIGNATURE);
  actions.add(WSSConstants.ENCRYPT);
  outSecurityProperties.setActions(actions);
  InputStream sourceDocument=this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml");
  ByteArrayOutputStream baos=doOutboundSecurity(outSecurityProperties,sourceDocument);
  WSSSecurityProperties inSecurityProperties=new WSSSecurityProperties();
  inSecurityProperties.setCallbackHandler(new CallbackHandlerImpl());
  inSecurityProperties.loadSignatureVerificationKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
  inSecurityProperties.loadDecryptionKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
  inSecurityProperties.addIgnoreBSPRule(BSPRule.R5421);
  PolicyEnforcer policyEnforcer=buildAndStartPolicyEngine(policyString);
  inSecurityProperties.addInputProcessor(new PolicyInputProcessor(policyEnforcer,null));
  HttpsTokenSecurityEvent httpsTokenSecurityEvent=new HttpsTokenSecurityEvent();
  httpsTokenSecurityEvent.setIssuerName("transmitter");
  httpsTokenSecurityEvent.setAuthenticationType(HttpsTokenSecurityEvent.AuthenticationType.HttpBasicAuthentication);
  HttpsSecurityTokenImpl httpsSecurityToken=new HttpsSecurityTokenImpl(true,"transmitter");
  httpsSecurityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_MAIN_SIGNATURE);
  httpsTokenSecurityEvent.setSecurityToken(httpsSecurityToken);
  List<SecurityEvent> securityEventList=new ArrayList<>();
  securityEventList.add(httpsTokenSecurityEvent);
  try {
    Document document=doInboundSecurity(inSecurityProperties,new ByteArrayInputStream(baos.toByteArray()),securityEventList,policyEnforcer);
    Transformer transformer=TransformerFactory.newInstance().newTransformer();
    transformer.transform(new DOMSource(document),new StreamResult(new OutputStream(){
      @Override public void write(      int b) throws IOException {
      }
    }
));
    Assert.fail("Exception expected");
  }
 catch (  XMLStreamException e) {
    Assert.assertTrue(e.getCause() instanceof WSSecurityException);
    Assert.assertEquals(e.getCause().getMessage(),"Asymmetric algorithm http://www.w3.org/2001/04/xmldsig-more#rsa-sha512 does not meet policy");
    Assert.assertEquals(((WSSecurityException)e.getCause()).getFaultCode(),WSSecurityException.INVALID_SECURITY);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testIncludeTimestampAndSignedUsernameSupportingTokenPolicyNegativeTest() throws Exception {
  String policyString="<wsp:ExactlyOne xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\" " + "xmlns:sp=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702\">\n" + "            <wsp:All>\n"+ "                <sp:TransportBinding>\n"+ "                    <wsp:Policy>\n"+ "                        <sp:TransportToken>\n"+ "                            <wsp:Policy>\n"+ "                                <sp:HttpsToken>\n"+ "                                    <!--<sp:Issuer>wsa:EndpointReferenceType</sp:Issuer>-->\n"+ "                                    <sp:IssuerName>transmitter</sp:IssuerName>\n"+ "                                    <wsp:Policy>\n"+ "                                        <sp:HttpBasicAuthentication/>\n"+ "                                    </wsp:Policy>\n"+ "                                </sp:HttpsToken>\n"+ "                            </wsp:Policy>\n"+ "                        </sp:TransportToken>\n"+ "                        <sp:AlgorithmSuite>\n"+ "                            <wsp:Policy>\n"+ "                                <sp:Basic256/>\n"+ "                            </wsp:Policy>\n"+ "                        </sp:AlgorithmSuite>\n"+ "                        <sp:Layout>\n"+ "                            <wsp:Policy>\n"+ "                                <sp:Lax/>\n"+ "                            </wsp:Policy>\n"+ "                        </sp:Layout>\n"+ "                        <sp:IncludeTimestamp/>\n"+ "                    </wsp:Policy>\n"+ "                </sp:TransportBinding>\n"+ "                <sp:SignedParts>\n"+ "                    <sp:Body/>\n"+ "                    <sp:Header Name=\"Header1\" Namespace=\"...\"/>\n"+ "                    <sp:Header Namespace=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\"/>\n"+ "                </sp:SignedParts>\n"+ "                <sp:SignedElements>\n"+ "                    <sp:XPath xmlns:wsu=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\">wsu:Created</sp:XPath>\n"+ "                </sp:SignedElements>\n"+ "                <sp:EncryptedParts>\n"+ "                    <sp:Body/>\n"+ "                    <sp:Header Name=\"Header2\" Namespace=\"...\"/>\n"+ "                    <sp:Header Namespace=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\"/>\n"+ "                </sp:EncryptedParts>\n"+ "                <sp:EncryptedElements>\n"+ "                    <sp:XPath xmlns:wsu=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\">wsu:Created</sp:XPath>\n"+ "                </sp:EncryptedElements>\n"+ "                <sp:ContentEncryptedElements>\n"+ "                    <sp:XPath xmlns:wsu=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\">wsu:Expires</sp:XPath>\n"+ "                </sp:ContentEncryptedElements>\n"+ "                <sp:SignedSupportingTokens>\n"+ "                    <wsp:Policy>\n"+ "                        <sp:UsernameToken sp:IncludeToken=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702/IncludeToken/AlwaysToRecipient\">\n"+ "                            <wsp:Policy>\n"+ "                                <sp:NoPassword/>\n"+ "                            </wsp:Policy>\n"+ "                        </sp:UsernameToken>\n"+ "                    </wsp:Policy>\n"+ "                </sp:SignedSupportingTokens>\n"+ "            </wsp:All>\n"+ "        </wsp:ExactlyOne>";
  WSSSecurityProperties outSecurityProperties=new WSSSecurityProperties();
  outSecurityProperties.setCallbackHandler(new CallbackHandlerImpl());
  outSecurityProperties.setEncryptionUser("receiver");
  outSecurityProperties.loadEncryptionKeystore(this.getClass().getClassLoader().getResource("transmitter.jks"),"default".toCharArray());
  outSecurityProperties.setSignatureUser("transmitter");
  outSecurityProperties.setTokenUser("transmitter");
  outSecurityProperties.setUsernameTokenPasswordType(WSSConstants.UsernameTokenPasswordType.PASSWORD_NONE);
  outSecurityProperties.loadSignatureKeyStore(this.getClass().getClassLoader().getResource("transmitter.jks"),"default".toCharArray());
  List<WSSConstants.Action> actions=new ArrayList<>();
  actions.add(WSSConstants.TIMESTAMP);
  actions.add(WSSConstants.SIGNATURE);
  actions.add(WSSConstants.ENCRYPT);
  outSecurityProperties.setActions(actions);
  InputStream sourceDocument=this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml");
  ByteArrayOutputStream baos=doOutboundSecurity(outSecurityProperties,sourceDocument);
  WSSSecurityProperties inSecurityProperties=new WSSSecurityProperties();
  inSecurityProperties.setCallbackHandler(new CallbackHandlerImpl());
  inSecurityProperties.loadSignatureVerificationKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
  inSecurityProperties.loadDecryptionKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
  PolicyEnforcer policyEnforcer=buildAndStartPolicyEngine(policyString);
  inSecurityProperties.addInputProcessor(new PolicyInputProcessor(policyEnforcer,null));
  HttpsTokenSecurityEvent httpsTokenSecurityEvent=new HttpsTokenSecurityEvent();
  httpsTokenSecurityEvent.setIssuerName("transmitter");
  httpsTokenSecurityEvent.setAuthenticationType(HttpsTokenSecurityEvent.AuthenticationType.HttpBasicAuthentication);
  HttpsSecurityTokenImpl httpsSecurityToken=new HttpsSecurityTokenImpl(true,"transmitter");
  httpsSecurityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_MAIN_SIGNATURE);
  httpsTokenSecurityEvent.setSecurityToken(httpsSecurityToken);
  List<SecurityEvent> securityEventList=new ArrayList<>();
  securityEventList.add(httpsTokenSecurityEvent);
  try {
    Document document=doInboundSecurity(inSecurityProperties,new ByteArrayInputStream(baos.toByteArray()),securityEventList,policyEnforcer);
    Transformer transformer=TransformerFactory.newInstance().newTransformer();
    transformer.transform(new DOMSource(document),new StreamResult(new OutputStream(){
      @Override public void write(      int b) throws IOException {
      }
    }
));
    Assert.fail("Exception expected");
  }
 catch (  XMLStreamException e) {
    Assert.assertTrue(e.getCause() instanceof WSSecurityException);
    Assert.assertEquals(e.getCause().getMessage(),"Assertion {http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702}UsernameToken not satisfied");
    Assert.assertEquals(((WSSecurityException)e.getCause()).getFaultCode(),WSSecurityException.INVALID_SECURITY);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testEncryptionAlgorithmSuiteNegative() throws Exception {
  String policyString="<wsp:ExactlyOne xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\" " + "xmlns:sp=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702\">\n" + "            <wsp:All>\n"+ "                <sp:TransportBinding>\n"+ "                    <wsp:Policy>\n"+ "                        <sp:TransportToken>\n"+ "                            <wsp:Policy>\n"+ "                                <sp:HttpsToken>\n"+ "                                    <!--<sp:Issuer>wsa:EndpointReferenceType</sp:Issuer>-->\n"+ "                                    <sp:IssuerName>transmitter</sp:IssuerName>\n"+ "                                    <wsp:Policy>\n"+ "                                        <sp:HttpBasicAuthentication/>\n"+ "                                    </wsp:Policy>\n"+ "                                </sp:HttpsToken>\n"+ "                            </wsp:Policy>\n"+ "                        </sp:TransportToken>\n"+ "                        <sp:AlgorithmSuite>\n"+ "                            <wsp:Policy>\n"+ "                                <sp:Basic256/>\n"+ "                            </wsp:Policy>\n"+ "                        </sp:AlgorithmSuite>\n"+ "                        <sp:Layout>\n"+ "                            <wsp:Policy>\n"+ "                                <sp:Lax/>\n"+ "                            </wsp:Policy>\n"+ "                        </sp:Layout>\n"+ "                        <sp:IncludeTimestamp/>\n"+ "                    </wsp:Policy>\n"+ "                </sp:TransportBinding>\n"+ "                <sp:SignedParts>\n"+ "                    <sp:Body/>\n"+ "                    <sp:Header Name=\"Header1\" Namespace=\"...\"/>\n"+ "                    <sp:Header Namespace=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\"/>\n"+ "                </sp:SignedParts>\n"+ "                <sp:SignedElements>\n"+ "                    <sp:XPath xmlns:wsu=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\">wsu:Created</sp:XPath>\n"+ "                </sp:SignedElements>\n"+ "                <sp:EncryptedParts>\n"+ "                    <sp:Body/>\n"+ "                    <sp:Header Name=\"Header2\" Namespace=\"...\"/>\n"+ "                    <sp:Header Namespace=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\"/>\n"+ "                </sp:EncryptedParts>\n"+ "                <sp:EncryptedElements>\n"+ "                    <sp:XPath xmlns:wsu=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\">wsu:Created</sp:XPath>\n"+ "                </sp:EncryptedElements>\n"+ "                <sp:ContentEncryptedElements>\n"+ "                    <sp:XPath xmlns:wsu=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\">wsu:Expires</sp:XPath>\n"+ "                </sp:ContentEncryptedElements>\n"+ "            </wsp:All>\n"+ "        </wsp:ExactlyOne>";
  WSSSecurityProperties outSecurityProperties=new WSSSecurityProperties();
  outSecurityProperties.setCallbackHandler(new CallbackHandlerImpl());
  outSecurityProperties.setEncryptionUser("receiver");
  outSecurityProperties.loadEncryptionKeystore(this.getClass().getClassLoader().getResource("transmitter.jks"),"default".toCharArray());
  outSecurityProperties.setEncryptionSymAlgorithm("http://www.w3.org/2001/04/xmlenc#tripledes-cbc");
  outSecurityProperties.setSignatureUser("transmitter");
  outSecurityProperties.loadSignatureKeyStore(this.getClass().getClassLoader().getResource("transmitter.jks"),"default".toCharArray());
  outSecurityProperties.addSignaturePart(new SecurePart(new QName(WSSConstants.TAG_WSU_TIMESTAMP.getNamespaceURI(),WSSConstants.TAG_WSU_TIMESTAMP.getLocalPart()),SecurePart.Modifier.Element));
  outSecurityProperties.addSignaturePart(new SecurePart(WSSConstants.TAG_SOAP11_BODY,SecurePart.Modifier.Element));
  outSecurityProperties.addEncryptionPart(new SecurePart(new QName(WSSConstants.TAG_WSU_CREATED.getNamespaceURI(),WSSConstants.TAG_WSU_CREATED.getLocalPart()),SecurePart.Modifier.Element));
  outSecurityProperties.addEncryptionPart(new SecurePart(new QName(WSSConstants.TAG_WSU_EXPIRES.getNamespaceURI(),WSSConstants.TAG_WSU_EXPIRES.getLocalPart()),SecurePart.Modifier.Content));
  outSecurityProperties.addEncryptionPart(new SecurePart(WSSConstants.TAG_SOAP11_BODY,SecurePart.Modifier.Content));
  List<WSSConstants.Action> actions=new ArrayList<>();
  actions.add(WSSConstants.TIMESTAMP);
  actions.add(WSSConstants.SIGNATURE);
  actions.add(WSSConstants.ENCRYPT);
  outSecurityProperties.setActions(actions);
  InputStream sourceDocument=this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml");
  ByteArrayOutputStream baos=doOutboundSecurity(outSecurityProperties,sourceDocument);
  WSSSecurityProperties inSecurityProperties=new WSSSecurityProperties();
  inSecurityProperties.setCallbackHandler(new CallbackHandlerImpl());
  inSecurityProperties.loadSignatureVerificationKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
  inSecurityProperties.loadDecryptionKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
  PolicyEnforcer policyEnforcer=buildAndStartPolicyEngine(policyString);
  inSecurityProperties.addInputProcessor(new PolicyInputProcessor(policyEnforcer,null));
  HttpsTokenSecurityEvent httpsTokenSecurityEvent=new HttpsTokenSecurityEvent();
  httpsTokenSecurityEvent.setIssuerName("transmitter");
  httpsTokenSecurityEvent.setAuthenticationType(HttpsTokenSecurityEvent.AuthenticationType.HttpBasicAuthentication);
  HttpsSecurityTokenImpl httpsSecurityToken=new HttpsSecurityTokenImpl(true,"transmitter");
  httpsSecurityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_MAIN_SIGNATURE);
  httpsTokenSecurityEvent.setSecurityToken(httpsSecurityToken);
  List<SecurityEvent> securityEventList=new ArrayList<>();
  securityEventList.add(httpsTokenSecurityEvent);
  try {
    Document document=doInboundSecurity(inSecurityProperties,new ByteArrayInputStream(baos.toByteArray()),securityEventList,policyEnforcer);
    Transformer transformer=TransformerFactory.newInstance().newTransformer();
    transformer.transform(new DOMSource(document),new StreamResult(new OutputStream(){
      @Override public void write(      int b) throws IOException {
      }
    }
));
    Assert.fail("Exception expected");
  }
 catch (  XMLStreamException e) {
    Assert.assertTrue(e.getCause() instanceof WSSecurityException);
    Assert.assertEquals(e.getCause().getMessage(),"Encryption algorithm http://www.w3.org/2001/04/xmlenc#tripledes-cbc does not meet policy\n" + "Symmetric encryption algorithm key length 192 does not meet policy");
    Assert.assertEquals(((WSSecurityException)e.getCause()).getFaultCode(),WSSecurityException.INVALID_SECURITY);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.wss4j.policy.stax.test.TransportBindingTest </h4><pre class="type-8 type-7 type-5 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testPolicyNotIncludeTimestamp() throws Exception {
  String policyString="<sp:TransportBinding xmlns:sp=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702\" xmlns:sp3=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200802\">\n" + "<wsp:Policy xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\">\n" + "   <sp:AlgorithmSuite>\n"+ "       <wsp:Policy>\n"+ "           <sp:Basic256/>\n"+ "       </wsp:Policy>\n"+ "   </sp:AlgorithmSuite>\n"+ "</wsp:Policy>\n"+ "</sp:TransportBinding>";
  PolicyEnforcer policyEnforcer=buildAndStartPolicyEngine(policyString);
  HttpsTokenSecurityEvent httpsTokenSecurityEvent=new HttpsTokenSecurityEvent();
  HttpsSecurityTokenImpl httpsSecurityToken=new HttpsSecurityTokenImpl(true,"username");
  httpsSecurityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_MAIN_SIGNATURE);
  httpsTokenSecurityEvent.setSecurityToken(httpsSecurityToken);
  policyEnforcer.registerSecurityEvent(httpsTokenSecurityEvent);
  TimestampSecurityEvent timestampSecurityEvent=new TimestampSecurityEvent();
  policyEnforcer.registerSecurityEvent(timestampSecurityEvent);
  OperationSecurityEvent operationSecurityEvent=new OperationSecurityEvent();
  operationSecurityEvent.setOperation(new QName("definitions"));
  try {
    policyEnforcer.registerSecurityEvent(operationSecurityEvent);
    Assert.fail("Exception expected");
  }
 catch (  WSSecurityException e) {
    Assert.assertTrue(e.getCause() instanceof PolicyViolationException);
    Assert.assertEquals(e.getCause().getMessage(),"Timestamp must not be present");
    Assert.assertEquals(e.getFaultCode(),WSSecurityException.INVALID_SECURITY);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.wss4j.policy.stax.test.UsernameTokenTest </h4><pre class="type-8 type-7 type-5 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testPolicyNegative() throws Exception {
  String policyString="<sp:SymmetricBinding xmlns:sp=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702\" xmlns:sp3=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200802\">\n" + "<wsp:Policy xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\">\n" + "<sp:EncryptionToken>\n"+ "   <wsp:Policy>\n"+ "       <sp:UsernameToken>\n"+ "           <sp:IssuerName>xs:anyURI</sp:IssuerName>\n"+ "           <wsp:Policy xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\">\n"+ "               <sp:HashPassword/>\n"+ "               <sp:WssUsernameToken11/>\n"+ "           </wsp:Policy>\n"+ "       </sp:UsernameToken>\n"+ "   </wsp:Policy>\n"+ "</sp:EncryptionToken>\n"+ "<sp:SignatureToken>\n"+ "   <wsp:Policy>\n"+ "       <sp:UsernameToken>\n"+ "           <sp:IssuerName>xs:anyURI</sp:IssuerName>\n"+ "           <wsp:Policy xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\">\n"+ "               <sp:HashPassword/>\n"+ "               <sp:WssUsernameToken11/>\n"+ "           </wsp:Policy>\n"+ "       </sp:UsernameToken>\n"+ "   </wsp:Policy>\n"+ "</sp:SignatureToken>\n"+ "   <sp:AlgorithmSuite>\n"+ "       <wsp:Policy>\n"+ "           <sp:Basic256/>\n"+ "       </wsp:Policy>\n"+ "   </sp:AlgorithmSuite>\n"+ "</wsp:Policy>\n"+ "</sp:SymmetricBinding>";
  PolicyEnforcer policyEnforcer=buildAndStartPolicyEngine(policyString);
  UsernameTokenSecurityEvent usernameTokenSecurityEvent=new UsernameTokenSecurityEvent();
  usernameTokenSecurityEvent.setUsernameTokenProfile(WSSConstants.NS_USERNAMETOKEN_PROFILE11);
  UsernameSecurityTokenImpl securityToken=new UsernameSecurityTokenImpl(WSSConstants.UsernameTokenPasswordType.PASSWORD_TEXT,"username","password",new Date().toString(),null,new byte[10],10L,null,IDGenerator.generateID(null),WSSecurityTokenConstants.KEYIDENTIFIER_SECURITY_TOKEN_DIRECT_REFERENCE);
  securityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_MAIN_SIGNATURE);
  usernameTokenSecurityEvent.setSecurityToken(securityToken);
  policyEnforcer.registerSecurityEvent(usernameTokenSecurityEvent);
  UsernameTokenSecurityEvent recipientTokenSecurityEvent=new UsernameTokenSecurityEvent();
  recipientTokenSecurityEvent.setUsernameTokenProfile(WSSConstants.NS_USERNAMETOKEN_PROFILE11);
  securityToken=new UsernameSecurityTokenImpl(WSSConstants.UsernameTokenPasswordType.PASSWORD_TEXT,"username","password",new Date().toString(),null,new byte[10],10L,null,IDGenerator.generateID(null),WSSecurityTokenConstants.KEYIDENTIFIER_SECURITY_TOKEN_DIRECT_REFERENCE);
  securityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_MAIN_ENCRYPTION);
  recipientTokenSecurityEvent.setSecurityToken(securityToken);
  policyEnforcer.registerSecurityEvent(recipientTokenSecurityEvent);
  List<XMLSecurityConstants.ContentType> protectionOrder=new LinkedList<>();
  protectionOrder.add(XMLSecurityConstants.ContentType.SIGNATURE);
  protectionOrder.add(XMLSecurityConstants.ContentType.ENCRYPTION);
  SignedPartSecurityEvent signedPartSecurityEvent=new SignedPartSecurityEvent((InboundSecurityToken)recipientTokenSecurityEvent.getSecurityToken(),true,protectionOrder);
  signedPartSecurityEvent.setElementPath(WSSConstants.SOAP_11_BODY_PATH);
  policyEnforcer.registerSecurityEvent(signedPartSecurityEvent);
  ContentEncryptedElementSecurityEvent contentEncryptedElementSecurityEvent=new ContentEncryptedElementSecurityEvent((InboundSecurityToken)recipientTokenSecurityEvent.getSecurityToken(),true,protectionOrder);
  contentEncryptedElementSecurityEvent.setElementPath(WSSConstants.SOAP_11_BODY_PATH);
  policyEnforcer.registerSecurityEvent(contentEncryptedElementSecurityEvent);
  OperationSecurityEvent operationSecurityEvent=new OperationSecurityEvent();
  operationSecurityEvent.setOperation(new QName("definitions"));
  try {
    policyEnforcer.registerSecurityEvent(operationSecurityEvent);
    Assert.fail("Exception expected");
  }
 catch (  WSSecurityException e) {
    Assert.assertTrue(e.getCause() instanceof PolicyViolationException);
    Assert.assertEquals(e.getCause().getMessage(),"UsernameToken does not contain a hashed password");
    Assert.assertEquals(e.getFaultCode(),WSSecurityException.INVALID_SECURITY);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.wss4j.policy.stax.test.VulnerabliltyVectorsTest </h4><pre class="type-3 type-8 type-7 type-1 type-6 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testSignedBodyRelocationToHeader() throws Exception {
  InputStream sourceDocument=this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml");
  String action=WSHandlerConstants.TIMESTAMP + " " + WSHandlerConstants.SIGNATURE+ " "+ WSHandlerConstants.ENCRYPT;
  Properties properties=new Properties();
  properties.setProperty(WSHandlerConstants.SIGNATURE_PARTS,"{Element}{http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd}Timestamp;{Element}{http://schemas.xmlsoap.org/soap/envelope/}Body;");
  properties.setProperty(WSHandlerConstants.ENC_SYM_ALGO,"http://www.w3.org/2001/04/xmlenc#aes256-cbc");
  Document securedDocument=doOutboundSecurityWithWSS4J(sourceDocument,action,properties);
  XPathExpression xPathExpression=getXPath("/soap:Envelope/soap:Body");
  Element bodyElement=(Element)xPathExpression.evaluate(securedDocument,XPathConstants.NODE);
  Element soapEnvElement=(Element)bodyElement.getParentNode();
  soapEnvElement.removeChild(bodyElement);
  Element newBody=securedDocument.createElementNS(WSSConstants.NS_SOAP11,WSSConstants.TAG_SOAP_BODY_LN);
  Element operationElement=securedDocument.createElementNS("http://schemas.xmlsoap.org/wsdl/","definitions");
  newBody.appendChild(operationElement);
  soapEnvElement.appendChild(newBody);
  xPathExpression=getXPath("/soap:Envelope/soap:Header");
  Element headerElement=(Element)xPathExpression.evaluate(securedDocument,XPathConstants.NODE);
  headerElement.appendChild(bodyElement);
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  javax.xml.transform.Transformer transformer=TRANSFORMER_FACTORY.newTransformer();
  transformer.transform(new DOMSource(securedDocument),new StreamResult(baos));
  WSSSecurityProperties inSecurityProperties=new WSSSecurityProperties();
  inSecurityProperties.setCallbackHandler(new CallbackHandlerImpl());
  inSecurityProperties.loadSignatureVerificationKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
  inSecurityProperties.loadDecryptionKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
  PolicyEnforcerFactory policyEnforcerFactory=PolicyEnforcerFactory.newInstance(this.getClass().getClassLoader().getResource("testdata/wsdl/actionSpoofing.wsdl"));
  PolicyEnforcer policyEnforcer=policyEnforcerFactory.newPolicyEnforcer("goodPolicy",false,null,0);
  inSecurityProperties.addInputProcessor(new PolicyInputProcessor(policyEnforcer,inSecurityProperties));
  try {
    doInboundSecurity(inSecurityProperties,xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray())),policyEnforcer);
    Assert.fail("Expected XMLStreamException");
  }
 catch (  XMLStreamException e) {
    Throwable throwable=e.getCause();
    Assert.assertNotNull(throwable);
    Assert.assertTrue(throwable instanceof WSSecurityException);
    Assert.assertEquals(throwable.getMessage(),"Element /{http://schemas.xmlsoap.org/soap/envelope/}Envelope/{http://schemas.xmlsoap.org/soap/envelope/}Body must be signed");
    Assert.assertEquals(((WSSecurityException)throwable).getFaultCode(),WSSecurityException.INVALID_SECURITY);
  }
}

</code></pre>

<br>
<pre class="type-3 type-8 type-7 type-1 type-6 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Tests what happens when an soapAction from an other operation is provided.
 * Can the policy framework be bypassed?
 * @Ignoring as SOAP Action spoofing detection should be left to the SOAP stack
 */
@Test @org.junit.Ignore public void testSOAPActionSpoofing() throws Exception {
  WSSSecurityProperties outSecurityProperties=new WSSSecurityProperties();
  outSecurityProperties.setCallbackHandler(new CallbackHandlerImpl());
  outSecurityProperties.setEncryptionUser("receiver");
  outSecurityProperties.loadEncryptionKeystore(this.getClass().getClassLoader().getResource("transmitter.jks"),"default".toCharArray());
  outSecurityProperties.setSignatureUser("transmitter");
  outSecurityProperties.loadSignatureKeyStore(this.getClass().getClassLoader().getResource("transmitter.jks"),"default".toCharArray());
  outSecurityProperties.addSignaturePart(new SecurePart(WSSConstants.TAG_WSU_TIMESTAMP,SecurePart.Modifier.Element));
  outSecurityProperties.addSignaturePart(new SecurePart(WSSConstants.TAG_SOAP11_BODY,SecurePart.Modifier.Element));
  outSecurityProperties.addEncryptionPart(new SecurePart(WSSConstants.TAG_SOAP11_BODY,SecurePart.Modifier.Content));
  List<WSSConstants.Action> actions=new ArrayList<>();
  actions.add(WSSConstants.TIMESTAMP);
  actions.add(WSSConstants.SIGNATURE);
  actions.add(WSSConstants.ENCRYPT);
  outSecurityProperties.setActions(actions);
  InputStream sourceDocument=this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml");
  ByteArrayOutputStream baos=doOutboundSecurity(outSecurityProperties,sourceDocument);
  WSSSecurityProperties inSecurityProperties=new WSSSecurityProperties();
  inSecurityProperties.setCallbackHandler(new CallbackHandlerImpl());
  inSecurityProperties.loadSignatureVerificationKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
  inSecurityProperties.loadDecryptionKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
  PolicyEnforcerFactory policyEnforcerFactory=PolicyEnforcerFactory.newInstance(this.getClass().getClassLoader().getResource("testdata/wsdl/actionSpoofing.wsdl"));
  PolicyEnforcer policyEnforcer=policyEnforcerFactory.newPolicyEnforcer("emptyPolicy",false,null,0);
  inSecurityProperties.addInputProcessor(new PolicyInputProcessor(policyEnforcer,inSecurityProperties));
  try {
    doInboundSecurity(inSecurityProperties,new ByteArrayInputStream(baos.toByteArray()),policyEnforcer);
    Assert.fail("Expected XMLStreamException");
  }
 catch (  XMLStreamException e) {
    Throwable throwable=e.getCause();
    Assert.assertNotNull(throwable);
    Assert.assertTrue(throwable instanceof WSSecurityException);
    Assert.assertEquals(throwable.getMessage(),"SOAPAction (emptyPolicyOperation) does not match with the current Operation: " + "{http://schemas.xmlsoap.org/wsdl/}definitions");
    Assert.assertEquals(((WSSecurityException)throwable).getFaultCode(),WSSecurityException.INVALID_SECURITY);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.wss4j.policy.stax.test.X509TokenTest </h4><pre class="type-8 type-5 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testPolicyNegative() throws Exception {
  String policyString="<sp:AsymmetricBinding xmlns:sp=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200702\" xmlns:sp3=\"http://docs.oasis-open.org/ws-sx/ws-securitypolicy/200802\">\n" + "<wsp:Policy xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\">\n" + "<sp:InitiatorToken>\n"+ "   <wsp:Policy>\n"+ "       <sp:X509Token>\n"+ "           <sp:IssuerName>CN=transmitter,OU=swssf,C=CH</sp:IssuerName>\n"+ "           <wsp:Policy xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\">\n"+ "               <sp:RequireThumbprintReference/>\n"+ "               <sp:WssX509V3Token11/>\n"+ "           </wsp:Policy>\n"+ "       </sp:X509Token>\n"+ "   </wsp:Policy>\n"+ "</sp:InitiatorToken>\n"+ "<sp:RecipientToken>\n"+ "   <wsp:Policy>\n"+ "       <sp:X509Token>\n"+ "           <sp:IssuerName>CN=transmitter,OU=swssf,C=CH</sp:IssuerName>\n"+ "           <wsp:Policy xmlns:wsp=\"http://schemas.xmlsoap.org/ws/2004/09/policy\">\n"+ "               <sp:RequireThumbprintReference/>\n"+ "               <sp:WssX509V3Token11/>\n"+ "           </wsp:Policy>\n"+ "       </sp:X509Token>\n"+ "   </wsp:Policy>\n"+ "</sp:RecipientToken>\n"+ "   <sp:AlgorithmSuite>\n"+ "       <wsp:Policy>\n"+ "           <sp:Basic256/>\n"+ "       </wsp:Policy>\n"+ "   </sp:AlgorithmSuite>\n"+ "</wsp:Policy>\n"+ "</sp:AsymmetricBinding>";
  PolicyEnforcer policyEnforcer=buildAndStartPolicyEngine(policyString);
  X509TokenSecurityEvent initiatorX509TokenSecurityEvent=new X509TokenSecurityEvent();
  X509SecurityTokenImpl securityToken=getX509Token(WSSecurityTokenConstants.X509V1Token);
  securityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_MAIN_SIGNATURE);
  initiatorX509TokenSecurityEvent.setSecurityToken(securityToken);
  policyEnforcer.registerSecurityEvent(initiatorX509TokenSecurityEvent);
  X509TokenSecurityEvent recipientX509TokenSecurityEvent=new X509TokenSecurityEvent();
  securityToken=getX509Token(WSSecurityTokenConstants.X509V3Token);
  securityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_MAIN_ENCRYPTION);
  recipientX509TokenSecurityEvent.setSecurityToken(securityToken);
  policyEnforcer.registerSecurityEvent(recipientX509TokenSecurityEvent);
  List<XMLSecurityConstants.ContentType> protectionOrder=new LinkedList<>();
  protectionOrder.add(XMLSecurityConstants.ContentType.SIGNATURE);
  protectionOrder.add(XMLSecurityConstants.ContentType.ENCRYPTION);
  SignedPartSecurityEvent signedPartSecurityEvent=new SignedPartSecurityEvent((InboundSecurityToken)recipientX509TokenSecurityEvent.getSecurityToken(),true,protectionOrder);
  signedPartSecurityEvent.setElementPath(WSSConstants.SOAP_11_BODY_PATH);
  policyEnforcer.registerSecurityEvent(signedPartSecurityEvent);
  ContentEncryptedElementSecurityEvent contentEncryptedElementSecurityEvent=new ContentEncryptedElementSecurityEvent((InboundSecurityToken)recipientX509TokenSecurityEvent.getSecurityToken(),true,protectionOrder);
  contentEncryptedElementSecurityEvent.setElementPath(WSSConstants.SOAP_11_BODY_PATH);
  policyEnforcer.registerSecurityEvent(contentEncryptedElementSecurityEvent);
  OperationSecurityEvent operationSecurityEvent=new OperationSecurityEvent();
  operationSecurityEvent.setOperation(new QName("definitions"));
  try {
    policyEnforcer.registerSecurityEvent(operationSecurityEvent);
    Assert.fail("Exception expected");
  }
 catch (  WSSecurityException e) {
    Assert.assertEquals(e.getMessage(),"X509Certificate Version 3 mismatch; Policy enforces WssX509V3Token11");
    Assert.assertEquals(e.getFaultCode(),WSSecurityException.INVALID_SECURITY);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.wss4j.stax.test.AttachmentTest </h4><pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testInvalidXMLAttachmentContentSignature() throws Exception {
  final String attachmentId=UUID.randomUUID().toString();
  final Attachment attachment=new Attachment();
  attachment.setMimeType("text/xml");
  attachment.addHeaders(getHeaders(attachmentId));
  attachment.setId(attachmentId);
  attachment.setSourceStream(new ByteArrayInputStream(SOAPUtil.SAMPLE_SOAP_MSG.getBytes(StandardCharsets.UTF_8)));
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
{
    WSSSecurityProperties securityProperties=new WSSSecurityProperties();
    List<WSSConstants.Action> actions=new ArrayList<WSSConstants.Action>();
    actions.add(WSSConstants.SIGNATURE);
    securityProperties.setActions(actions);
    securityProperties.loadSignatureKeyStore(this.getClass().getClassLoader().getResource("transmitter.jks"),"default".toCharArray());
    securityProperties.setSignatureUser("transmitter");
    securityProperties.addSignaturePart(new SecurePart(new QName("http://schemas.xmlsoap.org/soap/envelope/","Body"),SecurePart.Modifier.Element));
    securityProperties.addSignaturePart(new SecurePart("cid:Attachments",SecurePart.Modifier.Content));
    securityProperties.setCallbackHandler(new CallbackHandlerImpl());
    AttachmentCallbackHandler attachmentCallbackHandler=new AttachmentCallbackHandler(Collections.singletonList(attachment));
    securityProperties.setAttachmentCallbackHandler(attachmentCallbackHandler);
    OutboundWSSec wsSecOut=WSSec.getOutboundWSSec(securityProperties);
    XMLStreamWriter xmlStreamWriter=wsSecOut.processOutMessage(baos,StandardCharsets.UTF_8.name(),new ArrayList<SecurityEvent>());
    XMLStreamReader xmlStreamReader=xmlInputFactory.createXMLStreamReader(this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml"));
    XmlReaderToWriter.writeAll(xmlStreamReader,xmlStreamWriter);
    xmlStreamWriter.close();
  }
{
    WSSSecurityProperties securityProperties=new WSSSecurityProperties();
    securityProperties.loadSignatureVerificationKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
    securityProperties.setAttachmentCallbackHandler(new CallbackHandler(){
      @Override public void handle(      Callback[] callbacks) throws IOException, UnsupportedCallbackException {
        if (callbacks[0] instanceof AttachmentRequestCallback) {
          AttachmentRequestCallback attachmentRequestCallback=(AttachmentRequestCallback)callbacks[0];
          if (!attachment.getId().equals(attachmentRequestCallback.getAttachmentId())) {
            throw new RuntimeException("wrong attachment requested");
          }
          List<Attachment> attachments=new ArrayList<Attachment>();
          attachment.setSourceStream(new ByteArrayInputStream(SOAPUtil.SAMPLE_SOAP_MSG.replace("15","16").getBytes(StandardCharsets.UTF_8)));
          attachments.add(attachment);
          attachmentRequestCallback.setAttachments(attachments);
        }
      }
    }
);
    InboundWSSec wsSecIn=WSSec.getInboundWSSec(securityProperties);
    XMLStreamReader xmlStreamReader=wsSecIn.processInMessage(xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray())));
    try {
      StAX2DOM.readDoc(documentBuilderFactory.newDocumentBuilder(),xmlStreamReader);
      Assert.fail("Exception expected");
    }
 catch (    XMLStreamException e) {
      Assert.assertTrue(e.getCause() instanceof XMLSecurityException);
      Assert.assertTrue(e.getCause().getMessage().startsWith("Invalid digest of reference cid:"));
    }
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testInvalidXMLAttachmentCmplSignCmplEnc() throws Exception {
  final String attachmentId=UUID.randomUUID().toString();
  final Attachment[] attachment=new Attachment[1];
  attachment[0]=new Attachment();
  attachment[0].setMimeType("text/xml");
  attachment[0].addHeaders(getHeaders(attachmentId));
  attachment[0].setId(attachmentId);
  attachment[0].setSourceStream(new ByteArrayInputStream(SOAPUtil.SAMPLE_SOAP_MSG.getBytes(StandardCharsets.UTF_8)));
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
{
    WSSSecurityProperties securityProperties=new WSSSecurityProperties();
    List<WSSConstants.Action> actions=new ArrayList<WSSConstants.Action>();
    actions.add(WSSConstants.SIGNATURE);
    actions.add(WSSConstants.ENCRYPT);
    securityProperties.setActions(actions);
    securityProperties.loadSignatureKeyStore(this.getClass().getClassLoader().getResource("transmitter.jks"),"default".toCharArray());
    securityProperties.setSignatureUser("transmitter");
    securityProperties.addSignaturePart(new SecurePart(new QName("http://schemas.xmlsoap.org/soap/envelope/","Body"),SecurePart.Modifier.Element));
    securityProperties.addSignaturePart(new SecurePart("cid:Attachments",SecurePart.Modifier.Element));
    securityProperties.setCallbackHandler(new CallbackHandlerImpl());
    securityProperties.loadEncryptionKeystore(this.getClass().getClassLoader().getResource("transmitter.jks"),"default".toCharArray());
    securityProperties.setEncryptionUser("receiver");
    securityProperties.addEncryptionPart(new SecurePart(new QName("http://schemas.xmlsoap.org/soap/envelope/","Body"),SecurePart.Modifier.Content));
    securityProperties.addEncryptionPart(new SecurePart("cid:Attachments",SecurePart.Modifier.Element));
    securityProperties.setAttachmentCallbackHandler(new CallbackHandler(){
      @Override public void handle(      Callback[] callbacks) throws IOException, UnsupportedCallbackException {
        if (callbacks[0] instanceof AttachmentRequestCallback) {
          AttachmentRequestCallback attachmentRequestCallback=(AttachmentRequestCallback)callbacks[0];
          List<Attachment> attachments=new ArrayList<Attachment>();
          attachments.add(attachment[0]);
          attachmentRequestCallback.setAttachments(attachments);
        }
 else {
          AttachmentResultCallback attachmentResultCallback=(AttachmentResultCallback)callbacks[0];
          attachment[0]=attachmentResultCallback.getAttachment();
        }
      }
    }
);
    OutboundWSSec wsSecOut=WSSec.getOutboundWSSec(securityProperties);
    XMLStreamWriter xmlStreamWriter=wsSecOut.processOutMessage(baos,StandardCharsets.UTF_8.name(),new ArrayList<SecurityEvent>());
    XMLStreamReader xmlStreamReader=xmlInputFactory.createXMLStreamReader(this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml"));
    XmlReaderToWriter.writeAll(xmlStreamReader,xmlStreamWriter);
    xmlStreamWriter.close();
  }
{
    WSSSecurityProperties securityProperties=new WSSSecurityProperties();
    securityProperties.loadSignatureVerificationKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
    securityProperties.loadDecryptionKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
    securityProperties.setCallbackHandler(new CallbackHandlerImpl());
    securityProperties.setAttachmentCallbackHandler(new CallbackHandler(){
      @Override public void handle(      Callback[] callbacks) throws IOException, UnsupportedCallbackException {
        if (callbacks[0] instanceof AttachmentRequestCallback) {
          AttachmentRequestCallback attachmentRequestCallback=(AttachmentRequestCallback)callbacks[0];
          if (!attachment[0].getId().equals(attachmentRequestCallback.getAttachmentId())) {
            throw new RuntimeException("wrong attachment requested");
          }
          List<Attachment> attachments=new ArrayList<Attachment>();
          attachments.add(attachment[0]);
          if (attachment[0].getHeaders().size() == 6) {
            attachment[0].addHeader(AttachmentUtils.MIME_HEADER_CONTENT_DESCRIPTION,"Kaputt");
          }
          attachmentRequestCallback.setAttachments(attachments);
        }
 else {
          AttachmentResultCallback attachmentResultCallback=(AttachmentResultCallback)callbacks[0];
          attachment[0]=attachmentResultCallback.getAttachment();
        }
      }
    }
);
    InboundWSSec wsSecIn=WSSec.getInboundWSSec(securityProperties);
    XMLStreamReader xmlStreamReader=wsSecIn.processInMessage(xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray())));
    try {
      StAX2DOM.readDoc(documentBuilderFactory.newDocumentBuilder(),xmlStreamReader);
      Assert.fail("Exception expected");
    }
 catch (    XMLStreamException e) {
      Assert.assertTrue(e.getCause() instanceof XMLSecurityException);
      Assert.assertTrue(e.getCause().getMessage().startsWith("Invalid digest of reference cid:"));
    }
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testInvalidXMLAttachmentCompleteSignature() throws Exception {
  final String attachmentId=UUID.randomUUID().toString();
  final Attachment attachment=new Attachment();
  attachment.setMimeType("text/xml");
  attachment.addHeaders(getHeaders(attachmentId));
  attachment.setId(attachmentId);
  attachment.setSourceStream(new ByteArrayInputStream(SOAPUtil.SAMPLE_SOAP_MSG.getBytes(StandardCharsets.UTF_8)));
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
{
    WSSSecurityProperties securityProperties=new WSSSecurityProperties();
    List<WSSConstants.Action> actions=new ArrayList<WSSConstants.Action>();
    actions.add(WSSConstants.SIGNATURE);
    securityProperties.setActions(actions);
    securityProperties.loadSignatureKeyStore(this.getClass().getClassLoader().getResource("transmitter.jks"),"default".toCharArray());
    securityProperties.setSignatureUser("transmitter");
    securityProperties.addSignaturePart(new SecurePart(new QName("http://schemas.xmlsoap.org/soap/envelope/","Body"),SecurePart.Modifier.Element));
    securityProperties.addSignaturePart(new SecurePart("cid:Attachments",SecurePart.Modifier.Element));
    securityProperties.setCallbackHandler(new CallbackHandlerImpl());
    AttachmentCallbackHandler attachmentCallbackHandler=new AttachmentCallbackHandler(Collections.singletonList(attachment));
    securityProperties.setAttachmentCallbackHandler(attachmentCallbackHandler);
    OutboundWSSec wsSecOut=WSSec.getOutboundWSSec(securityProperties);
    XMLStreamWriter xmlStreamWriter=wsSecOut.processOutMessage(baos,StandardCharsets.UTF_8.name(),new ArrayList<SecurityEvent>());
    XMLStreamReader xmlStreamReader=xmlInputFactory.createXMLStreamReader(this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml"));
    XmlReaderToWriter.writeAll(xmlStreamReader,xmlStreamWriter);
    xmlStreamWriter.close();
  }
{
    attachment.addHeader(AttachmentUtils.MIME_HEADER_CONTENT_DESCRIPTION,"Kaputt");
    WSSSecurityProperties securityProperties=new WSSSecurityProperties();
    securityProperties.loadSignatureVerificationKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
    securityProperties.setAttachmentCallbackHandler(new CallbackHandler(){
      @Override public void handle(      Callback[] callbacks) throws IOException, UnsupportedCallbackException {
        if (callbacks[0] instanceof AttachmentRequestCallback) {
          AttachmentRequestCallback attachmentRequestCallback=(AttachmentRequestCallback)callbacks[0];
          if (!attachment.getId().equals(attachmentRequestCallback.getAttachmentId())) {
            throw new RuntimeException("wrong attachment requested");
          }
          List<Attachment> attachments=new ArrayList<Attachment>();
          attachments.add(attachment);
          attachmentRequestCallback.setAttachments(attachments);
        }
      }
    }
);
    InboundWSSec wsSecIn=WSSec.getInboundWSSec(securityProperties);
    XMLStreamReader xmlStreamReader=wsSecIn.processInMessage(xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray())));
    try {
      StAX2DOM.readDoc(documentBuilderFactory.newDocumentBuilder(),xmlStreamReader);
      Assert.fail("Exception expected");
    }
 catch (    XMLStreamException e) {
      Assert.assertTrue(e.getCause() instanceof XMLSecurityException);
      Assert.assertTrue(e.getCause().getMessage().startsWith("Invalid digest of reference cid:"));
    }
  }
}

</code></pre>

<br>
<pre class="type-3 type-8 type-5 type-1 type-6 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testInvalidXMLAttachmentCmplEncCmplSign() throws Exception {
  final String attachmentId=UUID.randomUUID().toString();
  final Attachment[] attachment=new Attachment[1];
  attachment[0]=new Attachment();
  attachment[0].setMimeType("text/xml");
  attachment[0].addHeaders(getHeaders(attachmentId));
  attachment[0].setId(attachmentId);
  attachment[0].setSourceStream(new ByteArrayInputStream(SOAPUtil.SAMPLE_SOAP_MSG.getBytes(StandardCharsets.UTF_8)));
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
{
    WSSSecurityProperties securityProperties=new WSSSecurityProperties();
    List<WSSConstants.Action> actions=new ArrayList<WSSConstants.Action>();
    actions.add(WSSConstants.ENCRYPT);
    actions.add(WSSConstants.SIGNATURE);
    securityProperties.setActions(actions);
    securityProperties.loadSignatureKeyStore(this.getClass().getClassLoader().getResource("transmitter.jks"),"default".toCharArray());
    securityProperties.setSignatureUser("transmitter");
    securityProperties.addSignaturePart(new SecurePart(new QName("http://schemas.xmlsoap.org/soap/envelope/","Body"),SecurePart.Modifier.Element));
    securityProperties.addSignaturePart(new SecurePart("cid:Attachments",SecurePart.Modifier.Element));
    securityProperties.setCallbackHandler(new CallbackHandlerImpl());
    securityProperties.loadEncryptionKeystore(this.getClass().getClassLoader().getResource("transmitter.jks"),"default".toCharArray());
    securityProperties.setEncryptionUser("receiver");
    securityProperties.addEncryptionPart(new SecurePart(new QName("http://schemas.xmlsoap.org/soap/envelope/","Body"),SecurePart.Modifier.Content));
    securityProperties.addEncryptionPart(new SecurePart("cid:Attachments",SecurePart.Modifier.Element));
    securityProperties.setAttachmentCallbackHandler(new CallbackHandler(){
      @Override public void handle(      Callback[] callbacks) throws IOException, UnsupportedCallbackException {
        if (callbacks[0] instanceof AttachmentRequestCallback) {
          AttachmentRequestCallback attachmentRequestCallback=(AttachmentRequestCallback)callbacks[0];
          List<Attachment> attachments=new ArrayList<Attachment>();
          attachments.add(attachment[0]);
          attachmentRequestCallback.setAttachments(attachments);
        }
 else {
          AttachmentResultCallback attachmentResultCallback=(AttachmentResultCallback)callbacks[0];
          attachment[0]=attachmentResultCallback.getAttachment();
        }
      }
    }
);
    OutboundWSSec wsSecOut=WSSec.getOutboundWSSec(securityProperties);
    XMLStreamWriter xmlStreamWriter=wsSecOut.processOutMessage(baos,StandardCharsets.UTF_8.name(),new ArrayList<SecurityEvent>());
    XMLStreamReader xmlStreamReader=xmlInputFactory.createXMLStreamReader(this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml"));
    XmlReaderToWriter.writeAll(xmlStreamReader,xmlStreamWriter);
    xmlStreamWriter.close();
    Document securedDoc=documentBuilderFactory.newDocumentBuilder().parse(new ByteArrayInputStream(baos.toByteArray()));
    NodeList securityHeaderElement=securedDoc.getElementsByTagNameNS(WSConstants.WSSE_NS,"Security");
    Assert.assertEquals(1,securityHeaderElement.getLength());
    NodeList childs=securityHeaderElement.item(0).getChildNodes();
    Assert.assertEquals(3,childs.getLength());
    Assert.assertEquals(childs.item(0).getLocalName(),"Signature");
    Assert.assertEquals(childs.item(1).getLocalName(),"EncryptedKey");
    Assert.assertEquals(childs.item(2).getLocalName(),"EncryptedData");
  }
{
    final PushbackInputStream pis=new PushbackInputStream(attachment[0].getSourceStream(),1);
    pis.unread('K');
    attachment[0].setSourceStream(pis);
    WSSSecurityProperties securityProperties=new WSSSecurityProperties();
    securityProperties.loadSignatureVerificationKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
    securityProperties.loadDecryptionKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
    securityProperties.setCallbackHandler(new CallbackHandlerImpl());
    securityProperties.setAttachmentCallbackHandler(new CallbackHandler(){
      @Override public void handle(      Callback[] callbacks) throws IOException, UnsupportedCallbackException {
        if (callbacks[0] instanceof AttachmentRequestCallback) {
          AttachmentRequestCallback attachmentRequestCallback=(AttachmentRequestCallback)callbacks[0];
          if (!attachment[0].getId().equals(attachmentRequestCallback.getAttachmentId())) {
            throw new RuntimeException("wrong attachment requested");
          }
          List<Attachment> attachments=new ArrayList<Attachment>();
          attachments.add(attachment[0]);
          attachmentRequestCallback.setAttachments(attachments);
        }
 else {
          AttachmentResultCallback attachmentResultCallback=(AttachmentResultCallback)callbacks[0];
          attachment[0]=attachmentResultCallback.getAttachment();
        }
      }
    }
);
    InboundWSSec wsSecIn=WSSec.getInboundWSSec(securityProperties);
    XMLStreamReader xmlStreamReader=wsSecIn.processInMessage(xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray())));
    try {
      StAX2DOM.readDoc(documentBuilderFactory.newDocumentBuilder(),xmlStreamReader);
      Assert.fail("Exception expected");
    }
 catch (    XMLStreamException e) {
      Assert.assertNotNull(e.getMessage());
    }
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.wss4j.stax.test.EncDecryptionTest </h4><pre class="type-8 type-7 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testElementoEncryptNotFound() throws Exception {
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
{
    WSSSecurityProperties securityProperties=new WSSSecurityProperties();
    List<WSSConstants.Action> actions=new ArrayList<WSSConstants.Action>();
    actions.add(WSSConstants.ENCRYPT);
    securityProperties.setActions(actions);
    securityProperties.loadEncryptionKeystore(this.getClass().getClassLoader().getResource("transmitter.jks"),"default".toCharArray());
    securityProperties.setEncryptionUser("receiver");
    securityProperties.setTokenUser("transmitter");
    securityProperties.setCallbackHandler(new CallbackHandlerImpl());
    securityProperties.addEncryptionPart(new SecurePart(new QName(WSSConstants.NS_WSSE10,"UsernameToken"),SecurePart.Modifier.Element));
    securityProperties.addEncryptionPart(new SecurePart(new QName(WSSConstants.NS_SOAP11,"Body"),SecurePart.Modifier.Content));
    OutboundWSSec wsSecOut=WSSec.getOutboundWSSec(securityProperties);
    XMLStreamWriter xmlStreamWriter=wsSecOut.processOutMessage(baos,StandardCharsets.UTF_8.name(),new ArrayList<SecurityEvent>());
    XMLStreamReader xmlStreamReader=xmlInputFactory.createXMLStreamReader(this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml"));
    try {
      XmlReaderToWriter.writeAll(xmlStreamReader,xmlStreamWriter);
      xmlStreamWriter.close();
      Assert.fail("Exception expected");
    }
 catch (    XMLStreamException e) {
      Assert.assertTrue(e.getCause() instanceof XMLSecurityException);
      Assert.assertEquals("Part to encrypt not found: {http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd}UsernameToken",e.getCause().getMessage());
    }
  }
}

</code></pre>

<br>
<pre class="type-3 type-11 type-15 type-8 type-5 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions in iterations
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testEncDecryptionUseThisCert() throws Exception {
  ByteArrayOutputStream baos;
{
    WSSSecurityProperties securityProperties=new WSSSecurityProperties();
    List<WSSConstants.Action> actions=new ArrayList<WSSConstants.Action>();
    actions.add(WSSConstants.ENCRYPT);
    securityProperties.setActions(actions);
    KeyStore keyStore=KeyStore.getInstance("jks");
    keyStore.load(this.getClass().getClassLoader().getResourceAsStream("transmitter.jks"),"default".toCharArray());
    securityProperties.setEncryptionUseThisCertificate((X509Certificate)keyStore.getCertificate("receiver"));
    InputStream sourceDocument=this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml");
    baos=doOutboundSecurity(securityProperties,sourceDocument);
    Document document=documentBuilderFactory.newDocumentBuilder().parse(new ByteArrayInputStream(baos.toByteArray()));
    NodeList nodeList=document.getElementsByTagNameNS(WSSConstants.TAG_xenc_EncryptedKey.getNamespaceURI(),WSSConstants.TAG_xenc_EncryptedKey.getLocalPart());
    Assert.assertEquals(nodeList.item(0).getParentNode().getLocalName(),WSSConstants.TAG_WSSE_SECURITY.getLocalPart());
    nodeList=document.getElementsByTagNameNS(WSSConstants.TAG_xenc_DataReference.getNamespaceURI(),WSSConstants.TAG_xenc_DataReference.getLocalPart());
    Assert.assertEquals(nodeList.getLength(),1);
    nodeList=document.getElementsByTagNameNS(WSSConstants.TAG_xenc_EncryptedData.getNamespaceURI(),WSSConstants.TAG_xenc_EncryptedData.getLocalPart());
    Assert.assertEquals(nodeList.getLength(),1);
    Assert.assertEquals(nodeList.item(0).getParentNode().getLocalName(),"Body");
    NodeList childNodes=nodeList.item(0).getParentNode().getChildNodes();
    for (int i=0; i < childNodes.getLength(); i++) {
      Node child=childNodes.item(i);
      if (child.getNodeType() == Node.TEXT_NODE) {
        Assert.assertEquals(child.getTextContent().trim(),"");
      }
 else       if (child.getNodeType() == Node.ELEMENT_NODE) {
        Assert.assertEquals(child,nodeList.item(0));
      }
 else {
        Assert.fail("Unexpected Node encountered");
      }
    }
  }
{
    WSSSecurityProperties securityProperties=new WSSSecurityProperties();
    securityProperties.loadDecryptionKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
    securityProperties.setCallbackHandler(new org.apache.wss4j.stax.test.CallbackHandlerImpl());
    Document document=doInboundSecurity(securityProperties,new ByteArrayInputStream(baos.toByteArray()));
    NodeList nodeList=document.getElementsByTagNameNS(WSSConstants.TAG_xenc_EncryptedKey.getNamespaceURI(),WSSConstants.TAG_xenc_EncryptedKey.getLocalPart());
    Assert.assertEquals(nodeList.getLength(),1);
    Assert.assertEquals(nodeList.item(0).getParentNode().getLocalName(),WSSConstants.TAG_WSSE_SECURITY.getLocalPart());
    nodeList=document.getElementsByTagNameNS(WSSConstants.TAG_xenc_EncryptedData.getNamespaceURI(),WSSConstants.TAG_xenc_EncryptedData.getLocalPart());
    Assert.assertEquals(nodeList.getLength(),0);
  }
}

</code></pre>

<br>
<pre class="type-3 type-11 type-15 type-8 type-5 type-1 type-6 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions in iterations
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * rsa-oaep, Digest:SHA384, MGF:SHA1, PSource: None
 */
@Test public void testKeyWrappingRSAOAEPAES192GCMSHA384MGF1sha384Outbound() throws Exception {
  try {
    Security.addProvider(new BouncyCastleProvider());
    ByteArrayOutputStream baos;
{
      WSSSecurityProperties securityProperties=new WSSSecurityProperties();
      List<WSSConstants.Action> actions=new ArrayList<WSSConstants.Action>();
      actions.add(WSSConstants.ENCRYPT);
      securityProperties.setActions(actions);
      securityProperties.loadEncryptionKeystore(this.getClass().getClassLoader().getResource("transmitter.jks"),"default".toCharArray());
      securityProperties.setEncryptionUser("receiver");
      securityProperties.setEncryptionSymAlgorithm("http://www.w3.org/2009/xmlenc11#aes192-gcm");
      securityProperties.setEncryptionKeyTransportAlgorithm("http://www.w3.org/2009/xmlenc11#rsa-oaep");
      securityProperties.setEncryptionKeyTransportDigestAlgorithm("http://www.w3.org/2001/04/xmldsig-more#sha384");
      securityProperties.setEncryptionKeyTransportMGFAlgorithm("http://www.w3.org/2009/xmlenc11#mgf1sha384");
      InputStream sourceDocument=this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml");
      baos=doOutboundSecurity(securityProperties,sourceDocument);
      Document document=documentBuilderFactory.newDocumentBuilder().parse(new ByteArrayInputStream(baos.toByteArray()));
      NodeList nodeList=document.getElementsByTagNameNS(WSSConstants.TAG_xenc_EncryptedKey.getNamespaceURI(),WSSConstants.TAG_xenc_EncryptedKey.getLocalPart());
      Assert.assertEquals(nodeList.item(0).getParentNode().getLocalName(),WSSConstants.TAG_WSSE_SECURITY.getLocalPart());
      XPathExpression xPathExpression=getXPath("/soap:Envelope/soap:Header/wsse:Security/xenc:EncryptedKey/xenc:EncryptionMethod[@Algorithm='http://www.w3.org/2009/xmlenc11#rsa-oaep']");
      Node node=(Node)xPathExpression.evaluate(document,XPathConstants.NODE);
      Assert.assertNotNull(node);
      xPathExpression=getXPath("/soap:Envelope/soap:Header/wsse:Security/xenc:EncryptedKey/xenc:EncryptionMethod/dsig:DigestMethod[@Algorithm='http://www.w3.org/2001/04/xmldsig-more#sha384']");
      node=(Node)xPathExpression.evaluate(document,XPathConstants.NODE);
      Assert.assertNotNull(node);
      xPathExpression=getXPath("/soap:Envelope/soap:Header/wsse:Security/xenc:EncryptedKey/xenc:EncryptionMethod/xenc11:MGF[@Algorithm='http://www.w3.org/2009/xmlenc11#mgf1sha384']");
      node=(Node)xPathExpression.evaluate(document,XPathConstants.NODE);
      Assert.assertNotNull(node);
      nodeList=document.getElementsByTagNameNS(WSSConstants.TAG_xenc_DataReference.getNamespaceURI(),WSSConstants.TAG_xenc_DataReference.getLocalPart());
      Assert.assertEquals(nodeList.getLength(),1);
      nodeList=document.getElementsByTagNameNS(WSSConstants.TAG_xenc_EncryptedData.getNamespaceURI(),WSSConstants.TAG_xenc_EncryptedData.getLocalPart());
      Assert.assertEquals(nodeList.getLength(),1);
      xPathExpression=getXPath("/soap:Envelope/soap:Body/xenc:EncryptedData/xenc:EncryptionMethod[@Algorithm='http://www.w3.org/2009/xmlenc11#aes192-gcm']");
      node=(Node)xPathExpression.evaluate(document,XPathConstants.NODE);
      Assert.assertNotNull(node);
      Assert.assertEquals(node.getParentNode().getParentNode().getLocalName(),"Body");
      NodeList childNodes=node.getParentNode().getParentNode().getChildNodes();
      for (int i=0; i < childNodes.getLength(); i++) {
        Node child=childNodes.item(i);
        if (child.getNodeType() == Node.TEXT_NODE) {
          Assert.assertEquals(child.getTextContent().trim(),"");
        }
 else         if (child.getNodeType() == Node.ELEMENT_NODE) {
          Assert.assertEquals(child,nodeList.item(0));
        }
 else {
          Assert.fail("Unexpected Node encountered");
        }
      }
    }
{
      String action=WSHandlerConstants.ENCRYPT;
      doInboundSecurityWithWSS4J_1(documentBuilderFactory.newDocumentBuilder().parse(new ByteArrayInputStream(baos.toByteArray())),action);
    }
  }
  finally {
    Security.removeProvider(BouncyCastleProvider.PROVIDER_NAME);
  }
}

</code></pre>

<br>
<pre class="type-3 type-11 type-15 type-8 type-5 type-1 type-6 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions in iterations
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testEncDecryptionCryptoPropertiesOutbound() throws Exception {
  ByteArrayOutputStream baos;
{
    WSSSecurityProperties securityProperties=new WSSSecurityProperties();
    List<WSSConstants.Action> actions=new ArrayList<WSSConstants.Action>();
    actions.add(WSSConstants.ENCRYPT);
    securityProperties.setActions(actions);
    Properties properties=CryptoFactory.getProperties("transmitter-crypto.properties",this.getClass().getClassLoader());
    securityProperties.setEncryptionCryptoProperties(properties);
    securityProperties.setEncryptionUser("receiver");
    InputStream sourceDocument=this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml");
    baos=doOutboundSecurity(securityProperties,sourceDocument);
    Document document=documentBuilderFactory.newDocumentBuilder().parse(new ByteArrayInputStream(baos.toByteArray()));
    NodeList nodeList=document.getElementsByTagNameNS(WSSConstants.TAG_xenc_EncryptedKey.getNamespaceURI(),WSSConstants.TAG_xenc_EncryptedKey.getLocalPart());
    Assert.assertEquals(nodeList.item(0).getParentNode().getLocalName(),WSSConstants.TAG_WSSE_SECURITY.getLocalPart());
    XPathExpression xPathExpression=getXPath("/soap:Envelope/soap:Header/wsse:Security/xenc:EncryptedKey/xenc:EncryptionMethod[@Algorithm='http://www.w3.org/2001/04/xmlenc#rsa-oaep-mgf1p']");
    Node node=(Node)xPathExpression.evaluate(document,XPathConstants.NODE);
    Assert.assertNotNull(node);
    nodeList=document.getElementsByTagNameNS(WSSConstants.TAG_xenc_DataReference.getNamespaceURI(),WSSConstants.TAG_xenc_DataReference.getLocalPart());
    Assert.assertEquals(nodeList.getLength(),1);
    nodeList=document.getElementsByTagNameNS(WSSConstants.TAG_xenc_EncryptedData.getNamespaceURI(),WSSConstants.TAG_xenc_EncryptedData.getLocalPart());
    Assert.assertEquals(nodeList.getLength(),1);
    xPathExpression=getXPath("/soap:Envelope/soap:Body/xenc:EncryptedData/xenc:EncryptionMethod[@Algorithm='http://www.w3.org/2001/04/xmlenc#aes256-cbc']");
    node=(Node)xPathExpression.evaluate(document,XPathConstants.NODE);
    Assert.assertNotNull(node);
    Assert.assertEquals(node.getParentNode().getParentNode().getLocalName(),"Body");
    NodeList childNodes=node.getParentNode().getParentNode().getChildNodes();
    for (int i=0; i < childNodes.getLength(); i++) {
      Node child=childNodes.item(i);
      if (child.getNodeType() == Node.TEXT_NODE) {
        Assert.assertEquals(child.getTextContent().trim(),"");
      }
 else       if (child.getNodeType() == Node.ELEMENT_NODE) {
        Assert.assertEquals(child,nodeList.item(0));
      }
 else {
        Assert.fail("Unexpected Node encountered");
      }
    }
  }
{
    String action=WSHandlerConstants.ENCRYPT;
    doInboundSecurityWithWSS4J(documentBuilderFactory.newDocumentBuilder().parse(new ByteArrayInputStream(baos.toByteArray())),action);
  }
}

</code></pre>

<br>
<pre class="type-3 type-11 type-15 type-8 type-5 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions in iterations
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testEncDecryptionPartsContentOutbound() throws Exception {
  ByteArrayOutputStream baos;
{
    WSSSecurityProperties securityProperties=new WSSSecurityProperties();
    List<WSSConstants.Action> actions=new ArrayList<WSSConstants.Action>();
    actions.add(WSSConstants.ENCRYPT);
    securityProperties.setActions(actions);
    securityProperties.loadEncryptionKeystore(this.getClass().getClassLoader().getResource("transmitter.jks"),"default".toCharArray());
    securityProperties.setEncryptionUser("receiver");
    securityProperties.addEncryptionPart(new SecurePart(new QName("http://www.w3.org/1999/XMLSchema","complexType"),SecurePart.Modifier.Content));
    InputStream sourceDocument=this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml");
    baos=doOutboundSecurity(securityProperties,sourceDocument);
    Document document=documentBuilderFactory.newDocumentBuilder().parse(new ByteArrayInputStream(baos.toByteArray()));
    NodeList nodeList=document.getElementsByTagNameNS(WSSConstants.TAG_xenc_EncryptedKey.getNamespaceURI(),WSSConstants.TAG_xenc_EncryptedKey.getLocalPart());
    Assert.assertEquals(nodeList.item(0).getParentNode().getLocalName(),WSSConstants.TAG_WSSE_SECURITY.getLocalPart());
    nodeList=document.getElementsByTagNameNS(WSSConstants.TAG_xenc_DataReference.getNamespaceURI(),WSSConstants.TAG_xenc_DataReference.getLocalPart());
    Assert.assertEquals(nodeList.getLength(),25);
    nodeList=document.getElementsByTagNameNS(WSSConstants.TAG_xenc_EncryptedData.getNamespaceURI(),WSSConstants.TAG_xenc_EncryptedData.getLocalPart());
    Assert.assertEquals(nodeList.getLength(),25);
    for (int i=0; i < nodeList.getLength(); i++) {
      Assert.assertEquals(nodeList.item(i).getParentNode().getLocalName(),"complexType");
      Assert.assertEquals(nodeList.item(i).getParentNode().getNamespaceURI(),"http://www.w3.org/1999/XMLSchema");
      NodeList childNodes=nodeList.item(i).getParentNode().getChildNodes();
      for (int j=0; j < childNodes.getLength(); j++) {
        Node child=childNodes.item(j);
        if (child.getNodeType() == Node.TEXT_NODE) {
          Assert.assertEquals(child.getTextContent().trim(),"");
        }
 else         if (child.getNodeType() == Node.ELEMENT_NODE) {
          Assert.assertEquals(child,nodeList.item(i));
        }
 else {
          Assert.fail("Unexpected Node encountered");
        }
      }
    }
  }
{
    String action=WSHandlerConstants.ENCRYPT;
    doInboundSecurityWithWSS4J(documentBuilderFactory.newDocumentBuilder().parse(new ByteArrayInputStream(baos.toByteArray())),action);
  }
}

</code></pre>

<br>
<pre class="type-3 type-8 type-7 type-6 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testInboundRequiredAlgorithms() throws Exception {
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
{
    InputStream sourceDocument=this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml");
    String action=WSHandlerConstants.ENCRYPT;
    Document securedDocument=doOutboundSecurityWithWSS4J(sourceDocument,action,new Properties());
    XPathExpression xPathExpression=getXPath("/soap:Envelope/soap:Header/wsse:Security/xenc:EncryptedKey/xenc:EncryptionMethod[@Algorithm='http://www.w3.org/2001/04/xmlenc#rsa-oaep-mgf1p']");
    Node node=(Node)xPathExpression.evaluate(securedDocument,XPathConstants.NODE);
    Assert.assertNotNull(node);
    Transformer transformer=TRANSFORMER_FACTORY.newTransformer();
    transformer.transform(new DOMSource(securedDocument),new StreamResult(baos));
  }
{
    WSSSecurityProperties securityProperties=new WSSSecurityProperties();
    securityProperties.setEncryptionKeyTransportAlgorithm(WSSConstants.NS_XENC_RSAOAEPMGF1P);
    securityProperties.setEncryptionSymAlgorithm(WSSConstants.NS_XENC_AES128);
    securityProperties.loadDecryptionKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
    securityProperties.setCallbackHandler(new CallbackHandlerImpl());
    doInboundSecurity(securityProperties,xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray())),null);
  }
{
    WSSSecurityProperties securityProperties=new WSSSecurityProperties();
    securityProperties.setEncryptionKeyTransportAlgorithm(WSSConstants.NS_XENC_RSA15);
    securityProperties.loadDecryptionKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
    securityProperties.setCallbackHandler(new CallbackHandlerImpl());
    try {
      doInboundSecurity(securityProperties,xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray())),null);
      Assert.fail("Failure expected on the wrong key transport algorithm");
    }
 catch (    XMLStreamException e) {
      Assert.assertTrue(e.getCause() instanceof WSSecurityException);
    }
  }
{
    WSSSecurityProperties securityProperties=new WSSSecurityProperties();
    securityProperties.setEncryptionSymAlgorithm(WSSConstants.NS_XENC_TRIPLE_DES);
    securityProperties.loadDecryptionKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
    securityProperties.setCallbackHandler(new CallbackHandlerImpl());
    try {
      doInboundSecurity(securityProperties,xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray())),null);
      Assert.fail("Failure expected on the wrong key transport algorithm");
    }
 catch (    XMLStreamException e) {
      Assert.assertTrue(e.getCause() instanceof WSSecurityException);
    }
  }
}

</code></pre>

<br>
<pre class="type-3 type-11 type-15 type-8 type-5 type-1 type-6 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions in iterations
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * rsa-oaep-mgf1p, Digest:SHA256, MGF:SHA1, PSource: None
 */
@Test public void testKeyWrappingRSAOAEPMGF1AESGCM128Outbound() throws Exception {
  try {
    Security.addProvider(new BouncyCastleProvider());
    ByteArrayOutputStream baos;
{
      WSSSecurityProperties securityProperties=new WSSSecurityProperties();
      List<WSSConstants.Action> actions=new ArrayList<WSSConstants.Action>();
      actions.add(WSSConstants.ENCRYPT);
      securityProperties.setActions(actions);
      securityProperties.loadEncryptionKeystore(this.getClass().getClassLoader().getResource("transmitter.jks"),"default".toCharArray());
      securityProperties.setEncryptionUser("receiver");
      securityProperties.setEncryptionSymAlgorithm("http://www.w3.org/2009/xmlenc11#aes128-gcm");
      securityProperties.setEncryptionKeyTransportAlgorithm("http://www.w3.org/2001/04/xmlenc#rsa-oaep-mgf1p");
      InputStream sourceDocument=this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml");
      baos=doOutboundSecurity(securityProperties,sourceDocument);
      Document document=documentBuilderFactory.newDocumentBuilder().parse(new ByteArrayInputStream(baos.toByteArray()));
      NodeList nodeList=document.getElementsByTagNameNS(WSSConstants.TAG_xenc_EncryptedKey.getNamespaceURI(),WSSConstants.TAG_xenc_EncryptedKey.getLocalPart());
      Assert.assertEquals(nodeList.item(0).getParentNode().getLocalName(),WSSConstants.TAG_WSSE_SECURITY.getLocalPart());
      XPathExpression xPathExpression=getXPath("/soap:Envelope/soap:Header/wsse:Security/xenc:EncryptedKey/xenc:EncryptionMethod[@Algorithm='http://www.w3.org/2001/04/xmlenc#rsa-oaep-mgf1p']");
      Node node=(Node)xPathExpression.evaluate(document,XPathConstants.NODE);
      Assert.assertNotNull(node);
      nodeList=document.getElementsByTagNameNS(WSSConstants.TAG_xenc_DataReference.getNamespaceURI(),WSSConstants.TAG_xenc_DataReference.getLocalPart());
      Assert.assertEquals(nodeList.getLength(),1);
      nodeList=document.getElementsByTagNameNS(WSSConstants.TAG_xenc_EncryptedData.getNamespaceURI(),WSSConstants.TAG_xenc_EncryptedData.getLocalPart());
      Assert.assertEquals(nodeList.getLength(),1);
      xPathExpression=getXPath("/soap:Envelope/soap:Body/xenc:EncryptedData/xenc:EncryptionMethod[@Algorithm='http://www.w3.org/2009/xmlenc11#aes128-gcm']");
      node=(Node)xPathExpression.evaluate(document,XPathConstants.NODE);
      Assert.assertNotNull(node);
      Assert.assertEquals(node.getParentNode().getParentNode().getLocalName(),"Body");
      NodeList childNodes=node.getParentNode().getParentNode().getChildNodes();
      for (int i=0; i < childNodes.getLength(); i++) {
        Node child=childNodes.item(i);
        if (child.getNodeType() == Node.TEXT_NODE) {
          Assert.assertEquals(child.getTextContent().trim(),"");
        }
 else         if (child.getNodeType() == Node.ELEMENT_NODE) {
          Assert.assertEquals(child,nodeList.item(0));
        }
 else {
          Assert.fail("Unexpected Node encountered");
        }
      }
    }
{
      String action=WSHandlerConstants.ENCRYPT;
      doInboundSecurityWithWSS4J(documentBuilderFactory.newDocumentBuilder().parse(new ByteArrayInputStream(baos.toByteArray())),action);
    }
  }
  finally {
    Security.removeProvider(BouncyCastleProvider.PROVIDER_NAME);
  }
}

</code></pre>

<br>
<pre class="type-3 type-11 type-15 type-8 type-5 type-1 type-6 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions in iterations
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test @SuppressWarnings("unchecked") public void testCompressedEncDecryption() throws Exception {
  Init.init(WSSec.class.getClassLoader().getResource("wss/wss-config.xml").toURI(),WSSec.class);
  Field algorithmsClassMapField=TransformerAlgorithmMapper.class.getDeclaredField("algorithmsClassMapOut");
  algorithmsClassMapField.setAccessible(true);
  Map<String,Class<?>> map=(Map<String,Class<?>>)algorithmsClassMapField.get(null);
  map.put("http://www.apache.org/2012/04/xmlsec/gzip",GzipCompressorOutputStream.class);
  algorithmsClassMapField=TransformerAlgorithmMapper.class.getDeclaredField("algorithmsClassMapIn");
  algorithmsClassMapField.setAccessible(true);
  map=(Map<String,Class<?>>)algorithmsClassMapField.get(null);
  map.put("http://www.apache.org/2012/04/xmlsec/gzip",GzipCompressorInputStream.class);
  ByteArrayOutputStream baos;
{
    WSSSecurityProperties securityProperties=new WSSSecurityProperties();
    List<WSSConstants.Action> actions=new ArrayList<WSSConstants.Action>();
    actions.add(WSSConstants.ENCRYPT);
    securityProperties.setActions(actions);
    securityProperties.loadEncryptionKeystore(this.getClass().getClassLoader().getResource("transmitter.jks"),"default".toCharArray());
    securityProperties.setEncryptionUser("receiver");
    securityProperties.setEncryptionCompressionAlgorithm("http://www.apache.org/2012/04/xmlsec/gzip");
    InputStream sourceDocument=this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml");
    baos=doOutboundSecurity(securityProperties,sourceDocument);
    Document document=documentBuilderFactory.newDocumentBuilder().parse(new ByteArrayInputStream(baos.toByteArray()));
    NodeList nodeList=document.getElementsByTagNameNS(WSSConstants.TAG_xenc_EncryptedKey.getNamespaceURI(),WSSConstants.TAG_xenc_EncryptedKey.getLocalPart());
    Assert.assertEquals(nodeList.item(0).getParentNode().getLocalName(),WSSConstants.TAG_WSSE_SECURITY.getLocalPart());
    XPathExpression xPathExpression=getXPath("/soap:Envelope/soap:Header/wsse:Security/xenc:EncryptedKey/xenc:EncryptionMethod[@Algorithm='http://www.w3.org/2001/04/xmlenc#rsa-oaep-mgf1p']");
    Node node=(Node)xPathExpression.evaluate(document,XPathConstants.NODE);
    Assert.assertNotNull(node);
    nodeList=document.getElementsByTagNameNS(WSSConstants.TAG_xenc_DataReference.getNamespaceURI(),WSSConstants.TAG_xenc_DataReference.getLocalPart());
    Assert.assertEquals(nodeList.getLength(),1);
    nodeList=document.getElementsByTagNameNS(WSSConstants.TAG_xenc_EncryptedData.getNamespaceURI(),WSSConstants.TAG_xenc_EncryptedData.getLocalPart());
    Assert.assertEquals(nodeList.getLength(),1);
    xPathExpression=getXPath("/soap:Envelope/soap:Body/xenc:EncryptedData/xenc:EncryptionMethod[@Algorithm='http://www.w3.org/2001/04/xmlenc#aes256-cbc']");
    node=(Node)xPathExpression.evaluate(document,XPathConstants.NODE);
    Assert.assertNotNull(node);
    Assert.assertEquals(node.getParentNode().getParentNode().getLocalName(),"Body");
    NodeList childNodes=node.getParentNode().getParentNode().getChildNodes();
    for (int i=0; i < childNodes.getLength(); i++) {
      Node child=childNodes.item(i);
      if (child.getNodeType() == Node.TEXT_NODE) {
        Assert.assertEquals(child.getTextContent().trim(),"");
      }
 else       if (child.getNodeType() == Node.ELEMENT_NODE) {
        Assert.assertEquals(child,nodeList.item(0));
      }
 else {
        Assert.fail("Unexpected Node encountered");
      }
    }
  }
{
    WSSSecurityProperties securityProperties=new WSSSecurityProperties();
    securityProperties.loadDecryptionKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
    securityProperties.setCallbackHandler(new CallbackHandlerImpl());
    WSSecurityEventConstants.Event[] expectedSecurityEvents=new WSSecurityEventConstants.Event[]{WSSecurityEventConstants.AlgorithmSuite,WSSecurityEventConstants.AlgorithmSuite,WSSecurityEventConstants.X509Token,WSSecurityEventConstants.ENCRYPTED_PART,WSSecurityEventConstants.OPERATION};
    final TestSecurityEventListener securityEventListener=new TestSecurityEventListener(expectedSecurityEvents);
    Document document=doInboundSecurity(securityProperties,xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray())),securityEventListener);
    NodeList nodeList=document.getElementsByTagNameNS(WSSConstants.TAG_xenc_EncryptedKey.getNamespaceURI(),WSSConstants.TAG_xenc_EncryptedKey.getLocalPart());
    Assert.assertEquals(nodeList.getLength(),1);
    Assert.assertEquals(nodeList.item(0).getParentNode().getLocalName(),WSSConstants.TAG_WSSE_SECURITY.getLocalPart());
    nodeList=document.getElementsByTagNameNS(WSSConstants.TAG_xenc_EncryptedData.getNamespaceURI(),WSSConstants.TAG_xenc_EncryptedData.getLocalPart());
    Assert.assertEquals(nodeList.getLength(),0);
    securityEventListener.compare();
    List<SecurityEvent> receivedSecurityEvents=securityEventListener.getReceivedSecurityEvents();
    for (int i=0; i < receivedSecurityEvents.size(); i++) {
      SecurityEvent securityEvent=receivedSecurityEvents.get(i);
      if (securityEvent.getSecurityEventType() == WSSecurityEventConstants.OPERATION) {
        OperationSecurityEvent operationSecurityEvent=(OperationSecurityEvent)securityEvent;
        Assert.assertEquals(operationSecurityEvent.getOperation(),new QName("http://schemas.xmlsoap.org/wsdl/","definitions"));
      }
 else       if (securityEvent.getSecurityEventType() == WSSecurityEventConstants.ENCRYPTED_PART) {
        EncryptedPartSecurityEvent encryptedPartSecurityEvent=(EncryptedPartSecurityEvent)securityEvent;
        Assert.assertNotNull(encryptedPartSecurityEvent.getXmlSecEvent());
        Assert.assertNotNull(encryptedPartSecurityEvent.getSecurityToken());
        Assert.assertNotNull(encryptedPartSecurityEvent.getElementPath());
        final QName expectedElementName=new QName("http://schemas.xmlsoap.org/soap/envelope/","Body");
        Assert.assertEquals(encryptedPartSecurityEvent.getXmlSecEvent().asStartElement().getName(),expectedElementName);
        Assert.assertEquals(encryptedPartSecurityEvent.getElementPath().size(),2);
        Assert.assertEquals(encryptedPartSecurityEvent.getElementPath().get(encryptedPartSecurityEvent.getElementPath().size() - 1),expectedElementName);
      }
    }
    EncryptedPartSecurityEvent encryptedPartSecurityEvent=securityEventListener.getSecurityEvent(WSSecurityEventConstants.ENCRYPTED_PART);
    OperationSecurityEvent operationSecurityEvent=securityEventListener.getSecurityEvent(WSSecurityEventConstants.OPERATION);
    String encryptedPartCorrelationID=encryptedPartSecurityEvent.getCorrelationID();
    String operationCorrelationID=operationSecurityEvent.getCorrelationID();
    List<SecurityEvent> operationSecurityEvents=new ArrayList<SecurityEvent>();
    List<SecurityEvent> encryptedPartSecurityEvents=new ArrayList<SecurityEvent>();
    List<SecurityEvent> securityEvents=securityEventListener.getReceivedSecurityEvents();
    for (int i=0; i < securityEvents.size(); i++) {
      SecurityEvent securityEvent=securityEvents.get(i);
      if (securityEvent.getCorrelationID().equals(encryptedPartCorrelationID)) {
        encryptedPartSecurityEvents.add(securityEvent);
      }
 else       if (securityEvent.getCorrelationID().equals(operationCorrelationID)) {
        operationSecurityEvents.add(securityEvent);
      }
    }
    Assert.assertEquals(4,encryptedPartSecurityEvents.size());
    Assert.assertEquals(securityEventListener.getReceivedSecurityEvents().size(),operationSecurityEvents.size() + encryptedPartSecurityEvents.size());
  }
}

</code></pre>

<br>
<pre class="type-3 type-11 type-15 type-8 type-5 type-1 type-6 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions in iterations
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testEncDecryptionPropertiesOutbound() throws Exception {
  ByteArrayOutputStream baos;
{
    Map<String,Object> config=new HashMap<String,Object>();
    config.put(ConfigurationConstants.ACTION,ConfigurationConstants.ENCRYPT);
    config.put(ConfigurationConstants.ENCRYPTION_USER,"receiver");
    config.put(ConfigurationConstants.ENC_PROP_FILE,"transmitter-crypto.properties");
    InputStream sourceDocument=this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml");
    baos=doOutboundSecurity(config,sourceDocument);
    Document document=documentBuilderFactory.newDocumentBuilder().parse(new ByteArrayInputStream(baos.toByteArray()));
    NodeList nodeList=document.getElementsByTagNameNS(WSSConstants.TAG_xenc_EncryptedKey.getNamespaceURI(),WSSConstants.TAG_xenc_EncryptedKey.getLocalPart());
    Assert.assertEquals(nodeList.item(0).getParentNode().getLocalName(),WSSConstants.TAG_WSSE_SECURITY.getLocalPart());
    XPathExpression xPathExpression=getXPath("/soap:Envelope/soap:Header/wsse:Security/xenc:EncryptedKey/xenc:EncryptionMethod[@Algorithm='http://www.w3.org/2001/04/xmlenc#rsa-oaep-mgf1p']");
    Node node=(Node)xPathExpression.evaluate(document,XPathConstants.NODE);
    Assert.assertNotNull(node);
    nodeList=document.getElementsByTagNameNS(WSSConstants.TAG_xenc_DataReference.getNamespaceURI(),WSSConstants.TAG_xenc_DataReference.getLocalPart());
    Assert.assertEquals(nodeList.getLength(),1);
    nodeList=document.getElementsByTagNameNS(WSSConstants.TAG_xenc_EncryptedData.getNamespaceURI(),WSSConstants.TAG_xenc_EncryptedData.getLocalPart());
    Assert.assertEquals(nodeList.getLength(),1);
    xPathExpression=getXPath("/soap:Envelope/soap:Body/xenc:EncryptedData/xenc:EncryptionMethod[@Algorithm='http://www.w3.org/2001/04/xmlenc#aes256-cbc']");
    node=(Node)xPathExpression.evaluate(document,XPathConstants.NODE);
    Assert.assertNotNull(node);
    Assert.assertEquals(node.getParentNode().getParentNode().getLocalName(),"Body");
    NodeList childNodes=node.getParentNode().getParentNode().getChildNodes();
    for (int i=0; i < childNodes.getLength(); i++) {
      Node child=childNodes.item(i);
      if (child.getNodeType() == Node.TEXT_NODE) {
        Assert.assertEquals(child.getTextContent().trim(),"");
      }
 else       if (child.getNodeType() == Node.ELEMENT_NODE) {
        Assert.assertEquals(child,nodeList.item(0));
      }
 else {
        Assert.fail("Unexpected Node encountered");
      }
    }
  }
{
    String action=WSHandlerConstants.ENCRYPT;
    doInboundSecurityWithWSS4J(documentBuilderFactory.newDocumentBuilder().parse(new ByteArrayInputStream(baos.toByteArray())),action);
  }
}

</code></pre>

<br>
<pre class="type-3 type-11 type-15 type-8 type-5 type-1 type-6 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions in iterations
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * rsa-oaep, Digest:SHA512, MGF:SHA1, PSource: Specified 8 bytes
 */
@Test public void testKeyWrappingRSAOAEPAESGCM192SHA384MGF1SHA384PSourceOutbound() throws Exception {
  try {
    Security.addProvider(new BouncyCastleProvider());
    ByteArrayOutputStream baos;
{
      WSSSecurityProperties securityProperties=new WSSSecurityProperties();
      List<WSSConstants.Action> actions=new ArrayList<WSSConstants.Action>();
      actions.add(WSSConstants.ENCRYPT);
      securityProperties.setActions(actions);
      securityProperties.loadEncryptionKeystore(this.getClass().getClassLoader().getResource("transmitter.jks"),"default".toCharArray());
      securityProperties.setEncryptionUser("receiver");
      securityProperties.setEncryptionSymAlgorithm("http://www.w3.org/2009/xmlenc11#aes192-gcm");
      securityProperties.setEncryptionKeyTransportAlgorithm("http://www.w3.org/2009/xmlenc11#rsa-oaep");
      securityProperties.setEncryptionKeyTransportDigestAlgorithm("http://www.w3.org/2001/04/xmldsig-more#sha384");
      securityProperties.setEncryptionKeyTransportMGFAlgorithm("http://www.w3.org/2009/xmlenc11#mgf1sha384");
      securityProperties.setEncryptionKeyTransportOAEPParams(Base64.decode("ZHVtbXkxMjM=".getBytes(StandardCharsets.UTF_8)));
      InputStream sourceDocument=this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml");
      baos=doOutboundSecurity(securityProperties,sourceDocument);
      Document document=documentBuilderFactory.newDocumentBuilder().parse(new ByteArrayInputStream(baos.toByteArray()));
      NodeList nodeList=document.getElementsByTagNameNS(WSSConstants.TAG_xenc_EncryptedKey.getNamespaceURI(),WSSConstants.TAG_xenc_EncryptedKey.getLocalPart());
      Assert.assertEquals(nodeList.item(0).getParentNode().getLocalName(),WSSConstants.TAG_WSSE_SECURITY.getLocalPart());
      XPathExpression xPathExpression=getXPath("/soap:Envelope/soap:Header/wsse:Security/xenc:EncryptedKey/xenc:EncryptionMethod[@Algorithm='http://www.w3.org/2009/xmlenc11#rsa-oaep']");
      Node node=(Node)xPathExpression.evaluate(document,XPathConstants.NODE);
      Assert.assertNotNull(node);
      xPathExpression=getXPath("/soap:Envelope/soap:Header/wsse:Security/xenc:EncryptedKey/xenc:EncryptionMethod/xenc:OAEPparams");
      node=(Node)xPathExpression.evaluate(document,XPathConstants.NODE);
      Assert.assertNotNull(node);
      xPathExpression=getXPath("/soap:Envelope/soap:Header/wsse:Security/xenc:EncryptedKey/xenc:EncryptionMethod/dsig:DigestMethod[@Algorithm='http://www.w3.org/2001/04/xmldsig-more#sha384']");
      node=(Node)xPathExpression.evaluate(document,XPathConstants.NODE);
      Assert.assertNotNull(node);
      xPathExpression=getXPath("/soap:Envelope/soap:Header/wsse:Security/xenc:EncryptedKey/xenc:EncryptionMethod/xenc11:MGF[@Algorithm='http://www.w3.org/2009/xmlenc11#mgf1sha384']");
      node=(Node)xPathExpression.evaluate(document,XPathConstants.NODE);
      Assert.assertNotNull(node);
      nodeList=document.getElementsByTagNameNS(WSSConstants.TAG_xenc_DataReference.getNamespaceURI(),WSSConstants.TAG_xenc_DataReference.getLocalPart());
      Assert.assertEquals(nodeList.getLength(),1);
      nodeList=document.getElementsByTagNameNS(WSSConstants.TAG_xenc_EncryptedData.getNamespaceURI(),WSSConstants.TAG_xenc_EncryptedData.getLocalPart());
      Assert.assertEquals(nodeList.getLength(),1);
      xPathExpression=getXPath("/soap:Envelope/soap:Body/xenc:EncryptedData/xenc:EncryptionMethod[@Algorithm='http://www.w3.org/2009/xmlenc11#aes192-gcm']");
      node=(Node)xPathExpression.evaluate(document,XPathConstants.NODE);
      Assert.assertNotNull(node);
      Assert.assertEquals(node.getParentNode().getParentNode().getLocalName(),"Body");
      NodeList childNodes=node.getParentNode().getParentNode().getChildNodes();
      for (int i=0; i < childNodes.getLength(); i++) {
        Node child=childNodes.item(i);
        if (child.getNodeType() == Node.TEXT_NODE) {
          Assert.assertEquals(child.getTextContent().trim(),"");
        }
 else         if (child.getNodeType() == Node.ELEMENT_NODE) {
          Assert.assertEquals(child,nodeList.item(0));
        }
 else {
          Assert.fail("Unexpected Node encountered");
        }
      }
    }
{
      String action=WSHandlerConstants.ENCRYPT;
      doInboundSecurityWithWSS4J_1(documentBuilderFactory.newDocumentBuilder().parse(new ByteArrayInputStream(baos.toByteArray())),action);
    }
  }
  finally {
    Security.removeProvider(BouncyCastleProvider.PROVIDER_NAME);
  }
}

</code></pre>

<br>
<pre class="type-3 type-11 type-15 type-8 type-5 type-1 type-6 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions in iterations
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * rsa-oaep-mgf1p, Digest:SHA256, MGF:SHA1, PSource: None
 */
@Test public void testKeyWrappingRSAOAEPAESGCM192SHA256Outbound() throws Exception {
  try {
    Security.addProvider(new BouncyCastleProvider());
    ByteArrayOutputStream baos;
{
      WSSSecurityProperties securityProperties=new WSSSecurityProperties();
      List<WSSConstants.Action> actions=new ArrayList<WSSConstants.Action>();
      actions.add(WSSConstants.ENCRYPT);
      securityProperties.setActions(actions);
      securityProperties.loadEncryptionKeystore(this.getClass().getClassLoader().getResource("transmitter.jks"),"default".toCharArray());
      securityProperties.setEncryptionUser("receiver");
      securityProperties.setEncryptionSymAlgorithm("http://www.w3.org/2009/xmlenc11#aes192-gcm");
      securityProperties.setEncryptionKeyTransportAlgorithm("http://www.w3.org/2001/04/xmlenc#rsa-oaep-mgf1p");
      securityProperties.setEncryptionKeyTransportDigestAlgorithm("http://www.w3.org/2001/04/xmlenc#sha256");
      InputStream sourceDocument=this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml");
      baos=doOutboundSecurity(securityProperties,sourceDocument);
      Document document=documentBuilderFactory.newDocumentBuilder().parse(new ByteArrayInputStream(baos.toByteArray()));
      NodeList nodeList=document.getElementsByTagNameNS(WSSConstants.TAG_xenc_EncryptedKey.getNamespaceURI(),WSSConstants.TAG_xenc_EncryptedKey.getLocalPart());
      Assert.assertEquals(nodeList.item(0).getParentNode().getLocalName(),WSSConstants.TAG_WSSE_SECURITY.getLocalPart());
      XPathExpression xPathExpression=getXPath("/soap:Envelope/soap:Header/wsse:Security/xenc:EncryptedKey/xenc:EncryptionMethod[@Algorithm='http://www.w3.org/2001/04/xmlenc#rsa-oaep-mgf1p']");
      Node node=(Node)xPathExpression.evaluate(document,XPathConstants.NODE);
      Assert.assertNotNull(node);
      xPathExpression=getXPath("/soap:Envelope/soap:Header/wsse:Security/xenc:EncryptedKey/xenc:EncryptionMethod/dsig:DigestMethod[@Algorithm='http://www.w3.org/2001/04/xmlenc#sha256']");
      node=(Node)xPathExpression.evaluate(document,XPathConstants.NODE);
      Assert.assertNotNull(node);
      nodeList=document.getElementsByTagNameNS(WSSConstants.TAG_xenc_DataReference.getNamespaceURI(),WSSConstants.TAG_xenc_DataReference.getLocalPart());
      Assert.assertEquals(nodeList.getLength(),1);
      nodeList=document.getElementsByTagNameNS(WSSConstants.TAG_xenc_EncryptedData.getNamespaceURI(),WSSConstants.TAG_xenc_EncryptedData.getLocalPart());
      Assert.assertEquals(nodeList.getLength(),1);
      xPathExpression=getXPath("/soap:Envelope/soap:Body/xenc:EncryptedData/xenc:EncryptionMethod[@Algorithm='http://www.w3.org/2009/xmlenc11#aes192-gcm']");
      node=(Node)xPathExpression.evaluate(document,XPathConstants.NODE);
      Assert.assertNotNull(node);
      Assert.assertEquals(node.getParentNode().getParentNode().getLocalName(),"Body");
      NodeList childNodes=node.getParentNode().getParentNode().getChildNodes();
      for (int i=0; i < childNodes.getLength(); i++) {
        Node child=childNodes.item(i);
        if (child.getNodeType() == Node.TEXT_NODE) {
          Assert.assertEquals(child.getTextContent().trim(),"");
        }
 else         if (child.getNodeType() == Node.ELEMENT_NODE) {
          Assert.assertEquals(child,nodeList.item(0));
        }
 else {
          Assert.fail("Unexpected Node encountered");
        }
      }
    }
{
      String action=WSHandlerConstants.ENCRYPT;
      doInboundSecurityWithWSS4J(documentBuilderFactory.newDocumentBuilder().parse(new ByteArrayInputStream(baos.toByteArray())),action);
    }
  }
  finally {
    Security.removeProvider(BouncyCastleProvider.PROVIDER_NAME);
  }
}

</code></pre>

<br>
<pre class="type-3 type-11 type-15 type-8 type-5 type-1 type-6 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions in iterations
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testEncDecryptionDefaultConfigurationOutbound() throws Exception {
  ByteArrayOutputStream baos;
{
    WSSSecurityProperties securityProperties=new WSSSecurityProperties();
    List<WSSConstants.Action> actions=new ArrayList<WSSConstants.Action>();
    actions.add(WSSConstants.ENCRYPT);
    securityProperties.setActions(actions);
    securityProperties.loadEncryptionKeystore(this.getClass().getClassLoader().getResource("transmitter.jks"),"default".toCharArray());
    securityProperties.setEncryptionUser("receiver");
    InputStream sourceDocument=this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml");
    baos=doOutboundSecurity(securityProperties,sourceDocument);
    Document document=documentBuilderFactory.newDocumentBuilder().parse(new ByteArrayInputStream(baos.toByteArray()));
    NodeList nodeList=document.getElementsByTagNameNS(WSSConstants.TAG_xenc_EncryptedKey.getNamespaceURI(),WSSConstants.TAG_xenc_EncryptedKey.getLocalPart());
    Assert.assertEquals(nodeList.item(0).getParentNode().getLocalName(),WSSConstants.TAG_WSSE_SECURITY.getLocalPart());
    XPathExpression xPathExpression=getXPath("/soap:Envelope/soap:Header/wsse:Security/xenc:EncryptedKey/xenc:EncryptionMethod[@Algorithm='http://www.w3.org/2001/04/xmlenc#rsa-oaep-mgf1p']");
    Node node=(Node)xPathExpression.evaluate(document,XPathConstants.NODE);
    Assert.assertNotNull(node);
    nodeList=document.getElementsByTagNameNS(WSSConstants.TAG_xenc_DataReference.getNamespaceURI(),WSSConstants.TAG_xenc_DataReference.getLocalPart());
    Assert.assertEquals(nodeList.getLength(),1);
    nodeList=document.getElementsByTagNameNS(WSSConstants.TAG_xenc_EncryptedData.getNamespaceURI(),WSSConstants.TAG_xenc_EncryptedData.getLocalPart());
    Assert.assertEquals(nodeList.getLength(),1);
    xPathExpression=getXPath("/soap:Envelope/soap:Body/xenc:EncryptedData/xenc:EncryptionMethod[@Algorithm='http://www.w3.org/2001/04/xmlenc#aes256-cbc']");
    node=(Node)xPathExpression.evaluate(document,XPathConstants.NODE);
    Assert.assertNotNull(node);
    Assert.assertEquals(node.getParentNode().getParentNode().getLocalName(),"Body");
    NodeList childNodes=node.getParentNode().getParentNode().getChildNodes();
    for (int i=0; i < childNodes.getLength(); i++) {
      Node child=childNodes.item(i);
      if (child.getNodeType() == Node.TEXT_NODE) {
        Assert.assertEquals(child.getTextContent().trim(),"");
      }
 else       if (child.getNodeType() == Node.ELEMENT_NODE) {
        Assert.assertEquals(child,nodeList.item(0));
      }
 else {
        Assert.fail("Unexpected Node encountered");
      }
    }
  }
{
    String action=WSHandlerConstants.ENCRYPT;
    doInboundSecurityWithWSS4J(documentBuilderFactory.newDocumentBuilder().parse(new ByteArrayInputStream(baos.toByteArray())),action);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testExceptionOnElementToEncryptNotFound() throws Exception {
{
    WSSSecurityProperties securityProperties=new WSSSecurityProperties();
    List<WSSConstants.Action> actions=new ArrayList<WSSConstants.Action>();
    actions.add(WSSConstants.ENCRYPT);
    securityProperties.setActions(actions);
    securityProperties.loadEncryptionKeystore(this.getClass().getClassLoader().getResource("transmitter.jks"),"default".toCharArray());
    securityProperties.setEncryptionUser("receiver");
    securityProperties.addEncryptionPart(new SecurePart(new QName("http://www.wrongnamespace.org","complexType"),SecurePart.Modifier.Content));
    InputStream sourceDocument=this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml");
    try {
      doOutboundSecurity(securityProperties,sourceDocument);
      Assert.fail("Exception expected");
    }
 catch (    XMLStreamException e) {
      Assert.assertTrue(e.getCause() instanceof XMLSecurityException);
      Assert.assertEquals("Part to encrypt not found: {http://www.wrongnamespace.org}complexType",e.getCause().getMessage());
    }
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.wss4j.stax.test.EncryptionCRLTest </h4><pre class="type-8 type-7 type-6 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * TODO Re-enable once CRL issue fixed
 */
@Test @org.junit.Ignore public void testEncryptionWithRevocationCheck() throws Exception {
{
    WSSSecurityProperties securityProperties=new WSSSecurityProperties();
    List<WSSConstants.Action> actions=new ArrayList<WSSConstants.Action>();
    actions.add(WSSConstants.ENCRYPT);
    securityProperties.setEnableRevocation(true);
    securityProperties.setActions(actions);
    securityProperties.loadEncryptionKeystore(this.getClass().getClassLoader().getResource("wss40rev.jks"),"security".toCharArray());
    securityProperties.setEncryptionUser("wss40rev");
    securityProperties.setEncryptionKeyIdentifier(WSSecurityTokenConstants.KEYIDENTIFIER_SECURITY_TOKEN_DIRECT_REFERENCE);
    securityProperties.loadCRLCertStore(this.getClass().getClassLoader().getResource("wss40CACRL.pem"));
    InputStream sourceDocument=this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml");
    try {
      doOutboundSecurity(securityProperties,sourceDocument);
      Assert.fail("Expected failure on a revocation check");
    }
 catch (    Exception ex) {
      Assert.assertNotNull(ex.getCause());
      Assert.assertTrue(ex.getCause() instanceof WSSecurityException);
    }
  }
}

</code></pre>

<br>
<pre class="type-3 type-11 type-15 type-8 type-5 type-1 type-6 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions in iterations
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testEncryptionWithOutRevocationCheck() throws Exception {
  ByteArrayOutputStream baos;
{
    WSSSecurityProperties securityProperties=new WSSSecurityProperties();
    List<WSSConstants.Action> actions=new ArrayList<WSSConstants.Action>();
    actions.add(WSSConstants.ENCRYPT);
    securityProperties.setActions(actions);
    securityProperties.loadEncryptionKeystore(this.getClass().getClassLoader().getResource("wss40rev.jks"),"security".toCharArray());
    securityProperties.setEncryptionUser("wss40rev");
    securityProperties.setEncryptionKeyIdentifier(WSSecurityTokenConstants.KEYIDENTIFIER_SECURITY_TOKEN_DIRECT_REFERENCE);
    InputStream sourceDocument=this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml");
    baos=doOutboundSecurity(securityProperties,sourceDocument);
    Document document=documentBuilderFactory.newDocumentBuilder().parse(new ByteArrayInputStream(baos.toByteArray()));
    NodeList nodeList=document.getElementsByTagNameNS(WSSConstants.TAG_xenc_EncryptedKey.getNamespaceURI(),WSSConstants.TAG_xenc_EncryptedKey.getLocalPart());
    Assert.assertEquals(nodeList.item(0).getParentNode().getLocalName(),WSSConstants.TAG_WSSE_SECURITY.getLocalPart());
    XPathExpression xPathExpression=getXPath("/soap:Envelope/soap:Header/wsse:Security/xenc:EncryptedKey/xenc:EncryptionMethod[@Algorithm='http://www.w3.org/2001/04/xmlenc#rsa-oaep-mgf1p']");
    Node node=(Node)xPathExpression.evaluate(document,XPathConstants.NODE);
    Assert.assertNotNull(node);
    nodeList=document.getElementsByTagNameNS(WSSConstants.TAG_xenc_DataReference.getNamespaceURI(),WSSConstants.TAG_xenc_DataReference.getLocalPart());
    Assert.assertEquals(nodeList.getLength(),1);
    nodeList=document.getElementsByTagNameNS(WSSConstants.TAG_xenc_EncryptedData.getNamespaceURI(),WSSConstants.TAG_xenc_EncryptedData.getLocalPart());
    Assert.assertEquals(nodeList.getLength(),1);
    xPathExpression=getXPath("/soap:Envelope/soap:Body/xenc:EncryptedData/xenc:EncryptionMethod[@Algorithm='http://www.w3.org/2001/04/xmlenc#aes256-cbc']");
    node=(Node)xPathExpression.evaluate(document,XPathConstants.NODE);
    Assert.assertNotNull(node);
    Assert.assertEquals(node.getParentNode().getParentNode().getLocalName(),"Body");
    NodeList childNodes=node.getParentNode().getParentNode().getChildNodes();
    for (int i=0; i < childNodes.getLength(); i++) {
      Node child=childNodes.item(i);
      if (child.getNodeType() == Node.TEXT_NODE) {
        Assert.assertEquals(child.getTextContent().trim(),"");
      }
 else       if (child.getNodeType() == Node.ELEMENT_NODE) {
        Assert.assertEquals(child,nodeList.item(0));
      }
 else {
        Assert.fail("Unexpected Node encountered");
      }
    }
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.wss4j.stax.test.InteroperabilityTest </h4><pre class="type-8 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testInteroperabilityInvalidSOAPActionOutbound() throws Exception {
  WSSSecurityProperties securityProperties=new WSSSecurityProperties();
  securityProperties.setCallbackHandler(new CallbackHandlerImpl());
  securityProperties.setActor("test");
  securityProperties.setEncryptionUser("receiver");
  securityProperties.loadEncryptionKeystore(this.getClass().getClassLoader().getResource("transmitter.jks"),"default".toCharArray());
  securityProperties.setSignatureUser("transmitter");
  securityProperties.loadSignatureKeyStore(this.getClass().getClassLoader().getResource("transmitter.jks"),"default".toCharArray());
  List<WSSConstants.Action> actions=new ArrayList<WSSConstants.Action>();
  actions.add(WSSConstants.TIMESTAMP);
  actions.add(WSSConstants.SIGNATURE);
  actions.add(WSSConstants.ENCRYPT);
  securityProperties.setActions(actions);
  InputStream sourceDocument=this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml");
  ByteArrayOutputStream baos=doOutboundSecurity(securityProperties,sourceDocument);
  String action=WSHandlerConstants.TIMESTAMP + " " + WSHandlerConstants.SIGNATURE+ " "+ WSHandlerConstants.ENCRYPT;
  Properties properties=new Properties();
  properties.setProperty(WSHandlerConstants.ACTOR,"anotherTest");
  try {
    doInboundSecurityWithWSS4J_1(documentBuilderFactory.newDocumentBuilder().parse(new ByteArrayInputStream(baos.toByteArray())),action,properties,false);
    Assert.fail("Expected WSSecurityException");
  }
 catch (  WSSecurityException e) {
    Assert.assertEquals(e.getMessage(),"WSS4JHandler: Request does not contain required Security header");
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.wss4j.stax.test.MultipleActionTest </h4><pre class="type-8 type-7 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testDuplicateActions() throws Exception {
  WSSSecurityProperties properties=new WSSSecurityProperties();
  List<XMLSecurityConstants.Action> actions=new ArrayList<XMLSecurityConstants.Action>();
  actions.add(XMLSecurityConstants.SIGNATURE);
  properties.loadSignatureKeyStore(this.getClass().getClassLoader().getResource("transmitter.jks"),"default".toCharArray());
  properties.setSignatureUser("transmitter");
  properties.setCallbackHandler(new CallbackHandlerImpl());
  properties.setActions(actions);
  WSSec.getOutboundWSSec(properties);
  actions.add(XMLSecurityConstants.SIGNATURE);
  properties.setActions(actions);
  try {
    WSSec.getOutboundWSSec(properties);
    Assert.fail();
  }
 catch (  WSSecurityException ex) {
    Assert.assertTrue(ex.getMessage().contains("Duplicate Actions are not allowed"));
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.wss4j.stax.test.OutputChainTest </h4><pre class="type-3 type-11 type-15 type-8 type-5 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions in iterations
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testEncryptionAction() throws Exception {
  WSSSecurityProperties securityProperties=new WSSSecurityProperties();
  List<WSSConstants.Action> actions=new ArrayList<WSSConstants.Action>();
  actions.add(WSSConstants.ENCRYPT);
  securityProperties.setActions(actions);
  securityProperties.loadEncryptionKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
  securityProperties.setEncryptionUser("receiver");
  OutboundWSSec wsSecOut=WSSec.getOutboundWSSec(securityProperties);
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  XMLStreamWriter xmlStreamWriter=wsSecOut.processOutMessage(baos,StandardCharsets.UTF_8.name(),new ArrayList<SecurityEvent>());
  XMLStreamReader xmlStreamReader=xmlInputFactory.createXMLStreamReader(this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml"));
  XmlReaderToWriter.writeAll(xmlStreamReader,xmlStreamWriter);
  xmlStreamWriter.close();
  Document document=documentBuilderFactory.newDocumentBuilder().parse(new ByteArrayInputStream(baos.toByteArray()));
  NodeList nodeList=document.getElementsByTagNameNS(WSSConstants.TAG_xenc_EncryptedKey.getNamespaceURI(),WSSConstants.TAG_xenc_EncryptedKey.getLocalPart());
  Assert.assertEquals(nodeList.item(0).getParentNode().getLocalName(),WSSConstants.TAG_WSSE_SECURITY.getLocalPart());
  nodeList=document.getElementsByTagNameNS(WSSConstants.TAG_xenc_EncryptedData.getNamespaceURI(),WSSConstants.TAG_xenc_EncryptedData.getLocalPart());
  Assert.assertEquals(nodeList.getLength(),1);
  Assert.assertEquals(nodeList.item(0).getParentNode().getLocalName(),"Body");
  NodeList childNodes=nodeList.item(0).getParentNode().getChildNodes();
  for (int i=0; i < childNodes.getLength(); i++) {
    Node child=childNodes.item(i);
    if (child.getNodeType() == Node.TEXT_NODE) {
      Assert.assertEquals(child.getTextContent().trim(),"");
    }
 else     if (child.getNodeType() == Node.ELEMENT_NODE) {
      Assert.assertEquals(child,nodeList.item(0));
    }
 else {
      Assert.fail("Unexpected Node encountered");
    }
  }
  nodeList=document.getElementsByTagNameNS(WSSConstants.TAG_dsig_Signature.getNamespaceURI(),WSSConstants.TAG_dsig_Signature.getLocalPart());
  Assert.assertEquals(nodeList.getLength(),0);
  nodeList=document.getElementsByTagNameNS(WSSConstants.TAG_WSU_TIMESTAMP.getNamespaceURI(),WSSConstants.TAG_WSU_TIMESTAMP.getLocalPart());
  Assert.assertEquals(nodeList.getLength(),0);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.wss4j.stax.test.PasswordEncryptorTest </h4><pre class="type-3 type-11 type-15 type-8 type-5 type-1 type-6 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions in iterations
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testEncDecryptionCryptoPropertiesOutbound() throws Exception {
  ByteArrayOutputStream baos;
{
    WSSSecurityProperties securityProperties=new WSSSecurityProperties();
    List<WSSConstants.Action> actions=new ArrayList<WSSConstants.Action>();
    actions.add(WSSConstants.ENCRYPT);
    securityProperties.setActions(actions);
    Properties properties=CryptoFactory.getProperties("transmitter-crypto-enc.properties",this.getClass().getClassLoader());
    PasswordEncryptor passwordEncryptor=new JasyptPasswordEncryptor(new CallbackHandlerImpl());
    securityProperties.setEncryptionCryptoProperties(properties,passwordEncryptor);
    securityProperties.setEncryptionUser("receiver");
    InputStream sourceDocument=this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml");
    baos=doOutboundSecurity(securityProperties,sourceDocument);
    Document document=documentBuilderFactory.newDocumentBuilder().parse(new ByteArrayInputStream(baos.toByteArray()));
    NodeList nodeList=document.getElementsByTagNameNS(WSSConstants.TAG_xenc_EncryptedKey.getNamespaceURI(),WSSConstants.TAG_xenc_EncryptedKey.getLocalPart());
    Assert.assertEquals(nodeList.item(0).getParentNode().getLocalName(),WSSConstants.TAG_WSSE_SECURITY.getLocalPart());
    XPathExpression xPathExpression=getXPath("/soap:Envelope/soap:Header/wsse:Security/xenc:EncryptedKey/xenc:EncryptionMethod[@Algorithm='http://www.w3.org/2001/04/xmlenc#rsa-oaep-mgf1p']");
    Node node=(Node)xPathExpression.evaluate(document,XPathConstants.NODE);
    Assert.assertNotNull(node);
    nodeList=document.getElementsByTagNameNS(WSSConstants.TAG_xenc_DataReference.getNamespaceURI(),WSSConstants.TAG_xenc_DataReference.getLocalPart());
    Assert.assertEquals(nodeList.getLength(),1);
    nodeList=document.getElementsByTagNameNS(WSSConstants.TAG_xenc_EncryptedData.getNamespaceURI(),WSSConstants.TAG_xenc_EncryptedData.getLocalPart());
    Assert.assertEquals(nodeList.getLength(),1);
    xPathExpression=getXPath("/soap:Envelope/soap:Body/xenc:EncryptedData/xenc:EncryptionMethod[@Algorithm='http://www.w3.org/2001/04/xmlenc#aes256-cbc']");
    node=(Node)xPathExpression.evaluate(document,XPathConstants.NODE);
    Assert.assertNotNull(node);
    Assert.assertEquals(node.getParentNode().getParentNode().getLocalName(),"Body");
    NodeList childNodes=node.getParentNode().getParentNode().getChildNodes();
    for (int i=0; i < childNodes.getLength(); i++) {
      Node child=childNodes.item(i);
      if (child.getNodeType() == Node.TEXT_NODE) {
        Assert.assertEquals(child.getTextContent().trim(),"");
      }
 else       if (child.getNodeType() == Node.ELEMENT_NODE) {
        Assert.assertEquals(child,nodeList.item(0));
      }
 else {
        Assert.fail("Unexpected Node encountered");
      }
    }
  }
{
    String action=WSHandlerConstants.ENCRYPT;
    doInboundSecurityWithWSS4J(documentBuilderFactory.newDocumentBuilder().parse(new ByteArrayInputStream(baos.toByteArray())),action);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.wss4j.stax.test.PasswordTypeTest </h4><pre class="type-3 type-8 type-7 type-5 type-1 type-6 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testPasswordDigest() throws Exception {
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
{
    InputStream sourceDocument=this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml");
    String action=WSHandlerConstants.USERNAME_TOKEN;
    Properties properties=new Properties();
    Document securedDocument=doOutboundSecurityWithWSS4J(sourceDocument,action,properties);
    NodeList nodeList=securedDocument.getElementsByTagNameNS(WSSConstants.TAG_WSSE_USERNAME_TOKEN.getNamespaceURI(),WSSConstants.TAG_WSSE_USERNAME_TOKEN.getLocalPart());
    Assert.assertEquals(nodeList.item(0).getParentNode().getLocalName(),WSSConstants.TAG_WSSE_SECURITY.getLocalPart());
    nodeList=securedDocument.getElementsByTagNameNS(WSSConstants.TAG_WSSE_PASSWORD.getNamespaceURI(),WSSConstants.TAG_WSSE_PASSWORD.getLocalPart());
    Assert.assertEquals(nodeList.getLength(),1);
    Assert.assertEquals(((Element)nodeList.item(0)).getAttributeNS(null,WSSConstants.ATT_NULL_Type.getLocalPart()),WSSConstants.UsernameTokenPasswordType.PASSWORD_DIGEST.getNamespace());
    javax.xml.transform.Transformer transformer=TRANSFORMER_FACTORY.newTransformer();
    transformer.transform(new DOMSource(securedDocument),new StreamResult(baos));
  }
{
    WSSSecurityProperties securityProperties=new WSSSecurityProperties();
    securityProperties.setCallbackHandler(new CallbackHandlerImpl());
    securityProperties.setUsernameTokenPasswordType(WSSConstants.UsernameTokenPasswordType.PASSWORD_DIGEST);
    InboundWSSec wsSecIn=WSSec.getInboundWSSec(securityProperties);
    XMLStreamReader xmlStreamReader=wsSecIn.processInMessage(xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray())),null);
    StAX2DOM.readDoc(documentBuilderFactory.newDocumentBuilder(),xmlStreamReader);
  }
{
    WSSSecurityProperties securityProperties=new WSSSecurityProperties();
    securityProperties.setCallbackHandler(new CallbackHandlerImpl());
    securityProperties.setUsernameTokenPasswordType(null);
    InboundWSSec wsSecIn=WSSec.getInboundWSSec(securityProperties);
    XMLStreamReader xmlStreamReader=wsSecIn.processInMessage(xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray())),null);
    StAX2DOM.readDoc(documentBuilderFactory.newDocumentBuilder(),xmlStreamReader);
  }
{
    WSSSecurityProperties securityProperties=new WSSSecurityProperties();
    securityProperties.setCallbackHandler(new CallbackHandlerImpl());
    securityProperties.setUsernameTokenPasswordType(WSSConstants.UsernameTokenPasswordType.PASSWORD_TEXT);
    InboundWSSec wsSecIn=WSSec.getInboundWSSec(securityProperties,false,true);
    XMLStreamReader xmlStreamReader=wsSecIn.processInMessage(xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray())),null);
    try {
      StAX2DOM.readDoc(documentBuilderFactory.newDocumentBuilder(),xmlStreamReader);
      Assert.fail("Expected XMLStreamException");
    }
 catch (    XMLStreamException e) {
      Assert.assertNotNull(e.getCause());
      Assert.assertTrue(e.getCause() instanceof WSSecurityException);
      Assert.assertEquals(e.getCause().getMessage(),"The security token could not be authenticated or authorized");
      Assert.assertEquals(((WSSecurityException)e.getCause()).getFaultCode(),WSSecurityException.FAILED_AUTHENTICATION);
    }
  }
}

</code></pre>

<br>
<pre class="type-3 type-8 type-7 type-5 type-1 type-6 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testPasswordText() throws Exception {
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
{
    InputStream sourceDocument=this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml");
    String action=WSHandlerConstants.USERNAME_TOKEN;
    Properties properties=new Properties();
    properties.put(WSHandlerConstants.PASSWORD_TYPE,WSConstants.PW_TEXT);
    Document securedDocument=doOutboundSecurityWithWSS4J(sourceDocument,action,properties);
    NodeList nodeList=securedDocument.getElementsByTagNameNS(WSSConstants.TAG_WSSE_USERNAME_TOKEN.getNamespaceURI(),WSSConstants.TAG_WSSE_USERNAME_TOKEN.getLocalPart());
    Assert.assertEquals(nodeList.item(0).getParentNode().getLocalName(),WSSConstants.TAG_WSSE_SECURITY.getLocalPart());
    nodeList=securedDocument.getElementsByTagNameNS(WSSConstants.TAG_WSSE_PASSWORD.getNamespaceURI(),WSSConstants.TAG_WSSE_PASSWORD.getLocalPart());
    Assert.assertEquals(nodeList.getLength(),1);
    Assert.assertEquals(((Element)nodeList.item(0)).getAttributeNS(null,WSSConstants.ATT_NULL_Type.getLocalPart()),WSSConstants.UsernameTokenPasswordType.PASSWORD_TEXT.getNamespace());
    javax.xml.transform.Transformer transformer=TRANSFORMER_FACTORY.newTransformer();
    transformer.transform(new DOMSource(securedDocument),new StreamResult(baos));
  }
{
    WSSSecurityProperties securityProperties=new WSSSecurityProperties();
    securityProperties.setCallbackHandler(new CallbackHandlerImpl());
    securityProperties.setUsernameTokenPasswordType(WSSConstants.UsernameTokenPasswordType.PASSWORD_TEXT);
    InboundWSSec wsSecIn=WSSec.getInboundWSSec(securityProperties);
    XMLStreamReader xmlStreamReader=wsSecIn.processInMessage(xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray())),null);
    StAX2DOM.readDoc(documentBuilderFactory.newDocumentBuilder(),xmlStreamReader);
  }
{
    WSSSecurityProperties securityProperties=new WSSSecurityProperties();
    securityProperties.setCallbackHandler(new CallbackHandlerImpl());
    securityProperties.setUsernameTokenPasswordType(null);
    InboundWSSec wsSecIn=WSSec.getInboundWSSec(securityProperties);
    XMLStreamReader xmlStreamReader=wsSecIn.processInMessage(xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray())),null);
    StAX2DOM.readDoc(documentBuilderFactory.newDocumentBuilder(),xmlStreamReader);
  }
{
    WSSSecurityProperties securityProperties=new WSSSecurityProperties();
    securityProperties.setCallbackHandler(new CallbackHandlerImpl());
    securityProperties.setUsernameTokenPasswordType(WSSConstants.UsernameTokenPasswordType.PASSWORD_DIGEST);
    InboundWSSec wsSecIn=WSSec.getInboundWSSec(securityProperties,false,true);
    XMLStreamReader xmlStreamReader=wsSecIn.processInMessage(xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray())),null);
    try {
      StAX2DOM.readDoc(documentBuilderFactory.newDocumentBuilder(),xmlStreamReader);
      Assert.fail("Expected XMLStreamException");
    }
 catch (    XMLStreamException e) {
      Assert.assertNotNull(e.getCause());
      Assert.assertTrue(e.getCause() instanceof WSSecurityException);
      Assert.assertEquals(e.getCause().getMessage(),"The security token could not be authenticated or authorized");
      Assert.assertEquals(((WSSecurityException)e.getCause()).getFaultCode(),WSSecurityException.FAILED_AUTHENTICATION);
    }
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.wss4j.stax.test.ReplayTest </h4><pre class="type-3 type-8 type-7 type-5 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testReplayedTimestamp() throws Exception {
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
{
    InputStream sourceDocument=this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml");
    String action=WSHandlerConstants.SIGNATURE + " " + WSHandlerConstants.TIMESTAMP;
    Properties properties=new Properties();
    properties.setProperty(WSHandlerConstants.SIGNATURE_PARTS,"{Element}{" + WSConstants.WSU_NS + "}Timestamp;");
    Document securedDocument=doOutboundSecurityWithWSS4J(sourceDocument,action,properties);
    NodeList nodeList=securedDocument.getElementsByTagNameNS(WSSConstants.TAG_dsig_Signature.getNamespaceURI(),WSSConstants.TAG_dsig_Signature.getLocalPart());
    Assert.assertEquals(nodeList.item(0).getParentNode().getLocalName(),WSSConstants.TAG_WSSE_SECURITY.getLocalPart());
    javax.xml.transform.Transformer transformer=TRANSFORMER_FACTORY.newTransformer();
    transformer.transform(new DOMSource(securedDocument),new StreamResult(baos));
  }
  ReplayCache replayCache=null;
{
    WSSSecurityProperties securityProperties=new WSSSecurityProperties();
    replayCache=securityProperties.getTimestampReplayCache();
    securityProperties.loadSignatureVerificationKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
    InboundWSSec wsSecIn=WSSec.getInboundWSSec(securityProperties);
    XMLStreamReader xmlStreamReader=wsSecIn.processInMessage(xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray())));
    Document document=StAX2DOM.readDoc(documentBuilderFactory.newDocumentBuilder(),xmlStreamReader);
    NodeList nodeList=document.getElementsByTagNameNS(WSSConstants.TAG_dsig_Signature.getNamespaceURI(),WSSConstants.TAG_dsig_Signature.getLocalPart());
    Assert.assertEquals(nodeList.getLength(),1);
    Assert.assertEquals(nodeList.item(0).getParentNode().getLocalName(),WSSConstants.TAG_WSSE_SECURITY.getLocalPart());
  }
{
    WSSSecurityProperties securityProperties=new WSSSecurityProperties();
    securityProperties.setTimestampReplayCache(replayCache);
    securityProperties.loadSignatureVerificationKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
    InboundWSSec wsSecIn=WSSec.getInboundWSSec(securityProperties,false,true);
    XMLStreamReader xmlStreamReader=wsSecIn.processInMessage(xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray())));
    try {
      StAX2DOM.readDoc(documentBuilderFactory.newDocumentBuilder(),xmlStreamReader);
      Assert.fail("Exception expected");
    }
 catch (    XMLStreamException e) {
      Assert.assertTrue(e.getCause() instanceof XMLSecurityException);
      Assert.assertEquals("The message has expired",e.getCause().getMessage());
    }
  }
}

</code></pre>

<br>
<pre class="type-3 type-8 type-7 type-5 type-6 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test that creates, sends and processes an unsigned SAML 2 authentication assertion
 * with a OneTimeUse Element
 */
@Test public void testEhCacheReplayedSAML2OneTimeUse() throws Exception {
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
{
    SAML2CallbackHandler callbackHandler=new SAML2CallbackHandler();
    callbackHandler.setStatement(SAML2CallbackHandler.Statement.AUTHN);
    callbackHandler.setConfirmationMethod(SAML2Constants.CONF_BEARER);
    callbackHandler.setIssuer("www.example.com");
    callbackHandler.setSignAssertion(false);
    ConditionsBean conditions=new ConditionsBean();
    conditions.setTokenPeriodMinutes(5);
    conditions.setOneTimeUse(true);
    callbackHandler.setConditions(conditions);
    InputStream sourceDocument=this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml");
    String action=WSHandlerConstants.SAML_TOKEN_UNSIGNED;
    Properties properties=new Properties();
    properties.put(WSHandlerConstants.SAML_CALLBACK_REF,callbackHandler);
    Document securedDocument=doOutboundSecurityWithWSS4J(sourceDocument,action,properties);
    javax.xml.transform.Transformer transformer=TRANSFORMER_FACTORY.newTransformer();
    transformer.transform(new DOMSource(securedDocument),new StreamResult(baos));
  }
  ReplayCache replayCache=null;
{
    WSSSecurityProperties securityProperties=new WSSSecurityProperties();
    SamlTokenValidatorImpl validator=new SamlTokenValidatorImpl();
    validator.setRequireBearerSignature(false);
    securityProperties.addValidator(WSSConstants.TAG_SAML2_ASSERTION,validator);
    securityProperties.addValidator(WSSConstants.TAG_SAML_ASSERTION,validator);
    replayCache=securityProperties.getSamlOneTimeUseReplayCache();
    InboundWSSec wsSecIn=WSSec.getInboundWSSec(securityProperties);
    XMLStreamReader xmlStreamReader=wsSecIn.processInMessage(xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray())));
    Document document=StAX2DOM.readDoc(documentBuilderFactory.newDocumentBuilder(),xmlStreamReader);
    Assert.assertNotNull(document);
  }
{
    WSSSecurityProperties securityProperties=new WSSSecurityProperties();
    SamlTokenValidatorImpl validator=new SamlTokenValidatorImpl();
    validator.setRequireBearerSignature(false);
    securityProperties.addValidator(WSSConstants.TAG_SAML2_ASSERTION,validator);
    securityProperties.addValidator(WSSConstants.TAG_SAML_ASSERTION,validator);
    securityProperties.setSamlOneTimeUseReplayCache(replayCache);
    InboundWSSec wsSecIn=WSSec.getInboundWSSec(securityProperties);
    XMLStreamReader xmlStreamReader=wsSecIn.processInMessage(xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray())));
    try {
      StAX2DOM.readDoc(documentBuilderFactory.newDocumentBuilder(),xmlStreamReader);
      Assert.fail("Exception expected");
    }
 catch (    XMLStreamException e) {
      Assert.assertTrue(e.getCause() instanceof XMLSecurityException);
    }
  }
}

</code></pre>

<br>
<pre class="type-3 type-8 type-7 type-5 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testUsernameToken() throws Exception {
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
{
    InputStream sourceDocument=this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml");
    String action=WSHandlerConstants.USERNAME_TOKEN;
    Properties properties=new Properties();
    Document securedDocument=doOutboundSecurityWithWSS4J(sourceDocument,action,properties);
    NodeList nodeList=securedDocument.getElementsByTagNameNS(WSSConstants.TAG_WSSE_USERNAME_TOKEN.getNamespaceURI(),WSSConstants.TAG_WSSE_USERNAME_TOKEN.getLocalPart());
    Assert.assertEquals(nodeList.item(0).getParentNode().getLocalName(),WSSConstants.TAG_WSSE_SECURITY.getLocalPart());
    javax.xml.transform.Transformer transformer=TRANSFORMER_FACTORY.newTransformer();
    transformer.transform(new DOMSource(securedDocument),new StreamResult(baos));
  }
  ReplayCache replayCache=null;
{
    WSSSecurityProperties securityProperties=new WSSSecurityProperties();
    replayCache=securityProperties.getNonceReplayCache();
    securityProperties.setCallbackHandler(new CallbackHandlerImpl());
    InboundWSSec wsSecIn=WSSec.getInboundWSSec(securityProperties);
    XMLStreamReader xmlStreamReader=wsSecIn.processInMessage(xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray())));
    Document document=StAX2DOM.readDoc(documentBuilderFactory.newDocumentBuilder(),xmlStreamReader);
    NodeList nodeList=document.getElementsByTagNameNS(WSSConstants.TAG_WSSE_USERNAME_TOKEN.getNamespaceURI(),WSSConstants.TAG_WSSE_USERNAME_TOKEN.getLocalPart());
    Assert.assertEquals(nodeList.getLength(),1);
    Assert.assertEquals(nodeList.item(0).getParentNode().getLocalName(),WSSConstants.TAG_WSSE_SECURITY.getLocalPart());
  }
{
    WSSSecurityProperties securityProperties=new WSSSecurityProperties();
    securityProperties.setNonceReplayCache(replayCache);
    securityProperties.setCallbackHandler(new CallbackHandlerImpl());
    InboundWSSec wsSecIn=WSSec.getInboundWSSec(securityProperties);
    XMLStreamReader xmlStreamReader=wsSecIn.processInMessage(xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray())));
    try {
      StAX2DOM.readDoc(documentBuilderFactory.newDocumentBuilder(),xmlStreamReader);
      Assert.fail("Exception expected");
    }
 catch (    XMLStreamException e) {
      Assert.assertTrue(e.getCause() instanceof XMLSecurityException);
    }
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.wss4j.stax.test.SignatureCRLTest </h4><pre class="type-3 type-8 type-7 type-5 type-1 type-6 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test signing a SOAP message using a BST. Revocation is not enabled and so the test
 * should pass.
 * TODO Re-enable once CRL issue fixed
 */
@Test @org.junit.Ignore public void testSignatureDirectReference() throws Exception {
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
{
    InputStream sourceDocument=this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml");
    String action=WSHandlerConstants.SIGNATURE;
    Document securedDocument=doOutboundSecurityWithWSS4J(sourceDocument,action,new Properties());
    NodeList nodeList=securedDocument.getElementsByTagNameNS(WSSConstants.TAG_dsig_Signature.getNamespaceURI(),WSSConstants.TAG_dsig_Signature.getLocalPart());
    Assert.assertEquals(nodeList.item(0).getParentNode().getLocalName(),WSSConstants.TAG_WSSE_SECURITY.getLocalPart());
    javax.xml.transform.Transformer transformer=TRANSFORMER_FACTORY.newTransformer();
    transformer.transform(new DOMSource(securedDocument),new StreamResult(baos));
  }
{
    WSSSecurityProperties securityProperties=new WSSSecurityProperties();
    securityProperties.loadSignatureVerificationKeystore(this.getClass().getClassLoader().getResource("wss40rev.jks"),"security".toCharArray());
    InboundWSSec wsSecIn=WSSec.getInboundWSSec(securityProperties);
    XMLStreamReader xmlStreamReader=wsSecIn.processInMessage(xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray())));
    Document document=StAX2DOM.readDoc(documentBuilderFactory.newDocumentBuilder(),xmlStreamReader);
    NodeList nodeList=document.getElementsByTagNameNS(WSSConstants.TAG_dsig_Signature.getNamespaceURI(),WSSConstants.TAG_dsig_Signature.getLocalPart());
    Assert.assertEquals(nodeList.getLength(),1);
    Assert.assertEquals(nodeList.item(0).getParentNode().getLocalName(),WSSConstants.TAG_WSSE_SECURITY.getLocalPart());
  }
{
    WSSSecurityProperties securityProperties=new WSSSecurityProperties();
    securityProperties.setEnableRevocation(true);
    securityProperties.loadSignatureVerificationKeystore(this.getClass().getClassLoader().getResource("wss40rev.jks"),"security".toCharArray());
    securityProperties.loadCRLCertStore(this.getClass().getClassLoader().getResource("wss40CACRL.pem"));
    InboundWSSec wsSecIn=WSSec.getInboundWSSec(securityProperties);
    XMLStreamReader xmlStreamReader=wsSecIn.processInMessage(xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray())));
    try {
      StAX2DOM.readDoc(documentBuilderFactory.newDocumentBuilder(),xmlStreamReader);
      Assert.fail("Expected failure on a revocation check");
    }
 catch (    Exception ex) {
      Assert.assertNotNull(ex.getCause());
      Assert.assertTrue(ex.getCause() instanceof WSSecurityException);
    }
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.wss4j.stax.test.SignatureCertConstaintsTest </h4><pre class="type-3 type-8 type-7 type-5 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testBSTSignature() throws Exception {
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
{
    InputStream sourceDocument=this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml");
    String action=WSHandlerConstants.SIGNATURE;
    Document securedDocument=doOutboundSecurityWithWSS4J(sourceDocument,action,new Properties());
    NodeList nodeList=securedDocument.getElementsByTagNameNS(WSSConstants.TAG_dsig_Signature.getNamespaceURI(),WSSConstants.TAG_dsig_Signature.getLocalPart());
    Assert.assertEquals(nodeList.item(0).getParentNode().getLocalName(),WSSConstants.TAG_WSSE_SECURITY.getLocalPart());
    javax.xml.transform.Transformer transformer=TRANSFORMER_FACTORY.newTransformer();
    transformer.transform(new DOMSource(securedDocument),new StreamResult(baos));
  }
{
    WSSSecurityProperties securityProperties=new WSSSecurityProperties();
    securityProperties.loadSignatureVerificationKeystore(this.getClass().getClassLoader().getResource("wss40CA.jks"),"security".toCharArray());
    String certConstraint=".*CN=Colm.*O=Apache.*";
    Pattern subjectDNPattern=Pattern.compile(certConstraint.trim());
    securityProperties.setSubjectCertConstraints(Collections.singletonList(subjectDNPattern));
    InboundWSSec wsSecIn=WSSec.getInboundWSSec(securityProperties);
    XMLStreamReader xmlStreamReader=wsSecIn.processInMessage(xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray())));
    Document document=StAX2DOM.readDoc(documentBuilderFactory.newDocumentBuilder(),xmlStreamReader);
    NodeList nodeList=document.getElementsByTagNameNS(WSSConstants.TAG_dsig_Signature.getNamespaceURI(),WSSConstants.TAG_dsig_Signature.getLocalPart());
    Assert.assertEquals(nodeList.getLength(),1);
    Assert.assertEquals(nodeList.item(0).getParentNode().getLocalName(),WSSConstants.TAG_WSSE_SECURITY.getLocalPart());
  }
{
    WSSSecurityProperties securityProperties=new WSSSecurityProperties();
    securityProperties.loadSignatureVerificationKeystore(this.getClass().getClassLoader().getResource("wss40CA.jks"),"security".toCharArray());
    String certConstraint=".*CN=Colm2.*O=Apache.*";
    Pattern subjectDNPattern=Pattern.compile(certConstraint.trim());
    securityProperties.setSubjectCertConstraints(Collections.singletonList(subjectDNPattern));
    InboundWSSec wsSecIn=WSSec.getInboundWSSec(securityProperties,false,true);
    XMLStreamReader xmlStreamReader=wsSecIn.processInMessage(xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray())));
    try {
      StAX2DOM.readDoc(documentBuilderFactory.newDocumentBuilder(),xmlStreamReader);
      Assert.fail("Expected failure on a incorrect cert constraint check");
    }
 catch (    Exception ex) {
      String errorMessage="The security token could not be authenticated or authorized";
      Assert.assertTrue(ex.getMessage().contains(errorMessage));
    }
  }
}

</code></pre>

<br>
<pre class="type-3 type-8 type-7 type-5 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testBSTSignaturePKIPath() throws Exception {
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
{
    InputStream sourceDocument=this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml");
    String action=WSHandlerConstants.SIGNATURE;
    Properties properties=new Properties();
    properties.put(WSHandlerConstants.USE_SINGLE_CERTIFICATE,"false");
    Document securedDocument=doOutboundSecurityWithWSS4J(sourceDocument,action,properties);
    NodeList nodeList=securedDocument.getElementsByTagNameNS(WSSConstants.TAG_dsig_Signature.getNamespaceURI(),WSSConstants.TAG_dsig_Signature.getLocalPart());
    Assert.assertEquals(nodeList.item(0).getParentNode().getLocalName(),WSSConstants.TAG_WSSE_SECURITY.getLocalPart());
    javax.xml.transform.Transformer transformer=TRANSFORMER_FACTORY.newTransformer();
    transformer.transform(new DOMSource(securedDocument),new StreamResult(baos));
  }
{
    WSSSecurityProperties securityProperties=new WSSSecurityProperties();
    securityProperties.loadSignatureVerificationKeystore(this.getClass().getClassLoader().getResource("wss40CA.jks"),"security".toCharArray());
    String certConstraint=".*CN=Colm.*O=Apache.*";
    Pattern subjectDNPattern=Pattern.compile(certConstraint.trim());
    securityProperties.setSubjectCertConstraints(Collections.singletonList(subjectDNPattern));
    InboundWSSec wsSecIn=WSSec.getInboundWSSec(securityProperties);
    XMLStreamReader xmlStreamReader=wsSecIn.processInMessage(xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray())));
    Document document=StAX2DOM.readDoc(documentBuilderFactory.newDocumentBuilder(),xmlStreamReader);
    NodeList nodeList=document.getElementsByTagNameNS(WSSConstants.TAG_dsig_Signature.getNamespaceURI(),WSSConstants.TAG_dsig_Signature.getLocalPart());
    Assert.assertEquals(nodeList.getLength(),1);
    Assert.assertEquals(nodeList.item(0).getParentNode().getLocalName(),WSSConstants.TAG_WSSE_SECURITY.getLocalPart());
  }
{
    WSSSecurityProperties securityProperties=new WSSSecurityProperties();
    securityProperties.loadSignatureVerificationKeystore(this.getClass().getClassLoader().getResource("wss40CA.jks"),"security".toCharArray());
    String certConstraint=".*CN=Colm2.*O=Apache.*";
    Pattern subjectDNPattern=Pattern.compile(certConstraint.trim());
    securityProperties.setSubjectCertConstraints(Collections.singletonList(subjectDNPattern));
    InboundWSSec wsSecIn=WSSec.getInboundWSSec(securityProperties,false,true);
    XMLStreamReader xmlStreamReader=wsSecIn.processInMessage(xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray())));
    try {
      StAX2DOM.readDoc(documentBuilderFactory.newDocumentBuilder(),xmlStreamReader);
      Assert.fail("Expected failure on a incorrect cert constraint check");
    }
 catch (    Exception ex) {
      String errorMessage="The security token could not be authenticated or authorized";
      Assert.assertTrue(ex.getMessage().contains(errorMessage));
    }
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.wss4j.stax.test.SignatureConfirmationTest </h4><pre class="type-3 type-8 type-7 type-5 type-1 type-6 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testOutboundNoSignatureConfirmation() throws Exception {
  final List<SecurityEvent> securityEventList=new ArrayList<SecurityEvent>();
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
{
    WSSSecurityProperties securityProperties=new WSSSecurityProperties();
    List<WSSConstants.Action> actions=new ArrayList<WSSConstants.Action>();
    actions.add(WSSConstants.SIGNATURE);
    securityProperties.setActions(actions);
    securityProperties.loadSignatureKeyStore(this.getClass().getClassLoader().getResource("transmitter.jks"),"default".toCharArray());
    securityProperties.setSignatureUser("transmitter");
    securityProperties.setCallbackHandler(new CallbackHandlerImpl());
    SecurityEventListener securityEventListener=new SecurityEventListener(){
      @Override public void registerSecurityEvent(      SecurityEvent securityEvent) throws WSSecurityException {
        securityEventList.add(securityEvent);
      }
    }
;
    OutboundWSSec wsSecOut=WSSec.getOutboundWSSec(securityProperties);
    XMLStreamWriter xmlStreamWriter=wsSecOut.processOutMessage(baos,StandardCharsets.UTF_8.name(),new ArrayList<SecurityEvent>(),securityEventListener);
    XMLStreamReader xmlStreamReader=xmlInputFactory.createXMLStreamReader(this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml"));
    XmlReaderToWriter.writeAll(xmlStreamReader,xmlStreamWriter);
    xmlStreamWriter.close();
    Document document=documentBuilderFactory.newDocumentBuilder().parse(new ByteArrayInputStream(baos.toByteArray()));
    NodeList nodeList=document.getElementsByTagNameNS(WSSConstants.TAG_dsig_Signature.getNamespaceURI(),WSSConstants.TAG_dsig_Signature.getLocalPart());
    Assert.assertEquals(nodeList.item(0).getParentNode().getLocalName(),WSSConstants.TAG_WSSE_SECURITY.getLocalPart());
    nodeList=document.getElementsByTagNameNS(WSSConstants.TAG_dsig_Reference.getNamespaceURI(),WSSConstants.TAG_dsig_Reference.getLocalPart());
    Assert.assertEquals(nodeList.getLength(),1);
  }
{
    String action=WSHandlerConstants.SIGNATURE;
    doInboundSecurityWithWSS4J_1(documentBuilderFactory.newDocumentBuilder().parse(new ByteArrayInputStream(baos.toByteArray())),action);
  }
  baos=new ByteArrayOutputStream();
{
    InputStream sourceDocument=this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml");
    String action=WSHandlerConstants.SIGNATURE;
    Properties properties=new Properties();
    Map<String,Object> messageContext=doOutboundSecurityWithWSS4J_1(sourceDocument,action,properties);
    Document securedDocument=(Document)messageContext.get(SECURED_DOCUMENT);
    NodeList nodeList=securedDocument.getElementsByTagNameNS(WSSConstants.TAG_dsig_Signature.getNamespaceURI(),WSSConstants.TAG_dsig_Signature.getLocalPart());
    Assert.assertEquals(nodeList.item(0).getParentNode().getLocalName(),WSSConstants.TAG_WSSE_SECURITY.getLocalPart());
    nodeList=securedDocument.getElementsByTagNameNS(WSSConstants.TAG_WSSE11_SIG_CONF.getNamespaceURI(),WSSConstants.TAG_WSSE11_SIG_CONF.getLocalPart());
    Assert.assertEquals(nodeList.getLength(),0);
    nodeList=securedDocument.getElementsByTagNameNS(WSSConstants.NS_SOAP11,WSSConstants.TAG_SOAP_BODY_LN);
    Assert.assertEquals(nodeList.getLength(),1);
    String idAttrValue=((Element)nodeList.item(0)).getAttributeNS(WSSConstants.ATT_WSU_ID.getNamespaceURI(),WSSConstants.ATT_WSU_ID.getLocalPart());
    Assert.assertNotNull(idAttrValue);
    Assert.assertTrue(idAttrValue.length() > 0);
    javax.xml.transform.Transformer transformer=TRANSFORMER_FACTORY.newTransformer();
    transformer.transform(new DOMSource(securedDocument),new StreamResult(baos));
  }
{
    WSSSecurityProperties securityProperties=new WSSSecurityProperties();
    securityProperties.setEnableSignatureConfirmationVerification(true);
    securityProperties.loadSignatureVerificationKeystore(this.getClass().getClassLoader().getResource("transmitter.jks"),"default".toCharArray());
    InboundWSSec wsSecIn=WSSec.getInboundWSSec(securityProperties,false,true);
    XMLStreamReader xmlStreamReader=wsSecIn.processInMessage(xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray())),securityEventList);
    try {
      StAX2DOM.readDoc(documentBuilderFactory.newDocumentBuilder(),xmlStreamReader);
      Assert.fail("Expected XMLStreamException");
    }
 catch (    XMLStreamException e) {
      Assert.assertNotNull(e.getCause());
      Assert.assertTrue(e.getCause() instanceof WSSecurityException);
      Assert.assertEquals(((WSSecurityException)e.getCause()).getFaultCode(),WSSecurityException.INVALID_SECURITY);
    }
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.wss4j.stax.test.SignatureTest </h4><pre class="type-8 type-7 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testSignatureHMACOutputLengthInbound() throws Exception {
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
{
    InputStream sourceDocument=this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml");
    String action=WSHandlerConstants.SIGNATURE;
    Document securedDocument=doOutboundSecurityWithWSS4J(sourceDocument,action,new Properties());
    NodeList nodeList=securedDocument.getElementsByTagNameNS(WSSConstants.TAG_dsig_SignatureMethod.getNamespaceURI(),WSSConstants.TAG_dsig_SignatureMethod.getLocalPart());
    Element hmacElement=securedDocument.createElementNS(WSSConstants.TAG_dsig_HMACOutputLength.getNamespaceURI(),WSSConstants.TAG_dsig_HMACOutputLength.getLocalPart());
    hmacElement.setTextContent("abc");
    nodeList.item(0).appendChild(hmacElement);
    javax.xml.transform.Transformer transformer=TRANSFORMER_FACTORY.newTransformer();
    transformer.transform(new DOMSource(securedDocument),new StreamResult(baos));
  }
{
    WSSSecurityProperties securityProperties=new WSSSecurityProperties();
    securityProperties.loadSignatureVerificationKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
    InboundWSSec wsSecIn=WSSec.getInboundWSSec(securityProperties,false,true);
    XMLStreamReader xmlStreamReader=wsSecIn.processInMessage(xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray())));
    try {
      StAX2DOM.readDoc(documentBuilderFactory.newDocumentBuilder(),xmlStreamReader);
      Assert.fail("Should have thrown XMLStreamException");
    }
 catch (    XMLStreamException e) {
      Assert.assertTrue(e.getCause() instanceof WSSecurityException);
      Assert.assertEquals(((WSSecurityException)e.getCause()).getFaultCode(),WSSecurityException.INVALID_SECURITY);
    }
  }
}

</code></pre>

<br>
<pre class="type-3 type-8 type-7 type-5 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testInboundRequiredAlgorithm() throws Exception {
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
{
    InputStream sourceDocument=this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml");
    String action=WSHandlerConstants.SIGNATURE;
    Document securedDocument=doOutboundSecurityWithWSS4J(sourceDocument,action,new Properties());
    NodeList nodeList=securedDocument.getElementsByTagNameNS(WSSConstants.TAG_dsig_Signature.getNamespaceURI(),WSSConstants.TAG_dsig_Signature.getLocalPart());
    Assert.assertEquals(nodeList.item(0).getParentNode().getLocalName(),WSSConstants.TAG_WSSE_SECURITY.getLocalPart());
    javax.xml.transform.Transformer transformer=TRANSFORMER_FACTORY.newTransformer();
    transformer.transform(new DOMSource(securedDocument),new StreamResult(baos));
  }
{
    WSSSecurityProperties securityProperties=new WSSSecurityProperties();
    securityProperties.setSignatureAlgorithm(WSSConstants.NS_XMLDSIG_RSASHA1);
    securityProperties.loadSignatureVerificationKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
    InboundWSSec wsSecIn=WSSec.getInboundWSSec(securityProperties);
    XMLStreamReader xmlStreamReader=wsSecIn.processInMessage(xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray())));
    Document document=StAX2DOM.readDoc(documentBuilderFactory.newDocumentBuilder(),xmlStreamReader);
    NodeList nodeList=document.getElementsByTagNameNS(WSSConstants.TAG_dsig_Signature.getNamespaceURI(),WSSConstants.TAG_dsig_Signature.getLocalPart());
    Assert.assertEquals(nodeList.getLength(),1);
    Assert.assertEquals(nodeList.item(0).getParentNode().getLocalName(),WSSConstants.TAG_WSSE_SECURITY.getLocalPart());
  }
{
    WSSSecurityProperties securityProperties=new WSSSecurityProperties();
    securityProperties.setSignatureAlgorithm(WSSConstants.NS_XMLDSIG_HMACSHA1);
    securityProperties.loadSignatureVerificationKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
    InboundWSSec wsSecIn=WSSec.getInboundWSSec(securityProperties);
    try {
      XMLStreamReader xmlStreamReader=wsSecIn.processInMessage(xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray())));
      StAX2DOM.readDoc(documentBuilderFactory.newDocumentBuilder(),xmlStreamReader);
      Assert.fail("Failure expected on the wrong signature algorithm");
    }
 catch (    XMLStreamException e) {
      Assert.assertTrue(e.getCause() instanceof WSSecurityException);
    }
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testExceptionOnElementToSignNotFound() throws Exception {
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
{
    WSSSecurityProperties securityProperties=new WSSSecurityProperties();
    List<WSSConstants.Action> actions=new ArrayList<WSSConstants.Action>();
    actions.add(WSSConstants.SIGNATURE);
    securityProperties.setActions(actions);
    securityProperties.loadSignatureKeyStore(this.getClass().getClassLoader().getResource("transmitter.jks"),"default".toCharArray());
    securityProperties.setSignatureUser("transmitter");
    securityProperties.addSignaturePart(new SecurePart(new QName("http://www.wrongnamespace.org","complexType"),SecurePart.Modifier.Element));
    securityProperties.setCallbackHandler(new CallbackHandlerImpl());
    OutboundWSSec wsSecOut=WSSec.getOutboundWSSec(securityProperties);
    XMLStreamWriter xmlStreamWriter=wsSecOut.processOutMessage(baos,StandardCharsets.UTF_8.name(),new ArrayList<SecurityEvent>());
    XMLStreamReader xmlStreamReader=xmlInputFactory.createXMLStreamReader(this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml"));
    try {
      XmlReaderToWriter.writeAll(xmlStreamReader,xmlStreamWriter);
      xmlStreamWriter.close();
      Assert.fail("Exception expected");
    }
 catch (    XMLStreamException e) {
      Assert.assertTrue(e.getCause() instanceof XMLSecurityException);
      Assert.assertEquals("Part to sign not found: {http://www.wrongnamespace.org}complexType",e.getCause().getMessage());
    }
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testElementToSignNotFound() throws Exception {
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
{
    WSSSecurityProperties securityProperties=new WSSSecurityProperties();
    List<WSSConstants.Action> actions=new ArrayList<WSSConstants.Action>();
    actions.add(WSSConstants.SIGNATURE);
    securityProperties.setActions(actions);
    securityProperties.loadSignatureKeyStore(this.getClass().getClassLoader().getResource("transmitter.jks"),"default".toCharArray());
    securityProperties.setSignatureUser("transmitter");
    securityProperties.setTokenUser("transmitter");
    securityProperties.setCallbackHandler(new CallbackHandlerImpl());
    securityProperties.addSignaturePart(new SecurePart(new QName(WSSConstants.NS_WSSE10,"UsernameToken"),SecurePart.Modifier.Element));
    securityProperties.addSignaturePart(new SecurePart(new QName(WSSConstants.NS_SOAP11,"Body"),SecurePart.Modifier.Element));
    OutboundWSSec wsSecOut=WSSec.getOutboundWSSec(securityProperties);
    XMLStreamWriter xmlStreamWriter=wsSecOut.processOutMessage(baos,StandardCharsets.UTF_8.name(),new ArrayList<SecurityEvent>());
    XMLStreamReader xmlStreamReader=xmlInputFactory.createXMLStreamReader(this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml"));
    try {
      XmlReaderToWriter.writeAll(xmlStreamReader,xmlStreamWriter);
      xmlStreamWriter.close();
      Assert.fail("Exception expected");
    }
 catch (    XMLStreamException e) {
      Assert.assertTrue(e.getCause() instanceof XMLSecurityException);
      Assert.assertEquals("Part to sign not found: {http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd}UsernameToken",e.getCause().getMessage());
    }
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.wss4j.stax.test.TimestampTest </h4><pre class="type-3 type-8 type-7 type-5 type-1 type-6 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testTimestampInvalidNoExpiresDateInbound() throws Exception {
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
{
    InputStream sourceDocument=this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml");
    String action=WSHandlerConstants.TIMESTAMP;
    Document securedDocument=doOutboundSecurityWithWSS4J(sourceDocument,action,new Properties());
    NodeList nodeList=securedDocument.getElementsByTagNameNS(WSSConstants.TAG_WSU_TIMESTAMP.getNamespaceURI(),WSSConstants.TAG_WSU_TIMESTAMP.getLocalPart());
    Assert.assertEquals(nodeList.item(0).getParentNode().getLocalName(),WSSConstants.TAG_WSSE_SECURITY.getLocalPart());
    for (int i=0; i < nodeList.item(0).getChildNodes().getLength(); i++) {
      Node node=nodeList.item(0).getChildNodes().item(i);
      if (node.getNodeType() == Node.ELEMENT_NODE && node.getLocalName().equals("Expires")) {
        node.getParentNode().removeChild(node);
      }
    }
    javax.xml.transform.Transformer transformer=TRANSFORMER_FACTORY.newTransformer();
    transformer.transform(new DOMSource(securedDocument),new StreamResult(baos));
  }
{
    WSSSecurityProperties securityProperties=new WSSSecurityProperties();
    securityProperties.setRequireTimestampExpires(true);
    InboundWSSec wsSecIn=WSSec.getInboundWSSec(securityProperties);
    XMLStreamReader xmlStreamReader=wsSecIn.processInMessage(xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray())));
    try {
      StAX2DOM.readDoc(documentBuilderFactory.newDocumentBuilder(),xmlStreamReader);
      fail("Failure expected on no Expires Element");
    }
 catch (    XMLStreamException e) {
      Assert.assertNotNull(e.getCause());
      Assert.assertTrue(e.getCause() instanceof WSSecurityException);
    }
  }
{
    WSSSecurityProperties securityProperties=new WSSSecurityProperties();
    InboundWSSec wsSecIn=WSSec.getInboundWSSec(securityProperties);
    XMLStreamReader xmlStreamReader=wsSecIn.processInMessage(xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray())));
    Document document=StAX2DOM.readDoc(documentBuilderFactory.newDocumentBuilder(),xmlStreamReader);
    NodeList nodeList=document.getElementsByTagNameNS(WSSConstants.TAG_WSU_TIMESTAMP.getNamespaceURI(),WSSConstants.TAG_WSU_TIMESTAMP.getLocalPart());
    Assert.assertEquals(nodeList.getLength(),1);
    Assert.assertEquals(nodeList.item(0).getParentNode().getLocalName(),WSSConstants.TAG_WSSE_SECURITY.getLocalPart());
  }
}

</code></pre>

<br>
<pre class="type-3 type-8 type-7 type-5 type-1 type-6 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testTimestampNoChildsInbound() throws Exception {
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
{
    InputStream sourceDocument=this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml");
    String action=WSHandlerConstants.TIMESTAMP;
    Document securedDocument=doOutboundSecurityWithWSS4J(sourceDocument,action,new Properties());
    NodeList nodeList=securedDocument.getElementsByTagNameNS(WSSConstants.TAG_WSU_TIMESTAMP.getNamespaceURI(),WSSConstants.TAG_WSU_TIMESTAMP.getLocalPart());
    Assert.assertEquals(nodeList.item(0).getParentNode().getLocalName(),WSSConstants.TAG_WSSE_SECURITY.getLocalPart());
    List<Node> nodesToRemove=new ArrayList<Node>();
    for (int i=0; i < nodeList.item(0).getChildNodes().getLength(); i++) {
      Node node=nodeList.item(0).getChildNodes().item(i);
      if (node.getNodeType() == Node.ELEMENT_NODE && (node.getLocalName().equals("Created")) || node.getLocalName().equals("Expires")) {
        nodesToRemove.add(node);
      }
    }
    for (int i=0; i < nodesToRemove.size(); i++) {
      Node node=nodesToRemove.get(i);
      node.getParentNode().removeChild(node);
    }
    javax.xml.transform.Transformer transformer=TRANSFORMER_FACTORY.newTransformer();
    transformer.transform(new DOMSource(securedDocument),new StreamResult(baos));
  }
{
    WSSSecurityProperties securityProperties=new WSSSecurityProperties();
    securityProperties.addIgnoreBSPRule(BSPRule.R3203);
    InboundWSSec wsSecIn=WSSec.getInboundWSSec(securityProperties,false,true);
    XMLStreamReader xmlStreamReader=wsSecIn.processInMessage(xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray())));
    try {
      StAX2DOM.readDoc(documentBuilderFactory.newDocumentBuilder(),xmlStreamReader);
      Assert.fail("Expected XMLStreamException");
    }
 catch (    XMLStreamException e) {
      Throwable throwable=e.getCause();
      Assert.assertNotNull(throwable);
      Assert.assertTrue(throwable instanceof WSSecurityException);
      Assert.assertEquals(((WSSecurityException)throwable).getFaultCode(),WSSecurityException.INVALID_SECURITY);
    }
  }
}

</code></pre>

<br>
<pre class="type-3 type-8 type-7 type-5 type-1 type-6 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testTimestampInFutureInbound() throws Exception {
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
{
    InputStream sourceDocument=this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml");
    String action=WSHandlerConstants.TIMESTAMP;
    Properties outboundProperties=new Properties();
    outboundProperties.setProperty(WSHandlerConstants.TTL_TIMESTAMP,"1");
    Document securedDocument=doOutboundSecurityWithWSS4J(sourceDocument,action,outboundProperties);
    NodeList nodeList=securedDocument.getElementsByTagNameNS(WSSConstants.TAG_WSU_TIMESTAMP.getNamespaceURI(),WSSConstants.TAG_WSU_TIMESTAMP.getLocalPart());
    Assert.assertEquals(nodeList.item(0).getParentNode().getLocalName(),WSSConstants.TAG_WSSE_SECURITY.getLocalPart());
    Element created=(Element)((Element)nodeList.item(0)).getElementsByTagNameNS(WSSConstants.TAG_WSU_CREATED.getNamespaceURI(),WSSConstants.TAG_WSU_CREATED.getLocalPart()).item(0);
    Element expires=(Element)((Element)nodeList.item(0)).getElementsByTagNameNS(WSSConstants.TAG_WSU_EXPIRES.getNamespaceURI(),WSSConstants.TAG_WSU_EXPIRES.getLocalPart()).item(0);
    DatatypeFactory datatypeFactory=DatatypeFactory.newInstance();
    GregorianCalendar gregorianCalendarCreated=new GregorianCalendar();
    gregorianCalendarCreated.add(Calendar.HOUR,2);
    XMLGregorianCalendar xmlGregorianCalendarCreated=datatypeFactory.newXMLGregorianCalendar(gregorianCalendarCreated);
    created.setTextContent(xmlGregorianCalendarCreated.toXMLFormat());
    GregorianCalendar gregorianCalendarExpires=new GregorianCalendar();
    gregorianCalendarExpires.add(Calendar.HOUR,2);
    gregorianCalendarExpires.add(Calendar.SECOND,300);
    XMLGregorianCalendar xmlGregorianCalendarExpires=datatypeFactory.newXMLGregorianCalendar(gregorianCalendarExpires);
    expires.setTextContent(xmlGregorianCalendarExpires.toXMLFormat());
    javax.xml.transform.Transformer transformer=TRANSFORMER_FACTORY.newTransformer();
    transformer.transform(new DOMSource(securedDocument),new StreamResult(baos));
  }
{
    WSSSecurityProperties securityProperties=new WSSSecurityProperties();
    InboundWSSec wsSecIn=WSSec.getInboundWSSec(securityProperties,false,true);
    XMLStreamReader xmlStreamReader=wsSecIn.processInMessage(xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray())));
    try {
      StAX2DOM.readDoc(documentBuilderFactory.newDocumentBuilder(),xmlStreamReader);
      Assert.fail("Expected XMLStreamException");
    }
 catch (    XMLStreamException e) {
      Assert.assertNotNull(e.getCause());
      Assert.assertTrue(e.getCause() instanceof WSSecurityException);
      Assert.assertEquals(((WSSecurityException)e.getCause()).getFaultCode(),WSSecurityException.MESSAGE_EXPIRED);
    }
  }
{
    WSSSecurityProperties securityProperties=new WSSSecurityProperties();
    securityProperties.setTimeStampFutureTTL(2 * 60 * 60 + 100);
    InboundWSSec wsSecIn=WSSec.getInboundWSSec(securityProperties);
    XMLStreamReader xmlStreamReader=wsSecIn.processInMessage(xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray())));
    StAX2DOM.readDoc(documentBuilderFactory.newDocumentBuilder(),xmlStreamReader);
  }
}

</code></pre>

<br>
<pre class="type-3 type-8 type-7 type-5 type-1 type-6 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testDoubleTimestamp() throws Exception {
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
{
    InputStream sourceDocument=this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml");
    String action=WSHandlerConstants.TIMESTAMP;
    Document securedDocument=doOutboundSecurityWithWSS4J(sourceDocument,action,new Properties());
    NodeList nodeList=securedDocument.getElementsByTagNameNS(WSSConstants.TAG_WSU_TIMESTAMP.getNamespaceURI(),WSSConstants.TAG_WSU_TIMESTAMP.getLocalPart());
    Assert.assertEquals(nodeList.item(0).getParentNode().getLocalName(),WSSConstants.TAG_WSSE_SECURITY.getLocalPart());
    Node parentNode=nodeList.item(0).getParentNode();
    Node node=nodeList.item(0).cloneNode(true);
    securedDocument.adoptNode(node);
    parentNode.appendChild(node);
    javax.xml.transform.Transformer transformer=TRANSFORMER_FACTORY.newTransformer();
    transformer.transform(new DOMSource(securedDocument),new StreamResult(baos));
  }
{
    WSSSecurityProperties securityProperties=new WSSSecurityProperties();
    InboundWSSec wsSecIn=WSSec.getInboundWSSec(securityProperties,false,true);
    XMLStreamReader xmlStreamReader=wsSecIn.processInMessage(xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray())));
    try {
      StAX2DOM.readDoc(documentBuilderFactory.newDocumentBuilder(),xmlStreamReader);
      Assert.fail("Expected XMLStreamException");
    }
 catch (    XMLStreamException e) {
      Throwable throwable=e.getCause();
      Assert.assertNotNull(throwable);
      Assert.assertTrue(throwable instanceof WSSecurityException);
      Assert.assertEquals(((WSSecurityException)throwable).getFaultCode(),WSSecurityException.INVALID_SECURITY);
    }
  }
}

</code></pre>

<br>
<pre class="type-3 type-8 type-7 type-5 type-1 type-6 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testTimestampNoCreatedDateInbound() throws Exception {
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
{
    InputStream sourceDocument=this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml");
    String action=WSHandlerConstants.TIMESTAMP;
    Document securedDocument=doOutboundSecurityWithWSS4J(sourceDocument,action,new Properties());
    NodeList nodeList=securedDocument.getElementsByTagNameNS(WSSConstants.TAG_WSU_TIMESTAMP.getNamespaceURI(),WSSConstants.TAG_WSU_TIMESTAMP.getLocalPart());
    Assert.assertEquals(nodeList.item(0).getParentNode().getLocalName(),WSSConstants.TAG_WSSE_SECURITY.getLocalPart());
    for (int i=0; i < nodeList.item(0).getChildNodes().getLength(); i++) {
      Node node=nodeList.item(0).getChildNodes().item(i);
      if (node.getNodeType() == Node.ELEMENT_NODE && node.getLocalName().equals("Created")) {
        node.getParentNode().removeChild(node);
      }
    }
    javax.xml.transform.Transformer transformer=TRANSFORMER_FACTORY.newTransformer();
    transformer.transform(new DOMSource(securedDocument),new StreamResult(baos));
  }
{
    WSSSecurityProperties securityProperties=new WSSSecurityProperties();
    securityProperties.addIgnoreBSPRule(BSPRule.R3203);
    securityProperties.addIgnoreBSPRule(BSPRule.R3221);
    InboundWSSec wsSecIn=WSSec.getInboundWSSec(securityProperties,false,true);
    XMLStreamReader xmlStreamReader=wsSecIn.processInMessage(xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray())));
    try {
      StAX2DOM.readDoc(documentBuilderFactory.newDocumentBuilder(),xmlStreamReader);
      Assert.fail("Expected XMLStreamException");
    }
 catch (    XMLStreamException e) {
      Throwable throwable=e.getCause();
      Assert.assertNotNull(throwable);
      Assert.assertTrue(throwable instanceof WSSecurityException);
      Assert.assertEquals(((WSSecurityException)throwable).getFaultCode(),WSSecurityException.INVALID_SECURITY);
    }
  }
}

</code></pre>

<br>
<pre class="type-3 type-8 type-7 type-5 type-1 type-6 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testTimestampTTLInbound() throws Exception {
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
{
    InputStream sourceDocument=this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml");
    String action=WSHandlerConstants.TIMESTAMP;
    Properties outboundProperties=new Properties();
    outboundProperties.setProperty(WSHandlerConstants.TTL_TIMESTAMP,"300");
    Document securedDocument=doOutboundSecurityWithWSS4J(sourceDocument,action,outboundProperties);
    NodeList nodeList=securedDocument.getElementsByTagNameNS(WSSConstants.TAG_WSU_TIMESTAMP.getNamespaceURI(),WSSConstants.TAG_WSU_TIMESTAMP.getLocalPart());
    Assert.assertEquals(nodeList.item(0).getParentNode().getLocalName(),WSSConstants.TAG_WSSE_SECURITY.getLocalPart());
    javax.xml.transform.Transformer transformer=TRANSFORMER_FACTORY.newTransformer();
    transformer.transform(new DOMSource(securedDocument),new StreamResult(baos));
  }
  Thread.sleep(1500);
{
    WSSSecurityProperties securityProperties=new WSSSecurityProperties();
    securityProperties.setTimestampTTL(1);
    InboundWSSec wsSecIn=WSSec.getInboundWSSec(securityProperties,false,true);
    XMLStreamReader xmlStreamReader=wsSecIn.processInMessage(xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray())));
    try {
      StAX2DOM.readDoc(documentBuilderFactory.newDocumentBuilder(),xmlStreamReader);
      Assert.fail("Expected XMLStreamException");
    }
 catch (    XMLStreamException e) {
      Assert.assertNotNull(e.getCause());
      Assert.assertTrue(e.getCause() instanceof WSSecurityException);
      Assert.assertEquals(((WSSecurityException)e.getCause()).getFaultCode(),WSSecurityException.MESSAGE_EXPIRED);
    }
  }
}

</code></pre>

<br>
<pre class="type-3 type-8 type-7 type-5 type-1 type-6 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testTimestampExpiredEncryptedInbound() throws Exception {
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
{
    InputStream sourceDocument=this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml");
    String action=WSHandlerConstants.TIMESTAMP + " " + WSHandlerConstants.ENCRYPT;
    Properties outboundProperties=new Properties();
    outboundProperties.setProperty(WSHandlerConstants.TTL_TIMESTAMP,"1");
    outboundProperties.setProperty(WSHandlerConstants.ENCRYPTION_PARTS,"{Element}{http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd}Timestamp;");
    Document securedDocument=doOutboundSecurityWithWSS4J(sourceDocument,action,outboundProperties);
    NodeList nodeList=securedDocument.getElementsByTagNameNS(WSSConstants.TAG_xenc_EncryptedKey.getNamespaceURI(),WSSConstants.TAG_xenc_EncryptedKey.getLocalPart());
    Assert.assertEquals(nodeList.item(0).getParentNode().getLocalName(),WSSConstants.TAG_WSSE_SECURITY.getLocalPart());
    javax.xml.transform.Transformer transformer=TRANSFORMER_FACTORY.newTransformer();
    transformer.transform(new DOMSource(securedDocument),new StreamResult(baos));
  }
  Thread.sleep(1500);
{
    WSSSecurityProperties securityProperties=new WSSSecurityProperties();
    securityProperties.setCallbackHandler(new CallbackHandlerImpl());
    securityProperties.loadDecryptionKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
    InboundWSSec wsSecIn=WSSec.getInboundWSSec(securityProperties,false,true);
    XMLStreamReader xmlStreamReader=wsSecIn.processInMessage(xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray())));
    try {
      StAX2DOM.readDoc(documentBuilderFactory.newDocumentBuilder(),xmlStreamReader);
      Assert.fail("Expected XMLStreamException");
    }
 catch (    XMLStreamException e) {
      Assert.assertNotNull(e.getCause());
      Assert.assertTrue(e.getCause() instanceof WSSecurityException);
      Assert.assertEquals(((WSSecurityException)e.getCause()).getFaultCode(),WSSecurityException.MESSAGE_EXPIRED);
    }
  }
}

</code></pre>

<br>
<pre class="type-3 type-8 type-7 type-5 type-1 type-6 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testTimestampExpiredInbound() throws Exception {
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
{
    InputStream sourceDocument=this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml");
    String action=WSHandlerConstants.TIMESTAMP;
    Properties outboundProperties=new Properties();
    outboundProperties.setProperty(WSHandlerConstants.TTL_TIMESTAMP,"1");
    Document securedDocument=doOutboundSecurityWithWSS4J(sourceDocument,action,outboundProperties);
    NodeList nodeList=securedDocument.getElementsByTagNameNS(WSSConstants.TAG_WSU_TIMESTAMP.getNamespaceURI(),WSSConstants.TAG_WSU_TIMESTAMP.getLocalPart());
    Assert.assertEquals(nodeList.item(0).getParentNode().getLocalName(),WSSConstants.TAG_WSSE_SECURITY.getLocalPart());
    javax.xml.transform.Transformer transformer=TRANSFORMER_FACTORY.newTransformer();
    transformer.transform(new DOMSource(securedDocument),new StreamResult(baos));
  }
  Thread.sleep(1500);
{
    WSSSecurityProperties securityProperties=new WSSSecurityProperties();
    InboundWSSec wsSecIn=WSSec.getInboundWSSec(securityProperties,false,true);
    XMLStreamReader xmlStreamReader=wsSecIn.processInMessage(xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray())));
    try {
      StAX2DOM.readDoc(documentBuilderFactory.newDocumentBuilder(),xmlStreamReader);
      Assert.fail("Expected XMLStreamException");
    }
 catch (    XMLStreamException e) {
      Assert.assertNotNull(e.getCause());
      Assert.assertTrue(e.getCause() instanceof WSSecurityException);
      Assert.assertEquals(((WSSecurityException)e.getCause()).getFaultCode(),WSSecurityException.MESSAGE_EXPIRED);
    }
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.wss4j.stax.test.UsernameTokenTest </h4><pre class="type-8 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * This is a test for processing an "old" UsernameToken, i.e. one with a "Created" element that is
 * out of date
 */
@Test public void testOldUsernameToken() throws Exception {
  GregorianCalendar createdCalendar=new GregorianCalendar();
  createdCalendar.add(Calendar.SECOND,-301);
  XMLGregorianCalendar created=WSSConstants.datatypeFactory.newXMLGregorianCalendar(createdCalendar);
  String createdString=created.toXMLFormat();
  String digest=org.apache.wss4j.dom.message.token.UsernameToken.doPasswordDigest("Ex2YEKVvsa1qne1m6TM8XA==",createdString,"default");
  String req="<?xml version=\"1.0\" encoding=\"UTF_8\"?>" + "<env:Envelope xmlns:env=\"http://schemas.xmlsoap.org/soap/envelope/\">\n" + "    <env:Header>"+ "       <wsse:Security xmlns:wsse=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd\" xmlns:wsu=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\" env:mustUnderstand=\"1\">"+ "           <wsse:UsernameToken wsu:Id=\"UsernameToken-1\">"+ "               <wsse:Username>transmitter</wsse:Username>"+ "               <wsse:Password Type=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-username-token-profile-1.0#PasswordDigest\">" + digest + "</wsse:Password>"+ "               <wsse:Nonce EncodingType=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary\">Ex2YEKVvsa1qne1m6TM8XA==</wsse:Nonce>"+ "               <wsu:Created>"+ createdString+ "</wsu:Created>"+ "           </wsse:UsernameToken>"+ "       </wsse:Security>\n"+ "    </env:Header>\n"+ "    <env:Body>\n"+ "    </env:Body>\n"+ "</env:Envelope>";
  WSSSecurityProperties securityProperties=new WSSSecurityProperties();
  securityProperties.setCallbackHandler(new CallbackHandlerImpl());
  InboundWSSec wsSecIn=WSSec.getInboundWSSec(securityProperties,false,true);
  try {
    XMLStreamReader xmlStreamReader=wsSecIn.processInMessage(xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(req.getBytes())));
    StAX2DOM.readDoc(documentBuilderFactory.newDocumentBuilder(),xmlStreamReader);
    Assert.fail("Expected XMLStreamException");
  }
 catch (  XMLStreamException e) {
    Assert.assertEquals(((WSSecurityException)e.getCause()).getFaultCode(),WSSecurityException.MESSAGE_EXPIRED);
  }
}

</code></pre>

<br>
<pre class="type-8 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testReusedNonce() throws Exception {
  XMLGregorianCalendar created=WSSConstants.datatypeFactory.newXMLGregorianCalendar(new GregorianCalendar());
  String createdString=created.toXMLFormat();
  String digest=org.apache.wss4j.dom.message.token.UsernameToken.doPasswordDigest("Ex2YESUvsa1qne1m6TM8XA==",createdString,"default");
  String req="<?xml version=\"1.0\" encoding=\"UTF_8\"?>" + "<env:Envelope xmlns:env=\"http://schemas.xmlsoap.org/soap/envelope/\">\n" + "    <env:Header>"+ "       <wsse:Security xmlns:wsse=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd\" xmlns:wsu=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\" env:mustUnderstand=\"1\">"+ "           <wsse:UsernameToken wsu:Id=\"UsernameToken-1\">"+ "               <wsse:Username>transmitter</wsse:Username>"+ "               <wsse:Password Type=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-username-token-profile-1.0#PasswordDigest\">" + digest + "</wsse:Password>"+ "               <wsse:Nonce EncodingType=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary\">Ex2YESUvsa1qne1m6TM8XA==</wsse:Nonce>"+ "               <wsu:Created>"+ createdString+ "</wsu:Created>"+ "           </wsse:UsernameToken>"+ "       </wsse:Security>\n"+ "    </env:Header>\n"+ "    <env:Body>\n"+ "    </env:Body>\n"+ "</env:Envelope>";
  WSSSecurityProperties securityProperties=new WSSSecurityProperties();
  securityProperties.setCallbackHandler(new CallbackHandlerImpl());
  InboundWSSec wsSecIn=WSSec.getInboundWSSec(securityProperties,false,true);
  XMLStreamReader xmlStreamReader=wsSecIn.processInMessage(xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(req.getBytes())));
  StAX2DOM.readDoc(documentBuilderFactory.newDocumentBuilder(),xmlStreamReader);
  try {
    xmlStreamReader=wsSecIn.processInMessage(xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(req.getBytes())));
    StAX2DOM.readDoc(documentBuilderFactory.newDocumentBuilder(),xmlStreamReader);
    Assert.fail("Expected XMLStreamException");
  }
 catch (  XMLStreamException e) {
    Assert.assertEquals(((WSSecurityException)e.getCause()).getFaultCode(),WSSecurityException.FAILED_AUTHENTICATION);
  }
}

</code></pre>

<br>
<pre class="type-8 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * This is a test for processing a UsernameToken where the "Created" element is in the future.
 * A UsernameToken that is 120 seconds in the future should be rejected by default.
 */
@Test public void testFutureCreated() throws Exception {
  GregorianCalendar createdCalendar=new GregorianCalendar();
  createdCalendar.add(Calendar.SECOND,120);
  XMLGregorianCalendar created=WSSConstants.datatypeFactory.newXMLGregorianCalendar(createdCalendar);
  String createdString=created.toXMLFormat();
  String digest=org.apache.wss4j.dom.message.token.UsernameToken.doPasswordDigest("Ex2YEKVvsa1Qne1m6TM8XA==",createdString,"default");
  String req="<?xml version=\"1.0\" encoding=\"UTF_8\"?>" + "<env:Envelope xmlns:env=\"http://schemas.xmlsoap.org/soap/envelope/\">\n" + "    <env:Header>"+ "       <wsse:Security xmlns:wsse=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd\" xmlns:wsu=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\" env:mustUnderstand=\"1\">"+ "           <wsse:UsernameToken wsu:Id=\"UsernameToken-1\">"+ "               <wsse:Username>transmitter</wsse:Username>"+ "               <wsse:Password Type=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-username-token-profile-1.0#PasswordDigest\">" + digest + "</wsse:Password>"+ "               <wsse:Nonce EncodingType=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary\">Ex2YEKVvsa1Qne1m6TM8XA==</wsse:Nonce>"+ "               <wsu:Created>"+ createdString+ "</wsu:Created>"+ "           </wsse:UsernameToken>"+ "       </wsse:Security>\n"+ "    </env:Header>\n"+ "    <env:Body>\n"+ "    </env:Body>\n"+ "</env:Envelope>";
  WSSSecurityProperties securityProperties=new WSSSecurityProperties();
  securityProperties.setCallbackHandler(new CallbackHandlerImpl());
  InboundWSSec wsSecIn=WSSec.getInboundWSSec(securityProperties,false,true);
  try {
    XMLStreamReader xmlStreamReader=wsSecIn.processInMessage(xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(req.getBytes())));
    StAX2DOM.readDoc(documentBuilderFactory.newDocumentBuilder(),xmlStreamReader);
    Assert.fail("Expected XMLStreamException");
  }
 catch (  XMLStreamException e) {
    Assert.assertEquals(((WSSecurityException)e.getCause()).getFaultCode(),WSSecurityException.MESSAGE_EXPIRED);
  }
}

</code></pre>

<br>
<pre class="type-3 type-8 type-7 type-5 type-1 type-6 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testWrongUsername() throws Exception {
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
{
    InputStream sourceDocument=this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml");
    String action=WSHandlerConstants.USERNAME_TOKEN;
    Properties properties=new Properties();
    Document securedDocument=doOutboundSecurityWithWSS4J(sourceDocument,action,properties);
    NodeList nodeList=securedDocument.getElementsByTagNameNS(WSSConstants.TAG_WSSE_USERNAME_TOKEN.getNamespaceURI(),WSSConstants.TAG_WSSE_USERNAME_TOKEN.getLocalPart());
    Assert.assertEquals(nodeList.item(0).getParentNode().getLocalName(),WSSConstants.TAG_WSSE_SECURITY.getLocalPart());
    javax.xml.transform.Transformer transformer=TRANSFORMER_FACTORY.newTransformer();
    transformer.transform(new DOMSource(securedDocument),new StreamResult(baos));
  }
{
    WSSSecurityProperties securityProperties=new WSSSecurityProperties();
    securityProperties.setCallbackHandler(new CallbackHandlerImpl("wrongUsername"));
    InboundWSSec wsSecIn=WSSec.getInboundWSSec(securityProperties,false,true);
    XMLStreamReader xmlStreamReader=wsSecIn.processInMessage(xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray())));
    try {
      StAX2DOM.readDoc(documentBuilderFactory.newDocumentBuilder(),xmlStreamReader);
      Assert.fail("Expected XMLStreamException");
    }
 catch (    XMLStreamException e) {
      Assert.assertNotNull(e.getCause());
      Assert.assertTrue(e.getCause() instanceof WSSecurityException);
      Assert.assertEquals(e.getCause().getMessage(),"The security token could not be authenticated or authorized");
      Assert.assertEquals(((WSSecurityException)e.getCause()).getFaultCode(),WSSecurityException.FAILED_AUTHENTICATION);
    }
  }
}

</code></pre>

<br>
<pre class="type-3 type-8 type-5 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testInboundOutboundPW_NONE() throws Exception {
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
{
    WSSSecurityProperties securityProperties=new WSSSecurityProperties();
    List<WSSConstants.Action> actions=new ArrayList<WSSConstants.Action>();
    actions.add(WSSConstants.USERNAMETOKEN);
    securityProperties.setActions(actions);
    securityProperties.loadSignatureKeyStore(this.getClass().getClassLoader().getResource("transmitter.jks"),"default".toCharArray());
    securityProperties.setTokenUser("transmitter");
    securityProperties.setUsernameTokenPasswordType(WSSConstants.UsernameTokenPasswordType.PASSWORD_NONE);
    securityProperties.setCallbackHandler(new CallbackHandlerImpl());
    OutboundWSSec wsSecOut=WSSec.getOutboundWSSec(securityProperties);
    XMLStreamWriter xmlStreamWriter=wsSecOut.processOutMessage(baos,StandardCharsets.UTF_8.name(),new ArrayList<SecurityEvent>());
    XMLStreamReader xmlStreamReader=xmlInputFactory.createXMLStreamReader(this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml"));
    XmlReaderToWriter.writeAll(xmlStreamReader,xmlStreamWriter);
    xmlStreamWriter.close();
    Document securedDocument=documentBuilderFactory.newDocumentBuilder().parse(new ByteArrayInputStream(baos.toByteArray()));
    NodeList nodeList=securedDocument.getElementsByTagNameNS(WSSConstants.TAG_WSSE_USERNAME_TOKEN.getNamespaceURI(),WSSConstants.TAG_WSSE_USERNAME_TOKEN.getLocalPart());
    Assert.assertEquals(nodeList.item(0).getParentNode().getLocalName(),WSSConstants.TAG_WSSE_SECURITY.getLocalPart());
    nodeList=securedDocument.getElementsByTagNameNS(WSSConstants.TAG_WSSE_PASSWORD.getNamespaceURI(),WSSConstants.TAG_WSSE_PASSWORD.getLocalPart());
    Assert.assertEquals(nodeList.getLength(),0);
  }
  try {
    WSSSecurityProperties securityProperties=new WSSSecurityProperties();
    securityProperties.setCallbackHandler(new CallbackHandlerImpl());
    InboundWSSec wsSecIn=WSSec.getInboundWSSec(securityProperties,false,true);
    XMLStreamReader xmlStreamReader=wsSecIn.processInMessage(xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray())));
    xmlStreamReader=wsSecIn.processInMessage(xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray())));
    StAX2DOM.readDoc(documentBuilderFactory.newDocumentBuilder(),xmlStreamReader);
    Assert.fail("Expected XMLStreamException");
  }
 catch (  XMLStreamException e) {
    Assert.assertEquals(((WSSecurityException)e.getCause()).getFaultCode(),WSSecurityException.FAILED_AUTHENTICATION);
  }
{
    WSSSecurityProperties securityProperties=new WSSSecurityProperties();
    securityProperties.setAllowUsernameTokenNoPassword(true);
    securityProperties.setCallbackHandler(new CallbackHandlerImpl());
    InboundWSSec wsSecIn=WSSec.getInboundWSSec(securityProperties);
    XMLStreamReader xmlStreamReader=wsSecIn.processInMessage(xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray())));
    Document document=StAX2DOM.readDoc(documentBuilderFactory.newDocumentBuilder(),xmlStreamReader);
    NodeList nodeList=document.getElementsByTagNameNS(WSSConstants.TAG_WSSE_USERNAME_TOKEN.getNamespaceURI(),WSSConstants.TAG_WSSE_USERNAME_TOKEN.getLocalPart());
    Assert.assertEquals(nodeList.getLength(),1);
    Assert.assertEquals(nodeList.item(0).getParentNode().getLocalName(),WSSConstants.TAG_WSSE_SECURITY.getLocalPart());
  }
}

</code></pre>

<br>
<pre class="type-3 type-8 type-5 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testInboundPW_TEXT() throws Exception {
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
{
    InputStream sourceDocument=this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml");
    String action=WSHandlerConstants.USERNAME_TOKEN;
    Properties properties=new Properties();
    properties.setProperty(WSHandlerConstants.PASSWORD_TYPE,WSConstants.PW_TEXT);
    Document securedDocument=doOutboundSecurityWithWSS4J(sourceDocument,action,properties);
    NodeList nodeList=securedDocument.getElementsByTagNameNS(WSSConstants.TAG_WSSE_USERNAME_TOKEN.getNamespaceURI(),WSSConstants.TAG_WSSE_USERNAME_TOKEN.getLocalPart());
    Assert.assertEquals(nodeList.item(0).getParentNode().getLocalName(),WSSConstants.TAG_WSSE_SECURITY.getLocalPart());
    nodeList=securedDocument.getElementsByTagNameNS(WSSConstants.TAG_WSSE_PASSWORD.getNamespaceURI(),WSSConstants.TAG_WSSE_PASSWORD.getLocalPart());
    Assert.assertEquals(nodeList.getLength(),1);
    Assert.assertEquals(((Element)nodeList.item(0)).getAttributeNS(null,WSSConstants.ATT_NULL_Type.getLocalPart()),WSSConstants.UsernameTokenPasswordType.PASSWORD_TEXT.getNamespace());
    javax.xml.transform.Transformer transformer=TRANSFORMER_FACTORY.newTransformer();
    transformer.transform(new DOMSource(securedDocument),new StreamResult(baos));
  }
{
    WSSSecurityProperties securityProperties=new WSSSecurityProperties();
    securityProperties.setCallbackHandler(new CallbackHandlerImpl("username"));
    InboundWSSec wsSecIn=WSSec.getInboundWSSec(securityProperties,false,true);
    SecurityEventListener securityEventListener=new SecurityEventListener(){
      @Override public void registerSecurityEvent(      SecurityEvent securityEvent) throws WSSecurityException {
        if (securityEvent instanceof UsernameTokenSecurityEvent) {
          UsernameTokenSecurityEvent usernameTokenSecurityEvent=(UsernameTokenSecurityEvent)securityEvent;
          if (!"username".equals(usernameTokenSecurityEvent.getSecurityToken().getPrincipal().getName())) {
            throw new WSSecurityException(WSSecurityException.ErrorCode.FAILURE,"empty",new Object[]{"Wrong username"});
          }
        }
      }
    }
;
    XMLStreamReader xmlStreamReader=wsSecIn.processInMessage(xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray())),new ArrayList<SecurityEvent>(),securityEventListener);
    try {
      StAX2DOM.readDoc(documentBuilderFactory.newDocumentBuilder(),xmlStreamReader);
      Assert.fail("Expected XMLStreamException");
    }
 catch (    XMLStreamException e) {
      Assert.assertEquals(((WSSecurityException)e.getCause()).getFaultCode(),WSSecurityException.FAILED_AUTHENTICATION);
    }
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.wss4j.stax.test.VulnerabliltyVectorsTest </h4><pre class="type-8 type-7 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test if the RSA 1.5 key transport algorithm will be rejected by default.
 * Standard key transport algorithm is RSA-OAEP
 */
@Test public void testDisallowRSA15Algorithm() throws Exception {
  WSSSecurityProperties outboundSecurityProperties=new WSSSecurityProperties();
  outboundSecurityProperties.setCallbackHandler(new CallbackHandlerImpl());
  outboundSecurityProperties.setEncryptionUser("receiver");
  outboundSecurityProperties.loadEncryptionKeystore(this.getClass().getClassLoader().getResource("transmitter.jks"),"default".toCharArray());
  outboundSecurityProperties.setSignatureUser("transmitter");
  outboundSecurityProperties.loadSignatureKeyStore(this.getClass().getClassLoader().getResource("transmitter.jks"),"default".toCharArray());
  outboundSecurityProperties.setEncryptionKeyTransportAlgorithm("http://www.w3.org/2001/04/xmlenc#rsa-1_5");
  List<WSSConstants.Action> actions=new ArrayList<WSSConstants.Action>();
  actions.add(WSSConstants.TIMESTAMP);
  actions.add(WSSConstants.SIGNATURE);
  actions.add(WSSConstants.ENCRYPT);
  outboundSecurityProperties.setActions(actions);
  InputStream sourceDocument=this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml");
  ByteArrayOutputStream baos=doOutboundSecurity(outboundSecurityProperties,sourceDocument);
  WSSSecurityProperties inboundsecurityProperties=new WSSSecurityProperties();
  inboundsecurityProperties.setCallbackHandler(new CallbackHandlerImpl());
  inboundsecurityProperties.loadSignatureVerificationKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
  inboundsecurityProperties.loadDecryptionKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
  inboundsecurityProperties.addIgnoreBSPRule(BSPRule.R5421);
  try {
    doInboundSecurity(inboundsecurityProperties,xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray())));
    Assert.fail("Expected XMLStreamException");
  }
 catch (  XMLStreamException e) {
    Assert.assertTrue(e.getCause() instanceof WSSecurityException);
    Assert.assertEquals(((WSSecurityException)e.getCause()).getFaultCode(),WSSecurityException.FAILED_CHECK);
  }
}

</code></pre>

<br>
<pre class="type-8 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testMaximumAllowedXMLStructureDepthInEncryptedContent() throws Exception {
  if (getJavaSpecificationVersion() >= 1.7) {
    System.out.println("testAllowMD5Algorithm skipped");
    return;
  }
  InputStream sourceDocument=this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml");
  String action=WSHandlerConstants.TIMESTAMP + " " + WSHandlerConstants.SIGNATURE+ " "+ WSHandlerConstants.ENCRYPT;
  Properties properties=new Properties();
  properties.setProperty(WSHandlerConstants.SIGNATURE_PARTS,"{Element}{http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd}Timestamp;{Element}{http://schemas.xmlsoap.org/soap/envelope/}Body;");
  Document securedDocument=doOutboundSecurityWithWSS4J(sourceDocument,action,properties);
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  javax.xml.transform.Transformer transformer=TRANSFORMER_FACTORY.newTransformer();
  transformer.transform(new DOMSource(securedDocument),new StreamResult(baos));
  WSSSecurityProperties securityProperties=new WSSSecurityProperties();
  securityProperties.setCallbackHandler(new CallbackHandlerImpl());
  securityProperties.loadSignatureVerificationKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
  securityProperties.loadDecryptionKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
  int oldval=0;
  try {
    Init.init(WSSec.class.getClassLoader().getResource("wss/wss-config.xml").toURI(),WSSec.class);
    oldval=changeValueOfMaximumAllowedXMLStructureDepth(10);
    doInboundSecurity(securityProperties,xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray())));
    Assert.fail("Expected XMLStreamException");
  }
 catch (  XMLStreamException e) {
    Assert.assertEquals(e.getCause().getMessage(),"Maximum depth (10) of the XML structure reached. You can raise the maximum via the " + "\"MaximumAllowedXMLStructureDepth\" property in the configuration.");
  }
 finally {
    changeValueOfMaximumAllowedXMLStructureDepth(oldval);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testMaximumAllowedReferencesPerManifest() throws Exception {
  InputStream sourceDocument=this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml");
  String action=WSHandlerConstants.TIMESTAMP + " " + WSHandlerConstants.SIGNATURE+ " "+ WSHandlerConstants.ENCRYPT;
  Properties properties=new Properties();
  properties.setProperty(WSHandlerConstants.SIGNATURE_PARTS,"{Element}{http://www.w3.org/1999/XMLSchema}complexType;{Element}{http://www.w3.org/1999/XMLSchema}simpleType;");
  Document securedDocument=doOutboundSecurityWithWSS4J(sourceDocument,action,properties);
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  javax.xml.transform.Transformer transformer=TRANSFORMER_FACTORY.newTransformer();
  transformer.transform(new DOMSource(securedDocument),new StreamResult(baos));
  WSSSecurityProperties securityProperties=new WSSSecurityProperties();
  securityProperties.setCallbackHandler(new CallbackHandlerImpl());
  securityProperties.loadSignatureVerificationKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
  securityProperties.loadDecryptionKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
  try {
    doInboundSecurity(securityProperties,xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray())));
    Assert.fail("Expected XMLStreamException");
  }
 catch (  XMLStreamException e) {
    Assert.assertTrue(e.getCause() instanceof WSSecurityException);
    Assert.assertEquals(((WSSecurityException)e.getCause()).getFaultCode(),WSSecurityException.INVALID_SECURITY);
  }
}

</code></pre>

<br>
<pre class="type-3 type-8 type-1 type-6 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Tests if the framework is vulnerable to recursive key references
 * @throws Exception
 */
@Test public void testRecursiveKeyReferencesDOS() throws Exception {
  InputStream sourceDocument=this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml");
  String action=WSHandlerConstants.TIMESTAMP + " " + WSHandlerConstants.SIGNATURE+ " "+ WSHandlerConstants.ENCRYPT;
  Properties properties=new Properties();
  properties.setProperty(WSHandlerConstants.SIGNATURE_PARTS,"{Element}{http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd}Timestamp;{Element}{http://schemas.xmlsoap.org/soap/envelope/}Body;");
  Document securedDocument=doOutboundSecurityWithWSS4J(sourceDocument,action,properties);
  XPathExpression xPathExpression=getXPath("/soap:Envelope/soap:Header/wsse:Security/xenc:EncryptedKey");
  Element encryptedKeyElement=(Element)xPathExpression.evaluate(securedDocument,XPathConstants.NODE);
  encryptedKeyElement.removeAttribute("Id");
  encryptedKeyElement.setAttributeNS(null,"Id","G2");
  xPathExpression=getXPath(".//dsig:X509Data");
  Element keyIdentifierElement=(Element)xPathExpression.evaluate(encryptedKeyElement,XPathConstants.NODE);
  Element securityTokenReferenceElement=(Element)keyIdentifierElement.getParentNode();
  securityTokenReferenceElement.removeChild(keyIdentifierElement);
  Element referenceElement=securedDocument.createElementNS(WSSConstants.TAG_WSSE_REFERENCE.getNamespaceURI(),WSSConstants.TAG_WSSE_REFERENCE.getLocalPart());
  referenceElement.setAttributeNS(null,"URI","#G1");
  securityTokenReferenceElement.appendChild(referenceElement);
  Element clonedEncryptedElement=(Element)encryptedKeyElement.cloneNode(true);
  clonedEncryptedElement.removeAttribute("Id");
  clonedEncryptedElement.setAttributeNS(null,"Id","G1");
  xPathExpression=getXPath(".//wsse:Reference");
  Element newReferenceElement=(Element)xPathExpression.evaluate(clonedEncryptedElement,XPathConstants.NODE);
  newReferenceElement.removeAttribute("URI");
  newReferenceElement.setAttributeNS(null,"URI","#G2");
  Element securityHeaderNode=(Element)encryptedKeyElement.getParentNode();
  securityHeaderNode.insertBefore(clonedEncryptedElement,encryptedKeyElement);
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  javax.xml.transform.Transformer transformer=TRANSFORMER_FACTORY.newTransformer();
  transformer.transform(new DOMSource(securedDocument),new StreamResult(baos));
  WSSSecurityProperties securityProperties=new WSSSecurityProperties();
  securityProperties.setCallbackHandler(new CallbackHandlerImpl());
  securityProperties.loadSignatureVerificationKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
  securityProperties.loadDecryptionKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
  try {
    doInboundSecurity(securityProperties,xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray())));
    Assert.fail("Expected XMLStreamException");
  }
 catch (  XMLStreamException e) {
    Throwable throwable=e.getCause();
    Assert.assertNotNull(throwable);
    Assert.assertEquals(throwable.getMessage(),"Recursive key reference detected.");
  }
}

</code></pre>

<br>
<pre class="type-3 type-8 type-7 type-5 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testModifiedEncryptedKeyCipherValue() throws Exception {
  InputStream sourceDocument=this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml");
  String action=WSHandlerConstants.TIMESTAMP + " " + WSHandlerConstants.SIGNATURE+ " "+ WSHandlerConstants.ENCRYPT;
  Properties properties=new Properties();
  properties.setProperty(WSHandlerConstants.SIGNATURE_PARTS,"{Element}{http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd}Timestamp;{Element}{http://schemas.xmlsoap.org/soap/envelope/}Body;");
  Document securedDocument=doOutboundSecurityWithWSS4J(sourceDocument,action,properties);
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  NodeList cipherValues=securedDocument.getElementsByTagNameNS(WSSConstants.TAG_xenc_CipherValue.getNamespaceURI(),WSSConstants.TAG_xenc_CipherValue.getLocalPart());
  Element cipherValueElement=(Element)cipherValues.item(0);
  Assert.assertEquals(cipherValueElement.getParentNode().getParentNode().getLocalName(),WSSConstants.TAG_xenc_EncryptedKey.getLocalPart());
  String cipherValue=cipherValueElement.getTextContent();
  StringBuilder stringBuilder=new StringBuilder(cipherValue);
  int index=stringBuilder.length() / 2;
  char ch=stringBuilder.charAt(index);
  if (ch != 'A') {
    ch='A';
  }
 else {
    ch='B';
  }
  stringBuilder.setCharAt(index,ch);
  cipherValueElement.setTextContent(stringBuilder.toString());
  javax.xml.transform.Transformer transformer=TRANSFORMER_FACTORY.newTransformer();
  transformer.transform(new DOMSource(securedDocument),new StreamResult(baos));
  WSSSecurityProperties inboundsecurityProperties=new WSSSecurityProperties();
  inboundsecurityProperties.setCallbackHandler(new CallbackHandlerImpl());
  inboundsecurityProperties.loadSignatureVerificationKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
  inboundsecurityProperties.loadDecryptionKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
  try {
    doInboundSecurity(inboundsecurityProperties,xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray())));
    Assert.fail("Expected XMLStreamException");
  }
 catch (  XMLStreamException e) {
    Assert.assertFalse(e.getMessage().contains("data hash wrong"));
  }
}

</code></pre>

<br>
<pre class="type-3 type-8 type-7 type-6 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Since we don't support (yet) external URI refs this shouldn't be a problem.
 * <p/>
 * @throws Exception
 */
@Test public void test_publicURIReferenceDOS() throws Exception {
  InputStream sourceDocument=this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml");
  String action=WSHandlerConstants.TIMESTAMP + " " + WSHandlerConstants.SIGNATURE+ " "+ WSHandlerConstants.ENCRYPT;
  Properties properties=new Properties();
  properties.setProperty(WSHandlerConstants.SIGNATURE_PARTS,"{Element}{http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd}Timestamp;{Element}{http://schemas.xmlsoap.org/soap/envelope/}Body;");
  properties.setProperty(WSHandlerConstants.ENC_SYM_ALGO,"http://www.w3.org/2001/04/xmlenc#aes256-cbc");
  Document securedDocument=doOutboundSecurityWithWSS4J(sourceDocument,action,properties);
  XPathExpression xPathExpression=getXPath("//@URI");
  Attr uri=(Attr)xPathExpression.evaluate(securedDocument,XPathConstants.NODE);
  uri.setNodeValue("http://www.kernel.org/pub/linux/kernel/v2.6/linux-2.6.23.tar.gz");
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  javax.xml.transform.Transformer transformer=TRANSFORMER_FACTORY.newTransformer();
  transformer.transform(new DOMSource(securedDocument),new StreamResult(baos));
  WSSSecurityProperties inSecurityProperties=new WSSSecurityProperties();
  inSecurityProperties.setCallbackHandler(new CallbackHandlerImpl());
  inSecurityProperties.loadSignatureVerificationKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
  inSecurityProperties.loadDecryptionKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
  inSecurityProperties.addIgnoreBSPRule(BSPRule.R3006);
  try {
    doInboundSecurity(inSecurityProperties,xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray())));
    Assert.fail("Expected XMLStreamException");
  }
 catch (  XMLStreamException e) {
    Throwable throwable=e.getCause();
    Assert.assertNotNull(throwable);
    Assert.assertTrue(throwable.getMessage().contains("Invalid digest of reference "));
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testDisallowMD5Algorithm() throws Exception {
  WSSSecurityProperties outboundSecurityProperties=new WSSSecurityProperties();
  outboundSecurityProperties.setCallbackHandler(new CallbackHandlerImpl());
  outboundSecurityProperties.setEncryptionUser("receiver");
  outboundSecurityProperties.loadEncryptionKeystore(this.getClass().getClassLoader().getResource("transmitter.jks"),"default".toCharArray());
  outboundSecurityProperties.setSignatureUser("transmitter");
  outboundSecurityProperties.loadSignatureKeyStore(this.getClass().getClassLoader().getResource("transmitter.jks"),"default".toCharArray());
  outboundSecurityProperties.setSignatureAlgorithm("http://www.w3.org/2001/04/xmldsig-more#rsa-md5");
  List<WSSConstants.Action> actions=new ArrayList<WSSConstants.Action>();
  actions.add(WSSConstants.TIMESTAMP);
  actions.add(WSSConstants.SIGNATURE);
  actions.add(WSSConstants.ENCRYPT);
  outboundSecurityProperties.setActions(actions);
  InputStream sourceDocument=this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml");
  ByteArrayOutputStream baos=doOutboundSecurity(outboundSecurityProperties,sourceDocument);
  WSSSecurityProperties inboundsecurityProperties=new WSSSecurityProperties();
  inboundsecurityProperties.setCallbackHandler(new CallbackHandlerImpl());
  inboundsecurityProperties.loadSignatureVerificationKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
  inboundsecurityProperties.loadDecryptionKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
  inboundsecurityProperties.addIgnoreBSPRule(BSPRule.R5421);
  try {
    doInboundSecurity(inboundsecurityProperties,xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray())));
    Assert.fail("Expected XMLStreamException");
  }
 catch (  XMLStreamException e) {
    Assert.assertTrue(e.getCause() instanceof WSSecurityException);
    Assert.assertEquals(((WSSecurityException)e.getCause()).getFaultCode(),WSSecurityException.FAILED_CHECK);
  }
}

</code></pre>

<br>
<pre class="type-8 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testMaximumAllowedXMLStructureDepth() throws Exception {
  if (getJavaSpecificationVersion() >= 1.7) {
    System.out.println("testAllowMD5Algorithm skipped");
    return;
  }
  InputStream sourceDocument=this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml");
  String action=WSHandlerConstants.TIMESTAMP + " " + WSHandlerConstants.SIGNATURE;
  Properties properties=new Properties();
  properties.setProperty(WSHandlerConstants.SIGNATURE_PARTS,"{Element}{http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd}Timestamp;{Element}{http://schemas.xmlsoap.org/soap/envelope/}Body;");
  Document securedDocument=doOutboundSecurityWithWSS4J(sourceDocument,action,properties);
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  javax.xml.transform.Transformer transformer=TRANSFORMER_FACTORY.newTransformer();
  transformer.transform(new DOMSource(securedDocument),new StreamResult(baos));
  WSSSecurityProperties securityProperties=new WSSSecurityProperties();
  securityProperties.setCallbackHandler(new CallbackHandlerImpl());
  securityProperties.loadSignatureVerificationKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
  securityProperties.loadDecryptionKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
  int oldval=0;
  try {
    Init.init(WSSec.class.getClassLoader().getResource("wss/wss-config.xml").toURI(),WSSec.class);
    oldval=changeValueOfMaximumAllowedXMLStructureDepth(10);
    doInboundSecurity(securityProperties,xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray())));
    Assert.fail("Expected XMLStreamException");
  }
 catch (  XMLStreamException e) {
    Assert.assertEquals(e.getCause().getMessage(),"Maximum depth (10) of the XML structure reached. You can raise the maximum via the " + "\"MaximumAllowedXMLStructureDepth\" property in the configuration.");
  }
 finally {
    changeValueOfMaximumAllowedXMLStructureDepth(oldval);
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testMaximumAllowedTransformsPerReference() throws Exception {
  if (getJavaSpecificationVersion() > 1.7) {
    System.out.println("testMaximumAllowedTransformsPerReference skipped");
    return;
  }
  InputStream sourceDocument=this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml");
  String action=WSHandlerConstants.TIMESTAMP + " " + WSHandlerConstants.SIGNATURE+ " "+ WSHandlerConstants.ENCRYPT;
  Properties properties=new Properties();
  properties.setProperty(WSHandlerConstants.SIGNATURE_PARTS,"{Element}{http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd}Timestamp;{Element}{http://schemas.xmlsoap.org/soap/envelope/}Body;");
  Document securedDocument=doOutboundSecurityWithWSS4J(sourceDocument,action,properties);
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  javax.xml.transform.Transformer transformer=TRANSFORMER_FACTORY.newTransformer();
  transformer.transform(new DOMSource(securedDocument),new StreamResult(baos));
  WSSSecurityProperties securityProperties=new WSSSecurityProperties();
  securityProperties.setCallbackHandler(new CallbackHandlerImpl());
  securityProperties.loadSignatureVerificationKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
  securityProperties.loadDecryptionKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
  int oldval=0;
  try {
    Init.init(WSSec.class.getClassLoader().getResource("wss/wss-config.xml").toURI(),WSSec.class);
    oldval=changeValueOfMaximumAllowedTransformsPerReference(0);
    doInboundSecurity(securityProperties,xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray())));
    Assert.fail("Expected XMLStreamException");
  }
 catch (  XMLStreamException e) {
    Assert.assertTrue(e.getCause() instanceof WSSecurityException);
    Assert.assertEquals(((WSSecurityException)e.getCause()).getFaultCode(),WSSecurityException.INVALID_SECURITY);
  }
 finally {
    changeValueOfMaximumAllowedTransformsPerReference(oldval);
  }
}

</code></pre>

<br>
<pre class="type-3 type-8 type-5 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testReplayAttackInbound() throws Exception {
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
{
    InputStream sourceDocument=this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml");
    String action=WSHandlerConstants.TIMESTAMP + " " + WSHandlerConstants.SIGNATURE;
    Properties properties=new Properties();
    properties.setProperty(WSHandlerConstants.SIGNATURE_PARTS,"{Element}{http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd}Timestamp;{Element}{http://schemas.xmlsoap.org/soap/envelope/}Body;");
    Document securedDocument=doOutboundSecurityWithWSS4J(sourceDocument,action,properties);
    NodeList nodeList=securedDocument.getElementsByTagNameNS(WSSConstants.TAG_dsig_Signature.getNamespaceURI(),WSSConstants.TAG_dsig_Signature.getLocalPart());
    Assert.assertEquals(nodeList.item(0).getParentNode().getLocalName(),WSSConstants.TAG_WSSE_SECURITY.getLocalPart());
    javax.xml.transform.Transformer transformer=TRANSFORMER_FACTORY.newTransformer();
    transformer.transform(new DOMSource(securedDocument),new StreamResult(baos));
  }
{
    WSSSecurityProperties securityProperties=new WSSSecurityProperties();
    securityProperties.loadSignatureVerificationKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
    InboundWSSec wsSecIn=WSSec.getInboundWSSec(securityProperties,false,true);
    XMLStreamReader xmlStreamReader=wsSecIn.processInMessage(xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray())));
    StAX2DOM.readDoc(documentBuilderFactory.newDocumentBuilder(),xmlStreamReader);
    try {
      xmlStreamReader=wsSecIn.processInMessage(xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray())));
      StAX2DOM.readDoc(documentBuilderFactory.newDocumentBuilder(),xmlStreamReader);
      Assert.fail("Expected XMLStreamException");
    }
 catch (    XMLStreamException e) {
      Assert.assertEquals(((WSSecurityException)e.getCause()).getFaultCode(),WSSecurityException.MESSAGE_EXPIRED);
    }
  }
}

</code></pre>

<br>
<pre class="type-8 type-7 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test @SuppressWarnings("unchecked") public void testMaximumAllowedDecompressedBytes() throws Exception {
  long oldval=0;
  try {
    Init.init(WSSec.class.getClassLoader().getResource("wss/wss-config.xml").toURI(),WSSec.class);
    Field algorithmsClassMapField=TransformerAlgorithmMapper.class.getDeclaredField("algorithmsClassMapOut");
    algorithmsClassMapField.setAccessible(true);
    Map<String,Class<?>> map=(Map<String,Class<?>>)algorithmsClassMapField.get(null);
    map.put("http://www.apache.org/2012/04/xmlsec/xz",XZCompressorOutputStream.class);
    algorithmsClassMapField=TransformerAlgorithmMapper.class.getDeclaredField("algorithmsClassMapIn");
    algorithmsClassMapField.setAccessible(true);
    map=(Map<String,Class<?>>)algorithmsClassMapField.get(null);
    map.put("http://www.apache.org/2012/04/xmlsec/xz",XZCompressorInputStream.class);
    oldval=changeValueOfMaximumAllowedDecompressedBytes(101L);
    WSSSecurityProperties outboundSecurityProperties=new WSSSecurityProperties();
    outboundSecurityProperties.setCallbackHandler(new CallbackHandlerImpl());
    outboundSecurityProperties.setEncryptionUser("receiver");
    outboundSecurityProperties.loadEncryptionKeystore(this.getClass().getClassLoader().getResource("transmitter.jks"),"default".toCharArray());
    outboundSecurityProperties.setSignatureUser("transmitter");
    outboundSecurityProperties.loadSignatureKeyStore(this.getClass().getClassLoader().getResource("transmitter.jks"),"default".toCharArray());
    List<WSSConstants.Action> actions=new ArrayList<WSSConstants.Action>();
    actions.add(WSSConstants.TIMESTAMP);
    actions.add(WSSConstants.SIGNATURE);
    actions.add(WSSConstants.ENCRYPT);
    outboundSecurityProperties.setActions(actions);
    outboundSecurityProperties.setEncryptionCompressionAlgorithm("http://www.apache.org/2012/04/xmlsec/xz");
    InputStream sourceDocument=this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml");
    ByteArrayOutputStream baos=doOutboundSecurity(outboundSecurityProperties,sourceDocument);
    WSSSecurityProperties inboundSecurityProperties=new WSSSecurityProperties();
    inboundSecurityProperties.setCallbackHandler(new CallbackHandlerImpl());
    inboundSecurityProperties.loadSignatureVerificationKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
    inboundSecurityProperties.loadDecryptionKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
    doInboundSecurity(inboundSecurityProperties,xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray())));
    Assert.fail("Expected XMLStreamException");
  }
 catch (  XMLStreamException e) {
    Assert.assertTrue(e.getCause() instanceof IOException);
    Assert.assertEquals(e.getCause().getMessage(),"Maximum byte count (101) reached.");
  }
 finally {
    changeValueOfMaximumAllowedDecompressedBytes(oldval);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.wss4j.stax.test.saml.SAMLTokenNegativeTest </h4><pre class="type-3 type-8 type-5 type-1 type-6 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testSAML2SignedKeyHolderKeyModifiedInbound() throws Exception {
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
{
    SAML2CallbackHandler callbackHandler=new SAML2CallbackHandler();
    callbackHandler.setStatement(SAML2CallbackHandler.Statement.AUTHN);
    callbackHandler.setConfirmationMethod(SAML2Constants.CONF_HOLDER_KEY);
    callbackHandler.setIssuer("www.example.com");
    InputStream sourceDocument=this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml");
    String action=WSHandlerConstants.SAML_TOKEN_SIGNED;
    Properties properties=new Properties();
    properties.put(WSHandlerConstants.SAML_CALLBACK_REF,callbackHandler);
    Document securedDocument=doOutboundSecurityWithWSS4J(sourceDocument,action,properties);
    NodeList nodeList=securedDocument.getElementsByTagNameNS(WSSConstants.TAG_dsig_Signature.getNamespaceURI(),WSSConstants.TAG_dsig_Signature.getLocalPart());
    Assert.assertEquals(nodeList.getLength(),2);
    NodeList list=securedDocument.getElementsByTagNameNS(WSConstants.SAML2_NS,"Assertion");
    Element assertionElement=(Element)list.item(0);
    assertionElement.setAttributeNS(null,"MinorVersion","5");
    javax.xml.transform.Transformer transformer=TRANSFORMER_FACTORY.newTransformer();
    transformer.transform(new DOMSource(securedDocument),new StreamResult(baos));
  }
{
    WSSSecurityProperties securityProperties=new WSSSecurityProperties();
    securityProperties.loadSignatureVerificationKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
    InboundWSSec wsSecIn=WSSec.getInboundWSSec(securityProperties,false,true);
    XMLStreamReader xmlStreamReader=wsSecIn.processInMessage(xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray())));
    try {
      StAX2DOM.readDoc(documentBuilderFactory.newDocumentBuilder(),xmlStreamReader);
      Assert.fail("XMLStreamException expected");
    }
 catch (    XMLStreamException e) {
      Assert.assertNotNull(e.getCause());
      Assert.assertNotNull(e.getCause().getCause());
    }
  }
}

</code></pre>

<br>
<pre class="type-3 type-8 type-5 type-1 type-6 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testSAML1SignedKeyHolderSigModifiedInbound() throws Exception {
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
{
    SAML1CallbackHandler callbackHandler=new SAML1CallbackHandler();
    callbackHandler.setStatement(SAML1CallbackHandler.Statement.AUTHN);
    callbackHandler.setConfirmationMethod(SAML1Constants.CONF_HOLDER_KEY);
    callbackHandler.setIssuer("www.example.com");
    InputStream sourceDocument=this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml");
    String action=WSHandlerConstants.SAML_TOKEN_SIGNED;
    Properties properties=new Properties();
    properties.put(WSHandlerConstants.SAML_CALLBACK_REF,callbackHandler);
    properties.setProperty(WSHandlerConstants.SIG_KEY_ID,"DirectReference");
    Document securedDocument=doOutboundSecurityWithWSS4J(sourceDocument,action,properties);
    NodeList nodeList=securedDocument.getElementsByTagNameNS(WSSConstants.TAG_dsig_Signature.getNamespaceURI(),WSSConstants.TAG_dsig_Signature.getLocalPart());
    Assert.assertEquals(nodeList.getLength(),2);
    Element envelope=securedDocument.getDocumentElement();
    NodeList list=envelope.getElementsByTagNameNS(WSConstants.SAML_NS,"Assertion");
    Element assertionElement=(Element)list.item(0);
    list=assertionElement.getElementsByTagNameNS(WSConstants.SIG_NS,"Signature");
    Element sigElement=(Element)list.item(0);
    list=sigElement.getElementsByTagNameNS(WSConstants.SIG_NS,"Transform");
    Element transformElement=(Element)list.item(0);
    transformElement.setAttributeNS(null,"Algorithm",WSConstants.C14N_EXCL_OMIT_COMMENTS);
    javax.xml.transform.Transformer transformer=TRANSFORMER_FACTORY.newTransformer();
    transformer.transform(new DOMSource(securedDocument),new StreamResult(baos));
  }
{
    WSSSecurityProperties securityProperties=new WSSSecurityProperties();
    securityProperties.loadSignatureVerificationKeystore(this.getClass().getClassLoader().getResource("saml/issuer.jks"),"default".toCharArray());
    InboundWSSec wsSecIn=WSSec.getInboundWSSec(securityProperties,false,true);
    XMLStreamReader xmlStreamReader=wsSecIn.processInMessage(xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray())));
    try {
      StAX2DOM.readDoc(documentBuilderFactory.newDocumentBuilder(),xmlStreamReader);
      Assert.fail("XMLStreamException expected");
    }
 catch (    XMLStreamException e) {
      Assert.assertNotNull(e.getCause());
      Assert.assertNotNull(e.getCause().getCause());
    }
  }
}

</code></pre>

<br>
<pre class="type-3 type-8 type-5 type-1 type-6 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testSAML2TrustFailureInbound() throws Exception {
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
{
    SAML2CallbackHandler callbackHandler=new SAML2CallbackHandler();
    callbackHandler.setStatement(SAML2CallbackHandler.Statement.AUTHN);
    callbackHandler.setConfirmationMethod(SAML2Constants.CONF_HOLDER_KEY);
    callbackHandler.setIssuer("www.example.com");
    InputStream sourceDocument=this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml");
    String action=WSHandlerConstants.SAML_TOKEN_SIGNED;
    Properties properties=new Properties();
    properties.put(WSHandlerConstants.SAML_CALLBACK_REF,callbackHandler);
    properties.setProperty(WSHandlerConstants.SIG_KEY_ID,"DirectReference");
    Document securedDocument=doOutboundSecurityWithWSS4J(sourceDocument,action,properties);
    NodeList nodeList=securedDocument.getElementsByTagNameNS(WSSConstants.TAG_dsig_Signature.getNamespaceURI(),WSSConstants.TAG_dsig_Signature.getLocalPart());
    Assert.assertEquals(nodeList.getLength(),2);
    javax.xml.transform.Transformer transformer=TRANSFORMER_FACTORY.newTransformer();
    transformer.transform(new DOMSource(securedDocument),new StreamResult(baos));
  }
{
    WSSSecurityProperties securityProperties=new WSSSecurityProperties();
    securityProperties.loadSignatureVerificationKeystore(this.getClass().getClassLoader().getResource("transmitter.jks"),"default".toCharArray());
    InboundWSSec wsSecIn=WSSec.getInboundWSSec(securityProperties,false,true);
    XMLStreamReader xmlStreamReader=wsSecIn.processInMessage(xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray())));
    try {
      StAX2DOM.readDoc(documentBuilderFactory.newDocumentBuilder(),xmlStreamReader);
      Assert.fail("XMLStreamException expected");
    }
 catch (    XMLStreamException e) {
      Assert.assertNotNull(e.getCause());
    }
  }
}

</code></pre>

<br>
<pre class="type-3 type-8 type-5 type-1 type-6 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testSAML2AuthnAssertionModifiedInbound() throws Exception {
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
{
    SAML2CallbackHandler callbackHandler=new SAML2CallbackHandler();
    callbackHandler.setStatement(SAML2CallbackHandler.Statement.AUTHN);
    callbackHandler.setConfirmationMethod(SAML2Constants.CONF_SENDER_VOUCHES);
    callbackHandler.setIssuer("www.example.com");
    InputStream sourceDocument=this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml");
    String action=WSHandlerConstants.SAML_TOKEN_SIGNED;
    Properties properties=new Properties();
    properties.put(WSHandlerConstants.SAML_CALLBACK_REF,callbackHandler);
    properties.setProperty(WSHandlerConstants.SIG_KEY_ID,"DirectReference");
    Document securedDocument=doOutboundSecurityWithWSS4J(sourceDocument,action,properties);
    NodeList nodeList=securedDocument.getElementsByTagNameNS(WSSConstants.TAG_dsig_Signature.getNamespaceURI(),WSSConstants.TAG_dsig_Signature.getLocalPart());
    Assert.assertEquals(nodeList.getLength(),2);
    NodeList list=securedDocument.getElementsByTagNameNS(WSConstants.SAML2_NS,"Assertion");
    Element assertionElement=(Element)list.item(0);
    assertionElement.setAttributeNS(null,"MinorVersion","5");
    javax.xml.transform.Transformer transformer=TRANSFORMER_FACTORY.newTransformer();
    transformer.transform(new DOMSource(securedDocument),new StreamResult(baos));
  }
{
    WSSSecurityProperties securityProperties=new WSSSecurityProperties();
    securityProperties.loadSignatureVerificationKeystore(this.getClass().getClassLoader().getResource("saml/issuer.jks"),"default".toCharArray());
    InboundWSSec wsSecIn=WSSec.getInboundWSSec(securityProperties,false,true);
    WSSec.getInboundWSSec(securityProperties,false,true);
    XMLStreamReader xmlStreamReader=wsSecIn.processInMessage(xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray())));
    try {
      StAX2DOM.readDoc(documentBuilderFactory.newDocumentBuilder(),xmlStreamReader);
      Assert.fail("XMLStreamException expected");
    }
 catch (    XMLStreamException e) {
      Assert.assertNotNull(e.getCause());
      Assert.assertNotNull(e.getCause().getCause());
    }
  }
}

</code></pre>

<br>
<pre class="type-3 type-8 type-5 type-1 type-6 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testHOKNotSignedInbound() throws Exception {
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
{
    SAML1CallbackHandler callbackHandler=new SAML1CallbackHandler();
    callbackHandler.setStatement(SAML1CallbackHandler.Statement.AUTHN);
    callbackHandler.setConfirmationMethod(SAML1Constants.CONF_HOLDER_KEY);
    callbackHandler.setIssuer("www.example.com");
    callbackHandler.setSignAssertion(false);
    InputStream sourceDocument=this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml");
    String action=WSHandlerConstants.SAML_TOKEN_UNSIGNED;
    Properties properties=new Properties();
    properties.put(WSHandlerConstants.SAML_CALLBACK_REF,callbackHandler);
    Document securedDocument=doOutboundSecurityWithWSS4J(sourceDocument,action,properties);
    NodeList nodeList=securedDocument.getElementsByTagNameNS(WSSConstants.TAG_dsig_Signature.getNamespaceURI(),WSSConstants.TAG_dsig_Signature.getLocalPart());
    Assert.assertEquals(nodeList.getLength(),0);
    javax.xml.transform.Transformer transformer=TRANSFORMER_FACTORY.newTransformer();
    transformer.transform(new DOMSource(securedDocument),new StreamResult(baos));
  }
{
    WSSSecurityProperties securityProperties=new WSSSecurityProperties();
    securityProperties.loadSignatureVerificationKeystore(this.getClass().getClassLoader().getResource("saml/issuer.jks"),"default".toCharArray());
    InboundWSSec wsSecIn=WSSec.getInboundWSSec(securityProperties,false,true);
    XMLStreamReader xmlStreamReader=wsSecIn.processInMessage(xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray())));
    try {
      StAX2DOM.readDoc(documentBuilderFactory.newDocumentBuilder(),xmlStreamReader);
      Assert.fail("XMLStreamException expected");
    }
 catch (    XMLStreamException e) {
      Assert.assertNotNull(e.getCause());
    }
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.wss4j.stax.test.saml.SAMLTokenTest </h4><pre class="type-3 type-8 type-7 type-5 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testUnsignedBearer() throws Exception {
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
{
    SAML2CallbackHandler callbackHandler=new SAML2CallbackHandler();
    callbackHandler.setStatement(SAML2CallbackHandler.Statement.AUTHN);
    callbackHandler.setIssuer("www.example.com");
    callbackHandler.setConfirmationMethod(SAML2Constants.CONF_BEARER);
    callbackHandler.setSignAssertion(false);
    InputStream sourceDocument=this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml");
    String action=WSHandlerConstants.SAML_TOKEN_UNSIGNED + " " + WSHandlerConstants.SIGNATURE;
    Properties properties=new Properties();
    properties.put(WSHandlerConstants.SAML_CALLBACK_REF,callbackHandler);
    properties.setProperty(WSHandlerConstants.SIGNATURE_PARTS,"{Element}{urn:oasis:names:tc:SAML:2.0:assertion}Assertion;{Element}{http://schemas.xmlsoap.org/soap/envelope/}Body;");
    Document securedDocument=doOutboundSecurityWithWSS4J(sourceDocument,action,properties);
    NodeList nodeList=securedDocument.getElementsByTagNameNS(WSSConstants.TAG_dsig_Signature.getNamespaceURI(),WSSConstants.TAG_dsig_Signature.getLocalPart());
    Assert.assertEquals(nodeList.getLength(),1);
    javax.xml.transform.Transformer transformer=TRANSFORMER_FACTORY.newTransformer();
    transformer.transform(new DOMSource(securedDocument),new StreamResult(baos));
  }
{
    WSSSecurityProperties securityProperties=new WSSSecurityProperties();
    securityProperties.loadSignatureVerificationKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
    securityProperties.setSamlCallbackHandler(new SAMLCallbackHandlerImpl());
    InboundWSSec wsSecIn=WSSec.getInboundWSSec(securityProperties);
    XMLStreamReader xmlStreamReader=wsSecIn.processInMessage(xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray())));
    try {
      StAX2DOM.readDoc(documentBuilderFactory.newDocumentBuilder(),xmlStreamReader);
      fail("Failure expected on an unsigned bearer token");
    }
 catch (    XMLStreamException e) {
      Assert.assertTrue(e.getCause() instanceof XMLSecurityException);
    }
  }
{
    WSSSecurityProperties securityProperties=new WSSSecurityProperties();
    securityProperties.loadSignatureVerificationKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
    securityProperties.setSamlCallbackHandler(new SAMLCallbackHandlerImpl());
    SamlTokenValidatorImpl validator=new SamlTokenValidatorImpl();
    validator.setRequireBearerSignature(false);
    securityProperties.addValidator(WSSConstants.TAG_SAML2_ASSERTION,validator);
    securityProperties.addValidator(WSSConstants.TAG_SAML_ASSERTION,validator);
    InboundWSSec wsSecIn=WSSec.getInboundWSSec(securityProperties);
    XMLStreamReader xmlStreamReader=wsSecIn.processInMessage(xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray())));
    StAX2DOM.readDoc(documentBuilderFactory.newDocumentBuilder(),xmlStreamReader);
  }
}

</code></pre>

<br>
<pre class="type-3 type-8 type-7 type-5 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testStandardSubjectConfirmationMethod() throws Exception {
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
{
    SAML2CallbackHandler callbackHandler=new SAML2CallbackHandler();
    callbackHandler.setStatement(SAML2CallbackHandler.Statement.AUTHN);
    callbackHandler.setIssuer("www.example.com");
    callbackHandler.setConfirmationMethod("urn:oasis:names:tc:SAML:2.0:cm:custom");
    callbackHandler.setSignAssertion(false);
    InputStream sourceDocument=this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml");
    String action=WSHandlerConstants.SAML_TOKEN_UNSIGNED + " " + WSHandlerConstants.SIGNATURE;
    Properties properties=new Properties();
    properties.put(WSHandlerConstants.SAML_CALLBACK_REF,callbackHandler);
    properties.setProperty(WSHandlerConstants.SIGNATURE_PARTS,"{Element}{urn:oasis:names:tc:SAML:2.0:assertion}Assertion;{Element}{http://schemas.xmlsoap.org/soap/envelope/}Body;");
    Document securedDocument=doOutboundSecurityWithWSS4J(sourceDocument,action,properties);
    NodeList nodeList=securedDocument.getElementsByTagNameNS(WSSConstants.TAG_dsig_Signature.getNamespaceURI(),WSSConstants.TAG_dsig_Signature.getLocalPart());
    Assert.assertEquals(nodeList.getLength(),1);
    javax.xml.transform.Transformer transformer=TRANSFORMER_FACTORY.newTransformer();
    transformer.transform(new DOMSource(securedDocument),new StreamResult(baos));
  }
{
    WSSSecurityProperties securityProperties=new WSSSecurityProperties();
    securityProperties.loadSignatureVerificationKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
    securityProperties.setSamlCallbackHandler(new SAMLCallbackHandlerImpl());
    InboundWSSec wsSecIn=WSSec.getInboundWSSec(securityProperties);
    XMLStreamReader xmlStreamReader=wsSecIn.processInMessage(xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray())));
    try {
      StAX2DOM.readDoc(documentBuilderFactory.newDocumentBuilder(),xmlStreamReader);
      fail("Failure expected on an unknown subject confirmation method");
    }
 catch (    XMLStreamException e) {
      Assert.assertTrue(e.getCause() instanceof XMLSecurityException);
    }
  }
{
    WSSSecurityProperties securityProperties=new WSSSecurityProperties();
    securityProperties.loadSignatureVerificationKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
    securityProperties.setSamlCallbackHandler(new SAMLCallbackHandlerImpl());
    SamlTokenValidatorImpl validator=new SamlTokenValidatorImpl();
    validator.setRequireStandardSubjectConfirmationMethod(false);
    securityProperties.addValidator(WSSConstants.TAG_SAML2_ASSERTION,validator);
    securityProperties.addValidator(WSSConstants.TAG_SAML_ASSERTION,validator);
    InboundWSSec wsSecIn=WSSec.getInboundWSSec(securityProperties);
    XMLStreamReader xmlStreamReader=wsSecIn.processInMessage(xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray())));
    StAX2DOM.readDoc(documentBuilderFactory.newDocumentBuilder(),xmlStreamReader);
  }
}

</code></pre>

<br>
<pre class="type-3 type-8 type-7 type-5 type-1 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testRequiredSubjectConfirmationMethod() throws Exception {
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
{
    SAML2CallbackHandler callbackHandler=new SAML2CallbackHandler();
    callbackHandler.setStatement(SAML2CallbackHandler.Statement.AUTHN);
    callbackHandler.setIssuer("www.example.com");
    callbackHandler.setSignAssertion(false);
    InputStream sourceDocument=this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml");
    String action=WSHandlerConstants.SAML_TOKEN_UNSIGNED + " " + WSHandlerConstants.SIGNATURE;
    Properties properties=new Properties();
    properties.put(WSHandlerConstants.SAML_CALLBACK_REF,callbackHandler);
    properties.setProperty(WSHandlerConstants.SIGNATURE_PARTS,"{Element}{urn:oasis:names:tc:SAML:2.0:assertion}Assertion;{Element}{http://schemas.xmlsoap.org/soap/envelope/}Body;");
    Document securedDocument=doOutboundSecurityWithWSS4J(sourceDocument,action,properties);
    NodeList nodeList=securedDocument.getElementsByTagNameNS(WSSConstants.TAG_dsig_Signature.getNamespaceURI(),WSSConstants.TAG_dsig_Signature.getLocalPart());
    Assert.assertEquals(nodeList.getLength(),1);
    javax.xml.transform.Transformer transformer=TRANSFORMER_FACTORY.newTransformer();
    transformer.transform(new DOMSource(securedDocument),new StreamResult(baos));
  }
{
    WSSSecurityProperties securityProperties=new WSSSecurityProperties();
    securityProperties.loadSignatureVerificationKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
    securityProperties.setSamlCallbackHandler(new SAMLCallbackHandlerImpl());
    SamlTokenValidatorImpl validator=new SamlTokenValidatorImpl();
    validator.setRequiredSubjectConfirmationMethod(SAML2Constants.CONF_SENDER_VOUCHES);
    securityProperties.addValidator(WSSConstants.TAG_SAML2_ASSERTION,validator);
    securityProperties.addValidator(WSSConstants.TAG_SAML_ASSERTION,validator);
    InboundWSSec wsSecIn=WSSec.getInboundWSSec(securityProperties);
    XMLStreamReader xmlStreamReader=wsSecIn.processInMessage(xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray())));
    Document document=StAX2DOM.readDoc(documentBuilderFactory.newDocumentBuilder(),xmlStreamReader);
    NodeList nodeList=document.getElementsByTagNameNS(WSSConstants.TAG_dsig_Signature.getNamespaceURI(),WSSConstants.TAG_dsig_Signature.getLocalPart());
    Assert.assertEquals(nodeList.getLength(),1);
  }
  baos=new ByteArrayOutputStream();
{
    SAML2CallbackHandler callbackHandler=new SAML2CallbackHandler();
    callbackHandler.setStatement(SAML2CallbackHandler.Statement.AUTHN);
    callbackHandler.setConfirmationMethod(SAML2Constants.CONF_BEARER);
    callbackHandler.setIssuer("www.example.com");
    callbackHandler.setSignAssertion(false);
    InputStream sourceDocument=this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml");
    String action=WSHandlerConstants.SAML_TOKEN_UNSIGNED + " " + WSHandlerConstants.SIGNATURE;
    Properties properties=new Properties();
    properties.put(WSHandlerConstants.SAML_CALLBACK_REF,callbackHandler);
    properties.setProperty(WSHandlerConstants.SIGNATURE_PARTS,"{Element}{urn:oasis:names:tc:SAML:2.0:assertion}Assertion;{Element}{http://schemas.xmlsoap.org/soap/envelope/}Body;");
    Document securedDocument=doOutboundSecurityWithWSS4J(sourceDocument,action,properties);
    NodeList nodeList=securedDocument.getElementsByTagNameNS(WSSConstants.TAG_dsig_Signature.getNamespaceURI(),WSSConstants.TAG_dsig_Signature.getLocalPart());
    Assert.assertEquals(nodeList.getLength(),1);
    javax.xml.transform.Transformer transformer=TRANSFORMER_FACTORY.newTransformer();
    transformer.transform(new DOMSource(securedDocument),new StreamResult(baos));
  }
{
    WSSSecurityProperties securityProperties=new WSSSecurityProperties();
    securityProperties.loadSignatureVerificationKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
    securityProperties.setSamlCallbackHandler(new SAMLCallbackHandlerImpl());
    SamlTokenValidatorImpl validator=new SamlTokenValidatorImpl();
    validator.setRequiredSubjectConfirmationMethod(SAML2Constants.CONF_SENDER_VOUCHES);
    securityProperties.addValidator(WSSConstants.TAG_SAML2_ASSERTION,validator);
    securityProperties.addValidator(WSSConstants.TAG_SAML_ASSERTION,validator);
    InboundWSSec wsSecIn=WSSec.getInboundWSSec(securityProperties);
    XMLStreamReader xmlStreamReader=wsSecIn.processInMessage(xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray())));
    try {
      StAX2DOM.readDoc(documentBuilderFactory.newDocumentBuilder(),xmlStreamReader);
      fail("Failure expected on a Bearer assertion");
    }
 catch (    XMLStreamException e) {
      Assert.assertTrue(e.getCause() instanceof XMLSecurityException);
    }
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.wss4j.stax.test.saml.SamlConditionsTest </h4><pre class="type-8 type-6 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test that creates, sends and processes an unsigned SAML 2 authentication assertion
 * with an (invalid) custom Conditions statement.
 */
@Test public void testSAML2InvalidBeforeConditionsInbound() throws Exception {
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
{
    SAML2CallbackHandler callbackHandler=new SAML2CallbackHandler();
    callbackHandler.setStatement(SAML2CallbackHandler.Statement.AUTHN);
    callbackHandler.setIssuer("www.example.com");
    ConditionsBean conditions=new ConditionsBean();
    DateTime notBefore=new DateTime();
    conditions.setNotBefore(notBefore.plusMinutes(2));
    conditions.setNotAfter(notBefore.plusMinutes(5));
    callbackHandler.setConditions(conditions);
    InputStream sourceDocument=this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml");
    String action=WSHandlerConstants.SAML_TOKEN_SIGNED;
    Properties properties=new Properties();
    properties.put(WSHandlerConstants.SAML_CALLBACK_REF,callbackHandler);
    Document securedDocument=doOutboundSecurityWithWSS4J(sourceDocument,action,properties);
    javax.xml.transform.Transformer transformer=TRANSFORMER_FACTORY.newTransformer();
    transformer.transform(new DOMSource(securedDocument),new StreamResult(baos));
  }
{
    WSSSecurityProperties securityProperties=new WSSSecurityProperties();
    securityProperties.loadSignatureVerificationKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
    InboundWSSec wsSecIn=WSSec.getInboundWSSec(securityProperties);
    XMLStreamReader xmlStreamReader=wsSecIn.processInMessage(xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray())));
    try {
      StAX2DOM.readDoc(documentBuilderFactory.newDocumentBuilder(),xmlStreamReader);
      Assert.fail("XMLStreamException expected");
    }
 catch (    XMLStreamException e) {
      Assert.assertNotNull(e.getCause());
    }
  }
}

</code></pre>

<br>
<pre class="type-3 type-8 type-5 type-6 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testSAML1AudienceRestrictionSeparateRestrictionsValidation() throws Exception {
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
{
    SAML2CallbackHandler callbackHandler=new SAML2CallbackHandler();
    callbackHandler.setStatement(SAML2CallbackHandler.Statement.AUTHN);
    callbackHandler.setIssuer("www.example.com");
    ConditionsBean conditions=new ConditionsBean();
    conditions.setTokenPeriodMinutes(5);
    List<AudienceRestrictionBean> audiencesRestrictions=new ArrayList<AudienceRestrictionBean>();
    AudienceRestrictionBean audienceRestrictionBean=new AudienceRestrictionBean();
    audienceRestrictionBean.setAudienceURIs(Collections.singletonList("http://apache.org/one"));
    audiencesRestrictions.add(audienceRestrictionBean);
    audienceRestrictionBean=new AudienceRestrictionBean();
    audienceRestrictionBean.setAudienceURIs(Collections.singletonList("http://apache.org/two"));
    audiencesRestrictions.add(audienceRestrictionBean);
    conditions.setAudienceRestrictions(audiencesRestrictions);
    callbackHandler.setConditions(conditions);
    InputStream sourceDocument=this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml");
    String action=WSHandlerConstants.SAML_TOKEN_SIGNED;
    Properties properties=new Properties();
    properties.put(WSHandlerConstants.SAML_CALLBACK_REF,callbackHandler);
    Document securedDocument=doOutboundSecurityWithWSS4J(sourceDocument,action,properties);
    javax.xml.transform.Transformer transformer=TRANSFORMER_FACTORY.newTransformer();
    transformer.transform(new DOMSource(securedDocument),new StreamResult(baos));
  }
  List<String> audiences=new ArrayList<String>();
  audiences.add("http://apache.org/three");
{
    WSSSecurityProperties securityProperties=new WSSSecurityProperties();
    securityProperties.loadSignatureVerificationKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
    securityProperties.setAudienceRestrictions(audiences);
    InboundWSSec wsSecIn=WSSec.getInboundWSSec(securityProperties);
    XMLStreamReader xmlStreamReader=wsSecIn.processInMessage(xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray())));
    try {
      StAX2DOM.readDoc(documentBuilderFactory.newDocumentBuilder(),xmlStreamReader);
      Assert.fail("XMLStreamException expected");
    }
 catch (    XMLStreamException e) {
      Assert.assertNotNull(e.getCause());
    }
  }
  audiences.add("http://apache.org/one");
{
    WSSSecurityProperties securityProperties=new WSSSecurityProperties();
    securityProperties.loadSignatureVerificationKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
    securityProperties.setAudienceRestrictions(audiences);
    InboundWSSec wsSecIn=WSSec.getInboundWSSec(securityProperties);
    XMLStreamReader xmlStreamReader=wsSecIn.processInMessage(xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray())));
    Document document=StAX2DOM.readDoc(documentBuilderFactory.newDocumentBuilder(),xmlStreamReader);
    Assert.assertNotNull(document);
  }
}

</code></pre>

<br>
<pre class="type-8 type-6 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testSAML2FutureNotBefore() throws Exception {
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
{
    SAML2CallbackHandler callbackHandler=new SAML2CallbackHandler();
    callbackHandler.setStatement(SAML2CallbackHandler.Statement.AUTHN);
    callbackHandler.setIssuer("www.example.com");
    ConditionsBean conditions=new ConditionsBean();
    DateTime notBefore=new DateTime();
    conditions.setNotAfter(new DateTime().plusMinutes(70));
    conditions.setNotBefore(notBefore.plusMinutes(60));
    callbackHandler.setConditions(conditions);
    InputStream sourceDocument=this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml");
    String action=WSHandlerConstants.SAML_TOKEN_SIGNED;
    Properties properties=new Properties();
    properties.put(WSHandlerConstants.SAML_CALLBACK_REF,callbackHandler);
    Document securedDocument=doOutboundSecurityWithWSS4J(sourceDocument,action,properties);
    javax.xml.transform.Transformer transformer=TRANSFORMER_FACTORY.newTransformer();
    transformer.transform(new DOMSource(securedDocument),new StreamResult(baos));
  }
{
    WSSSecurityProperties securityProperties=new WSSSecurityProperties();
    securityProperties.loadSignatureVerificationKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
    InboundWSSec wsSecIn=WSSec.getInboundWSSec(securityProperties);
    XMLStreamReader xmlStreamReader=wsSecIn.processInMessage(xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray())));
    try {
      StAX2DOM.readDoc(documentBuilderFactory.newDocumentBuilder(),xmlStreamReader);
      Assert.fail("XMLStreamException expected");
    }
 catch (    XMLStreamException e) {
      Assert.assertNotNull(e.getCause());
    }
  }
}

</code></pre>

<br>
<pre class="type-3 type-8 type-5 type-6 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testSAML1AudienceRestrictionValidation() throws Exception {
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  List<String> audiences=new ArrayList<String>();
{
    SAML1CallbackHandler callbackHandler=new SAML1CallbackHandler();
    callbackHandler.setStatement(SAML1CallbackHandler.Statement.AUTHN);
    callbackHandler.setIssuer("www.example.com");
    ConditionsBean conditions=new ConditionsBean();
    conditions.setTokenPeriodMinutes(5);
    audiences.add("http://apache.org/one");
    audiences.add("http://apache.org/two");
    AudienceRestrictionBean audienceRestrictionBean=new AudienceRestrictionBean();
    audienceRestrictionBean.setAudienceURIs(audiences);
    conditions.setAudienceRestrictions(Collections.singletonList(audienceRestrictionBean));
    callbackHandler.setConditions(conditions);
    InputStream sourceDocument=this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml");
    String action=WSHandlerConstants.SAML_TOKEN_SIGNED;
    Properties properties=new Properties();
    properties.put(WSHandlerConstants.SAML_CALLBACK_REF,callbackHandler);
    Document securedDocument=doOutboundSecurityWithWSS4J(sourceDocument,action,properties);
    javax.xml.transform.Transformer transformer=TRANSFORMER_FACTORY.newTransformer();
    transformer.transform(new DOMSource(securedDocument),new StreamResult(baos));
  }
  audiences.clear();
  audiences.add("http://apache.org/three");
{
    WSSSecurityProperties securityProperties=new WSSSecurityProperties();
    securityProperties.loadSignatureVerificationKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
    securityProperties.setAudienceRestrictions(audiences);
    InboundWSSec wsSecIn=WSSec.getInboundWSSec(securityProperties);
    XMLStreamReader xmlStreamReader=wsSecIn.processInMessage(xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray())));
    try {
      StAX2DOM.readDoc(documentBuilderFactory.newDocumentBuilder(),xmlStreamReader);
      Assert.fail("XMLStreamException expected");
    }
 catch (    XMLStreamException e) {
      Assert.assertNotNull(e.getCause());
    }
  }
  audiences.add("http://apache.org/one");
{
    WSSSecurityProperties securityProperties=new WSSSecurityProperties();
    securityProperties.loadSignatureVerificationKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
    securityProperties.setAudienceRestrictions(audiences);
    InboundWSSec wsSecIn=WSSec.getInboundWSSec(securityProperties);
    XMLStreamReader xmlStreamReader=wsSecIn.processInMessage(xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray())));
    Document document=StAX2DOM.readDoc(documentBuilderFactory.newDocumentBuilder(),xmlStreamReader);
    Assert.assertNotNull(document);
  }
}

</code></pre>

<br>
<pre class="type-8 type-6 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testSAML2StaleNotOnOrAfter() throws Exception {
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
{
    SAML2CallbackHandler callbackHandler=new SAML2CallbackHandler();
    callbackHandler.setStatement(SAML2CallbackHandler.Statement.AUTHN);
    callbackHandler.setIssuer("www.example.com");
    ConditionsBean conditions=new ConditionsBean();
    DateTime notBefore=new DateTime();
    conditions.setNotAfter(notBefore.minusMinutes(60));
    conditions.setNotBefore(notBefore.minusMinutes(70));
    callbackHandler.setConditions(conditions);
    InputStream sourceDocument=this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml");
    String action=WSHandlerConstants.SAML_TOKEN_SIGNED;
    Properties properties=new Properties();
    properties.put(WSHandlerConstants.SAML_CALLBACK_REF,callbackHandler);
    Document securedDocument=doOutboundSecurityWithWSS4J(sourceDocument,action,properties);
    javax.xml.transform.Transformer transformer=TRANSFORMER_FACTORY.newTransformer();
    transformer.transform(new DOMSource(securedDocument),new StreamResult(baos));
  }
{
    WSSSecurityProperties securityProperties=new WSSSecurityProperties();
    securityProperties.loadSignatureVerificationKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
    InboundWSSec wsSecIn=WSSec.getInboundWSSec(securityProperties);
    XMLStreamReader xmlStreamReader=wsSecIn.processInMessage(xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray())));
    try {
      StAX2DOM.readDoc(documentBuilderFactory.newDocumentBuilder(),xmlStreamReader);
      Assert.fail("XMLStreamException expected");
    }
 catch (    XMLStreamException e) {
      Assert.assertNotNull(e.getCause());
    }
  }
}

</code></pre>

<br>
<pre class="type-3 type-8 type-5 type-6 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testSAML2AudienceRestrictionValidation() throws Exception {
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  List<String> audiences=new ArrayList<String>();
{
    SAML2CallbackHandler callbackHandler=new SAML2CallbackHandler();
    callbackHandler.setStatement(SAML2CallbackHandler.Statement.AUTHN);
    callbackHandler.setIssuer("www.example.com");
    ConditionsBean conditions=new ConditionsBean();
    conditions.setTokenPeriodMinutes(5);
    audiences.add("http://apache.org/one");
    audiences.add("http://apache.org/two");
    AudienceRestrictionBean audienceRestrictionBean=new AudienceRestrictionBean();
    audienceRestrictionBean.setAudienceURIs(audiences);
    conditions.setAudienceRestrictions(Collections.singletonList(audienceRestrictionBean));
    callbackHandler.setConditions(conditions);
    InputStream sourceDocument=this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml");
    String action=WSHandlerConstants.SAML_TOKEN_SIGNED;
    Properties properties=new Properties();
    properties.put(WSHandlerConstants.SAML_CALLBACK_REF,callbackHandler);
    Document securedDocument=doOutboundSecurityWithWSS4J(sourceDocument,action,properties);
    javax.xml.transform.Transformer transformer=TRANSFORMER_FACTORY.newTransformer();
    transformer.transform(new DOMSource(securedDocument),new StreamResult(baos));
  }
  audiences.clear();
  audiences.add("http://apache.org/three");
{
    WSSSecurityProperties securityProperties=new WSSSecurityProperties();
    securityProperties.loadSignatureVerificationKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
    securityProperties.setAudienceRestrictions(audiences);
    InboundWSSec wsSecIn=WSSec.getInboundWSSec(securityProperties);
    XMLStreamReader xmlStreamReader=wsSecIn.processInMessage(xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray())));
    try {
      StAX2DOM.readDoc(documentBuilderFactory.newDocumentBuilder(),xmlStreamReader);
      Assert.fail("XMLStreamException expected");
    }
 catch (    XMLStreamException e) {
      Assert.assertNotNull(e.getCause());
    }
  }
  audiences.add("http://apache.org/one");
{
    WSSSecurityProperties securityProperties=new WSSSecurityProperties();
    securityProperties.loadSignatureVerificationKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
    securityProperties.setAudienceRestrictions(audiences);
    InboundWSSec wsSecIn=WSSec.getInboundWSSec(securityProperties);
    XMLStreamReader xmlStreamReader=wsSecIn.processInMessage(xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray())));
    Document document=StAX2DOM.readDoc(documentBuilderFactory.newDocumentBuilder(),xmlStreamReader);
    Assert.assertNotNull(document);
  }
}

</code></pre>

<br>
<pre class="type-8 type-6 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test that creates, sends and processes an unsigned SAML 2 authentication assertion
 * with an (invalid) custom Conditions statement.
 */
@Test public void testSAML2InvalidAfterConditionsInbound() throws Exception {
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
{
    SAML2CallbackHandler callbackHandler=new SAML2CallbackHandler();
    callbackHandler.setStatement(SAML2CallbackHandler.Statement.AUTHN);
    callbackHandler.setIssuer("www.example.com");
    ConditionsBean conditions=new ConditionsBean();
    DateTime notBefore=new DateTime();
    conditions.setNotBefore(notBefore.minusMinutes(5));
    conditions.setNotAfter(notBefore.minusMinutes(3));
    callbackHandler.setConditions(conditions);
    InputStream sourceDocument=this.getClass().getClassLoader().getResourceAsStream("testdata/plain-soap-1.1.xml");
    String action=WSHandlerConstants.SAML_TOKEN_SIGNED;
    Properties properties=new Properties();
    properties.put(WSHandlerConstants.SAML_CALLBACK_REF,callbackHandler);
    Document securedDocument=doOutboundSecurityWithWSS4J(sourceDocument,action,properties);
    javax.xml.transform.Transformer transformer=TRANSFORMER_FACTORY.newTransformer();
    transformer.transform(new DOMSource(securedDocument),new StreamResult(baos));
  }
{
    WSSSecurityProperties securityProperties=new WSSSecurityProperties();
    securityProperties.loadSignatureVerificationKeystore(this.getClass().getClassLoader().getResource("receiver.jks"),"default".toCharArray());
    InboundWSSec wsSecIn=WSSec.getInboundWSSec(securityProperties);
    XMLStreamReader xmlStreamReader=wsSecIn.processInMessage(xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray())));
    try {
      StAX2DOM.readDoc(documentBuilderFactory.newDocumentBuilder(),xmlStreamReader);
      Assert.fail("XMLStreamException expected");
    }
 catch (    XMLStreamException e) {
      Assert.assertNotNull(e.getCause());
    }
  }
}

</code></pre>

<br>
<script>$(document).ready(function() {
  $('pre code').each(function(i, block) {
    hljs.highlightBlock(block);
  });
});</script>
