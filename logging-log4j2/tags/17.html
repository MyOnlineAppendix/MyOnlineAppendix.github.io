<h3><span class=" glyphicon glyphicon-tag"/>&nbspIterativeVerifier</h3><kbd>Verifies assertions in iterations</kbd><br><br><br><h4 style="margin:0px">Class: org.apache.logging.log4j.ThreadContextInheritanceTest </h4><pre class="type-17 type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies whether objects are null
"></span><br>
@Test public void perfTest() throws Exception {
  ThreadContext.clearMap();
  final Timer complete=new Timer("ThreadContextTest");
  complete.start();
  ThreadContext.put("Var1","value 1");
  ThreadContext.put("Var2","value 2");
  ThreadContext.put("Var3","value 3");
  ThreadContext.put("Var4","value 4");
  ThreadContext.put("Var5","value 5");
  ThreadContext.put("Var6","value 6");
  ThreadContext.put("Var7","value 7");
  ThreadContext.put("Var8","value 8");
  ThreadContext.put("Var9","value 9");
  ThreadContext.put("Var10","value 10");
  final int loopCount=1000000;
  final Timer timer=new Timer("ThreadContextCopy",loopCount);
  timer.start();
  for (int i=0; i < loopCount; ++i) {
    final Map<String,String> map=ThreadContext.getImmutableContext();
    assertNotNull(map);
  }
  timer.stop();
  complete.stop();
  System.out.println(timer.toString());
  System.out.println(complete.toString());
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.logging.log4j.ThreadContextTest </h4><pre class="type-17 type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies whether objects are null
"></span><br>
@Test public void perfTest() throws Exception {
  ThreadContext.clearMap();
  final Timer complete=new Timer("ThreadContextTest");
  complete.start();
  ThreadContext.put("Var1","value 1");
  ThreadContext.put("Var2","value 2");
  ThreadContext.put("Var3","value 3");
  ThreadContext.put("Var4","value 4");
  ThreadContext.put("Var5","value 5");
  ThreadContext.put("Var6","value 6");
  ThreadContext.put("Var7","value 7");
  ThreadContext.put("Var8","value 8");
  ThreadContext.put("Var9","value 9");
  ThreadContext.put("Var10","value 10");
  final int loopCount=1000000;
  final Timer timer=new Timer("ThreadContextCopy",loopCount);
  timer.start();
  for (int i=0; i < loopCount; ++i) {
    final Map<String,String> map=ThreadContext.getImmutableContext();
    assertNotNull(map);
  }
  timer.stop();
  complete.stop();
  System.out.println(timer.toString());
  System.out.println(complete.toString());
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.logging.log4j.core.appender.FileAppenderTest </h4><pre class="type-17 type-6 type-5 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
"></span><br>
@Test public void testSmallestBufferSize() throws Exception {
  final Layout<String> layout=PatternLayout.newBuilder().withPattern(PatternLayout.SIMPLE_CONVERSION_PATTERN).build();
  final String bufferSizeStr="1";
  final FileAppender appender=FileAppender.createAppender(FILENAME,"true","false","test","false","false","false",bufferSizeStr,layout,null,"false",null,null);
  appender.start();
  final File file=new File(FILENAME);
  assertTrue("Appender did not start",appender.isStarted());
  long curLen=file.length();
  long prevLen=curLen;
  assertTrue("File length: " + curLen,curLen == 0);
  for (int i=0; i < 100; ++i) {
    final LogEvent event=Log4jLogEvent.newBuilder().setLoggerName("TestLogger").setLoggerFqcn(FileAppenderTest.class.getName()).setLevel(Level.INFO).setMessage(new SimpleMessage("Test")).setThreadName(this.getClass().getSimpleName()).setTimeMillis(System.currentTimeMillis()).build();
    try {
      appender.append(event);
      curLen=file.length();
      assertTrue("File length: " + curLen,curLen > prevLen);
      Thread.sleep(25);
    }
 catch (    final Exception ex) {
      throw ex;
    }
    prevLen=curLen;
  }
  appender.stop();
  assertFalse("Appender did not stop",appender.isStarted());
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.logging.log4j.core.appender.MemoryMappedFileManagerTest </h4><pre class="type-17 type-6 type-5 type-3 type-8 type-9 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testRemapAfterInitialMapSizeExceeded() throws IOException {
  final int mapSize=64;
  final File file=File.createTempFile("log4j2","test");
  file.deleteOnExit();
  assertEquals(0,file.length());
  final boolean append=false;
  final boolean force=false;
  final MemoryMappedFileManager manager=MemoryMappedFileManager.getFileManager(file.getAbsolutePath(),append,force,mapSize,null,null);
  byte[] msg;
  for (int i=0; i < 1000; i++) {
    msg=("Message " + i + "\n").getBytes();
    manager.write(msg,0,msg.length);
  }
  manager.release();
  try (BufferedReader reader=new BufferedReader(new FileReader(file))){
    String line=reader.readLine();
    for (int i=0; i < 1000; i++) {
      assertNotNull("line",line);
      assertTrue("line incorrect",line.contains("Message " + i));
      line=reader.readLine();
    }
  }
 }

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.logging.log4j.core.appender.rolling.RollingAppenderCustomDeleteActionTest </h4><pre class="type-17 type-10 type-19 type-5 type-9 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testAppender() throws Exception {
  final Logger logger=ctx.getLogger();
  for (int i=0; i < 10; ++i) {
    logger.debug("This is a test message number " + i);
  }
  Thread.sleep(100);
  final File dir=new File(DIR);
  assertTrue("Dir " + DIR + " should exist",dir.exists());
  assertTrue("Dir " + DIR + " should contain files",dir.listFiles().length > 0);
  final int MAX_TRIES=20;
  for (int i=0; i < MAX_TRIES; i++) {
    final File[] files=dir.listFiles();
    for (    File file : files) {
      System.out.println(file);
    }
    if (files.length == 3) {
      for (      File file : files) {
        assertTrue("test-4.log should have been deleted",Arrays.asList("test-1.log","test-2.log","test-3.log").contains(file.getName()));
      }
      return;
    }
    logger.debug("Adding additional event " + i);
    Thread.sleep(100);
  }
  fail("No rollover files found");
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.logging.log4j.core.appender.rolling.action.IfAccumulatedFileCountTest </h4><pre class="type-17 type-6 type-10 type-5 type-4 type-3 type-9 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions inside branch conditions
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testAcceptCallsNestedConditionsOnlyIfPathAccepted(){
  final CountingCondition counter=new CountingCondition(true);
  IfAccumulatedFileCount condition=IfAccumulatedFileCount.createFileCountCondition(3,counter);
  for (int i=1; i < 10; i++) {
    if (i <= 3) {
      assertFalse("i=" + i,condition.accept(null,null,null));
      assertEquals(0,counter.getAcceptCount());
    }
 else {
      assertTrue(condition.accept(null,null,null));
      assertEquals(i - 3,counter.getAcceptCount());
    }
  }
}

</code></pre>

<br>
<pre class="type-17 type-6 type-5 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
"></span><br>
@Test public void testAccept(){
  int[] counts={3,5,9};
  for (  int count : counts) {
    IfAccumulatedFileCount condition=IfAccumulatedFileCount.createFileCountCondition(count);
    for (int i=0; i < count; i++) {
      assertFalse(condition.accept(null,null,null));
    }
    assertTrue(condition.accept(null,null,null));
    assertTrue(condition.accept(null,null,null));
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.logging.log4j.core.filter.BurstFilterTest </h4><pre class="type-17 type-5 type-4 type-3 type-9 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test BurstFilter by surpassing maximum number of log messages allowed by filter and
 * making sure only the maximum number are indeed logged, then wait for while and make
 * sure the filter allows the appropriate number of messages to be logged.
 */
@Test public void test() throws Exception {
  final long start=System.nanoTime();
  for (int i=0; i < 110; i++) {
    if (i % 10 == 0) {
      Thread.sleep(200);
    }
    logger.info("Logging 110 messages, should only see 100 logs # " + (i + 1));
    assertTrue("Incorrect number of available slots",filter.getAvailable() < 100);
  }
  List<String> msgs=app.getMessages();
  assertEquals("Incorrect message count. Should be 100, actual " + msgs.size(),100,msgs.size());
  app.clear();
  assertTrue("Incorrect number of available slots",filter.getAvailable() < 100);
  Thread.sleep(1500);
  for (int i=0; i < 110; i++) {
    logger.info("Waited 1.5 seconds and trying to log again, should see more than 0 and less than 100" + (i + 1));
  }
  msgs=app.getMessages();
  assertFalse("No messages were counted.",msgs.isEmpty());
  assertTrue("Incorrect message count. Should be > 0 and < 100, actual " + msgs.size(),msgs.size() < 100);
  app.clear();
  filter.clear();
  for (int i=0; i < 110; i++) {
    logger.info("Waited 1.5 seconds and trying to log again, should see more than 0 and less than 100" + (i + 1));
  }
  assertEquals("",0,filter.getAvailable());
  app.clear();
  for (int i=0; i < 110; i++) {
    logger.debug("TEST FAILED! Logging 110 debug messages, shouldn't see any of them because they are debugs #" + (i + 1));
  }
  msgs=app.getMessages();
  assertTrue("Incorrect message count. Should be 0, actual " + msgs.size(),msgs.isEmpty());
  app.clear();
  for (int i=0; i < 110; i++) {
    logger.warn("Logging 110 warn messages, should see all of them because they are warns #" + (i + 1));
  }
  msgs=app.getMessages();
  assertEquals("Incorrect message count. Should be 110, actual " + msgs.size(),110,msgs.size());
  app.clear();
  for (int i=0; i < 110; i++) {
    logger.error("Logging 110 error messages, should see all of them because they are errors #" + (i + 1));
  }
  msgs=app.getMessages();
  assertEquals("Incorrect message count. Should be 110, actual " + msgs.size(),110,msgs.size());
  app.clear();
  for (int i=0; i < 110; i++) {
    logger.fatal("Logging 110 fatal messages, should see all of them because they are fatals #" + (i + 1));
  }
  msgs=app.getMessages();
  assertEquals("Incorrect message count. Should be 110, actual " + msgs.size(),110,msgs.size());
  app.clear();
  Thread.sleep(3100);
  for (int i=0; i < 110; i++) {
    logger.debug("Waited 3+ seconds, should see 100 logs #" + (i + 1));
  }
  msgs=app.getMessages();
  assertEquals("Incorrect message count. Should be 100, actual " + msgs.size(),100,msgs.size());
  app.clear();
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.logging.log4j.core.tools.GenerateCustomLoggerTest </h4><pre class="type-17 type-6 type-5 type-4 type-3 type-9 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testGenerateSource() throws Exception {
  final String CLASSNAME="org.myorg.MyCustomLogger";
  final List<String> values=Arrays.asList("DEFCON1=350 DEFCON2=450 DEFCON3=550".split(" "));
  final List<Generate.LevelInfo> levels=Generate.LevelInfo.parse(values,Generate.CustomLogger.class);
  final String src=Generate.generateSource(CLASSNAME,levels,Generate.Type.CUSTOM);
  final File f=new File("target/test-classes/org/myorg/MyCustomLogger.java");
  f.getParentFile().mkdirs();
  try (final FileOutputStream out=new FileOutputStream(f)){
    out.write(src.getBytes(Charset.defaultCharset()));
  }
   final JavaCompiler compiler=ToolProvider.getSystemJavaCompiler();
  final DiagnosticCollector<JavaFileObject> diagnostics=new DiagnosticCollector<>();
  final List<String> errors=new ArrayList<>();
  try (final StandardJavaFileManager fileManager=compiler.getStandardFileManager(diagnostics,null,null)){
    final Iterable<? extends JavaFileObject> compilationUnits=fileManager.getJavaFileObjectsFromFiles(Arrays.asList(f));
    compiler.getTask(null,fileManager,diagnostics,null,null,compilationUnits).call();
    for (    final Diagnostic<? extends JavaFileObject> diagnostic : diagnostics.getDiagnostics()) {
      if (diagnostic.getKind() == Diagnostic.Kind.ERROR) {
        errors.add(String.format("Compile error: %s%n",diagnostic.getMessage(Locale.getDefault())));
      }
    }
  }
   assertTrue(errors.toString(),errors.isEmpty());
  final Class<?> cls=Class.forName(CLASSNAME);
  assertTrue(Modifier.isStatic(cls.getDeclaredMethod("create",new Class[0]).getModifiers()));
  assertTrue(Modifier.isStatic(cls.getDeclaredMethod("create",new Class[]{Class.class}).getModifiers()));
  assertTrue(Modifier.isStatic(cls.getDeclaredMethod("create",new Class[]{Object.class}).getModifiers()));
  assertTrue(Modifier.isStatic(cls.getDeclaredMethod("create",new Class[]{String.class}).getModifiers()));
  assertTrue(Modifier.isStatic(cls.getDeclaredMethod("create",Class.class,MessageFactory.class).getModifiers()));
  assertTrue(Modifier.isStatic(cls.getDeclaredMethod("create",Object.class,MessageFactory.class).getModifiers()));
  assertTrue(Modifier.isStatic(cls.getDeclaredMethod("create",String.class,MessageFactory.class).getModifiers()));
  final String[] logMethods={"defcon1","defcon2","defcon3"};
  for (  final String name : logMethods) {
    cls.getDeclaredMethod(name,Marker.class,Message.class,Throwable.class);
    cls.getDeclaredMethod(name,Marker.class,Object.class,Throwable.class);
    cls.getDeclaredMethod(name,Marker.class,String.class,Throwable.class);
    cls.getDeclaredMethod(name,Marker.class,Message.class);
    cls.getDeclaredMethod(name,Marker.class,Object.class);
    cls.getDeclaredMethod(name,Marker.class,String.class);
    cls.getDeclaredMethod(name,Message.class);
    cls.getDeclaredMethod(name,Object.class);
    cls.getDeclaredMethod(name,String.class);
    cls.getDeclaredMethod(name,Message.class,Throwable.class);
    cls.getDeclaredMethod(name,Object.class,Throwable.class);
    cls.getDeclaredMethod(name,String.class,Throwable.class);
    cls.getDeclaredMethod(name,String.class,Object[].class);
    cls.getDeclaredMethod(name,Marker.class,String.class,Object[].class);
    cls.getDeclaredMethod(name,Marker.class,MessageSupplier.class);
    cls.getDeclaredMethod(name,Marker.class,MessageSupplier.class,Throwable.class);
    cls.getDeclaredMethod(name,Marker.class,String.class,Supplier[].class);
    cls.getDeclaredMethod(name,Marker.class,Supplier.class);
    cls.getDeclaredMethod(name,Marker.class,Supplier.class,Throwable.class);
    cls.getDeclaredMethod(name,MessageSupplier.class);
    cls.getDeclaredMethod(name,MessageSupplier.class,Throwable.class);
    cls.getDeclaredMethod(name,String.class,Supplier[].class);
    cls.getDeclaredMethod(name,Supplier.class);
    cls.getDeclaredMethod(name,Supplier.class,Throwable.class);
  }
  final Method create=cls.getDeclaredMethod("create",new Class[]{String.class});
  final Object customLogger=create.invoke(null,"X.Y.Z");
  int n=0;
  for (  final String name : logMethods) {
    final Method method=cls.getDeclaredMethod(name,String.class);
    method.invoke(customLogger,"This is message " + n++);
  }
  final TestLogger underlying=(TestLogger)LogManager.getLogger("X.Y.Z");
  final List<String> lines=underlying.getEntries();
  for (int i=0; i < lines.size(); i++) {
    assertEquals(" " + levels.get(i).name + " This is message "+ i,lines.get(i));
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.logging.log4j.core.tools.GenerateExtendedLoggerTest </h4><pre class="type-17 type-6 type-5 type-4 type-3 type-9 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testGenerateSource() throws Exception {
  final String CLASSNAME="org.myorg.MyExtendedLogger";
  final List<String> values=Arrays.asList("DIAG=350 NOTICE=450 VERBOSE=550".split(" "));
  final List<Generate.LevelInfo> levels=Generate.LevelInfo.parse(values,Generate.ExtendedLogger.class);
  final String src=Generate.generateSource(CLASSNAME,levels,Generate.Type.EXTEND);
  final File f=new File("target/test-classes/org/myorg/MyExtendedLogger.java");
  f.getParentFile().mkdirs();
  try (final FileOutputStream out=new FileOutputStream(f)){
    out.write(src.getBytes(Charset.defaultCharset()));
  }
   final JavaCompiler compiler=ToolProvider.getSystemJavaCompiler();
  final DiagnosticCollector<JavaFileObject> diagnostics=new DiagnosticCollector<>();
  final List<String> errors=new ArrayList<>();
  try (final StandardJavaFileManager fileManager=compiler.getStandardFileManager(diagnostics,null,null)){
    final Iterable<? extends JavaFileObject> compilationUnits=fileManager.getJavaFileObjectsFromFiles(Arrays.asList(f));
    compiler.getTask(null,fileManager,diagnostics,null,null,compilationUnits).call();
    for (    final Diagnostic<? extends JavaFileObject> diagnostic : diagnostics.getDiagnostics()) {
      if (diagnostic.getKind() == Diagnostic.Kind.ERROR) {
        errors.add(String.format("Compile error: %s%n",diagnostic.getMessage(Locale.getDefault())));
      }
    }
  }
   assertTrue(errors.toString(),errors.isEmpty());
  final Class<?> cls=Class.forName(CLASSNAME);
  assertTrue(Modifier.isStatic(cls.getDeclaredMethod("create",new Class[0]).getModifiers()));
  assertTrue(Modifier.isStatic(cls.getDeclaredMethod("create",new Class[]{Class.class}).getModifiers()));
  assertTrue(Modifier.isStatic(cls.getDeclaredMethod("create",new Class[]{Object.class}).getModifiers()));
  assertTrue(Modifier.isStatic(cls.getDeclaredMethod("create",new Class[]{String.class}).getModifiers()));
  assertTrue(Modifier.isStatic(cls.getDeclaredMethod("create",Class.class,MessageFactory.class).getModifiers()));
  assertTrue(Modifier.isStatic(cls.getDeclaredMethod("create",Object.class,MessageFactory.class).getModifiers()));
  assertTrue(Modifier.isStatic(cls.getDeclaredMethod("create",String.class,MessageFactory.class).getModifiers()));
  final String[] extendedMethods={"diag","notice","verbose"};
  for (  final String name : extendedMethods) {
    cls.getDeclaredMethod(name,Marker.class,Message.class,Throwable.class);
    cls.getDeclaredMethod(name,Marker.class,Object.class,Throwable.class);
    cls.getDeclaredMethod(name,Marker.class,String.class,Throwable.class);
    cls.getDeclaredMethod(name,Marker.class,Message.class);
    cls.getDeclaredMethod(name,Marker.class,Object.class);
    cls.getDeclaredMethod(name,Marker.class,String.class);
    cls.getDeclaredMethod(name,Message.class);
    cls.getDeclaredMethod(name,Object.class);
    cls.getDeclaredMethod(name,String.class);
    cls.getDeclaredMethod(name,Message.class,Throwable.class);
    cls.getDeclaredMethod(name,Object.class,Throwable.class);
    cls.getDeclaredMethod(name,String.class,Throwable.class);
    cls.getDeclaredMethod(name,String.class,Object[].class);
    cls.getDeclaredMethod(name,Marker.class,String.class,Object[].class);
    cls.getDeclaredMethod(name,Marker.class,MessageSupplier.class);
    cls.getDeclaredMethod(name,Marker.class,MessageSupplier.class,Throwable.class);
    cls.getDeclaredMethod(name,Marker.class,String.class,Supplier[].class);
    cls.getDeclaredMethod(name,Marker.class,Supplier.class);
    cls.getDeclaredMethod(name,Marker.class,Supplier.class,Throwable.class);
    cls.getDeclaredMethod(name,MessageSupplier.class);
    cls.getDeclaredMethod(name,MessageSupplier.class,Throwable.class);
    cls.getDeclaredMethod(name,String.class,Supplier[].class);
    cls.getDeclaredMethod(name,Supplier.class);
    cls.getDeclaredMethod(name,Supplier.class,Throwable.class);
  }
  final Method create=cls.getDeclaredMethod("create",new Class[]{String.class});
  final Object extendedLogger=create.invoke(null,"X.Y.Z");
  int n=0;
  for (  final String name : extendedMethods) {
    final Method method=cls.getDeclaredMethod(name,String.class);
    method.invoke(extendedLogger,"This is message " + n++);
  }
  final ExtendedLogger logger=(ExtendedLogger)extendedLogger;
  logger.trace("trace message");
  logger.debug("debug message");
  logger.info("info message");
  logger.warn("warn message");
  logger.error("error message");
  logger.fatal("fatal message");
  final TestLogger underlying=(TestLogger)LogManager.getLogger("X.Y.Z");
  final List<String> lines=underlying.getEntries();
  for (int i=0; i < lines.size() - 6; i++) {
    assertEquals(" " + levels.get(i).name + " This is message "+ i,lines.get(i));
  }
  int i=lines.size() - 6;
  assertEquals(" TRACE trace message",lines.get(i++));
  assertEquals(" DEBUG debug message",lines.get(i++));
  assertEquals(" INFO info message",lines.get(i++));
  assertEquals(" WARN warn message",lines.get(i++));
  assertEquals(" ERROR error message",lines.get(i++));
  assertEquals(" FATAL fatal message",lines.get(i++));
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.logging.log4j.core.util.datetime.FixedDateFormatTest </h4><pre class="type-17 type-6 type-4 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
"></span><br>
@Test public void testFormatLong_goingBackInTime(){
  final long now=System.currentTimeMillis();
  final long start=now - TimeUnit.HOURS.toMillis(25);
  final long end=now + TimeUnit.HOURS.toMillis(25);
  for (  final FixedFormat format : FixedFormat.values()) {
    final SimpleDateFormat simpleDF=new SimpleDateFormat(format.getPattern(),Locale.getDefault());
    final FixedDateFormat customTF=new FixedDateFormat(format);
    for (long time=end; time > start; time-=12345) {
      final String actual=customTF.format(time);
      final String expected=simpleDF.format(new Date(time));
      assertEquals(format + "/" + time,expected,actual);
    }
  }
}

</code></pre>

<br>
<pre class="type-17 type-6 type-4 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
"></span><br>
@Test public void testFormatLongCharArrayInt(){
  final long now=System.currentTimeMillis();
  final long start=now - TimeUnit.HOURS.toMillis(25);
  final long end=now + TimeUnit.HOURS.toMillis(25);
  final char[] buffer=new char[128];
  for (  final FixedFormat format : FixedFormat.values()) {
    final SimpleDateFormat simpleDF=new SimpleDateFormat(format.getPattern(),Locale.getDefault());
    final FixedDateFormat customTF=new FixedDateFormat(format);
    for (long time=start; time < end; time+=12345) {
      final int length=customTF.format(time,buffer,23);
      final String actual=new String(buffer,23,length);
      final String expected=simpleDF.format(new Date(time));
      assertEquals(format + "/" + time,expected,actual);
    }
  }
}

</code></pre>

<br>
<pre class="type-17 type-6 type-4 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
"></span><br>
@Test public void testFormatLong(){
  final long now=System.currentTimeMillis();
  final long start=now - TimeUnit.HOURS.toMillis(25);
  final long end=now + TimeUnit.HOURS.toMillis(25);
  for (  final FixedFormat format : FixedFormat.values()) {
    final SimpleDateFormat simpleDF=new SimpleDateFormat(format.getPattern(),Locale.getDefault());
    final FixedDateFormat customTF=new FixedDateFormat(format);
    for (long time=start; time < end; time+=12345) {
      final String actual=customTF.format(time);
      final String expected=simpleDF.format(new Date(time));
      assertEquals(format + "/" + time,expected,actual);
    }
  }
}

</code></pre>

<br>
<pre class="type-17 type-6 type-4 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
"></span><br>
@Test public void testFormatLongCharArrayInt_goingBackInTime(){
  final long now=System.currentTimeMillis();
  final long start=now - TimeUnit.HOURS.toMillis(25);
  final long end=now + TimeUnit.HOURS.toMillis(25);
  final char[] buffer=new char[128];
  for (  final FixedFormat format : FixedFormat.values()) {
    final SimpleDateFormat simpleDF=new SimpleDateFormat(format.getPattern(),Locale.getDefault());
    final FixedDateFormat customTF=new FixedDateFormat(format);
    for (long time=end; time > start; time-=12345) {
      final int length=customTF.format(time,buffer,23);
      final String actual=new String(buffer,23,length);
      final String expected=simpleDF.format(new Date(time));
      assertEquals(format + "/" + time,expected,actual);
    }
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.logging.log4j.flume.appender.FlumeAppenderTest </h4><pre class="type-17 type-5 type-4 type-8 type-9 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testIncompleteBatch() throws IOException {
  final Agent[] agents=new Agent[]{Agent.createAgent("localhost",testPort)};
  final FlumeAppender avroAppender=FlumeAppender.createAppender(agents,null,"false","Avro",null,"1000","1000","1","500","avro","false",null,null,null,null,null,"true","10",null,null,null,null);
  avroAppender.start();
  avroLogger.addAppender(avroAppender);
  avroLogger.setLevel(Level.ALL);
  Assert.assertNotNull(avroLogger);
  avroLogger.info("Test message 0");
  final Transaction transaction=channel.getTransaction();
  transaction.begin();
  Event event=channel.take();
  Assert.assertNull("Received event",event);
  try {
    Thread.sleep(500);
  }
 catch (  final InterruptedException ie) {
  }
  avroLogger.info("Test message 1");
  for (int i=0; i < 2; ++i) {
    event=channel.take();
    Assert.assertNotNull("No event for item " + i,event);
    Assert.assertTrue("Channel contained event, but not expected message",getBody(event).endsWith("Test message " + i));
  }
  transaction.commit();
  transaction.close();
  eventSource.stop();
}

</code></pre>

<br>
<pre class="type-17 type-5 type-4 type-8 type-9 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testMultiple() throws IOException {
  final Agent[] agents=new Agent[]{Agent.createAgent("localhost",testPort)};
  final FlumeAppender avroAppender=FlumeAppender.createAppender(agents,null,"false","Avro",null,"1000","1000","1","1000","avro","false",null,null,null,null,null,"true","1",null,null,null,null);
  avroAppender.start();
  avroLogger.addAppender(avroAppender);
  avroLogger.setLevel(Level.ALL);
  Assert.assertNotNull(avroLogger);
  for (int i=0; i < 10; ++i) {
    avroLogger.info("Test message " + i);
  }
  for (int i=0; i < 10; ++i) {
    final Transaction transaction=channel.getTransaction();
    transaction.begin();
    final Event event=channel.take();
    Assert.assertNotNull(event);
    Assert.assertTrue("Channel contained event, but not expected message",getBody(event).endsWith("Test message " + i));
    transaction.commit();
    transaction.close();
  }
  eventSource.stop();
}

</code></pre>

<br>
<pre class="type-17 type-5 type-4 type-8 type-9 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testIncompleteBatch2() throws IOException {
  final Agent[] agents=new Agent[]{Agent.createAgent("localhost",testPort)};
  final FlumeAppender avroAppender=FlumeAppender.createAppender(agents,null,"false","Avro",null,"1000","1000","1","500","avro","false",null,null,null,null,null,"true","10",null,null,null,null);
  avroAppender.start();
  avroLogger.addAppender(avroAppender);
  avroLogger.setLevel(Level.ALL);
  Assert.assertNotNull(avroLogger);
  avroLogger.info("Test message 0");
  final Transaction transaction=channel.getTransaction();
  transaction.begin();
  avroLogger.info("Test message 1");
  avroLogger.info("Test message 2");
  avroAppender.stop();
  for (int i=0; i < 3; ++i) {
    Event event=channel.take();
    Assert.assertNotNull("No event for item " + i,event);
    Assert.assertTrue("Channel contained event, but not expected message. Received : " + getBody(event),getBody(event).endsWith("Test message " + i));
  }
  transaction.commit();
  transaction.close();
  eventSource.stop();
}

</code></pre>

<br>
<pre class="type-17 type-5 type-4 type-8 type-9 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testBatch() throws IOException {
  final Agent[] agents=new Agent[]{Agent.createAgent("localhost",testPort)};
  final FlumeAppender avroAppender=FlumeAppender.createAppender(agents,null,"false","Avro",null,"1000","1000","1","1000","avro","false",null,null,null,null,null,"true","10",null,null,null,null);
  avroAppender.start();
  avroLogger.addAppender(avroAppender);
  avroLogger.setLevel(Level.ALL);
  Assert.assertNotNull(avroLogger);
  for (int i=0; i < 10; ++i) {
    avroLogger.info("Test message " + i);
  }
  final Transaction transaction=channel.getTransaction();
  transaction.begin();
  for (int i=0; i < 10; ++i) {
    final Event event=channel.take();
    Assert.assertNotNull("No event for item " + i,event);
    Assert.assertTrue("Channel contained event, but not expected message",getBody(event).endsWith("Test message " + i));
  }
  transaction.commit();
  transaction.close();
  eventSource.stop();
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.logging.log4j.flume.appender.FlumeEmbeddedAgentTest </h4><pre class="type-17 type-6 type-5 type-4 type-8 type-9 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testMultiple() throws IOException {
  for (int i=0; i < 10; ++i) {
    final StructuredDataMessage msg=new StructuredDataMessage("Test","Test Multiple " + i,"Test");
    EventLogger.logEvent(msg);
  }
  for (int i=0; i < 10; ++i) {
    final Event event=primary.poll();
    Assert.assertNotNull(event);
    final String body=getBody(event);
    final String expected="Test Multiple " + i;
    Assert.assertTrue("Channel contained event, but not expected message. Received: " + body,body.endsWith(expected));
  }
}

</code></pre>

<br>
<pre class="type-17 type-6 type-5 type-4 type-8 type-9 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testFailover() throws InterruptedException, IOException {
  final Logger logger=LogManager.getLogger("testFailover");
  logger.debug("Starting testFailover");
  for (int i=0; i < 10; ++i) {
    final StructuredDataMessage msg=new StructuredDataMessage("Test","Test Primary " + i,"Test");
    EventLogger.logEvent(msg);
  }
  for (int i=0; i < 10; ++i) {
    final Event event=primary.poll();
    Assert.assertNotNull(event);
    final String body=getBody(event);
    final String expected="Test Primary " + i;
    Assert.assertTrue("Channel contained event, but not expected message. Received: " + body,body.endsWith(expected));
  }
  Thread.sleep(500);
  primary.stop();
  for (int i=0; i < 10; ++i) {
    final StructuredDataMessage msg=new StructuredDataMessage("Test","Test Alternate " + i,"Test");
    EventLogger.logEvent(msg);
  }
  for (int i=0; i < 10; ++i) {
    final Event event=alternate.poll();
    Assert.assertNotNull(event);
    final String body=getBody(event);
    final String expected="Test Alternate " + i;
    Assert.assertTrue("Channel contained event, but not expected message. Expected: " + expected + " Received: "+ body,body.endsWith(expected));
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.logging.log4j.flume.appender.FlumeEmbeddedAppenderTest </h4><pre class="type-17 type-6 type-5 type-4 type-8 type-9 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testFailover() throws InterruptedException, IOException {
  final Logger logger=LogManager.getLogger("testFailover");
  logger.debug("Starting testFailover");
  for (int i=0; i < 10; ++i) {
    final StructuredDataMessage msg=new StructuredDataMessage("Test","Test Primary " + i,"Test");
    EventLogger.logEvent(msg);
  }
  for (int i=0; i < 10; ++i) {
    final Event event=primary.poll();
    Assert.assertNotNull(event);
    final String body=getBody(event);
    final String expected="Test Primary " + i;
    Assert.assertTrue("Channel contained event, but not expected message. Received: " + body,body.endsWith(expected));
  }
  Thread.sleep(500);
  primary.stop();
  for (int i=0; i < 10; ++i) {
    final StructuredDataMessage msg=new StructuredDataMessage("Test","Test Alternate " + i,"Test");
    EventLogger.logEvent(msg);
  }
  for (int i=0; i < 10; ++i) {
    final Event event=alternate.poll();
    Assert.assertNotNull(event);
    final String body=getBody(event);
    final String expected="Test Alternate " + i;
    Assert.assertTrue("Channel contained event, but not expected message. Expected: " + expected + " Received: "+ body,body.endsWith(expected));
  }
}

</code></pre>

<br>
<pre class="type-17 type-6 type-5 type-4 type-8 type-9 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testMultiple() throws IOException {
  for (int i=0; i < 10; ++i) {
    final StructuredDataMessage msg=new StructuredDataMessage("Test","Test Multiple " + i,"Test");
    EventLogger.logEvent(msg);
  }
  for (int i=0; i < 10; ++i) {
    final Event event=primary.poll();
    Assert.assertNotNull(event);
    final String body=getBody(event);
    final String expected="Test Multiple " + i;
    Assert.assertTrue("Channel contained event, but not expected message. Received: " + body,body.endsWith(expected));
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.logging.log4j.flume.appender.FlumePersistentAppenderTest </h4><pre class="type-17 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies boolean conditions
"></span><br>
@Test public void testMultipleConcurrent() throws InterruptedException {
  final int eventsCount=10000;
  final Thread writer1=new WriterThread(0,eventsCount / 4);
  final Thread writer2=new WriterThread(eventsCount / 4,eventsCount / 2);
  final Thread writer3=new WriterThread(eventsCount / 2,(3 * eventsCount) / 4);
  final Thread writer4=new WriterThread((3 * eventsCount) / 4,eventsCount);
  writer1.start();
  writer2.start();
  writer3.start();
  writer4.start();
  final boolean[] fields=new boolean[eventsCount];
  final Thread reader1=new ReaderThread(0,eventsCount / 4,fields);
  final Thread reader2=new ReaderThread(eventsCount / 4,eventsCount / 2,fields);
  final Thread reader3=new ReaderThread(eventsCount / 2,(eventsCount * 3) / 4,fields);
  final Thread reader4=new ReaderThread((eventsCount * 3) / 4,eventsCount,fields);
  reader1.start();
  reader2.start();
  reader3.start();
  reader4.start();
  writer1.join();
  writer2.join();
  writer3.join();
  writer4.join();
  reader1.join();
  reader2.join();
  reader3.join();
  reader4.join();
  for (int i=0; i < eventsCount; ++i) {
    Assert.assertTrue("Channel contained event, but not expected message " + i,fields[i]);
  }
}

</code></pre>

<br>
<pre class="type-17 type-10 type-19 type-5 type-4 type-8 type-9 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testFailover() throws InterruptedException {
  final Logger logger=LogManager.getLogger("testFailover");
  logger.debug("Starting testFailover");
  for (int i=0; i < 10; ++i) {
    final StructuredDataMessage msg=new StructuredDataMessage("Test","Test Primary " + i,"Test");
    msg.put("counter",Integer.toString(i));
    EventLogger.logEvent(msg);
  }
  boolean[] fields=new boolean[10];
  for (int i=0; i < 10; ++i) {
    final Event event=primary.poll();
    Assert.assertNotNull("Received " + i + " events. Event "+ (i + 1)+ " is null",event);
    final String value=event.getHeaders().get("counter");
    Assert.assertNotNull("Missing counter",value);
    final int counter=Integer.parseInt(value);
    if (fields[counter]) {
      Assert.fail("Duplicate event");
    }
 else {
      fields[counter]=true;
    }
  }
  for (int i=0; i < 10; ++i) {
    Assert.assertTrue("Channel contained event, but not expected message " + i,fields[i]);
  }
  Thread.sleep(500);
  primary.stop();
  for (int i=0; i < 10; ++i) {
    final StructuredDataMessage msg=new StructuredDataMessage("Test","Test Alternate " + i,"Test");
    msg.put("cntr",Integer.toString(i));
    EventLogger.logEvent(msg);
  }
  fields=new boolean[10];
  for (int i=0; i < 10; ++i) {
    final Event event=alternate.poll();
    Assert.assertNotNull("Received " + i + " events. Event "+ (i + 1)+ " is null",event);
    final String value=event.getHeaders().get("cntr");
    Assert.assertNotNull("Missing counter",value);
    final int counter=Integer.parseInt(value);
    if (fields[counter]) {
      Assert.fail("Duplicate event");
    }
 else {
      fields[counter]=true;
    }
  }
  for (int i=0; i < 10; ++i) {
    Assert.assertTrue("Channel contained event, but not expected message " + i,fields[i]);
  }
}

</code></pre>

<br>
<pre class="type-17 type-10 type-19 type-5 type-4 type-8 type-9 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testMultiple(){
  for (int i=0; i < 10; ++i) {
    final StructuredDataMessage msg=new StructuredDataMessage("Test","Test Multiple " + i,"Test");
    msg.put("counter",Integer.toString(i));
    EventLogger.logEvent(msg);
  }
  final boolean[] fields=new boolean[10];
  for (int i=0; i < 10; ++i) {
    final Event event=primary.poll();
    Assert.assertNotNull("Received " + i + " events. Event "+ (i + 1)+ " is null",event);
    final String value=event.getHeaders().get("counter");
    Assert.assertNotNull("Missing counter",value);
    final int counter=Integer.parseInt(value);
    if (fields[counter]) {
      Assert.fail("Duplicate event");
    }
 else {
      fields[counter]=true;
    }
  }
  for (int i=0; i < 10; ++i) {
    Assert.assertTrue("Channel contained event, but not expected message " + i,fields[i]);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.logging.log4j.nosql.appender.NoSqlDatabaseManagerTest </h4><pre class="type-17 type-6 type-5 type-4 type-3 type-8 type-9 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testWriteInternal02(){
  final NoSqlDatabaseManager<?> manager=NoSqlDatabaseManager.getNoSqlDatabaseManager("name",0,this.provider);
  try {
    replay(this.provider,this.connection);
    manager.startup();
    verify(this.provider,this.connection);
    reset(this.provider,this.connection);
    expect(this.provider.getConnection()).andReturn(this.connection);
    replay(this.provider,this.connection);
    manager.connectAndStart();
    verify(this.provider,this.connection);
    reset(this.provider,this.connection);
    final Capture<NoSqlObject<Map<String,Object>>> capture=new Capture<>();
    final RuntimeException exception=new RuntimeException("This is something cool!");
    final Map<String,String> context=new HashMap<>();
    context.put("hello","world");
    context.put("user","pass");
    final LogEvent event=createStrictMock(LogEvent.class);
    final Message message=createStrictMock(Message.class);
    ThreadContext.push("message1");
    ThreadContext.push("stack2");
    final ThreadContext.ContextStack stack=ThreadContext.getImmutableStack();
    ThreadContext.clearStack();
    expect(this.connection.isClosed()).andReturn(false);
    expect(this.connection.createObject()).andAnswer(new IAnswer<DefaultNoSqlObject>(){
      @Override public DefaultNoSqlObject answer() throws Throwable {
        return new DefaultNoSqlObject();
      }
    }
).atLeastOnce();
    expect(this.connection.createList(anyInt())).andAnswer(new IAnswer<DefaultNoSqlObject[]>(){
      @Override public DefaultNoSqlObject[] answer() throws Throwable {
        return new DefaultNoSqlObject[(Integer)getCurrentArguments()[0]];
      }
    }
);
    expect(this.connection.createObject()).andAnswer(new IAnswer<DefaultNoSqlObject>(){
      @Override public DefaultNoSqlObject answer() throws Throwable {
        return new DefaultNoSqlObject();
      }
    }
).atLeastOnce();
    expect(event.getLevel()).andReturn(Level.DEBUG);
    expect(event.getLoggerName()).andReturn("com.foo.NoSQLDbTest.testWriteInternal02");
    expect(event.getMessage()).andReturn(message).times(2);
    expect(message.getFormattedMessage()).andReturn("Another cool message 02.");
    expect(event.getSource()).andReturn(new StackTraceElement("com.bar.Foo","anotherMethod03","Foo.java",9));
    expect(event.getMarker()).andReturn(MarkerManager.getMarker("LoneMarker"));
    expect(event.getThreadName()).andReturn("AnotherThread-B");
    expect(event.getTimeMillis()).andReturn(987654321564L).times(2);
    expect(event.getThrown()).andReturn(exception);
    expect(event.getContextMap()).andReturn(context);
    expect(event.getContextStack()).andReturn(stack);
    this.connection.insertObject(capture(capture));
    expectLastCall();
    replay(this.provider,this.connection,event,message);
    manager.writeInternal(event);
    final NoSqlObject<Map<String,Object>> inserted=capture.getValue();
    assertNotNull("The inserted value should not be null.",inserted);
    final Map<String,Object> object=inserted.unwrap();
    assertNotNull("The unwrapped object should not be null.",object);
    assertEquals("The level is not correct.",Level.DEBUG,object.get("level"));
    assertEquals("The logger is not correct.","com.foo.NoSQLDbTest.testWriteInternal02",object.get("loggerName"));
    assertEquals("The message is not correct.","Another cool message 02.",object.get("message"));
    assertEquals("The thread is not correct.","AnotherThread-B",object.get("threadName"));
    assertEquals("The millis is not correct.",987654321564L,object.get("millis"));
    assertEquals("The date is not correct.",987654321564L,((Date)object.get("date")).getTime());
    assertTrue("The source should be a map.",object.get("source") instanceof Map);
    @SuppressWarnings("unchecked") final Map<String,Object> source=(Map<String,Object>)object.get("source");
    assertEquals("The class is not correct.","com.bar.Foo",source.get("className"));
    assertEquals("The method is not correct.","anotherMethod03",source.get("methodName"));
    assertEquals("The file name is not correct.","Foo.java",source.get("fileName"));
    assertEquals("The line number is not correct.",9,source.get("lineNumber"));
    assertTrue("The marker should be a map.",object.get("marker") instanceof Map);
    @SuppressWarnings("unchecked") final Map<String,Object> marker=(Map<String,Object>)object.get("marker");
    assertEquals("The marker name is not correct.","LoneMarker",marker.get("name"));
    assertNull("The marker parent should be null.",marker.get("parent"));
    assertTrue("The thrown should be a map.",object.get("thrown") instanceof Map);
    @SuppressWarnings("unchecked") final Map<String,Object> thrown=(Map<String,Object>)object.get("thrown");
    assertEquals("The thrown type is not correct.","java.lang.RuntimeException",thrown.get("type"));
    assertEquals("The thrown message is not correct.","This is something cool!",thrown.get("message"));
    assertTrue("The thrown stack trace should be a list.",thrown.get("stackTrace") instanceof List);
    @SuppressWarnings("unchecked") final List<Map<String,Object>> stackTrace=(List<Map<String,Object>>)thrown.get("stackTrace");
    assertEquals("The thrown stack trace length is not correct.",exception.getStackTrace().length,stackTrace.size());
    for (int i=0; i < exception.getStackTrace().length; i++) {
      final StackTraceElement e1=exception.getStackTrace()[i];
      final Map<String,Object> e2=stackTrace.get(i);
      assertEquals("Element class name [" + i + "] is not correct.",e1.getClassName(),e2.get("className"));
      assertEquals("Element method name [" + i + "] is not correct.",e1.getMethodName(),e2.get("methodName"));
      assertEquals("Element file name [" + i + "] is not correct.",e1.getFileName(),e2.get("fileName"));
      assertEquals("Element line number [" + i + "] is not correct.",e1.getLineNumber(),e2.get("lineNumber"));
    }
    assertNull("The thrown should have no cause.",thrown.get("cause"));
    assertTrue("The context map should be a map.",object.get("contextMap") instanceof Map);
    assertEquals("The context map is not correct.",context,object.get("contextMap"));
    assertTrue("The context stack should be list.",object.get("contextStack") instanceof List);
    assertEquals("The context stack is not correct.",stack.asList(),object.get("contextStack"));
    verify(this.provider,this.connection,event,message);
  }
  finally {
    try {
      manager.release();
    }
 catch (    final Throwable ignore) {
    }
  }
}

</code></pre>

<br>
<pre class="type-17 type-6 type-5 type-4 type-3 type-8 type-9 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testWriteInternal03(){
  final NoSqlDatabaseManager<?> manager=NoSqlDatabaseManager.getNoSqlDatabaseManager("name",0,this.provider);
  try {
    replay(this.provider,this.connection);
    manager.startup();
    verify(this.provider,this.connection);
    reset(this.provider,this.connection);
    expect(this.provider.getConnection()).andReturn(this.connection);
    replay(this.provider,this.connection);
    manager.connectAndStart();
    verify(this.provider,this.connection);
    reset(this.provider,this.connection);
    final Capture<NoSqlObject<Map<String,Object>>> capture=new Capture<>();
    final IOException exception1=new IOException("This is the cause.");
    final SQLException exception2=new SQLException("This is the result.",exception1);
    final Map<String,String> context=new HashMap<>();
    context.put("hello","world");
    context.put("user","pass");
    final LogEvent event=createStrictMock(LogEvent.class);
    final Message message=createStrictMock(Message.class);
    ThreadContext.push("message1");
    ThreadContext.push("stack2");
    final ThreadContext.ContextStack stack=ThreadContext.getImmutableStack();
    ThreadContext.clearStack();
    expect(this.connection.isClosed()).andReturn(false);
    expect(this.connection.createObject()).andAnswer(new IAnswer<DefaultNoSqlObject>(){
      @Override public DefaultNoSqlObject answer() throws Throwable {
        return new DefaultNoSqlObject();
      }
    }
).atLeastOnce();
    expect(this.connection.createList(anyInt())).andAnswer(new IAnswer<DefaultNoSqlObject[]>(){
      @Override public DefaultNoSqlObject[] answer() throws Throwable {
        return new DefaultNoSqlObject[(Integer)getCurrentArguments()[0]];
      }
    }
);
    expect(this.connection.createObject()).andAnswer(new IAnswer<DefaultNoSqlObject>(){
      @Override public DefaultNoSqlObject answer() throws Throwable {
        return new DefaultNoSqlObject();
      }
    }
).atLeastOnce();
    expect(this.connection.createList(anyInt())).andAnswer(new IAnswer<DefaultNoSqlObject[]>(){
      @Override public DefaultNoSqlObject[] answer() throws Throwable {
        return new DefaultNoSqlObject[(Integer)getCurrentArguments()[0]];
      }
    }
);
    expect(this.connection.createObject()).andAnswer(new IAnswer<DefaultNoSqlObject>(){
      @Override public DefaultNoSqlObject answer() throws Throwable {
        return new DefaultNoSqlObject();
      }
    }
).atLeastOnce();
    expect(event.getLevel()).andReturn(Level.DEBUG);
    expect(event.getLoggerName()).andReturn("com.foo.NoSQLDbTest.testWriteInternal02");
    expect(event.getMessage()).andReturn(message).times(2);
    expect(message.getFormattedMessage()).andReturn("Another cool message 02.");
    expect(event.getSource()).andReturn(new StackTraceElement("com.bar.Foo","anotherMethod03","Foo.java",9));
    expect(event.getMarker()).andReturn(MarkerManager.getMarker("AnotherMarker").addParents(MarkerManager.getMarker("Parent1").addParents(MarkerManager.getMarker("GrandParent1")),MarkerManager.getMarker("Parent2")));
    expect(event.getThreadName()).andReturn("AnotherThread-B");
    expect(event.getTimeMillis()).andReturn(987654321564L).times(2);
    expect(event.getThrown()).andReturn(exception2);
    expect(event.getContextMap()).andReturn(context);
    expect(event.getContextStack()).andReturn(stack);
    this.connection.insertObject(capture(capture));
    expectLastCall();
    replay(this.provider,this.connection,event,message);
    manager.writeInternal(event);
    final NoSqlObject<Map<String,Object>> inserted=capture.getValue();
    assertNotNull("The inserted value should not be null.",inserted);
    final Map<String,Object> object=inserted.unwrap();
    assertNotNull("The unwrapped object should not be null.",object);
    assertEquals("The level is not correct.",Level.DEBUG,object.get("level"));
    assertEquals("The logger is not correct.","com.foo.NoSQLDbTest.testWriteInternal02",object.get("loggerName"));
    assertEquals("The message is not correct.","Another cool message 02.",object.get("message"));
    assertEquals("The thread is not correct.","AnotherThread-B",object.get("threadName"));
    assertEquals("The millis is not correct.",987654321564L,object.get("millis"));
    assertEquals("The date is not correct.",987654321564L,((Date)object.get("date")).getTime());
    assertTrue("The source should be a map.",object.get("source") instanceof Map);
    @SuppressWarnings("unchecked") final Map<String,Object> source=(Map<String,Object>)object.get("source");
    assertEquals("The class is not correct.","com.bar.Foo",source.get("className"));
    assertEquals("The method is not correct.","anotherMethod03",source.get("methodName"));
    assertEquals("The file name is not correct.","Foo.java",source.get("fileName"));
    assertEquals("The line number is not correct.",9,source.get("lineNumber"));
    assertTrue("The marker should be a map.",object.get("marker") instanceof Map);
    @SuppressWarnings("unchecked") final Map<String,Object> marker=(Map<String,Object>)object.get("marker");
    assertEquals("The marker name is not correct.","AnotherMarker",marker.get("name"));
    assertTrue("The marker parents should be a list.",marker.get("parents") instanceof List);
    @SuppressWarnings("unchecked") final List markerParents=(List)marker.get("parents");
    assertEquals("The marker parents should contain two parents",2,markerParents.size());
    assertTrue("The marker parents[0] should be a map.",markerParents.get(0) instanceof Map);
    @SuppressWarnings("unchecked") final Map<String,Object> parent1=(Map<String,Object>)markerParents.get(0);
    assertEquals("The first marker parent name is not correct.","Parent1",parent1.get("name"));
    assertTrue("The marker parents[1] should be a map.",markerParents.get(1) instanceof Map);
    @SuppressWarnings("unchecked") final Map<String,Object> parent2=(Map<String,Object>)markerParents.get(1);
    assertEquals("The second marker parent name is not correct.","Parent2",parent2.get("name"));
    assertNull("The second marker should have no parent.",parent2.get("parent"));
    assertTrue("The parent1 parents should be a list.",parent1.get("parents") instanceof List);
    @SuppressWarnings("unchecked") final List parent1Parents=(List)parent1.get("parents");
    assertEquals("The parent1 parents should have only one parent",1,parent1Parents.size());
    assertTrue("The parent1Parents[0] should be a map.",parent1Parents.get(0) instanceof Map);
    @SuppressWarnings("unchecked") final Map<String,Object> parent1parent=(Map<String,Object>)parent1Parents.get(0);
    assertEquals("The first parent1 parent name is not correct.","GrandParent1",parent1parent.get("name"));
    assertNull("The parent1parent marker should have no parent.",parent1parent.get("parent"));
    assertTrue("The thrown should be a map.",object.get("thrown") instanceof Map);
    @SuppressWarnings("unchecked") final Map<String,Object> thrown=(Map<String,Object>)object.get("thrown");
    assertEquals("The thrown type is not correct.","java.sql.SQLException",thrown.get("type"));
    assertEquals("The thrown message is not correct.","This is the result.",thrown.get("message"));
    assertTrue("The thrown stack trace should be a list.",thrown.get("stackTrace") instanceof List);
    @SuppressWarnings("unchecked") final List<Map<String,Object>> stackTrace=(List<Map<String,Object>>)thrown.get("stackTrace");
    assertEquals("The thrown stack trace length is not correct.",exception2.getStackTrace().length,stackTrace.size());
    for (int i=0; i < exception2.getStackTrace().length; i++) {
      final StackTraceElement e1=exception2.getStackTrace()[i];
      final Map<String,Object> e2=stackTrace.get(i);
      assertEquals("Element class name [" + i + "] is not correct.",e1.getClassName(),e2.get("className"));
      assertEquals("Element method name [" + i + "] is not correct.",e1.getMethodName(),e2.get("methodName"));
      assertEquals("Element file name [" + i + "] is not correct.",e1.getFileName(),e2.get("fileName"));
      assertEquals("Element line number [" + i + "] is not correct.",e1.getLineNumber(),e2.get("lineNumber"));
    }
    assertTrue("The thrown cause should be a map.",thrown.get("cause") instanceof Map);
    @SuppressWarnings("unchecked") final Map<String,Object> cause=(Map<String,Object>)thrown.get("cause");
    assertEquals("The cause type is not correct.","java.io.IOException",cause.get("type"));
    assertEquals("The cause message is not correct.","This is the cause.",cause.get("message"));
    assertTrue("The cause stack trace should be a list.",cause.get("stackTrace") instanceof List);
    @SuppressWarnings("unchecked") final List<Map<String,Object>> causeStackTrace=(List<Map<String,Object>>)cause.get("stackTrace");
    assertEquals("The cause stack trace length is not correct.",exception1.getStackTrace().length,causeStackTrace.size());
    for (int i=0; i < exception1.getStackTrace().length; i++) {
      final StackTraceElement e1=exception1.getStackTrace()[i];
      final Map<String,Object> e2=causeStackTrace.get(i);
      assertEquals("Element class name [" + i + "] is not correct.",e1.getClassName(),e2.get("className"));
      assertEquals("Element method name [" + i + "] is not correct.",e1.getMethodName(),e2.get("methodName"));
      assertEquals("Element file name [" + i + "] is not correct.",e1.getFileName(),e2.get("fileName"));
      assertEquals("Element line number [" + i + "] is not correct.",e1.getLineNumber(),e2.get("lineNumber"));
    }
    assertNull("The cause should have no cause.",cause.get("cause"));
    assertTrue("The context map should be a map.",object.get("contextMap") instanceof Map);
    assertEquals("The context map is not correct.",context,object.get("contextMap"));
    assertTrue("The context stack should be list.",object.get("contextStack") instanceof List);
    assertEquals("The context stack is not correct.",stack.asList(),object.get("contextStack"));
    verify(this.provider,this.connection,event,message);
  }
  finally {
    try {
      manager.release();
    }
 catch (    final Throwable ignore) {
    }
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.logging.log4j.util.ReflectionUtilTest </h4><pre class="type-17 type-11 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether two objects/variables are the same">IdentityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies whether two objects/variables are the same
"></span><br>
@Test public void testSunReflectionEquivalence() throws Exception {
  for (int i=1; i < 6; i++) {
    assertSame(Reflection.getCallerClass(i + ReflectionUtil.JDK_7u25_OFFSET),ReflectionUtil.getCallerClass(i));
  }
}

</code></pre>

<br>
<pre class="type-17 type-6 type-11 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether two objects/variables are the same">IdentityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies whether two objects/variables are the same
"></span><br>
@Test public void testStackTraceEquivalence() throws Exception {
  for (int i=1; i < 15; i++) {
    final Class<?> expected=Reflection.getCallerClass(i + ReflectionUtil.JDK_7u25_OFFSET);
    final Class<?> actual=ReflectionUtil.getCallerClass(i);
    final Class<?> fallbackActual=Class.forName(ReflectionUtil.getEquivalentStackTraceElement(i).getClassName());
    assertSame(expected,actual);
    assertSame(expected,fallbackActual);
  }
}

</code></pre>

<br>
<script>$(document).ready(function() {
  $('pre code').each(function(i, block) {
    hljs.highlightBlock(block);
  });
});</script>
