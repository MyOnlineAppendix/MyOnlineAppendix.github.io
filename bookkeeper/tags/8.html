<h3><span class=" glyphicon glyphicon-tag"/>&nbspUtilityVerifier</h3><kbd>Verifies (un)successful execution of the test case by reporting explicitly a failure</kbd><br><br><br><h4 style="margin:0px">Class: org.apache.bookkeeper.bookie.BookieInitializationTest </h4><pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * Verify that if I try to start a bookie without zk initialized, it won't
 * prevent me from starting the bookie when zk is initialized
 */
@Test(timeout=20000) public void testStartBookieWithoutZKInitialized() throws Exception {
  File tmpDir=createTempDir("bookie","test");
  final String ZK_ROOT="/ledgers2";
  final ServerConfiguration conf=TestBKConfiguration.newServerConfiguration().setZkServers(zkUtil.getZooKeeperConnectString()).setZkTimeout(5000).setJournalDirName(tmpDir.getPath()).setLedgerDirNames(new String[]{tmpDir.getPath()});
  conf.setZkLedgersRootPath(ZK_ROOT);
  try {
    new Bookie(conf);
    fail("Should throw NoNodeException");
  }
 catch (  Exception e) {
  }
  ClientConfiguration clientConf=new ClientConfiguration();
  clientConf.setZkServers(zkUtil.getZooKeeperConnectString());
  clientConf.setZkLedgersRootPath(ZK_ROOT);
  BookKeeperAdmin.format(clientConf,false,false);
  Bookie b=new Bookie(conf);
  b.shutdown();
}

</code></pre>

<br>
<pre class="type-8 type-3 type-4 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Verify duplicate bookie server startup. Should throw
 * java.net.BindException if already BK server is running
 */
@Test(timeout=20000) public void testDuplicateBookieServerStartup() throws Exception {
  File tmpDir=createTempDir("bookie","test");
  ServerConfiguration conf=TestBKConfiguration.newServerConfiguration();
  int port=12555;
  conf.setZkServers(null).setBookiePort(port).setJournalDirName(tmpDir.getPath()).setLedgerDirNames(new String[]{tmpDir.getPath()});
  BookieServer bs1=new BookieServer(conf);
  bs1.start();
  try {
    BookieServer bs2=new BookieServer(conf);
    bs2.start();
    fail("Should throw BindException, as the bk server is already running!");
  }
 catch (  ChannelException ce) {
    Assert.assertTrue("Should be caused by a bind exception",ce.getCause() instanceof BindException);
    Assert.assertTrue("BKServer allowed duplicate startups!",ce.getCause().getMessage().contains("Address already in use"));
  }
}

</code></pre>

<br>
<pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * Verify bookie start behaviour when ZK Server is not running.
 */
@Test(timeout=20000) public void testStartBookieWithoutZKServer() throws Exception {
  zkUtil.killServer();
  File tmpDir=createTempDir("bookie","test");
  final ServerConfiguration conf=TestBKConfiguration.newServerConfiguration().setZkServers(zkUtil.getZooKeeperConnectString()).setZkTimeout(5000).setJournalDirName(tmpDir.getPath()).setLedgerDirNames(new String[]{tmpDir.getPath()});
  try {
    new Bookie(conf);
    fail("Should throw ConnectionLossException as ZKServer is not running!");
  }
 catch (  KeeperException.ConnectionLossException e) {
  }
}

</code></pre>

<br>
<pre class="type-2 type-6 type-8 type-3 type-4 type-7 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Verify the bookie registration, it should throw
 * KeeperException.NodeExistsException if the znode still exists even after
 * the zk session timeout.
 */
@Test(timeout=30000) public void testRegNodeExistsAfterSessionTimeOut() throws Exception {
  File tmpDir=createTempDir("bookie","test");
  ServerConfiguration conf=TestBKConfiguration.newServerConfiguration().setZkServers(null).setJournalDirName(tmpDir.getPath()).setLedgerDirNames(new String[]{tmpDir.getPath()});
  String bkRegPath=conf.getZkAvailableBookiesPath() + "/" + InetAddress.getLocalHost().getHostAddress()+ ":"+ conf.getBookiePort();
  MockBookie b=new MockBookie(conf);
  b.zk=zkc;
  b.testRegisterBookie(conf);
  Stat bkRegNode1=zkc.exists(bkRegPath,false);
  Assert.assertNotNull("Bookie registration node doesn't exists!",bkRegNode1);
  createNewZKClient();
  b.zk=newzk;
  try {
    b.testRegisterBookie(conf);
    fail("Should throw NodeExistsException as the znode is not getting expired");
  }
 catch (  IOException e) {
    Throwable t=e.getCause();
    if (t instanceof KeeperException) {
      KeeperException ke=(KeeperException)t;
      Assert.assertTrue("ErrorCode:" + ke.code() + ", Registration node doesn't exists",ke.code() == KeeperException.Code.NODEEXISTS);
      Stat bkRegNode2=newzk.exists(bkRegPath,false);
      Assert.assertNotNull("Bookie registration has been failed",bkRegNode2);
      Assert.assertTrue("Bookie wrongly registered. Old registration znode:" + bkRegNode1 + ", New znode:"+ bkRegNode2,bkRegNode1.getEphemeralOwner() == bkRegNode2.getEphemeralOwner());
      return;
    }
    throw e;
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.bookkeeper.bookie.BookieJournalTest </h4><pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * Test that if the bookie crashes while writing the length
 * of an entry, that we can recover.
 * This is currently not the case, which is bad as recovery
 * should be fine here. The bookie has crashed while writing
 * but so the client has not be notified of success.
 */
@Test(timeout=60000) public void testTruncatedInLenJournal() throws Exception {
  File journalDir=createTempDir("bookie","journal");
  Bookie.checkDirectoryStructure(Bookie.getCurrentDirectory(journalDir));
  File ledgerDir=createTempDir("bookie","ledger");
  Bookie.checkDirectoryStructure(Bookie.getCurrentDirectory(ledgerDir));
  JournalChannel jc=writeV2Journal(Bookie.getCurrentDirectory(journalDir),100);
  ByteBuffer zeros=ByteBuffer.allocate(2048);
  jc.fc.position(jc.getBufferedChannel().position() - 0x429);
  jc.fc.write(zeros);
  jc.fc.force(false);
  writeIndexFileForLedger(Bookie.getCurrentDirectory(ledgerDir),1,"testPasswd".getBytes());
  ServerConfiguration conf=TestBKConfiguration.newServerConfiguration().setZkServers(null).setJournalDirName(journalDir.getPath()).setLedgerDirNames(new String[]{ledgerDir.getPath()});
  Bookie b=new Bookie(conf);
  b.readJournal();
  b.readEntry(1,99);
  try {
    b.readEntry(1,100);
    fail("Shouldn't have found entry 100");
  }
 catch (  Bookie.NoEntryException e) {
  }
}

</code></pre>

<br>
<pre class="type-2 type-8 type-3 type-4 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test that if the bookie crashes in the middle of writing
 * the actual entry it can recover.
 * In this case the entry will be available, but it will corrupt.
 * This is ok, as the client will disregard the entry after looking
 * at its checksum.
 */
@Test(timeout=60000) public void testTruncatedInEntryJournal() throws Exception {
  File journalDir=createTempDir("bookie","journal");
  Bookie.checkDirectoryStructure(Bookie.getCurrentDirectory(journalDir));
  File ledgerDir=createTempDir("bookie","ledger");
  Bookie.checkDirectoryStructure(Bookie.getCurrentDirectory(ledgerDir));
  JournalChannel jc=writeV2Journal(Bookie.getCurrentDirectory(journalDir),100);
  ByteBuffer zeros=ByteBuffer.allocate(2048);
  jc.fc.position(jc.getBufferedChannel().position() - 0x300);
  jc.fc.write(zeros);
  jc.fc.force(false);
  writeIndexFileForLedger(Bookie.getCurrentDirectory(ledgerDir),1,"testPasswd".getBytes());
  ServerConfiguration conf=TestBKConfiguration.newServerConfiguration().setZkServers(null).setJournalDirName(journalDir.getPath()).setLedgerDirNames(new String[]{ledgerDir.getPath()});
  Bookie b=new Bookie(conf);
  b.readJournal();
  b.readEntry(1,99);
  ByteBuffer buf=b.readEntry(1,100);
  assertEquals("Ledger Id is wrong",buf.getLong(),1);
  assertEquals("Entry Id is wrong",buf.getLong(),100);
  assertEquals("Last confirmed is wrong",buf.getLong(),99);
  assertEquals("Length is wrong",buf.getLong(),100 * 1024);
  buf.getLong();
  boolean allX=true;
  for (int i=0; i < 1024; i++) {
    byte x=buf.get();
    allX=allX && x == (byte)'X';
  }
  assertFalse("Some of buffer should have been zeroed",allX);
  try {
    b.readEntry(1,101);
    fail("Shouldn't have found entry 101");
  }
 catch (  Bookie.NoEntryException e) {
  }
}

</code></pre>

<br>
<pre class="type-2 type-8 type-3 type-4 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testV5Journal() throws Exception {
  File journalDir=createTempDir("bookie","journal");
  Bookie.checkDirectoryStructure(Bookie.getCurrentDirectory(journalDir));
  File ledgerDir=createTempDir("bookie","ledger");
  Bookie.checkDirectoryStructure(Bookie.getCurrentDirectory(ledgerDir));
  writeV5Journal(Bookie.getCurrentDirectory(journalDir),2 * JournalChannel.SECTOR_SIZE,"testV5Journal".getBytes());
  ServerConfiguration conf=TestBKConfiguration.newServerConfiguration().setZkServers(null).setJournalDirName(journalDir.getPath()).setLedgerDirNames(new String[]{ledgerDir.getPath()});
  Bookie b=new Bookie(conf);
  b.readJournal();
  for (int i=1; i <= 2 * JournalChannel.SECTOR_SIZE; i++) {
    b.readEntry(1,i);
  }
  try {
    b.readEntry(1,2 * JournalChannel.SECTOR_SIZE + 1);
    fail("Shouldn't have found entry " + (2 * JournalChannel.SECTOR_SIZE + 1));
  }
 catch (  Bookie.NoEntryException e) {
  }
  assertTrue(b.handles.getHandle(1,"testV5Journal".getBytes()).isFenced());
  b.shutdown();
}

</code></pre>

<br>
<pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * Test that if the journal is all journal, we can not
 * start the bookie. An admin should look to see what has
 * happened in this case
 */
@Test(timeout=60000) public void testAllJunkJournal() throws Exception {
  File journalDir=createTempDir("bookie","journal");
  Bookie.checkDirectoryStructure(Bookie.getCurrentDirectory(journalDir));
  File ledgerDir=createTempDir("bookie","ledger");
  Bookie.checkDirectoryStructure(Bookie.getCurrentDirectory(ledgerDir));
  writeJunkJournal(Bookie.getCurrentDirectory(journalDir));
  ServerConfiguration conf=TestBKConfiguration.newServerConfiguration().setZkServers(null).setJournalDirName(journalDir.getPath()).setLedgerDirNames(new String[]{ledgerDir.getPath()});
  Bookie b=null;
  try {
    b=new Bookie(conf);
    fail("Shouldn't have been able to start without admin");
  }
 catch (  Throwable t) {
  }
 finally {
    if (b != null) {
      b.shutdown();
    }
  }
}

</code></pre>

<br>
<pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * test that we can open a journal written without the magic
 * word at the start. This is for versions of bookkeeper before
 * the magic word was introduced
 */
@Test(timeout=60000) public void testPreV2Journal() throws Exception {
  File journalDir=createTempDir("bookie","journal");
  Bookie.checkDirectoryStructure(Bookie.getCurrentDirectory(journalDir));
  File ledgerDir=createTempDir("bookie","ledger");
  Bookie.checkDirectoryStructure(Bookie.getCurrentDirectory(ledgerDir));
  writePreV2Journal(Bookie.getCurrentDirectory(journalDir),100);
  writeIndexFileForLedger(Bookie.getCurrentDirectory(ledgerDir),1,"testPasswd".getBytes());
  ServerConfiguration conf=TestBKConfiguration.newServerConfiguration().setZkServers(null).setJournalDirName(journalDir.getPath()).setLedgerDirNames(new String[]{ledgerDir.getPath()});
  Bookie b=new Bookie(conf);
  b.readJournal();
  b.readEntry(1,100);
  try {
    b.readEntry(1,101);
    fail("Shouldn't have found entry 101");
  }
 catch (  Bookie.NoEntryException e) {
  }
  b.shutdown();
}

</code></pre>

<br>
<pre class="type-2 type-8 type-3 type-4 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testV4Journal() throws Exception {
  File journalDir=createTempDir("bookie","journal");
  Bookie.checkDirectoryStructure(Bookie.getCurrentDirectory(journalDir));
  File ledgerDir=createTempDir("bookie","ledger");
  Bookie.checkDirectoryStructure(Bookie.getCurrentDirectory(ledgerDir));
  writeV4Journal(Bookie.getCurrentDirectory(journalDir),100,"testPasswd".getBytes());
  ServerConfiguration conf=TestBKConfiguration.newServerConfiguration().setZkServers(null).setJournalDirName(journalDir.getPath()).setLedgerDirNames(new String[]{ledgerDir.getPath()});
  Bookie b=new Bookie(conf);
  b.readJournal();
  b.readEntry(1,100);
  try {
    b.readEntry(1,101);
    fail("Shouldn't have found entry 101");
  }
 catch (  Bookie.NoEntryException e) {
  }
  assertTrue(b.handles.getHandle(1,"testPasswd".getBytes()).isFenced());
  b.shutdown();
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.bookkeeper.bookie.BookieShutdownTest </h4><pre class="type-11 type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * Tests verifies the bookkeeper shutdown while writing entries.
 * Continuously restarting the bookie server to see all the external
 * resources are releasing properly. BOOKKEEPER-678
 */
@Test(timeout=150000) public void testBookieRestartContinuously() throws Exception {
  for (int index=0; index < 100; index++) {
    SyncObj sync=new SyncObj();
    try {
      lh=bkc.createLedger(3,2,digestType,"aaa".getBytes());
      LOG.info("Ledger ID: " + lh.getId());
      for (int i=0; i < numEntriesToWrite; i++) {
        ByteBuffer entry=ByteBuffer.allocate(4);
        entry.putInt(rng.nextInt(maxInt));
        entry.position(0);
        lh.asyncAddEntry(entry.array(),new LedgerEntryAddCallback(),sync);
      }
      LOG.info("Wrote " + numEntriesToWrite + " and now going to fail bookie.");
      bsConfs.remove(0);
      bs.get(0).shutdown();
      bs.remove(0);
      startNewBookie();
      LOG.info("Shutdown one bookie server and started new bookie server...");
    }
 catch (    BKException e) {
      LOG.error("Caught BKException",e);
      fail(e.toString());
    }
catch (    InterruptedException e) {
      LOG.error("Caught InterruptedException",e);
      fail(e.toString());
    }
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.bookkeeper.bookie.CookieTest </h4><pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * Test that if a bookie's port is changed
 * the bookie will fail to start
 */
@Test(timeout=60000) public void testBookiePortChanged() throws Exception {
  ServerConfiguration conf=TestBKConfiguration.newServerConfiguration().setZkServers(zkUtil.getZooKeeperConnectString()).setJournalDirName(newDirectory()).setLedgerDirNames(new String[]{newDirectory(),newDirectory()}).setBookiePort(bookiePort);
  Bookie b=new Bookie(conf);
  b.start();
  b.shutdown();
  conf.setBookiePort(3182);
  try {
    b=new Bookie(conf);
    fail("Shouldn't have been able to start");
  }
 catch (  BookieException.InvalidCookieException ice) {
  }
}

</code></pre>

<br>
<pre class="type-8 type-4 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test that if a bookie is started with directories with
 * version 1 data, that it will fail to start (it needs upgrade)
 */
@Test(timeout=60000) public void testV1data() throws Exception {
  File journalDir=newV1JournalDirectory();
  tmpDirs.add(journalDir);
  File ledgerDir=newV1LedgerDirectory();
  tmpDirs.add(ledgerDir);
  ServerConfiguration conf=TestBKConfiguration.newServerConfiguration().setZkServers(zkUtil.getZooKeeperConnectString()).setJournalDirName(journalDir.getPath()).setLedgerDirNames(new String[]{ledgerDir.getPath()}).setBookiePort(bookiePort);
  try {
    Bookie b=new Bookie(conf);
    fail("Shouldn't have been able to start");
  }
 catch (  BookieException.InvalidCookieException ice) {
    assertTrue("wrong exception",ice.getCause().getMessage().contains("upgrade needed"));
  }
}

</code></pre>

<br>
<pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * Test that if a zookeeper cookie
 * is different to a local cookie, the bookie
 * will fail to start
 */
@Test(timeout=60000) public void testBadJournalCookie() throws Exception {
  ServerConfiguration conf1=TestBKConfiguration.newServerConfiguration().setJournalDirName(newDirectory()).setLedgerDirNames(new String[]{newDirectory()}).setBookiePort(bookiePort);
  Cookie.Builder cookieBuilder=Cookie.generateCookie(conf1);
  Cookie c=cookieBuilder.build();
  c.writeToZooKeeper(zkc,conf1,Version.NEW);
  String journalDir=newDirectory();
  String ledgerDir=newDirectory();
  ServerConfiguration conf2=TestBKConfiguration.newServerConfiguration().setZkServers(zkUtil.getZooKeeperConnectString()).setJournalDirName(journalDir).setLedgerDirNames(new String[]{ledgerDir}).setBookiePort(bookiePort);
  Cookie.Builder cookieBuilder2=Cookie.generateCookie(conf2);
  Cookie c2=cookieBuilder2.build();
  c2.writeToDirectory(new File(journalDir,"current"));
  c2.writeToDirectory(new File(ledgerDir,"current"));
  try {
    Bookie b=new Bookie(conf2);
    fail("Shouldn't have been able to start");
  }
 catch (  BookieException.InvalidCookieException ice) {
  }
}

</code></pre>

<br>
<pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * Test that if a directory's contents
 * are emptied, the bookie will fail to start
 */
@Test(timeout=60000) public void testDirectoryCleared() throws Exception {
  String ledgerDir0=newDirectory();
  String journalDir=newDirectory();
  ServerConfiguration conf=TestBKConfiguration.newServerConfiguration().setZkServers(zkUtil.getZooKeeperConnectString()).setJournalDirName(journalDir).setLedgerDirNames(new String[]{ledgerDir0,newDirectory()}).setBookiePort(bookiePort);
  Bookie b=new Bookie(conf);
  b.start();
  b.shutdown();
  FileUtils.deleteDirectory(new File(ledgerDir0));
  try {
    Bookie b2=new Bookie(conf);
    fail("Shouldn't have been able to start");
  }
 catch (  BookieException.InvalidCookieException ice) {
  }
}

</code></pre>

<br>
<pre class="type-8 type-4 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test old version bookie starts with the cookies generated by new version
 * (with useHostNameAsBookieID=true)
 */
@Test(timeout=60000) public void testV2dataWithHostNameAsBookieID() throws Exception {
  File journalDir=newV2JournalDirectory();
  tmpDirs.add(journalDir);
  File ledgerDir=newV2LedgerDirectory();
  tmpDirs.add(ledgerDir);
  ServerConfiguration conf=TestBKConfiguration.newServerConfiguration().setZkServers(zkUtil.getZooKeeperConnectString()).setJournalDirName(journalDir.getPath()).setLedgerDirNames(new String[]{ledgerDir.getPath()}).setBookiePort(bookiePort);
  try {
    conf.setUseHostNameAsBookieID(true);
    new Bookie(conf);
    fail("Shouldn't have been able to start");
  }
 catch (  BookieException.InvalidCookieException ice) {
    assertTrue("wrong exception",ice.getCause().getMessage().contains("upgrade needed"));
  }
}

</code></pre>

<br>
<pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * Test starting bookie with clean state.
 */
@Test(timeout=60000) public void testCleanStart() throws Exception {
  ServerConfiguration conf=TestBKConfiguration.newServerConfiguration().setZkServers(zkUtil.getZooKeeperConnectString()).setJournalDirName(newDirectory(false)).setLedgerDirNames(new String[]{newDirectory(false)}).setBookiePort(bookiePort);
  try {
    Bookie b=new Bookie(conf);
  }
 catch (  Exception e) {
    fail("Should not reach here.");
  }
}

</code></pre>

<br>
<pre class="type-8 type-4 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test that if a bookie is started with directories with
 * version 2 data, that it will fail to start (it needs upgrade)
 */
@Test(timeout=60000) public void testV2data() throws Exception {
  File journalDir=newV2JournalDirectory();
  tmpDirs.add(journalDir);
  File ledgerDir=newV2LedgerDirectory();
  tmpDirs.add(ledgerDir);
  ServerConfiguration conf=TestBKConfiguration.newServerConfiguration().setZkServers(zkUtil.getZooKeeperConnectString()).setJournalDirName(journalDir.getPath()).setLedgerDirNames(new String[]{ledgerDir.getPath()}).setBookiePort(bookiePort);
  try {
    Bookie b=new Bookie(conf);
    fail("Shouldn't have been able to start");
  }
 catch (  BookieException.InvalidCookieException ice) {
    assertTrue("wrong exception",ice.getCause().getMessage().contains("upgrade needed"));
  }
}

</code></pre>

<br>
<pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * Test that if a directory is removed from
 * the configuration, the bookie will fail to
 * start
 */
@Test(timeout=60000) public void testDirectoryMissing() throws Exception {
  String[] ledgerDirs=new String[]{newDirectory(),newDirectory(),newDirectory()};
  String journalDir=newDirectory();
  ServerConfiguration conf=TestBKConfiguration.newServerConfiguration().setZkServers(zkUtil.getZooKeeperConnectString()).setJournalDirName(journalDir).setLedgerDirNames(ledgerDirs).setBookiePort(bookiePort);
  Bookie b=new Bookie(conf);
  b.start();
  b.shutdown();
  conf.setLedgerDirNames(new String[]{ledgerDirs[0],ledgerDirs[1]});
  try {
    Bookie b2=new Bookie(conf);
    fail("Shouldn't have been able to start");
  }
 catch (  BookieException.InvalidCookieException ice) {
  }
  conf.setJournalDirName(newDirectory()).setLedgerDirNames(ledgerDirs);
  try {
    Bookie b2=new Bookie(conf);
    fail("Shouldn't have been able to start");
  }
 catch (  BookieException.InvalidCookieException ice) {
  }
  conf.setJournalDirName(journalDir);
  b=new Bookie(conf);
  b.start();
  b.shutdown();
}

</code></pre>

<br>
<pre class="type-8 type-4 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testVerifyCookieWithFormat() throws Exception {
  ClientConfiguration adminConf=new ClientConfiguration().setZkServers(zkUtil.getZooKeeperConnectString());
  adminConf.setProperty("bookkeeper.format",true);
  BookKeeperAdmin.format(adminConf,false,true);
  ServerConfiguration bookieConf=TestBKConfiguration.newServerConfiguration().setZkServers(zkUtil.getZooKeeperConnectString()).setJournalDirName(newDirectory(false)).setLedgerDirNames(new String[]{newDirectory(false)}).setBookiePort(bookiePort);
  new Bookie(bookieConf);
  BookKeeperAdmin.format(adminConf,false,true);
  try {
    new Bookie(bookieConf);
    fail("Bookie should not start with previous instance id.");
  }
 catch (  BookieException.InvalidCookieException e) {
    assertTrue("Bookie startup should fail because of invalid instance id",e.getMessage().contains("instanceId"));
  }
  Bookie.format(bookieConf,false,true);
  new Bookie(bookieConf);
}

</code></pre>

<br>
<pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * Test that if a directory is added to a
 * preexisting bookie, the bookie will fail
 * to start
 */
@Test(timeout=60000) public void testDirectoryAdded() throws Exception {
  String ledgerDir0=newDirectory();
  String journalDir=newDirectory();
  ServerConfiguration conf=TestBKConfiguration.newServerConfiguration().setZkServers(zkUtil.getZooKeeperConnectString()).setJournalDirName(journalDir).setLedgerDirNames(new String[]{ledgerDir0}).setBookiePort(bookiePort);
  Bookie b=new Bookie(conf);
  b.start();
  b.shutdown();
  conf.setLedgerDirNames(new String[]{ledgerDir0,newDirectory()});
  try {
    Bookie b2=new Bookie(conf);
    fail("Shouldn't have been able to start");
  }
 catch (  BookieException.InvalidCookieException ice) {
  }
  conf.setLedgerDirNames(new String[]{ledgerDir0});
  b=new Bookie(conf);
  b.start();
  b.shutdown();
}

</code></pre>

<br>
<pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * Test that if a bookie tries to start
 * with the address of a bookie which has already
 * existed in the system, then the bookie will fail
 * to start
 */
@Test(timeout=60000) public void testNewBookieStartingWithAnotherBookiesPort() throws Exception {
  ServerConfiguration conf=TestBKConfiguration.newServerConfiguration().setZkServers(zkUtil.getZooKeeperConnectString()).setJournalDirName(newDirectory()).setLedgerDirNames(new String[]{newDirectory(),newDirectory()}).setBookiePort(bookiePort);
  Bookie b=new Bookie(conf);
  b.start();
  b.shutdown();
  conf=TestBKConfiguration.newServerConfiguration().setZkServers(zkUtil.getZooKeeperConnectString()).setJournalDirName(newDirectory()).setLedgerDirNames(new String[]{newDirectory(),newDirectory()}).setBookiePort(bookiePort);
  try {
    b=new Bookie(conf);
    fail("Shouldn't have been able to start");
  }
 catch (  BookieException.InvalidCookieException ice) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.bookkeeper.bookie.EntryLogTest </h4><pre class="type-8 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testEntryLoggerShouldThrowFNFEIfDirectoriesDoesNotExist() throws Exception {
  File tmpDir=createTempDir("bkTest",".dir");
  ServerConfiguration conf=TestBKConfiguration.newServerConfiguration();
  conf.setLedgerDirNames(new String[]{tmpDir.toString()});
  EntryLogger entryLogger=null;
  try {
    entryLogger=new EntryLogger(conf,new LedgerDirsManager(conf,conf.getLedgerDirs()));
    fail("Expecting FileNotFoundException");
  }
 catch (  FileNotFoundException e) {
    assertEquals("Entry log directory does not exist",e.getLocalizedMessage());
  }
 finally {
    if (entryLogger != null) {
      entryLogger.shutdown();
    }
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.bookkeeper.bookie.LedgerCacheTest </h4><pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * {@link https://issues.apache.org/jira/browse/BOOKKEEPER-524}Checks that getLedgerEntryPage does not throw an NPE in the
 * case getFromTable returns a null ledger entry page reference.
 * This NPE might kill the sync thread leaving a bookie with no
 * sync thread running.
 * @throws IOException
 */
@Test(timeout=30000) public void testSyncThreadNPE() throws IOException {
  newLedgerCache();
  try {
    ((LedgerCacheImpl)ledgerCache).getIndexPageManager().getLedgerEntryPage(0L,0L,true);
  }
 catch (  Exception e) {
    LOG.error("Exception when trying to get a ledger entry page",e);
    fail("Shouldn't have thrown an exception");
  }
}

</code></pre>

<br>
<pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test(timeout=30000) public void testLedgerEviction() throws Exception {
  int numEntries=10;
  conf.setOpenFileLimit(1).setPageLimit(2).setPageSize(8 * numEntries);
  newLedgerCache();
  try {
    int numLedgers=3;
    byte[] masterKey="blah".getBytes();
    for (int i=1; i <= numLedgers; i++) {
      ledgerCache.setMasterKey((long)i,masterKey);
      for (int j=0; j < numEntries; j++) {
        ledgerCache.putEntryOffset(i,j,i * numEntries + j);
      }
    }
  }
 catch (  Exception e) {
    LOG.error("Got Exception.",e);
    fail("Failed to add entry.");
  }
}

</code></pre>

<br>
<pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test(timeout=30000) public void testDeleteLedger() throws Exception {
  int numEntries=10;
  conf.setOpenFileLimit(999).setPageLimit(2).setPageSize(8 * numEntries);
  newLedgerCache();
  try {
    int numLedgers=2;
    byte[] masterKey="blah".getBytes();
    for (int i=1; i <= numLedgers; i++) {
      ledgerCache.setMasterKey((long)i,masterKey);
      for (int j=0; j < numEntries; j++) {
        ledgerCache.putEntryOffset(i,j,i * numEntries + j);
      }
    }
    for (int i=1; i <= numLedgers; i++) {
      ledgerCache.deleteLedger((long)i);
    }
    for (int i=numLedgers + 1; i <= 2 * numLedgers; i++) {
      ledgerCache.setMasterKey((long)i,masterKey);
      for (int j=0; j < numEntries; j++) {
        ledgerCache.putEntryOffset(i,j,i * numEntries + j);
      }
    }
  }
 catch (  Exception e) {
    LOG.error("Got Exception.",e);
    fail("Failed to add entry.");
  }
}

</code></pre>

<br>
<pre class="type-11 type-6 type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test(timeout=30000) public void testPageEviction() throws Exception {
  int numLedgers=10;
  byte[] masterKey="blah".getBytes();
  conf.setOpenFileLimit(999999).setPageLimit(3);
  newLedgerCache();
  try {
    for (int i=1; i <= numLedgers; i++) {
      ledgerCache.setMasterKey((long)i,masterKey);
      ledgerCache.putEntryOffset(i,0,i * 8);
      ledgerCache.putEntryOffset(i,1,i * 8);
    }
    ledgerCache.flushLedger(true);
    ledgerCache.flushLedger(true);
    for (int i=1; i <= numLedgers / 2; i++) {
      ledgerCache.deleteLedger(i);
    }
    newLedgerCache();
    for (int i=1; i <= numLedgers; i++) {
      try {
        ledgerCache.putEntryOffset(i,1,i * 8);
      }
 catch (      NoLedgerException nsle) {
        if (i <= numLedgers / 2) {
        }
 else {
          LOG.error("Error put entry offset : ",nsle);
          fail("Should not reach here.");
        }
      }
    }
  }
 catch (  Exception e) {
    LOG.error("Got Exception.",e);
    fail("Failed to add entry.");
  }
}

</code></pre>

<br>
<pre class="type-11 type-8 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test that if we are writing to more ledgers than there
 * are pages, then we will not flush the index before the
 * entries in the entrylogger have been persisted to disk.{@link https://issues.apache.org/jira/browse/BOOKKEEPER-447}
 */
@Test(timeout=30000) public void testIndexPageEvictionWriteOrder() throws Exception {
  final int numLedgers=10;
  File journalDir=createTempDir("bookie","journal");
  Bookie.checkDirectoryStructure(Bookie.getCurrentDirectory(journalDir));
  File ledgerDir=createTempDir("bookie","ledger");
  Bookie.checkDirectoryStructure(Bookie.getCurrentDirectory(ledgerDir));
  ServerConfiguration conf=TestBKConfiguration.newServerConfiguration().setZkServers(null).setJournalDirName(journalDir.getPath()).setLedgerDirNames(new String[]{ledgerDir.getPath()}).setFlushInterval(1000).setPageLimit(1).setSortedLedgerStorageEnabled(false);
  Bookie b=new Bookie(conf);
  b.start();
  for (int i=1; i <= numLedgers; i++) {
    ByteBuffer packet=generateEntry(i,1);
    b.addEntry(packet,new Bookie.NopWriteCallback(),null,"passwd".getBytes());
  }
  conf=TestBKConfiguration.newServerConfiguration().setZkServers(null).setJournalDirName(journalDir.getPath()).setLedgerDirNames(new String[]{ledgerDir.getPath()});
  b=new Bookie(conf);
  for (int i=1; i <= numLedgers; i++) {
    try {
      b.readEntry(i,1);
    }
 catch (    Bookie.NoLedgerException nle) {
      assertEquals("No ledger should only happen for the last ledger",i,numLedgers);
    }
catch (    Bookie.NoEntryException nee) {
    }
catch (    IOException ioe) {
      LOG.info("Shouldn't have received IOException",ioe);
      fail("Shouldn't throw IOException, should say that entry is not found");
    }
  }
}

</code></pre>

<br>
<pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test(timeout=30000) public void testAddEntryException() throws IOException {
  conf.setPageLimit(10);
  newLedgerCache();
  try {
    byte[] masterKey="blah".getBytes();
    for (int i=0; i < 100; i++) {
      ledgerCache.setMasterKey((long)i,masterKey);
      ledgerCache.putEntryOffset(i,0,i * 8);
    }
  }
 catch (  IOException e) {
    LOG.error("Got IOException.",e);
    fail("Failed to add entry.");
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.bookkeeper.bookie.TestLedgerDirsManager </h4><pre class="type-8 type-4 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testPickWritableDirExclusive() throws Exception {
  try {
    dirsManager.pickRandomWritableDir(curDir);
    fail("Should not reach here due to there is no writable ledger dir.");
  }
 catch (  NoWritableLedgerDirException nwlde) {
    assertTrue(true);
  }
}

</code></pre>

<br>
<pre class="type-8 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testNoWritableDir() throws Exception {
  try {
    dirsManager.addToFilledDirs(curDir);
    dirsManager.pickRandomWritableDir();
    fail("Should not reach here due to there is no writable ledger dir.");
  }
 catch (  NoWritableLedgerDirException nwlde) {
    assertEquals("Should got NoWritableLedgerDirException w/ 'All ledger directories are non writable'.","All ledger directories are non writable",nwlde.getMessage());
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.bookkeeper.bookie.TestSyncThread </h4><pre class="type-2 type-11 type-6 type-8 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions in iterations
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test that sync thread suspension works.
 * i.e. when we suspend the syncthread, nothing
 * will be synced.
 */
@Test(timeout=60000) public void testSyncThreadSuspension() throws Exception {
  int flushInterval=100;
  ServerConfiguration conf=TestBKConfiguration.newServerConfiguration();
  CheckpointSource checkpointSource=new DummyCheckpointSource();
  LedgerDirsListener listener=new DummyLedgerDirsListener();
  final AtomicInteger checkpointCount=new AtomicInteger(0);
  LedgerStorage storage=new DummyLedgerStorage(){
    @Override public Checkpoint checkpoint(    Checkpoint checkpoint) throws IOException {
      checkpointCount.incrementAndGet();
      return checkpoint;
    }
  }
;
  final SyncThread t=new SyncThread(conf,listener,storage,checkpointSource);
  t.start();
  while (checkpointCount.get() == 0) {
    Thread.sleep(flushInterval);
  }
  t.suspendSync();
  Thread.sleep(flushInterval);
  int count=checkpointCount.get();
  for (int i=0; i < 10; i++) {
    assertEquals("Checkpoint count shouldn't change",count,checkpointCount.get());
  }
  t.resumeSync();
  int i=0;
  while (checkpointCount.get() == count) {
    Thread.sleep(flushInterval);
    i++;
    if (i > 100) {
      fail("Checkpointing never resumed");
    }
  }
  t.shutdown();
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.bookkeeper.bookie.UpgradeTest </h4><pre class="type-8 type-4 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testCommandLine() throws Exception {
  PrintStream origerr=System.err;
  PrintStream origout=System.out;
  File output=IOUtils.createTempFileAndDeleteOnExit("bookie","stdout");
  File erroutput=IOUtils.createTempFileAndDeleteOnExit("bookie","stderr");
  System.setOut(new PrintStream(output));
  System.setErr(new PrintStream(erroutput));
  try {
    FileSystemUpgrade.main(new String[]{"-h"});
    try {
      FileSystemUpgrade.main(new String[]{"-u"});
      fail("Should have failed");
    }
 catch (    IllegalArgumentException iae) {
      assertTrue("Wrong exception " + iae.getMessage(),iae.getMessage().contains("without configuration"));
    }
    File f=IOUtils.createTempFileAndDeleteOnExit("bookie","tmpconf");
    try {
      FileSystemUpgrade.main(new String[]{"--conf",f.getPath()});
      fail("Should have failed");
    }
 catch (    IllegalArgumentException iae) {
      assertTrue("Wrong exception " + iae.getMessage(),iae.getMessage().contains("Must specify -upgrade"));
    }
  }
  finally {
    System.setOut(origout);
    System.setErr(origerr);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.bookkeeper.client.BookKeeperCloseTest </h4><pre class="type-8 type-4 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test that createledger using bookkeeper client which is closed should
 * throw ClientClosedException
 */
@Test(timeout=60000) public void testCreateLedger() throws Exception {
  BookKeeper bk=new BookKeeper(baseClientConf,zkc);
  LOG.info("Closing bookkeeper client");
  bk.close();
  try {
    bk.createLedger(digestType,PASSWORD.getBytes());
    fail("should have failed, client is closed");
  }
 catch (  BKClientClosedException e) {
  }
  final AtomicInteger returnCode=new AtomicInteger(0);
  final CountDownLatch openLatch=new CountDownLatch(1);
  CreateCallback cb=new CreateCallback(){
    @Override public void createComplete(    int rc,    LedgerHandle lh,    Object ctx){
      returnCode.set(rc);
      openLatch.countDown();
    }
  }
;
  bk.asyncCreateLedger(3,2,digestType,PASSWORD.getBytes(),cb,openLatch);
  LOG.info("Waiting to finish the ledger creation");
  assertTrue("create ledger call should have completed",openLatch.await(20,TimeUnit.SECONDS));
  assertEquals("Succesfully created ledger through closed bkclient!",BKException.Code.ClientClosedException,returnCode.get());
}

</code></pre>

<br>
<pre class="type-8 type-3 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test that BookKeeperAdmin operationg using a closed BK client will
 * throw a ClientClosedException
 */
@Test(timeout=60000) public void testBookKeeperAdmin() throws Exception {
  BookKeeper bk=new BookKeeper(baseClientConf,zkc);
  BookKeeperAdmin bkadmin=new BookKeeperAdmin(bk);
  LOG.info("Create ledger and add entries to it");
  LedgerHandle lh1=createLedgerWithEntries(bk,100);
  LedgerHandle lh2=createLedgerWithEntries(bk,100);
  LedgerHandle lh3=createLedgerWithEntries(bk,100);
  lh3.close();
  BookieSocketAddress bookieToKill=getBookie(0);
  killBookie(bookieToKill);
  startNewBookie();
  BookieSocketAddress newBookie=getBookie(2);
  CheckerCb checkercb=new CheckerCb();
  LedgerChecker lc=new LedgerChecker(bk);
  lc.checkLedger(lh3,checkercb);
  assertEquals("Should have completed",checkercb.getRc(30,TimeUnit.SECONDS),BKException.Code.OK);
  assertEquals("Should have a missing fragment",1,checkercb.getResult(30,TimeUnit.SECONDS).size());
  restartBookieSlow();
  restartBookieSlow();
  bk.close();
  try {
    bkadmin.openLedger(lh1.getId());
    fail("Shouldn't be able to open with a closed client");
  }
 catch (  BKException.BKClientClosedException cce) {
  }
  try {
    bkadmin.openLedgerNoRecovery(lh1.getId());
    fail("Shouldn't be able to open with a closed client");
  }
 catch (  BKException.BKClientClosedException cce) {
  }
  try {
    bkadmin.recoverBookieData(bookieToKill,newBookie);
    fail("Shouldn't be able to recover with a closed client");
  }
 catch (  BKException.BKClientClosedException cce) {
  }
  try {
    bkadmin.replicateLedgerFragment(lh3,checkercb.getResult(10,TimeUnit.SECONDS).iterator().next(),newBookie);
    fail("Shouldn't be able to replicate with a closed client");
  }
 catch (  BKException.BKClientClosedException cce) {
  }
}

</code></pre>

<br>
<pre class="type-8 type-4 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test that adding entry to a ledger using bookkeeper client which is
 * closed should throw ClientClosedException
 */
@Test(timeout=60000) public void testAddLedgerEntry() throws Exception {
  BookKeeper bk=new BookKeeper(baseClientConf,zkc);
  LOG.info("Create ledger and add entries to it");
  LedgerHandle lh=createLedgerWithEntries(bk,1);
  LOG.info("Closing bookkeeper client");
  restartBookieSlow();
  bk.close();
  try {
    lh.addEntry("foobar".getBytes());
    fail("should have failed, client is closed");
  }
 catch (  BKClientClosedException e) {
  }
  final CountDownLatch completeLatch=new CountDownLatch(1);
  final AtomicInteger rc=new AtomicInteger(BKException.Code.OK);
  lh.asyncAddEntry("foobar".getBytes(),new AddCallback(){
    public void addComplete(    int rccb,    LedgerHandle lh,    long entryId,    Object ctx){
      rc.set(rccb);
      completeLatch.countDown();
    }
  }
,null);
  LOG.info("Waiting to finish adding another entry asynchronously");
  assertTrue("Add entry to ledger call should have completed",completeLatch.await(20,TimeUnit.SECONDS));
  assertEquals("Add entry to ledger should not have succeeded through closed bkclient!",BKException.Code.ClientClosedException,rc.get());
}

</code></pre>

<br>
<pre class="type-8 type-4 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test that deleting a ledger using bookkeeper client which is closed
 * should throw ClientClosedException
 */
@Test(timeout=60000) public void testDeleteLedger() throws Exception {
  BookKeeper bk=new BookKeeper(baseClientConf,zkc);
  LOG.info("Create ledger and add entries to it");
  LedgerHandle lh=createLedgerWithEntries(bk,100);
  LOG.info("Closing bookkeeper client");
  bk.close();
  try {
    bk.deleteLedger(lh.getId());
    fail("should have failed, client is closed");
  }
 catch (  BKClientClosedException e) {
  }
  final AtomicInteger returnCode=new AtomicInteger(0);
  final CountDownLatch openLatch=new CountDownLatch(1);
  AsyncCallback.DeleteCallback cb=new AsyncCallback.DeleteCallback(){
    public void deleteComplete(    int rc,    Object ctx){
      returnCode.set(rc);
      openLatch.countDown();
    }
  }
;
  bk.asyncDeleteLedger(lh.getId(),cb,openLatch);
  LOG.info("Waiting to delete the ledger asynchronously");
  assertTrue("Delete call should have completed",openLatch.await(20,TimeUnit.SECONDS));
  assertEquals("Delete should not have succeeded through closed bkclient!",BKException.Code.ClientClosedException,returnCode.get());
}

</code></pre>

<br>
<pre class="type-8 type-4 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test that closing a ledger using bookkeeper client which is closed should
 * throw ClientClosedException
 */
@Test(timeout=60000) public void testCloseLedger() throws Exception {
  BookKeeper bk=new BookKeeper(baseClientConf,zkc);
  LOG.info("Create ledger and add entries to it");
  LedgerHandle lh=createLedgerWithEntries(bk,100);
  LedgerHandle lh2=createLedgerWithEntries(bk,100);
  LOG.info("Closing bookkeeper client");
  bk.close();
  try {
    lh.close();
    fail("should have failed, client is closed");
  }
 catch (  BKClientClosedException e) {
  }
  final CountDownLatch completeLatch=new CountDownLatch(1);
  final AtomicInteger rc=new AtomicInteger(BKException.Code.OK);
  lh2.asyncClose(new CloseCallback(){
    public void closeComplete(    int rccb,    LedgerHandle lh,    Object ctx){
      rc.set(rccb);
      completeLatch.countDown();
    }
  }
,null);
  LOG.info("Waiting to finish adding another entry asynchronously");
  assertTrue("Close ledger call should have completed",completeLatch.await(20,TimeUnit.SECONDS));
  assertEquals("Close ledger should have succeeded through closed bkclient!",BKException.Code.ClientClosedException,rc.get());
}

</code></pre>

<br>
<pre class="type-8 type-4 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test that readlastconfirmed entry from a ledger using bookkeeper client
 * which is closed should throw ClientClosedException
 */
@Test(timeout=60000) public void testReadLastConfirmed() throws Exception {
  BookKeeper bk=new BookKeeper(baseClientConf,zkc);
  LOG.info("Create ledger and add entries to it");
  LedgerHandle lh=createLedgerWithEntries(bk,100);
  LOG.info("Closing bookkeeper client");
  restartBookieSlow();
  restartBookieSlow();
  restartBookieSlow();
  bk.close();
  final CountDownLatch readLatch=new CountDownLatch(1);
  final AtomicInteger rc=new AtomicInteger(BKException.Code.OK);
  AsyncCallback.ReadLastConfirmedCallback cb=new AsyncCallback.ReadLastConfirmedCallback(){
    @Override public void readLastConfirmedComplete(    int rccb,    long lastConfirmed,    Object ctx){
      rc.set(rccb);
      readLatch.countDown();
    }
  }
;
  lh.asyncReadLastConfirmed(cb,readLatch);
  LOG.info("Waiting to finish reading last confirmed entry asynchronously");
  assertTrue("ReadLastConfirmed call should have completed",readLatch.await(20,TimeUnit.SECONDS));
  assertEquals("ReadLastConfirmed should have succeeded through closed bkclient!",BKException.Code.ClientClosedException,rc.get());
  try {
    lh.readLastConfirmed();
    fail("should have failed, client is closed");
  }
 catch (  BKClientClosedException e) {
  }
}

</code></pre>

<br>
<pre class="type-8 type-4 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test that opening a ledger using bookkeeper client which is closed should
 * throw ClientClosedException
 */
@Test(timeout=60000) public void testFenceLedger() throws Exception {
  BookKeeper bk=new BookKeeper(baseClientConf,zkc);
  LOG.info("Create ledger and add entries to it");
  LedgerHandle lh=createLedgerWithEntries(bk,100);
  LOG.info("Closing bookkeeper client");
  restartBookieSlow();
  bk.close();
  try {
    bk.openLedger(lh.getId(),digestType,PASSWORD.getBytes());
    fail("should have failed, client is closed");
  }
 catch (  BKClientClosedException e) {
  }
  try {
    bk.openLedgerNoRecovery(lh.getId(),digestType,PASSWORD.getBytes());
    fail("should have failed, client is closed");
  }
 catch (  BKClientClosedException e) {
  }
  final AtomicInteger returnCode=new AtomicInteger(0);
  final CountDownLatch openLatch=new CountDownLatch(1);
  AsyncCallback.OpenCallback cb=new AsyncCallback.OpenCallback(){
    public void openComplete(    int rc,    LedgerHandle lh,    Object ctx){
      returnCode.set(rc);
      openLatch.countDown();
    }
  }
;
  bk.asyncOpenLedger(lh.getId(),digestType,PASSWORD.getBytes(),cb,openLatch);
  LOG.info("Waiting to open the ledger asynchronously");
  assertTrue("Open call should have completed",openLatch.await(20,TimeUnit.SECONDS));
  assertTrue("Open should not have succeeded through closed bkclient!",BKException.Code.ClientClosedException == returnCode.get());
}

</code></pre>

<br>
<pre class="type-8 type-4 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test that reading entry from a ledger using bookkeeper client which is
 * closed should throw ClientClosedException
 */
@Test(timeout=60000) public void testReadLedgerEntry() throws Exception {
  BookKeeper bk=new BookKeeper(baseClientConf,zkc);
  LOG.info("Create ledger and add entries to it");
  int numOfEntries=100;
  LedgerHandle lh=createLedgerWithEntries(bk,numOfEntries);
  LOG.info("Closing bookkeeper client");
  restartBookieSlow();
  bk.close();
  try {
    lh.readEntries(0,numOfEntries - 1);
    fail("should have failed, client is closed");
  }
 catch (  BKClientClosedException e) {
  }
  final CountDownLatch readLatch=new CountDownLatch(1);
  final AtomicInteger rc=new AtomicInteger(BKException.Code.OK);
  ReadCallback cb=new ReadCallback(){
    @Override public void readComplete(    int rccb,    LedgerHandle lh,    Enumeration<LedgerEntry> seq,    Object ctx){
      rc.set(rccb);
      readLatch.countDown();
    }
  }
;
  lh.asyncReadEntries(0,numOfEntries - 1,cb,readLatch);
  LOG.info("Waiting to finish reading the entries asynchronously");
  assertTrue("Read entry ledger call should have completed",readLatch.await(20,TimeUnit.SECONDS));
  assertEquals("Read entry ledger should have succeeded through closed bkclient!",BKException.Code.ClientClosedException,rc.get());
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.bookkeeper.client.BookKeeperTest </h4><pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * Test that bookkeeper is not able to open ledgers if
 * it provides the wrong password or wrong digest
 */
@Test(timeout=60000) public void testBookkeeperPassword() throws Exception {
  ClientConfiguration conf=new ClientConfiguration().setZkServers(zkUtil.getZooKeeperConnectString());
  BookKeeper bkc=new BookKeeper(conf);
  DigestType digestCorrect=digestType;
  byte[] passwdCorrect="AAAAAAA".getBytes();
  DigestType digestBad=digestType == DigestType.MAC ? DigestType.CRC32 : DigestType.MAC;
  byte[] passwdBad="BBBBBBB".getBytes();
  LedgerHandle lh=null;
  try {
    lh=bkc.createLedger(digestCorrect,passwdCorrect);
    long id=lh.getId();
    for (int i=0; i < 100; i++) {
      lh.addEntry("foobar".getBytes());
    }
    lh.close();
    try {
      bkc.openLedger(id,digestCorrect,passwdBad);
      fail("Shouldn't be able to open with bad passwd");
    }
 catch (    BKException.BKUnauthorizedAccessException bke) {
    }
    try {
      bkc.openLedger(id,digestBad,passwdCorrect);
      fail("Shouldn't be able to open with bad digest");
    }
 catch (    BKException.BKDigestMatchException bke) {
    }
    try {
      bkc.openLedger(id,digestBad,passwdBad);
      fail("Shouldn't be able to open with bad passwd and digest");
    }
 catch (    BKException.BKUnauthorizedAccessException bke) {
    }
    bkc.openLedger(id,digestCorrect,passwdCorrect).close();
  }
  finally {
    if (lh != null) {
      lh.close();
    }
    bkc.close();
  }
}

</code></pre>

<br>
<pre class="type-8 type-4 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testConstructionNotConnectedExplicitZk() throws Exception {
  ClientConfiguration conf=new ClientConfiguration().setZkServers(zkUtil.getZooKeeperConnectString()).setZkTimeout(20000);
  CountDownLatch l=new CountDownLatch(1);
  zkUtil.sleepServer(5,l);
  l.await();
  ZooKeeper zk=new ZooKeeper(zkUtil.getZooKeeperConnectString(),10000,new Watcher(){
    @Override public void process(    WatchedEvent event){
    }
  }
);
  assertFalse("ZK shouldn't have connected yet",zk.getState().isConnected());
  try {
    BookKeeper bkc=new BookKeeper(conf,zk);
    fail("Shouldn't be able to construct with unconnected zk");
  }
 catch (  KeeperException.ConnectionLossException cle) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.bookkeeper.client.BookieRecoveryTest </h4><pre class="type-2 type-8 type-3 type-4 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testBookieRecoveryOnInRecoveryLedger() throws Exception {
  int numMsgs=10;
  int numLedgers=1;
  List<LedgerHandle> lhs=createLedgers(numLedgers,2,2);
  writeEntriestoLedgers(numMsgs,0,lhs);
  ArrayList<BookieSocketAddress> lastEnsemble=lhs.get(0).getLedgerMetadata().getEnsembles().entrySet().iterator().next().getValue();
  BookieSocketAddress bookieToKill=lastEnsemble.get(0);
  killBookie(bookieToKill);
  BookieSocketAddress bookieToKill2=lastEnsemble.get(1);
  ServerConfiguration conf2=killBookie(bookieToKill2);
  startNewBookie();
  for (  LedgerHandle oldLh : lhs) {
    try {
      bkc.openLedger(oldLh.getId(),digestType,baseClientConf.getBookieRecoveryPasswd());
      fail("Should have thrown exception");
    }
 catch (    Exception e) {
    }
  }
  try {
    bkAdmin.recoverBookieData(bookieToKill,null);
    fail("Should have thrown exception");
  }
 catch (  BKException.BKLedgerRecoveryException bke) {
  }
  bs.add(startBookie(conf2));
  bsConfs.add(conf2);
  bkAdmin.recoverBookieData(bookieToKill,null);
  for (  LedgerHandle lh : lhs) {
    assertTrue("Not fully replicated",verifyFullyReplicated(lh,numMsgs));
  }
  List<LedgerHandle> newLhs=openLedgers(lhs);
  for (  LedgerHandle newLh : newLhs) {
    Map.Entry<Long,ArrayList<BookieSocketAddress>> entry=newLh.getLedgerMetadata().getEnsembles().entrySet().iterator().next();
    assertFalse(entry.getValue().contains(bookieToKill));
    assertTrue(entry.getValue().contains(bookieToKill2));
  }
}

</code></pre>

<br>
<pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test(timeout=60000) public void testAsyncBookieRecoveryToRandomBookiesNotEnoughBookies() throws Exception {
  int numLedgers=3;
  List<LedgerHandle> lhs=createLedgers(numLedgers,numBookies,2);
  int numMsgs=10;
  writeEntriestoLedgers(numMsgs,0,lhs);
  LOG.info("Finished writing all ledger entries so shutdown one of the bookies.");
  int initialPort=bsConfs.get(0).getBookiePort();
  bs.get(0).shutdown();
  bs.remove(0);
  BookieSocketAddress bookieSrc=new BookieSocketAddress(InetAddress.getLocalHost().getHostAddress(),initialPort);
  LOG.info("Now recover the data on the killed bookie (" + bookieSrc + ") and replicate it to a random available one");
  sync.value=false;
  try {
    bkAdmin.recoverBookieData(bookieSrc,null);
    fail("Should have thrown exception");
  }
 catch (  BKException.BKLedgerRecoveryException bke) {
  }
}

</code></pre>

<br>
<pre class="type-2 type-6 type-8 type-3 type-4 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test that when we try to recover a ledger which doesn't have
 * the password stored in the configuration, we don't succeed
 */
@Test(timeout=60000) public void ensurePasswordUsedForOldLedgers() throws Exception {
  if (MSLedgerManagerFactory.class.getName().equals(ledgerManagerFactory)) {
    return;
  }
  zkUtil.getZooKeeperClient().delete("/ledgers/LAYOUT",-1);
  byte[] passwdCorrect="AAAAAA".getBytes();
  byte[] passwdBad="BBBBBB".getBytes();
  DigestType digestCorrect=digestType;
  DigestType digestBad=digestCorrect == DigestType.MAC ? DigestType.CRC32 : DigestType.MAC;
  org.apache.bk_v4_1_0.bookkeeper.client.BookKeeper.DigestType digestCorrect410=org.apache.bk_v4_1_0.bookkeeper.client.BookKeeper.DigestType.valueOf(digestType.toString());
  org.apache.bk_v4_1_0.bookkeeper.conf.ClientConfiguration c=new org.apache.bk_v4_1_0.bookkeeper.conf.ClientConfiguration();
  c.setZkServers(zkUtil.getZooKeeperConnectString()).setLedgerManagerType(ledgerManagerFactory.equals("org.apache.bookkeeper.meta.FlatLedgerManagerFactory") ? "flat" : "hierarchical");
  org.apache.bk_v4_1_0.bookkeeper.client.BookKeeper bkc41=new org.apache.bk_v4_1_0.bookkeeper.client.BookKeeper(c);
  bkc41.close();
  restartBookies();
  bkc41=new org.apache.bk_v4_1_0.bookkeeper.client.BookKeeper(c);
  org.apache.bk_v4_1_0.bookkeeper.client.LedgerHandle lh41=bkc41.createLedger(3,2,digestCorrect410,passwdCorrect);
  long ledgerId=lh41.getId();
  for (int i=0; i < 100; i++) {
    lh41.addEntry("foobar".getBytes());
  }
  lh41.close();
  bkc41.close();
  startNewBookie();
  int removeIndex=0;
  BookieSocketAddress bookieSrc=bs.get(removeIndex).getLocalAddress();
  bs.get(removeIndex).shutdown();
  bs.remove(removeIndex);
  LedgerHandle lh=bkc.openLedgerNoRecovery(ledgerId,digestCorrect,passwdCorrect);
  assertFalse("Should be entries missing",verifyFullyReplicated(lh,100));
  lh.close();
  ClientConfiguration adminConf;
  BookKeeperAdmin bka;
  if (digestCorrect == DigestType.MAC) {
    adminConf=new ClientConfiguration();
    adminConf.setZkServers(zkUtil.getZooKeeperConnectString());
    adminConf.setLedgerManagerFactoryClassName(ledgerManagerFactory);
    adminConf.setBookieRecoveryDigestType(digestCorrect);
    adminConf.setBookieRecoveryPasswd(passwdBad);
    bka=new BookKeeperAdmin(adminConf);
    try {
      bka.recoverBookieData(bookieSrc,null);
      fail("Shouldn't be able to recover with wrong password");
    }
 catch (    BKException bke) {
    }
 finally {
      bka.close();
    }
  }
  adminConf=new ClientConfiguration();
  adminConf.setZkServers(zkUtil.getZooKeeperConnectString());
  adminConf.setLedgerManagerFactoryClassName(ledgerManagerFactory);
  adminConf.setBookieRecoveryDigestType(digestBad);
  adminConf.setBookieRecoveryPasswd(passwdCorrect);
  bka=new BookKeeperAdmin(adminConf);
  try {
    bka.recoverBookieData(bookieSrc,null);
    fail("Shouldn't be able to recover with wrong digest");
  }
 catch (  BKException bke) {
  }
 finally {
    bka.close();
  }
  lh=bkc.openLedgerNoRecovery(ledgerId,digestCorrect,passwdCorrect);
  assertFalse("Should be entries missing",verifyFullyReplicated(lh,100));
  lh.close();
  adminConf.setBookieRecoveryDigestType(digestCorrect);
  adminConf.setBookieRecoveryPasswd(passwdCorrect);
  bka=new BookKeeperAdmin(adminConf);
  bka.recoverBookieData(bookieSrc,null);
  bka.close();
  lh=bkc.openLedgerNoRecovery(ledgerId,digestCorrect,passwdCorrect);
  assertTrue("Should have recovered everything",verifyFullyReplicated(lh,100));
  lh.close();
}

</code></pre>

<br>
<pre class="type-8 type-4 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testBookieRecoveryOnOpenedLedgers() throws Exception {
  int numLedgers=3;
  List<LedgerHandle> lhs=createLedgers(numLedgers,numBookies,2);
  int numMsgs=10;
  writeEntriestoLedgers(numMsgs,0,lhs);
  ArrayList<BookieSocketAddress> lastEnsemble=lhs.get(0).getLedgerMetadata().getEnsembles().entrySet().iterator().next().getValue();
  BookieSocketAddress bookieToKill=lastEnsemble.get(lastEnsemble.size() - 1);
  killBookie(bookieToKill);
  startNewBookie();
  BookieSocketAddress bookieDest=null;
  LOG.info("Now recover the data on the killed bookie (" + bookieToKill + ") and replicate it to a random available one");
  bkAdmin.recoverBookieData(bookieToKill,bookieDest);
  for (  LedgerHandle lh : lhs) {
    assertTrue("Not fully replicated",verifyFullyReplicated(lh,numMsgs));
  }
  try {
    writeEntriestoLedgers(numMsgs,0,lhs);
    fail("should not reach here");
  }
 catch (  Exception e) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.bookkeeper.client.BookieWriteLedgerTest </h4><pre class="type-8 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Verify the functionality LedgerHandleAdv addEntry with duplicate entryIds
 * @throws Exception
 */
@Test(timeout=60000) public void testLedgerCreateAdvSyncAddDuplicateEntryIds() throws Exception {
  lh=bkc.createLedgerAdv(5,3,2,digestType,ledgerPassword);
  LOG.info("Ledger ID: " + lh.getId());
  for (int i=0; i < numEntriesToWrite; i++) {
    ByteBuffer entry=ByteBuffer.allocate(4);
    entry.putInt(rng.nextInt(maxInt));
    entry.position(0);
    entries1.add(entry.array());
    lh.addEntry(i,entry.array());
    entry.position(0);
  }
  readEntries(lh,entries1);
  int dupEntryId=rng.nextInt(numEntriesToWrite - 1);
  try {
    ByteBuffer entry=ByteBuffer.allocate(4);
    entry.putInt(rng.nextInt(maxInt));
    entry.position(0);
    lh.addEntry(dupEntryId,entry.array());
    fail("Expected exception not thrown");
  }
 catch (  BKException e) {
    assertEquals(e.getCode(),BKException.Code.DuplicateEntryIdException);
  }
  lh.close();
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.bookkeeper.client.LedgerCloseTest </h4><pre class="type-11 type-8 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
"></span><br>
@Test(timeout=60000) public void testAllWritesAreCompletedOnClosedLedger() throws Exception {
  for (int i=0; i < 100; i++) {
    LOG.info("Iteration {}",i);
    List<AddCallbackFuture> futures=new ArrayList<AddCallbackFuture>();
    LedgerHandle w=bkc.createLedger(DigestType.CRC32,new byte[0]);
    AddCallbackFuture f=new AddCallbackFuture(0L);
    w.asyncAddEntry("foobar".getBytes(UTF_8),f,null);
    f.get();
    LedgerHandle r=bkc.openLedger(w.getId(),DigestType.CRC32,new byte[0]);
    for (int j=0; j < 100; j++) {
      AddCallbackFuture f1=new AddCallbackFuture(1L + j);
      w.asyncAddEntry("foobar".getBytes(),f1,null);
      futures.add(f1);
    }
    for (    AddCallbackFuture f2 : futures) {
      try {
        f2.get(10,TimeUnit.SECONDS);
      }
 catch (      ExecutionException ee) {
      }
catch (      TimeoutException te) {
        LOG.error("Error on waiting completing entry {} : ",f2.getExpectedEntryId(),te);
        fail("Should succeed on waiting completing entry " + f2.getExpectedEntryId());
      }
    }
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.bookkeeper.client.LedgerRecoveryTest </h4><pre class="type-2 type-6 type-8 type-3 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Verify that it doesn't break the recovery when changing ensemble in
 * recovery add.
 */
@Test(timeout=60000) public void testEnsembleChangeDuringRecovery() throws Exception {
  LedgerHandle lh=bkc.createLedger(numBookies,2,2,digestType,"".getBytes());
  int numEntries=(numBookies * 3) + 1;
  final AtomicInteger numPendingAdds=new AtomicInteger(numEntries);
  final CountDownLatch addDone=new CountDownLatch(1);
  for (int i=0; i < numEntries; i++) {
    lh.asyncAddEntry("data".getBytes(),new AddCallback(){
      @Override public void addComplete(      int rc,      LedgerHandle lh,      long entryId,      Object ctx){
        if (BKException.Code.OK != rc) {
          addDone.countDown();
          return;
        }
        if (numPendingAdds.decrementAndGet() == 0) {
          addDone.countDown();
        }
      }
    }
,null);
  }
  addDone.await(10,TimeUnit.SECONDS);
  if (numPendingAdds.get() > 0) {
    fail("Failed to add " + numEntries + " to ledger handle "+ lh.getId());
  }
  BookieSocketAddress bookie1=lh.getLedgerMetadata().currentEnsemble.get(0);
  ServerConfiguration conf1=killBookie(bookie1);
  BookieSocketAddress bookie2=lh.getLedgerMetadata().currentEnsemble.get(1);
  ServerConfiguration conf2=killBookie(bookie2);
  startDeadBookie(conf1);
  startDeadBookie(conf2);
  startNewBookie();
  startNewBookie();
  LedgerHandle recoveredLh=bkc.openLedger(lh.getId(),digestType,"".getBytes());
  assertEquals("Fenced ledger should have correct lastAddConfirmed",lh.getLastAddConfirmed(),recoveredLh.getLastAddConfirmed());
}

</code></pre>

<br>
<pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test(timeout=60000) public void testLedgerRecoveryWithWrongPassword() throws Exception {
  byte[] ledgerPassword="aaaa".getBytes();
  LedgerHandle lh=bkc.createLedger(digestType,ledgerPassword);
  long ledgerId=lh.getId();
  LOG.info("Ledger ID: " + lh.getId());
  String tmp="BookKeeper is cool!";
  int numEntries=30;
  for (int i=0; i < numEntries; i++) {
    lh.addEntry(tmp.getBytes());
  }
  ledgerPassword="bbbb".getBytes();
  try {
    lh=bkc.openLedger(ledgerId,digestType,ledgerPassword);
    fail("Opening ledger with wrong password should fail");
  }
 catch (  BKException e) {
  }
}

</code></pre>

<br>
<pre class="type-2 type-8 type-3 type-4 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * {@link https://issues.apache.org/jira/browse/BOOKKEEPER-355}A recovery during a rolling restart shouldn't affect the ability
 * to recovery the ledger later.
 * We have a ledger on ensemble B1,B2,B3.
 * The sequence of events is
 * 1. B1 brought down for maintenance
 * 2. Ledger recovery started
 * 3. B2 answers read last confirmed.
 * 4. B1 replaced in ensemble by B4
 * 5. Write to B4 fails for some reason
 * 6. B1 comes back up.
 * 7. B2 goes down for maintenance.
 * 8. Ledger recovery starts (ledger is now unavailable)
 */
@Test(timeout=60000) public void testLedgerRecoveryWithRollingRestart() throws Exception {
  LedgerHandle lhbefore=bkc.createLedger(numBookies,2,digestType,"".getBytes());
  for (int i=0; i < (numBookies * 3) + 1; i++) {
    lhbefore.addEntry("data".getBytes());
  }
  ServerConfiguration conf=newServerConfiguration();
  Bookie deadBookie1=new Bookie(conf){
    @Override public void recoveryAddEntry(    ByteBuffer entry,    WriteCallback cb,    Object ctx,    byte[] masterKey) throws IOException, BookieException {
      throw new IOException("Couldn't write for some reason");
    }
  }
;
  bsConfs.add(conf);
  bs.add(startBookie(conf,deadBookie1));
  BookieSocketAddress bookie1=lhbefore.getLedgerMetadata().currentEnsemble.get(0);
  ServerConfiguration conf1=killBookie(bookie1);
  try {
    bkc.openLedger(lhbefore.getId(),digestType,"".getBytes());
    fail("Shouldn't be able to open ledger, there should be entries missing");
  }
 catch (  BKException.BKLedgerRecoveryException e) {
  }
  bsConfs.add(conf1);
  bs.add(startBookie(conf1));
  BookieSocketAddress bookie2=lhbefore.getLedgerMetadata().currentEnsemble.get(1);
  ServerConfiguration conf2=killBookie(bookie2);
  final AtomicInteger returnCode=new AtomicInteger(0);
  final CountDownLatch openLatch=new CountDownLatch(1);
  bkc.asyncOpenLedger(lhbefore.getId(),digestType,"".getBytes(),new AsyncCallback.OpenCallback(){
    public void openComplete(    int rc,    LedgerHandle lh,    Object ctx){
      returnCode.set(rc);
      openLatch.countDown();
      if (rc == BKException.Code.OK) {
        try {
          lh.close();
        }
 catch (        Exception e) {
          LOG.error("Exception closing ledger handle",e);
        }
      }
    }
  }
,null);
  assertTrue("Open call should have completed",openLatch.await(5,TimeUnit.SECONDS));
  assertFalse("Open should not have succeeded",returnCode.get() == BKException.Code.OK);
  bsConfs.add(conf2);
  bs.add(startBookie(conf2));
  LedgerHandle lhafter=bkc.openLedger(lhbefore.getId(),digestType,"".getBytes());
  assertEquals("Fenced ledger should have correct lastAddConfirmed",lhbefore.getLastAddConfirmed(),lhafter.getLastAddConfirmed());
}

</code></pre>

<br>
<pre class="type-2 type-8 type-3 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testLedgerRecoveryWithNotEnoughBookies() throws Exception {
  int numEntries=3;
  LedgerHandle beforelh=null;
  beforelh=bkc.createLedger(3,3,digestType,"".getBytes());
  String tmp="BookKeeper is cool!";
  for (int i=0; i < numEntries; i++) {
    beforelh.addEntry(tmp.getBytes());
  }
  bs.get(0).shutdown();
  bs.remove(0);
  try {
    bkc.openLedger(beforelh.getId(),digestType,"".getBytes());
    fail("should not reach here!");
  }
 catch (  Exception e) {
  }
  startNewBookie();
  LedgerHandle afterlh=bkc.openLedger(beforelh.getId(),digestType,"".getBytes());
  assertEquals(numEntries - 1,afterlh.getLastAddConfirmed());
}

</code></pre>

<br>
<pre class="type-2 type-8 type-3 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * {@link https://issues.apache.org/jira/browse/BOOKKEEPER-355}Verify that if a recovery happens with 1 replica missing, and it's replaced
 * with a faulty bookie, it doesn't break future recovery from happening.
 * 1. Ledger is created with quorum size as 2, and entries are written
 * 2. Now first bookie is in the ensemble is brought down.
 * 3. Another client fence and trying to recover the same ledger
 * 4. During this time ensemble change will happen
 * and new bookie will be added. But this bookie is not able to write.
 * 5. This recovery will fail.
 * 7. A new non-faulty bookie comes up
 * 8. Another client trying to recover the same ledger.
 */
@Test(timeout=60000) public void testBookieFailureDuringRecovery() throws Exception {
  LedgerHandle lhbefore=bkc.createLedger(numBookies,2,digestType,"".getBytes());
  for (int i=0; i < (numBookies * 3) + 1; i++) {
    lhbefore.addEntry("data".getBytes());
  }
  ServerConfiguration conf=newServerConfiguration();
  Bookie deadBookie1=new Bookie(conf){
    @Override public void recoveryAddEntry(    ByteBuffer entry,    WriteCallback cb,    Object ctx,    byte[] masterKey) throws IOException, BookieException {
      throw new IOException("Couldn't write for some reason");
    }
  }
;
  bsConfs.add(conf);
  bs.add(startBookie(conf,deadBookie1));
  BookieSocketAddress bookie1=lhbefore.getLedgerMetadata().currentEnsemble.get(0);
  killBookie(bookie1);
  try {
    bkc.openLedger(lhbefore.getId(),digestType,"".getBytes());
    fail("Shouldn't be able to open ledger, there should be entries missing");
  }
 catch (  BKException.BKLedgerRecoveryException e) {
  }
  startNewBookie();
  LedgerHandle lhafter=bkc.openLedger(lhbefore.getId(),digestType,"".getBytes());
  assertEquals("Fenced ledger should have correct lastAddConfirmed",lhbefore.getLastAddConfirmed(),lhafter.getLastAddConfirmed());
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.bookkeeper.client.ListLedgersTest </h4><pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test(timeout=60000) public void testRemoveNotSupported() throws Exception {
  int numOfLedgers=1;
  ClientConfiguration conf=new ClientConfiguration().setZkServers(zkUtil.getZooKeeperConnectString());
  BookKeeper bkc=new BookKeeper(conf);
  for (int i=0; i < numOfLedgers; i++) {
    bkc.createLedger(digestType,"testPasswd".getBytes()).close();
  }
  BookKeeperAdmin admin=new BookKeeperAdmin(zkUtil.getZooKeeperConnectString());
  Iterator<Long> iterator=admin.listLedgers().iterator();
  iterator.next();
  try {
    iterator.remove();
  }
 catch (  UnsupportedOperationException e) {
    return;
  }
  Assert.fail("Remove is not supported, we shouln't have reached this point");
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.bookkeeper.client.TestAddEntryQuorumTimeout </h4><pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test(timeout=60000) public void testBasicTimeout() throws Exception {
  BookKeeperTestClient bkc=new BookKeeperTestClient(baseClientConf);
  LedgerHandle lh=bkc.createLedger(3,3,3,digestType,testPasswd);
  List<BookieSocketAddress> curEns=lh.getLedgerMetadata().currentEnsemble;
  byte[] data="foobar".getBytes();
  lh.addEntry(data);
  sleepBookie(curEns.get(0),5).await();
  try {
    lh.addEntry(data);
    Assert.fail("should have thrown");
  }
 catch (  BKException.BKAddEntryQuorumTimeoutException ex) {
  }
}

</code></pre>

<br>
<pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test(timeout=60000) public void testLedgerClosedAfterTimeout() throws Exception {
  BookKeeperTestClient bkc=new BookKeeperTestClient(baseClientConf);
  LedgerHandle lh=bkc.createLedger(3,3,3,digestType,testPasswd);
  List<BookieSocketAddress> curEns=lh.getLedgerMetadata().currentEnsemble;
  byte[] data="foobar".getBytes();
  CountDownLatch b0latch=sleepBookie(curEns.get(0),5);
  try {
    lh.addEntry(data);
    Assert.fail("should have thrown");
  }
 catch (  BKException.BKAddEntryQuorumTimeoutException ex) {
  }
  b0latch.await();
  try {
    lh.addEntry(data);
    Assert.fail("should have thrown");
  }
 catch (  BKException.BKLedgerClosedException ex) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.bookkeeper.client.TestFencing </h4><pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * Test that fencing doesn't work with a bad password
 */
@Test(timeout=60000) public void testFencingBadPassword() throws Exception {
  LedgerHandle writelh=null;
  writelh=bkc.createLedger(digestType,"password1".getBytes());
  String tmp="BookKeeper is cool!";
  for (int i=0; i < 10; i++) {
    writelh.addEntry(tmp.getBytes());
  }
  try {
    bkc.openLedger(writelh.getId(),digestType,"badPassword".getBytes());
    fail("Should not have been able to open with a bad password");
  }
 catch (  BKException.BKUnauthorizedAccessException uue) {
  }
  writelh.addEntry(tmp.getBytes());
}

</code></pre>

<br>
<pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * create a ledger and write entries.
 * kill a bookie in the ensemble. Recover.
 * Fence the ledger. Kill another bookie. Recover.
 */
@Test(timeout=60000) public void testFencingInteractionWithBookieRecovery() throws Exception {
  System.setProperty("digestType",digestType.toString());
  System.setProperty("passwd","testPasswd");
  BookKeeperAdmin admin=new BookKeeperAdmin(zkUtil.getZooKeeperConnectString());
  LedgerHandle writelh=bkc.createLedger(digestType,"testPasswd".getBytes());
  String tmp="Foobar";
  final int numEntries=10;
  for (int i=0; i < numEntries; i++) {
    writelh.addEntry(tmp.getBytes());
  }
  BookieSocketAddress bookieToKill=writelh.getLedgerMetadata().getEnsemble(numEntries).get(0);
  killBookie(bookieToKill);
  for (int i=0; i < numEntries; i++) {
    writelh.addEntry(tmp.getBytes());
  }
  admin.recoverBookieData(bookieToKill,null);
  for (int i=0; i < numEntries; i++) {
    writelh.addEntry(tmp.getBytes());
  }
  LedgerHandle readlh=bkc.openLedger(writelh.getId(),digestType,"testPasswd".getBytes());
  try {
    writelh.addEntry(tmp.getBytes());
    LOG.error("Should have thrown an exception");
    fail("Should have thrown an exception when trying to write");
  }
 catch (  BKException.BKLedgerFencedException e) {
  }
  readlh.close();
  writelh.close();
}

</code></pre>

<br>
<pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test(timeout=60000) public void testFencingAndRestartBookies() throws Exception {
  LedgerHandle writelh=null;
  writelh=bkc.createLedger(digestType,"password".getBytes());
  String tmp="BookKeeper is cool!";
  for (int i=0; i < 10; i++) {
    writelh.addEntry(tmp.getBytes());
  }
  LedgerHandle readlh=bkc.openLedger(writelh.getId(),digestType,"password".getBytes());
  restartBookies();
  try {
    writelh.addEntry(tmp.getBytes());
    LOG.error("Should have thrown an exception");
    fail("Should have thrown an exception when trying to write");
  }
 catch (  BKException.BKLedgerFencedException e) {
  }
  readlh.close();
}

</code></pre>

<br>
<pre class="type-2 type-8 type-3 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test that opening a ledger in norecovery mode
 * doesn't fence off a ledger
 */
@Test(timeout=60000) public void testNoRecoveryOpen() throws Exception {
  LedgerHandle writelh=null;
  writelh=bkc.createLedger(digestType,"".getBytes());
  String tmp="BookKeeper is cool!";
  final int numEntries=10;
  for (int i=0; i < numEntries; i++) {
    writelh.addEntry(tmp.getBytes());
  }
  LedgerHandle readlh=bkc.openLedgerNoRecovery(writelh.getId(),digestType,"".getBytes());
  writelh.addEntry(tmp.getBytes());
  long numReadable=readlh.getLastAddConfirmed();
  LOG.error("numRead " + numReadable);
  readlh.readEntries(1,numReadable);
  try {
    readlh.readEntries(numReadable + 1,numReadable + 1);
    fail("Shouldn't have been able to read this far");
  }
 catch (  BKException.BKReadException e) {
  }
  writelh.addEntry(tmp.getBytes());
  long numReadable2=readlh.getLastAddConfirmed();
  assertEquals("Number of readable entries hasn't changed",numReadable2,numReadable);
  readlh.close();
  writelh.addEntry(tmp.getBytes());
  writelh.close();
}

</code></pre>

<br>
<pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * create a ledger and write entries.
 * Fence the ledger. Kill a bookie. Recover.
 * Ensure that recover doesn't reallow adding
 */
@Test(timeout=60000) public void testFencingInteractionWithBookieRecovery2() throws Exception {
  System.setProperty("digestType",digestType.toString());
  System.setProperty("passwd","testPasswd");
  BookKeeperAdmin admin=new BookKeeperAdmin(zkUtil.getZooKeeperConnectString());
  LedgerHandle writelh=bkc.createLedger(digestType,"testPasswd".getBytes());
  String tmp="Foobar";
  final int numEntries=10;
  for (int i=0; i < numEntries; i++) {
    writelh.addEntry(tmp.getBytes());
  }
  LedgerHandle readlh=bkc.openLedger(writelh.getId(),digestType,"testPasswd".getBytes());
  BookieSocketAddress bookieToKill=writelh.getLedgerMetadata().getEnsemble(numEntries).get(0);
  killBookie(bookieToKill);
  admin.recoverBookieData(bookieToKill,null);
  try {
    writelh.addEntry(tmp.getBytes());
    LOG.error("Should have thrown an exception");
    fail("Should have thrown an exception when trying to write");
  }
 catch (  BKException.BKLedgerFencedException e) {
  }
  readlh.close();
  writelh.close();
}

</code></pre>

<br>
<pre class="type-2 type-8 type-3 type-4 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Basic fencing test. Create ledger, write to it,
 * open ledger, write again (should fail).
 */
@Test(timeout=60000) public void testBasicFencing() throws Exception {
  LedgerHandle writelh=null;
  writelh=bkc.createLedger(digestType,"password".getBytes());
  String tmp="BookKeeper is cool!";
  for (int i=0; i < 10; i++) {
    writelh.addEntry(tmp.getBytes());
  }
  LedgerHandle readlh=bkc.openLedger(writelh.getId(),digestType,"password".getBytes());
  try {
    writelh.addEntry(tmp.getBytes());
    LOG.error("Should have thrown an exception");
    fail("Should have thrown an exception when trying to write");
  }
 catch (  BKException.BKLedgerFencedException e) {
  }
  assertTrue("Has not recovered correctly: " + readlh.getLastAddConfirmed() + " original "+ writelh.getLastAddConfirmed(),readlh.getLastAddConfirmed() == writelh.getLastAddConfirmed());
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.bookkeeper.client.TestLedgerFragmentReplication </h4><pre class="type-6 type-8 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Tests that fragment re-replication fails on last unclosed ledger
 * fragments.
 */
@Test(timeout=60000) public void testReplicateLFFailsOnlyOnLastUnClosedFragments() throws Exception {
  byte[] data="TestLedgerFragmentReplication".getBytes();
  LedgerHandle lh=bkc.createLedger(3,3,TEST_DIGEST_TYPE,TEST_PSSWD);
  for (int i=0; i < 10; i++) {
    lh.addEntry(data);
  }
  BookieSocketAddress replicaToKill=lh.getLedgerMetadata().getEnsembles().get(0L).get(0);
  startNewBookie();
  LOG.info("Killing Bookie",replicaToKill);
  killBookie(replicaToKill);
  for (int i=0; i < 10; i++) {
    lh.addEntry(data);
  }
  BookieSocketAddress replicaToKill2=lh.getLedgerMetadata().getEnsembles().get(0L).get(1);
  int startNewBookie2=startNewBookie();
  LOG.info("Killing Bookie",replicaToKill2);
  killBookie(replicaToKill2);
  BookieSocketAddress newBkAddr=new BookieSocketAddress(InetAddress.getLocalHost().getHostAddress(),startNewBookie2);
  LOG.info("New Bookie addr :" + newBkAddr);
  Set<LedgerFragment> result=getFragmentsToReplicate(lh);
  BookKeeperAdmin admin=new BookKeeperAdmin(baseClientConf);
  int unclosedCount=0;
  for (  LedgerFragment lf : result) {
    if (lf.isClosed()) {
      admin.replicateLedgerFragment(lh,lf,newBkAddr);
    }
 else {
      unclosedCount++;
      try {
        admin.replicateLedgerFragment(lh,lf,newBkAddr);
        fail("Shouldn't be able to rereplicate unclosed ledger");
      }
 catch (      BKException bke) {
      }
    }
  }
  assertEquals("Should be only one unclosed fragment",1,unclosedCount);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.bookkeeper.client.TestRackawareEnsemblePlacementPolicy </h4><pre class="type-2 type-8 type-3 type-4 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testNewEnsembleWithMultipleRacks() throws Exception {
  BookieSocketAddress addr1=new BookieSocketAddress("127.0.0.1",3181);
  BookieSocketAddress addr2=new BookieSocketAddress("127.0.0.2",3181);
  BookieSocketAddress addr3=new BookieSocketAddress("127.0.0.3",3181);
  BookieSocketAddress addr4=new BookieSocketAddress("127.0.0.4",3181);
  StaticDNSResolver.addNodeToRack(addr1.getSocketAddress().getAddress().getHostAddress(),NetworkTopology.DEFAULT_RACK);
  StaticDNSResolver.addNodeToRack(addr2.getSocketAddress().getAddress().getHostAddress(),"/r2");
  StaticDNSResolver.addNodeToRack(addr3.getSocketAddress().getAddress().getHostAddress(),"/r2");
  StaticDNSResolver.addNodeToRack(addr4.getSocketAddress().getAddress().getHostAddress(),"/r2");
  Set<BookieSocketAddress> addrs=new HashSet<BookieSocketAddress>();
  addrs.add(addr1);
  addrs.add(addr2);
  addrs.add(addr3);
  addrs.add(addr4);
  repp.onClusterChanged(addrs,new HashSet<BookieSocketAddress>());
  try {
    ArrayList<BookieSocketAddress> ensemble=repp.newEnsemble(3,2,new HashSet<BookieSocketAddress>());
    int numCovered=getNumCoveredWriteQuorums(ensemble,2);
    assertTrue(numCovered >= 1 && numCovered < 3);
    ArrayList<BookieSocketAddress> ensemble2=repp.newEnsemble(4,2,new HashSet<BookieSocketAddress>());
    numCovered=getNumCoveredWriteQuorums(ensemble2,2);
    assertTrue(numCovered >= 1 && numCovered < 3);
  }
 catch (  BKNotEnoughBookiesException bnebe) {
    fail("Should not get not enough bookies exception even there is only one rack.");
  }
}

</code></pre>

<br>
<pre class="type-8 type-3 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testNewEnsembleWithSingleRack() throws Exception {
  BookieSocketAddress addr1=new BookieSocketAddress("127.0.0.1",3181);
  BookieSocketAddress addr2=new BookieSocketAddress("127.0.0.2",3181);
  BookieSocketAddress addr3=new BookieSocketAddress("127.0.0.3",3181);
  BookieSocketAddress addr4=new BookieSocketAddress("127.0.0.4",3181);
  Set<BookieSocketAddress> addrs=new HashSet<BookieSocketAddress>();
  addrs.add(addr1);
  addrs.add(addr2);
  addrs.add(addr3);
  addrs.add(addr4);
  repp.onClusterChanged(addrs,new HashSet<BookieSocketAddress>());
  try {
    ArrayList<BookieSocketAddress> ensemble=repp.newEnsemble(3,2,new HashSet<BookieSocketAddress>());
    assertEquals(0,getNumCoveredWriteQuorums(ensemble,2));
    ArrayList<BookieSocketAddress> ensemble2=repp.newEnsemble(4,2,new HashSet<BookieSocketAddress>());
    assertEquals(0,getNumCoveredWriteQuorums(ensemble2,2));
  }
 catch (  BKNotEnoughBookiesException bnebe) {
    fail("Should not get not enough bookies exception even there is only one rack.");
  }
}

</code></pre>

<br>
<pre class="type-8 type-3 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=90000) public void testNewEnsembleWithEnoughRacks() throws Exception {
  BookieSocketAddress addr1=new BookieSocketAddress("127.0.0.1",3181);
  BookieSocketAddress addr2=new BookieSocketAddress("127.0.0.2",3181);
  BookieSocketAddress addr3=new BookieSocketAddress("127.0.0.3",3181);
  BookieSocketAddress addr4=new BookieSocketAddress("127.0.0.4",3181);
  BookieSocketAddress addr5=new BookieSocketAddress("127.0.0.5",3181);
  BookieSocketAddress addr6=new BookieSocketAddress("127.0.0.6",3181);
  BookieSocketAddress addr7=new BookieSocketAddress("127.0.0.7",3181);
  BookieSocketAddress addr8=new BookieSocketAddress("127.0.0.8",3181);
  StaticDNSResolver.addNodeToRack(addr1.getSocketAddress().getAddress().getHostAddress(),NetworkTopology.DEFAULT_RACK);
  StaticDNSResolver.addNodeToRack(addr2.getSocketAddress().getAddress().getHostAddress(),"/r2");
  StaticDNSResolver.addNodeToRack(addr3.getSocketAddress().getAddress().getHostAddress(),"/r3");
  StaticDNSResolver.addNodeToRack(addr4.getSocketAddress().getAddress().getHostAddress(),"/r4");
  StaticDNSResolver.addNodeToRack(addr5.getSocketAddress().getAddress().getHostAddress(),NetworkTopology.DEFAULT_RACK);
  StaticDNSResolver.addNodeToRack(addr6.getSocketAddress().getAddress().getHostAddress(),"/r2");
  StaticDNSResolver.addNodeToRack(addr7.getSocketAddress().getAddress().getHostAddress(),"/r3");
  StaticDNSResolver.addNodeToRack(addr8.getSocketAddress().getAddress().getHostAddress(),"/r4");
  Set<BookieSocketAddress> addrs=new HashSet<BookieSocketAddress>();
  addrs.add(addr1);
  addrs.add(addr2);
  addrs.add(addr3);
  addrs.add(addr4);
  addrs.add(addr5);
  addrs.add(addr6);
  addrs.add(addr7);
  addrs.add(addr8);
  repp.onClusterChanged(addrs,new HashSet<BookieSocketAddress>());
  try {
    ArrayList<BookieSocketAddress> ensemble1=repp.newEnsemble(3,2,new HashSet<BookieSocketAddress>());
    assertEquals(3,getNumCoveredWriteQuorums(ensemble1,2));
    ArrayList<BookieSocketAddress> ensemble2=repp.newEnsemble(4,2,new HashSet<BookieSocketAddress>());
    assertEquals(4,getNumCoveredWriteQuorums(ensemble2,2));
  }
 catch (  BKNotEnoughBookiesException bnebe) {
    fail("Should not get not enough bookies exception even there is only one rack.");
  }
}

</code></pre>

<br>
<pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test(timeout=60000) public void testReplaceBookieWithNotEnoughBookies() throws Exception {
  BookieSocketAddress addr1=new BookieSocketAddress("127.0.0.1",3181);
  BookieSocketAddress addr2=new BookieSocketAddress("127.0.0.2",3181);
  BookieSocketAddress addr3=new BookieSocketAddress("127.0.0.3",3181);
  BookieSocketAddress addr4=new BookieSocketAddress("127.0.0.4",3181);
  StaticDNSResolver.addNodeToRack(addr1.getSocketAddress().getAddress().getHostAddress(),NetworkTopology.DEFAULT_RACK);
  StaticDNSResolver.addNodeToRack(addr2.getSocketAddress().getAddress().getHostAddress(),"/r2");
  StaticDNSResolver.addNodeToRack(addr3.getSocketAddress().getAddress().getHostAddress(),"/r3");
  StaticDNSResolver.addNodeToRack(addr4.getSocketAddress().getAddress().getHostAddress(),"/r4");
  Set<BookieSocketAddress> addrs=new HashSet<BookieSocketAddress>();
  addrs.add(addr1);
  addrs.add(addr2);
  addrs.add(addr3);
  addrs.add(addr4);
  repp.onClusterChanged(addrs,new HashSet<BookieSocketAddress>());
  Set<BookieSocketAddress> excludedAddrs=new HashSet<BookieSocketAddress>();
  excludedAddrs.add(addr1);
  excludedAddrs.add(addr3);
  excludedAddrs.add(addr4);
  try {
    repp.replaceBookie(addr2,excludedAddrs);
    fail("Should throw BKNotEnoughBookiesException when there is not enough bookies");
  }
 catch (  BKNotEnoughBookiesException bnebe) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.bookkeeper.meta.LedgerLayoutTest </h4><pre class="type-8 type-4 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testBadVersionLedgerLayout() throws Exception {
  ClientConfiguration conf=new ClientConfiguration();
  writeLedgerLayout(conf.getZkLedgersRootPath(),FlatLedgerManagerFactory.class.getName(),FlatLedgerManagerFactory.CUR_VERSION,LedgerLayout.LAYOUT_FORMAT_VERSION + 1);
  try {
    LedgerLayout.readLayout(zkc,conf.getZkLedgersRootPath());
    fail("Shouldn't reach here!");
  }
 catch (  IOException ie) {
    assertTrue("Invalid exception",ie.getMessage().contains("version not compatible"));
  }
}

</code></pre>

<br>
<pre class="type-8 type-4 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testAbsentLedgerManagerLayout() throws Exception {
  ClientConfiguration conf=new ClientConfiguration();
  String ledgersLayout=conf.getZkLedgersRootPath() + "/" + BookKeeperConstants.LAYOUT_ZNODE;
  StringBuilder sb=new StringBuilder();
  sb.append(LedgerLayout.LAYOUT_FORMAT_VERSION).append("\n");
  zkc.create(ledgersLayout,sb.toString().getBytes(),Ids.OPEN_ACL_UNSAFE,CreateMode.PERSISTENT);
  try {
    LedgerLayout.readLayout(zkc,conf.getZkLedgersRootPath());
    fail("Shouldn't reach here!");
  }
 catch (  IOException ie) {
    assertTrue("Invalid exception",ie.getMessage().contains("version absent from"));
  }
}

</code></pre>

<br>
<pre class="type-8 type-4 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testBaseLedgerManagerLayout() throws Exception {
  ClientConfiguration conf=new ClientConfiguration();
  String rootPath=conf.getZkLedgersRootPath();
  String ledgersLayout=rootPath + "/" + BookKeeperConstants.LAYOUT_ZNODE;
  StringBuilder sb=new StringBuilder();
  sb.append(LedgerLayout.LAYOUT_FORMAT_VERSION).append("\n").append(FlatLedgerManagerFactory.class.getName());
  zkc.create(ledgersLayout,sb.toString().getBytes(),Ids.OPEN_ACL_UNSAFE,CreateMode.PERSISTENT);
  try {
    LedgerLayout.readLayout(zkc,rootPath);
    fail("Shouldn't reach here!");
  }
 catch (  IOException ie) {
    assertTrue("Invalid exception",ie.getMessage().contains("Invalid Ledger Manager"));
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.bookkeeper.meta.TestLedgerManager </h4><pre class="type-2 type-8 type-3 type-4 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test bad client configuration
 */
@SuppressWarnings("deprecation") @Test(timeout=60000) public void testBadConfV1() throws Exception {
  ClientConfiguration conf=new ClientConfiguration();
  String root0="/goodconf0";
  zkc.create(root0,new byte[0],Ids.OPEN_ACL_UNSAFE,CreateMode.PERSISTENT);
  conf.setZkLedgersRootPath(root0);
  writeLedgerLayout(root0,FlatLedgerManagerFactory.NAME,FlatLedgerManagerFactory.CUR_VERSION,1);
  conf.setLedgerManagerFactoryClass(FlatLedgerManagerFactory.class);
  LedgerManagerFactory m=LedgerManagerFactory.newLedgerManagerFactory(conf,zkc);
  assertTrue("Ledger manager is unexpected type",(m instanceof FlatLedgerManagerFactory));
  m.uninitialize();
  conf.setLedgerManagerFactoryClass(HierarchicalLedgerManagerFactory.class);
  m=LedgerManagerFactory.newLedgerManagerFactory(conf,zkc);
  assertTrue("Ledger manager is unexpected type",(m instanceof FlatLedgerManagerFactory));
  m.uninitialize();
  conf.setLedgerManagerType(HierarchicalLedgerManagerFactory.NAME);
  try {
    LedgerManagerFactory.newLedgerManagerFactory(conf,zkc);
    fail("Shouldn't reach here");
  }
 catch (  Exception e) {
    LOG.error("Received exception",e);
    assertTrue("Invalid exception",e.getMessage().contains("does not match existing layout"));
  }
}

</code></pre>

<br>
<pre class="type-8 type-4 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test bad zk configuration
 */
@Test(timeout=60000) public void testBadZkContents() throws Exception {
  ClientConfiguration conf=new ClientConfiguration();
  String root0="/badzk0";
  zkc.create(root0,new byte[0],Ids.OPEN_ACL_UNSAFE,CreateMode.PERSISTENT);
  conf.setZkLedgersRootPath(root0);
  new LedgerLayout("DoesNotExist",0xdeadbeef).store(zkc,root0);
  try {
    LedgerManagerFactory.newLedgerManagerFactory(conf,zkc);
    fail("Shouldn't reach here");
  }
 catch (  Exception e) {
    LOG.error("Received exception",e);
    assertTrue("Invalid exception",e.getMessage().contains("Failed to instantiate ledger manager factory"));
  }
  String root1="/badzk1";
  zkc.create(root1,new byte[0],Ids.OPEN_ACL_UNSAFE,CreateMode.PERSISTENT);
  conf.setZkLedgersRootPath(root1);
  new LedgerLayout(FlatLedgerManagerFactory.class.getName(),0xdeadbeef).store(zkc,root1);
  try {
    LedgerManagerFactory.newLedgerManagerFactory(conf,zkc);
    fail("Shouldn't reach here");
  }
 catch (  Exception e) {
    LOG.error("Received exception",e);
    assertTrue("Invalid exception",e.getMessage().contains("Incompatible layout version found"));
  }
}

</code></pre>

<br>
<pre class="type-2 type-8 type-3 type-4 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test bad client configuration
 */
@Test(timeout=60000) public void testBadConf() throws Exception {
  ClientConfiguration conf=new ClientConfiguration();
  String root0="/goodconf0";
  zkc.create(root0,new byte[0],Ids.OPEN_ACL_UNSAFE,CreateMode.PERSISTENT);
  conf.setZkLedgersRootPath(root0);
  LedgerManagerFactory m=LedgerManagerFactory.newLedgerManagerFactory(conf,zkc);
  assertTrue("Ledger manager is unexpected type",(m instanceof FlatLedgerManagerFactory));
  m.uninitialize();
  conf.setLedgerManagerFactoryClass(HierarchicalLedgerManagerFactory.class);
  try {
    LedgerManagerFactory.newLedgerManagerFactory(conf,zkc);
    fail("Shouldn't reach here");
  }
 catch (  Exception e) {
    LOG.error("Received exception",e);
    assertTrue("Invalid exception",e.getMessage().contains("does not match existing layout"));
  }
  String root1="/badconf1";
  zkc.create(root1,new byte[0],Ids.OPEN_ACL_UNSAFE,CreateMode.PERSISTENT);
  conf.setZkLedgersRootPath(root1);
  conf.setLedgerManagerFactoryClassName("DoesNotExist");
  try {
    LedgerManagerFactory f=LedgerManagerFactory.newLedgerManagerFactory(conf,zkc);
    fail("Shouldn't reach here");
  }
 catch (  Exception e) {
    LOG.error("Received exception",e);
    assertTrue("Invalid exception",e.getMessage().contains("Failed to get ledger manager factory class from configuration"));
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.bookkeeper.meta.TestZkVersion </h4><pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test(timeout=60000) public void testNullZkVersion(){
  ZkVersion zkVersion=new ZkVersion(99);
  try {
    zkVersion.compare(null);
    Assert.fail("Should fail comparing with null version.");
  }
 catch (  NullPointerException npe) {
  }
}

</code></pre>

<br>
<pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test(timeout=60000) public void testInvalidVersion(){
  ZkVersion zkVersion=new ZkVersion(99);
  try {
    zkVersion.compare(new Version(){
      @Override public Occurred compare(      Version v){
        return Occurred.AFTER;
      }
    }
);
    Assert.fail("Should not reach here!");
  }
 catch (  IllegalArgumentException iae) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.bookkeeper.metastore.TestMetaStore </h4><pre class="type-2 type-8 type-3 type-7 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test usage of get operation on (full and partial) fields.
 */
@Test(timeout=60000) public void testGet() throws Exception {
  Versioned<Value> vv;
  final Set<String> fields=new HashSet<String>(Arrays.asList(new String[]{FIELD_NAME}));
  final String name="get";
  final Integer counter=getRandom();
  Version version=myTable.put(RECORDID,makeValue(name,counter),Version.NEW);
  assertNotNull(version);
  vv=getExistRecordFields(RECORDID,ALL_FIELDS);
  checkExpectedValue(vv,name,counter,version);
  vv=getExistRecordFields(RECORDID,fields);
  checkExpectedValue(vv,name,null,version);
  vv=getExistRecordFields(RECORDID,NON_FIELDS);
  checkExpectedValue(vv,null,null,version);
  try {
    getExistRecordFields(null,NON_FIELDS);
    fail("Should fail to get null key with NON fields");
  }
 catch (  MSException.IllegalOpException ioe) {
  }
  try {
    getExistRecordFields(null,ALL_FIELDS);
    fail("Should fail to get null key with ALL fields.");
  }
 catch (  MSException.IllegalOpException ioe) {
  }
  try {
    getExistRecordFields(null,fields);
    fail("Should fail to get null key with fields " + fields);
  }
 catch (  MSException.IllegalOpException ioe) {
  }
}

</code></pre>

<br>
<pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * Test (get, get partial field, remove) on non-existent element.
 */
@Test(timeout=60000) public void testNonExistent() throws Exception {
  try {
    myTable.get(RECORDID);
    fail("Should fail to get a non-existent key");
  }
 catch (  MSException.NoKeyException nke) {
  }
  Set<String> fields=new HashSet<String>(Arrays.asList(new String[]{FIELD_COUNTER}));
  try {
    myTable.get(RECORDID,fields);
    fail("Should fail to get a non-existent key with specified fields");
  }
 catch (  MSException.NoKeyException nke) {
  }
  try {
    myTable.remove(RECORDID,Version.ANY);
    fail("Should fail to delete a non-existent key");
  }
 catch (  MSException.NoKeyException nke) {
  }
}

</code></pre>

<br>
<pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * Test usage of (scan) operation on (full and partial) fields.
 */
@Test(timeout=60000) public void testOpenCursor() throws Exception {
  TreeMap<String,Value> allValues=Maps.newTreeMap();
  TreeMap<String,Value> partialValues=Maps.newTreeMap();
  TreeMap<String,Value> nonValues=Maps.newTreeMap();
  Set<String> counterFields=Sets.newHashSet(FIELD_COUNTER);
  for (int i=5; i < 24; i++) {
    char c=(char)('a' + i);
    String key=String.valueOf(c);
    Value v=makeValue("value" + i,i);
    Value cv=v.project(counterFields);
    Value nv=v.project(NON_FIELDS);
    myTable.put(key,new Value(v),Version.NEW);
    allValues.put(key,v);
    partialValues.put(key,cv);
    nonValues.put(key,nv);
  }
  MetastoreCursor cursor=myTable.openCursor(ALL_FIELDS);
  openCursorTest(cursor,allValues,7);
  cursor=myTable.openCursor(counterFields);
  openCursorTest(cursor,partialValues,7);
  cursor=myTable.openCursor(NON_FIELDS);
  openCursorTest(cursor,nonValues,7);
  Iterator<Map.Entry<String,Value>> expectedIterator;
  expectedIterator=allValues.subMap("l",true,"u",true).entrySet().iterator();
  openRangeCursorTest("l",true,"u",true,Order.ASC,ALL_FIELDS,expectedIterator,7);
  expectedIterator=allValues.descendingMap().subMap("u",true,"l",true).entrySet().iterator();
  openRangeCursorTest("u",true,"l",true,Order.DESC,ALL_FIELDS,expectedIterator,7);
  expectedIterator=allValues.subMap("l",false,"u",false).entrySet().iterator();
  openRangeCursorTest("l",false,"u",false,Order.ASC,ALL_FIELDS,expectedIterator,7);
  expectedIterator=allValues.descendingMap().subMap("u",false,"l",false).entrySet().iterator();
  openRangeCursorTest("u",false,"l",false,Order.DESC,ALL_FIELDS,expectedIterator,7);
  expectedIterator=allValues.subMap("l",true,"u",false).entrySet().iterator();
  openRangeCursorTest("l",true,"u",false,Order.ASC,ALL_FIELDS,expectedIterator,7);
  expectedIterator=allValues.descendingMap().subMap("u",true,"l",false).entrySet().iterator();
  openRangeCursorTest("u",true,"l",false,Order.DESC,ALL_FIELDS,expectedIterator,7);
  expectedIterator=allValues.subMap("l",false,"u",true).entrySet().iterator();
  openRangeCursorTest("l",false,"u",true,Order.ASC,ALL_FIELDS,expectedIterator,7);
  expectedIterator=allValues.descendingMap().subMap("u",false,"l",true).entrySet().iterator();
  openRangeCursorTest("u",false,"l",true,Order.DESC,ALL_FIELDS,expectedIterator,7);
  String firstKey="f";
  String lastKey="x";
  expectedIterator=allValues.subMap(firstKey,true,lastKey,true).entrySet().iterator();
  openRangeCursorTest("a",true,"z",true,Order.ASC,ALL_FIELDS,expectedIterator,7);
  expectedIterator=allValues.subMap("l",true,lastKey,true).entrySet().iterator();
  openRangeCursorTest("l",true,"z",true,Order.ASC,ALL_FIELDS,expectedIterator,7);
  expectedIterator=allValues.subMap(firstKey,true,"u",true).entrySet().iterator();
  openRangeCursorTest("a",true,"u",true,Order.ASC,ALL_FIELDS,expectedIterator,7);
  expectedIterator=allValues.subMap(firstKey,true,"u",true).entrySet().iterator();
  openRangeCursorTest(EMPTY_START_KEY,true,"u",true,Order.ASC,ALL_FIELDS,expectedIterator,7);
  expectedIterator=allValues.descendingMap().subMap(lastKey,true,"l",true).entrySet().iterator();
  openRangeCursorTest(EMPTY_END_KEY,true,"l",true,Order.DESC,ALL_FIELDS,expectedIterator,7);
  try {
    myTable.openCursor("a",true,"z",true,Order.DESC,ALL_FIELDS);
    fail("Should fail with wrong range");
  }
 catch (  MSException.IllegalOpException ioe) {
  }
  try {
    myTable.openCursor("z",true,"a",true,Order.ASC,ALL_FIELDS);
    fail("Should fail with wrong range");
  }
 catch (  MSException.IllegalOpException ioe) {
  }
  try {
    myTable.openCursor("a",true,"z",true,null,ALL_FIELDS);
    fail("Should fail with null order");
  }
 catch (  MSException.IllegalOpException ioe) {
  }
}

</code></pre>

<br>
<pre class="type-2 type-8 type-3 type-7 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test usage of (unconditional remove, BadVersion remove, CorrectVersion
 * remove) operation.
 */
@Test(timeout=60000) public void testRemove() throws Exception {
  final Integer counter=getRandom();
  final String name="remove";
  Version version;
  version=myTable.put(RECORDID,makeValue(name,counter),Version.NEW);
  assertNotNull(version);
  myTable.remove(RECORDID,Version.ANY);
  version=myTable.put(RECORDID,makeValue(name,counter),Version.NEW);
  assertNotNull(version);
  try {
    myTable.remove(RECORDID,Version.NEW);
    fail("Should fail to remove a given key with bad version");
  }
 catch (  MSException.BadVersionException bve) {
  }
  try {
    myTable.remove(RECORDID,newBadVersion());
    fail("Should fail to remove a given key with bad version");
  }
 catch (  MSException.BadVersionException bve) {
  }
  myTable.remove(RECORDID,version);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.bookkeeper.replication.AuditorLedgerCheckerTest </h4><pre class="type-8 type-4 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=20000) public void testDuplicateEnDisableAutoRecovery() throws Exception {
  urLedgerMgr.disableLedgerReplication();
  try {
    urLedgerMgr.disableLedgerReplication();
    fail("Must throw exception, since AutoRecovery is already disabled");
  }
 catch (  UnavailableException e) {
    assertTrue("AutoRecovery is not disabled previously!",e.getCause() instanceof KeeperException.NodeExistsException);
  }
  urLedgerMgr.enableLedgerReplication();
  try {
    urLedgerMgr.enableLedgerReplication();
    fail("Must throw exception, since AutoRecovery is already enabled");
  }
 catch (  UnavailableException e) {
    assertTrue("AutoRecovery is not enabled previously!",e.getCause() instanceof KeeperException.NoNodeException);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.bookkeeper.replication.BookieLedgerIndexTest </h4><pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * Verify ledger index with failed bookies and throws exception
 */
@Test(timeout=60000) public void testWithoutZookeeper() throws Exception {
  if (newLedgerManagerFactory instanceof MSLedgerManagerFactory) {
    return;
  }
  for (int i=0; i < numberOfLedgers; i++) {
    createAndAddEntriesToLedger().close();
  }
  BookieLedgerIndexer bookieLedgerIndex=new BookieLedgerIndexer(ledgerManager);
  stopZKCluster();
  try {
    bookieLedgerIndex.getBookieToLedgerIndex();
    fail("Must throw exception as zookeeper are not running!");
  }
 catch (  BKAuditException bkAuditException) {
  }
}

</code></pre>

<br>
<pre class="type-8 type-3 type-4 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Verify indexing with multiple ensemble reformation
 */
@Test(timeout=60000) public void testEnsembleReformation() throws Exception {
  try {
    LedgerHandle lh1=createAndAddEntriesToLedger();
    LedgerHandle lh2=createAndAddEntriesToLedger();
    startNewBookie();
    shutdownBookie(bs.size() - 2);
    for (int i=0; i < 10; i++) {
      ByteBuffer entry=ByteBuffer.allocate(4);
      entry.putInt(rng.nextInt(Integer.MAX_VALUE));
      entry.position(0);
      entries.add(entry.array());
      lh1.addEntry(entry.array());
      lh2.addEntry(entry.array());
    }
    BookieLedgerIndexer bookieLedgerIndex=new BookieLedgerIndexer(ledgerManager);
    Map<String,Set<Long>> bookieToLedgerIndex=bookieLedgerIndex.getBookieToLedgerIndex();
    assertEquals("Missed few bookies in the bookie-ledger mapping!",4,bookieToLedgerIndex.size());
    Collection<Set<Long>> bk2ledgerEntry=bookieToLedgerIndex.values();
    for (    Set<Long> ledgers : bk2ledgerEntry) {
      assertEquals("Missed few ledgers in the bookie-ledger mapping!",2,ledgers.size());
      for (      Long ledgerNode : ledgers) {
        assertTrue("Unknown ledger-bookie mapping",ledgerList.contains(ledgerNode));
      }
    }
  }
 catch (  BKException e) {
    LOG.error("Test failed",e);
    fail("Test failed due to BookKeeper exception");
  }
catch (  InterruptedException e) {
    LOG.error("Test failed",e);
    fail("Test failed due to interruption");
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.bookkeeper.replication.TestLedgerUnderreplicationManager </h4><pre class="type-2 type-8 type-3 type-4 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test basic interactions with the ledger underreplication
 * manager.
 * Mark some ledgers as underreplicated.
 * Ensure that getLedgerToReplicate will block until it a ledger
 * becomes available.
 */
@Test(timeout=60000) public void testBasicInteraction() throws Exception {
  Set<Long> ledgers=new HashSet<Long>();
  ledgers.add(0xdeadbeefL);
  ledgers.add(0xbeefcafeL);
  ledgers.add(0xffffbeefL);
  ledgers.add(0xfacebeefL);
  String missingReplica="localhost:3181";
  int count=0;
  LedgerUnderreplicationManager m=lmf1.newLedgerUnderreplicationManager();
  Iterator<Long> iter=ledgers.iterator();
  while (iter.hasNext()) {
    m.markLedgerUnderreplicated(iter.next(),missingReplica);
    count++;
  }
  List<Future<Long>> futures=new ArrayList<Future<Long>>();
  for (int i=0; i < count; i++) {
    futures.add(getLedgerToReplicate(m));
  }
  for (  Future<Long> f : futures) {
    Long l=f.get(5,TimeUnit.SECONDS);
    assertTrue(ledgers.remove(l));
  }
  Future<Long> f=getLedgerToReplicate(m);
  try {
    f.get(1,TimeUnit.SECONDS);
    fail("Shouldn't be able to find a ledger to replicate");
  }
 catch (  TimeoutException te) {
  }
  Long newl=0xfefefefefefeL;
  m.markLedgerUnderreplicated(newl,missingReplica);
  assertEquals("Should have got the one just added",newl,f.get(5,TimeUnit.SECONDS));
}

</code></pre>

<br>
<pre class="type-8 type-4 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test disabling the ledger re-replication. After disabling, it will not be
 * able to getLedgerToRereplicate(). This calls will enter into infinite
 * waiting until enabling rereplication process
 */
@Test(timeout=20000) public void testDisableLedegerReplication() throws Exception {
  final LedgerUnderreplicationManager replicaMgr=lmf1.newLedgerUnderreplicationManager();
  final Long ledgerA=0xfeadeefdacL;
  final String missingReplica="localhost:3181";
  replicaMgr.disableLedgerReplication();
  LOG.info("Disabled Ledeger Replication");
  try {
    replicaMgr.markLedgerUnderreplicated(ledgerA,missingReplica);
  }
 catch (  UnavailableException e) {
    LOG.debug("Unexpected exception while marking urLedger",e);
    fail("Unexpected exception while marking urLedger" + e.getMessage());
  }
  Future<Long> fA=getLedgerToReplicate(replicaMgr);
  try {
    fA.get(1,TimeUnit.SECONDS);
    fail("Shouldn't be able to find a ledger to replicate");
  }
 catch (  TimeoutException te) {
    isLedgerReplicationDisabled=false;
  }
  assertTrue("Ledger replication is not disabled!",!isLedgerReplicationDisabled);
}

</code></pre>

<br>
<pre class="type-2 type-8 type-3 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test locking for ledger unreplication manager.
 * If there's only one ledger marked for rereplication,
 * and one client has it, it should be locked; another
 * client shouldn't be able to get it. If the first client dies
 * however, the second client should be able to get it.
 */
@Test(timeout=60000) public void testLocking() throws Exception {
  String missingReplica="localhost:3181";
  LedgerUnderreplicationManager m1=lmf1.newLedgerUnderreplicationManager();
  LedgerUnderreplicationManager m2=lmf2.newLedgerUnderreplicationManager();
  Long ledger=0xfeadeefdacL;
  m1.markLedgerUnderreplicated(ledger,missingReplica);
  Future<Long> f=getLedgerToReplicate(m1);
  Long l=f.get(5,TimeUnit.SECONDS);
  assertEquals("Should be the ledger I just marked",ledger,l);
  f=getLedgerToReplicate(m2);
  try {
    f.get(1,TimeUnit.SECONDS);
    fail("Shouldn't be able to find a ledger to replicate");
  }
 catch (  TimeoutException te) {
  }
  zkc1.close();
  zkc1=null;
  l=f.get(5,TimeUnit.SECONDS);
  assertEquals("Should be the ledger I marked",ledger,l);
}

</code></pre>

<br>
<pre class="type-8 type-3 type-4 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test enabling the ledger re-replication. After enableLedegerReplication,
 * should continue getLedgerToRereplicate() task
 */
@Test(timeout=20000) public void testEnableLedgerReplication() throws Exception {
  isLedgerReplicationDisabled=true;
  final LedgerUnderreplicationManager replicaMgr=lmf1.newLedgerUnderreplicationManager();
  final Long ledgerA=0xfeadeefdacL;
  final String missingReplica="localhost:3181";
  try {
    replicaMgr.markLedgerUnderreplicated(ledgerA,missingReplica);
  }
 catch (  UnavailableException e) {
    LOG.debug("Unexpected exception while marking urLedger",e);
    fail("Unexpected exception while marking urLedger" + e.getMessage());
  }
  replicaMgr.disableLedgerReplication();
  LOG.debug("Disabled Ledeger Replication");
  String znodeA=getUrLedgerZnode(ledgerA);
  final CountDownLatch znodeLatch=new CountDownLatch(2);
  String urledgerA=StringUtils.substringAfterLast(znodeA,"/");
  String urLockLedgerA=basePath + "/locks/" + urledgerA;
  zkc1.exists(urLockLedgerA,new Watcher(){
    @Override public void process(    WatchedEvent event){
      if (event.getType() == EventType.NodeCreated) {
        znodeLatch.countDown();
        LOG.debug("Recieved node creation event for the zNodePath:" + event.getPath());
      }
    }
  }
);
  Thread thread1=new Thread(){
    @Override public void run(){
      try {
        Long lA=replicaMgr.getLedgerToRereplicate();
        assertEquals("Should be the ledger I just marked",lA,ledgerA);
        isLedgerReplicationDisabled=false;
        znodeLatch.countDown();
      }
 catch (      UnavailableException e) {
        LOG.debug("Unexpected exception while marking urLedger",e);
        isLedgerReplicationDisabled=false;
      }
    }
  }
;
  thread1.start();
  try {
    assertFalse("shouldn't complete",znodeLatch.await(1,TimeUnit.SECONDS));
    assertTrue("Ledger replication is not disabled!",isLedgerReplicationDisabled);
    assertEquals("Failed to disable ledger replication!",2,znodeLatch.getCount());
    replicaMgr.enableLedgerReplication();
    znodeLatch.await(5,TimeUnit.SECONDS);
    LOG.debug("Enabled Ledeger Replication");
    assertTrue("Ledger replication is not disabled!",!isLedgerReplicationDisabled);
    assertEquals("Failed to disable ledger replication!",0,znodeLatch.getCount());
  }
  finally {
    thread1.interrupt();
  }
}

</code></pre>

<br>
<pre class="type-2 type-8 type-3 type-4 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test that when a ledger has been marked as replicated, it
 * will not be offered to anther client.
 * This test checked that by marking two ledgers, and acquiring
 * them on a single client. It marks one as replicated and then
 * the client is killed. We then check that another client can
 * acquire a ledger, and that it's not the one that was previously
 * marked as replicated.
 */
@Test(timeout=60000) public void testMarkingAsReplicated() throws Exception {
  String missingReplica="localhost:3181";
  LedgerUnderreplicationManager m1=lmf1.newLedgerUnderreplicationManager();
  LedgerUnderreplicationManager m2=lmf2.newLedgerUnderreplicationManager();
  Long ledgerA=0xfeadeefdacL;
  Long ledgerB=0xdefadebL;
  m1.markLedgerUnderreplicated(ledgerA,missingReplica);
  m1.markLedgerUnderreplicated(ledgerB,missingReplica);
  Future<Long> fA=getLedgerToReplicate(m1);
  Future<Long> fB=getLedgerToReplicate(m1);
  Long lA=fA.get(5,TimeUnit.SECONDS);
  Long lB=fB.get(5,TimeUnit.SECONDS);
  assertTrue("Should be the ledgers I just marked",(lA.equals(ledgerA) && lB.equals(ledgerB)) || (lA.equals(ledgerB) && lB.equals(ledgerA)));
  Future<Long> f=getLedgerToReplicate(m2);
  try {
    f.get(1,TimeUnit.SECONDS);
    fail("Shouldn't be able to find a ledger to replicate");
  }
 catch (  TimeoutException te) {
  }
  m1.markLedgerReplicated(lA);
  zkc1.close();
  zkc1=null;
  Long l=f.get(5,TimeUnit.SECONDS);
  assertEquals("Should be the ledger I marked",lB,l);
}

</code></pre>

<br>
<pre class="type-2 type-8 type-3 type-4 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test that when a ledger is marked as underreplicated with
 * the same missing replica twice, only marking as replicated
 * will be enough to remove it from the list.
 */
@Test(timeout=60000) public void test2reportSame() throws Exception {
  String missingReplica1="localhost:3181";
  LedgerUnderreplicationManager m1=lmf1.newLedgerUnderreplicationManager();
  LedgerUnderreplicationManager m2=lmf2.newLedgerUnderreplicationManager();
  Long ledgerA=0xfeadeefdacL;
  m1.markLedgerUnderreplicated(ledgerA,missingReplica1);
  m2.markLedgerUnderreplicated(ledgerA,missingReplica1);
  UnderreplicatedLedgerFormat.Builder builderA=UnderreplicatedLedgerFormat.newBuilder();
  String znode=getUrLedgerZnode(ledgerA);
  byte[] data=zkc1.getData(znode,false,null);
  TextFormat.merge(new String(data,Charset.forName("UTF-8")),builderA);
  List<String> replicaList=builderA.getReplicaList();
  assertEquals("Published duplicate missing replica : " + replicaList,1,replicaList.size());
  assertTrue("Published duplicate missing replica : " + replicaList,replicaList.contains(missingReplica1));
  Future<Long> fA=getLedgerToReplicate(m1);
  Long lA=fA.get(5,TimeUnit.SECONDS);
  assertEquals("Should be the ledger I just marked",lA,ledgerA);
  m1.markLedgerReplicated(lA);
  Future<Long> f=getLedgerToReplicate(m2);
  try {
    f.get(1,TimeUnit.SECONDS);
    fail("Shouldn't be able to find a ledger to replicate");
  }
 catch (  TimeoutException te) {
  }
}

</code></pre>

<br>
<pre class="type-2 type-8 type-3 type-4 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test releasing of a ledger
 * A ledger is released when a client decides it does not want
 * to replicate it (or cannot at the moment).
 * When a client releases a previously acquired ledger, another
 * client should then be able to acquire it.
 */
@Test(timeout=60000) public void testRelease() throws Exception {
  String missingReplica="localhost:3181";
  LedgerUnderreplicationManager m1=lmf1.newLedgerUnderreplicationManager();
  LedgerUnderreplicationManager m2=lmf2.newLedgerUnderreplicationManager();
  Long ledgerA=0xfeadeefdacL;
  Long ledgerB=0xdefadebL;
  m1.markLedgerUnderreplicated(ledgerA,missingReplica);
  m1.markLedgerUnderreplicated(ledgerB,missingReplica);
  Future<Long> fA=getLedgerToReplicate(m1);
  Future<Long> fB=getLedgerToReplicate(m1);
  Long lA=fA.get(5,TimeUnit.SECONDS);
  Long lB=fB.get(5,TimeUnit.SECONDS);
  assertTrue("Should be the ledgers I just marked",(lA.equals(ledgerA) && lB.equals(ledgerB)) || (lA.equals(ledgerB) && lB.equals(ledgerA)));
  Future<Long> f=getLedgerToReplicate(m2);
  try {
    f.get(1,TimeUnit.SECONDS);
    fail("Shouldn't be able to find a ledger to replicate");
  }
 catch (  TimeoutException te) {
  }
  m1.markLedgerReplicated(lA);
  m1.releaseUnderreplicatedLedger(lB);
  Long l=f.get(5,TimeUnit.SECONDS);
  assertEquals("Should be the ledger I marked",lB,l);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.bookkeeper.test.AsyncLedgerOpsTest </h4><pre class="type-2 type-11 type-8 type-3 type-4 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions in iterations
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testAsyncCreateClose() throws IOException, BKException {
  try {
    ControlObj ctx=new ControlObj();
synchronized (ctx) {
      LOG.info("Going to create ledger asynchronously");
      bkc.asyncCreateLedger(3,2,digestType,ledgerPassword,this,ctx);
      ctx.wait();
    }
    LedgerHandle lh=ctx.getLh();
    ledgerId=lh.getId();
    LOG.info("Ledger ID: " + lh.getId());
    for (int i=0; i < numEntriesToWrite; i++) {
      ByteBuffer entry=ByteBuffer.allocate(4);
      entry.putInt(rng.nextInt(maxInt));
      entry.position(0);
      entries.add(entry.array());
      entriesSize.add(entry.array().length);
      lh.asyncAddEntry(entry.array(),this,sync);
    }
synchronized (sync) {
      while (sync.counter < numEntriesToWrite) {
        LOG.debug("Entries counter = " + sync.counter);
        sync.wait();
      }
    }
    LOG.info("*** WRITE COMPLETE ***");
synchronized (ctx) {
      lh.asyncClose(this,ctx);
      ctx.wait();
    }
synchronized (ctx) {
      bkc.asyncOpenLedger(ledgerId,digestType,ledgerPassword,this,ctx);
      ctx.wait();
    }
    lh=ctx.getLh();
    LOG.debug("Number of entries written: " + lh.getLastAddConfirmed());
    assertTrue("Verifying number of entries written",lh.getLastAddConfirmed() == (numEntriesToWrite - 1));
    lh.asyncReadEntries(0,numEntriesToWrite - 1,this,sync);
synchronized (sync) {
      while (sync.value == false) {
        sync.wait();
      }
    }
    LOG.debug("*** READ COMPLETE ***");
    int i=0;
    while (ls.hasMoreElements()) {
      ByteBuffer origbb=ByteBuffer.wrap(entries.get(i));
      Integer origEntry=origbb.getInt();
      byte[] entry=ls.nextElement().getEntry();
      ByteBuffer result=ByteBuffer.wrap(entry);
      LOG.debug("Length of result: " + result.capacity());
      LOG.debug("Original entry: " + origEntry);
      Integer retrEntry=result.getInt();
      LOG.debug("Retrieved entry: " + retrEntry);
      assertTrue("Checking entry " + i + " for equality",origEntry.equals(retrEntry));
      assertTrue("Checking entry " + i + " for size",entry.length == entriesSize.get(i).intValue());
      i++;
    }
    assertTrue("Checking number of read entries",i == numEntriesToWrite);
    lh.close();
  }
 catch (  InterruptedException e) {
    LOG.error("Interrupted",e);
    fail("InterruptedException");
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.bookkeeper.test.BookieFailureTest </h4><pre class="type-2 type-8 type-3 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testLedgerNoRecoveryOpenAfterBKCrashed() throws Exception {
  LedgerHandle beforelh=bkc.createLedger(numBookies,numBookies,digestType,"".getBytes());
  int numEntries=10;
  String tmp="BookKeeper is cool!";
  for (int i=0; i < numEntries; i++) {
    beforelh.addEntry(tmp.getBytes());
  }
  killBookie(0);
  LedgerHandle afterlh=bkc.openLedgerNoRecovery(beforelh.getId(),digestType,"".getBytes());
  assertEquals(numEntries - 2,afterlh.getLastAddConfirmed());
  startNewBookie();
  LedgerHandle beforelh2=bkc.createLedger(numBookies,1,digestType,"".getBytes());
  for (int i=0; i < numEntries; i++) {
    beforelh2.addEntry(tmp.getBytes());
  }
  killBookie(0);
  try {
    bkc.openLedgerNoRecovery(beforelh2.getId(),digestType,"".getBytes());
    fail("Should have thrown exception");
  }
 catch (  BKException.BKReadException e) {
  }
}

</code></pre>

<br>
<pre class="type-2 type-8 type-3 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testLedgerOpenAfterBKCrashed() throws Exception {
  LedgerHandle beforelh=bkc.createLedger(numBookies,numBookies,digestType,"".getBytes());
  int numEntries=10;
  String tmp="BookKeeper is cool!";
  for (int i=0; i < numEntries; i++) {
    beforelh.addEntry(tmp.getBytes());
  }
  killBookie(0);
  startNewBookie();
  LedgerHandle afterlh=bkc.openLedger(beforelh.getId(),digestType,"".getBytes());
  assertEquals(beforelh.getLastAddPushed(),afterlh.getLastAddConfirmed());
  LedgerHandle beforelh2=bkc.createLedger(numBookies,1,digestType,"".getBytes());
  for (int i=0; i < numEntries; i++) {
    beforelh2.addEntry(tmp.getBytes());
  }
  killBookie(0);
  try {
    bkc.openLedger(beforelh2.getId(),digestType,"".getBytes());
    fail("Should have thrown exception");
  }
 catch (  BKException.BKLedgerRecoveryException e) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.bookkeeper.test.BookieReadWriteTest </h4><pre class="type-2 type-8 type-3 type-4 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testReadFromOpenLedgerOpenOnce() throws Exception {
  try {
    lh=bkc.createLedger(digestType,ledgerPassword);
    ledgerId=lh.getId();
    LOG.info("Ledger ID: " + lh.getId());
    LedgerHandle lhOpen=bkc.openLedgerNoRecovery(ledgerId,digestType,ledgerPassword);
    writeNEntriesLastWriteSync(lh,numEntriesToWrite / 2);
    ByteBuffer entry=ByteBuffer.allocate(4);
    entry.putInt(rng.nextInt(maxInt));
    entry.position(0);
    int toRead=numEntriesToWrite / 2 - 2;
    long readLastConfirmed=lhOpen.readLastConfirmed();
    assertTrue(readLastConfirmed != 0);
    Enumeration<LedgerEntry> readEntry=lhOpen.readEntries(toRead,toRead);
    assertTrue("Enumeration of ledger entries has no element",readEntry.hasMoreElements() == true);
    LedgerEntry e=readEntry.nextElement();
    assertEquals(toRead,e.getEntryId());
    Assert.assertArrayEquals(entries.get(toRead),e.getEntry());
    try {
      lhOpen.addEntry(entry.array());
      fail("Should have thrown an exception here");
    }
 catch (    BKException.BKIllegalOpException bkioe) {
    }
catch (    Exception ex) {
      LOG.error("Unexpected exception",ex);
      fail("Unexpected exception");
    }
    writeNEntriesLastWriteSync(lh,numEntriesToWrite / 2);
    long last=lh.readLastConfirmed();
    assertTrue("Last confirmed add: " + last,last == (numEntriesToWrite - 2));
    LOG.debug("*** WRITE COMPLETE ***");
    lh.close();
    lhOpen.close();
  }
 catch (  BKException e) {
    LOG.error("Test failed",e);
    fail("Test failed due to BookKeeper exception");
  }
catch (  InterruptedException e) {
    LOG.error("Test failed",e);
    fail("Test failed due to interruption");
  }
}

</code></pre>

<br>
<pre class="type-2 type-8 type-3 type-4 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testReadFromOpenLedgerZeroAndOne() throws Exception {
  try {
    lh=bkc.createLedger(digestType,ledgerPassword);
    ledgerId=lh.getId();
    LOG.info("Ledger ID: " + lh.getId());
    LedgerHandle lhOpen=bkc.openLedgerNoRecovery(ledgerId,digestType,ledgerPassword);
    LOG.debug("Checking that it is empty");
    long readLastConfirmed=lhOpen.readLastConfirmed();
    assertTrue("Last confirmed has the wrong value",readLastConfirmed == LedgerHandle.INVALID_ENTRY_ID);
    LOG.debug("Going to write one entry");
    ByteBuffer entry=ByteBuffer.allocate(4);
    entry.putInt(rng.nextInt(maxInt));
    entry.position(0);
    entries.add(entry.array());
    entriesSize.add(entry.array().length);
    lh.addEntry(entry.array());
    LOG.debug("Checking that it is still empty even after writing one entry");
    readLastConfirmed=lhOpen.readLastConfirmed();
    assertTrue(readLastConfirmed == LedgerHandle.INVALID_ENTRY_ID);
    entry=ByteBuffer.allocate(4);
    entry.putInt(rng.nextInt(maxInt));
    entry.position(0);
    entries.add(entry.array());
    entriesSize.add(entry.array().length);
    lh.addEntry(entry.array());
    LOG.info("Checking that it has an entry");
    readLastConfirmed=lhOpen.readLastConfirmed();
    assertTrue(readLastConfirmed == 0L);
    lh.close();
    lhOpen.close();
  }
 catch (  BKException e) {
    LOG.error("Test failed",e);
    fail("Test failed due to BookKeeper exception");
  }
catch (  InterruptedException e) {
    LOG.error("Test failed",e);
    fail("Test failed due to interruption");
  }
}

</code></pre>

<br>
<pre class="type-2 type-8 type-3 type-4 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testLastConfirmedAdd() throws Exception {
  try {
    lh=bkc.createLedger(digestType,ledgerPassword);
    ledgerId=lh.getId();
    LOG.info("Ledger ID: " + lh.getId());
    writeNEntriesLastWriteSync(lh,numEntriesToWrite);
    long last=lh.readLastConfirmed();
    assertTrue("Last confirmed add: " + last,last == (numEntriesToWrite - 2));
    LOG.debug("*** WRITE COMPLETE ***");
    lh.close();
    lh=bkc.createLedger(digestType,ledgerPassword);
    ledgerId=lh.getId();
    LOG.info("Ledger ID: " + lh.getId());
    writeNEntriesLastWriteSync(lh,numEntriesToWrite);
    SyncObj sync=new SyncObj();
    lh.asyncReadLastConfirmed(this,sync);
synchronized (sync) {
      while (sync.lastConfirmed == LedgerHandle.INVALID_ENTRY_ID) {
        LOG.debug("Counter = " + sync.lastConfirmed);
        sync.wait();
      }
      assertEquals("Error reading",BKException.Code.OK,sync.getReturnCode());
    }
    assertTrue("Last confirmed add: " + sync.lastConfirmed,sync.lastConfirmed == (numEntriesToWrite - 2));
    LOG.debug("*** WRITE COMPLETE ***");
    lh.close();
  }
 catch (  BKException e) {
    LOG.error("Test failed",e);
    fail("Test failed due to BookKeeper exception");
  }
catch (  InterruptedException e) {
    LOG.error("Test failed",e);
    fail("Test failed due to interruption");
  }
}

</code></pre>

<br>
<pre class="type-2 type-11 type-8 type-3 type-4 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions in iterations
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testReadWriteZero() throws IOException {
  try {
    lh=bkc.createLedger(digestType,ledgerPassword);
    ledgerId=lh.getId();
    LOG.info("Ledger ID: " + lh.getId());
    final CountDownLatch completeLatch=new CountDownLatch(numEntriesToWrite);
    final AtomicInteger rc=new AtomicInteger(BKException.Code.OK);
    for (int i=0; i < numEntriesToWrite; i++) {
      lh.asyncAddEntry(new byte[0],new AddCallback(){
        public void addComplete(        int rccb,        LedgerHandle lh,        long entryId,        Object ctx){
          rc.compareAndSet(BKException.Code.OK,rccb);
          completeLatch.countDown();
        }
      }
,null);
    }
    completeLatch.await();
    if (rc.get() != BKException.Code.OK) {
      throw BKException.create(rc.get());
    }
    ByteBuffer entry=ByteBuffer.allocate(4);
    entry.putInt(rng.nextInt(maxInt));
    entry.position(0);
    entries.add(entry.array());
    lh.addEntry(entry.array());
    lh.close();
    lh=bkc.openLedger(ledgerId,digestType,ledgerPassword);
    LOG.debug("Number of entries written: " + lh.getLastAddConfirmed());
    assertTrue("Verifying number of entries written",lh.getLastAddConfirmed() == numEntriesToWrite);
    Enumeration<LedgerEntry> ls=lh.readEntries(0,numEntriesToWrite - 1);
    int i=0;
    while (ls.hasMoreElements()) {
      ByteBuffer result=ByteBuffer.wrap(ls.nextElement().getEntry());
      LOG.debug("Length of result: " + result.capacity());
      assertTrue("Checking if entry " + i + " has zero bytes",result.capacity() == 0);
    }
    lh.close();
  }
 catch (  BKException e) {
    LOG.error("Test failed",e);
    fail("Test failed due to BookKeeper exception");
  }
catch (  InterruptedException e) {
    LOG.error("Test failed",e);
    fail("Test failed due to interruption");
  }
}

</code></pre>

<br>
<pre class="type-2 type-11 type-8 type-3 type-4 type-7 type-9 type-13 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values related to public fields.">PublicFieldVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions in iterations
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects are null
- Verifies whether objects/variable are equal to an expected value 
- Verifies values related to public fields.
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Check that the add api with offset and length work correctly.
 * First try varying the offset. Then the length with a fixed non-zero
 * offset.
 */
@Test(timeout=60000) public void testReadWriteRangeAsyncSingleClient() throws IOException {
  SyncObj sync=new SyncObj();
  try {
    lh=bkc.createLedger(digestType,ledgerPassword);
    ledgerId=lh.getId();
    LOG.info("Ledger ID: " + lh.getId());
    byte bytes[]={'a','b','c','d','e','f','g','h','i'};
    lh.asyncAddEntry(bytes,0,bytes.length,this,sync);
    lh.asyncAddEntry(bytes,0,4,this,sync);
    lh.asyncAddEntry(bytes,3,4,this,sync);
    lh.asyncAddEntry(bytes,3,(bytes.length - 3),this,sync);
    int numEntries=4;
synchronized (sync) {
      while (sync.counter < numEntries) {
        LOG.debug("Entries counter = " + sync.counter);
        sync.wait();
      }
      assertEquals("Error adding",BKException.Code.OK,sync.getReturnCode());
    }
    try {
      lh.asyncAddEntry(bytes,-1,bytes.length,this,sync);
      fail("Shouldn't be able to use negative offset");
    }
 catch (    ArrayIndexOutOfBoundsException aiob) {
    }
    try {
      lh.asyncAddEntry(bytes,0,bytes.length + 1,this,sync);
      fail("Shouldn't be able to use that much length");
    }
 catch (    ArrayIndexOutOfBoundsException aiob) {
    }
    try {
      lh.asyncAddEntry(bytes,-1,bytes.length + 2,this,sync);
      fail("Shouldn't be able to use negative offset " + "with that much length");
    }
 catch (    ArrayIndexOutOfBoundsException aiob) {
    }
    try {
      lh.asyncAddEntry(bytes,4,-3,this,sync);
      fail("Shouldn't be able to use negative length");
    }
 catch (    ArrayIndexOutOfBoundsException aiob) {
    }
    try {
      lh.asyncAddEntry(bytes,-4,-3,this,sync);
      fail("Shouldn't be able to use negative offset & length");
    }
 catch (    ArrayIndexOutOfBoundsException aiob) {
    }
    LOG.debug("*** WRITE COMPLETE ***");
    lh.close();
    lh=bkc.openLedger(ledgerId,digestType,ledgerPassword);
    LOG.debug("Number of entries written: " + (lh.getLastAddConfirmed() + 1));
    assertTrue("Verifying number of entries written",lh.getLastAddConfirmed() == (numEntries - 1));
    lh.asyncReadEntries(0,numEntries - 1,this,sync);
synchronized (sync) {
      while (sync.value == false) {
        sync.wait();
      }
      assertEquals("Error reading",BKException.Code.OK,sync.getReturnCode());
    }
    LOG.debug("*** READ COMPLETE ***");
    int i=0;
    Enumeration<LedgerEntry> ls=sync.getLedgerEntries();
    while (ls.hasMoreElements()) {
      byte[] expected=null;
      byte[] entry=ls.nextElement().getEntry();
switch (i) {
case 0:
        expected=Arrays.copyOfRange(bytes,0,bytes.length);
      break;
case 1:
    expected=Arrays.copyOfRange(bytes,0,4);
  break;
case 2:
expected=Arrays.copyOfRange(bytes,3,3 + 4);
break;
case 3:
expected=Arrays.copyOfRange(bytes,3,3 + (bytes.length - 3));
break;
}
assertNotNull("There are more checks than writes",expected);
String message="Checking entry " + i + " for equality ["+ new String(entry,"UTF-8")+ ","+ new String(expected,"UTF-8")+ "]";
assertTrue(message,Arrays.equals(entry,expected));
i++;
}
assertTrue("Checking number of read entries",i == numEntries);
lh.close();
}
 catch (BKException e) {
LOG.error("Test failed",e);
fail("Test failed due to BookKeeper exception");
}
catch (InterruptedException e) {
LOG.error("Test failed",e);
fail("Test failed due to interruption");
}
}

</code></pre>

<br>
<pre class="type-2 type-11 type-8 type-3 type-4 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions in iterations
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testSyncReadAsyncWriteStringsSingleClient() throws IOException {
  SyncObj sync=new SyncObj();
  LOG.info("TEST READ WRITE STRINGS MIXED SINGLE CLIENT");
  String charset="utf-8";
  LOG.debug("Default charset: " + Charset.defaultCharset());
  try {
    lh=bkc.createLedger(digestType,ledgerPassword);
    ledgerId=lh.getId();
    LOG.info("Ledger ID: " + lh.getId());
    for (int i=0; i < numEntriesToWrite; i++) {
      int randomInt=rng.nextInt(maxInt);
      byte[] entry=new String(Integer.toString(randomInt)).getBytes(charset);
      entries.add(entry);
      lh.asyncAddEntry(entry,this,sync);
    }
synchronized (sync) {
      while (sync.counter < numEntriesToWrite) {
        LOG.debug("Entries counter = " + sync.counter);
        sync.wait();
      }
      assertEquals("Error adding",BKException.Code.OK,sync.getReturnCode());
    }
    LOG.debug("*** ASYNC WRITE COMPLETE ***");
    lh.close();
    lh=bkc.openLedger(ledgerId,digestType,ledgerPassword);
    LOG.debug("Number of entries written: " + (lh.getLastAddConfirmed() + 1));
    assertTrue("Verifying number of entries written",lh.getLastAddConfirmed() == (numEntriesToWrite - 1));
    Enumeration<LedgerEntry> ls=lh.readEntries(0,numEntriesToWrite - 1);
    LOG.debug("*** SYNC READ COMPLETE ***");
    int i=0;
    while (ls.hasMoreElements()) {
      byte[] origEntryBytes=entries.get(i++);
      byte[] retrEntryBytes=ls.nextElement().getEntry();
      LOG.debug("Original byte entry size: " + origEntryBytes.length);
      LOG.debug("Saved byte entry size: " + retrEntryBytes.length);
      String origEntry=new String(origEntryBytes,charset);
      String retrEntry=new String(retrEntryBytes,charset);
      LOG.debug("Original entry: " + origEntry);
      LOG.debug("Retrieved entry: " + retrEntry);
      assertTrue("Checking entry " + i + " for equality",origEntry.equals(retrEntry));
    }
    assertTrue("Checking number of read entries",i == numEntriesToWrite);
    lh.close();
  }
 catch (  BKException e) {
    LOG.error("Test failed",e);
    fail("Test failed due to BookKeeper exception");
  }
catch (  InterruptedException e) {
    LOG.error("Test failed",e);
    fail("Test failed due to interruption");
  }
}

</code></pre>

<br>
<pre class="type-2 type-11 type-8 type-3 type-4 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions in iterations
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testReadWriteSyncSingleClient() throws IOException {
  try {
    lh=bkc.createLedger(digestType,ledgerPassword);
    ledgerId=lh.getId();
    LOG.info("Ledger ID: " + lh.getId());
    for (int i=0; i < numEntriesToWrite; i++) {
      ByteBuffer entry=ByteBuffer.allocate(4);
      entry.putInt(rng.nextInt(maxInt));
      entry.position(0);
      entries.add(entry.array());
      lh.addEntry(entry.array());
    }
    lh.close();
    lh=bkc.openLedger(ledgerId,digestType,ledgerPassword);
    LOG.debug("Number of entries written: " + lh.getLastAddConfirmed());
    assertTrue("Verifying number of entries written",lh.getLastAddConfirmed() == (numEntriesToWrite - 1));
    Enumeration<LedgerEntry> ls=lh.readEntries(0,numEntriesToWrite - 1);
    int i=0;
    while (ls.hasMoreElements()) {
      ByteBuffer origbb=ByteBuffer.wrap(entries.get(i++));
      Integer origEntry=origbb.getInt();
      ByteBuffer result=ByteBuffer.wrap(ls.nextElement().getEntry());
      LOG.debug("Length of result: " + result.capacity());
      LOG.debug("Original entry: " + origEntry);
      Integer retrEntry=result.getInt();
      LOG.debug("Retrieved entry: " + retrEntry);
      assertTrue("Checking entry " + i + " for equality",origEntry.equals(retrEntry));
    }
    lh.close();
  }
 catch (  BKException e) {
    LOG.error("Test failed",e);
    fail("Test failed due to BookKeeper exception");
  }
catch (  InterruptedException e) {
    LOG.error("Test failed",e);
    fail("Test failed due to interruption");
  }
}

</code></pre>

<br>
<pre class="type-2 type-8 type-3 type-4 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testReadWriteAsyncLength() throws IOException {
  SyncObj sync=new SyncObj();
  try {
    lh=bkc.createLedger(digestType,ledgerPassword);
    ledgerId=lh.getId();
    LOG.info("Ledger ID: " + lh.getId());
    for (int i=0; i < numEntriesToWrite; i++) {
      ByteBuffer entry=ByteBuffer.allocate(4);
      entry.putInt(rng.nextInt(maxInt));
      entry.position(0);
      entries.add(entry.array());
      entriesSize.add(entry.array().length);
      lh.asyncAddEntry(entry.array(),this,sync);
    }
synchronized (sync) {
      while (sync.counter < numEntriesToWrite) {
        LOG.debug("Entries counter = " + sync.counter);
        sync.wait();
      }
      assertEquals("Error adding",BKException.Code.OK,sync.getReturnCode());
    }
    long length=numEntriesToWrite * 4;
    assertTrue("Ledger length before closing: " + lh.getLength(),lh.getLength() == length);
    LOG.debug("*** WRITE COMPLETE ***");
    lh.close();
    lh=bkc.openLedger(ledgerId,digestType,ledgerPassword);
    assertTrue("Ledger length after opening: " + lh.getLength(),lh.getLength() == length);
    lh.close();
  }
 catch (  BKException e) {
    LOG.error("Test failed",e);
    fail("Test failed due to BookKeeper exception");
  }
catch (  InterruptedException e) {
    LOG.error("Test failed",e);
    fail("Test failed due to interruption");
  }
}

</code></pre>

<br>
<pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test(timeout=60000) public void testOpenException() throws IOException, InterruptedException {
  try {
    lh=bkc.openLedger(0,digestType,ledgerPassword);
    fail("Haven't thrown exception");
  }
 catch (  BKException e) {
    LOG.warn("Successfully thrown and caught exception:",e);
  }
}

</code></pre>

<br>
<pre class="type-2 type-8 type-3 type-4 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testReadFromOpenLedger() throws Exception {
  try {
    lh=bkc.createLedger(digestType,ledgerPassword);
    ledgerId=lh.getId();
    LOG.info("Ledger ID: " + lh.getId());
    long lac=writeNEntriesLastWriteSync(lh,numEntriesToWrite);
    LedgerHandle lhOpen=bkc.openLedgerNoRecovery(ledgerId,digestType,ledgerPassword);
    long toRead=lac - 1;
    Enumeration<LedgerEntry> readEntry=lhOpen.readEntries(toRead,toRead);
    assertTrue("Enumeration of ledger entries has no element",readEntry.hasMoreElements() == true);
    LedgerEntry e=readEntry.nextElement();
    assertEquals(toRead,e.getEntryId());
    Assert.assertArrayEquals(entries.get((int)toRead),e.getEntry());
    try {
      ByteBuffer entry=ByteBuffer.allocate(4);
      entry.putInt(rng.nextInt(maxInt));
      entry.position(0);
      lhOpen.addEntry(entry.array());
      fail("Should have thrown an exception here");
    }
 catch (    BKException.BKIllegalOpException bkioe) {
    }
catch (    Exception ex) {
      LOG.error("Unexpected exception",ex);
      fail("Unexpected exception");
    }
    lhOpen.close();
    lac=writeNEntriesLastWriteSync(lh,numEntriesToWrite);
    assertEquals("Last confirmed add: ",lac,(numEntriesToWrite * 2) - 1);
    LOG.debug("*** WRITE COMPLETE ***");
    lh.close();
    lh=bkc.createLedger(digestType,ledgerPassword);
    ledgerId=lh.getId();
    writeNEntriesLastWriteSync(lh,numEntriesToWrite);
    SyncObj sync=new SyncObj();
    lh.asyncReadLastConfirmed(this,sync);
synchronized (sync) {
      while (sync.lastConfirmed == -1) {
        LOG.debug("Counter = " + sync.lastConfirmed);
        sync.wait();
      }
      assertEquals("Error reading",BKException.Code.OK,sync.getReturnCode());
    }
    assertEquals("Last confirmed add",sync.lastConfirmed,(numEntriesToWrite - 2));
    LOG.debug("*** WRITE COMPLETE ***");
    lh.close();
  }
 catch (  BKException e) {
    LOG.error("Test failed",e);
    fail("Test failed due to BookKeeper exception");
  }
catch (  InterruptedException e) {
    LOG.error("Test failed",e);
    fail("Test failed due to interruption");
  }
}

</code></pre>

<br>
<pre class="type-2 type-11 type-8 type-3 type-4 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions in iterations
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testMultiLedger() throws IOException {
  try {
    lh=bkc.createLedger(digestType,ledgerPassword);
    lh2=bkc.createLedger(digestType,ledgerPassword);
    long ledgerId=lh.getId();
    long ledgerId2=lh2.getId();
    final CountDownLatch completeLatch=new CountDownLatch(numEntriesToWrite * 2);
    final AtomicInteger rc=new AtomicInteger(BKException.Code.OK);
    LOG.info("Ledger ID 1: " + lh.getId() + ", Ledger ID 2: "+ lh2.getId());
    for (int i=0; i < numEntriesToWrite; i++) {
      lh.asyncAddEntry(new byte[0],new AddCallback(){
        public void addComplete(        int rc2,        LedgerHandle lh,        long entryId,        Object ctx){
          rc.compareAndSet(BKException.Code.OK,rc2);
          completeLatch.countDown();
        }
      }
,null);
      lh2.asyncAddEntry(new byte[0],new AddCallback(){
        public void addComplete(        int rc2,        LedgerHandle lh,        long entryId,        Object ctx){
          rc.compareAndSet(BKException.Code.OK,rc2);
          completeLatch.countDown();
        }
      }
,null);
    }
    completeLatch.await();
    if (rc.get() != BKException.Code.OK) {
      throw BKException.create(rc.get());
    }
    lh.close();
    lh2.close();
    lh=bkc.openLedger(ledgerId,digestType,ledgerPassword);
    lh2=bkc.openLedger(ledgerId2,digestType,ledgerPassword);
    LOG.debug("Number of entries written: " + lh.getLastAddConfirmed() + ", "+ lh2.getLastAddConfirmed());
    assertTrue("Verifying number of entries written lh (" + lh.getLastAddConfirmed() + ")",lh.getLastAddConfirmed() == (numEntriesToWrite - 1));
    assertTrue("Verifying number of entries written lh2 (" + lh2.getLastAddConfirmed() + ")",lh2.getLastAddConfirmed() == (numEntriesToWrite - 1));
    Enumeration<LedgerEntry> ls=lh.readEntries(0,numEntriesToWrite - 1);
    int i=0;
    while (ls.hasMoreElements()) {
      ByteBuffer result=ByteBuffer.wrap(ls.nextElement().getEntry());
      LOG.debug("Length of result: " + result.capacity());
      assertTrue("Checking if entry " + i + " has zero bytes",result.capacity() == 0);
    }
    lh.close();
    ls=lh2.readEntries(0,numEntriesToWrite - 1);
    i=0;
    while (ls.hasMoreElements()) {
      ByteBuffer result=ByteBuffer.wrap(ls.nextElement().getEntry());
      LOG.debug("Length of result: " + result.capacity());
      assertTrue("Checking if entry " + i + " has zero bytes",result.capacity() == 0);
    }
    lh2.close();
  }
 catch (  BKException e) {
    LOG.error("Test failed",e);
    fail("Test failed due to BookKeeper exception");
  }
catch (  InterruptedException e) {
    LOG.error("Test failed",e);
    fail("Test failed due to interruption");
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.bookkeeper.test.BookieZKExpireTest </h4><pre class="type-2 type-11 type-6 type-8 type-3 type-4 type-7 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions in iterations
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@SuppressWarnings("deprecation") @Test(timeout=60000) public void testBookieServerZKExpireBehaviour() throws Exception {
  BookieServer server=null;
  try {
    File f=createTempDir("bookieserver","test");
    HashSet<Thread> threadset=new HashSet<Thread>();
    int threadCount=Thread.activeCount();
    Thread threads[]=new Thread[threadCount * 2];
    threadCount=Thread.enumerate(threads);
    for (int i=0; i < threadCount; i++) {
      if (threads[i].getName().indexOf("SendThread") != -1) {
        threadset.add(threads[i]);
      }
    }
    ServerConfiguration conf=newServerConfiguration(PortManager.nextFreePort(),zkUtil.getZooKeeperConnectString(),f,new File[]{f});
    server=new BookieServer(conf);
    server.start();
    int secondsToWait=5;
    while (!server.isRunning()) {
      Thread.sleep(1000);
      if (secondsToWait-- <= 0) {
        fail("Bookie never started");
      }
    }
    Thread sendthread=null;
    threadCount=Thread.activeCount();
    threads=new Thread[threadCount * 2];
    threadCount=Thread.enumerate(threads);
    for (int i=0; i < threadCount; i++) {
      if (threads[i].getName().indexOf("SendThread") != -1 && !threadset.contains(threads[i])) {
        sendthread=threads[i];
        break;
      }
    }
    assertNotNull("Send thread not found",sendthread);
    sendthread.suspend();
    Thread.sleep(2 * conf.getZkTimeout());
    sendthread.resume();
    Thread.sleep(3000);
    assertTrue("Bookie should not shutdown on losing zk session",server.isBookieRunning());
    assertTrue("Bookie Server should not shutdown on losing zk session",server.isRunning());
  }
  finally {
    server.shutdown();
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.bookkeeper.test.ConditionalSetTest </h4><pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * Opens a ledger before the ledger writer, which triggers ledger recovery.
 * When the ledger writer tries to close the ledger, the close operation
 * should fail.
 * @throws IOException
 * @throws InterruptedException
 * @throws BKException
 * @throws KeeperException
 */
@Test(timeout=60000) public void testConditionalSet() throws IOException, InterruptedException, BKException, KeeperException {
  LedgerHandle lhWrite=bkc.createLedger(digestType,new byte[]{'a','b'});
  long ledgerId=lhWrite.getId();
  LOG.debug("Ledger ID: " + lhWrite.getId());
  for (int i=0; i < 10; i++) {
    LOG.debug("Adding entry: " + i);
    lhWrite.addEntry(entry);
  }
  LOG.debug("Instantiating new bookkeeper client.");
  LedgerHandle lhRead=bkcReader.openLedger(lhWrite.getId(),digestType,new byte[]{'a','b'});
  LOG.debug("Opened the ledger already");
  try {
    lhWrite.close();
    fail("Should have received an exception when trying to close the ledger.");
  }
 catch (  BKException e) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.bookkeeper.test.LedgerCreateDeleteTest </h4><pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test(timeout=60000) public void testCreateLedgerWithZKException() throws Exception {
  stopZKCluster();
  try {
    bkc.createLedger(1,1,DigestType.CRC32,"bk is cool".getBytes());
    fail("Should be able to throw ZKException");
  }
 catch (  BKException.ZKException zke) {
  }
}

</code></pre>

<br>
<pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test(timeout=60000) public void testCreateLedgerWithBKNotEnoughBookiesException() throws Exception {
  try {
    bkc.createLedger(2,2,DigestType.CRC32,"bk is cool".getBytes());
    fail("Should be able to throw BKNotEnoughBookiesException");
  }
 catch (  BKException.BKNotEnoughBookiesException bkn) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.bookkeeper.test.ReadOnlyBookieTest </h4><pre class="type-2 type-11 type-8 type-3 type-4 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions in iterations
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Check readonly bookie
 */
@Test(timeout=60000) public void testBookieShouldServeAsReadOnly() throws Exception {
  killBookie(0);
  baseConf.setReadOnlyModeEnabled(true);
  startNewBookie();
  LedgerHandle ledger=bkc.createLedger(2,2,DigestType.MAC,"".getBytes());
  File[] ledgerDirs=bsConfs.get(1).getLedgerDirs();
  assertEquals("Only one ledger dir should be present",1,ledgerDirs.length);
  Bookie bookie=bs.get(1).getBookie();
  LedgerDirsManager ledgerDirsManager=bookie.getLedgerDirsManager();
  for (int i=0; i < 10; i++) {
    ledger.addEntry("data".getBytes());
  }
  ledgerDirsManager.addToFilledDirs(new File(ledgerDirs[0],"current"));
  try {
    ledger.addEntry("data".getBytes());
    fail("Should fail to add entry since there isn't enough bookies alive.");
  }
 catch (  BKException.BKNotEnoughBookiesException e) {
  }
  assertTrue("Bookie should be running and converted to readonly mode",bookie.isRunning() && bookie.isReadOnly());
  killBookie(0);
  Enumeration<LedgerEntry> readEntries=ledger.readEntries(0,9);
  while (readEntries.hasMoreElements()) {
    LedgerEntry entry=readEntries.nextElement();
    assertEquals("Entry should contain correct data","data",new String(entry.getEntry()));
  }
}

</code></pre>

<br>
<pre class="type-2 type-11 type-8 type-3 type-4 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions in iterations
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testBookieShouldTurnWritableFromReadOnly() throws Exception {
  killBookie(0);
  baseConf.setReadOnlyModeEnabled(true);
  startNewBookie();
  LedgerHandle ledger=bkc.createLedger(2,2,DigestType.MAC,"".getBytes());
  File[] ledgerDirs=bsConfs.get(1).getLedgerDirs();
  assertEquals("Only one ledger dir should be present",1,ledgerDirs.length);
  Bookie bookie=bs.get(1).getBookie();
  LedgerDirsManager ledgerDirsManager=bookie.getLedgerDirsManager();
  for (int i=0; i < 10; i++) {
    ledger.addEntry("data".getBytes());
  }
  File testDir=new File(ledgerDirs[0],"current");
  ledgerDirsManager.addToFilledDirs(testDir);
  try {
    ledger.addEntry("data".getBytes());
    fail("Should fail to add entry since there isn't enough bookies alive.");
  }
 catch (  BKException.BKNotEnoughBookiesException e) {
  }
  LOG.info("bookie is running {}, readonly {}.",bookie.isRunning(),bookie.isReadOnly());
  assertTrue("Bookie should be running and converted to readonly mode",bookie.isRunning() && bookie.isReadOnly());
  bkc.readBookiesBlocking();
  try {
    bkc.createLedger(2,2,DigestType.MAC,"".getBytes());
    fail("Should fail to create a ledger since there isn't enough bookies alive.");
  }
 catch (  BKException.BKNotEnoughBookiesException bke) {
  }
  ledgerDirsManager.addToWritableDirs(testDir,true);
  LOG.info("bookie is running {}, readonly {}.",bookie.isRunning(),bookie.isReadOnly());
  assertTrue("Bookie should be running and converted back to writable mode",bookie.isRunning() && !bookie.isReadOnly());
  bkc.readBookiesBlocking();
  LedgerHandle newLedger=bkc.createLedger(2,2,DigestType.MAC,"".getBytes());
  for (int i=0; i < 10; i++) {
    newLedger.addEntry("data".getBytes());
  }
  Enumeration<LedgerEntry> readEntries=newLedger.readEntries(0,9);
  while (readEntries.hasMoreElements()) {
    LedgerEntry entry=readEntries.nextElement();
    assertEquals("Entry should contain correct data","data",new String(entry.getEntry()));
  }
}

</code></pre>

<br>
<pre class="type-8 type-3 type-4 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * check readOnlyModeEnabled=false
 */
@Test(timeout=60000) public void testBookieShutdownIfReadOnlyModeNotEnabled() throws Exception {
  File[] ledgerDirs=bsConfs.get(1).getLedgerDirs();
  assertEquals("Only one ledger dir should be present",1,ledgerDirs.length);
  Bookie bookie=bs.get(1).getBookie();
  LedgerHandle ledger=bkc.createLedger(2,2,DigestType.MAC,"".getBytes());
  LedgerDirsManager ledgerDirsManager=bookie.getLedgerDirsManager();
  for (int i=0; i < 10; i++) {
    ledger.addEntry("data".getBytes());
  }
  ledgerDirsManager.addToFilledDirs(new File(ledgerDirs[0],"current"));
  try {
    ledger.addEntry("data".getBytes());
    fail("Should fail to add entry since there isn't enough bookies alive.");
  }
 catch (  BKException.BKNotEnoughBookiesException e) {
  }
  for (int i=0; i < 10 && bookie.isAlive(); i++) {
    Thread.sleep(1000);
  }
  assertFalse("Bookie should shutdown if readOnlyMode not enabled",bookie.isAlive());
}

</code></pre>

<br>
<pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * Test ledger creation with readonly bookies
 */
@Test(timeout=60000) public void testLedgerCreationShouldFailWithReadonlyBookie() throws Exception {
  killBookie(1);
  baseConf.setReadOnlyModeEnabled(true);
  startNewBookie();
  bs.get(1).getBookie().doTransitionToReadOnlyMode();
  try {
    bkc.readBookiesBlocking();
    bkc.createLedger(2,2,DigestType.CRC32,"".getBytes());
    fail("Must throw exception, as there is one readonly bookie");
  }
 catch (  BKException e) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.bookkeeper.test.TestBackwardCompat </h4><pre class="type-8 type-3 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test compatability between version 4.1.0 and the current version.
 * - A 4.1.0 client is not able to open a ledger created by the current
 * version due to a change in the ledger metadata format.
 * - Otherwise, they should be compatible.
 */
@Test(timeout=60000) public void testCompat410() throws Exception {
  File journalDir=createTempDir("bookie","journal");
  File ledgerDir=createTempDir("bookie","ledger");
  int port=PortManager.nextFreePort();
  Server410 s410=new Server410(journalDir,ledgerDir,port);
  s410.start();
  Ledger410 l410=Ledger410.newLedger();
  l410.write100();
  long oldLedgerId=l410.getId();
  l410.close();
  LedgerCurrent lcur=LedgerCurrent.newLedger();
  try {
    lcur.write100();
    fail("Shouldn't be able to write");
  }
 catch (  Exception e) {
  }
  lcur.close();
  s410.stop();
  ServerCurrent scur=new ServerCurrent(journalDir,ledgerDir,port,false);
  scur.start();
  l410=Ledger410.openLedger(oldLedgerId);
  assertEquals(100,l410.readAll());
  l410.close();
  l410=Ledger410.newLedger();
  l410.write100();
  l410.close();
  l410=Ledger410.newLedger();
  l410.write100();
  Ledger410 l410f=Ledger410.openLedger(l410.getId());
  try {
    l410.write100();
    fail("Shouldn't be able to write");
  }
 catch (  Exception e) {
  }
  l410f.close();
  try {
    l410.close();
    fail("Shouldn't be able to close");
  }
 catch (  Exception e) {
  }
  l410=Ledger410.newLedger();
  l410.write100();
  oldLedgerId=l410.getId();
  lcur=LedgerCurrent.openLedger(oldLedgerId);
  try {
    l410.write100();
    fail("Shouldn't be able to write");
  }
 catch (  Exception e) {
  }
  try {
    l410.close();
    fail("Shouldn't be able to close");
  }
 catch (  Exception e) {
  }
  lcur.close();
  l410=Ledger410.openLedger(oldLedgerId);
  assertEquals(100,l410.readAll());
  l410.close();
  lcur=LedgerCurrent.openLedger(oldLedgerId);
  assertEquals(100,lcur.readAll());
  lcur.close();
  lcur=LedgerCurrent.openLedger(oldLedgerId);
  assertEquals(100,lcur.readAll());
  lcur.close();
  lcur=LedgerCurrent.newLedger();
  lcur.write100();
  long fenceLedgerId=lcur.getId();
  try {
    l410=Ledger410.openLedger(fenceLedgerId);
    fail("Shouldn't be able to open ledger");
  }
 catch (  Exception e) {
  }
  lcur.write100();
  lcur.close();
  scur.stop();
}

</code></pre>

<br>
<pre class="type-8 type-3 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test compatability between version 4.0.0 and the current version.
 * Incompatabilities are:
 * - Current client will not be able to talk to 4.0.0 server.
 * - 4.0.0 client will not be able to fence ledgers on current server.
 * - Current server won't start with 4.0.0 server directories without upgrade.
 */
@Test(timeout=60000) public void testCompat400() throws Exception {
  File journalDir=createTempDir("bookie","journal");
  File ledgerDir=createTempDir("bookie","ledger");
  int port=PortManager.nextFreePort();
  Server400 s400=new Server400(journalDir,ledgerDir,port);
  s400.start();
  Ledger400 l400=Ledger400.newLedger();
  l400.write100();
  long oldLedgerId=l400.getId();
  l400.close();
  LedgerCurrent lcur=LedgerCurrent.newLedger();
  try {
    lcur.write100();
    fail("Current shouldn't be able to write to 4.0.0 server");
  }
 catch (  Exception e) {
  }
  lcur.close();
  s400.stop();
  ServerCurrent scur=new ServerCurrent(journalDir,ledgerDir,port,false);
  try {
    scur.start();
    fail("Shouldn't be able to start without directory upgrade");
  }
 catch (  Exception e) {
  }
  FileSystemUpgrade.upgrade(scur.getConf());
  scur.start();
  l400=Ledger400.openLedger(oldLedgerId);
  assertEquals(100,l400.readAll());
  l400.close();
  l400=Ledger400.newLedger();
  l400.write100();
  l400.close();
  lcur=LedgerCurrent.openLedger(oldLedgerId);
  assertEquals(100,lcur.readAll());
  lcur.close();
  lcur=LedgerCurrent.openLedger(oldLedgerId);
  assertEquals(100,lcur.readAll());
  lcur.close();
  lcur=LedgerCurrent.newLedger();
  lcur.write100();
  long fenceLedgerId=lcur.getId();
  try {
    l400=Ledger400.openLedger(fenceLedgerId);
    fail("Shouldn't be able to open ledger");
  }
 catch (  Exception e) {
  }
  lcur.write100();
  lcur.close();
  lcur=LedgerCurrent.openLedger(fenceLedgerId);
  assertEquals(200,lcur.readAll());
  lcur.close();
  scur.stop();
}

</code></pre>

<br>
<pre class="type-8 type-3 type-4 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testOldCookieAccessingNewCluster() throws Exception {
  File journalDir=createTempDir("bookie","journal");
  File ledgerDir=createTempDir("bookie","ledger");
  int port=PortManager.nextFreePort();
  Server410 s410=new Server410(journalDir,ledgerDir,port);
  s410.start();
  Ledger410 l410=Ledger410.newLedger();
  l410.write100();
  l410.getId();
  l410.close();
  s410.stop();
  ServerCurrent currentServer=new ServerCurrent(journalDir,ledgerDir,port,false);
  BookKeeperAdmin.format(new ClientConfiguration(currentServer.conf),false,true);
  try {
    currentServer.start();
    fail("Bookie should not start with old cookie");
  }
 catch (  BookieException e) {
    assertTrue("Old Cookie should not be able to access",e.getMessage().contains("instanceId"));
  }
 finally {
    currentServer.stop();
  }
  assertTrue("Format should be success",Bookie.format(currentServer.conf,false,true));
  try {
    currentServer=null;
    currentServer=new ServerCurrent(journalDir,ledgerDir,port,false);
    currentServer.start();
  }
  finally {
    if (null != currentServer) {
      currentServer.stop();
    }
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.bookkeeper.zookeeper.TestZooKeeperClient </h4><pre class="type-2 type-8 type-3 type-4 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=12000) public void testReconnectAfterExipred() throws Exception {
  final CountDownLatch expireLatch=new CountDownLatch(1);
  Watcher testWatcher=new Watcher(){
    @Override public void process(    WatchedEvent event){
      if (event.getType() == EventType.None && event.getState() == KeeperState.Expired) {
        expireLatch.countDown();
      }
    }
  }
;
  final int timeout=2000;
  ZooKeeperWatcherBase watcherManager=new ZooKeeperWatcherBase(timeout).addChildWatcher(testWatcher);
  List<Watcher> watchers=new ArrayList<Watcher>(1);
  watchers.add(testWatcher);
  ZooKeeperClient client=new ShutdownZkServerClient(zkUtil.getZooKeeperConnectString(),timeout,watcherManager,new BoundExponentialBackoffRetryPolicy(timeout,timeout,0));
  client.waitForConnection();
  Assert.assertTrue("Client failed to connect an alive ZooKeeper.",client.getState().isConnected());
  logger.info("Expire zookeeper client");
  expireZooKeeperSession(client,timeout);
  Assert.assertTrue("Client registered watcher should receive expire event.",expireLatch.await(2 * timeout,TimeUnit.MILLISECONDS));
  Assert.assertFalse("Client doesn't receive expire event from ZooKeeper.",client.getState().isConnected());
  try {
    client.exists("/tmp",false);
    Assert.fail("Should fail due to connection loss.");
  }
 catch (  KeeperException.ConnectionLossException cle) {
  }
catch (  KeeperException.SessionExpiredException cle) {
  }
  zkUtil.restartServer();
  Thread.sleep(2 * timeout);
  Assert.assertTrue("Client failed to connect zookeeper even it was back.",client.getState().isConnected());
  try {
    client.exists("/tmp",false);
  }
 catch (  KeeperException.ConnectionLossException cle) {
    Assert.fail("Should not throw ConnectionLossException");
  }
catch (  KeeperException.SessionExpiredException cle) {
    Assert.fail("Should not throw SessionExpiredException");
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hedwig.client.TestPubSubClient </h4><pre class="type-8 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testSyncSubscribeWithListener() throws Exception {
  ByteString topic=ByteString.copyFromUtf8("mySyncSubscribeWithListener");
  ByteString subscriberId=ByteString.copyFromUtf8("mysub");
  subscriber.addSubscriptionListener(new TestSubscriptionListener());
  try {
    SubscriptionOptions options=SubscriptionOptions.newBuilder().setCreateOrAttach(CreateOrAttach.CREATE_OR_ATTACH).setEnableResubscribe(false).build();
    subscriber.subscribe(topic,subscriberId,options);
  }
 catch (  PubSubException.ServiceDownException e) {
    fail("Should not reach here!");
  }
  subscriber.startDelivery(topic,subscriberId,new TestMessageHandler());
  tearDownHubServer();
  assertEquals(SubscriptionEvent.TOPIC_MOVED,eventQueue.take());
}

</code></pre>

<br>
<pre class="type-8 type-4 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testSyncSubscribeWithListenerWhenReleasingTopic() throws Exception {
  client.close();
  tearDownHubServer();
  startHubServer(new RetentionServerConfiguration());
  client=new HedwigClient(new ClientConfiguration(){
    @Override public HedwigSocketAddress getDefaultServerHedwigSocketAddress(){
      return getDefaultHedwigAddress();
    }
    @Override public boolean isSubscriptionChannelSharingEnabled(){
      return TestPubSubClient.this.isSubscriptionChannelSharingEnabled;
    }
  }
);
  publisher=client.getPublisher();
  subscriber=client.getSubscriber();
  ByteString topic=ByteString.copyFromUtf8("mySyncSubscribeWithListenerWhenReleasingTopic");
  ByteString subscriberId=ByteString.copyFromUtf8("mysub");
  subscriber.addSubscriptionListener(new TestSubscriptionListener());
  SubscriptionOptions options=SubscriptionOptions.newBuilder().setCreateOrAttach(CreateOrAttach.CREATE_OR_ATTACH).setForceAttach(false).setEnableResubscribe(false).build();
  try {
    subscriber.subscribe(topic,subscriberId,options);
  }
 catch (  PubSubException.ServiceDownException e) {
    fail("Should not reach here!");
  }
  subscriber.startDelivery(topic,subscriberId,new TestMessageHandler());
  publisher.asyncPublish(topic,Message.newBuilder().setBody(ByteString.copyFromUtf8("Message #1")).build(),new TestCallback(),null);
  assertTrue(queue.take());
  assertTrue(consumeQueue.take());
  Thread.sleep(RETENTION_SECS_VALUE * 2);
  assertEquals(SubscriptionEvent.TOPIC_MOVED,eventQueue.take());
}

</code></pre>

<br>
<pre class="type-8 type-4 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testSyncSubscribeForceAttach() throws Exception {
  ByteString topic=ByteString.copyFromUtf8("mySyncSubscribeForceAttach");
  ByteString subscriberId=ByteString.copyFromUtf8("mysub");
  subscriber.addSubscriptionListener(new TestSubscriptionListener());
  SubscriptionOptions options=SubscriptionOptions.newBuilder().setCreateOrAttach(CreateOrAttach.CREATE_OR_ATTACH).setForceAttach(true).setEnableResubscribe(false).build();
  try {
    subscriber.subscribe(topic,subscriberId,options);
  }
 catch (  PubSubException.ServiceDownException e) {
    fail("Should not reach here!");
  }
  subscriber.startDelivery(topic,subscriberId,new TestMessageHandler());
  HedwigClient client2=new HedwigClient(new ClientConfiguration(){
    @Override public HedwigSocketAddress getDefaultServerHedwigSocketAddress(){
      return getDefaultHedwigAddress();
    }
  }
);
  Subscriber subscriber2=client2.getSubscriber();
  Publisher publisher2=client2.getPublisher();
  SynchronousQueue<SubscriptionEvent> eventQueue2=new SynchronousQueue<SubscriptionEvent>();
  subscriber2.addSubscriptionListener(new TestSubscriptionListener(eventQueue2));
  try {
    subscriber2.subscribe(topic,subscriberId,options);
  }
 catch (  PubSubException.ServiceDownException e) {
    fail("Should not reach here!");
  }
  SynchronousQueue<Boolean> consumeQueue2=new SynchronousQueue<Boolean>();
  subscriber2.startDelivery(topic,subscriberId,new TestMessageHandler(consumeQueue2));
  assertEquals(SubscriptionEvent.SUBSCRIPTION_FORCED_CLOSED,eventQueue.take());
  assertTrue(eventQueue2.isEmpty());
  publisher.asyncPublish(topic,Message.newBuilder().setBody(ByteString.copyFromUtf8("Message #1")).build(),new TestCallback(),null);
  assertTrue(queue.take());
  assertTrue(consumeQueue2.take());
  assertTrue(consumeQueue.isEmpty());
  publisher2.asyncPublish(topic,Message.newBuilder().setBody(ByteString.copyFromUtf8("Message #2")).build(),new TestCallback(),null);
  assertTrue(queue.take());
  assertTrue(consumeQueue2.take());
  assertTrue(consumeQueue.isEmpty());
  client2.close();
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hedwig.server.TestBackwardCompat </h4><pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * Test compatability between version 4.1.0 and the current version.
 * A current client running message filter would fail on 4.1.0 hub servers.
 */
@Test(timeout=60000) public void testClientMessageFilterCompat410() throws Exception {
  ByteString topic=ByteString.copyFromUtf8("TestUpdateMessageBoundCompat410");
  ByteString subid=ByteString.copyFromUtf8("mysub");
  BookKeeperCluster410 bkc410=new BookKeeperCluster410(3);
  bkc410.start();
  int port=PortManager.nextFreePort();
  int sslPort=PortManager.nextFreePort();
  Server410 s410=new Server410(zkUtil.getZooKeeperConnectString(),port,sslPort);
  s410.start();
  ClientCurrent ccur=new ClientCurrent("localhost:" + port + ":"+ sslPort);
  ccur.subscribe(topic,subid);
  ccur.closeSubscription(topic,subid);
  ccur.publishInts(topic,0,100);
  try {
    ccur.receiveNumModM(topic,subid,0,50,2);
    fail("client-side filter could not run on 4.1.0 hub server");
  }
 catch (  Exception e) {
    logger.info("Should fail to run client-side message filter on 4.1.0 hub server.",e);
    ccur.closeSubscription(topic,subid);
  }
  s410.stop();
  bkc410.stop();
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hedwig.server.filter.TestMessageFilter </h4><pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test(timeout=60000) public void testNullClientMessageFilter() throws Exception {
  ByteString topic=ByteString.copyFromUtf8("TestNullClientMessageFilter");
  ByteString subid=ByteString.copyFromUtf8("mysub");
  SubscriptionOptions opts=SubscriptionOptions.newBuilder().setCreateOrAttach(CreateOrAttach.CREATE_OR_ATTACH).build();
  subscriber.subscribe(topic,subid,opts);
  try {
    subscriber.startDeliveryWithFilter(topic,subid,null,new ModMessageFilter());
    fail("Should fail start delivery with filter using null message handler.");
  }
 catch (  NullPointerException npe) {
  }
  try {
    subscriber.startDeliveryWithFilter(topic,subid,new MessageHandler(){
      public void deliver(      ByteString topic,      ByteString subscriberId,      Message msg,      Callback<Void> callback,      Object context){
      }
    }
,null);
    fail("Should fail start delivery with filter using null message filter.");
  }
 catch (  NullPointerException npe) {
  }
}

</code></pre>

<br>
<pre class="type-8 type-4 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testInvalidServerSideMessageFilter() throws Exception {
  ByteString topic=ByteString.copyFromUtf8("TestInvalidMessageFilter");
  ByteString subid=ByteString.copyFromUtf8("mysub");
  SubscriptionOptions options=SubscriptionOptions.newBuilder().setCreateOrAttach(CreateOrAttach.CREATE_OR_ATTACH).setMessageFilter("Invalid_Message_Filter").build();
  try {
    subscriber.subscribe(topic,subid,options);
    fail("Should fail subscribe with invalid message filter");
  }
 catch (  PubSubException pse) {
    assertTrue("Should respond with INVALID_MESSAGE_FILTER",pse.getMessage().contains("INVALID_MESSAGE_FILTER"));
  }
}

</code></pre>

<br>
<pre class="type-8 type-4 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testFixInvalidServerSideMessageFilter() throws Exception {
  ByteString topic=ByteString.copyFromUtf8("TestFixMessageFilter");
  ByteString subid=ByteString.copyFromUtf8("mysub");
  SubscriptionOptions opts=SubscriptionOptions.newBuilder().setCreateOrAttach(CreateOrAttach.CREATE_OR_ATTACH).build();
  subscriber.subscribe(topic,subid,opts);
  subscriber.closeSubscription(topic,subid);
  publishNums(topic,0,100,3);
  try {
    receiveNumModM(topic,subid,"Invalid_Message_Filter",null,0,33,3,true);
    fail("Should fail subscribe with invalid message filter");
  }
 catch (  Exception pse) {
    assertTrue("Should respond with INVALID_MESSAGE_FILTER",pse.getMessage().contains("INVALID_MESSAGE_FILTER"));
  }
  receiveNumModM(topic,subid,HeaderMessageFilter.class.getName(),null,0,33,3,true);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hedwig.server.integration.TestHedwigHub </h4><pre class="type-8 type-4 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=10000) public void testStartDeliveryTwice() throws Exception {
  ByteString topic=getTopic(0);
  SubscriptionOptions opts=SubscriptionOptions.newBuilder().setCreateOrAttach(CreateOrAttach.CREATE_OR_ATTACH).build();
  subscriber.asyncSubscribe(topic,localSubscriberId,opts,new TestCallback(queue),null);
  assertTrue(queue.take());
  startDelivery(topic,localSubscriberId,new TestMessageHandler(consumeQueue));
  try {
    startDelivery(topic,localSubscriberId,new TestMessageHandler(consumeQueue));
    fail("Should not reach here!");
  }
 catch (  AlreadyStartDeliveryException e) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hedwig.server.meta.TestFactoryLayout </h4><pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test(timeout=60000) public void testCorruptedFactoryLayout() throws Exception {
  ServerConfiguration conf=new ServerConfiguration();
  StringBuilder msb=new StringBuilder();
  String factoryLayoutPath=FactoryLayout.getFactoryLayoutPath(msb,conf);
  ZkUtils.createFullPathOptimistic(zk,factoryLayoutPath,"BadLayout".getBytes(),Ids.OPEN_ACL_UNSAFE,CreateMode.PERSISTENT);
  try {
    FactoryLayout.readLayout(zk,conf);
    Assert.fail("Shouldn't reach here!");
  }
 catch (  IOException ie) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hedwig.server.meta.TestMetadataManagerFactory </h4><pre class="type-2 type-8 type-3 type-4 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test bad server configuration
 */
@Test(timeout=60000) public void testBadConf() throws Exception {
  TestServerConfiguration conf=new TestServerConfiguration();
  String root0="/goodconf";
  conf.setZkPrefix(root0);
  MetadataManagerFactory m=MetadataManagerFactory.newMetadataManagerFactory(conf,zk);
  Assert.assertTrue("MetadataManagerFactory is unexpected type",(m instanceof ZkMetadataManagerFactory));
  conf.setMetadataManagerFactoryName(DummyMetadataManagerFactory.class.getName());
  try {
    MetadataManagerFactory.newMetadataManagerFactory(conf,zk);
    Assert.fail("Shouldn't reach here");
  }
 catch (  Exception e) {
    Assert.assertTrue("Invalid exception",e.getMessage().contains("does not match existing factory"));
  }
  String root1="/badconf1";
  conf.setZkPrefix(root1);
  conf.setMetadataManagerFactoryName("DoesNotExist");
  try {
    MetadataManagerFactory.newMetadataManagerFactory(conf,zk);
    Assert.fail("Shouldn't reach here");
  }
 catch (  Exception e) {
    Assert.assertTrue("Invalid exception",e.getMessage().contains("Failed to get metadata manager factory class from configuration"));
  }
}

</code></pre>

<br>
<pre class="type-8 type-4 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test bad zk configuration
 */
@Test(timeout=60000) public void testBadZkContents() throws Exception {
  TestServerConfiguration conf=new TestServerConfiguration();
  String root0="/badzk0";
  conf.setZkPrefix(root0);
  writeFactoryLayout(conf,"DoesNotExist",0xdeadbeef);
  try {
    MetadataManagerFactory.newMetadataManagerFactory(conf,zk);
    Assert.fail("Shouldn't reach here");
  }
 catch (  Exception e) {
    Assert.assertTrue("Invalid exception",e.getMessage().contains("No class found to instantiate metadata manager factory"));
  }
  String root1="/badzk1";
  conf.setZkPrefix(root1);
  writeFactoryLayout(conf,ZkMetadataManagerFactory.class.getName(),0xdeadbeef);
  try {
    MetadataManagerFactory.newMetadataManagerFactory(conf,zk);
    Assert.fail("Shouldn't reach here");
  }
 catch (  Exception e) {
    Assert.assertTrue("Invalid exception",e.getMessage().contains("Incompatible ZkMetadataManagerFactory version"));
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hedwig.server.persistence.TestBookKeeperPersistenceManager </h4><pre class="type-6 type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test(timeout=60000) public void testScanMessagesOnTwoLedgers() throws Exception {
  stopCluster();
  startCluster(readDelay);
  ByteString topic=ByteString.copyFromUtf8("TestScanMessagesOnTwoLedgers");
  List<Message> msgs=new ArrayList<Message>();
  acquireTopic(topic);
  msgs.addAll(publishMessages(topic,1));
  releaseTopic(topic);
  acquireTopic(topic);
  msgs.addAll(publishMessages(topic,3));
  LinkedBlockingQueue<Boolean> statusQueue=new LinkedBlockingQueue<Boolean>();
  RangeScanRequest nextScan=new RangeScanRequest(topic,3,2,Long.MAX_VALUE,new RangeScanVerifier(subMessages(msgs,2,3),null),statusQueue);
  manager.scanMessages(new RangeScanRequest(topic,1,2,Long.MAX_VALUE,new RangeScanVerifier(subMessages(msgs,0,1),nextScan),statusQueue));
  Boolean b=statusQueue.poll(10 * readDelay,TimeUnit.MILLISECONDS);
  if (b == null) {
    fail("One scan request doesn't finish");
  }
  b=statusQueue.poll(10 * readDelay,TimeUnit.MILLISECONDS);
  if (b == null) {
    fail("One scan request doesn't finish");
  }
}

</code></pre>

<br>
<pre class="type-2 type-6 type-8 type-4 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testReadWhenTopicChangeLedger() throws Exception {
  final ByteString topic=ByteString.copyFromUtf8("testReadWhenTopicChangeLedger");
  LinkedList<Message> msgs=new LinkedList<Message>();
  acquireTopic(topic);
  msgs.addAll(publishMessages(topic,maxEntriesPerLedger));
  Thread.sleep(2000);
  LinkedBlockingQueue<Boolean> statusQueue=new LinkedBlockingQueue<Boolean>();
  RangeScanRequest scan=new RangeScanRequest(topic,maxEntriesPerLedger + 1,1,Long.MAX_VALUE,new RangeScanVerifier(msgs,null),statusQueue);
  manager.scanMessages(scan);
  Boolean b=statusQueue.poll(10 * readDelay,TimeUnit.MILLISECONDS);
  if (b == null) {
    fail("Scan request timeout");
  }
  assertFalse("Expect none message is scanned on the new created ledger",b);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hedwig.server.topics.TestHubInfo </h4><pre class="type-2 type-8 type-3 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testParseHubInfo() throws Exception {
  HedwigSocketAddress addr=new HedwigSocketAddress("localhost",9086,9087);
  HubInfo hubInfo1=new HubInfo(addr,9999);
  String strHubInfo1=hubInfo1.toString();
  HubInfo parsedHubInfo1=HubInfo.parse(strHubInfo1);
  Assert.assertEquals("Hub infos should be same",hubInfo1,parsedHubInfo1);
  HubInfo hubInfo2=new HubInfo(addr,0);
  HubInfo parsedHubInfo2=HubInfo.parse("localhost:9086:9087");
  Assert.assertEquals("Hub infos w/o zxid should be same",hubInfo2,parsedHubInfo2);
  try {
    HubInfo.parse("");
    Assert.fail("Should throw InvalidHubInfoException parsing empty string.");
  }
 catch (  HubInfo.InvalidHubInfoException ihie) {
  }
  try {
    HubInfo.parse("localhost,a,b,c");
    Assert.fail("Should throw InvalidHubInfoException parsing corrupted hostname.");
  }
 catch (  HubInfo.InvalidHubInfoException ihie) {
  }
  try {
    HubInfo.parse("hostname: localhost:9086:9087");
    Assert.fail("Should throw InvalidHubInfoException parsing corrupted string.");
  }
 catch (  HubInfo.InvalidHubInfoException ihie) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hedwig.server.topics.TestHubLoad </h4><pre class="type-2 type-8 type-3 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testParseHubLoad() throws Exception {
  HubLoad hubLoad1=new HubLoad(9999);
  String strHubLoad1=hubLoad1.toString();
  HubLoad parsedHubLoad1=HubLoad.parse(strHubLoad1);
  Assert.assertEquals("Hub load data should be same",hubLoad1,parsedHubLoad1);
  final int numTopics=9998;
  HubLoad hubLoad2=new HubLoad(numTopics);
  HubLoad parsedHubLoad2=HubLoad.parse(numTopics + "");
  Assert.assertEquals("Hub load data not protobuf encoded should be same",hubLoad2,parsedHubLoad2);
  try {
    HubLoad.parse("");
    Assert.fail("Should throw InvalidHubLoadException parsing empty string.");
  }
 catch (  HubLoad.InvalidHubLoadException ihie) {
  }
  try {
    HubLoad.parse("9998_x");
    Assert.fail("Should throw InvalidHubLoadException parsing corrupted hub load data.");
  }
 catch (  HubLoad.InvalidHubLoadException ihie) {
  }
  try {
    HubLoad.parse("hostname: 9998_x");
    Assert.fail("Should throw InvalidHubLoadException parsing corrupted hub load data.");
  }
 catch (  HubLoad.InvalidHubLoadException ihie) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hedwig.server.topics.TestMMTopicManager </h4><pre class="type-11 type-6 type-8 type-3 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testGetOwnerMulti() throws Exception {
  ServerConfiguration conf1=new CustomServerConfiguration(conf.getServerPort() + 1), conf2=new CustomServerConfiguration(conf.getServerPort() + 2);
  MMTopicManager tm1=new MMTopicManager(conf1,zk,metadataManagerFactory,scheduler), tm2=new MMTopicManager(conf2,zk,metadataManagerFactory,scheduler);
  tm.getOwner(topic,false,addrCbq,null);
  HedwigSocketAddress owner=check(addrCbq.take());
  for (int i=0; i < 100; ++i) {
    tm.getOwner(topic,false,addrCbq,null);
    Assert.assertEquals(owner,check(addrCbq.take()));
    tm1.getOwner(topic,false,addrCbq,null);
    Assert.assertEquals(owner,check(addrCbq.take()));
    tm2.getOwner(topic,false,addrCbq,null);
    Assert.assertEquals(owner,check(addrCbq.take()));
  }
  for (int i=0; i < 100; ++i) {
    if (!owner.equals(me))     break;
    tm.getOwner(mkTopic(i),false,addrCbq,null);
    owner=check(addrCbq.take());
    if (i == 99)     Assert.fail("Never chose another owner");
  }
  tm1.stop();
  tm2.stop();
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hedwig.server.topics.TestZkTopicManager </h4><pre class="type-11 type-6 type-8 type-3 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testGetOwnerMulti() throws Exception {
  ServerConfiguration cfg1=new CustomServerConfiguration(cfg.getServerPort() + 1), cfg2=new CustomServerConfiguration(cfg.getServerPort() + 2);
  ZkTopicManager tm1=new ZkTopicManager(zk,cfg1,scheduler), tm2=new ZkTopicManager(zk,cfg2,scheduler);
  tm.getOwner(topic,false,addrCbq,null);
  HedwigSocketAddress owner=check(addrCbq.take());
  if (owner.getPort() == cfg1.getServerPort())   tm1.getOwner(topic,true,addrCbq,null);
 else   if (owner.getPort() == cfg2.getServerPort())   tm2.getOwner(topic,true,addrCbq,null);
  if (owner.getPort() != cfg.getServerPort())   Assert.assertEquals(owner,check(addrCbq.take()));
  for (int i=0; i < 100; ++i) {
    tm.getOwner(topic,false,addrCbq,null);
    Assert.assertEquals(owner,check(addrCbq.take()));
    tm1.getOwner(topic,false,addrCbq,null);
    Assert.assertEquals(owner,check(addrCbq.take()));
    tm2.getOwner(topic,false,addrCbq,null);
    Assert.assertEquals(owner,check(addrCbq.take()));
  }
  for (int i=0; i < 100; ++i) {
    if (!owner.equals(me))     break;
    tm.getOwner(mkTopic(i),false,addrCbq,null);
    owner=check(addrCbq.take());
    if (i == 99)     Assert.fail("Never chose another owner");
  }
  for (int i=0; i < 100; ++i) {
    tm.getOwner(mkTopic(100),true,addrCbq,null);
    Assert.assertEquals(me,check(addrCbq.take()));
  }
  tm1.stop();
  tm2.stop();
}

</code></pre>

<br>
<script>$(document).ready(function() {
  $('pre code').each(function(i, block) {
    hljs.highlightBlock(block);
  });
});</script>
