<h3><span class=" glyphicon glyphicon-tag"/>&nbspBooleanVerifier</h3><kbd>Verifies boolean conditions</kbd><br><br><br><h4 style="margin:0px">Class: org.apache.bookkeeper.benchmark.TestBenchmark </h4><pre class="type-2 type-3 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
"></span><br>
@Test(timeout=60000) public void testReadThroughputLatency() throws Exception {
  final AtomicBoolean threwException=new AtomicBoolean(false);
  Thread t=new Thread(){
    public void run(){
      try {
        BenchReadThroughputLatency.main(new String[]{"--zookeeper",zkUtil.getZooKeeperConnectString(),"--listen","10"});
      }
 catch (      Throwable t) {
        LOG.error("Error reading",t);
        threwException.set(true);
      }
    }
  }
;
  t.start();
  Thread.sleep(10000);
  byte data[]=new byte[1024];
  Arrays.fill(data,(byte)'x');
  long lastLedgerId=0;
  Assert.assertTrue("Thread should be running",t.isAlive());
  for (int i=0; i < 10; i++) {
    BookKeeper bk=new BookKeeper(zkUtil.getZooKeeperConnectString());
    LedgerHandle lh=bk.createLedger(BookKeeper.DigestType.CRC32,"benchPasswd".getBytes());
    lastLedgerId=lh.getId();
    try {
      for (int j=0; j < 100; j++) {
        lh.addEntry(data);
      }
    }
  finally {
      lh.close();
      bk.close();
    }
  }
  for (int i=0; i < 60; i++) {
    if (!t.isAlive()) {
      break;
    }
    Thread.sleep(1000);
  }
  Assert.assertFalse("Thread should be finished",t.isAlive());
  BenchReadThroughputLatency.main(new String[]{"--zookeeper",zkUtil.getZooKeeperConnectString(),"--ledger",String.valueOf(lastLedgerId)});
  final long nextLedgerId=lastLedgerId + 1;
  t=new Thread(){
    public void run(){
      try {
        BenchReadThroughputLatency.main(new String[]{"--zookeeper",zkUtil.getZooKeeperConnectString(),"--ledger",String.valueOf(nextLedgerId)});
      }
 catch (      Throwable t) {
        LOG.error("Error reading",t);
        threwException.set(true);
      }
    }
  }
;
  t.start();
  Assert.assertTrue("Thread should be running",t.isAlive());
  BookKeeper bk=new BookKeeper(zkUtil.getZooKeeperConnectString());
  LedgerHandle lh=bk.createLedger(BookKeeper.DigestType.CRC32,"benchPasswd".getBytes());
  try {
    for (int j=0; j < 100; j++) {
      lh.addEntry(data);
    }
  }
  finally {
    lh.close();
    bk.close();
  }
  for (int i=0; i < 60; i++) {
    if (!t.isAlive()) {
      break;
    }
    Thread.sleep(1000);
  }
  Assert.assertFalse("Thread should be finished",t.isAlive());
  Assert.assertFalse("A thread has thrown an exception, check logs",threwException.get());
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.bookkeeper.bookie.BookieInitializationTest </h4><pre class="type-2 type-6 type-3 type-4 type-7 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions inside branch conditions
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Verify the bookie reg. Restarting bookie server will wait for the session
 * timeout when previous reg node exists in zk. On zNode delete event,
 * should continue startup
 */
@Test(timeout=20000) public void testBookieRegistration() throws Exception {
  File tmpDir=createTempDir("bookie","test");
  final ServerConfiguration conf=TestBKConfiguration.newServerConfiguration().setZkServers(null).setJournalDirName(tmpDir.getPath()).setLedgerDirNames(new String[]{tmpDir.getPath()});
  final String bkRegPath=conf.getZkAvailableBookiesPath() + "/" + InetAddress.getLocalHost().getHostAddress()+ ":"+ conf.getBookiePort();
  MockBookie b=new MockBookie(conf);
  b.zk=zkc;
  b.testRegisterBookie(conf);
  Stat bkRegNode1=zkc.exists(bkRegPath,false);
  Assert.assertNotNull("Bookie registration node doesn't exists!",bkRegNode1);
  createNewZKClient();
  b.zk=newzk;
  new Thread(){
    @Override public void run(){
      try {
        Thread.sleep(conf.getZkTimeout() / 3);
        zkc.delete(bkRegPath,-1);
      }
 catch (      Exception e) {
        LOG.error("Failed to delete the znode :" + bkRegPath,e);
      }
    }
  }
.start();
  try {
    b.testRegisterBookie(conf);
  }
 catch (  IOException e) {
    Throwable t=e.getCause();
    if (t instanceof KeeperException) {
      KeeperException ke=(KeeperException)t;
      Assert.assertTrue("ErrorCode:" + ke.code() + ", Registration node exists",ke.code() != KeeperException.Code.NODEEXISTS);
    }
    throw e;
  }
  Stat bkRegNode2=newzk.exists(bkRegPath,false);
  Assert.assertNotNull("Bookie registration has been failed",bkRegNode2);
  Assert.assertTrue("Bookie is referring to old registration znode:" + bkRegNode1 + ", New ZNode:"+ bkRegNode2,bkRegNode1.getEphemeralOwner() != bkRegNode2.getEphemeralOwner());
}

</code></pre>

<br>
<pre class="type-8 type-3 type-4 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Verify duplicate bookie server startup. Should throw
 * java.net.BindException if already BK server is running
 */
@Test(timeout=20000) public void testDuplicateBookieServerStartup() throws Exception {
  File tmpDir=createTempDir("bookie","test");
  ServerConfiguration conf=TestBKConfiguration.newServerConfiguration();
  int port=12555;
  conf.setZkServers(null).setBookiePort(port).setJournalDirName(tmpDir.getPath()).setLedgerDirNames(new String[]{tmpDir.getPath()});
  BookieServer bs1=new BookieServer(conf);
  bs1.start();
  try {
    BookieServer bs2=new BookieServer(conf);
    bs2.start();
    fail("Should throw BindException, as the bk server is already running!");
  }
 catch (  ChannelException ce) {
    Assert.assertTrue("Should be caused by a bind exception",ce.getCause() instanceof BindException);
    Assert.assertTrue("BKServer allowed duplicate startups!",ce.getCause().getMessage().contains("Address already in use"));
  }
}

</code></pre>

<br>
<pre class="type-2 type-6 type-8 type-3 type-4 type-7 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Verify the bookie registration, it should throw
 * KeeperException.NodeExistsException if the znode still exists even after
 * the zk session timeout.
 */
@Test(timeout=30000) public void testRegNodeExistsAfterSessionTimeOut() throws Exception {
  File tmpDir=createTempDir("bookie","test");
  ServerConfiguration conf=TestBKConfiguration.newServerConfiguration().setZkServers(null).setJournalDirName(tmpDir.getPath()).setLedgerDirNames(new String[]{tmpDir.getPath()});
  String bkRegPath=conf.getZkAvailableBookiesPath() + "/" + InetAddress.getLocalHost().getHostAddress()+ ":"+ conf.getBookiePort();
  MockBookie b=new MockBookie(conf);
  b.zk=zkc;
  b.testRegisterBookie(conf);
  Stat bkRegNode1=zkc.exists(bkRegPath,false);
  Assert.assertNotNull("Bookie registration node doesn't exists!",bkRegNode1);
  createNewZKClient();
  b.zk=newzk;
  try {
    b.testRegisterBookie(conf);
    fail("Should throw NodeExistsException as the znode is not getting expired");
  }
 catch (  IOException e) {
    Throwable t=e.getCause();
    if (t instanceof KeeperException) {
      KeeperException ke=(KeeperException)t;
      Assert.assertTrue("ErrorCode:" + ke.code() + ", Registration node doesn't exists",ke.code() == KeeperException.Code.NODEEXISTS);
      Stat bkRegNode2=newzk.exists(bkRegPath,false);
      Assert.assertNotNull("Bookie registration has been failed",bkRegNode2);
      Assert.assertTrue("Bookie wrongly registered. Old registration znode:" + bkRegNode1 + ", New znode:"+ bkRegNode2,bkRegNode1.getEphemeralOwner() == bkRegNode2.getEphemeralOwner());
      return;
    }
    throw e;
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.bookkeeper.bookie.BookieJournalTest </h4><pre class="type-2 type-8 type-3 type-4 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test that if the bookie crashes in the middle of writing
 * the actual entry it can recover.
 * In this case the entry will be available, but it will corrupt.
 * This is ok, as the client will disregard the entry after looking
 * at its checksum.
 */
@Test(timeout=60000) public void testTruncatedInEntryJournal() throws Exception {
  File journalDir=createTempDir("bookie","journal");
  Bookie.checkDirectoryStructure(Bookie.getCurrentDirectory(journalDir));
  File ledgerDir=createTempDir("bookie","ledger");
  Bookie.checkDirectoryStructure(Bookie.getCurrentDirectory(ledgerDir));
  JournalChannel jc=writeV2Journal(Bookie.getCurrentDirectory(journalDir),100);
  ByteBuffer zeros=ByteBuffer.allocate(2048);
  jc.fc.position(jc.getBufferedChannel().position() - 0x300);
  jc.fc.write(zeros);
  jc.fc.force(false);
  writeIndexFileForLedger(Bookie.getCurrentDirectory(ledgerDir),1,"testPasswd".getBytes());
  ServerConfiguration conf=TestBKConfiguration.newServerConfiguration().setZkServers(null).setJournalDirName(journalDir.getPath()).setLedgerDirNames(new String[]{ledgerDir.getPath()});
  Bookie b=new Bookie(conf);
  b.readJournal();
  b.readEntry(1,99);
  ByteBuffer buf=b.readEntry(1,100);
  assertEquals("Ledger Id is wrong",buf.getLong(),1);
  assertEquals("Entry Id is wrong",buf.getLong(),100);
  assertEquals("Last confirmed is wrong",buf.getLong(),99);
  assertEquals("Length is wrong",buf.getLong(),100 * 1024);
  buf.getLong();
  boolean allX=true;
  for (int i=0; i < 1024; i++) {
    byte x=buf.get();
    allX=allX && x == (byte)'X';
  }
  assertFalse("Some of buffer should have been zeroed",allX);
  try {
    b.readEntry(1,101);
    fail("Shouldn't have found entry 101");
  }
 catch (  Bookie.NoEntryException e) {
  }
}

</code></pre>

<br>
<pre class="type-2 type-8 type-3 type-4 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testV5Journal() throws Exception {
  File journalDir=createTempDir("bookie","journal");
  Bookie.checkDirectoryStructure(Bookie.getCurrentDirectory(journalDir));
  File ledgerDir=createTempDir("bookie","ledger");
  Bookie.checkDirectoryStructure(Bookie.getCurrentDirectory(ledgerDir));
  writeV5Journal(Bookie.getCurrentDirectory(journalDir),2 * JournalChannel.SECTOR_SIZE,"testV5Journal".getBytes());
  ServerConfiguration conf=TestBKConfiguration.newServerConfiguration().setZkServers(null).setJournalDirName(journalDir.getPath()).setLedgerDirNames(new String[]{ledgerDir.getPath()});
  Bookie b=new Bookie(conf);
  b.readJournal();
  for (int i=1; i <= 2 * JournalChannel.SECTOR_SIZE; i++) {
    b.readEntry(1,i);
  }
  try {
    b.readEntry(1,2 * JournalChannel.SECTOR_SIZE + 1);
    fail("Shouldn't have found entry " + (2 * JournalChannel.SECTOR_SIZE + 1));
  }
 catch (  Bookie.NoEntryException e) {
  }
  assertTrue(b.handles.getHandle(1,"testV5Journal".getBytes()).isFenced());
  b.shutdown();
}

</code></pre>

<br>
<pre class="type-2 type-8 type-3 type-4 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testV4Journal() throws Exception {
  File journalDir=createTempDir("bookie","journal");
  Bookie.checkDirectoryStructure(Bookie.getCurrentDirectory(journalDir));
  File ledgerDir=createTempDir("bookie","ledger");
  Bookie.checkDirectoryStructure(Bookie.getCurrentDirectory(ledgerDir));
  writeV4Journal(Bookie.getCurrentDirectory(journalDir),100,"testPasswd".getBytes());
  ServerConfiguration conf=TestBKConfiguration.newServerConfiguration().setZkServers(null).setJournalDirName(journalDir.getPath()).setLedgerDirNames(new String[]{ledgerDir.getPath()});
  Bookie b=new Bookie(conf);
  b.readJournal();
  b.readEntry(1,100);
  try {
    b.readEntry(1,101);
    fail("Shouldn't have found entry 101");
  }
 catch (  Bookie.NoEntryException e) {
  }
  assertTrue(b.handles.getHandle(1,"testPasswd".getBytes()).isFenced());
  b.shutdown();
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.bookkeeper.bookie.BookieThreadTest </h4><pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies boolean conditions
"></span><br>
/** 
 * Test verifies uncaught exception handling of BookieThread
 */
@Test(timeout=30000) public void testUncaughtException() throws Exception {
  MyThread myThread=new MyThread("Test-Thread");
  myThread.start();
  Assert.assertTrue("Uncaught exception is not properly handled.",runningLatch.await(10000,TimeUnit.MILLISECONDS));
  runningLatch=new CountDownLatch(1);
  MyCriticalThread myCriticalThread=new MyCriticalThread("Test-Critical-Thread");
  myCriticalThread.start();
  Assert.assertTrue("Uncaught exception is not properly handled.",runningLatch.await(10000,TimeUnit.MILLISECONDS));
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.bookkeeper.bookie.CompactionTest </h4><pre class="type-2 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies boolean conditions
"></span><br>
/** 
 * Test that compaction doesnt add to index without having persisted
 * entrylog first. This is needed because compaction doesn't go through the journal.{@see https://issues.apache.org/jira/browse/BOOKKEEPER-530}{@see https://issues.apache.org/jira/browse/BOOKKEEPER-664}
 */
@Test(timeout=60000) public void testCompactionSafety() throws Exception {
  tearDown();
  ServerConfiguration conf=TestBKConfiguration.newServerConfiguration();
  final Set<Long> ledgers=Collections.newSetFromMap(new ConcurrentHashMap<Long,Boolean>());
  LedgerManager manager=getLedgerManager(ledgers);
  File tmpDir=createTempDir("bkTest",".dir");
  File curDir=Bookie.getCurrentDirectory(tmpDir);
  Bookie.checkDirectoryStructure(curDir);
  conf.setLedgerDirNames(new String[]{tmpDir.toString()});
  conf.setEntryLogSizeLimit(EntryLogger.LOGFILE_HEADER_SIZE + 3 * (4 + ENTRY_SIZE));
  conf.setGcWaitTime(100);
  conf.setMinorCompactionThreshold(0.7f);
  conf.setMajorCompactionThreshold(0.0f);
  conf.setMinorCompactionInterval(1);
  conf.setMajorCompactionInterval(10);
  conf.setPageLimit(1);
  CheckpointSource checkpointSource=new CheckpointSource(){
    AtomicInteger idGen=new AtomicInteger(0);
class MyCheckpoint implements CheckpointSource.Checkpoint {
      int id=idGen.incrementAndGet();
      @Override public int compareTo(      CheckpointSource.Checkpoint o){
        if (o == CheckpointSource.Checkpoint.MAX) {
          return -1;
        }
 else         if (o == CheckpointSource.Checkpoint.MIN) {
          return 1;
        }
        return id - ((MyCheckpoint)o).id;
      }
    }
    @Override public CheckpointSource.Checkpoint newCheckpoint(){
      return new MyCheckpoint();
    }
    public void checkpointComplete(    CheckpointSource.Checkpoint checkpoint,    boolean compact) throws IOException {
    }
  }
;
  final byte[] KEY="foobar".getBytes();
  File log0=new File(curDir,"0.log");
  LedgerDirsManager dirs=new LedgerDirsManager(conf,conf.getLedgerDirs());
  assertFalse("Log shouldnt exist",log0.exists());
  InterleavedLedgerStorage storage=new InterleavedLedgerStorage(conf,manager,dirs,checkpointSource);
  ledgers.add(1l);
  ledgers.add(2l);
  ledgers.add(3l);
  storage.setMasterKey(1,KEY);
  storage.setMasterKey(2,KEY);
  storage.setMasterKey(3,KEY);
  storage.addEntry(genEntry(1,1,ENTRY_SIZE));
  storage.addEntry(genEntry(2,1,ENTRY_SIZE));
  storage.addEntry(genEntry(2,2,ENTRY_SIZE));
  storage.addEntry(genEntry(3,2,ENTRY_SIZE));
  storage.flush();
  storage.shutdown();
  assertTrue("Log should exist",log0.exists());
  ledgers.remove(2l);
  ledgers.remove(3l);
  storage=new InterleavedLedgerStorage(conf,manager,dirs,checkpointSource);
  storage.start();
  for (int i=0; i < 10; i++) {
    if (!log0.exists()) {
      break;
    }
    Thread.sleep(1000);
    storage.entryLogger.flush();
  }
  assertFalse("Log shouldnt exist",log0.exists());
  ledgers.add(4l);
  storage.setMasterKey(4,KEY);
  storage.addEntry(genEntry(4,1,ENTRY_SIZE));
  storage=new InterleavedLedgerStorage(conf,manager,dirs,checkpointSource);
  storage.getEntry(1,1);
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies boolean conditions
"></span><br>
@Test(timeout=60000) public void testMinorCompaction() throws Exception {
  LedgerHandle[] lhs=prepareData(3,false);
  for (  LedgerHandle lh : lhs) {
    lh.close();
  }
  baseConf.setMajorCompactionThreshold(0.0f);
  restartBookies(baseConf);
  bkc.deleteLedger(lhs[1].getId());
  bkc.deleteLedger(lhs[2].getId());
  LOG.info("Finished deleting the ledgers contains most entries.");
  Thread.sleep(baseConf.getMinorCompactionInterval() * 1000 + baseConf.getGcWaitTime());
  for (  File ledgerDirectory : tmpDirs) {
    assertFalse("Found entry log file ([0,1,2].log that should have not been compacted in ledgerDirectory: " + ledgerDirectory,TestUtils.hasLogFiles(ledgerDirectory,true,0,1,2));
  }
  verifyLedger(lhs[0].getId(),0,lhs[0].getLastAddConfirmed());
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies boolean conditions
"></span><br>
@Test(timeout=60000) public void testMajorCompaction() throws Exception {
  LedgerHandle[] lhs=prepareData(3,true);
  for (  LedgerHandle lh : lhs) {
    lh.close();
  }
  baseConf.setMinorCompactionThreshold(0.0f);
  restartBookies(baseConf);
  bkc.deleteLedger(lhs[0].getId());
  bkc.deleteLedger(lhs[2].getId());
  LOG.info("Finished deleting the ledgers contains most entries.");
  Thread.sleep(baseConf.getMajorCompactionInterval() * 1000 + baseConf.getGcWaitTime());
  for (  File ledgerDirectory : tmpDirs) {
    assertFalse("Found entry log file ([0,1,2].log that should have not been compacted in ledgerDirectory: " + ledgerDirectory,TestUtils.hasLogFiles(ledgerDirectory,true,0,1,2));
  }
  verifyLedger(lhs[1].getId(),0,lhs[1].getLastAddConfirmed());
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies boolean conditions
"></span><br>
@Test(timeout=60000) public void testMajorCompactionAboveThreshold() throws Exception {
  LedgerHandle[] lhs=prepareData(3,false);
  for (  LedgerHandle lh : lhs) {
    lh.close();
  }
  bkc.deleteLedger(lhs[0].getId());
  bkc.deleteLedger(lhs[1].getId());
  LOG.info("Finished deleting the ledgers contains less entries.");
  Thread.sleep(baseConf.getMajorCompactionInterval() * 1000 + baseConf.getGcWaitTime());
  for (  File ledgerDirectory : tmpDirs) {
    assertTrue("Not Found entry log file ([1,2].log that should have been compacted in ledgerDirectory: " + ledgerDirectory,TestUtils.hasLogFiles(ledgerDirectory,false,0,1,2));
  }
}

</code></pre>

<br>
<pre class="type-2 type-3 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
"></span><br>
@Test(timeout=60000) public void testForceGarbageCollection() throws Exception {
  ServerConfiguration conf=newServerConfiguration();
  conf.setGcWaitTime(60000);
  conf.setMinorCompactionInterval(120000);
  conf.setMajorCompactionInterval(240000);
  LedgerDirsManager dirManager=new LedgerDirsManager(conf,conf.getLedgerDirs());
  CheckpointSource cp=new CheckpointSource(){
    @Override public Checkpoint newCheckpoint(){
      return null;
    }
    @Override public void checkpointComplete(    Checkpoint checkPoint,    boolean compact) throws IOException {
    }
  }
;
  Bookie.checkDirectoryStructure(conf.getJournalDir());
  for (  File dir : dirManager.getAllLedgerDirs()) {
    Bookie.checkDirectoryStructure(dir);
  }
  InterleavedLedgerStorage storage=new InterleavedLedgerStorage(conf,LedgerManagerFactory.newLedgerManagerFactory(conf,zkc).newLedgerManager(),dirManager,cp);
  storage.start();
  long startTime=MathUtils.now();
  Thread.sleep(2000);
  storage.gcThread.enableForceGC();
  Thread.sleep(1000);
  assertTrue("Minor or major compaction did not trigger even on forcing.",storage.gcThread.lastMajorCompactionTime > startTime && storage.gcThread.lastMinorCompactionTime > startTime);
  storage.shutdown();
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies boolean conditions
"></span><br>
@Test(timeout=60000) public void testCompactionSmallEntryLogs() throws Exception {
  LedgerHandle alh=bkc.createLedger(NUM_BOOKIES,NUM_BOOKIES,digestType,"".getBytes());
  for (int i=0; i < 3; i++) {
    alh.addEntry(msg.getBytes());
  }
  alh.close();
  restartBookies();
  LedgerHandle[] lhs=prepareData(3,false);
  for (  LedgerHandle lh : lhs) {
    lh.close();
  }
  bkc.deleteLedger(lhs[1].getId());
  bkc.deleteLedger(lhs[2].getId());
  LOG.info("Finished deleting the ledgers contains most entries.");
  restartBookies();
  Thread.sleep(baseConf.getMajorCompactionInterval() * 1000 + baseConf.getGcWaitTime());
  for (  File ledgerDirectory : tmpDirs) {
    assertTrue("Not Found entry log file ([0].log that should have been compacted in ledgerDirectory: " + ledgerDirectory,TestUtils.hasLogFiles(ledgerDirectory,true,0));
    assertFalse("Found entry log file ([1,2,3].log that should have not been compacted in ledgerDirectory: " + ledgerDirectory,TestUtils.hasLogFiles(ledgerDirectory,true,1,2,3));
  }
  verifyLedger(lhs[0].getId(),0,lhs[0].getLastAddConfirmed());
}

</code></pre>

<br>
<pre class="type-2 type-3 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
"></span><br>
/** 
 * Suspend garbage collection when suspendMajor/suspendMinor is set.
 */
@Test(timeout=60000) public void testSuspendGarbageCollection() throws Exception {
  ServerConfiguration conf=newServerConfiguration();
  conf.setGcWaitTime(500);
  conf.setMinorCompactionInterval(1);
  conf.setMajorCompactionInterval(2);
  LedgerDirsManager dirManager=new LedgerDirsManager(conf,conf.getLedgerDirs());
  CheckpointSource cp=new CheckpointSource(){
    @Override public Checkpoint newCheckpoint(){
      return null;
    }
    @Override public void checkpointComplete(    Checkpoint checkPoint,    boolean compact) throws IOException {
    }
  }
;
  Bookie.checkDirectoryStructure(conf.getJournalDir());
  for (  File dir : dirManager.getAllLedgerDirs()) {
    Bookie.checkDirectoryStructure(dir);
  }
  InterleavedLedgerStorage storage=new InterleavedLedgerStorage(conf,LedgerManagerFactory.newLedgerManagerFactory(conf,zkc).newLedgerManager(),dirManager,cp);
  storage.start();
  Thread.sleep(conf.getMajorCompactionInterval() * 1000 + conf.getGcWaitTime());
  storage.gcThread.suspendMajorGC();
  Thread.sleep(1000);
  long startTime=MathUtils.now();
  Thread.sleep(conf.getMajorCompactionInterval() * 1000 + conf.getGcWaitTime());
  assertTrue("major compaction triggered while set suspend",storage.gcThread.lastMajorCompactionTime < startTime);
  storage.gcThread.suspendMinorGC();
  Thread.sleep(1000);
  startTime=MathUtils.now();
  Thread.sleep(conf.getMajorCompactionInterval() * 1000 + conf.getGcWaitTime());
  assertTrue("minor compaction triggered while set suspend",storage.gcThread.lastMinorCompactionTime < startTime);
  storage.gcThread.resumeMinorGC();
  storage.gcThread.resumeMajorGC();
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies boolean conditions
"></span><br>
@Test(timeout=60000) public void testDisableCompaction() throws Exception {
  LedgerHandle[] lhs=prepareData(3,false);
  baseConf.setMinorCompactionThreshold(0.0f);
  baseConf.setMajorCompactionThreshold(0.0f);
  restartBookies(baseConf);
  bkc.deleteLedger(lhs[1].getId());
  bkc.deleteLedger(lhs[2].getId());
  LOG.info("Finished deleting the ledgers contains most entries.");
  Thread.sleep(baseConf.getMajorCompactionInterval() * 1000 + baseConf.getGcWaitTime());
  for (  File ledgerDirectory : tmpDirs) {
    assertTrue("Not Found entry log file ([0,1].log that should have been compacted in ledgerDirectory: " + ledgerDirectory,TestUtils.hasLogFiles(ledgerDirectory,false,0,1));
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.bookkeeper.bookie.CookieTest </h4><pre class="type-8 type-4 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test that if a bookie is started with directories with
 * version 1 data, that it will fail to start (it needs upgrade)
 */
@Test(timeout=60000) public void testV1data() throws Exception {
  File journalDir=newV1JournalDirectory();
  tmpDirs.add(journalDir);
  File ledgerDir=newV1LedgerDirectory();
  tmpDirs.add(ledgerDir);
  ServerConfiguration conf=TestBKConfiguration.newServerConfiguration().setZkServers(zkUtil.getZooKeeperConnectString()).setJournalDirName(journalDir.getPath()).setLedgerDirNames(new String[]{ledgerDir.getPath()}).setBookiePort(bookiePort);
  try {
    Bookie b=new Bookie(conf);
    fail("Shouldn't have been able to start");
  }
 catch (  BookieException.InvalidCookieException ice) {
    assertTrue("wrong exception",ice.getCause().getMessage().contains("upgrade needed"));
  }
}

</code></pre>

<br>
<pre class="type-2 type-3 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
"></span><br>
/** 
 * Test restart bookie with useHostNameAsBookieID=true, which had cookie generated
 * with ipaddress.
 */
@Test(timeout=60000) public void testRestartWithHostNameAsBookieID() throws Exception {
  String[] ledgerDirs=new String[]{newDirectory(),newDirectory(),newDirectory()};
  String journalDir=newDirectory();
  ServerConfiguration conf=TestBKConfiguration.newServerConfiguration().setZkServers(zkUtil.getZooKeeperConnectString()).setJournalDirName(journalDir).setLedgerDirNames(ledgerDirs).setBookiePort(bookiePort);
  Bookie b=new Bookie(conf);
  b.start();
  b.shutdown();
  conf.setUseHostNameAsBookieID(true);
  b=new Bookie(conf);
  b.start();
  assertTrue("Fails to recognize bookie which was started with IPAddr as ID",!conf.getUseHostNameAsBookieID());
  b.shutdown();
}

</code></pre>

<br>
<pre class="type-8 type-4 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test old version bookie starts with the cookies generated by new version
 * (with useHostNameAsBookieID=true)
 */
@Test(timeout=60000) public void testV2dataWithHostNameAsBookieID() throws Exception {
  File journalDir=newV2JournalDirectory();
  tmpDirs.add(journalDir);
  File ledgerDir=newV2LedgerDirectory();
  tmpDirs.add(ledgerDir);
  ServerConfiguration conf=TestBKConfiguration.newServerConfiguration().setZkServers(zkUtil.getZooKeeperConnectString()).setJournalDirName(journalDir.getPath()).setLedgerDirNames(new String[]{ledgerDir.getPath()}).setBookiePort(bookiePort);
  try {
    conf.setUseHostNameAsBookieID(true);
    new Bookie(conf);
    fail("Shouldn't have been able to start");
  }
 catch (  BookieException.InvalidCookieException ice) {
    assertTrue("wrong exception",ice.getCause().getMessage().contains("upgrade needed"));
  }
}

</code></pre>

<br>
<pre class="type-8 type-4 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test that if a bookie is started with directories with
 * version 2 data, that it will fail to start (it needs upgrade)
 */
@Test(timeout=60000) public void testV2data() throws Exception {
  File journalDir=newV2JournalDirectory();
  tmpDirs.add(journalDir);
  File ledgerDir=newV2LedgerDirectory();
  tmpDirs.add(ledgerDir);
  ServerConfiguration conf=TestBKConfiguration.newServerConfiguration().setZkServers(zkUtil.getZooKeeperConnectString()).setJournalDirName(journalDir.getPath()).setLedgerDirNames(new String[]{ledgerDir.getPath()}).setBookiePort(bookiePort);
  try {
    Bookie b=new Bookie(conf);
    fail("Shouldn't have been able to start");
  }
 catch (  BookieException.InvalidCookieException ice) {
    assertTrue("wrong exception",ice.getCause().getMessage().contains("upgrade needed"));
  }
}

</code></pre>

<br>
<pre class="type-8 type-4 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testVerifyCookieWithFormat() throws Exception {
  ClientConfiguration adminConf=new ClientConfiguration().setZkServers(zkUtil.getZooKeeperConnectString());
  adminConf.setProperty("bookkeeper.format",true);
  BookKeeperAdmin.format(adminConf,false,true);
  ServerConfiguration bookieConf=TestBKConfiguration.newServerConfiguration().setZkServers(zkUtil.getZooKeeperConnectString()).setJournalDirName(newDirectory(false)).setLedgerDirNames(new String[]{newDirectory(false)}).setBookiePort(bookiePort);
  new Bookie(bookieConf);
  BookKeeperAdmin.format(adminConf,false,true);
  try {
    new Bookie(bookieConf);
    fail("Bookie should not start with previous instance id.");
  }
 catch (  BookieException.InvalidCookieException e) {
    assertTrue("Bookie startup should fail because of invalid instance id",e.getMessage().contains("instanceId"));
  }
  Bookie.format(bookieConf,false,true);
  new Bookie(bookieConf);
}

</code></pre>

<br>
<pre class="type-2 type-3 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
"></span><br>
/** 
 * Test restart bookie with useHostNameAsBookieID=false, which had cookie generated
 * with hostname.
 */
@Test(timeout=60000) public void testRestartWithIpAddressAsBookieID() throws Exception {
  String[] ledgerDirs=new String[]{newDirectory(),newDirectory(),newDirectory()};
  String journalDir=newDirectory();
  ServerConfiguration conf=TestBKConfiguration.newServerConfiguration().setZkServers(zkUtil.getZooKeeperConnectString()).setJournalDirName(journalDir).setLedgerDirNames(ledgerDirs).setBookiePort(bookiePort);
  conf.setUseHostNameAsBookieID(true);
  Bookie b=new Bookie(conf);
  b.start();
  b.shutdown();
  conf.setUseHostNameAsBookieID(false);
  b=new Bookie(conf);
  b.start();
  assertTrue("Fails to recognize bookie which was started with HostName as ID",conf.getUseHostNameAsBookieID());
  b.shutdown();
}

</code></pre>

<br>
<pre class="type-2 type-3 type-4 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test write cookie multiple times.
 */
@Test(timeout=60000) public void testWriteToZooKeeper() throws Exception {
  String[] ledgerDirs=new String[]{newDirectory(),newDirectory(),newDirectory()};
  String journalDir=newDirectory();
  ServerConfiguration conf=TestBKConfiguration.newServerConfiguration().setZkServers(zkUtil.getZooKeeperConnectString()).setJournalDirName(journalDir).setLedgerDirNames(ledgerDirs).setBookiePort(bookiePort);
  Bookie b=new Bookie(conf);
  b.start();
  b.shutdown();
  Versioned<Cookie> zkCookie=Cookie.readFromZooKeeper(zkc,conf);
  Version version1=zkCookie.getVersion();
  Assert.assertTrue("Invalid type expected ZkVersion type",version1 instanceof ZkVersion);
  ZkVersion zkVersion1=(ZkVersion)version1;
  Cookie cookie=zkCookie.getValue();
  cookie.writeToZooKeeper(zkc,conf,version1);
  zkCookie=Cookie.readFromZooKeeper(zkc,conf);
  Version version2=zkCookie.getVersion();
  Assert.assertTrue("Invalid type expected ZkVersion type",version2 instanceof ZkVersion);
  ZkVersion zkVersion2=(ZkVersion)version2;
  Assert.assertEquals("Version mismatches!",zkVersion1.getZnodeVersion() + 1,zkVersion2.getZnodeVersion());
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.bookkeeper.bookie.CreateNewLogTest </h4><pre class="type-3 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
"></span><br>
/** 
 * Checks if new log file id is verified against all directories.{@link https://issues.apache.org/jira/browse/BOOKKEEPER-465}
 * @throws Exception
 */
@Test(timeout=60000) public void testCreateNewLog() throws Exception {
  ServerConfiguration conf=TestBKConfiguration.newServerConfiguration();
  conf.setLedgerDirNames(ledgerDirs);
  LedgerDirsManager ledgerDirsManager=new LedgerDirsManager(conf,conf.getLedgerDirs());
  EntryLogger el=new EntryLogger(conf,ledgerDirsManager);
  String logFileName=Long.toHexString(1) + ".log";
  File dir=ledgerDirsManager.pickRandomWritableDir();
  LOG.info("Picked this directory: " + dir);
  File newLogFile=new File(dir,logFileName);
  newLogFile.createNewFile();
  el.createNewLog();
  LOG.info("This is the current log id: " + el.getCurrentLogId());
  Assert.assertTrue("Wrong log id",el.getCurrentLogId() > 1);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.bookkeeper.bookie.EntryLogTest </h4><pre class="type-2 type-11 type-3 type-4 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions in iterations
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testMissingLogId() throws Exception {
  File tmpDir=createTempDir("entryLogTest",".dir");
  File curDir=Bookie.getCurrentDirectory(tmpDir);
  Bookie.checkDirectoryStructure(curDir);
  ServerConfiguration conf=TestBKConfiguration.newServerConfiguration();
  conf.setLedgerDirNames(new String[]{tmpDir.toString()});
  Bookie bookie=new Bookie(conf);
  int numLogs=3;
  int numEntries=10;
  long[][] positions=new long[2 * numLogs][];
  for (int i=0; i < numLogs; i++) {
    positions[i]=new long[numEntries];
    EntryLogger logger=new EntryLogger(conf,bookie.getLedgerDirsManager());
    for (int j=0; j < numEntries; j++) {
      positions[i][j]=logger.addEntry(i,generateEntry(i,j));
    }
    logger.flush();
  }
  File lastLogId=new File(curDir,"lastId");
  lastLogId.delete();
  for (int i=numLogs; i < 2 * numLogs; i++) {
    positions[i]=new long[numEntries];
    EntryLogger logger=new EntryLogger(conf,bookie.getLedgerDirsManager());
    for (int j=0; j < numEntries; j++) {
      positions[i][j]=logger.addEntry(i,generateEntry(i,j));
    }
    logger.flush();
  }
  EntryLogger newLogger=new EntryLogger(conf,bookie.getLedgerDirsManager());
  for (int i=0; i < (2 * numLogs + 1); i++) {
    File logFile=new File(curDir,Long.toHexString(i) + ".log");
    assertTrue(logFile.exists());
  }
  for (int i=0; i < 2 * numLogs; i++) {
    for (int j=0; j < numEntries; j++) {
      String expectedValue="ledger-" + i + "-"+ j;
      byte[] value=newLogger.readEntry(i,j,positions[i][j]);
      ByteBuffer buf=ByteBuffer.wrap(value);
      long ledgerId=buf.getLong();
      long entryId=buf.getLong();
      byte[] data=new byte[buf.remaining()];
      buf.get(data);
      assertEquals(i,ledgerId);
      assertEquals(j,entryId);
      assertEquals(expectedValue,new String(data));
    }
  }
}

</code></pre>

<br>
<pre class="type-3 type-4 type-13 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values related to public fields.">PublicFieldVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies values related to public fields.
"></span><br>
/** 
 * Test to verify the DiskFull during addEntry
 */
@Test(timeout=60000) public void testAddEntryFailureOnDiskFull() throws Exception {
  File ledgerDir1=createTempDir("bkTest",".dir");
  File ledgerDir2=createTempDir("bkTest",".dir");
  ServerConfiguration conf=TestBKConfiguration.newServerConfiguration();
  conf.setLedgerDirNames(new String[]{ledgerDir1.getAbsolutePath(),ledgerDir2.getAbsolutePath()});
  Bookie bookie=new Bookie(conf);
  EntryLogger entryLogger=new EntryLogger(conf,bookie.getLedgerDirsManager());
  InterleavedLedgerStorage ledgerStorage=((InterleavedLedgerStorage)bookie.ledgerStorage);
  ledgerStorage.entryLogger=entryLogger;
  ledgerStorage.setMasterKey(1,"key".getBytes());
  ledgerStorage.setMasterKey(2,"key".getBytes());
  ledgerStorage.setMasterKey(3,"key".getBytes());
  ledgerStorage.addEntry(generateEntry(1,1));
  ledgerStorage.addEntry(generateEntry(2,1));
  bookie.getLedgerDirsManager().addToFilledDirs(entryLogger.currentDir);
  ledgerStorage.addEntry(generateEntry(3,1));
  Assert.assertTrue(0 == generateEntry(1,1).compareTo(ledgerStorage.getEntry(1,1)));
  Assert.assertTrue(0 == generateEntry(2,1).compareTo(ledgerStorage.getEntry(2,1)));
  Assert.assertTrue(0 == generateEntry(3,1).compareTo(ledgerStorage.getEntry(3,1)));
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.bookkeeper.bookie.IndexCorruptionTest </h4><pre class="type-2 type-11 type-3 type-4 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions in iterations
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testNoSuchLedger() throws Exception {
  LOG.debug("Testing NoSuchLedger");
  SyncThread syncThread=bs.get(0).getBookie().syncThread;
  syncThread.suspendSync();
  LedgerHandle lh=bkc.createLedger(1,1,digestType,"".getBytes());
  LedgerHandle newLh=bkc.openLedger(lh.getId(),digestType,"".getBytes());
  String dummyMsg="NoSuchLedger";
  int numMsgs=3;
  LedgerHandle wlh=bkc.createLedger(1,1,digestType,"".getBytes());
  for (int i=0; i < numMsgs; i++) {
    wlh.addEntry(dummyMsg.getBytes());
  }
  syncThread.resumeSync();
  Thread.sleep(2 * baseConf.getFlushInterval());
  restartBookies();
  Enumeration<LedgerEntry> seq=wlh.readEntries(0,numMsgs - 1);
  assertTrue("Enumeration of ledger entries has no element",seq.hasMoreElements() == true);
  int entryId=0;
  while (seq.hasMoreElements()) {
    LedgerEntry e=seq.nextElement();
    assertEquals(entryId,e.getEntryId());
    Assert.assertArrayEquals(dummyMsg.getBytes(),e.getEntry());
    ++entryId;
  }
  assertEquals(entryId,numMsgs);
}

</code></pre>

<br>
<pre class="type-2 type-11 type-3 type-4 type-7 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions in iterations
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects are null
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testEmptyIndexPage() throws Exception {
  LOG.debug("Testing EmptyIndexPage");
  SyncThread syncThread=bs.get(0).getBookie().syncThread;
  assertNotNull("Not found SyncThread.",syncThread);
  syncThread.suspendSync();
  LedgerHandle lh1=bkc.createLedger(1,1,digestType,"".getBytes());
  String dummyMsg="NoSuchLedger";
  int numMsgs=2 * pageSize / 8;
  LedgerHandle lh2=bkc.createLedger(1,1,digestType,"".getBytes());
  for (int i=0; i < numMsgs; i++) {
    lh2.addEntry(dummyMsg.getBytes());
  }
  syncThread.resumeSync();
  Thread.sleep(2 * baseConf.getFlushInterval());
  syncThread.suspendSync();
  LedgerHandle newLh1=bkc.openLedger(lh1.getId(),digestType,"".getBytes());
  for (int i=0; i < 3; i++) {
    lh2.addEntry(dummyMsg.getBytes());
  }
  syncThread.resumeSync();
  Thread.sleep(2 * baseConf.getFlushInterval());
  restartBookies();
  numMsgs+=3;
  Enumeration<LedgerEntry> seq=lh2.readEntries(0,numMsgs - 1);
  assertTrue("Enumeration of ledger entries has no element",seq.hasMoreElements() == true);
  int entryId=0;
  while (seq.hasMoreElements()) {
    LedgerEntry e=seq.nextElement();
    assertEquals(entryId,e.getEntryId());
    Assert.assertArrayEquals(dummyMsg.getBytes(),e.getEntry());
    ++entryId;
  }
  assertEquals(entryId,numMsgs);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.bookkeeper.bookie.LedgerCacheTest </h4><pre class="type-3 type-4 type-9 type-13 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values related to public fields.">PublicFieldVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Verifies values related to public fields.
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test Ledger Cache flush failure
 */
@Test(timeout=30000) public void testLedgerCacheFlushFailureOnDiskFull() throws Exception {
  File ledgerDir1=createTempDir("bkTest",".dir");
  File ledgerDir2=createTempDir("bkTest",".dir");
  ServerConfiguration conf=TestBKConfiguration.newServerConfiguration();
  conf.setLedgerDirNames(new String[]{ledgerDir1.getAbsolutePath(),ledgerDir2.getAbsolutePath()});
  Bookie bookie=new Bookie(conf);
  InterleavedLedgerStorage ledgerStorage=((InterleavedLedgerStorage)bookie.ledgerStorage);
  LedgerCacheImpl ledgerCache=(LedgerCacheImpl)ledgerStorage.ledgerCache;
  ledgerStorage.setMasterKey(1,"key".getBytes());
  FileInfo fileInfo=ledgerCache.getIndexPersistenceManager().getFileInfo(Long.valueOf(1),null);
  FileInfo newFileInfo=new FileInfo(fileInfo.getLf(),fileInfo.getMasterKey());
  ledgerCache.getIndexPersistenceManager().fileInfoCache.put(Long.valueOf(1),newFileInfo);
  ledgerStorage.addEntry(generateEntry(1,1));
  ledgerStorage.addEntry(generateEntry(1,2));
  ledgerStorage.flush();
  ledgerStorage.addEntry(generateEntry(1,3));
  bookie.getIndexDirsManager().addToFilledDirs(newFileInfo.getLf().getParentFile().getParentFile().getParentFile());
  File before=newFileInfo.getLf();
  ledgerStorage.flush();
  File after=newFileInfo.getLf();
  assertEquals("Reference counting for the file info should be zero.",0,newFileInfo.getUseCount());
  assertFalse("After flush index file should be changed",before.equals(after));
  Assert.assertArrayEquals(generateEntry(1,1).array(),ledgerStorage.getEntry(1,1).array());
  Assert.assertArrayEquals(generateEntry(1,2).array(),ledgerStorage.getEntry(1,2).array());
  Assert.assertArrayEquals(generateEntry(1,3).array(),ledgerStorage.getEntry(1,3).array());
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.bookkeeper.bookie.TestLedgerDirsManager </h4><pre class="type-8 type-4 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testPickWritableDirExclusive() throws Exception {
  try {
    dirsManager.pickRandomWritableDir(curDir);
    fail("Should not reach here due to there is no writable ledger dir.");
  }
 catch (  NoWritableLedgerDirException nwlde) {
    assertTrue(true);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.bookkeeper.bookie.TestSyncThread </h4><pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies boolean conditions
"></span><br>
/** 
 * Test that if the ledger storage throws
 * a disk full exception, the owner of the sync
 * thread will be notified.
 */
@Test(timeout=60000) public void testSyncThreadDisksFull() throws Exception {
  int flushInterval=100;
  ServerConfiguration conf=TestBKConfiguration.newServerConfiguration();
  CheckpointSource checkpointSource=new DummyCheckpointSource();
  final CountDownLatch diskFullLatch=new CountDownLatch(1);
  LedgerDirsListener listener=new DummyLedgerDirsListener(){
    @Override public void allDisksFull(){
      diskFullLatch.countDown();
    }
  }
;
  LedgerStorage storage=new DummyLedgerStorage(){
    @Override public Checkpoint checkpoint(    Checkpoint checkpoint) throws IOException {
      throw new NoWritableLedgerDirException("Disk full error in sync thread");
    }
  }
;
  final SyncThread t=new SyncThread(conf,listener,storage,checkpointSource);
  t.start();
  assertTrue("Should have disk full error",diskFullLatch.await(10,TimeUnit.SECONDS));
  t.shutdown();
}

</code></pre>

<br>
<pre class="type-2 type-3 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
"></span><br>
/** 
 * Test that if a flush is taking a long time,
 * the sync thread will not shutdown until it
 * has finished.
 */
@Test(timeout=60000) public void testSyncThreadLongShutdown() throws Exception {
  int flushInterval=100;
  ServerConfiguration conf=TestBKConfiguration.newServerConfiguration();
  CheckpointSource checkpointSource=new DummyCheckpointSource();
  LedgerDirsListener listener=new DummyLedgerDirsListener();
  final CountDownLatch checkpointCalledLatch=new CountDownLatch(1);
  final CountDownLatch checkpointLatch=new CountDownLatch(1);
  final CountDownLatch flushCalledLatch=new CountDownLatch(1);
  final CountDownLatch flushLatch=new CountDownLatch(1);
  final AtomicBoolean failedSomewhere=new AtomicBoolean(false);
  LedgerStorage storage=new DummyLedgerStorage(){
    @Override public void flush() throws IOException {
      flushCalledLatch.countDown();
      try {
        flushLatch.await();
      }
 catch (      InterruptedException ie) {
        Thread.currentThread().interrupt();
        LOG.error("Interrupted in flush thread",ie);
        failedSomewhere.set(true);
      }
    }
    @Override public Checkpoint checkpoint(    Checkpoint checkpoint) throws IOException {
      checkpointCalledLatch.countDown();
      try {
        checkpointLatch.await();
      }
 catch (      InterruptedException ie) {
        Thread.currentThread().interrupt();
        LOG.error("Interrupted in checkpoint thread",ie);
        failedSomewhere.set(true);
      }
      return checkpoint;
    }
  }
;
  final SyncThread t=new SyncThread(conf,listener,storage,checkpointSource);
  t.start();
  assertTrue("Checkpoint should have been called",checkpointCalledLatch.await(10,TimeUnit.SECONDS));
  Future<Boolean> done=executor.submit(new Callable<Boolean>(){
    public Boolean call(){
      try {
        t.shutdown();
      }
 catch (      InterruptedException ie) {
        Thread.currentThread().interrupt();
        LOG.error("Interrupted shutting down sync thread",ie);
        failedSomewhere.set(true);
        return false;
      }
      return true;
    }
  }
);
  checkpointLatch.countDown();
  assertFalse("Shutdown shouldn't have finished",done.isDone());
  assertTrue("Flush should have been called",flushCalledLatch.await(10,TimeUnit.SECONDS));
  assertFalse("Shutdown shouldn't have finished",done.isDone());
  flushLatch.countDown();
  assertTrue("Shutdown should have finished successfully",done.get(10,TimeUnit.SECONDS));
  assertFalse("Shouldn't have failed anywhere",failedSomewhere.get());
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies boolean conditions
"></span><br>
/** 
 * Test that if the ledger storage throws a
 * runtime exception, the bookie will be told
 * to shutdown.
 */
@Test(timeout=60000) public void testSyncThreadShutdownOnError() throws Exception {
  int flushInterval=100;
  ServerConfiguration conf=TestBKConfiguration.newServerConfiguration();
  CheckpointSource checkpointSource=new DummyCheckpointSource();
  final CountDownLatch fatalLatch=new CountDownLatch(1);
  LedgerDirsListener listener=new DummyLedgerDirsListener(){
    @Override public void fatalError(){
      fatalLatch.countDown();
    }
  }
;
  LedgerStorage storage=new DummyLedgerStorage(){
    @Override public Checkpoint checkpoint(    Checkpoint checkpoint) throws IOException {
      throw new RuntimeException("Fatal error in sync thread");
    }
  }
;
  final SyncThread t=new SyncThread(conf,listener,storage,checkpointSource);
  t.start();
  assertTrue("Should have called fatal error",fatalLatch.await(10,TimeUnit.SECONDS));
  t.shutdown();
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.bookkeeper.bookie.UpdateCookieCmdTest </h4><pre class="type-2 type-3 type-4 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * During first updatecookie it successfully created the hostname cookie but
 * it fails to delete the old ipaddress cookie. Here user will issue
 * updatecookie again, now it should be able to delete the old cookie
 * gracefully.
 */
@Test public void testWhenBothIPaddressAndHostNameCookiesExists() throws Exception {
  updateCookie("-b","hostname",true);
  ServerConfiguration conf=bsConfs.get(0);
  conf.setUseHostNameAsBookieID(true);
  Cookie cookie=Cookie.readFromZooKeeper(zkc,conf).getValue();
  Cookie.Builder cookieBuilder=Cookie.newBuilder(cookie);
  conf.setUseHostNameAsBookieID(false);
  final String newBookieHost=Bookie.getBookieAddress(conf).toString();
  cookieBuilder.setBookieHost(newBookieHost);
  cookieBuilder.build().writeToZooKeeper(zkc,conf,Version.NEW);
  verifyCookieInZooKeeper(conf,2);
  BookieShell bkShell=new BookieShell();
  conf.setUseHostNameAsBookieID(true);
  bkShell.setConf(conf);
  String[] argv=new String[]{"updatecookie","-b","hostname"};
  Assert.assertEquals("Failed to return the error code!",0,bkShell.run(argv));
  conf.setUseHostNameAsBookieID(true);
  cookie=Cookie.readFromZooKeeper(zkc,conf).getValue();
  Assert.assertFalse("Cookie has created with IP!",cookie.isBookieHostCreatedFromIp());
  verifyCookieInZooKeeper(conf,1);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.bookkeeper.bookie.UpgradeTest </h4><pre class="type-8 type-4 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testCommandLine() throws Exception {
  PrintStream origerr=System.err;
  PrintStream origout=System.out;
  File output=IOUtils.createTempFileAndDeleteOnExit("bookie","stdout");
  File erroutput=IOUtils.createTempFileAndDeleteOnExit("bookie","stderr");
  System.setOut(new PrintStream(output));
  System.setErr(new PrintStream(erroutput));
  try {
    FileSystemUpgrade.main(new String[]{"-h"});
    try {
      FileSystemUpgrade.main(new String[]{"-u"});
      fail("Should have failed");
    }
 catch (    IllegalArgumentException iae) {
      assertTrue("Wrong exception " + iae.getMessage(),iae.getMessage().contains("without configuration"));
    }
    File f=IOUtils.createTempFileAndDeleteOnExit("bookie","tmpconf");
    try {
      FileSystemUpgrade.main(new String[]{"--conf",f.getPath()});
      fail("Should have failed");
    }
 catch (    IllegalArgumentException iae) {
      assertTrue("Wrong exception " + iae.getMessage(),iae.getMessage().contains("Must specify -upgrade"));
    }
  }
  finally {
    System.setOut(origout);
    System.setErr(origerr);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.bookkeeper.client.BookKeeperCloseTest </h4><pre class="type-8 type-4 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test that createledger using bookkeeper client which is closed should
 * throw ClientClosedException
 */
@Test(timeout=60000) public void testCreateLedger() throws Exception {
  BookKeeper bk=new BookKeeper(baseClientConf,zkc);
  LOG.info("Closing bookkeeper client");
  bk.close();
  try {
    bk.createLedger(digestType,PASSWORD.getBytes());
    fail("should have failed, client is closed");
  }
 catch (  BKClientClosedException e) {
  }
  final AtomicInteger returnCode=new AtomicInteger(0);
  final CountDownLatch openLatch=new CountDownLatch(1);
  CreateCallback cb=new CreateCallback(){
    @Override public void createComplete(    int rc,    LedgerHandle lh,    Object ctx){
      returnCode.set(rc);
      openLatch.countDown();
    }
  }
;
  bk.asyncCreateLedger(3,2,digestType,PASSWORD.getBytes(),cb,openLatch);
  LOG.info("Waiting to finish the ledger creation");
  assertTrue("create ledger call should have completed",openLatch.await(20,TimeUnit.SECONDS));
  assertEquals("Succesfully created ledger through closed bkclient!",BKException.Code.ClientClosedException,returnCode.get());
}

</code></pre>

<br>
<pre class="type-8 type-4 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test that adding entry to a ledger using bookkeeper client which is
 * closed should throw ClientClosedException
 */
@Test(timeout=60000) public void testAddLedgerEntry() throws Exception {
  BookKeeper bk=new BookKeeper(baseClientConf,zkc);
  LOG.info("Create ledger and add entries to it");
  LedgerHandle lh=createLedgerWithEntries(bk,1);
  LOG.info("Closing bookkeeper client");
  restartBookieSlow();
  bk.close();
  try {
    lh.addEntry("foobar".getBytes());
    fail("should have failed, client is closed");
  }
 catch (  BKClientClosedException e) {
  }
  final CountDownLatch completeLatch=new CountDownLatch(1);
  final AtomicInteger rc=new AtomicInteger(BKException.Code.OK);
  lh.asyncAddEntry("foobar".getBytes(),new AddCallback(){
    public void addComplete(    int rccb,    LedgerHandle lh,    long entryId,    Object ctx){
      rc.set(rccb);
      completeLatch.countDown();
    }
  }
,null);
  LOG.info("Waiting to finish adding another entry asynchronously");
  assertTrue("Add entry to ledger call should have completed",completeLatch.await(20,TimeUnit.SECONDS));
  assertEquals("Add entry to ledger should not have succeeded through closed bkclient!",BKException.Code.ClientClosedException,rc.get());
}

</code></pre>

<br>
<pre class="type-4 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test that checking a ledger using a closed BK client will
 * throw a ClientClosedException
 */
@Test(timeout=60000) public void testLedgerCheck() throws Exception {
  BookKeeper bk=new BookKeeper(baseClientConf,zkc);
  LOG.info("Create ledger and add entries to it");
  LedgerHandle lh=createLedgerWithEntries(bk,100);
  LOG.info("Closing bookkeeper client");
  LedgerChecker lc=new LedgerChecker(bk);
  restartBookieSlow();
  bk.close();
  final CountDownLatch postLatch=new CountDownLatch(1);
  final AtomicInteger postRc=new AtomicInteger(BKException.Code.OK);
  lc.checkLedger(lh,new GenericCallback<Set<LedgerFragment>>(){
    @Override public void operationComplete(    int rc,    Set<LedgerFragment> result){
      postRc.set(rc);
      postLatch.countDown();
    }
  }
);
  assertTrue("checkLedger should have finished",postLatch.await(30,TimeUnit.SECONDS));
  assertEquals("Should have client closed exception",postRc.get(),BKException.Code.ClientClosedException);
}

</code></pre>

<br>
<pre class="type-8 type-4 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test that deleting a ledger using bookkeeper client which is closed
 * should throw ClientClosedException
 */
@Test(timeout=60000) public void testDeleteLedger() throws Exception {
  BookKeeper bk=new BookKeeper(baseClientConf,zkc);
  LOG.info("Create ledger and add entries to it");
  LedgerHandle lh=createLedgerWithEntries(bk,100);
  LOG.info("Closing bookkeeper client");
  bk.close();
  try {
    bk.deleteLedger(lh.getId());
    fail("should have failed, client is closed");
  }
 catch (  BKClientClosedException e) {
  }
  final AtomicInteger returnCode=new AtomicInteger(0);
  final CountDownLatch openLatch=new CountDownLatch(1);
  AsyncCallback.DeleteCallback cb=new AsyncCallback.DeleteCallback(){
    public void deleteComplete(    int rc,    Object ctx){
      returnCode.set(rc);
      openLatch.countDown();
    }
  }
;
  bk.asyncDeleteLedger(lh.getId(),cb,openLatch);
  LOG.info("Waiting to delete the ledger asynchronously");
  assertTrue("Delete call should have completed",openLatch.await(20,TimeUnit.SECONDS));
  assertEquals("Delete should not have succeeded through closed bkclient!",BKException.Code.ClientClosedException,returnCode.get());
}

</code></pre>

<br>
<pre class="type-8 type-4 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test that closing a ledger using bookkeeper client which is closed should
 * throw ClientClosedException
 */
@Test(timeout=60000) public void testCloseLedger() throws Exception {
  BookKeeper bk=new BookKeeper(baseClientConf,zkc);
  LOG.info("Create ledger and add entries to it");
  LedgerHandle lh=createLedgerWithEntries(bk,100);
  LedgerHandle lh2=createLedgerWithEntries(bk,100);
  LOG.info("Closing bookkeeper client");
  bk.close();
  try {
    lh.close();
    fail("should have failed, client is closed");
  }
 catch (  BKClientClosedException e) {
  }
  final CountDownLatch completeLatch=new CountDownLatch(1);
  final AtomicInteger rc=new AtomicInteger(BKException.Code.OK);
  lh2.asyncClose(new CloseCallback(){
    public void closeComplete(    int rccb,    LedgerHandle lh,    Object ctx){
      rc.set(rccb);
      completeLatch.countDown();
    }
  }
,null);
  LOG.info("Waiting to finish adding another entry asynchronously");
  assertTrue("Close ledger call should have completed",completeLatch.await(20,TimeUnit.SECONDS));
  assertEquals("Close ledger should have succeeded through closed bkclient!",BKException.Code.ClientClosedException,rc.get());
}

</code></pre>

<br>
<pre class="type-8 type-4 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test that readlastconfirmed entry from a ledger using bookkeeper client
 * which is closed should throw ClientClosedException
 */
@Test(timeout=60000) public void testReadLastConfirmed() throws Exception {
  BookKeeper bk=new BookKeeper(baseClientConf,zkc);
  LOG.info("Create ledger and add entries to it");
  LedgerHandle lh=createLedgerWithEntries(bk,100);
  LOG.info("Closing bookkeeper client");
  restartBookieSlow();
  restartBookieSlow();
  restartBookieSlow();
  bk.close();
  final CountDownLatch readLatch=new CountDownLatch(1);
  final AtomicInteger rc=new AtomicInteger(BKException.Code.OK);
  AsyncCallback.ReadLastConfirmedCallback cb=new AsyncCallback.ReadLastConfirmedCallback(){
    @Override public void readLastConfirmedComplete(    int rccb,    long lastConfirmed,    Object ctx){
      rc.set(rccb);
      readLatch.countDown();
    }
  }
;
  lh.asyncReadLastConfirmed(cb,readLatch);
  LOG.info("Waiting to finish reading last confirmed entry asynchronously");
  assertTrue("ReadLastConfirmed call should have completed",readLatch.await(20,TimeUnit.SECONDS));
  assertEquals("ReadLastConfirmed should have succeeded through closed bkclient!",BKException.Code.ClientClosedException,rc.get());
  try {
    lh.readLastConfirmed();
    fail("should have failed, client is closed");
  }
 catch (  BKClientClosedException e) {
  }
}

</code></pre>

<br>
<pre class="type-8 type-4 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test that opening a ledger using bookkeeper client which is closed should
 * throw ClientClosedException
 */
@Test(timeout=60000) public void testFenceLedger() throws Exception {
  BookKeeper bk=new BookKeeper(baseClientConf,zkc);
  LOG.info("Create ledger and add entries to it");
  LedgerHandle lh=createLedgerWithEntries(bk,100);
  LOG.info("Closing bookkeeper client");
  restartBookieSlow();
  bk.close();
  try {
    bk.openLedger(lh.getId(),digestType,PASSWORD.getBytes());
    fail("should have failed, client is closed");
  }
 catch (  BKClientClosedException e) {
  }
  try {
    bk.openLedgerNoRecovery(lh.getId(),digestType,PASSWORD.getBytes());
    fail("should have failed, client is closed");
  }
 catch (  BKClientClosedException e) {
  }
  final AtomicInteger returnCode=new AtomicInteger(0);
  final CountDownLatch openLatch=new CountDownLatch(1);
  AsyncCallback.OpenCallback cb=new AsyncCallback.OpenCallback(){
    public void openComplete(    int rc,    LedgerHandle lh,    Object ctx){
      returnCode.set(rc);
      openLatch.countDown();
    }
  }
;
  bk.asyncOpenLedger(lh.getId(),digestType,PASSWORD.getBytes(),cb,openLatch);
  LOG.info("Waiting to open the ledger asynchronously");
  assertTrue("Open call should have completed",openLatch.await(20,TimeUnit.SECONDS));
  assertTrue("Open should not have succeeded through closed bkclient!",BKException.Code.ClientClosedException == returnCode.get());
}

</code></pre>

<br>
<pre class="type-8 type-4 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test that reading entry from a ledger using bookkeeper client which is
 * closed should throw ClientClosedException
 */
@Test(timeout=60000) public void testReadLedgerEntry() throws Exception {
  BookKeeper bk=new BookKeeper(baseClientConf,zkc);
  LOG.info("Create ledger and add entries to it");
  int numOfEntries=100;
  LedgerHandle lh=createLedgerWithEntries(bk,numOfEntries);
  LOG.info("Closing bookkeeper client");
  restartBookieSlow();
  bk.close();
  try {
    lh.readEntries(0,numOfEntries - 1);
    fail("should have failed, client is closed");
  }
 catch (  BKClientClosedException e) {
  }
  final CountDownLatch readLatch=new CountDownLatch(1);
  final AtomicInteger rc=new AtomicInteger(BKException.Code.OK);
  ReadCallback cb=new ReadCallback(){
    @Override public void readComplete(    int rccb,    LedgerHandle lh,    Enumeration<LedgerEntry> seq,    Object ctx){
      rc.set(rccb);
      readLatch.countDown();
    }
  }
;
  lh.asyncReadEntries(0,numOfEntries - 1,cb,readLatch);
  LOG.info("Waiting to finish reading the entries asynchronously");
  assertTrue("Read entry ledger call should have completed",readLatch.await(20,TimeUnit.SECONDS));
  assertEquals("Read entry ledger should have succeeded through closed bkclient!",BKException.Code.ClientClosedException,rc.get());
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.bookkeeper.client.BookKeeperTest </h4><pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies boolean conditions
"></span><br>
/** 
 * Tests that when trying to use a closed BK client object we get
 * a callback error and not an InterruptedException.
 * @throws Exception
 */
@Test(timeout=60000) public void testAsyncReadWithError() throws Exception {
  LedgerHandle lh=bkc.createLedger(3,3,DigestType.CRC32,"testPasswd".getBytes());
  bkc.close();
  final AtomicInteger result=new AtomicInteger(0);
  final CountDownLatch counter=new CountDownLatch(1);
  lh.asyncAddEntry("test".getBytes(),new AddCallback(){
    public void addComplete(    int rc,    LedgerHandle lh,    long entryId,    Object ctx){
      result.set(rc);
      counter.countDown();
    }
  }
,null);
  counter.await();
  Assert.assertTrue(result.get() != 0);
}

</code></pre>

<br>
<pre class="type-11 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies boolean conditions
"></span><br>
/** 
 * Test that bookkeeper will close cleanly if close is issued
 * while another operation is in progress.
 */
@Test(timeout=60000) public void testCloseDuringOp() throws Exception {
  ClientConfiguration conf=new ClientConfiguration().setZkServers(zkUtil.getZooKeeperConnectString());
  for (int i=0; i < 100; i++) {
    final BookKeeper client=new BookKeeper(conf);
    final CountDownLatch l=new CountDownLatch(1);
    final AtomicBoolean success=new AtomicBoolean(false);
    Thread t=new Thread(){
      public void run(){
        try {
          LedgerHandle lh=client.createLedger(3,3,digestType,"testPasswd".getBytes());
          startNewBookie();
          killBookie(0);
          lh.asyncAddEntry("test".getBytes(),new AddCallback(){
            @Override public void addComplete(            int rc,            LedgerHandle lh,            long entryId,            Object ctx){
            }
          }
,null);
          client.close();
          success.set(true);
          l.countDown();
        }
 catch (        Exception e) {
          LOG.error("Error running test",e);
          success.set(false);
          l.countDown();
        }
      }
    }
;
    t.start();
    assertTrue("Close never completed",l.await(10,TimeUnit.SECONDS));
    assertTrue("Close was not successful",success.get());
  }
}

</code></pre>

<br>
<pre class="type-3 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
"></span><br>
@Test(timeout=60000) public void testIsClosed() throws Exception {
  ClientConfiguration conf=new ClientConfiguration().setZkServers(zkUtil.getZooKeeperConnectString());
  BookKeeper bkc=new BookKeeper(conf);
  LedgerHandle lh=bkc.createLedger(digestType,"testPasswd".getBytes());
  Long lId=lh.getId();
  lh.addEntry("000".getBytes());
  boolean result=bkc.isClosed(lId);
  Assert.assertTrue("Ledger shouldn't be flagged as closed!",!result);
  lh.close();
  result=bkc.isClosed(lId);
  Assert.assertTrue("Ledger should be flagged as closed!",result);
  bkc.close();
}

</code></pre>

<br>
<pre class="type-8 type-4 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testConstructionNotConnectedExplicitZk() throws Exception {
  ClientConfiguration conf=new ClientConfiguration().setZkServers(zkUtil.getZooKeeperConnectString()).setZkTimeout(20000);
  CountDownLatch l=new CountDownLatch(1);
  zkUtil.sleepServer(5,l);
  l.await();
  ZooKeeper zk=new ZooKeeper(zkUtil.getZooKeeperConnectString(),10000,new Watcher(){
    @Override public void process(    WatchedEvent event){
    }
  }
);
  assertFalse("ZK shouldn't have connected yet",zk.getState().isConnected());
  try {
    BookKeeper bkc=new BookKeeper(conf,zk);
    fail("Shouldn't be able to construct with unconnected zk");
  }
 catch (  KeeperException.ConnectionLossException cle) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.bookkeeper.client.BookieRecoveryTest </h4><pre class="type-2 type-8 type-3 type-4 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testBookieRecoveryOnInRecoveryLedger() throws Exception {
  int numMsgs=10;
  int numLedgers=1;
  List<LedgerHandle> lhs=createLedgers(numLedgers,2,2);
  writeEntriestoLedgers(numMsgs,0,lhs);
  ArrayList<BookieSocketAddress> lastEnsemble=lhs.get(0).getLedgerMetadata().getEnsembles().entrySet().iterator().next().getValue();
  BookieSocketAddress bookieToKill=lastEnsemble.get(0);
  killBookie(bookieToKill);
  BookieSocketAddress bookieToKill2=lastEnsemble.get(1);
  ServerConfiguration conf2=killBookie(bookieToKill2);
  startNewBookie();
  for (  LedgerHandle oldLh : lhs) {
    try {
      bkc.openLedger(oldLh.getId(),digestType,baseClientConf.getBookieRecoveryPasswd());
      fail("Should have thrown exception");
    }
 catch (    Exception e) {
    }
  }
  try {
    bkAdmin.recoverBookieData(bookieToKill,null);
    fail("Should have thrown exception");
  }
 catch (  BKException.BKLedgerRecoveryException bke) {
  }
  bs.add(startBookie(conf2));
  bsConfs.add(conf2);
  bkAdmin.recoverBookieData(bookieToKill,null);
  for (  LedgerHandle lh : lhs) {
    assertTrue("Not fully replicated",verifyFullyReplicated(lh,numMsgs));
  }
  List<LedgerHandle> newLhs=openLedgers(lhs);
  for (  LedgerHandle newLh : newLhs) {
    Map.Entry<Long,ArrayList<BookieSocketAddress>> entry=newLh.getLedgerMetadata().getEnsembles().entrySet().iterator().next();
    assertFalse(entry.getValue().contains(bookieToKill));
    assertTrue(entry.getValue().contains(bookieToKill2));
  }
}

</code></pre>

<br>
<pre class="type-2 type-3 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
"></span><br>
/** 
 * This tests the bookie recovery functionality with ensemble changes.
 * We'll verify that:
 * - bookie recovery should not affect ensemble change.
 * - ensemble change should not erase changes made by recovery.{@link https://issues.apache.org/jira/browse/BOOKKEEPER-667}
 */
@Test(timeout=60000) public void testMetadataConflictWithRecovery() throws Exception {
  int numEntries=10;
  byte[] data="testMetadataConflictWithRecovery".getBytes();
  LedgerHandle lh=bkc.createLedger(2,2,digestType,baseClientConf.getBookieRecoveryPasswd());
  for (int i=0; i < numEntries; i++) {
    lh.addEntry(data);
  }
  BookieSocketAddress bookieToKill=lh.getLedgerMetadata().getEnsemble(numEntries - 1).get(1);
  killBookie(bookieToKill);
  startNewBookie();
  for (int i=0; i < numEntries; i++) {
    lh.addEntry(data);
  }
  bkAdmin.recoverBookieData(bookieToKill,null);
  bookieToKill=lh.getLedgerMetadata().getEnsemble(2 * numEntries - 1).get(1);
  ServerConfiguration confOfKilledBookie=killBookie(bookieToKill);
  startNewBookie();
  for (int i=0; i < numEntries; i++) {
    lh.addEntry(data);
  }
  bsConfs.add(confOfKilledBookie);
  bs.add(startBookie(confOfKilledBookie));
  assertTrue("Not fully replicated",verifyFullyReplicated(lh,3 * numEntries));
  lh.close();
}

</code></pre>

<br>
<pre class="type-2 type-6 type-8 type-3 type-4 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test that when we try to recover a ledger which doesn't have
 * the password stored in the configuration, we don't succeed
 */
@Test(timeout=60000) public void ensurePasswordUsedForOldLedgers() throws Exception {
  if (MSLedgerManagerFactory.class.getName().equals(ledgerManagerFactory)) {
    return;
  }
  zkUtil.getZooKeeperClient().delete("/ledgers/LAYOUT",-1);
  byte[] passwdCorrect="AAAAAA".getBytes();
  byte[] passwdBad="BBBBBB".getBytes();
  DigestType digestCorrect=digestType;
  DigestType digestBad=digestCorrect == DigestType.MAC ? DigestType.CRC32 : DigestType.MAC;
  org.apache.bk_v4_1_0.bookkeeper.client.BookKeeper.DigestType digestCorrect410=org.apache.bk_v4_1_0.bookkeeper.client.BookKeeper.DigestType.valueOf(digestType.toString());
  org.apache.bk_v4_1_0.bookkeeper.conf.ClientConfiguration c=new org.apache.bk_v4_1_0.bookkeeper.conf.ClientConfiguration();
  c.setZkServers(zkUtil.getZooKeeperConnectString()).setLedgerManagerType(ledgerManagerFactory.equals("org.apache.bookkeeper.meta.FlatLedgerManagerFactory") ? "flat" : "hierarchical");
  org.apache.bk_v4_1_0.bookkeeper.client.BookKeeper bkc41=new org.apache.bk_v4_1_0.bookkeeper.client.BookKeeper(c);
  bkc41.close();
  restartBookies();
  bkc41=new org.apache.bk_v4_1_0.bookkeeper.client.BookKeeper(c);
  org.apache.bk_v4_1_0.bookkeeper.client.LedgerHandle lh41=bkc41.createLedger(3,2,digestCorrect410,passwdCorrect);
  long ledgerId=lh41.getId();
  for (int i=0; i < 100; i++) {
    lh41.addEntry("foobar".getBytes());
  }
  lh41.close();
  bkc41.close();
  startNewBookie();
  int removeIndex=0;
  BookieSocketAddress bookieSrc=bs.get(removeIndex).getLocalAddress();
  bs.get(removeIndex).shutdown();
  bs.remove(removeIndex);
  LedgerHandle lh=bkc.openLedgerNoRecovery(ledgerId,digestCorrect,passwdCorrect);
  assertFalse("Should be entries missing",verifyFullyReplicated(lh,100));
  lh.close();
  ClientConfiguration adminConf;
  BookKeeperAdmin bka;
  if (digestCorrect == DigestType.MAC) {
    adminConf=new ClientConfiguration();
    adminConf.setZkServers(zkUtil.getZooKeeperConnectString());
    adminConf.setLedgerManagerFactoryClassName(ledgerManagerFactory);
    adminConf.setBookieRecoveryDigestType(digestCorrect);
    adminConf.setBookieRecoveryPasswd(passwdBad);
    bka=new BookKeeperAdmin(adminConf);
    try {
      bka.recoverBookieData(bookieSrc,null);
      fail("Shouldn't be able to recover with wrong password");
    }
 catch (    BKException bke) {
    }
 finally {
      bka.close();
    }
  }
  adminConf=new ClientConfiguration();
  adminConf.setZkServers(zkUtil.getZooKeeperConnectString());
  adminConf.setLedgerManagerFactoryClassName(ledgerManagerFactory);
  adminConf.setBookieRecoveryDigestType(digestBad);
  adminConf.setBookieRecoveryPasswd(passwdCorrect);
  bka=new BookKeeperAdmin(adminConf);
  try {
    bka.recoverBookieData(bookieSrc,null);
    fail("Shouldn't be able to recover with wrong digest");
  }
 catch (  BKException bke) {
  }
 finally {
    bka.close();
  }
  lh=bkc.openLedgerNoRecovery(ledgerId,digestCorrect,passwdCorrect);
  assertFalse("Should be entries missing",verifyFullyReplicated(lh,100));
  lh.close();
  adminConf.setBookieRecoveryDigestType(digestCorrect);
  adminConf.setBookieRecoveryPasswd(passwdCorrect);
  bka=new BookKeeperAdmin(adminConf);
  bka.recoverBookieData(bookieSrc,null);
  bka.close();
  lh=bkc.openLedgerNoRecovery(ledgerId,digestCorrect,passwdCorrect);
  assertTrue("Should have recovered everything",verifyFullyReplicated(lh,100));
  lh.close();
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies boolean conditions
"></span><br>
/** 
 * This tests the asynchronous bookie recovery functionality by writing
 * entries into 3 bookies, killing one bookie, starting up a new one to
 * replace it, and then recovering the ledger entries from the killed bookie
 * onto the new one. We'll verify that the entries stored on the killed
 * bookie are properly copied over and restored onto the new one.
 * @throws Exception
 */
@Test(timeout=60000) public void testAsyncBookieRecoveryToSpecificBookie() throws Exception {
  int numLedgers=3;
  List<LedgerHandle> lhs=createLedgers(numLedgers);
  int numMsgs=10;
  writeEntriestoLedgers(numMsgs,0,lhs);
  LOG.info("Finished writing all ledger entries so shutdown one of the bookies.");
  int initialPort=bsConfs.get(0).getBookiePort();
  bs.get(0).shutdown();
  bs.remove(0);
  int newBookiePort=startNewBookie();
  writeEntriestoLedgers(numMsgs,10,lhs);
  BookieSocketAddress bookieSrc=new BookieSocketAddress(InetAddress.getLocalHost().getHostAddress(),initialPort);
  BookieSocketAddress bookieDest=new BookieSocketAddress(InetAddress.getLocalHost().getHostAddress(),newBookiePort);
  LOG.info("Now recover the data on the killed bookie (" + bookieSrc + ") and replicate it to the new one ("+ bookieDest+ ")");
  sync.value=false;
  bkAdmin.asyncRecoverBookieData(bookieSrc,bookieDest,bookieRecoverCb,sync);
synchronized (sync) {
    while (sync.value == false) {
      sync.wait();
    }
    assertTrue(bookieRecoverCb.success);
  }
  verifyRecoveredLedgers(lhs,0,2 * numMsgs - 1);
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies boolean conditions
"></span><br>
/** 
 * This tests the asynchronous bookie recovery functionality by writing
 * entries into 3 bookies, killing one bookie, starting up a few new
 * bookies, and then recovering the ledger entries from the killed bookie
 * onto random available bookie servers. We'll verify that the entries
 * stored on the killed bookie are properly copied over and restored onto
 * the other bookies.
 * @throws Exception
 */
@Test(timeout=60000) public void testAsyncBookieRecoveryToRandomBookies() throws Exception {
  int numLedgers=3;
  List<LedgerHandle> lhs=createLedgers(numLedgers);
  int numMsgs=10;
  writeEntriestoLedgers(numMsgs,0,lhs);
  LOG.info("Finished writing all ledger entries so shutdown one of the bookies.");
  int initialPort=bsConfs.get(0).getBookiePort();
  bs.get(0).shutdown();
  bs.remove(0);
  for (int i=0; i < 3; i++) {
    startNewBookie();
  }
  writeEntriestoLedgers(numMsgs,10,lhs);
  BookieSocketAddress bookieSrc=new BookieSocketAddress(InetAddress.getLocalHost().getHostAddress(),initialPort);
  BookieSocketAddress bookieDest=null;
  LOG.info("Now recover the data on the killed bookie (" + bookieSrc + ") and replicate it to a random available one");
  sync.value=false;
  bkAdmin.asyncRecoverBookieData(bookieSrc,bookieDest,bookieRecoverCb,sync);
synchronized (sync) {
    while (sync.value == false) {
      sync.wait();
    }
    assertTrue(bookieRecoverCb.success);
  }
  verifyRecoveredLedgers(lhs,0,2 * numMsgs - 1);
}

</code></pre>

<br>
<pre class="type-2 type-3 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
"></span><br>
@Test(timeout=60000) public void recoverWithoutPasswordInConf() throws Exception {
  byte[] passwdCorrect="AAAAAA".getBytes();
  byte[] passwdBad="BBBBBB".getBytes();
  DigestType digestCorrect=digestType;
  LedgerHandle lh=bkc.createLedger(3,2,digestCorrect,passwdCorrect);
  long ledgerId=lh.getId();
  for (int i=0; i < 100; i++) {
    lh.addEntry("foobar".getBytes());
  }
  lh.close();
  BookieSocketAddress bookieSrc=bs.get(0).getLocalAddress();
  bs.get(0).shutdown();
  bs.remove(0);
  startNewBookie();
  lh=bkc.openLedgerNoRecovery(ledgerId,digestCorrect,passwdCorrect);
  assertFalse("Should be entries missing",verifyFullyReplicated(lh,100));
  lh.close();
  ClientConfiguration adminConf=new ClientConfiguration();
  adminConf.setZkServers(zkUtil.getZooKeeperConnectString());
  adminConf.setBookieRecoveryDigestType(digestCorrect);
  adminConf.setBookieRecoveryPasswd(passwdBad);
  setMetastoreImplClass(adminConf);
  BookKeeperAdmin bka=new BookKeeperAdmin(adminConf);
  bka.recoverBookieData(bookieSrc,null);
  bka.close();
  lh=bkc.openLedgerNoRecovery(ledgerId,digestCorrect,passwdCorrect);
  assertTrue("Should be back to fully replication",verifyFullyReplicated(lh,100));
  lh.close();
  bookieSrc=bs.get(0).getLocalAddress();
  bs.get(0).shutdown();
  bs.remove(0);
  startNewBookie();
  lh=bkc.openLedgerNoRecovery(ledgerId,digestCorrect,passwdCorrect);
  assertFalse("Should be entries missing",verifyFullyReplicated(lh,100));
  lh.close();
  adminConf=new ClientConfiguration();
  adminConf.setZkServers(zkUtil.getZooKeeperConnectString());
  setMetastoreImplClass(adminConf);
  bka=new BookKeeperAdmin(adminConf);
  bka.recoverBookieData(bookieSrc,null);
  bka.close();
  lh=bkc.openLedgerNoRecovery(ledgerId,digestCorrect,passwdCorrect);
  assertTrue("Should be back to fully replication",verifyFullyReplicated(lh,100));
  lh.close();
}

</code></pre>

<br>
<pre class="type-2 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies boolean conditions
"></span><br>
@Test(timeout=60000) public void testSyncBookieRecoveryToRandomBookiesCheckForDupes() throws Exception {
  Random r=new Random();
  int numLedgers=3;
  List<LedgerHandle> lhs=createLedgers(numLedgers,numBookies,2);
  int numMsgs=10;
  writeEntriestoLedgers(numMsgs,0,lhs);
  LOG.info("Finished writing all ledger entries so shutdown one of the bookies.");
  int removeIndex=r.nextInt(bs.size());
  BookieSocketAddress bookieSrc=bs.get(removeIndex).getLocalAddress();
  bs.get(removeIndex).shutdown();
  bs.remove(removeIndex);
  startNewBookie();
  writeEntriestoLedgers(numMsgs,numMsgs,lhs);
  LOG.info("Now recover the data on the killed bookie (" + bookieSrc + ") and replicate it to a random available one");
  sync.value=false;
  bkAdmin.recoverBookieData(bookieSrc,null);
  assertFalse("Dupes exist in ensembles",findDupesInEnsembles(lhs));
  writeEntriestoLedgers(numMsgs,numMsgs * 2,lhs);
  for (  LedgerHandle lh : lhs) {
    assertTrue("Not fully replicated",verifyFullyReplicated(lh,numMsgs * 3));
    lh.close();
  }
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies boolean conditions
"></span><br>
/** 
 * Test recoverying the closed ledgers when the failed bookie server is in the last ensemble
 */
@Test(timeout=60000) public void testBookieRecoveryOnClosedLedgers() throws Exception {
  int numLedgers=3;
  List<LedgerHandle> lhs=createLedgers(numLedgers,numBookies,2);
  int numMsgs=10;
  writeEntriestoLedgers(numMsgs,0,lhs);
  closeLedgers(lhs);
  ArrayList<BookieSocketAddress> lastEnsemble=lhs.get(0).getLedgerMetadata().getEnsembles().entrySet().iterator().next().getValue();
  BookieSocketAddress bookieToKill=lastEnsemble.get(lastEnsemble.size() - 1);
  killBookie(bookieToKill);
  startNewBookie();
  BookieSocketAddress bookieDest=null;
  LOG.info("Now recover the data on the killed bookie (" + bookieToKill + ") and replicate it to a random available one");
  bkAdmin.recoverBookieData(bookieToKill,bookieDest);
  for (  LedgerHandle lh : lhs) {
    assertTrue("Not fully replicated",verifyFullyReplicated(lh,numMsgs));
    lh.close();
  }
}

</code></pre>

<br>
<pre class="type-8 type-4 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testBookieRecoveryOnOpenedLedgers() throws Exception {
  int numLedgers=3;
  List<LedgerHandle> lhs=createLedgers(numLedgers,numBookies,2);
  int numMsgs=10;
  writeEntriestoLedgers(numMsgs,0,lhs);
  ArrayList<BookieSocketAddress> lastEnsemble=lhs.get(0).getLedgerMetadata().getEnsembles().entrySet().iterator().next().getValue();
  BookieSocketAddress bookieToKill=lastEnsemble.get(lastEnsemble.size() - 1);
  killBookie(bookieToKill);
  startNewBookie();
  BookieSocketAddress bookieDest=null;
  LOG.info("Now recover the data on the killed bookie (" + bookieToKill + ") and replicate it to a random available one");
  bkAdmin.recoverBookieData(bookieToKill,bookieDest);
  for (  LedgerHandle lh : lhs) {
    assertTrue("Not fully replicated",verifyFullyReplicated(lh,numMsgs));
  }
  try {
    writeEntriestoLedgers(numMsgs,0,lhs);
    fail("should not reach here");
  }
 catch (  Exception e) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.bookkeeper.client.LedgerRecoveryTest </h4><pre class="type-2 type-8 type-3 type-4 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * {@link https://issues.apache.org/jira/browse/BOOKKEEPER-355}A recovery during a rolling restart shouldn't affect the ability
 * to recovery the ledger later.
 * We have a ledger on ensemble B1,B2,B3.
 * The sequence of events is
 * 1. B1 brought down for maintenance
 * 2. Ledger recovery started
 * 3. B2 answers read last confirmed.
 * 4. B1 replaced in ensemble by B4
 * 5. Write to B4 fails for some reason
 * 6. B1 comes back up.
 * 7. B2 goes down for maintenance.
 * 8. Ledger recovery starts (ledger is now unavailable)
 */
@Test(timeout=60000) public void testLedgerRecoveryWithRollingRestart() throws Exception {
  LedgerHandle lhbefore=bkc.createLedger(numBookies,2,digestType,"".getBytes());
  for (int i=0; i < (numBookies * 3) + 1; i++) {
    lhbefore.addEntry("data".getBytes());
  }
  ServerConfiguration conf=newServerConfiguration();
  Bookie deadBookie1=new Bookie(conf){
    @Override public void recoveryAddEntry(    ByteBuffer entry,    WriteCallback cb,    Object ctx,    byte[] masterKey) throws IOException, BookieException {
      throw new IOException("Couldn't write for some reason");
    }
  }
;
  bsConfs.add(conf);
  bs.add(startBookie(conf,deadBookie1));
  BookieSocketAddress bookie1=lhbefore.getLedgerMetadata().currentEnsemble.get(0);
  ServerConfiguration conf1=killBookie(bookie1);
  try {
    bkc.openLedger(lhbefore.getId(),digestType,"".getBytes());
    fail("Shouldn't be able to open ledger, there should be entries missing");
  }
 catch (  BKException.BKLedgerRecoveryException e) {
  }
  bsConfs.add(conf1);
  bs.add(startBookie(conf1));
  BookieSocketAddress bookie2=lhbefore.getLedgerMetadata().currentEnsemble.get(1);
  ServerConfiguration conf2=killBookie(bookie2);
  final AtomicInteger returnCode=new AtomicInteger(0);
  final CountDownLatch openLatch=new CountDownLatch(1);
  bkc.asyncOpenLedger(lhbefore.getId(),digestType,"".getBytes(),new AsyncCallback.OpenCallback(){
    public void openComplete(    int rc,    LedgerHandle lh,    Object ctx){
      returnCode.set(rc);
      openLatch.countDown();
      if (rc == BKException.Code.OK) {
        try {
          lh.close();
        }
 catch (        Exception e) {
          LOG.error("Exception closing ledger handle",e);
        }
      }
    }
  }
,null);
  assertTrue("Open call should have completed",openLatch.await(5,TimeUnit.SECONDS));
  assertFalse("Open should not have succeeded",returnCode.get() == BKException.Code.OK);
  bsConfs.add(conf2);
  bs.add(startBookie(conf2));
  LedgerHandle lhafter=bkc.openLedger(lhbefore.getId(),digestType,"".getBytes());
  assertEquals("Fenced ledger should have correct lastAddConfirmed",lhbefore.getLastAddConfirmed(),lhafter.getLastAddConfirmed());
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.bookkeeper.client.ListLedgersTest </h4><pre class="type-3 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
"></span><br>
@Test(timeout=60000) public void testEmptyList() throws Exception {
  ClientConfiguration conf=new ClientConfiguration().setZkServers(zkUtil.getZooKeeperConnectString());
  BookKeeperAdmin admin=new BookKeeperAdmin(zkUtil.getZooKeeperConnectString());
  Iterable<Long> iterable=admin.listLedgers();
  Assert.assertFalse("There should be no ledger",iterable.iterator().hasNext());
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies boolean conditions
"></span><br>
@Test(timeout=60000) public void testListLedgers() throws Exception {
  int numOfLedgers=10;
  ClientConfiguration conf=new ClientConfiguration().setZkServers(zkUtil.getZooKeeperConnectString());
  BookKeeper bkc=new BookKeeper(conf);
  for (int i=0; i < numOfLedgers; i++) {
    bkc.createLedger(digestType,"testPasswd".getBytes()).close();
  }
  BookKeeperAdmin admin=new BookKeeperAdmin(zkUtil.getZooKeeperConnectString());
  Iterable<Long> iterable=admin.listLedgers();
  int counter=0;
  for (  Long lId : iterable) {
    counter++;
  }
  Assert.assertTrue("Wrong number of ledgers: " + numOfLedgers,counter == numOfLedgers);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.bookkeeper.client.RoundRobinDistributionScheduleTest </h4><pre class="type-3 type-4 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testDistributionSchedule() throws Exception {
  RoundRobinDistributionSchedule schedule=new RoundRobinDistributionSchedule(3,2,5);
  List<Integer> wSet=schedule.getWriteSet(1);
  assertEquals("Write set is wrong size",wSet.size(),3);
  DistributionSchedule.AckSet ackSet=schedule.getAckSet();
  assertFalse("Shouldn't ack yet",ackSet.addBookieAndCheck(wSet.get(0)));
  assertFalse("Shouldn't ack yet",ackSet.addBookieAndCheck(wSet.get(0)));
  assertTrue("Should ack after 2 unique",ackSet.addBookieAndCheck(wSet.get(2)));
  assertTrue("Should still be acking",ackSet.addBookieAndCheck(wSet.get(1)));
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.bookkeeper.client.SlowBookieTest </h4><pre class="type-4 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testManyBookieFailureWithSlowBookies() throws Exception {
  ClientConfiguration conf=new ClientConfiguration();
  conf.setZkServers(zkUtil.getZooKeeperConnectString()).setReadTimeout(5);
  BookKeeper bkc=new BookKeeper(conf);
  byte[] pwd=new byte[]{};
  final LedgerHandle lh=bkc.createLedger(4,3,1,BookKeeper.DigestType.CRC32,pwd);
  final AtomicBoolean finished=new AtomicBoolean(false);
  final AtomicBoolean failTest=new AtomicBoolean(false);
  final byte[] entry="Test Entry".getBytes();
  Thread t=new Thread(){
    public void run(){
      try {
        while (!finished.get()) {
          lh.addEntry(entry);
        }
      }
 catch (      Exception e) {
        LOG.error("Exception in add entry thread",e);
        failTest.set(true);
      }
    }
  }
;
  t.start();
  final CountDownLatch b0latch=new CountDownLatch(1);
  final CountDownLatch b1latch=new CountDownLatch(1);
  startNewBookie();
  startNewBookie();
  sleepBookie(getBookie(0),b0latch);
  sleepBookie(getBookie(1),b1latch);
  Thread.sleep(10000);
  b0latch.countDown();
  b1latch.countDown();
  finished.set(true);
  t.join();
  assertFalse(failTest.get());
  lh.close();
  LedgerHandle lh2=bkc.openLedger(lh.getId(),BookKeeper.DigestType.CRC32,pwd);
  LedgerChecker lc=new LedgerChecker(bkc);
  final CountDownLatch checklatch=new CountDownLatch(1);
  final AtomicInteger numFragments=new AtomicInteger(-1);
  lc.checkLedger(lh2,new GenericCallback<Set<LedgerFragment>>(){
    public void operationComplete(    int rc,    Set<LedgerFragment> fragments){
      LOG.debug("Checked ledgers returned {} {}",rc,fragments);
      if (rc == BKException.Code.OK) {
        numFragments.set(fragments.size());
      }
      checklatch.countDown();
    }
  }
);
  checklatch.await();
  assertEquals("There should be no missing fragments",0,numFragments.get());
}

</code></pre>

<br>
<pre class="type-4 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testBookieFailureWithSlowBookie() throws Exception {
  ClientConfiguration conf=new ClientConfiguration();
  conf.setZkServers(zkUtil.getZooKeeperConnectString()).setReadTimeout(5);
  BookKeeper bkc=new BookKeeper(conf);
  byte[] pwd=new byte[]{};
  final LedgerHandle lh=bkc.createLedger(4,3,2,BookKeeper.DigestType.CRC32,pwd);
  final AtomicBoolean finished=new AtomicBoolean(false);
  final AtomicBoolean failTest=new AtomicBoolean(false);
  final byte[] entry="Test Entry".getBytes();
  Thread t=new Thread(){
    public void run(){
      try {
        while (!finished.get()) {
          lh.addEntry(entry);
        }
      }
 catch (      Exception e) {
        LOG.error("Exception in add entry thread",e);
        failTest.set(true);
      }
    }
  }
;
  t.start();
  final CountDownLatch b0latch=new CountDownLatch(1);
  startNewBookie();
  sleepBookie(getBookie(0),b0latch);
  Thread.sleep(10000);
  b0latch.countDown();
  finished.set(true);
  t.join();
  assertFalse(failTest.get());
  lh.close();
  LedgerHandle lh2=bkc.openLedger(lh.getId(),BookKeeper.DigestType.CRC32,pwd);
  LedgerChecker lc=new LedgerChecker(bkc);
  final CountDownLatch checklatch=new CountDownLatch(1);
  final AtomicInteger numFragments=new AtomicInteger(-1);
  lc.checkLedger(lh2,new GenericCallback<Set<LedgerFragment>>(){
    public void operationComplete(    int rc,    Set<LedgerFragment> fragments){
      LOG.debug("Checked ledgers returned {} {}",rc,fragments);
      if (rc == BKException.Code.OK) {
        numFragments.set(fragments.size());
      }
      checklatch.countDown();
    }
  }
);
  checklatch.await();
  assertEquals("There should be no missing fragments",0,numFragments.get());
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.bookkeeper.client.TestFencing </h4><pre class="type-2 type-8 type-3 type-4 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Basic fencing test. Create ledger, write to it,
 * open ledger, write again (should fail).
 */
@Test(timeout=60000) public void testBasicFencing() throws Exception {
  LedgerHandle writelh=null;
  writelh=bkc.createLedger(digestType,"password".getBytes());
  String tmp="BookKeeper is cool!";
  for (int i=0; i < 10; i++) {
    writelh.addEntry(tmp.getBytes());
  }
  LedgerHandle readlh=bkc.openLedger(writelh.getId(),digestType,"password".getBytes());
  try {
    writelh.addEntry(tmp.getBytes());
    LOG.error("Should have thrown an exception");
    fail("Should have thrown an exception when trying to write");
  }
 catch (  BKException.BKLedgerFencedException e) {
  }
  assertTrue("Has not recovered correctly: " + readlh.getLastAddConfirmed() + " original "+ writelh.getLastAddConfirmed(),readlh.getLastAddConfirmed() == writelh.getLastAddConfirmed());
}

</code></pre>

<br>
<pre class="type-2 type-11 type-3 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions in iterations
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
"></span><br>
/** 
 * Try to open a ledger many times in parallel.
 * All opens should result in a ledger with an equals number of
 * entries.
 */
@Test(timeout=60000) public void testManyOpenParallel() throws Exception {
  final LedgerHandle writelh=bkc.createLedger(digestType,"".getBytes());
  final int numRecovery=10;
  final String tmp="BookKeeper is cool!";
  final CountDownLatch latch=new CountDownLatch(numRecovery);
  Thread writethread=new Thread(){
    public void run(){
      try {
        while (true) {
          writelh.addEntry(tmp.getBytes());
          latch.countDown();
        }
      }
 catch (      Exception e) {
        LOG.info("Exception adding entry",e);
      }
    }
  }
;
  writethread.start();
  CyclicBarrier barrier=new CyclicBarrier(numRecovery + 1);
  LedgerOpenThread threads[]=new LedgerOpenThread[numRecovery];
  for (int i=0; i < numRecovery; i++) {
    threads[i]=new LedgerOpenThread(digestType,writelh.getId(),barrier);
    threads[i].start();
  }
  latch.await();
  barrier.await();
  writethread.join();
  long lastConfirmed=writelh.getLastAddConfirmed();
  for (int i=0; i < numRecovery; i++) {
    threads[i].join();
    assertTrue("Added confirmed is incorrect",lastConfirmed <= threads[i].getLastConfirmedEntry());
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.bookkeeper.client.TestRackawareEnsemblePlacementPolicy </h4><pre class="type-2 type-8 type-3 type-4 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testNewEnsembleWithMultipleRacks() throws Exception {
  BookieSocketAddress addr1=new BookieSocketAddress("127.0.0.1",3181);
  BookieSocketAddress addr2=new BookieSocketAddress("127.0.0.2",3181);
  BookieSocketAddress addr3=new BookieSocketAddress("127.0.0.3",3181);
  BookieSocketAddress addr4=new BookieSocketAddress("127.0.0.4",3181);
  StaticDNSResolver.addNodeToRack(addr1.getSocketAddress().getAddress().getHostAddress(),NetworkTopology.DEFAULT_RACK);
  StaticDNSResolver.addNodeToRack(addr2.getSocketAddress().getAddress().getHostAddress(),"/r2");
  StaticDNSResolver.addNodeToRack(addr3.getSocketAddress().getAddress().getHostAddress(),"/r2");
  StaticDNSResolver.addNodeToRack(addr4.getSocketAddress().getAddress().getHostAddress(),"/r2");
  Set<BookieSocketAddress> addrs=new HashSet<BookieSocketAddress>();
  addrs.add(addr1);
  addrs.add(addr2);
  addrs.add(addr3);
  addrs.add(addr4);
  repp.onClusterChanged(addrs,new HashSet<BookieSocketAddress>());
  try {
    ArrayList<BookieSocketAddress> ensemble=repp.newEnsemble(3,2,new HashSet<BookieSocketAddress>());
    int numCovered=getNumCoveredWriteQuorums(ensemble,2);
    assertTrue(numCovered >= 1 && numCovered < 3);
    ArrayList<BookieSocketAddress> ensemble2=repp.newEnsemble(4,2,new HashSet<BookieSocketAddress>());
    numCovered=getNumCoveredWriteQuorums(ensemble2,2);
    assertTrue(numCovered >= 1 && numCovered < 3);
  }
 catch (  BKNotEnoughBookiesException bnebe) {
    fail("Should not get not enough bookies exception even there is only one rack.");
  }
}

</code></pre>

<br>
<pre class="type-3 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
"></span><br>
@Test(timeout=60000) public void testReplaceBookieWithEnoughBookiesInDifferentRack() throws Exception {
  BookieSocketAddress addr1=new BookieSocketAddress("127.0.0.1",3181);
  BookieSocketAddress addr2=new BookieSocketAddress("127.0.0.2",3181);
  BookieSocketAddress addr3=new BookieSocketAddress("127.0.0.3",3181);
  BookieSocketAddress addr4=new BookieSocketAddress("127.0.0.4",3181);
  StaticDNSResolver.addNodeToRack(addr1.getSocketAddress().getAddress().getHostAddress(),NetworkTopology.DEFAULT_RACK);
  StaticDNSResolver.addNodeToRack(addr2.getSocketAddress().getAddress().getHostAddress(),"/r2");
  StaticDNSResolver.addNodeToRack(addr3.getSocketAddress().getAddress().getHostAddress(),"/r3");
  StaticDNSResolver.addNodeToRack(addr4.getSocketAddress().getAddress().getHostAddress(),"/r4");
  Set<BookieSocketAddress> addrs=new HashSet<BookieSocketAddress>();
  addrs.add(addr1);
  addrs.add(addr2);
  addrs.add(addr3);
  addrs.add(addr4);
  repp.onClusterChanged(addrs,new HashSet<BookieSocketAddress>());
  Set<BookieSocketAddress> excludedAddrs=new HashSet<BookieSocketAddress>();
  excludedAddrs.add(addr1);
  BookieSocketAddress replacedBookie=repp.replaceBookie(addr2,excludedAddrs);
  assertFalse(addr1.equals(replacedBookie));
  assertTrue(addr3.equals(replacedBookie) || addr4.equals(replacedBookie));
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.bookkeeper.client.TestReadTimeout </h4><pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies boolean conditions
"></span><br>
@SuppressWarnings("deprecation") @Test(timeout=60000) public void testReadTimeout() throws Exception {
  final AtomicBoolean completed=new AtomicBoolean(false);
  LedgerHandle writelh=bkc.createLedger(3,3,digestType,"testPasswd".getBytes());
  String tmp="Foobar";
  final int numEntries=10;
  for (int i=0; i < numEntries; i++) {
    writelh.addEntry(tmp.getBytes());
  }
  Set<BookieSocketAddress> beforeSet=new HashSet<BookieSocketAddress>();
  for (  BookieSocketAddress addr : writelh.getLedgerMetadata().getEnsemble(numEntries)) {
    beforeSet.add(addr);
  }
  final BookieSocketAddress bookieToSleep=writelh.getLedgerMetadata().getEnsemble(numEntries).get(0);
  int sleeptime=baseClientConf.getReadTimeout() * 3;
  CountDownLatch latch=sleepBookie(bookieToSleep,sleeptime);
  latch.await();
  writelh.asyncAddEntry(tmp.getBytes(),new AddCallback(){
    public void addComplete(    int rc,    LedgerHandle lh,    long entryId,    Object ctx){
      completed.set(true);
    }
  }
,null);
  Thread.sleep((baseClientConf.getReadTimeout() * 3) * 1000);
  Assert.assertTrue("Write request did not finish",completed.get());
  Set<BookieSocketAddress> afterSet=new HashSet<BookieSocketAddress>();
  for (  BookieSocketAddress addr : writelh.getLedgerMetadata().getEnsemble(numEntries + 1)) {
    afterSet.add(addr);
  }
  beforeSet.removeAll(afterSet);
  Assert.assertTrue("Bookie set should not match",beforeSet.size() != 0);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.bookkeeper.client.TestSpeculativeRead </h4><pre class="type-3 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
"></span><br>
/** 
 * Test that if more than one replica is down, we can still read, as long as the quorum
 * size is larger than the number of down replicas.
 */
@Test(timeout=60000) public void testSpeculativeReadMultipleReplicasDown() throws Exception {
  long id=getLedgerToRead(5,5);
  int timeout=5000;
  BookKeeper bkspec=createClient(timeout);
  LedgerHandle l=bkspec.openLedger(id,digestType,passwd);
  CountDownLatch sleepLatch=new CountDownLatch(1);
  sleepBookie(l.getLedgerMetadata().getEnsembles().get(0L).get(1),sleepLatch);
  sleepBookie(l.getLedgerMetadata().getEnsembles().get(0L).get(2),sleepLatch);
  sleepBookie(l.getLedgerMetadata().getEnsembles().get(0L).get(4),sleepLatch);
  try {
    LatchCallback latch0=new LatchCallback();
    l.asyncReadEntries(0,0,latch0,null);
    latch0.expectSuccess(timeout / 2);
    LatchCallback latch1=new LatchCallback();
    l.asyncReadEntries(1,1,latch1,null);
    latch1.expectTimeout(timeout);
    latch1.expectSuccess(timeout * 2);
    LOG.info("Timeout {} latch1 duration {}",timeout,latch1.getDuration());
    assertTrue("should have taken longer than two timeouts, but less than 3",latch1.getDuration() >= timeout * 2 && latch1.getDuration() < timeout * 3);
    LatchCallback latch2=new LatchCallback();
    l.asyncReadEntries(2,2,latch2,null);
    latch2.expectTimeout(timeout / 2);
    latch2.expectSuccess(timeout);
    LOG.info("Timeout {} latch2 duration {}",timeout,latch2.getDuration());
    assertTrue("should have taken longer than one timeout, but less than 2",latch2.getDuration() >= timeout && latch2.getDuration() < timeout * 2);
    LatchCallback latch3=new LatchCallback();
    l.asyncReadEntries(3,3,latch3,null);
    latch3.expectSuccess(timeout / 2);
    LatchCallback latch4=new LatchCallback();
    l.asyncReadEntries(4,4,latch4,null);
    latch4.expectTimeout(timeout / 2);
    latch4.expectSuccess(timeout);
    LOG.info("Timeout {} latch4 duration {}",timeout,latch4.getDuration());
    assertTrue("should have taken longer than one timeout, but less than 2",latch4.getDuration() >= timeout && latch4.getDuration() < timeout * 2);
  }
  finally {
    sleepLatch.countDown();
    l.close();
    bkspec.close();
  }
}

</code></pre>

<br>
<pre class="type-2 type-6 type-3 type-4 type-7 type-13 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values related to public fields.">PublicFieldVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions inside branch conditions
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects are null
- Verifies values related to public fields.
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Unit test for the speculative read scheduling method
 */
@Test(timeout=60000) public void testSpeculativeReadScheduling() throws Exception {
  long id=getLedgerToRead(3,2);
  int timeout=1000;
  BookKeeper bkspec=createClient(timeout);
  LedgerHandle l=bkspec.openLedger(id,digestType,passwd);
  ArrayList<BookieSocketAddress> ensemble=l.getLedgerMetadata().getEnsembles().get(0L);
  Set<BookieSocketAddress> allHosts=new HashSet<BookieSocketAddress>(ensemble);
  Set<BookieSocketAddress> noHost=new HashSet<BookieSocketAddress>();
  Set<BookieSocketAddress> secondHostOnly=new HashSet<BookieSocketAddress>();
  secondHostOnly.add(ensemble.get(1));
  PendingReadOp.LedgerEntryRequest req0=null, req2=null, req4=null;
  try {
    LatchCallback latch0=new LatchCallback();
    PendingReadOp op=new PendingReadOp(l,bkspec.scheduler,0,5,latch0,null);
    req0=op.new LedgerEntryRequest(ensemble,l.getId(),0);
    assertTrue("Should have sent to first",req0.maybeSendSpeculativeRead(allHosts).equals(ensemble.get(0)));
    assertNull("Should not have sent another",req0.maybeSendSpeculativeRead(allHosts));
    req2=op.new LedgerEntryRequest(ensemble,l.getId(),2);
    assertTrue("Should have sent to third",req2.maybeSendSpeculativeRead(noHost).equals(ensemble.get(2)));
    assertTrue("Should have sent to first",req2.maybeSendSpeculativeRead(secondHostOnly).equals(ensemble.get(0)));
    req4=op.new LedgerEntryRequest(ensemble,l.getId(),4);
    assertTrue("Should have sent to second",req4.maybeSendSpeculativeRead(noHost).equals(ensemble.get(1)));
    assertNull("Should not have sent another",req4.maybeSendSpeculativeRead(secondHostOnly));
  }
  finally {
    for (    PendingReadOp.LedgerEntryRequest req : new PendingReadOp.LedgerEntryRequest[]{req0,req2,req4}) {
      if (req != null) {
        int i=0;
        while (!req.isComplete()) {
          if (i++ > 10) {
            break;
          }
          Thread.sleep(1000);
        }
        assertTrue("Request should be done",req0.isComplete());
      }
    }
    l.close();
    bkspec.close();
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.bookkeeper.client.TestTryReadLastConfirmed </h4><pre class="type-2 type-11 type-3 type-4 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions in iterations
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testTryReadLaCWhenSomeBookiesDown() throws Exception {
  final int numEntries=3;
  final int ensembleSize=3;
  final LedgerHandle lh=bkc.createLedger(ensembleSize,1,1,digestType,"".getBytes());
  LedgerHandle readLh=bkc.openLedgerNoRecovery(lh.getId(),digestType,"".getBytes());
  assertEquals(LedgerHandle.INVALID_ENTRY_ID,readLh.getLastAddConfirmed());
  for (int i=0; i < numEntries; i++) {
    lh.addEntry(("data" + i).getBytes());
  }
  for (int i=0; i < numEntries; i++) {
    ServerConfiguration[] confs=new ServerConfiguration[ensembleSize - 1];
    for (int j=0; j < ensembleSize - 1; j++) {
      int idx=(i + 1 + j) % ensembleSize;
      confs[j]=killBookie(lh.getLedgerMetadata().currentEnsemble.get(idx));
    }
    final AtomicBoolean success=new AtomicBoolean(false);
    final AtomicInteger numCallbacks=new AtomicInteger(0);
    final CountDownLatch latch=new CountDownLatch(1);
    final int entryId=i;
    readLh.asyncTryReadLastConfirmed(new AsyncCallback.ReadLastConfirmedCallback(){
      @Override public void readLastConfirmedComplete(      int rc,      long lastConfirmed,      Object ctx){
        numCallbacks.incrementAndGet();
        if (BKException.Code.OK == rc) {
          success.set(lastConfirmed == (entryId - 1));
        }
 else {
          success.set(false);
        }
        latch.countDown();
      }
    }
,null);
    latch.await();
    assertTrue(success.get());
    assertTrue(numCallbacks.get() == 1);
    for (    ServerConfiguration conf : confs) {
      bs.add(startBookie(conf));
      bsConfs.add(conf);
    }
  }
  lh.close();
  readLh.close();
}

</code></pre>

<br>
<pre class="type-2 type-3 type-4 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testTryReadLACWhenAllBookiesDown() throws Exception {
  final int numEntries=2;
  final int ensembleSize=3;
  final LedgerHandle lh=bkc.createLedger(ensembleSize,1,1,digestType,"".getBytes());
  LedgerHandle readLh=bkc.openLedgerNoRecovery(lh.getId(),digestType,"".getBytes());
  assertEquals(LedgerHandle.INVALID_ENTRY_ID,readLh.getLastAddConfirmed());
  for (int i=0; i < numEntries; i++) {
    lh.addEntry(("data" + i).getBytes());
  }
  for (int i=0; i < ensembleSize; i++) {
    killBookie(lh.getLedgerMetadata().currentEnsemble.get(i));
  }
  final AtomicBoolean success=new AtomicBoolean(false);
  final AtomicInteger numCallbacks=new AtomicInteger(0);
  final CountDownLatch latch=new CountDownLatch(1);
  readLh.asyncTryReadLastConfirmed(new AsyncCallback.ReadLastConfirmedCallback(){
    @Override public void readLastConfirmedComplete(    int rc,    long lastConfirmed,    Object ctx){
      logger.info("ReadLastConfirmedComplete : rc = {}, lac = {}.",rc,lastConfirmed);
      numCallbacks.incrementAndGet();
      if (BKException.Code.OK == rc) {
        success.set(lastConfirmed == LedgerHandle.INVALID_ENTRY_ID);
      }
 else {
        success.set(false);
      }
      latch.countDown();
    }
  }
,null);
  latch.await();
  TimeUnit.SECONDS.sleep(2);
  assertFalse(success.get());
  assertTrue(numCallbacks.get() == 1);
  lh.close();
  readLh.close();
}

</code></pre>

<br>
<pre class="type-2 type-3 type-4 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testTryReadLACWhenAllBookiesUp() throws Exception {
  final int numEntries=3;
  final LedgerHandle lh=bkc.createLedger(3,3,1,digestType,"".getBytes());
  LedgerHandle readLh=bkc.openLedgerNoRecovery(lh.getId(),digestType,"".getBytes());
  assertEquals(LedgerHandle.INVALID_ENTRY_ID,readLh.getLastAddConfirmed());
  for (int i=0; i < numEntries; i++) {
    lh.addEntry(("data" + i).getBytes());
  }
  final AtomicBoolean success=new AtomicBoolean(false);
  final AtomicInteger numCallbacks=new AtomicInteger(0);
  final CountDownLatch latch1=new CountDownLatch(1);
  readLh.asyncTryReadLastConfirmed(new AsyncCallback.ReadLastConfirmedCallback(){
    @Override public void readLastConfirmedComplete(    int rc,    long lastConfirmed,    Object ctx){
      numCallbacks.incrementAndGet();
      if (BKException.Code.OK == rc) {
        success.set(true);
      }
 else {
        success.set(false);
      }
      latch1.countDown();
    }
  }
,null);
  latch1.await();
  TimeUnit.SECONDS.sleep(2);
  assertTrue(success.get());
  assertTrue(numCallbacks.get() == 1);
  assertEquals(numEntries - 2,readLh.getLastAddConfirmed());
  success.set(false);
  numCallbacks.set(0);
  final CountDownLatch latch2=new CountDownLatch(1);
  readLh.asyncTryReadLastConfirmed(new AsyncCallback.ReadLastConfirmedCallback(){
    @Override public void readLastConfirmedComplete(    int rc,    long lastConfirmed,    Object ctx){
      numCallbacks.incrementAndGet();
      if (BKException.Code.OK == rc && lastConfirmed == (numEntries - 2)) {
        success.set(true);
      }
 else {
        success.set(false);
      }
      latch2.countDown();
    }
  }
,null);
  latch2.await();
  TimeUnit.SECONDS.sleep(2);
  assertTrue(success.get());
  assertTrue(numCallbacks.get() == 1);
  assertEquals(numEntries - 2,readLh.getLastAddConfirmed());
  lh.close();
  readLh.close();
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.bookkeeper.client.TestWatchEnsembleChange </h4><pre class="type-2 type-4 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testWatchMetadataRemoval() throws Exception {
  LedgerManagerFactory factory=ReflectionUtils.newInstance(lmFactoryCls);
  factory.initialize(baseConf,super.zkc,factory.getCurrentVersion());
  final LedgerManager manager=factory.newLedgerManager();
  LedgerIdGenerator idGenerator=factory.newLedgerIdGenerator();
  final ByteBuffer bbLedgerId=ByteBuffer.allocate(8);
  final CountDownLatch createLatch=new CountDownLatch(1);
  final CountDownLatch removeLatch=new CountDownLatch(1);
  idGenerator.generateLedgerId(new GenericCallback<Long>(){
    @Override public void operationComplete(    int rc,    final Long lid){
      manager.createLedgerMetadata(lid,new LedgerMetadata(4,2,2,digestType,"fpj was here".getBytes()),new BookkeeperInternalCallbacks.GenericCallback<Void>(){
        @Override public void operationComplete(        int rc,        Void result){
          bbLedgerId.putLong(lid);
          bbLedgerId.flip();
          createLatch.countDown();
        }
      }
);
    }
  }
);
  assertTrue(createLatch.await(2000,TimeUnit.MILLISECONDS));
  final long createdLid=bbLedgerId.getLong();
  manager.registerLedgerMetadataListener(createdLid,new LedgerMetadataListener(){
    @Override public void onChanged(    long ledgerId,    LedgerMetadata metadata){
      assertEquals(ledgerId,createdLid);
      assertEquals(metadata,null);
      removeLatch.countDown();
    }
  }
);
  manager.removeLedgerMetadata(createdLid,Version.ANY,new BookkeeperInternalCallbacks.GenericCallback<Void>(){
    @Override public void operationComplete(    int rc,    Void result){
      assertEquals(rc,BKException.Code.OK);
    }
  }
);
  assertTrue(removeLatch.await(2000,TimeUnit.MILLISECONDS));
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.bookkeeper.client.UpdateLedgerOpTest </h4><pre class="type-2 type-3 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
"></span><br>
/** 
 * Tests verifies update bookie id when there are many ledgers.
 */
@Test(timeout=120000) public void testManyLedgers() throws Exception {
  BookKeeper bk=new BookKeeper(baseClientConf,zkc);
  BookKeeperAdmin bkadmin=new BookKeeperAdmin(bk);
  LOG.info("Create ledger and add entries to it");
  List<LedgerHandle> ledgers=new ArrayList<LedgerHandle>();
  LedgerHandle lh1=createLedgerWithEntries(bk,0);
  ledgers.add(lh1);
  for (int i=0; i < 99; i++) {
    ledgers.add(createLedgerWithEntries(bk,0));
  }
  ArrayList<BookieSocketAddress> ensemble=lh1.getLedgerMetadata().getEnsemble(0);
  BookieSocketAddress curBookieAddr=ensemble.get(0);
  baseConf.setUseHostNameAsBookieID(true);
  BookieSocketAddress curBookieId=Bookie.getBookieAddress(baseConf);
  BookieSocketAddress toBookieAddr=new BookieSocketAddress(curBookieId.getHostname() + ":" + curBookieAddr.getPort());
  UpdateLedgerOp updateLedgerOp=new UpdateLedgerOp(bk,bkadmin);
  updateLedgerOp.updateBookieIdInLedgers(curBookieAddr,toBookieAddr,5,Integer.MIN_VALUE,progressable);
  for (  LedgerHandle lh : ledgers) {
    lh.close();
    LedgerHandle openLedger=bk.openLedger(lh.getId(),digestType,PASSWORD.getBytes());
    ensemble=openLedger.getLedgerMetadata().getEnsemble(0);
    Assert.assertTrue("Failed to update the ledger metadata to use bookie host name",ensemble.contains(toBookieAddr));
    Assert.assertFalse("Failed to update the ledger metadata to use bookie host name",ensemble.contains(curBookieAddr));
  }
}

</code></pre>

<br>
<pre class="type-2 type-3 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
"></span><br>
/** 
 * Tests verifies simultaneous flow between adding entries and rename of
 * bookie id
 */
@Test(timeout=120000) public void testRenameWhenAddEntryInProgress() throws Exception {
  final BookKeeper bk=new BookKeeper(baseClientConf,zkc);
  BookKeeperAdmin bkadmin=new BookKeeperAdmin(bk);
  LOG.info("Create ledger and add entries to it");
  final int numOfEntries=5000;
  final CountDownLatch latch=new CountDownLatch(numOfEntries);
  final AtomicInteger rc=new AtomicInteger(BKException.Code.OK);
  final LedgerHandle lh=createLedgerWithEntries(bk,1);
  latch.countDown();
  Thread th=new Thread(){
    public void run(){
      final AddCallback cb=new AddCallback(){
        public void addComplete(        int rccb,        LedgerHandle lh,        long entryId,        Object ctx){
          rc.compareAndSet(BKException.Code.OK,rccb);
          if (entryId % 100 == 0) {
            LOG.info("Added entries till entryId:{}",entryId);
          }
          latch.countDown();
        }
      }
;
      for (int i=1; i < numOfEntries; i++) {
        lh.asyncAddEntry(("foobar" + i).getBytes(),cb,null);
      }
    }
  }
;
  th.start();
  ArrayList<BookieSocketAddress> ensemble=lh.getLedgerMetadata().getEnsemble(0);
  BookieSocketAddress curBookieAddr=ensemble.get(0);
  BookieSocketAddress toBookieAddr=new BookieSocketAddress("localhost:" + curBookieAddr.getPort());
  UpdateLedgerOp updateLedgerOp=new UpdateLedgerOp(bk,bkadmin);
  updateLedgerOp.updateBookieIdInLedgers(curBookieAddr,toBookieAddr,5,100,progressable);
  if (!latch.await(120,TimeUnit.SECONDS)) {
    throw new Exception("Entries took too long to add");
  }
  if (rc.get() != BKException.Code.OK) {
    throw BKException.create(rc.get());
  }
  lh.close();
  LedgerHandle openLedger=bk.openLedger(lh.getId(),digestType,PASSWORD.getBytes());
  ensemble=openLedger.getLedgerMetadata().getEnsemble(0);
  Assert.assertTrue("Failed to update the ledger metadata to use bookie host name",ensemble.contains(toBookieAddr));
}

</code></pre>

<br>
<pre class="type-2 type-3 type-4 type-7 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects are null
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Tests verifies the ensemble reformation after updating the bookie id in
 * the existing ensemble
 */
@Test(timeout=120000) public void testChangeEnsembleAfterRenaming() throws Exception {
  BookKeeper bk=new BookKeeper(baseClientConf,zkc);
  BookKeeperAdmin bkadmin=new BookKeeperAdmin(bk);
  LOG.info("Create ledger and add entries to it");
  LedgerHandle lh=createLedgerWithEntries(bk,100);
  BookieServer bookieServer=bs.get(0);
  ArrayList<BookieSocketAddress> ensemble=lh.getLedgerMetadata().getEnsemble(0);
  BookieSocketAddress curBookieAddr=null;
  for (  BookieSocketAddress bookieSocketAddress : ensemble) {
    if (bookieServer.getLocalAddress().equals(bookieSocketAddress)) {
      curBookieAddr=bookieSocketAddress;
    }
  }
  Assert.assertNotNull("Couldn't find the bookie in ledger metadata!",curBookieAddr);
  baseConf.setUseHostNameAsBookieID(true);
  BookieSocketAddress toBookieId=Bookie.getBookieAddress(baseConf);
  BookieSocketAddress toBookieAddr=new BookieSocketAddress(toBookieId.getHostname() + ":" + curBookieAddr.getPort());
  UpdateLedgerOp updateLedgerOp=new UpdateLedgerOp(bk,bkadmin);
  updateLedgerOp.updateBookieIdInLedgers(curBookieAddr,toBookieAddr,5,100,progressable);
  bookieServer.shutdown();
  ServerConfiguration serverConf1=newServerConfiguration();
  bsConfs.add(serverConf1);
  bs.add(startBookie(serverConf1));
  final CountDownLatch latch=new CountDownLatch(1);
  final AtomicInteger rc=new AtomicInteger(BKException.Code.OK);
  lh.asyncAddEntry("foobar".getBytes(),new AddCallback(){
    @Override public void addComplete(    int rccb,    LedgerHandle lh,    long entryId,    Object ctx){
      rc.compareAndSet(BKException.Code.OK,rccb);
      latch.countDown();
    }
  }
,null);
  if (!latch.await(30,TimeUnit.SECONDS)) {
    throw new Exception("Entries took too long to add");
  }
  if (rc.get() != BKException.Code.OK) {
    throw BKException.create(rc.get());
  }
  lh.close();
  LedgerHandle openLedger=bk.openLedger(lh.getId(),digestType,PASSWORD.getBytes());
  final LedgerMetadata ledgerMetadata=openLedger.getLedgerMetadata();
  Assert.assertEquals("Failed to reform ensemble!",2,ledgerMetadata.getEnsembles().size());
  ensemble=ledgerMetadata.getEnsemble(0);
  Assert.assertTrue("Failed to update the ledger metadata to use bookie host name",ensemble.contains(toBookieAddr));
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.bookkeeper.meta.GcLedgersTest </h4><pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies boolean conditions
"></span><br>
@Test(timeout=60000) public void testGarbageCollectLedgers() throws Exception {
  int numLedgers=100;
  int numRemovedLedgers=10;
  final Set<Long> createdLedgers=new HashSet<Long>();
  final Set<Long> removedLedgers=new HashSet<Long>();
  createLedgers(numLedgers,createdLedgers);
  Random r=new Random(System.currentTimeMillis());
  final List<Long> tmpList=new ArrayList<Long>();
  tmpList.addAll(createdLedgers);
  Collections.shuffle(tmpList,r);
  for (int i=0; i < numRemovedLedgers; i++) {
    long ledgerId=tmpList.get(i);
synchronized (removedLedgers) {
      getLedgerManager().removeLedgerMetadata(ledgerId,Version.ANY,new GenericCallback<Void>(){
        @Override public void operationComplete(        int rc,        Void result){
synchronized (removedLedgers) {
            removedLedgers.notify();
          }
        }
      }
);
      removedLedgers.wait();
    }
    removedLedgers.add(ledgerId);
    createdLedgers.remove(ledgerId);
  }
  final CountDownLatch inGcProgress=new CountDownLatch(1);
  final CountDownLatch createLatch=new CountDownLatch(1);
  final CountDownLatch endLatch=new CountDownLatch(2);
  final GarbageCollector garbageCollector=new ScanAndCompareGarbageCollector(getLedgerManager(),activeLedgers);
  Thread gcThread=new Thread(){
    @Override public void run(){
      garbageCollector.gc(new GarbageCollector.GarbageCleaner(){
        boolean paused=false;
        @Override public void clean(        long ledgerId){
          if (!paused) {
            inGcProgress.countDown();
            try {
              createLatch.await();
            }
 catch (            InterruptedException ie) {
            }
            paused=true;
          }
          LOG.info("Garbage Collected ledger {}",ledgerId);
        }
      }
);
      LOG.info("Gc Thread quits.");
      endLatch.countDown();
    }
  }
;
  Thread createThread=new Thread(){
    @Override public void run(){
      try {
        inGcProgress.await();
        createLedgers(10,createdLedgers);
        LOG.info("Finished creating 10 more ledgers.");
        createLatch.countDown();
      }
 catch (      Exception e) {
      }
      LOG.info("Create Thread quits.");
      endLatch.countDown();
    }
  }
;
  createThread.start();
  gcThread.start();
  endLatch.await();
  for (  Long ledger : removedLedgers) {
    assertFalse(activeLedgers.containsKey(ledger));
  }
  for (  Long ledger : createdLedgers) {
    assertTrue(activeLedgers.containsKey(ledger));
  }
}

</code></pre>

<br>
<pre class="type-2 type-4 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testGcLedgersNotLast() throws Exception {
  final SortedSet<Long> createdLedgers=Collections.synchronizedSortedSet(new TreeSet<Long>());
  final List<Long> cleaned=new ArrayList<Long>();
  final int numLedgers=30001;
  createLedgers(numLedgers,createdLedgers);
  final GarbageCollector garbageCollector=new ScanAndCompareGarbageCollector(getLedgerManager(),activeLedgers);
  GarbageCollector.GarbageCleaner cleaner=new GarbageCollector.GarbageCleaner(){
    @Override public void clean(    long ledgerId){
      LOG.info("Cleaned {}",ledgerId);
      cleaned.add(ledgerId);
    }
  }
;
  SortedSet<Long> scannedLedgers=new TreeSet<Long>();
  LedgerRangeIterator iterator=getLedgerManager().getLedgerRanges();
  while (iterator.hasNext()) {
    LedgerRange ledgerRange=iterator.next();
    scannedLedgers.addAll(ledgerRange.getLedgers());
  }
  assertEquals(createdLedgers,scannedLedgers);
  garbageCollector.gc(cleaner);
  assertTrue("Should have cleaned nothing",cleaned.isEmpty());
  long first=createdLedgers.first();
  removeLedger(first);
  garbageCollector.gc(cleaner);
  assertEquals("Should have cleaned something",1,cleaned.size());
  assertEquals("Should have cleaned first ledger" + first,(long)first,(long)cleaned.get(0));
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.bookkeeper.meta.LedgerLayoutTest </h4><pre class="type-8 type-4 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testBadVersionLedgerLayout() throws Exception {
  ClientConfiguration conf=new ClientConfiguration();
  writeLedgerLayout(conf.getZkLedgersRootPath(),FlatLedgerManagerFactory.class.getName(),FlatLedgerManagerFactory.CUR_VERSION,LedgerLayout.LAYOUT_FORMAT_VERSION + 1);
  try {
    LedgerLayout.readLayout(zkc,conf.getZkLedgersRootPath());
    fail("Shouldn't reach here!");
  }
 catch (  IOException ie) {
    assertTrue("Invalid exception",ie.getMessage().contains("version not compatible"));
  }
}

</code></pre>

<br>
<pre class="type-8 type-4 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testAbsentLedgerManagerLayout() throws Exception {
  ClientConfiguration conf=new ClientConfiguration();
  String ledgersLayout=conf.getZkLedgersRootPath() + "/" + BookKeeperConstants.LAYOUT_ZNODE;
  StringBuilder sb=new StringBuilder();
  sb.append(LedgerLayout.LAYOUT_FORMAT_VERSION).append("\n");
  zkc.create(ledgersLayout,sb.toString().getBytes(),Ids.OPEN_ACL_UNSAFE,CreateMode.PERSISTENT);
  try {
    LedgerLayout.readLayout(zkc,conf.getZkLedgersRootPath());
    fail("Shouldn't reach here!");
  }
 catch (  IOException ie) {
    assertTrue("Invalid exception",ie.getMessage().contains("version absent from"));
  }
}

</code></pre>

<br>
<pre class="type-8 type-4 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testBaseLedgerManagerLayout() throws Exception {
  ClientConfiguration conf=new ClientConfiguration();
  String rootPath=conf.getZkLedgersRootPath();
  String ledgersLayout=rootPath + "/" + BookKeeperConstants.LAYOUT_ZNODE;
  StringBuilder sb=new StringBuilder();
  sb.append(LedgerLayout.LAYOUT_FORMAT_VERSION).append("\n").append(FlatLedgerManagerFactory.class.getName());
  zkc.create(ledgersLayout,sb.toString().getBytes(),Ids.OPEN_ACL_UNSAFE,CreateMode.PERSISTENT);
  try {
    LedgerLayout.readLayout(zkc,rootPath);
    fail("Shouldn't reach here!");
  }
 catch (  IOException ie) {
    assertTrue("Invalid exception",ie.getMessage().contains("Invalid Ledger Manager"));
  }
}

</code></pre>

<br>
<pre class="type-2 type-3 type-4 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testLedgerLayout() throws Exception {
  ClientConfiguration conf=new ClientConfiguration();
  conf.setLedgerManagerFactoryClass(HierarchicalLedgerManagerFactory.class);
  String ledgerRootPath="/testLedgerLayout";
  zkc.create(ledgerRootPath,new byte[0],Ids.OPEN_ACL_UNSAFE,CreateMode.PERSISTENT);
  LedgerLayout layout=LedgerLayout.readLayout(zkc,ledgerRootPath);
  assertTrue("Layout should be null",layout == null);
  String testName="foobar";
  int testVersion=0xdeadbeef;
  LedgerLayout layout2=new LedgerLayout(testName,testVersion);
  layout2.store(zkc,ledgerRootPath);
  layout=LedgerLayout.readLayout(zkc,ledgerRootPath);
  assertEquals(testName,layout.getManagerFactoryClass());
  assertEquals(testVersion,layout.getManagerVersion());
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.bookkeeper.meta.TestLedgerManager </h4><pre class="type-2 type-8 type-3 type-4 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test bad client configuration
 */
@SuppressWarnings("deprecation") @Test(timeout=60000) public void testBadConfV1() throws Exception {
  ClientConfiguration conf=new ClientConfiguration();
  String root0="/goodconf0";
  zkc.create(root0,new byte[0],Ids.OPEN_ACL_UNSAFE,CreateMode.PERSISTENT);
  conf.setZkLedgersRootPath(root0);
  writeLedgerLayout(root0,FlatLedgerManagerFactory.NAME,FlatLedgerManagerFactory.CUR_VERSION,1);
  conf.setLedgerManagerFactoryClass(FlatLedgerManagerFactory.class);
  LedgerManagerFactory m=LedgerManagerFactory.newLedgerManagerFactory(conf,zkc);
  assertTrue("Ledger manager is unexpected type",(m instanceof FlatLedgerManagerFactory));
  m.uninitialize();
  conf.setLedgerManagerFactoryClass(HierarchicalLedgerManagerFactory.class);
  m=LedgerManagerFactory.newLedgerManagerFactory(conf,zkc);
  assertTrue("Ledger manager is unexpected type",(m instanceof FlatLedgerManagerFactory));
  m.uninitialize();
  conf.setLedgerManagerType(HierarchicalLedgerManagerFactory.NAME);
  try {
    LedgerManagerFactory.newLedgerManagerFactory(conf,zkc);
    fail("Shouldn't reach here");
  }
 catch (  Exception e) {
    LOG.error("Received exception",e);
    assertTrue("Invalid exception",e.getMessage().contains("does not match existing layout"));
  }
}

</code></pre>

<br>
<pre class="type-8 type-4 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test bad zk configuration
 */
@Test(timeout=60000) public void testBadZkContents() throws Exception {
  ClientConfiguration conf=new ClientConfiguration();
  String root0="/badzk0";
  zkc.create(root0,new byte[0],Ids.OPEN_ACL_UNSAFE,CreateMode.PERSISTENT);
  conf.setZkLedgersRootPath(root0);
  new LedgerLayout("DoesNotExist",0xdeadbeef).store(zkc,root0);
  try {
    LedgerManagerFactory.newLedgerManagerFactory(conf,zkc);
    fail("Shouldn't reach here");
  }
 catch (  Exception e) {
    LOG.error("Received exception",e);
    assertTrue("Invalid exception",e.getMessage().contains("Failed to instantiate ledger manager factory"));
  }
  String root1="/badzk1";
  zkc.create(root1,new byte[0],Ids.OPEN_ACL_UNSAFE,CreateMode.PERSISTENT);
  conf.setZkLedgersRootPath(root1);
  new LedgerLayout(FlatLedgerManagerFactory.class.getName(),0xdeadbeef).store(zkc,root1);
  try {
    LedgerManagerFactory.newLedgerManagerFactory(conf,zkc);
    fail("Shouldn't reach here");
  }
 catch (  Exception e) {
    LOG.error("Received exception",e);
    assertTrue("Invalid exception",e.getMessage().contains("Incompatible layout version found"));
  }
}

</code></pre>

<br>
<pre class="type-3 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
"></span><br>
@Test(timeout=60000) public void testConcurrent1() throws Exception {
  int numThreads=50;
  String root0="/lmroot0";
  zkc.create(root0,new byte[0],Ids.OPEN_ACL_UNSAFE,CreateMode.PERSISTENT);
  CyclicBarrier barrier=new CyclicBarrier(numThreads + 1);
  List<CreateLMThread> threads=new ArrayList<CreateLMThread>(numThreads);
  for (int i=0; i < numThreads; i++) {
    CreateLMThread t=new CreateLMThread(zkUtil.getZooKeeperConnectString(),root0,FlatLedgerManagerFactory.class.getName(),barrier);
    t.start();
    threads.add(t);
  }
  barrier.await();
  boolean success=true;
  for (  CreateLMThread t : threads) {
    t.join();
    t.close();
    success=t.isSuccessful() && success;
  }
  assertTrue("Not all ledger managers created",success);
}

</code></pre>

<br>
<pre class="type-2 type-8 type-3 type-4 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test bad client configuration
 */
@Test(timeout=60000) public void testBadConf() throws Exception {
  ClientConfiguration conf=new ClientConfiguration();
  String root0="/goodconf0";
  zkc.create(root0,new byte[0],Ids.OPEN_ACL_UNSAFE,CreateMode.PERSISTENT);
  conf.setZkLedgersRootPath(root0);
  LedgerManagerFactory m=LedgerManagerFactory.newLedgerManagerFactory(conf,zkc);
  assertTrue("Ledger manager is unexpected type",(m instanceof FlatLedgerManagerFactory));
  m.uninitialize();
  conf.setLedgerManagerFactoryClass(HierarchicalLedgerManagerFactory.class);
  try {
    LedgerManagerFactory.newLedgerManagerFactory(conf,zkc);
    fail("Shouldn't reach here");
  }
 catch (  Exception e) {
    LOG.error("Received exception",e);
    assertTrue("Invalid exception",e.getMessage().contains("does not match existing layout"));
  }
  String root1="/badconf1";
  zkc.create(root1,new byte[0],Ids.OPEN_ACL_UNSAFE,CreateMode.PERSISTENT);
  conf.setZkLedgersRootPath(root1);
  conf.setLedgerManagerFactoryClassName("DoesNotExist");
  try {
    LedgerManagerFactory f=LedgerManagerFactory.newLedgerManagerFactory(conf,zkc);
    fail("Shouldn't reach here");
  }
 catch (  Exception e) {
    LOG.error("Received exception",e);
    assertTrue("Invalid exception",e.getMessage().contains("Failed to get ledger manager factory class from configuration"));
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.bookkeeper.meta.TestZkLedgerIdGenerator </h4><pre class="type-2 type-11 type-4 type-7 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions in iterations
- Verifies boolean conditions
- Verifies whether objects are null
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testGenerateLedgerId() throws Exception {
  final int nThread=2;
  final int nLedgers=2000;
  final CountDownLatch countDownLatch=new CountDownLatch(nThread * nLedgers);
  final AtomicInteger errCount=new AtomicInteger(0);
  final ConcurrentLinkedQueue<Long> ledgerIds=new ConcurrentLinkedQueue<Long>();
  final GenericCallback<Long> cb=new GenericCallback<Long>(){
    @Override public void operationComplete(    int rc,    Long result){
      if (Code.OK.intValue() == rc) {
        ledgerIds.add(result);
      }
 else {
        errCount.incrementAndGet();
      }
      countDownLatch.countDown();
    }
  }
;
  long start=System.currentTimeMillis();
  for (int i=0; i < nThread; i++) {
    new Thread(){
      @Override public void run(){
        for (int j=0; j < nLedgers; j++) {
          ledgerIdGenerator.generateLedgerId(cb);
        }
      }
    }
.start();
  }
  assertTrue("Wait ledger id generation threads to stop timeout : ",countDownLatch.await(30,TimeUnit.SECONDS));
  LOG.info("Number of generated ledger id: {}, time used: {}",ledgerIds.size(),System.currentTimeMillis() - start);
  assertEquals("Error occur during ledger id generation : ",0,errCount.get());
  Set<Long> ledgers=new HashSet<Long>();
  while (!ledgerIds.isEmpty()) {
    Long ledger=ledgerIds.poll();
    assertNotNull("Generated ledger id is null : ",ledger);
    assertFalse("Ledger id [" + ledger + "] conflict : ",ledgers.contains(ledger));
    ledgers.add(ledger);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.bookkeeper.proto.TestDeathwatcher </h4><pre class="type-2 type-3 type-4 type-7 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Ensure that if the autorecovery daemon is running inside the bookie
 * then a failure/crash in the autorecovery daemon will not take down the
 * bookie also.
 */
@Test(timeout=30000) public void testAutorecoveryFailureDoesntKillBookie() throws Exception {
  ServerConfiguration conf=newServerConfiguration().setAutoRecoveryDaemonEnabled(true);
  BookieServer bs=startBookie(conf);
  assertNotNull("Autorecovery daemon should exist",bs.autoRecoveryMain);
  assertTrue("Bookie should be running",bs.isBookieRunning());
  bs.autoRecoveryMain.shutdown();
  Thread.sleep(conf.getDeathWatchInterval() * 2);
  assertTrue("Bookie should be running",bs.isBookieRunning());
  bs.shutdown();
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.bookkeeper.proto.TestPerChannelBookieClient </h4><pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies boolean conditions
"></span><br>
/** 
 * Test that all resources are freed if connections and disconnections
 * are interleaved randomly.{@link https://issues.apache.org/jira/browse/BOOKKEEPER-620}
 */
@Test(timeout=60000) public void testDisconnectRace() throws Exception {
  final GenericCallback<PerChannelBookieClient> nullop=new GenericCallback<PerChannelBookieClient>(){
    @Override public void operationComplete(    int rc,    PerChannelBookieClient client){
    }
  }
;
  final int ITERATIONS=100000;
  ClientSocketChannelFactory channelFactory=new NioClientSocketChannelFactory(Executors.newCachedThreadPool(),Executors.newCachedThreadPool());
  OrderedSafeExecutor executor=getOrderedSafeExecutor();
  BookieSocketAddress addr=getBookie(0);
  final PerChannelBookieClient client=new PerChannelBookieClient(executor,channelFactory,addr);
  final AtomicBoolean shouldFail=new AtomicBoolean(false);
  final AtomicBoolean inconsistent=new AtomicBoolean(false);
  final AtomicBoolean running=new AtomicBoolean(true);
  final CountDownLatch disconnectRunning=new CountDownLatch(1);
  Thread connectThread=new Thread(){
    public void run(){
      try {
        if (!disconnectRunning.await(10,TimeUnit.SECONDS)) {
          LOG.error("Disconnect thread never started");
          shouldFail.set(true);
        }
      }
 catch (      InterruptedException ie) {
        LOG.error("Connect thread interrupted",ie);
        Thread.currentThread().interrupt();
        running.set(false);
      }
      for (int i=0; i < ITERATIONS && running.get(); i++) {
        client.connectIfNeededAndDoOp(nullop);
      }
      running.set(false);
    }
  }
;
  Thread disconnectThread=new Thread(){
    public void run(){
      disconnectRunning.countDown();
      while (running.get()) {
        client.disconnect();
      }
    }
  }
;
  Thread checkThread=new Thread(){
    public void run(){
      ConnectionState state;
      Channel channel;
      while (running.get()) {
synchronized (client) {
          state=client.state;
          channel=client.channel;
          if ((state == ConnectionState.CONNECTED && (channel == null || !channel.isConnected())) || (state != ConnectionState.CONNECTED && channel != null && channel.isConnected())) {
            LOG.error("State({}) and channel({}) inconsistent " + channel,state,channel == null ? null : channel.isConnected());
            shouldFail.set(true);
            running.set(false);
          }
        }
      }
    }
  }
;
  connectThread.start();
  disconnectThread.start();
  checkThread.start();
  connectThread.join();
  disconnectThread.join();
  checkThread.join();
  assertFalse("Failure in threads, check logs",shouldFail.get());
  client.close();
  channelFactory.releaseExternalResources();
  executor.shutdown();
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies boolean conditions
"></span><br>
/** 
 * Test that requests are completed even if the channel is disconnected{@link https://issues.apache.org/jira/browse/BOOKKEEPER-668}
 */
@Test(timeout=60000) public void testRequestCompletesAfterDisconnectRace() throws Exception {
  ServerConfiguration conf=killBookie(0);
  Bookie delayBookie=new Bookie(conf){
    @Override public ByteBuffer readEntry(    long ledgerId,    long entryId) throws IOException, NoLedgerException {
      try {
        Thread.sleep(3000);
      }
 catch (      InterruptedException ie) {
        throw new IOException("Interrupted waiting",ie);
      }
      return super.readEntry(ledgerId,entryId);
    }
  }
;
  bsConfs.add(conf);
  bs.add(startBookie(conf,delayBookie));
  ClientSocketChannelFactory channelFactory=new NioClientSocketChannelFactory(Executors.newCachedThreadPool(),Executors.newCachedThreadPool());
  final OrderedSafeExecutor executor=getOrderedSafeExecutor();
  BookieSocketAddress addr=getBookie(0);
  final PerChannelBookieClient client=new PerChannelBookieClient(executor,channelFactory,addr);
  final CountDownLatch completion=new CountDownLatch(1);
  final ReadEntryCallback cb=new ReadEntryCallback(){
    @Override public void readEntryComplete(    int rc,    long ledgerId,    long entryId,    ChannelBuffer buffer,    Object ctx){
      completion.countDown();
    }
  }
;
  client.connectIfNeededAndDoOp(new GenericCallback<PerChannelBookieClient>(){
    @Override public void operationComplete(    final int rc,    PerChannelBookieClient pcbc){
      if (rc != BKException.Code.OK) {
        executor.submitOrdered(1,new SafeRunnable(){
          @Override public void safeRun(){
            cb.readEntryComplete(rc,1,1,null,null);
          }
        }
);
        return;
      }
      client.readEntryAndFenceLedger(1,"00000111112222233333".getBytes(),1,cb,null);
    }
  }
);
  Thread.sleep(1000);
  client.disconnect();
  client.close();
  channelFactory.releaseExternalResources();
  executor.shutdown();
  assertTrue("Request should have completed",completion.await(5,TimeUnit.SECONDS));
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.bookkeeper.replication.AuditorBookieTest </h4><pre class="type-2 type-3 type-4 type-14 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether two objects/variables are the same">IdentityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether two objects/variables are the same
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test the vote is deleting from the ZooKeeper during shutdown.
 */
@Test(timeout=60000) public void testShutdown() throws Exception {
  BookieServer auditor=verifyAuditor();
  shutdownBookie(auditor);
  BookieServer newAuditor=waitForNewAuditor(auditor);
  Assert.assertNotSame("Auditor re-election is not happened for auditor failure!",auditor,newAuditor);
  int indexOfDownBookie=bs.indexOf(auditor);
  bs.remove(indexOfDownBookie);
  bsConfs.remove(indexOfDownBookie);
  List<String> children=zkc.getChildren(electionPath,false);
  for (  String child : children) {
    byte[] data=zkc.getData(electionPath + '/' + child,false,null);
    String bookieIP=new String(data);
    String addr=auditor.getLocalAddress().toString();
    Assert.assertFalse("AuditorElection cleanup fails",bookieIP.contains(addr));
  }
}

</code></pre>

<br>
<pre class="type-2 type-4 type-14 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether two objects/variables are the same">IdentityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies boolean conditions
- Verifies whether two objects/variables are the same
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test restarting the entire bookie cluster. It shouldn't create multiple
 * bookie auditors
 */
@Test(timeout=60000) public void testBookieClusterRestart() throws Exception {
  BookieServer auditor=verifyAuditor();
  for (  AuditorElector auditorElector : auditorElectors.values()) {
    assertTrue("Auditor elector is not running!",auditorElector.isRunning());
  }
  stopBKCluster();
  stopAuditorElectors();
  startBKCluster();
  startAuditorElectors();
  BookieServer newAuditor=waitForNewAuditor(auditor);
  Assert.assertNotSame("Auditor re-election is not happened for auditor failure!",auditor,newAuditor);
}

</code></pre>

<br>
<pre class="type-2 type-3 type-4 type-14 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether two objects/variables are the same">IdentityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether two objects/variables are the same
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test restart of the previous Auditor bookie shouldn't initiate
 * re-election and should create new vote after restarting.
 */
@Test(timeout=60000) public void testRestartAuditorBookieAfterCrashing() throws Exception {
  BookieServer auditor=verifyAuditor();
  shutdownBookie(auditor);
  String addr=auditor.getLocalAddress().toString();
  int indexOfDownBookie=bs.indexOf(auditor);
  ServerConfiguration serverConfiguration=bsConfs.get(indexOfDownBookie);
  bs.remove(indexOfDownBookie);
  bsConfs.remove(indexOfDownBookie);
  auditorElectors.remove(addr);
  startBookie(serverConfiguration);
  LOG.debug("Performing Auditor Election:" + addr);
  startAuditorElector(addr);
  BookieServer newAuditor=waitForNewAuditor(auditor);
  Assert.assertNotSame("Auditor re-election is not happened for auditor failure!",auditor,newAuditor);
  Assert.assertFalse("No relection after old auditor rejoins",auditor.getLocalAddress().getPort() == newAuditor.getLocalAddress().getPort());
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.bookkeeper.replication.AuditorLedgerCheckerTest </h4><pre class="type-2 type-3 type-4 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test publishing of under replicated ledgers by the auditor bookie
 */
@Test(timeout=60000) public void testSimpleLedger() throws Exception {
  LedgerHandle lh1=createAndAddEntriesToLedger();
  Long ledgerId=lh1.getId();
  LOG.debug("Created ledger : " + ledgerId);
  ledgerList.add(ledgerId);
  lh1.close();
  final CountDownLatch underReplicaLatch=registerUrLedgerWatcher(ledgerList.size());
  int bkShutdownIndex=bs.size() - 1;
  String shutdownBookie=shutdownBookie(bkShutdownIndex);
  LOG.debug("Waiting for ledgers to be marked as under replicated");
  underReplicaLatch.await(5,TimeUnit.SECONDS);
  Map<Long,String> urLedgerData=getUrLedgerData(urLedgerList);
  assertEquals("Missed identifying under replicated ledgers",1,urLedgerList.size());
  assertTrue("Ledger is not marked as underreplicated:" + ledgerId,urLedgerList.contains(ledgerId));
  String data=urLedgerData.get(ledgerId);
  assertTrue("Bookie " + shutdownBookie + "is not listed in the ledger as missing replica :"+ data,data.contains(shutdownBookie));
}

</code></pre>

<br>
<pre class="type-2 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies boolean conditions
"></span><br>
/** 
 * Test Auditor should consider Readonly bookie as available bookie. Should not publish ur ledgers for
 * readonly bookies.
 */
@Test(timeout=20000) public void testReadOnlyBookieExclusionFromURLedgersCheck() throws Exception {
  LedgerHandle lh=createAndAddEntriesToLedger();
  ledgerList.add(lh.getId());
  LOG.debug("Created following ledgers : " + ledgerList);
  int count=ledgerList.size();
  final CountDownLatch underReplicaLatch=registerUrLedgerWatcher(count);
  ServerConfiguration bookieConf=bsConfs.get(2);
  BookieServer bk=bs.get(2);
  bookieConf.setReadOnlyModeEnabled(true);
  bk.getBookie().doTransitionToReadOnlyMode();
  LOG.debug("Waiting for Auditor to finish ledger check.");
  assertFalse("latch should not have completed",underReplicaLatch.await(5,TimeUnit.SECONDS));
}

</code></pre>

<br>
<pre class="type-3 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
"></span><br>
/** 
 * Test publishing of under replicated ledgers when multiple bookie failures
 * one after another.
 */
@Test(timeout=60000) public void testMultipleBookieFailures() throws Exception {
  LedgerHandle lh1=createAndAddEntriesToLedger();
  shutdownBookie(bs.size() - 1);
  doLedgerRereplication(lh1.getId());
  String shutdownBookie=shutdownBookie(bs.size() - 1);
  LOG.debug("Waiting for ledgers to be marked as under replicated");
  assertTrue("Ledger should be missing second replica",waitForLedgerMissingReplicas(lh1.getId(),10,shutdownBookie));
}

</code></pre>

<br>
<pre class="type-8 type-4 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=20000) public void testDuplicateEnDisableAutoRecovery() throws Exception {
  urLedgerMgr.disableLedgerReplication();
  try {
    urLedgerMgr.disableLedgerReplication();
    fail("Must throw exception, since AutoRecovery is already disabled");
  }
 catch (  UnavailableException e) {
    assertTrue("AutoRecovery is not disabled previously!",e.getCause() instanceof KeeperException.NodeExistsException);
  }
  urLedgerMgr.enableLedgerReplication();
  try {
    urLedgerMgr.enableLedgerReplication();
    fail("Must throw exception, since AutoRecovery is already enabled");
  }
 catch (  UnavailableException e) {
    assertTrue("AutoRecovery is not enabled previously!",e.getCause() instanceof KeeperException.NoNodeException);
  }
}

</code></pre>

<br>
<pre class="type-2 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies boolean conditions
"></span><br>
@Test(timeout=30000) public void testToggleLedgerReplication() throws Exception {
  LedgerHandle lh1=createAndAddEntriesToLedger();
  ledgerList.add(lh1.getId());
  LOG.debug("Created following ledgers : " + ledgerList);
  CountDownLatch urReplicaLatch=registerUrLedgerWatcher(ledgerList.size());
  urLedgerMgr.disableLedgerReplication();
  ArrayList<String> shutdownBookieList=new ArrayList<String>();
  shutdownBookieList.add(shutdownBookie(bs.size() - 1));
  shutdownBookieList.add(shutdownBookie(bs.size() - 1));
  assertFalse("Ledger replication is not disabled!",urReplicaLatch.await(1,TimeUnit.SECONDS));
  urLedgerMgr.enableLedgerReplication();
  assertTrue("Ledger replication is not enabled!",urReplicaLatch.await(5,TimeUnit.SECONDS));
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.bookkeeper.replication.AuditorPeriodicCheckTest </h4><pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies boolean conditions
"></span><br>
/** 
 * Test that the period check will succeed if a ledger is deleted midway
 */
@Test(timeout=120000) public void testPeriodicCheckWhenLedgerDeleted() throws Exception {
  for (  AuditorElector e : auditorElectors.values()) {
    e.shutdown();
  }
  final int numLedgers=10;
  List<Long> ids=new LinkedList<Long>();
  for (int i=0; i < numLedgers; i++) {
    LedgerHandle lh=bkc.createLedger(3,3,DigestType.CRC32,"passwd".getBytes());
    ids.add(lh.getId());
    for (int j=0; j < 2; j++) {
      lh.addEntry("testdata".getBytes());
    }
    lh.close();
  }
  final Auditor auditor=new Auditor(Bookie.getBookieAddress(bsConfs.get(0)).toString(),bsConfs.get(0),zkc);
  final AtomicBoolean exceptionCaught=new AtomicBoolean(false);
  final CountDownLatch latch=new CountDownLatch(1);
  Thread t=new Thread(){
    public void run(){
      try {
        latch.countDown();
        for (int i=0; i < numLedgers; i++) {
          auditor.checkAllLedgers();
        }
      }
 catch (      Exception e) {
        LOG.error("Caught exception while checking all ledgers",e);
        exceptionCaught.set(true);
      }
    }
  }
;
  t.start();
  latch.await();
  for (  Long id : ids) {
    bkc.deleteLedger(id);
  }
  t.join();
  assertFalse("Shouldn't have thrown exception",exceptionCaught.get());
}

</code></pre>

<br>
<pre class="type-3 type-4 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test that the period checker will not run when auto replication has been disabled
 */
@Test(timeout=120000) public void testPeriodicCheckWhenDisabled() throws Exception {
  LedgerManagerFactory mFactory=LedgerManagerFactory.newLedgerManagerFactory(bsConfs.get(0),zkc);
  final LedgerUnderreplicationManager underReplicationManager=mFactory.newLedgerUnderreplicationManager();
  final int numLedgers=10;
  final int numMsgs=2;
  final CountDownLatch completeLatch=new CountDownLatch(numMsgs * numLedgers);
  final AtomicInteger rc=new AtomicInteger(BKException.Code.OK);
  List<LedgerHandle> lhs=new ArrayList<LedgerHandle>();
  for (int i=0; i < numLedgers; i++) {
    LedgerHandle lh=bkc.createLedger(3,3,DigestType.CRC32,"passwd".getBytes());
    lhs.add(lh);
    for (int j=0; j < 2; j++) {
      lh.asyncAddEntry("testdata".getBytes(),new AddCallback(){
        public void addComplete(        int rc2,        LedgerHandle lh,        long entryId,        Object ctx){
          if (rc.compareAndSet(BKException.Code.OK,rc2)) {
            LOG.info("Failed to add entry : {}",BKException.getMessage(rc2));
          }
          completeLatch.countDown();
        }
      }
,null);
    }
  }
  completeLatch.await();
  if (rc.get() != BKException.Code.OK) {
    throw BKException.create(rc.get());
  }
  for (  LedgerHandle lh : lhs) {
    lh.close();
  }
  underReplicationManager.disableLedgerReplication();
  final AtomicInteger numReads=new AtomicInteger(0);
  ServerConfiguration conf=killBookie(0);
  Bookie deadBookie=new Bookie(conf){
    @Override public ByteBuffer readEntry(    long ledgerId,    long entryId) throws IOException, NoLedgerException {
      numReads.incrementAndGet();
      throw new IOException("Fake I/O exception");
    }
  }
;
  bsConfs.add(conf);
  bs.add(startBookie(conf,deadBookie));
  Thread.sleep(CHECK_INTERVAL * 2000);
  assertEquals("Nothing should have tried to read",0,numReads.get());
  underReplicationManager.enableLedgerReplication();
  Thread.sleep(CHECK_INTERVAL * 2000);
  underReplicationManager.disableLedgerReplication();
  Thread.sleep(CHECK_INTERVAL * 2000);
  int numUnderreplicated=0;
  long underReplicatedLedger=-1;
  do {
    underReplicatedLedger=underReplicationManager.pollLedgerToRereplicate();
    if (underReplicatedLedger == -1) {
      break;
    }
    numUnderreplicated++;
    underReplicationManager.markLedgerReplicated(underReplicatedLedger);
  }
 while (underReplicatedLedger != -1);
  Thread.sleep(CHECK_INTERVAL * 2000);
  underReplicatedLedger=underReplicationManager.pollLedgerToRereplicate();
  assertEquals("There should be no underreplicated ledgers",-1,underReplicatedLedger);
  LOG.info("{} of {} ledgers underreplicated",numUnderreplicated,numUnderreplicated);
  assertTrue("All should be underreplicated",numUnderreplicated <= numLedgers && numUnderreplicated > 0);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.bookkeeper.replication.AutoRecoveryMainTest </h4><pre class="type-3 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
"></span><br>
@Test(timeout=60000) public void testShutdown() throws Exception {
  AutoRecoveryMain main=new AutoRecoveryMain(bsConfs.get(0));
  main.start();
  Thread.sleep(500);
  assertTrue("AuditorElector should be running",main.auditorElector.isRunning());
  assertTrue("Replication worker should be running",main.replicationWorker.isRunning());
  main.shutdown();
  assertFalse("AuditorElector should not be running",main.auditorElector.isRunning());
  assertFalse("Replication worker should not be running",main.replicationWorker.isRunning());
}

</code></pre>

<br>
<pre class="type-3 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
"></span><br>
@Test(timeout=60000) public void testStartup() throws Exception {
  AutoRecoveryMain main=new AutoRecoveryMain(bsConfs.get(0));
  try {
    main.start();
    Thread.sleep(500);
    assertTrue("AuditorElector should be running",main.auditorElector.isRunning());
    assertTrue("Replication worker should be running",main.replicationWorker.isRunning());
  }
  finally {
    main.shutdown();
  }
}

</code></pre>

<br>
<pre class="type-3 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
"></span><br>
/** 
 * Test that, if an autorecovery looses its ZK connection/session
 * it will shutdown.
 */
@Test(timeout=60000) public void testAutoRecoverySessionLoss() throws Exception {
  AutoRecoveryMain main1=new AutoRecoveryMain(bsConfs.get(0));
  AutoRecoveryMain main2=new AutoRecoveryMain(bsConfs.get(1));
  main1.start();
  main2.start();
  Thread.sleep(500);
  assertTrue("AuditorElectors should be running",main1.auditorElector.isRunning() && main2.auditorElector.isRunning());
  assertTrue("Replication workers should be running",main1.replicationWorker.isRunning() && main2.replicationWorker.isRunning());
  zkUtil.expireSession(main1.zk);
  zkUtil.expireSession(main2.zk);
  for (int i=0; i < 10; i++) {
    if (!main1.auditorElector.isRunning() && !main2.auditorElector.isRunning() && !main1.replicationWorker.isRunning()&& !main2.replicationWorker.isRunning()) {
      break;
    }
    Thread.sleep(1000);
  }
  assertFalse("Elector1 should have shutdown",main1.auditorElector.isRunning());
  assertFalse("Elector2 should have shutdown",main2.auditorElector.isRunning());
  assertFalse("RW1 should have shutdown",main1.replicationWorker.isRunning());
  assertFalse("RW2 should have shutdown",main2.replicationWorker.isRunning());
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.bookkeeper.replication.BookieAutoRecoveryTest </h4><pre class="type-6 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions inside branch conditions
- Verifies boolean conditions
"></span><br>
/** 
 * Test that if a empty ledger loses the bookie not in the quorum for entry 0, it will
 * still be openable when it loses enough bookies to lose a whole quorum.
 */
@Test(timeout=10000) public void testEmptyLedgerLosesQuorumEventually() throws Exception {
  LedgerHandle lh=bkc.createLedger(3,2,2,DigestType.CRC32,PASSWD);
  CountDownLatch latch=new CountDownLatch(1);
  String urZNode=getUrLedgerZNode(lh);
  watchUrLedgerNode(urZNode,latch);
  BookieSocketAddress replicaToKill=LedgerHandleAdapter.getLedgerMetadata(lh).getEnsembles().get(0L).get(2);
  LOG.info("Killing last bookie, {}, in ensemble {}",replicaToKill,LedgerHandleAdapter.getLedgerMetadata(lh).getEnsembles().get(0L));
  killBookie(replicaToKill);
  getAuditor(10,TimeUnit.SECONDS).submitAuditTask().get();
  assertTrue("Should be marked as underreplicated",latch.await(5,TimeUnit.SECONDS));
  latch=new CountDownLatch(1);
  Stat s=watchUrLedgerNode(urZNode,latch);
  if (s != null) {
    assertTrue("Should be marked as replicated",latch.await(10,TimeUnit.SECONDS));
  }
  replicaToKill=LedgerHandleAdapter.getLedgerMetadata(lh).getEnsembles().get(0L).get(1);
  LOG.info("Killing second bookie, {}, in ensemble {}",replicaToKill,LedgerHandleAdapter.getLedgerMetadata(lh).getEnsembles().get(0L));
  killBookie(replicaToKill);
  getAuditor(10,TimeUnit.SECONDS).submitAuditTask().get();
  assertTrue("Should be marked as underreplicated",latch.await(5,TimeUnit.SECONDS));
  latch=new CountDownLatch(1);
  s=watchUrLedgerNode(urZNode,latch);
  if (s != null) {
    assertTrue("Should be marked as replicated",latch.await(5,TimeUnit.SECONDS));
  }
  bkc.openLedger(lh.getId(),DigestType.CRC32,PASSWD);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.bookkeeper.replication.BookieLedgerIndexTest </h4><pre class="type-3 type-4 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Verify the bookie-ledger mapping with minimum number of bookies and few
 * ledgers
 */
@Test(timeout=60000) public void testSimpleBookieLedgerMapping() throws Exception {
  for (int i=0; i < numberOfLedgers; i++) {
    createAndAddEntriesToLedger().close();
  }
  BookieLedgerIndexer bookieLedgerIndex=new BookieLedgerIndexer(ledgerManager);
  Map<String,Set<Long>> bookieToLedgerIndex=bookieLedgerIndex.getBookieToLedgerIndex();
  assertEquals("Missed few bookies in the bookie-ledger mapping!",3,bookieToLedgerIndex.size());
  Collection<Set<Long>> bk2ledgerEntry=bookieToLedgerIndex.values();
  for (  Set<Long> ledgers : bk2ledgerEntry) {
    assertEquals("Missed few ledgers in the bookie-ledger mapping!",3,ledgers.size());
    for (    Long ledgerId : ledgers) {
      assertTrue("Unknown ledger-bookie mapping",ledgerList.contains(ledgerId));
    }
  }
}

</code></pre>

<br>
<pre class="type-8 type-3 type-4 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Verify indexing with multiple ensemble reformation
 */
@Test(timeout=60000) public void testEnsembleReformation() throws Exception {
  try {
    LedgerHandle lh1=createAndAddEntriesToLedger();
    LedgerHandle lh2=createAndAddEntriesToLedger();
    startNewBookie();
    shutdownBookie(bs.size() - 2);
    for (int i=0; i < 10; i++) {
      ByteBuffer entry=ByteBuffer.allocate(4);
      entry.putInt(rng.nextInt(Integer.MAX_VALUE));
      entry.position(0);
      entries.add(entry.array());
      lh1.addEntry(entry.array());
      lh2.addEntry(entry.array());
    }
    BookieLedgerIndexer bookieLedgerIndex=new BookieLedgerIndexer(ledgerManager);
    Map<String,Set<Long>> bookieToLedgerIndex=bookieLedgerIndex.getBookieToLedgerIndex();
    assertEquals("Missed few bookies in the bookie-ledger mapping!",4,bookieToLedgerIndex.size());
    Collection<Set<Long>> bk2ledgerEntry=bookieToLedgerIndex.values();
    for (    Set<Long> ledgers : bk2ledgerEntry) {
      assertEquals("Missed few ledgers in the bookie-ledger mapping!",2,ledgers.size());
      for (      Long ledgerNode : ledgers) {
        assertTrue("Unknown ledger-bookie mapping",ledgerList.contains(ledgerNode));
      }
    }
  }
 catch (  BKException e) {
    LOG.error("Test failed",e);
    fail("Test failed due to BookKeeper exception");
  }
catch (  InterruptedException e) {
    LOG.error("Test failed",e);
    fail("Test failed due to interruption");
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.bookkeeper.replication.TestAutoRecoveryAlongWithBookieServers </h4><pre class="type-2 type-11 type-3 type-4 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions in iterations
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Tests that the auto recovery service along with Bookie servers itself 
 */
@Test(timeout=60000) public void testAutoRecoveryAlongWithBookieServers() throws Exception {
  LedgerHandle lh=bkc.createLedger(3,3,BookKeeper.DigestType.CRC32,"testpasswd".getBytes());
  byte[] testData="testBuiltAutoRecovery".getBytes();
  for (int i=0; i < 10; i++) {
    lh.addEntry(testData);
  }
  lh.close();
  BookieSocketAddress replicaToKill=LedgerHandleAdapter.getLedgerMetadata(lh).getEnsembles().get(0L).get(0);
  killBookie(replicaToKill);
  int startNewBookie=startNewBookie();
  BookieSocketAddress newBkAddr=new BookieSocketAddress(InetAddress.getLocalHost().getHostAddress(),startNewBookie);
  while (ReplicationTestUtil.isLedgerInUnderReplication(zkc,lh.getId(),basePath)) {
    Thread.sleep(100);
  }
  Set<Entry<Long,ArrayList<BookieSocketAddress>>> entrySet=LedgerHandleAdapter.getLedgerMetadata(lh).getEnsembles().entrySet();
  for (  Entry<Long,ArrayList<BookieSocketAddress>> entry : entrySet) {
    ArrayList<BookieSocketAddress> bookies=entry.getValue();
    for (    BookieSocketAddress bookie : bookies) {
      if (bookie.equals(newBkAddr)) {
        continue;
      }
      killBookie(bookie);
    }
  }
  LedgerHandle lhs=bkc.openLedgerNoRecovery(lh.getId(),BookKeeper.DigestType.CRC32,"testpasswd".getBytes());
  Enumeration<LedgerEntry> entries=lhs.readEntries(0,9);
  assertTrue("Should have the elements",entries.hasMoreElements());
  while (entries.hasMoreElements()) {
    LedgerEntry entry=entries.nextElement();
    assertEquals("testBuiltAutoRecovery",new String(entry.getEntry()));
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.bookkeeper.replication.TestLedgerUnderreplicationManager </h4><pre class="type-11 type-3 type-4 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test that as the hierarchy gets cleaned up, it doesn't interfere
 * with the marking of other ledgers as underreplicated
 */
@Test(timeout=90000) public void testHierarchyCleanupInterference() throws Exception {
  final LedgerUnderreplicationManager replicaMgr1=lmf1.newLedgerUnderreplicationManager();
  final LedgerUnderreplicationManager replicaMgr2=lmf2.newLedgerUnderreplicationManager();
  final int iterations=100;
  final AtomicBoolean threadFailed=new AtomicBoolean(false);
  Thread markUnder=new Thread(){
    public void run(){
      long l=1;
      try {
        for (int i=0; i < iterations; i++) {
          replicaMgr1.markLedgerUnderreplicated(l,"localhost:3181");
          l+=10000;
        }
      }
 catch (      Exception e) {
        LOG.error("markUnder Thread failed with exception",e);
        threadFailed.set(true);
        return;
      }
    }
  }
;
  final AtomicInteger processed=new AtomicInteger(0);
  Thread markRepl=new Thread(){
    public void run(){
      try {
        for (int i=0; i < iterations; i++) {
          long l=replicaMgr2.getLedgerToRereplicate();
          replicaMgr2.markLedgerReplicated(l);
          processed.incrementAndGet();
        }
      }
 catch (      Exception e) {
        LOG.error("markRepl Thread failed with exception",e);
        threadFailed.set(true);
        return;
      }
    }
  }
;
  markRepl.setDaemon(true);
  markUnder.setDaemon(true);
  markRepl.start();
  markUnder.start();
  markUnder.join();
  assertFalse("Thread failed to complete",threadFailed.get());
  int lastProcessed=0;
  while (true) {
    markRepl.join(10000);
    if (!markRepl.isAlive()) {
      break;
    }
    assertFalse("markRepl thread not progressing",lastProcessed == processed.get());
  }
  assertFalse("Thread failed to complete",threadFailed.get());
  List<String> children=zkc1.getChildren(urLedgerPath,false);
  for (  String s : children) {
    LOG.info("s: {}",s);
  }
  assertEquals("All hierarchies should be cleaned up",0,children.size());
}

</code></pre>

<br>
<pre class="type-2 type-8 type-3 type-4 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test basic interactions with the ledger underreplication
 * manager.
 * Mark some ledgers as underreplicated.
 * Ensure that getLedgerToReplicate will block until it a ledger
 * becomes available.
 */
@Test(timeout=60000) public void testBasicInteraction() throws Exception {
  Set<Long> ledgers=new HashSet<Long>();
  ledgers.add(0xdeadbeefL);
  ledgers.add(0xbeefcafeL);
  ledgers.add(0xffffbeefL);
  ledgers.add(0xfacebeefL);
  String missingReplica="localhost:3181";
  int count=0;
  LedgerUnderreplicationManager m=lmf1.newLedgerUnderreplicationManager();
  Iterator<Long> iter=ledgers.iterator();
  while (iter.hasNext()) {
    m.markLedgerUnderreplicated(iter.next(),missingReplica);
    count++;
  }
  List<Future<Long>> futures=new ArrayList<Future<Long>>();
  for (int i=0; i < count; i++) {
    futures.add(getLedgerToReplicate(m));
  }
  for (  Future<Long> f : futures) {
    Long l=f.get(5,TimeUnit.SECONDS);
    assertTrue(ledgers.remove(l));
  }
  Future<Long> f=getLedgerToReplicate(m);
  try {
    f.get(1,TimeUnit.SECONDS);
    fail("Shouldn't be able to find a ledger to replicate");
  }
 catch (  TimeoutException te) {
  }
  Long newl=0xfefefefefefeL;
  m.markLedgerUnderreplicated(newl,missingReplica);
  assertEquals("Should have got the one just added",newl,f.get(5,TimeUnit.SECONDS));
}

</code></pre>

<br>
<pre class="type-8 type-4 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test disabling the ledger re-replication. After disabling, it will not be
 * able to getLedgerToRereplicate(). This calls will enter into infinite
 * waiting until enabling rereplication process
 */
@Test(timeout=20000) public void testDisableLedegerReplication() throws Exception {
  final LedgerUnderreplicationManager replicaMgr=lmf1.newLedgerUnderreplicationManager();
  final Long ledgerA=0xfeadeefdacL;
  final String missingReplica="localhost:3181";
  replicaMgr.disableLedgerReplication();
  LOG.info("Disabled Ledeger Replication");
  try {
    replicaMgr.markLedgerUnderreplicated(ledgerA,missingReplica);
  }
 catch (  UnavailableException e) {
    LOG.debug("Unexpected exception while marking urLedger",e);
    fail("Unexpected exception while marking urLedger" + e.getMessage());
  }
  Future<Long> fA=getLedgerToReplicate(replicaMgr);
  try {
    fA.get(1,TimeUnit.SECONDS);
    fail("Shouldn't be able to find a ledger to replicate");
  }
 catch (  TimeoutException te) {
    isLedgerReplicationDisabled=false;
  }
  assertTrue("Ledger replication is not disabled!",!isLedgerReplicationDisabled);
}

</code></pre>

<br>
<pre class="type-8 type-3 type-4 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test enabling the ledger re-replication. After enableLedegerReplication,
 * should continue getLedgerToRereplicate() task
 */
@Test(timeout=20000) public void testEnableLedgerReplication() throws Exception {
  isLedgerReplicationDisabled=true;
  final LedgerUnderreplicationManager replicaMgr=lmf1.newLedgerUnderreplicationManager();
  final Long ledgerA=0xfeadeefdacL;
  final String missingReplica="localhost:3181";
  try {
    replicaMgr.markLedgerUnderreplicated(ledgerA,missingReplica);
  }
 catch (  UnavailableException e) {
    LOG.debug("Unexpected exception while marking urLedger",e);
    fail("Unexpected exception while marking urLedger" + e.getMessage());
  }
  replicaMgr.disableLedgerReplication();
  LOG.debug("Disabled Ledeger Replication");
  String znodeA=getUrLedgerZnode(ledgerA);
  final CountDownLatch znodeLatch=new CountDownLatch(2);
  String urledgerA=StringUtils.substringAfterLast(znodeA,"/");
  String urLockLedgerA=basePath + "/locks/" + urledgerA;
  zkc1.exists(urLockLedgerA,new Watcher(){
    @Override public void process(    WatchedEvent event){
      if (event.getType() == EventType.NodeCreated) {
        znodeLatch.countDown();
        LOG.debug("Recieved node creation event for the zNodePath:" + event.getPath());
      }
    }
  }
);
  Thread thread1=new Thread(){
    @Override public void run(){
      try {
        Long lA=replicaMgr.getLedgerToRereplicate();
        assertEquals("Should be the ledger I just marked",lA,ledgerA);
        isLedgerReplicationDisabled=false;
        znodeLatch.countDown();
      }
 catch (      UnavailableException e) {
        LOG.debug("Unexpected exception while marking urLedger",e);
        isLedgerReplicationDisabled=false;
      }
    }
  }
;
  thread1.start();
  try {
    assertFalse("shouldn't complete",znodeLatch.await(1,TimeUnit.SECONDS));
    assertTrue("Ledger replication is not disabled!",isLedgerReplicationDisabled);
    assertEquals("Failed to disable ledger replication!",2,znodeLatch.getCount());
    replicaMgr.enableLedgerReplication();
    znodeLatch.await(5,TimeUnit.SECONDS);
    LOG.debug("Enabled Ledeger Replication");
    assertTrue("Ledger replication is not disabled!",!isLedgerReplicationDisabled);
    assertEquals("Failed to disable ledger replication!",0,znodeLatch.getCount());
  }
  finally {
    thread1.interrupt();
  }
}

</code></pre>

<br>
<pre class="type-2 type-8 type-3 type-4 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test that when a ledger has been marked as replicated, it
 * will not be offered to anther client.
 * This test checked that by marking two ledgers, and acquiring
 * them on a single client. It marks one as replicated and then
 * the client is killed. We then check that another client can
 * acquire a ledger, and that it's not the one that was previously
 * marked as replicated.
 */
@Test(timeout=60000) public void testMarkingAsReplicated() throws Exception {
  String missingReplica="localhost:3181";
  LedgerUnderreplicationManager m1=lmf1.newLedgerUnderreplicationManager();
  LedgerUnderreplicationManager m2=lmf2.newLedgerUnderreplicationManager();
  Long ledgerA=0xfeadeefdacL;
  Long ledgerB=0xdefadebL;
  m1.markLedgerUnderreplicated(ledgerA,missingReplica);
  m1.markLedgerUnderreplicated(ledgerB,missingReplica);
  Future<Long> fA=getLedgerToReplicate(m1);
  Future<Long> fB=getLedgerToReplicate(m1);
  Long lA=fA.get(5,TimeUnit.SECONDS);
  Long lB=fB.get(5,TimeUnit.SECONDS);
  assertTrue("Should be the ledgers I just marked",(lA.equals(ledgerA) && lB.equals(ledgerB)) || (lA.equals(ledgerB) && lB.equals(ledgerA)));
  Future<Long> f=getLedgerToReplicate(m2);
  try {
    f.get(1,TimeUnit.SECONDS);
    fail("Shouldn't be able to find a ledger to replicate");
  }
 catch (  TimeoutException te) {
  }
  m1.markLedgerReplicated(lA);
  zkc1.close();
  zkc1=null;
  Long l=f.get(5,TimeUnit.SECONDS);
  assertEquals("Should be the ledger I marked",lB,l);
}

</code></pre>

<br>
<pre class="type-2 type-8 type-3 type-4 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test that when a ledger is marked as underreplicated with
 * the same missing replica twice, only marking as replicated
 * will be enough to remove it from the list.
 */
@Test(timeout=60000) public void test2reportSame() throws Exception {
  String missingReplica1="localhost:3181";
  LedgerUnderreplicationManager m1=lmf1.newLedgerUnderreplicationManager();
  LedgerUnderreplicationManager m2=lmf2.newLedgerUnderreplicationManager();
  Long ledgerA=0xfeadeefdacL;
  m1.markLedgerUnderreplicated(ledgerA,missingReplica1);
  m2.markLedgerUnderreplicated(ledgerA,missingReplica1);
  UnderreplicatedLedgerFormat.Builder builderA=UnderreplicatedLedgerFormat.newBuilder();
  String znode=getUrLedgerZnode(ledgerA);
  byte[] data=zkc1.getData(znode,false,null);
  TextFormat.merge(new String(data,Charset.forName("UTF-8")),builderA);
  List<String> replicaList=builderA.getReplicaList();
  assertEquals("Published duplicate missing replica : " + replicaList,1,replicaList.size());
  assertTrue("Published duplicate missing replica : " + replicaList,replicaList.contains(missingReplica1));
  Future<Long> fA=getLedgerToReplicate(m1);
  Long lA=fA.get(5,TimeUnit.SECONDS);
  assertEquals("Should be the ledger I just marked",lA,ledgerA);
  m1.markLedgerReplicated(lA);
  Future<Long> f=getLedgerToReplicate(m2);
  try {
    f.get(1,TimeUnit.SECONDS);
    fail("Shouldn't be able to find a ledger to replicate");
  }
 catch (  TimeoutException te) {
  }
}

</code></pre>

<br>
<pre class="type-2 type-8 type-3 type-4 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test releasing of a ledger
 * A ledger is released when a client decides it does not want
 * to replicate it (or cannot at the moment).
 * When a client releases a previously acquired ledger, another
 * client should then be able to acquire it.
 */
@Test(timeout=60000) public void testRelease() throws Exception {
  String missingReplica="localhost:3181";
  LedgerUnderreplicationManager m1=lmf1.newLedgerUnderreplicationManager();
  LedgerUnderreplicationManager m2=lmf2.newLedgerUnderreplicationManager();
  Long ledgerA=0xfeadeefdacL;
  Long ledgerB=0xdefadebL;
  m1.markLedgerUnderreplicated(ledgerA,missingReplica);
  m1.markLedgerUnderreplicated(ledgerB,missingReplica);
  Future<Long> fA=getLedgerToReplicate(m1);
  Future<Long> fB=getLedgerToReplicate(m1);
  Long lA=fA.get(5,TimeUnit.SECONDS);
  Long lB=fB.get(5,TimeUnit.SECONDS);
  assertTrue("Should be the ledgers I just marked",(lA.equals(ledgerA) && lB.equals(ledgerB)) || (lA.equals(ledgerB) && lB.equals(ledgerA)));
  Future<Long> f=getLedgerToReplicate(m2);
  try {
    f.get(1,TimeUnit.SECONDS);
    fail("Shouldn't be able to find a ledger to replicate");
  }
 catch (  TimeoutException te) {
  }
  m1.markLedgerReplicated(lA);
  m1.releaseUnderreplicatedLedger(lB);
  Long l=f.get(5,TimeUnit.SECONDS);
  assertEquals("Should be the ledger I marked",lB,l);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.bookkeeper.replication.TestReplicationWorker </h4><pre class="type-2 type-3 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
"></span><br>
/** 
 * Tests that ReplicationWorker should fence the ledger and release ledger
 * lock after timeout. Then replication should happen normally.
 */
@Test(timeout=60000) public void testRWShouldReplicateTheLedgersAfterTimeoutIfLastFragmentIsUR() throws Exception {
  LedgerHandle lh=bkc.createLedger(3,3,BookKeeper.DigestType.CRC32,TESTPASSWD);
  for (int i=0; i < 10; i++) {
    lh.addEntry(data);
  }
  BookieSocketAddress replicaToKill=LedgerHandleAdapter.getLedgerMetadata(lh).getEnsembles().get(0L).get(0);
  LOG.info("Killing Bookie",replicaToKill);
  killBookie(replicaToKill);
  int startNewBookie=startNewBookie();
  BookieSocketAddress newBkAddr=new BookieSocketAddress(InetAddress.getLocalHost().getHostAddress(),startNewBookie);
  LOG.info("New Bookie addr :" + newBkAddr);
  baseConf.setOpenLedgerRereplicationGracePeriod("3000");
  ReplicationWorker rw=new ReplicationWorker(zkc,baseConf,newBkAddr);
  LedgerManagerFactory mFactory=LedgerManagerFactory.newLedgerManagerFactory(baseClientConf,zkc);
  LedgerUnderreplicationManager underReplicationManager=mFactory.newLedgerUnderreplicationManager();
  rw.start();
  try {
    underReplicationManager.markLedgerUnderreplicated(lh.getId(),replicaToKill.toString());
    while (ReplicationTestUtil.isLedgerInUnderReplication(zkc,lh.getId(),basePath)) {
      Thread.sleep(100);
    }
    killAllBookies(lh,newBkAddr);
    verifyRecoveredLedgers(lh,0,9);
    lh=bkc.openLedgerNoRecovery(lh.getId(),BookKeeper.DigestType.CRC32,TESTPASSWD);
    assertFalse("Ledger must have been closed by RW",ClientUtil.isLedgerOpen(lh));
  }
  finally {
    rw.shutdown();
    underReplicationManager.close();
  }
}

</code></pre>

<br>
<pre class="type-2 type-11 type-3 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions in iterations
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
"></span><br>
/** 
 * Tests that replication worker should retry for replication until enough
 * bookies available for replication
 */
@Test(timeout=60000) public void testRWShouldRetryUntilThereAreEnoughBksAvailableForReplication() throws Exception {
  LedgerHandle lh=bkc.createLedger(1,1,BookKeeper.DigestType.CRC32,TESTPASSWD);
  for (int i=0; i < 10; i++) {
    lh.addEntry(data);
  }
  lh.close();
  BookieSocketAddress replicaToKill=LedgerHandleAdapter.getLedgerMetadata(lh).getEnsembles().get(0L).get(0);
  LOG.info("Killing Bookie",replicaToKill);
  ServerConfiguration killedBookieConfig=killBookie(replicaToKill);
  int startNewBookie=startNewBookie();
  BookieSocketAddress newBkAddr=new BookieSocketAddress(InetAddress.getLocalHost().getHostAddress(),startNewBookie);
  LOG.info("New Bookie addr :" + newBkAddr);
  killAllBookies(lh,newBkAddr);
  ReplicationWorker rw=new ReplicationWorker(zkc,baseConf,newBkAddr);
  rw.start();
  try {
    underReplicationManager.markLedgerUnderreplicated(lh.getId(),replicaToKill.toString());
    int counter=30;
    while (counter-- > 0) {
      assertTrue("Expecting that replication should not complete",ReplicationTestUtil.isLedgerInUnderReplication(zkc,lh.getId(),basePath));
      Thread.sleep(100);
    }
    bs.add(startBookie(killedBookieConfig));
    bsConfs.add(killedBookieConfig);
    while (ReplicationTestUtil.isLedgerInUnderReplication(zkc,lh.getId(),basePath)) {
      Thread.sleep(100);
    }
    verifyRecoveredLedgers(lh,0,9);
  }
  finally {
    rw.shutdown();
  }
}

</code></pre>

<br>
<pre class="type-3 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
"></span><br>
/** 
 * Test that if the local bookie turns out to be readonly, then no point in running RW. So RW should shutdown.
 */
@Test(timeout=20000) public void testRWShutdownOnLocalBookieReadonlyTransition() throws Exception {
  LedgerHandle lh=bkc.createLedger(3,3,BookKeeper.DigestType.CRC32,TESTPASSWD);
  for (int i=0; i < 10; i++) {
    lh.addEntry(data);
  }
  BookieSocketAddress replicaToKill=LedgerHandleAdapter.getLedgerMetadata(lh).getEnsembles().get(0L).get(0);
  LOG.info("Killing Bookie",replicaToKill);
  killBookie(replicaToKill);
  int newBkPort=startNewBookie();
  for (int i=0; i < 10; i++) {
    lh.addEntry(data);
  }
  BookieSocketAddress newBkAddr=new BookieSocketAddress(InetAddress.getLocalHost().getHostAddress(),newBkPort);
  LOG.info("New Bookie addr :" + newBkAddr);
  ReplicationWorker rw=new ReplicationWorker(zkc,baseConf,newBkAddr);
  rw.start();
  try {
    BookieServer newBk=bs.get(bs.size() - 1);
    bsConfs.get(bsConfs.size() - 1).setReadOnlyModeEnabled(true);
    newBk.getBookie().doTransitionToReadOnlyMode();
    underReplicationManager.markLedgerUnderreplicated(lh.getId(),replicaToKill.toString());
    while (ReplicationTestUtil.isLedgerInUnderReplication(zkc,lh.getId(),basePath) && rw.isRunning()) {
      Thread.sleep(100);
    }
    assertFalse("RW should shutdown if the bookie is readonly",rw.isRunning());
  }
  finally {
    rw.shutdown();
  }
}

</code></pre>

<br>
<pre class="type-2 type-11 type-3 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions in iterations
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
"></span><br>
/** 
 * Tests that replication worker1 should take one fragment replication and
 * other replication worker also should compete for the replication.
 */
@Test(timeout=90000) public void test2RWsShouldCompeteForReplicationOf2FragmentsAndCompleteReplication() throws Exception {
  LedgerHandle lh=bkc.createLedger(2,2,BookKeeper.DigestType.CRC32,TESTPASSWD);
  for (int i=0; i < 10; i++) {
    lh.addEntry(data);
  }
  lh.close();
  BookieSocketAddress replicaToKill=LedgerHandleAdapter.getLedgerMetadata(lh).getEnsembles().get(0L).get(0);
  LOG.info("Killing Bookie",replicaToKill);
  ServerConfiguration killedBookieConfig=killBookie(replicaToKill);
  killAllBookies(lh,null);
  int startNewBookie1=startNewBookie();
  BookieSocketAddress newBkAddr1=new BookieSocketAddress(InetAddress.getLocalHost().getHostAddress(),startNewBookie1);
  LOG.info("New Bookie addr :" + newBkAddr1);
  ReplicationWorker rw1=new ReplicationWorker(zkc,baseConf,newBkAddr1);
  int startNewBookie2=startNewBookie();
  BookieSocketAddress newBkAddr2=new BookieSocketAddress(InetAddress.getLocalHost().getHostAddress(),startNewBookie2);
  LOG.info("New Bookie addr :" + newBkAddr2);
  ZooKeeper zkc1=ZooKeeperClient.newBuilder().connectString(zkUtil.getZooKeeperConnectString()).sessionTimeoutMs(10000).build();
  ReplicationWorker rw2=new ReplicationWorker(zkc1,baseConf,newBkAddr2);
  rw1.start();
  rw2.start();
  try {
    underReplicationManager.markLedgerUnderreplicated(lh.getId(),replicaToKill.toString());
    int counter=10;
    while (counter-- > 0) {
      assertTrue("Expecting that replication should not complete",ReplicationTestUtil.isLedgerInUnderReplication(zkc,lh.getId(),basePath));
      Thread.sleep(100);
    }
    bs.add(startBookie(killedBookieConfig));
    bsConfs.add(killedBookieConfig);
    while (ReplicationTestUtil.isLedgerInUnderReplication(zkc,lh.getId(),basePath)) {
      Thread.sleep(100);
    }
    verifyRecoveredLedgers(lh,0,9);
  }
  finally {
    rw1.shutdown();
    rw2.shutdown();
    zkc1.close();
  }
}

</code></pre>

<br>
<pre class="type-3 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
"></span><br>
/** 
 * Test that the replication worker will shutdown if it lose its zookeeper session
 */
@Test(timeout=30000) public void testRWZKSessionLost() throws Exception {
  ZooKeeper zk=ZooKeeperClient.newBuilder().connectString(zkUtil.getZooKeeperConnectString()).sessionTimeoutMs(10000).build();
  try {
    ReplicationWorker rw=new ReplicationWorker(zk,baseConf,getBookie(0));
    rw.start();
    for (int i=0; i < 10; i++) {
      if (rw.isRunning()) {
        break;
      }
      Thread.sleep(1000);
    }
    assertTrue("Replication worker should be running",rw.isRunning());
    stopZKCluster();
    for (int i=0; i < 10; i++) {
      if (!rw.isRunning()) {
        break;
      }
      Thread.sleep(1000);
    }
    assertFalse("Replication worker should have shut down",rw.isRunning());
  }
  finally {
    zk.close();
  }
}

</code></pre>

<br>
<pre class="type-2 type-3 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
"></span><br>
/** 
 * Tests that ReplicationWorker should not have identified for postponing
 * the replication if ledger is in open state and lastFragment is not in
 * underReplication state. Note that RW should not fence such ledgers.
 */
@Test(timeout=30000) public void testRWShouldReplicateTheLedgersAfterTimeoutIfLastFragmentIsNotUR() throws Exception {
  LedgerHandle lh=bkc.createLedger(3,3,BookKeeper.DigestType.CRC32,TESTPASSWD);
  for (int i=0; i < 10; i++) {
    lh.addEntry(data);
  }
  BookieSocketAddress replicaToKill=LedgerHandleAdapter.getLedgerMetadata(lh).getEnsembles().get(0L).get(0);
  LOG.info("Killing Bookie",replicaToKill);
  killBookie(replicaToKill);
  int startNewBookie=startNewBookie();
  for (int i=0; i < 10; i++) {
    lh.addEntry(data);
  }
  BookieSocketAddress newBkAddr=new BookieSocketAddress(InetAddress.getLocalHost().getHostAddress(),startNewBookie);
  LOG.info("New Bookie addr :" + newBkAddr);
  ReplicationWorker rw=new ReplicationWorker(zkc,baseConf,newBkAddr);
  LedgerManagerFactory mFactory=LedgerManagerFactory.newLedgerManagerFactory(baseClientConf,zkc);
  LedgerUnderreplicationManager underReplicationManager=mFactory.newLedgerUnderreplicationManager();
  rw.start();
  try {
    underReplicationManager.markLedgerUnderreplicated(lh.getId(),replicaToKill.toString());
    while (ReplicationTestUtil.isLedgerInUnderReplication(zkc,lh.getId(),basePath)) {
      Thread.sleep(100);
    }
    killAllBookies(lh,newBkAddr);
    verifyRecoveredLedgers(lh,0,9);
    lh=bkc.openLedgerNoRecovery(lh.getId(),BookKeeper.DigestType.CRC32,TESTPASSWD);
    assertTrue("Ledger must have been closed by RW",ClientUtil.isLedgerOpen(lh));
  }
  finally {
    rw.shutdown();
    underReplicationManager.close();
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.bookkeeper.test.AsyncLedgerOpsTest </h4><pre class="type-2 type-11 type-8 type-3 type-4 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions in iterations
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testAsyncCreateClose() throws IOException, BKException {
  try {
    ControlObj ctx=new ControlObj();
synchronized (ctx) {
      LOG.info("Going to create ledger asynchronously");
      bkc.asyncCreateLedger(3,2,digestType,ledgerPassword,this,ctx);
      ctx.wait();
    }
    LedgerHandle lh=ctx.getLh();
    ledgerId=lh.getId();
    LOG.info("Ledger ID: " + lh.getId());
    for (int i=0; i < numEntriesToWrite; i++) {
      ByteBuffer entry=ByteBuffer.allocate(4);
      entry.putInt(rng.nextInt(maxInt));
      entry.position(0);
      entries.add(entry.array());
      entriesSize.add(entry.array().length);
      lh.asyncAddEntry(entry.array(),this,sync);
    }
synchronized (sync) {
      while (sync.counter < numEntriesToWrite) {
        LOG.debug("Entries counter = " + sync.counter);
        sync.wait();
      }
    }
    LOG.info("*** WRITE COMPLETE ***");
synchronized (ctx) {
      lh.asyncClose(this,ctx);
      ctx.wait();
    }
synchronized (ctx) {
      bkc.asyncOpenLedger(ledgerId,digestType,ledgerPassword,this,ctx);
      ctx.wait();
    }
    lh=ctx.getLh();
    LOG.debug("Number of entries written: " + lh.getLastAddConfirmed());
    assertTrue("Verifying number of entries written",lh.getLastAddConfirmed() == (numEntriesToWrite - 1));
    lh.asyncReadEntries(0,numEntriesToWrite - 1,this,sync);
synchronized (sync) {
      while (sync.value == false) {
        sync.wait();
      }
    }
    LOG.debug("*** READ COMPLETE ***");
    int i=0;
    while (ls.hasMoreElements()) {
      ByteBuffer origbb=ByteBuffer.wrap(entries.get(i));
      Integer origEntry=origbb.getInt();
      byte[] entry=ls.nextElement().getEntry();
      ByteBuffer result=ByteBuffer.wrap(entry);
      LOG.debug("Length of result: " + result.capacity());
      LOG.debug("Original entry: " + origEntry);
      Integer retrEntry=result.getInt();
      LOG.debug("Retrieved entry: " + retrEntry);
      assertTrue("Checking entry " + i + " for equality",origEntry.equals(retrEntry));
      assertTrue("Checking entry " + i + " for size",entry.length == entriesSize.get(i).intValue());
      i++;
    }
    assertTrue("Checking number of read entries",i == numEntriesToWrite);
    lh.close();
  }
 catch (  InterruptedException e) {
    LOG.error("Interrupted",e);
    fail("InterruptedException");
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.bookkeeper.test.BookieJournalRollingTest </h4><pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies boolean conditions
"></span><br>
/** 
 * This test writes enough ledger entries to roll over the journals
 * It will then keep only 1 journal file before last marked journal
 * @throws Exception
 */
@Test(timeout=60000) public void testJournalRolling() throws Exception {
  if (LOG.isDebugEnabled()) {
    LOG.debug("Testing Journal Rolling");
  }
  LedgerHandle[] lhs=writeLedgerEntries(4,1024,1024);
  long[] ledgerIds=new long[lhs.length];
  for (int i=0; i < lhs.length; i++) {
    ledgerIds[i]=lhs[i].getId();
    lhs[i].close();
  }
  Thread.sleep(2000);
  for (  File journalDir : tmpDirs) {
    File[] journals=journalDir.listFiles();
    int numJournals=0;
    for (    File f : journals) {
      if (!f.getName().endsWith(".txn")) {
        continue;
      }
      ++numJournals;
    }
    assertTrue(numJournals <= 2);
  }
  restartBookies();
  validLedgerEntries(ledgerIds,1024,1024);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.bookkeeper.test.BookieReadWriteTest </h4><pre class="type-2 type-8 type-3 type-4 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testReadFromOpenLedgerOpenOnce() throws Exception {
  try {
    lh=bkc.createLedger(digestType,ledgerPassword);
    ledgerId=lh.getId();
    LOG.info("Ledger ID: " + lh.getId());
    LedgerHandle lhOpen=bkc.openLedgerNoRecovery(ledgerId,digestType,ledgerPassword);
    writeNEntriesLastWriteSync(lh,numEntriesToWrite / 2);
    ByteBuffer entry=ByteBuffer.allocate(4);
    entry.putInt(rng.nextInt(maxInt));
    entry.position(0);
    int toRead=numEntriesToWrite / 2 - 2;
    long readLastConfirmed=lhOpen.readLastConfirmed();
    assertTrue(readLastConfirmed != 0);
    Enumeration<LedgerEntry> readEntry=lhOpen.readEntries(toRead,toRead);
    assertTrue("Enumeration of ledger entries has no element",readEntry.hasMoreElements() == true);
    LedgerEntry e=readEntry.nextElement();
    assertEquals(toRead,e.getEntryId());
    Assert.assertArrayEquals(entries.get(toRead),e.getEntry());
    try {
      lhOpen.addEntry(entry.array());
      fail("Should have thrown an exception here");
    }
 catch (    BKException.BKIllegalOpException bkioe) {
    }
catch (    Exception ex) {
      LOG.error("Unexpected exception",ex);
      fail("Unexpected exception");
    }
    writeNEntriesLastWriteSync(lh,numEntriesToWrite / 2);
    long last=lh.readLastConfirmed();
    assertTrue("Last confirmed add: " + last,last == (numEntriesToWrite - 2));
    LOG.debug("*** WRITE COMPLETE ***");
    lh.close();
    lhOpen.close();
  }
 catch (  BKException e) {
    LOG.error("Test failed",e);
    fail("Test failed due to BookKeeper exception");
  }
catch (  InterruptedException e) {
    LOG.error("Test failed",e);
    fail("Test failed due to interruption");
  }
}

</code></pre>

<br>
<pre class="type-2 type-8 type-3 type-4 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testReadFromOpenLedgerZeroAndOne() throws Exception {
  try {
    lh=bkc.createLedger(digestType,ledgerPassword);
    ledgerId=lh.getId();
    LOG.info("Ledger ID: " + lh.getId());
    LedgerHandle lhOpen=bkc.openLedgerNoRecovery(ledgerId,digestType,ledgerPassword);
    LOG.debug("Checking that it is empty");
    long readLastConfirmed=lhOpen.readLastConfirmed();
    assertTrue("Last confirmed has the wrong value",readLastConfirmed == LedgerHandle.INVALID_ENTRY_ID);
    LOG.debug("Going to write one entry");
    ByteBuffer entry=ByteBuffer.allocate(4);
    entry.putInt(rng.nextInt(maxInt));
    entry.position(0);
    entries.add(entry.array());
    entriesSize.add(entry.array().length);
    lh.addEntry(entry.array());
    LOG.debug("Checking that it is still empty even after writing one entry");
    readLastConfirmed=lhOpen.readLastConfirmed();
    assertTrue(readLastConfirmed == LedgerHandle.INVALID_ENTRY_ID);
    entry=ByteBuffer.allocate(4);
    entry.putInt(rng.nextInt(maxInt));
    entry.position(0);
    entries.add(entry.array());
    entriesSize.add(entry.array().length);
    lh.addEntry(entry.array());
    LOG.info("Checking that it has an entry");
    readLastConfirmed=lhOpen.readLastConfirmed();
    assertTrue(readLastConfirmed == 0L);
    lh.close();
    lhOpen.close();
  }
 catch (  BKException e) {
    LOG.error("Test failed",e);
    fail("Test failed due to BookKeeper exception");
  }
catch (  InterruptedException e) {
    LOG.error("Test failed",e);
    fail("Test failed due to interruption");
  }
}

</code></pre>

<br>
<pre class="type-2 type-8 type-3 type-4 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testLastConfirmedAdd() throws Exception {
  try {
    lh=bkc.createLedger(digestType,ledgerPassword);
    ledgerId=lh.getId();
    LOG.info("Ledger ID: " + lh.getId());
    writeNEntriesLastWriteSync(lh,numEntriesToWrite);
    long last=lh.readLastConfirmed();
    assertTrue("Last confirmed add: " + last,last == (numEntriesToWrite - 2));
    LOG.debug("*** WRITE COMPLETE ***");
    lh.close();
    lh=bkc.createLedger(digestType,ledgerPassword);
    ledgerId=lh.getId();
    LOG.info("Ledger ID: " + lh.getId());
    writeNEntriesLastWriteSync(lh,numEntriesToWrite);
    SyncObj sync=new SyncObj();
    lh.asyncReadLastConfirmed(this,sync);
synchronized (sync) {
      while (sync.lastConfirmed == LedgerHandle.INVALID_ENTRY_ID) {
        LOG.debug("Counter = " + sync.lastConfirmed);
        sync.wait();
      }
      assertEquals("Error reading",BKException.Code.OK,sync.getReturnCode());
    }
    assertTrue("Last confirmed add: " + sync.lastConfirmed,sync.lastConfirmed == (numEntriesToWrite - 2));
    LOG.debug("*** WRITE COMPLETE ***");
    lh.close();
  }
 catch (  BKException e) {
    LOG.error("Test failed",e);
    fail("Test failed due to BookKeeper exception");
  }
catch (  InterruptedException e) {
    LOG.error("Test failed",e);
    fail("Test failed due to interruption");
  }
}

</code></pre>

<br>
<pre class="type-2 type-11 type-8 type-3 type-4 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions in iterations
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testReadWriteZero() throws IOException {
  try {
    lh=bkc.createLedger(digestType,ledgerPassword);
    ledgerId=lh.getId();
    LOG.info("Ledger ID: " + lh.getId());
    final CountDownLatch completeLatch=new CountDownLatch(numEntriesToWrite);
    final AtomicInteger rc=new AtomicInteger(BKException.Code.OK);
    for (int i=0; i < numEntriesToWrite; i++) {
      lh.asyncAddEntry(new byte[0],new AddCallback(){
        public void addComplete(        int rccb,        LedgerHandle lh,        long entryId,        Object ctx){
          rc.compareAndSet(BKException.Code.OK,rccb);
          completeLatch.countDown();
        }
      }
,null);
    }
    completeLatch.await();
    if (rc.get() != BKException.Code.OK) {
      throw BKException.create(rc.get());
    }
    ByteBuffer entry=ByteBuffer.allocate(4);
    entry.putInt(rng.nextInt(maxInt));
    entry.position(0);
    entries.add(entry.array());
    lh.addEntry(entry.array());
    lh.close();
    lh=bkc.openLedger(ledgerId,digestType,ledgerPassword);
    LOG.debug("Number of entries written: " + lh.getLastAddConfirmed());
    assertTrue("Verifying number of entries written",lh.getLastAddConfirmed() == numEntriesToWrite);
    Enumeration<LedgerEntry> ls=lh.readEntries(0,numEntriesToWrite - 1);
    int i=0;
    while (ls.hasMoreElements()) {
      ByteBuffer result=ByteBuffer.wrap(ls.nextElement().getEntry());
      LOG.debug("Length of result: " + result.capacity());
      assertTrue("Checking if entry " + i + " has zero bytes",result.capacity() == 0);
    }
    lh.close();
  }
 catch (  BKException e) {
    LOG.error("Test failed",e);
    fail("Test failed due to BookKeeper exception");
  }
catch (  InterruptedException e) {
    LOG.error("Test failed",e);
    fail("Test failed due to interruption");
  }
}

</code></pre>

<br>
<pre class="type-2 type-11 type-8 type-3 type-4 type-7 type-9 type-13 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values related to public fields.">PublicFieldVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions in iterations
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects are null
- Verifies whether objects/variable are equal to an expected value 
- Verifies values related to public fields.
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Check that the add api with offset and length work correctly.
 * First try varying the offset. Then the length with a fixed non-zero
 * offset.
 */
@Test(timeout=60000) public void testReadWriteRangeAsyncSingleClient() throws IOException {
  SyncObj sync=new SyncObj();
  try {
    lh=bkc.createLedger(digestType,ledgerPassword);
    ledgerId=lh.getId();
    LOG.info("Ledger ID: " + lh.getId());
    byte bytes[]={'a','b','c','d','e','f','g','h','i'};
    lh.asyncAddEntry(bytes,0,bytes.length,this,sync);
    lh.asyncAddEntry(bytes,0,4,this,sync);
    lh.asyncAddEntry(bytes,3,4,this,sync);
    lh.asyncAddEntry(bytes,3,(bytes.length - 3),this,sync);
    int numEntries=4;
synchronized (sync) {
      while (sync.counter < numEntries) {
        LOG.debug("Entries counter = " + sync.counter);
        sync.wait();
      }
      assertEquals("Error adding",BKException.Code.OK,sync.getReturnCode());
    }
    try {
      lh.asyncAddEntry(bytes,-1,bytes.length,this,sync);
      fail("Shouldn't be able to use negative offset");
    }
 catch (    ArrayIndexOutOfBoundsException aiob) {
    }
    try {
      lh.asyncAddEntry(bytes,0,bytes.length + 1,this,sync);
      fail("Shouldn't be able to use that much length");
    }
 catch (    ArrayIndexOutOfBoundsException aiob) {
    }
    try {
      lh.asyncAddEntry(bytes,-1,bytes.length + 2,this,sync);
      fail("Shouldn't be able to use negative offset " + "with that much length");
    }
 catch (    ArrayIndexOutOfBoundsException aiob) {
    }
    try {
      lh.asyncAddEntry(bytes,4,-3,this,sync);
      fail("Shouldn't be able to use negative length");
    }
 catch (    ArrayIndexOutOfBoundsException aiob) {
    }
    try {
      lh.asyncAddEntry(bytes,-4,-3,this,sync);
      fail("Shouldn't be able to use negative offset & length");
    }
 catch (    ArrayIndexOutOfBoundsException aiob) {
    }
    LOG.debug("*** WRITE COMPLETE ***");
    lh.close();
    lh=bkc.openLedger(ledgerId,digestType,ledgerPassword);
    LOG.debug("Number of entries written: " + (lh.getLastAddConfirmed() + 1));
    assertTrue("Verifying number of entries written",lh.getLastAddConfirmed() == (numEntries - 1));
    lh.asyncReadEntries(0,numEntries - 1,this,sync);
synchronized (sync) {
      while (sync.value == false) {
        sync.wait();
      }
      assertEquals("Error reading",BKException.Code.OK,sync.getReturnCode());
    }
    LOG.debug("*** READ COMPLETE ***");
    int i=0;
    Enumeration<LedgerEntry> ls=sync.getLedgerEntries();
    while (ls.hasMoreElements()) {
      byte[] expected=null;
      byte[] entry=ls.nextElement().getEntry();
switch (i) {
case 0:
        expected=Arrays.copyOfRange(bytes,0,bytes.length);
      break;
case 1:
    expected=Arrays.copyOfRange(bytes,0,4);
  break;
case 2:
expected=Arrays.copyOfRange(bytes,3,3 + 4);
break;
case 3:
expected=Arrays.copyOfRange(bytes,3,3 + (bytes.length - 3));
break;
}
assertNotNull("There are more checks than writes",expected);
String message="Checking entry " + i + " for equality ["+ new String(entry,"UTF-8")+ ","+ new String(expected,"UTF-8")+ "]";
assertTrue(message,Arrays.equals(entry,expected));
i++;
}
assertTrue("Checking number of read entries",i == numEntries);
lh.close();
}
 catch (BKException e) {
LOG.error("Test failed",e);
fail("Test failed due to BookKeeper exception");
}
catch (InterruptedException e) {
LOG.error("Test failed",e);
fail("Test failed due to interruption");
}
}

</code></pre>

<br>
<pre class="type-2 type-11 type-8 type-3 type-4 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions in iterations
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testSyncReadAsyncWriteStringsSingleClient() throws IOException {
  SyncObj sync=new SyncObj();
  LOG.info("TEST READ WRITE STRINGS MIXED SINGLE CLIENT");
  String charset="utf-8";
  LOG.debug("Default charset: " + Charset.defaultCharset());
  try {
    lh=bkc.createLedger(digestType,ledgerPassword);
    ledgerId=lh.getId();
    LOG.info("Ledger ID: " + lh.getId());
    for (int i=0; i < numEntriesToWrite; i++) {
      int randomInt=rng.nextInt(maxInt);
      byte[] entry=new String(Integer.toString(randomInt)).getBytes(charset);
      entries.add(entry);
      lh.asyncAddEntry(entry,this,sync);
    }
synchronized (sync) {
      while (sync.counter < numEntriesToWrite) {
        LOG.debug("Entries counter = " + sync.counter);
        sync.wait();
      }
      assertEquals("Error adding",BKException.Code.OK,sync.getReturnCode());
    }
    LOG.debug("*** ASYNC WRITE COMPLETE ***");
    lh.close();
    lh=bkc.openLedger(ledgerId,digestType,ledgerPassword);
    LOG.debug("Number of entries written: " + (lh.getLastAddConfirmed() + 1));
    assertTrue("Verifying number of entries written",lh.getLastAddConfirmed() == (numEntriesToWrite - 1));
    Enumeration<LedgerEntry> ls=lh.readEntries(0,numEntriesToWrite - 1);
    LOG.debug("*** SYNC READ COMPLETE ***");
    int i=0;
    while (ls.hasMoreElements()) {
      byte[] origEntryBytes=entries.get(i++);
      byte[] retrEntryBytes=ls.nextElement().getEntry();
      LOG.debug("Original byte entry size: " + origEntryBytes.length);
      LOG.debug("Saved byte entry size: " + retrEntryBytes.length);
      String origEntry=new String(origEntryBytes,charset);
      String retrEntry=new String(retrEntryBytes,charset);
      LOG.debug("Original entry: " + origEntry);
      LOG.debug("Retrieved entry: " + retrEntry);
      assertTrue("Checking entry " + i + " for equality",origEntry.equals(retrEntry));
    }
    assertTrue("Checking number of read entries",i == numEntriesToWrite);
    lh.close();
  }
 catch (  BKException e) {
    LOG.error("Test failed",e);
    fail("Test failed due to BookKeeper exception");
  }
catch (  InterruptedException e) {
    LOG.error("Test failed",e);
    fail("Test failed due to interruption");
  }
}

</code></pre>

<br>
<pre class="type-2 type-4 type-13 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values related to public fields.">PublicFieldVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies boolean conditions
- Verifies values related to public fields.
"></span><br>
/** 
 * test the streaming api for reading and writing
 * @throws {@link IOException}
 */
@Test(timeout=60000) public void testStreamingClients() throws IOException, BKException, InterruptedException {
  lh=bkc.createLedger(digestType,ledgerPassword);
  String toWrite="we need to check for this string to match " + "and for the record mahadev is the best";
  LedgerOutputStream lout=new LedgerOutputStream(lh,1);
  byte[] b=toWrite.getBytes();
  lout.write(b);
  lout.close();
  long lId=lh.getId();
  lh.close();
  lh=bkc.openLedger(lId,digestType,ledgerPassword);
  LedgerInputStream lin=new LedgerInputStream(lh,1);
  byte[] bread=new byte[b.length];
  int read=0;
  while (read < b.length) {
    read=read + lin.read(bread,read,b.length);
  }
  String newString=new String(bread);
  assertTrue("these two should same",toWrite.equals(newString));
  lin.close();
  lh.close();
  lh=bkc.createLedger(digestType,ledgerPassword);
  lout=new LedgerOutputStream(lh);
  for (int i=0; i < b.length; i++) {
    lout.write(b[i]);
  }
  lout.close();
  lId=lh.getId();
  lh.close();
  lh=bkc.openLedger(lId,digestType,ledgerPassword);
  lin=new LedgerInputStream(lh);
  bread=new byte[b.length];
  read=0;
  while (read < b.length) {
    read=read + lin.read(bread,read,b.length);
  }
  newString=new String(bread);
  assertTrue("these two should be same ",toWrite.equals(newString));
  lin.close();
  lh.close();
}

</code></pre>

<br>
<pre class="type-2 type-11 type-8 type-3 type-4 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions in iterations
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testReadWriteSyncSingleClient() throws IOException {
  try {
    lh=bkc.createLedger(digestType,ledgerPassword);
    ledgerId=lh.getId();
    LOG.info("Ledger ID: " + lh.getId());
    for (int i=0; i < numEntriesToWrite; i++) {
      ByteBuffer entry=ByteBuffer.allocate(4);
      entry.putInt(rng.nextInt(maxInt));
      entry.position(0);
      entries.add(entry.array());
      lh.addEntry(entry.array());
    }
    lh.close();
    lh=bkc.openLedger(ledgerId,digestType,ledgerPassword);
    LOG.debug("Number of entries written: " + lh.getLastAddConfirmed());
    assertTrue("Verifying number of entries written",lh.getLastAddConfirmed() == (numEntriesToWrite - 1));
    Enumeration<LedgerEntry> ls=lh.readEntries(0,numEntriesToWrite - 1);
    int i=0;
    while (ls.hasMoreElements()) {
      ByteBuffer origbb=ByteBuffer.wrap(entries.get(i++));
      Integer origEntry=origbb.getInt();
      ByteBuffer result=ByteBuffer.wrap(ls.nextElement().getEntry());
      LOG.debug("Length of result: " + result.capacity());
      LOG.debug("Original entry: " + origEntry);
      Integer retrEntry=result.getInt();
      LOG.debug("Retrieved entry: " + retrEntry);
      assertTrue("Checking entry " + i + " for equality",origEntry.equals(retrEntry));
    }
    lh.close();
  }
 catch (  BKException e) {
    LOG.error("Test failed",e);
    fail("Test failed due to BookKeeper exception");
  }
catch (  InterruptedException e) {
    LOG.error("Test failed",e);
    fail("Test failed due to interruption");
  }
}

</code></pre>

<br>
<pre class="type-2 type-8 type-3 type-4 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testReadWriteAsyncLength() throws IOException {
  SyncObj sync=new SyncObj();
  try {
    lh=bkc.createLedger(digestType,ledgerPassword);
    ledgerId=lh.getId();
    LOG.info("Ledger ID: " + lh.getId());
    for (int i=0; i < numEntriesToWrite; i++) {
      ByteBuffer entry=ByteBuffer.allocate(4);
      entry.putInt(rng.nextInt(maxInt));
      entry.position(0);
      entries.add(entry.array());
      entriesSize.add(entry.array().length);
      lh.asyncAddEntry(entry.array(),this,sync);
    }
synchronized (sync) {
      while (sync.counter < numEntriesToWrite) {
        LOG.debug("Entries counter = " + sync.counter);
        sync.wait();
      }
      assertEquals("Error adding",BKException.Code.OK,sync.getReturnCode());
    }
    long length=numEntriesToWrite * 4;
    assertTrue("Ledger length before closing: " + lh.getLength(),lh.getLength() == length);
    LOG.debug("*** WRITE COMPLETE ***");
    lh.close();
    lh=bkc.openLedger(ledgerId,digestType,ledgerPassword);
    assertTrue("Ledger length after opening: " + lh.getLength(),lh.getLength() == length);
    lh.close();
  }
 catch (  BKException e) {
    LOG.error("Test failed",e);
    fail("Test failed due to BookKeeper exception");
  }
catch (  InterruptedException e) {
    LOG.error("Test failed",e);
    fail("Test failed due to interruption");
  }
}

</code></pre>

<br>
<pre class="type-2 type-8 type-3 type-4 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testReadFromOpenLedger() throws Exception {
  try {
    lh=bkc.createLedger(digestType,ledgerPassword);
    ledgerId=lh.getId();
    LOG.info("Ledger ID: " + lh.getId());
    long lac=writeNEntriesLastWriteSync(lh,numEntriesToWrite);
    LedgerHandle lhOpen=bkc.openLedgerNoRecovery(ledgerId,digestType,ledgerPassword);
    long toRead=lac - 1;
    Enumeration<LedgerEntry> readEntry=lhOpen.readEntries(toRead,toRead);
    assertTrue("Enumeration of ledger entries has no element",readEntry.hasMoreElements() == true);
    LedgerEntry e=readEntry.nextElement();
    assertEquals(toRead,e.getEntryId());
    Assert.assertArrayEquals(entries.get((int)toRead),e.getEntry());
    try {
      ByteBuffer entry=ByteBuffer.allocate(4);
      entry.putInt(rng.nextInt(maxInt));
      entry.position(0);
      lhOpen.addEntry(entry.array());
      fail("Should have thrown an exception here");
    }
 catch (    BKException.BKIllegalOpException bkioe) {
    }
catch (    Exception ex) {
      LOG.error("Unexpected exception",ex);
      fail("Unexpected exception");
    }
    lhOpen.close();
    lac=writeNEntriesLastWriteSync(lh,numEntriesToWrite);
    assertEquals("Last confirmed add: ",lac,(numEntriesToWrite * 2) - 1);
    LOG.debug("*** WRITE COMPLETE ***");
    lh.close();
    lh=bkc.createLedger(digestType,ledgerPassword);
    ledgerId=lh.getId();
    writeNEntriesLastWriteSync(lh,numEntriesToWrite);
    SyncObj sync=new SyncObj();
    lh.asyncReadLastConfirmed(this,sync);
synchronized (sync) {
      while (sync.lastConfirmed == -1) {
        LOG.debug("Counter = " + sync.lastConfirmed);
        sync.wait();
      }
      assertEquals("Error reading",BKException.Code.OK,sync.getReturnCode());
    }
    assertEquals("Last confirmed add",sync.lastConfirmed,(numEntriesToWrite - 2));
    LOG.debug("*** WRITE COMPLETE ***");
    lh.close();
  }
 catch (  BKException e) {
    LOG.error("Test failed",e);
    fail("Test failed due to BookKeeper exception");
  }
catch (  InterruptedException e) {
    LOG.error("Test failed",e);
    fail("Test failed due to interruption");
  }
}

</code></pre>

<br>
<pre class="type-2 type-11 type-8 type-3 type-4 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions in iterations
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testMultiLedger() throws IOException {
  try {
    lh=bkc.createLedger(digestType,ledgerPassword);
    lh2=bkc.createLedger(digestType,ledgerPassword);
    long ledgerId=lh.getId();
    long ledgerId2=lh2.getId();
    final CountDownLatch completeLatch=new CountDownLatch(numEntriesToWrite * 2);
    final AtomicInteger rc=new AtomicInteger(BKException.Code.OK);
    LOG.info("Ledger ID 1: " + lh.getId() + ", Ledger ID 2: "+ lh2.getId());
    for (int i=0; i < numEntriesToWrite; i++) {
      lh.asyncAddEntry(new byte[0],new AddCallback(){
        public void addComplete(        int rc2,        LedgerHandle lh,        long entryId,        Object ctx){
          rc.compareAndSet(BKException.Code.OK,rc2);
          completeLatch.countDown();
        }
      }
,null);
      lh2.asyncAddEntry(new byte[0],new AddCallback(){
        public void addComplete(        int rc2,        LedgerHandle lh,        long entryId,        Object ctx){
          rc.compareAndSet(BKException.Code.OK,rc2);
          completeLatch.countDown();
        }
      }
,null);
    }
    completeLatch.await();
    if (rc.get() != BKException.Code.OK) {
      throw BKException.create(rc.get());
    }
    lh.close();
    lh2.close();
    lh=bkc.openLedger(ledgerId,digestType,ledgerPassword);
    lh2=bkc.openLedger(ledgerId2,digestType,ledgerPassword);
    LOG.debug("Number of entries written: " + lh.getLastAddConfirmed() + ", "+ lh2.getLastAddConfirmed());
    assertTrue("Verifying number of entries written lh (" + lh.getLastAddConfirmed() + ")",lh.getLastAddConfirmed() == (numEntriesToWrite - 1));
    assertTrue("Verifying number of entries written lh2 (" + lh2.getLastAddConfirmed() + ")",lh2.getLastAddConfirmed() == (numEntriesToWrite - 1));
    Enumeration<LedgerEntry> ls=lh.readEntries(0,numEntriesToWrite - 1);
    int i=0;
    while (ls.hasMoreElements()) {
      ByteBuffer result=ByteBuffer.wrap(ls.nextElement().getEntry());
      LOG.debug("Length of result: " + result.capacity());
      assertTrue("Checking if entry " + i + " has zero bytes",result.capacity() == 0);
    }
    lh.close();
    ls=lh2.readEntries(0,numEntriesToWrite - 1);
    i=0;
    while (ls.hasMoreElements()) {
      ByteBuffer result=ByteBuffer.wrap(ls.nextElement().getEntry());
      LOG.debug("Length of result: " + result.capacity());
      assertTrue("Checking if entry " + i + " has zero bytes",result.capacity() == 0);
    }
    lh2.close();
  }
 catch (  BKException e) {
    LOG.error("Test failed",e);
    fail("Test failed due to BookKeeper exception");
  }
catch (  InterruptedException e) {
    LOG.error("Test failed",e);
    fail("Test failed due to interruption");
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.bookkeeper.test.BookieZKExpireTest </h4><pre class="type-2 type-11 type-6 type-8 type-3 type-4 type-7 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions in iterations
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@SuppressWarnings("deprecation") @Test(timeout=60000) public void testBookieServerZKExpireBehaviour() throws Exception {
  BookieServer server=null;
  try {
    File f=createTempDir("bookieserver","test");
    HashSet<Thread> threadset=new HashSet<Thread>();
    int threadCount=Thread.activeCount();
    Thread threads[]=new Thread[threadCount * 2];
    threadCount=Thread.enumerate(threads);
    for (int i=0; i < threadCount; i++) {
      if (threads[i].getName().indexOf("SendThread") != -1) {
        threadset.add(threads[i]);
      }
    }
    ServerConfiguration conf=newServerConfiguration(PortManager.nextFreePort(),zkUtil.getZooKeeperConnectString(),f,new File[]{f});
    server=new BookieServer(conf);
    server.start();
    int secondsToWait=5;
    while (!server.isRunning()) {
      Thread.sleep(1000);
      if (secondsToWait-- <= 0) {
        fail("Bookie never started");
      }
    }
    Thread sendthread=null;
    threadCount=Thread.activeCount();
    threads=new Thread[threadCount * 2];
    threadCount=Thread.enumerate(threads);
    for (int i=0; i < threadCount; i++) {
      if (threads[i].getName().indexOf("SendThread") != -1 && !threadset.contains(threads[i])) {
        sendthread=threads[i];
        break;
      }
    }
    assertNotNull("Send thread not found",sendthread);
    sendthread.suspend();
    Thread.sleep(2 * conf.getZkTimeout());
    sendthread.resume();
    Thread.sleep(3000);
    assertTrue("Bookie should not shutdown on losing zk session",server.isBookieRunning());
    assertTrue("Bookie Server should not shutdown on losing zk session",server.isRunning());
  }
  finally {
    server.shutdown();
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.bookkeeper.test.ForceReadOnlyBookieTest </h4><pre class="type-2 type-11 type-3 type-4 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions in iterations
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Check force start readonly bookie
 */
@Test(timeout=60000) public void testBookieForceStartAsReadOnly() throws Exception {
  LedgerHandle ledger=bkc.createLedger(2,2,DigestType.MAC,"".getBytes());
  for (int i=0; i < 10; i++) {
    ledger.addEntry("data".getBytes());
  }
  ledger.close();
  LOG.info("successed prepare");
  bsConfs.get(1).setReadOnlyModeEnabled(true);
  bsConfs.get(1).setForceReadOnlyBookie(true);
  restartBookies();
  Bookie bookie=bs.get(1).getBookie();
  assertTrue("Bookie should be running and in readonly mode",bookie.isRunning() && bookie.isReadOnly());
  LOG.info("successed force start ReadOnlyBookie");
  File[] ledgerDirs=bsConfs.get(1).getLedgerDirs();
  assertEquals("Only one ledger dir should be present",1,ledgerDirs.length);
  killBookie(0);
  Enumeration<LedgerEntry> readEntries=ledger.readEntries(0,9);
  while (readEntries.hasMoreElements()) {
    LedgerEntry entry=readEntries.nextElement();
    assertEquals("Entry should contain correct data","data",new String(entry.getEntry()));
  }
  LOG.info("successed read entry from ReadOnlyBookie");
  LedgerDirsManager ledgerDirsManager=bookie.getLedgerDirsManager();
  ledgerDirsManager.addToWritableDirs(new File(ledgerDirs[0],"current"),true);
  assertTrue("Bookie should be running and in readonly mode",bookie.isRunning() && bookie.isReadOnly());
  LOG.info("successed: bookie still readonly");
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.bookkeeper.test.LedgerDeleteTest </h4><pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies boolean conditions
"></span><br>
/** 
 * This test writes enough ledger entries to roll over the entry log file.
 * It will then delete all of the ledgers from the client and let the
 * server's EntryLogger garbage collector thread delete the initial entry
 * log file.
 * @throws Exception
 */
@Test(timeout=60000) public void testLedgerDelete() throws Exception {
  LedgerHandle[] lhs=writeLedgerEntries(3,1024,1024);
  restartBookies();
  for (  LedgerHandle lh : lhs) {
    bkc.deleteLedger(lh.getId());
  }
  LOG.info("Finished deleting all ledgers so waiting for the GC thread to clean up the entryLogs");
  Thread.sleep(2000);
  for (  File ledgerDirectory : tmpDirs) {
    assertFalse("Found the entry log file (0.log) that should have been deleted in ledgerDirectory: " + ledgerDirectory,TestUtils.hasLogFiles(ledgerDirectory,true,0));
  }
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies boolean conditions
"></span><br>
/** 
 * This test is similar to testLedgerDelete() except it will stop and
 * restart the Bookie Servers after it has written out the ledger entries.
 * On restart, there will be existing entry logs and ledger index files for
 * the EntryLogger and LedgerCache to read and store into memory.
 * @throws Exception
 */
@Test(timeout=60000) public void testLedgerDeleteWithExistingEntryLogs() throws Exception {
  LedgerHandle[] lhs=writeLedgerEntries(3,1024,1024);
  restartBookies();
  for (  LedgerHandle lh : lhs) {
    bkc.deleteLedger(lh.getId());
  }
  LOG.info("Finished deleting all ledgers so waiting for the GC thread to clean up the entryLogs");
  Thread.sleep(2 * baseConf.getGcWaitTime());
  for (  File ledgerDirectory : tmpDirs) {
    assertFalse("Found the entry log file ([0,1].log) that should have been deleted in ledgerDirectory: " + ledgerDirectory,TestUtils.hasLogFiles(ledgerDirectory,true,0,1));
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.bookkeeper.test.ReadOnlyBookieTest </h4><pre class="type-2 type-11 type-8 type-3 type-4 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions in iterations
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Check readonly bookie
 */
@Test(timeout=60000) public void testBookieShouldServeAsReadOnly() throws Exception {
  killBookie(0);
  baseConf.setReadOnlyModeEnabled(true);
  startNewBookie();
  LedgerHandle ledger=bkc.createLedger(2,2,DigestType.MAC,"".getBytes());
  File[] ledgerDirs=bsConfs.get(1).getLedgerDirs();
  assertEquals("Only one ledger dir should be present",1,ledgerDirs.length);
  Bookie bookie=bs.get(1).getBookie();
  LedgerDirsManager ledgerDirsManager=bookie.getLedgerDirsManager();
  for (int i=0; i < 10; i++) {
    ledger.addEntry("data".getBytes());
  }
  ledgerDirsManager.addToFilledDirs(new File(ledgerDirs[0],"current"));
  try {
    ledger.addEntry("data".getBytes());
    fail("Should fail to add entry since there isn't enough bookies alive.");
  }
 catch (  BKException.BKNotEnoughBookiesException e) {
  }
  assertTrue("Bookie should be running and converted to readonly mode",bookie.isRunning() && bookie.isReadOnly());
  killBookie(0);
  Enumeration<LedgerEntry> readEntries=ledger.readEntries(0,9);
  while (readEntries.hasMoreElements()) {
    LedgerEntry entry=readEntries.nextElement();
    assertEquals("Entry should contain correct data","data",new String(entry.getEntry()));
  }
}

</code></pre>

<br>
<pre class="type-2 type-11 type-8 type-3 type-4 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions in iterations
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testBookieShouldTurnWritableFromReadOnly() throws Exception {
  killBookie(0);
  baseConf.setReadOnlyModeEnabled(true);
  startNewBookie();
  LedgerHandle ledger=bkc.createLedger(2,2,DigestType.MAC,"".getBytes());
  File[] ledgerDirs=bsConfs.get(1).getLedgerDirs();
  assertEquals("Only one ledger dir should be present",1,ledgerDirs.length);
  Bookie bookie=bs.get(1).getBookie();
  LedgerDirsManager ledgerDirsManager=bookie.getLedgerDirsManager();
  for (int i=0; i < 10; i++) {
    ledger.addEntry("data".getBytes());
  }
  File testDir=new File(ledgerDirs[0],"current");
  ledgerDirsManager.addToFilledDirs(testDir);
  try {
    ledger.addEntry("data".getBytes());
    fail("Should fail to add entry since there isn't enough bookies alive.");
  }
 catch (  BKException.BKNotEnoughBookiesException e) {
  }
  LOG.info("bookie is running {}, readonly {}.",bookie.isRunning(),bookie.isReadOnly());
  assertTrue("Bookie should be running and converted to readonly mode",bookie.isRunning() && bookie.isReadOnly());
  bkc.readBookiesBlocking();
  try {
    bkc.createLedger(2,2,DigestType.MAC,"".getBytes());
    fail("Should fail to create a ledger since there isn't enough bookies alive.");
  }
 catch (  BKException.BKNotEnoughBookiesException bke) {
  }
  ledgerDirsManager.addToWritableDirs(testDir,true);
  LOG.info("bookie is running {}, readonly {}.",bookie.isRunning(),bookie.isReadOnly());
  assertTrue("Bookie should be running and converted back to writable mode",bookie.isRunning() && !bookie.isReadOnly());
  bkc.readBookiesBlocking();
  LedgerHandle newLedger=bkc.createLedger(2,2,DigestType.MAC,"".getBytes());
  for (int i=0; i < 10; i++) {
    newLedger.addEntry("data".getBytes());
  }
  Enumeration<LedgerEntry> readEntries=newLedger.readEntries(0,9);
  while (readEntries.hasMoreElements()) {
    LedgerEntry entry=readEntries.nextElement();
    assertEquals("Entry should contain correct data","data",new String(entry.getEntry()));
  }
}

</code></pre>

<br>
<pre class="type-3 type-4 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Check multiple ledger dirs
 */
@Test(timeout=60000) public void testBookieContinueWritingIfMultipleLedgersPresent() throws Exception {
  startNewBookieWithMultipleLedgerDirs(2);
  File[] ledgerDirs=bsConfs.get(1).getLedgerDirs();
  assertEquals("Only one ledger dir should be present",2,ledgerDirs.length);
  Bookie bookie=bs.get(1).getBookie();
  LedgerHandle ledger=bkc.createLedger(2,2,DigestType.MAC,"".getBytes());
  LedgerDirsManager ledgerDirsManager=bookie.getLedgerDirsManager();
  for (int i=0; i < 10; i++) {
    ledger.addEntry("data".getBytes());
  }
  ledgerDirsManager.addToFilledDirs(new File(ledgerDirs[0],"current"));
  for (int i=0; i < 10; i++) {
    ledger.addEntry("data".getBytes());
  }
  assertEquals("writable dirs should have one dir",1,ledgerDirsManager.getWritableLedgerDirs().size());
  assertTrue("Bookie should shutdown if readOnlyMode not enabled",bookie.isAlive());
}

</code></pre>

<br>
<pre class="type-8 type-3 type-4 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * check readOnlyModeEnabled=false
 */
@Test(timeout=60000) public void testBookieShutdownIfReadOnlyModeNotEnabled() throws Exception {
  File[] ledgerDirs=bsConfs.get(1).getLedgerDirs();
  assertEquals("Only one ledger dir should be present",1,ledgerDirs.length);
  Bookie bookie=bs.get(1).getBookie();
  LedgerHandle ledger=bkc.createLedger(2,2,DigestType.MAC,"".getBytes());
  LedgerDirsManager ledgerDirsManager=bookie.getLedgerDirsManager();
  for (int i=0; i < 10; i++) {
    ledger.addEntry("data".getBytes());
  }
  ledgerDirsManager.addToFilledDirs(new File(ledgerDirs[0],"current"));
  try {
    ledger.addEntry("data".getBytes());
    fail("Should fail to add entry since there isn't enough bookies alive.");
  }
 catch (  BKException.BKNotEnoughBookiesException e) {
  }
  for (int i=0; i < 10 && bookie.isAlive(); i++) {
    Thread.sleep(1000);
  }
  assertFalse("Bookie should shutdown if readOnlyMode not enabled",bookie.isAlive());
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.bookkeeper.test.TestBackwardCompat </h4><pre class="type-8 type-3 type-4 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testOldCookieAccessingNewCluster() throws Exception {
  File journalDir=createTempDir("bookie","journal");
  File ledgerDir=createTempDir("bookie","ledger");
  int port=PortManager.nextFreePort();
  Server410 s410=new Server410(journalDir,ledgerDir,port);
  s410.start();
  Ledger410 l410=Ledger410.newLedger();
  l410.write100();
  l410.getId();
  l410.close();
  s410.stop();
  ServerCurrent currentServer=new ServerCurrent(journalDir,ledgerDir,port,false);
  BookKeeperAdmin.format(new ClientConfiguration(currentServer.conf),false,true);
  try {
    currentServer.start();
    fail("Bookie should not start with old cookie");
  }
 catch (  BookieException e) {
    assertTrue("Old Cookie should not be able to access",e.getMessage().contains("instanceId"));
  }
 finally {
    currentServer.stop();
  }
  assertTrue("Format should be success",Bookie.format(currentServer.conf,false,true));
  try {
    currentServer=null;
    currentServer=new ServerCurrent(journalDir,ledgerDir,port,false);
    currentServer.start();
  }
  finally {
    if (null != currentServer) {
      currentServer.stop();
    }
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.bookkeeper.util.TestDiskChecker </h4><pre class="type-4 type-15 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies that exceptions are thrown during the test case execution">ExceptionVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies boolean conditions
- Verifies that exceptions are thrown during the test case execution
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Check disk full on non exist file. in this case it should check for
 * parent file
 */
@Test(timeout=30000,expected=DiskOutOfSpaceException.class) public void testCheckDiskFullOnNonExistFile() throws IOException {
  File file=createTempDir("DiskCheck","test");
  long usableSpace=file.getUsableSpace();
  long totalSpace=file.getTotalSpace();
  float threshold=(1f - ((float)usableSpace / (float)totalSpace)) * 0.5f;
  diskChecker.setDiskSpaceThreshold(threshold,threshold);
  assertTrue(file.delete());
  diskChecker.checkDiskFull(file);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.bookkeeper.zookeeper.TestZooKeeperClient </h4><pre class="type-2 type-3 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
"></span><br>
@Test(timeout=60000) public void testRetryOnCreatingEphemeralZnode() throws Exception {
  final int timeout=2000;
  ZooKeeperClient client=ZooKeeperClient.createConnectedZooKeeperClient(zkUtil.getZooKeeperConnectString(),timeout,new HashSet<Watcher>(),new BoundExponentialBackoffRetryPolicy(timeout,timeout,Integer.MAX_VALUE));
  Assert.assertTrue("Client failed to connect an alive ZooKeeper.",client.getState().isConnected());
  String path="/a";
  byte[] data="test".getBytes();
  logger.info("Create znode " + path);
  client.create(path,data,Ids.OPEN_ACL_UNSAFE,CreateMode.EPHEMERAL);
  logger.info("Created znode " + path);
  expireZooKeeperSession(client,timeout);
  logger.info("Create znode w/ new session : " + path);
  client.create(path,data,Ids.OPEN_ACL_UNSAFE,CreateMode.EPHEMERAL);
  logger.info("Created znode w/ new session : " + path);
}

</code></pre>

<br>
<pre class="type-2 type-8 type-3 type-4 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=12000) public void testReconnectAfterExipred() throws Exception {
  final CountDownLatch expireLatch=new CountDownLatch(1);
  Watcher testWatcher=new Watcher(){
    @Override public void process(    WatchedEvent event){
      if (event.getType() == EventType.None && event.getState() == KeeperState.Expired) {
        expireLatch.countDown();
      }
    }
  }
;
  final int timeout=2000;
  ZooKeeperWatcherBase watcherManager=new ZooKeeperWatcherBase(timeout).addChildWatcher(testWatcher);
  List<Watcher> watchers=new ArrayList<Watcher>(1);
  watchers.add(testWatcher);
  ZooKeeperClient client=new ShutdownZkServerClient(zkUtil.getZooKeeperConnectString(),timeout,watcherManager,new BoundExponentialBackoffRetryPolicy(timeout,timeout,0));
  client.waitForConnection();
  Assert.assertTrue("Client failed to connect an alive ZooKeeper.",client.getState().isConnected());
  logger.info("Expire zookeeper client");
  expireZooKeeperSession(client,timeout);
  Assert.assertTrue("Client registered watcher should receive expire event.",expireLatch.await(2 * timeout,TimeUnit.MILLISECONDS));
  Assert.assertFalse("Client doesn't receive expire event from ZooKeeper.",client.getState().isConnected());
  try {
    client.exists("/tmp",false);
    Assert.fail("Should fail due to connection loss.");
  }
 catch (  KeeperException.ConnectionLossException cle) {
  }
catch (  KeeperException.SessionExpiredException cle) {
  }
  zkUtil.restartServer();
  Thread.sleep(2 * timeout);
  Assert.assertTrue("Client failed to connect zookeeper even it was back.",client.getState().isConnected());
  try {
    client.exists("/tmp",false);
  }
 catch (  KeeperException.ConnectionLossException cle) {
    Assert.fail("Should not throw ConnectionLossException");
  }
catch (  KeeperException.SessionExpiredException cle) {
    Assert.fail("Should not throw SessionExpiredException");
  }
}

</code></pre>

<br>
<pre class="type-2 type-3 type-4 type-7 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects are null
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testRetrySyncOperations() throws Exception {
  final int timeout=2000;
  ZooKeeperClient client=ZooKeeperClient.createConnectedZooKeeperClient(zkUtil.getZooKeeperConnectString(),timeout,new HashSet<Watcher>(),new BoundExponentialBackoffRetryPolicy(timeout,timeout,Integer.MAX_VALUE));
  Assert.assertTrue("Client failed to connect an alive ZooKeeper.",client.getState().isConnected());
  String path="/a";
  byte[] data="test".getBytes();
  expireZooKeeperSession(client,timeout);
  logger.info("Create znode " + path);
  client.create(path,data,Ids.OPEN_ACL_UNSAFE,CreateMode.PERSISTENT);
  logger.info("Created znode " + path);
  expireZooKeeperSession(client,timeout);
  logger.info("Exists znode " + path);
  Stat stat=client.exists(path,false);
  Assert.assertNotNull("znode doesn't existed",stat);
  expireZooKeeperSession(client,timeout);
  logger.info("Get data from znode " + path);
  Stat newStat=new Stat();
  client.getData(path,false,newStat);
  Assert.assertEquals(stat,newStat);
  expireZooKeeperSession(client,timeout);
  logger.info("Create children under znode " + path);
  client.create(path + "/children",data,Ids.OPEN_ACL_UNSAFE,CreateMode.PERSISTENT);
  expireZooKeeperSession(client,timeout);
  List<String> children=client.getChildren(path,false,newStat);
  Assert.assertEquals(1,children.size());
  Assert.assertEquals("children",children.get(0));
  logger.info("Get children under znode " + path);
  expireZooKeeperSession(client,timeout);
  client.delete(path + "/children",-1);
  logger.info("Delete children from znode " + path);
}

</code></pre>

<br>
<pre class="type-2 type-3 type-4 type-7 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects are null
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testRetryAsyncOperations() throws Exception {
  final int timeout=2000;
  ZooKeeperClient client=ZooKeeperClient.createConnectedZooKeeperClient(zkUtil.getZooKeeperConnectString(),timeout,new HashSet<Watcher>(),new BoundExponentialBackoffRetryPolicy(timeout,timeout,Integer.MAX_VALUE));
  Assert.assertTrue("Client failed to connect an alive ZooKeeper.",client.getState().isConnected());
  String path="/a";
  byte[] data="test".getBytes();
  expireZooKeeperSession(client,timeout);
  logger.info("Create znode " + path);
  final CountDownLatch createLatch=new CountDownLatch(1);
  client.create(path,data,Ids.OPEN_ACL_UNSAFE,CreateMode.PERSISTENT,new StringCallback(){
    @Override public void processResult(    int rc,    String path,    Object ctx,    String name){
      if (KeeperException.Code.OK.intValue() == rc) {
        createLatch.countDown();
      }
    }
  }
,null);
  createLatch.await();
  logger.info("Created znode " + path);
  expireZooKeeperSession(client,timeout);
  logger.info("Exists znode " + path);
  final CountDownLatch existsLatch=new CountDownLatch(1);
  client.exists(path,false,new StatCallback(){
    @Override public void processResult(    int rc,    String path,    Object ctx,    Stat stat){
      if (KeeperException.Code.OK.intValue() == rc) {
        existsLatch.countDown();
      }
    }
  }
,null);
  existsLatch.await();
  expireZooKeeperSession(client,timeout);
  final CountDownLatch getLatch=new CountDownLatch(1);
  logger.info("Get data from znode " + path);
  client.getData(path,false,new DataCallback(){
    @Override public void processResult(    int rc,    String path,    Object ctx,    byte[] data,    Stat stat){
      if (KeeperException.Code.OK.intValue() == rc) {
        getLatch.countDown();
      }
    }
  }
,null);
  getLatch.await();
  expireZooKeeperSession(client,timeout);
  logger.info("Create children under znode " + path);
  final CountDownLatch createChildLatch=new CountDownLatch(1);
  client.create(path + "/children",data,Ids.OPEN_ACL_UNSAFE,CreateMode.PERSISTENT,new StringCallback(){
    @Override public void processResult(    int rc,    String path,    Object ctx,    String name){
      if (KeeperException.Code.OK.intValue() == rc) {
        createChildLatch.countDown();
      }
    }
  }
,null);
  createChildLatch.await();
  expireZooKeeperSession(client,timeout);
  final CountDownLatch getChildLatch=new CountDownLatch(1);
  final AtomicReference<List<String>> children=new AtomicReference<List<String>>();
  client.getChildren(path,false,new Children2Callback(){
    @Override public void processResult(    int rc,    String path,    Object ctx,    List<String> childList,    Stat stat){
      if (KeeperException.Code.OK.intValue() == rc) {
        children.set(childList);
        getChildLatch.countDown();
      }
    }
  }
,null);
  getChildLatch.await();
  Assert.assertNotNull(children.get());
  Assert.assertEquals(1,children.get().size());
  Assert.assertEquals("children",children.get().get(0));
  logger.info("Get children under znode " + path);
  expireZooKeeperSession(client,timeout);
  final CountDownLatch deleteChildLatch=new CountDownLatch(1);
  client.delete(path + "/children",-1,new VoidCallback(){
    @Override public void processResult(    int rc,    String path,    Object ctx){
      if (KeeperException.Code.OK.intValue() == rc) {
        deleteChildLatch.countDown();
      }
    }
  }
,null);
  deleteChildLatch.await();
  logger.info("Delete children from znode " + path);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hedwig.client.TestPubSubClient </h4><pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies boolean conditions
"></span><br>
@Test(timeout=60000) public void testSyncUnsubscribeWithoutSubscription() throws Exception {
  boolean unsubscribeSuccess=false;
  try {
    subscriber.unsubscribe(ByteString.copyFromUtf8("mySyncUnsubTopic"),ByteString.copyFromUtf8("1"));
  }
 catch (  ClientNotSubscribedException e) {
    unsubscribeSuccess=true;
  }
catch (  Exception ex) {
    unsubscribeSuccess=false;
  }
  assertTrue(unsubscribeSuccess);
}

</code></pre>

<br>
<pre class="type-4 type-7 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies boolean conditions
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testCloseSubscribeDuringResubscribe() throws Exception {
  client.close();
  final long reconnectWaitTime=2000L;
  client=new HedwigClient(new ClientConfiguration(){
    @Override public HedwigSocketAddress getDefaultServerHedwigSocketAddress(){
      return getDefaultHedwigAddress();
    }
    @Override public boolean isSubscriptionChannelSharingEnabled(){
      return TestPubSubClient.this.isSubscriptionChannelSharingEnabled;
    }
    @Override public long getSubscribeReconnectRetryWaitTime(){
      return reconnectWaitTime;
    }
  }
);
  publisher=client.getPublisher();
  subscriber=client.getSubscriber();
  ByteString topic=ByteString.copyFromUtf8("testCloseSubscribeDuringResubscribe");
  ByteString subscriberId=ByteString.copyFromUtf8("mysub");
  subscriber.addSubscriptionListener(new TestSubscriptionListener());
  SubscriptionOptions options=SubscriptionOptions.newBuilder().setCreateOrAttach(CreateOrAttach.CREATE_OR_ATTACH).setForceAttach(false).setEnableResubscribe(true).build();
  subscriber.subscribe(topic,subscriberId,options);
  logger.info("Subscribed topic {}, subscriber {}.",topic.toStringUtf8(),subscriberId.toStringUtf8());
  subscriber.startDelivery(topic,subscriberId,new TestMessageHandler());
  tearDownHubServer();
  logger.info("Tear down the hub server");
  Thread.sleep(reconnectWaitTime / 2);
  subscriber.closeSubscription(topic,subscriberId);
  startHubServer(conf);
  publisher.asyncPublish(topic,Message.newBuilder().setBody(ByteString.copyFromUtf8("Message #1")).build(),new TestCallback(),null);
  assertTrue(queue.take());
  assertNull("Should not receive any messages since the subscription has already been closed.",consumeQueue.poll(reconnectWaitTime + reconnectWaitTime / 2,TimeUnit.MILLISECONDS));
}

</code></pre>

<br>
<pre class="type-4 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testAsyncSubscribeWithListener() throws Exception {
  ByteString topic=ByteString.copyFromUtf8("myAsyncSubscribeWithListener");
  ByteString subscriberId=ByteString.copyFromUtf8("mysub");
  subscriber.addSubscriptionListener(new TestSubscriptionListener());
  SubscriptionOptions options=SubscriptionOptions.newBuilder().setCreateOrAttach(CreateOrAttach.CREATE_OR_ATTACH).setEnableResubscribe(false).build();
  subscriber.asyncSubscribe(topic,subscriberId,options,new TestCallback(),null);
  assertTrue(queue.take());
  subscriber.startDelivery(topic,subscriberId,new TestMessageHandler());
  tearDownHubServer();
  assertEquals(SubscriptionEvent.TOPIC_MOVED,eventQueue.take());
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies boolean conditions
"></span><br>
@Test(timeout=60000) public void testAsyncSubscribeAndCloseSubscription() throws Exception {
  ByteString topic=ByteString.copyFromUtf8("myAsyncSubAndCloseSubTopic");
  ByteString subscriberId=ByteString.copyFromUtf8("1");
  SubscriptionOptions opts=SubscriptionOptions.newBuilder().setCreateOrAttach(CreateOrAttach.CREATE_OR_ATTACH).build();
  subscriber.asyncSubscribe(topic,subscriberId,opts,new TestCallback(),null);
  assertTrue(queue.take());
  subscriber.closeSubscription(topic,subscriberId);
  assertTrue(true);
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies boolean conditions
"></span><br>
@Test(timeout=60000) public void testAsyncSubscribe() throws Exception {
  SubscriptionOptions opts=SubscriptionOptions.newBuilder().setCreateOrAttach(CreateOrAttach.CREATE_OR_ATTACH).build();
  subscriber.asyncSubscribe(ByteString.copyFromUtf8("myAsyncSubscribeTopic"),ByteString.copyFromUtf8("1"),opts,new TestCallback(),null);
  assertTrue(queue.take());
}

</code></pre>

<br>
<pre class="type-2 type-11 type-4 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions in iterations
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testAsyncPublishWithResponse() throws Exception {
  ByteString topic=ByteString.copyFromUtf8("testAsyncPublishWithResponse");
  ByteString subid=ByteString.copyFromUtf8("mysubid");
  final String prefix="AsyncMessage-";
  final int numMessages=30;
  final AtomicInteger numPublished=new AtomicInteger(0);
  final CountDownLatch publishLatch=new CountDownLatch(1);
  final Map<String,MessageSeqId> publishedMsgs=new HashMap<String,MessageSeqId>();
  final AtomicInteger numReceived=new AtomicInteger(0);
  final CountDownLatch receiveLatch=new CountDownLatch(1);
  final Map<String,MessageSeqId> receivedMsgs=new HashMap<String,MessageSeqId>();
  SubscriptionOptions opts=SubscriptionOptions.newBuilder().setCreateOrAttach(CreateOrAttach.CREATE_OR_ATTACH).build();
  subscriber.subscribe(topic,subid,opts);
  subscriber.startDelivery(topic,subid,new MessageHandler(){
    synchronized public void deliver(    ByteString topic,    ByteString subscriberId,    Message msg,    Callback<Void> callback,    Object context){
      String str=msg.getBody().toStringUtf8();
      receivedMsgs.put(str,msg.getMsgId());
      if (numMessages == numReceived.incrementAndGet()) {
        receiveLatch.countDown();
      }
      callback.operationFinished(context,null);
    }
  }
);
  for (int i=0; i < numMessages; i++) {
    final String str=prefix + i;
    ByteString data=ByteString.copyFromUtf8(str);
    Message msg=Message.newBuilder().setBody(data).build();
    publisher.asyncPublishWithResponse(topic,msg,new Callback<PublishResponse>(){
      @Override public void operationFinished(      Object ctx,      PublishResponse response){
        publishedMsgs.put(str,response.getPublishedMsgId());
        if (numMessages == numPublished.incrementAndGet()) {
          publishLatch.countDown();
        }
      }
      @Override public void operationFailed(      Object ctx,      final PubSubException exception){
        publishLatch.countDown();
      }
    }
,null);
  }
  assertTrue("Timed out waiting on callback for publish requests.",publishLatch.await(10,TimeUnit.SECONDS));
  assertEquals("Should be expected " + numMessages + " publishes.",numMessages,numPublished.get());
  assertEquals("Should be expected " + numMessages + " publishe responses.",numMessages,publishedMsgs.size());
  assertTrue("Timed out waiting on callback for messages.",receiveLatch.await(30,TimeUnit.SECONDS));
  assertEquals("Should be expected " + numMessages + " messages.",numMessages,numReceived.get());
  assertEquals("Should be expected " + numMessages + " messages in map.",numMessages,receivedMsgs.size());
  for (int i=0; i < numMessages; i++) {
    final String str=prefix + i;
    MessageSeqId pubId=publishedMsgs.get(str);
    MessageSeqId revId=receivedMsgs.get(str);
    assertTrue("Doesn't receive same message seq id for " + str,pubId.equals(revId));
  }
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies boolean conditions
"></span><br>
@Test(timeout=60000) public void testStartDeliveryAfterCloseSub() throws Exception {
  ByteString topic=ByteString.copyFromUtf8("testStartDeliveryAfterCloseSub");
  ByteString subid=ByteString.copyFromUtf8("mysubid");
  SubscriptionOptions opts=SubscriptionOptions.newBuilder().setCreateOrAttach(CreateOrAttach.CREATE_OR_ATTACH).build();
  subscriber.subscribe(topic,subid,opts);
  subscriber.startDelivery(topic,subid,new TestMessageHandler());
  publisher.publish(topic,Message.newBuilder().setBody(ByteString.copyFromUtf8("Message #1")).build());
  assertTrue(consumeQueue.take());
  subscriber.closeSubscription(topic,subid);
  subscriber.subscribe(topic,subid,opts);
  subscriber.startDelivery(topic,subid,new TestMessageHandler());
  publisher.publish(topic,Message.newBuilder().setBody(ByteString.copyFromUtf8("Message #2")).build());
  assertTrue(consumeQueue.take());
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies boolean conditions
"></span><br>
@Test(timeout=60000) public void testAsyncPublish() throws Exception {
  publisher.asyncPublish(ByteString.copyFromUtf8("myAsyncTopic"),Message.newBuilder().setBody(ByteString.copyFromUtf8("Hello Async World!")).build(),new TestCallback(),null);
  assertTrue(queue.take());
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies boolean conditions
"></span><br>
@Test(timeout=60000) public void testSubscribeAndConsume() throws Exception {
  ByteString topic=ByteString.copyFromUtf8("myConsumeTopic");
  ByteString subscriberId=ByteString.copyFromUtf8("1");
  SubscriptionOptions opts=SubscriptionOptions.newBuilder().setCreateOrAttach(CreateOrAttach.CREATE_OR_ATTACH).build();
  subscriber.asyncSubscribe(topic,subscriberId,opts,new TestCallback(),null);
  assertTrue(queue.take());
  subscriber.startDelivery(topic,subscriberId,new TestMessageHandler());
  publisher.asyncPublish(topic,Message.newBuilder().setBody(ByteString.copyFromUtf8("Message #1")).build(),new TestCallback(),null);
  assertTrue(queue.take());
  assertTrue(consumeQueue.take());
  publisher.asyncPublish(topic,Message.newBuilder().setBody(ByteString.copyFromUtf8("Message #2")).build(),new TestCallback(),null);
  assertTrue(queue.take());
  assertTrue(consumeQueue.take());
  publisher.asyncPublish(topic,Message.newBuilder().setBody(ByteString.copyFromUtf8("Message #3")).build(),new TestCallback(),null);
  assertTrue(queue.take());
  assertTrue(consumeQueue.take());
  publisher.asyncPublish(topic,Message.newBuilder().setBody(ByteString.copyFromUtf8("Message #4")).build(),new TestCallback(),null);
  assertTrue(queue.take());
  assertTrue(consumeQueue.take());
  publisher.asyncPublish(topic,Message.newBuilder().setBody(ByteString.copyFromUtf8("Message #5")).build(),new TestCallback(),null);
  assertTrue(queue.take());
  assertTrue(consumeQueue.take());
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies boolean conditions
"></span><br>
@Test(timeout=60000) public void testAsyncSubscribeAndUnsubscribe() throws Exception {
  ByteString topic=ByteString.copyFromUtf8("myAsyncUnsubTopic");
  ByteString subscriberId=ByteString.copyFromUtf8("1");
  SubscriptionOptions opts=SubscriptionOptions.newBuilder().setCreateOrAttach(CreateOrAttach.CREATE_OR_ATTACH).build();
  subscriber.asyncSubscribe(topic,subscriberId,opts,new TestCallback(),null);
  assertTrue(queue.take());
  subscriber.asyncUnsubscribe(topic,subscriberId,new TestCallback(),null);
  assertTrue(queue.take());
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies boolean conditions
"></span><br>
@Test(timeout=60000) public void testSyncPublish() throws Exception {
  boolean publishSuccess=true;
  try {
    publisher.publish(ByteString.copyFromUtf8("mySyncTopic"),Message.newBuilder().setBody(ByteString.copyFromUtf8("Hello Sync World!")).build());
  }
 catch (  Exception e) {
    publishSuccess=false;
  }
  assertTrue(publishSuccess);
}

</code></pre>

<br>
<pre class="type-8 type-4 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testSyncSubscribeWithListenerWhenReleasingTopic() throws Exception {
  client.close();
  tearDownHubServer();
  startHubServer(new RetentionServerConfiguration());
  client=new HedwigClient(new ClientConfiguration(){
    @Override public HedwigSocketAddress getDefaultServerHedwigSocketAddress(){
      return getDefaultHedwigAddress();
    }
    @Override public boolean isSubscriptionChannelSharingEnabled(){
      return TestPubSubClient.this.isSubscriptionChannelSharingEnabled;
    }
  }
);
  publisher=client.getPublisher();
  subscriber=client.getSubscriber();
  ByteString topic=ByteString.copyFromUtf8("mySyncSubscribeWithListenerWhenReleasingTopic");
  ByteString subscriberId=ByteString.copyFromUtf8("mysub");
  subscriber.addSubscriptionListener(new TestSubscriptionListener());
  SubscriptionOptions options=SubscriptionOptions.newBuilder().setCreateOrAttach(CreateOrAttach.CREATE_OR_ATTACH).setForceAttach(false).setEnableResubscribe(false).build();
  try {
    subscriber.subscribe(topic,subscriberId,options);
  }
 catch (  PubSubException.ServiceDownException e) {
    fail("Should not reach here!");
  }
  subscriber.startDelivery(topic,subscriberId,new TestMessageHandler());
  publisher.asyncPublish(topic,Message.newBuilder().setBody(ByteString.copyFromUtf8("Message #1")).build(),new TestCallback(),null);
  assertTrue(queue.take());
  assertTrue(consumeQueue.take());
  Thread.sleep(RETENTION_SECS_VALUE * 2);
  assertEquals(SubscriptionEvent.TOPIC_MOVED,eventQueue.take());
}

</code></pre>

<br>
<pre class="type-8 type-4 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testSyncSubscribeForceAttach() throws Exception {
  ByteString topic=ByteString.copyFromUtf8("mySyncSubscribeForceAttach");
  ByteString subscriberId=ByteString.copyFromUtf8("mysub");
  subscriber.addSubscriptionListener(new TestSubscriptionListener());
  SubscriptionOptions options=SubscriptionOptions.newBuilder().setCreateOrAttach(CreateOrAttach.CREATE_OR_ATTACH).setForceAttach(true).setEnableResubscribe(false).build();
  try {
    subscriber.subscribe(topic,subscriberId,options);
  }
 catch (  PubSubException.ServiceDownException e) {
    fail("Should not reach here!");
  }
  subscriber.startDelivery(topic,subscriberId,new TestMessageHandler());
  HedwigClient client2=new HedwigClient(new ClientConfiguration(){
    @Override public HedwigSocketAddress getDefaultServerHedwigSocketAddress(){
      return getDefaultHedwigAddress();
    }
  }
);
  Subscriber subscriber2=client2.getSubscriber();
  Publisher publisher2=client2.getPublisher();
  SynchronousQueue<SubscriptionEvent> eventQueue2=new SynchronousQueue<SubscriptionEvent>();
  subscriber2.addSubscriptionListener(new TestSubscriptionListener(eventQueue2));
  try {
    subscriber2.subscribe(topic,subscriberId,options);
  }
 catch (  PubSubException.ServiceDownException e) {
    fail("Should not reach here!");
  }
  SynchronousQueue<Boolean> consumeQueue2=new SynchronousQueue<Boolean>();
  subscriber2.startDelivery(topic,subscriberId,new TestMessageHandler(consumeQueue2));
  assertEquals(SubscriptionEvent.SUBSCRIPTION_FORCED_CLOSED,eventQueue.take());
  assertTrue(eventQueue2.isEmpty());
  publisher.asyncPublish(topic,Message.newBuilder().setBody(ByteString.copyFromUtf8("Message #1")).build(),new TestCallback(),null);
  assertTrue(queue.take());
  assertTrue(consumeQueue2.take());
  assertTrue(consumeQueue.isEmpty());
  publisher2.asyncPublish(topic,Message.newBuilder().setBody(ByteString.copyFromUtf8("Message #2")).build(),new TestCallback(),null);
  assertTrue(queue.take());
  assertTrue(consumeQueue2.take());
  assertTrue(consumeQueue.isEmpty());
  client2.close();
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies boolean conditions
"></span><br>
@Test(timeout=60000) public void testSyncSubscribe() throws Exception {
  boolean subscribeSuccess=true;
  try {
    SubscriptionOptions opts=SubscriptionOptions.newBuilder().setCreateOrAttach(CreateOrAttach.CREATE_OR_ATTACH).build();
    subscriber.subscribe(ByteString.copyFromUtf8("mySyncSubscribeTopic"),ByteString.copyFromUtf8("1"),opts);
  }
 catch (  Exception e) {
    subscribeSuccess=false;
  }
  assertTrue(subscribeSuccess);
}

</code></pre>

<br>
<pre class="type-11 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies boolean conditions
"></span><br>
@Test(timeout=60000) public void testSubClosesubAndPublish() throws Exception {
  ByteString topic=ByteString.copyFromUtf8("mySubClosesubAndPublish");
  ByteString subid=ByteString.copyFromUtf8("mysub");
  SubscriptionOptions opts=SubscriptionOptions.newBuilder().setCreateOrAttach(CreateOrAttach.CREATE_OR_ATTACH).build();
  for (int i=0; i < 5; i++) {
    subscriber.subscribe(topic,subid,opts);
    subscriber.closeSubscription(topic,subid);
  }
  subscriber.subscribe(topic,subid,opts);
  subscriber.startDelivery(topic,subid,new TestMessageHandler());
  for (int i=0; i < 3; i++) {
    publisher.asyncPublish(topic,Message.newBuilder().setBody(ByteString.copyFromUtf8("Message #" + i)).build(),new TestCallback(),null);
    assertTrue(queue.take());
    assertTrue(consumeQueue.take());
  }
}

</code></pre>

<br>
<pre class="type-2 type-11 type-3 type-4 type-7 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions in iterations
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects are null
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testSyncPublishWithResponse() throws Exception {
  ByteString topic=ByteString.copyFromUtf8("testSyncPublishWithResponse");
  ByteString subid=ByteString.copyFromUtf8("mysubid");
  final String prefix="SyncMessage-";
  final int numMessages=30;
  final Map<String,MessageSeqId> publishedMsgs=new HashMap<String,MessageSeqId>();
  final AtomicInteger numReceived=new AtomicInteger(0);
  final CountDownLatch receiveLatch=new CountDownLatch(1);
  final Map<String,MessageSeqId> receivedMsgs=new HashMap<String,MessageSeqId>();
  SubscriptionOptions opts=SubscriptionOptions.newBuilder().setCreateOrAttach(CreateOrAttach.CREATE_OR_ATTACH).build();
  subscriber.subscribe(topic,subid,opts);
  subscriber.startDelivery(topic,subid,new MessageHandler(){
    synchronized public void deliver(    ByteString topic,    ByteString subscriberId,    Message msg,    Callback<Void> callback,    Object context){
      String str=msg.getBody().toStringUtf8();
      receivedMsgs.put(str,msg.getMsgId());
      if (numMessages == numReceived.incrementAndGet()) {
        receiveLatch.countDown();
      }
      callback.operationFinished(context,null);
    }
  }
);
  for (int i=0; i < numMessages; i++) {
    String str=prefix + i;
    ByteString data=ByteString.copyFromUtf8(str);
    Message msg=Message.newBuilder().setBody(data).build();
    PublishResponse response=publisher.publish(topic,msg);
    assertNotNull(response);
    publishedMsgs.put(str,response.getPublishedMsgId());
  }
  assertTrue("Timed out waiting on callback for messages.",receiveLatch.await(30,TimeUnit.SECONDS));
  assertEquals("Should be expected " + numMessages + " messages.",numMessages,numReceived.get());
  assertEquals("Should be expected " + numMessages + " messages in map.",numMessages,receivedMsgs.size());
  for (int i=0; i < numMessages; i++) {
    final String str=prefix + i;
    MessageSeqId pubId=publishedMsgs.get(str);
    MessageSeqId revId=receivedMsgs.get(str);
    assertTrue("Doesn't receive same message seq id for " + str,pubId.equals(revId));
  }
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies boolean conditions
"></span><br>
@Test(timeout=60000) public void testMultipleAsyncPublish() throws Exception {
  ByteString topic1=ByteString.copyFromUtf8("myFirstTopic");
  ByteString topic2=ByteString.copyFromUtf8("myNewTopic");
  publisher.asyncPublish(topic1,Message.newBuilder().setBody(ByteString.copyFromUtf8("Hello World!")).build(),new TestCallback(),null);
  assertTrue(queue.take());
  publisher.asyncPublish(topic2,Message.newBuilder().setBody(ByteString.copyFromUtf8("Hello on new topic!")).build(),new TestCallback(),null);
  assertTrue(queue.take());
  publisher.asyncPublish(topic1,Message.newBuilder().setBody(ByteString.copyFromUtf8("Hello Again on old topic!")).build(),new TestCallback(),null);
  assertTrue(queue.take());
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hedwig.server.delivery.TestFIFODeliveryManager </h4><pre class="type-3 type-4 type-7 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test that the FIFO delivery manager executes stopServing and startServing
 * in the correct order{@link https://issues.apache.org/jira/browse/BOOKKEEPER-539}
 */
@Test(timeout=60000) public void testFIFODeliverySubCloseSubRace() throws Exception {
  ServerConfiguration conf=new ServerConfiguration();
  ByteString topic=ByteString.copyFromUtf8("subRaceTopic");
  ByteString subscriber=ByteString.copyFromUtf8("subRaceSubscriber");
  PersistenceManager pm=new StubPersistenceManager();
  FIFODeliveryManager fdm=new FIFODeliveryManager(new StubTopicManager(conf),pm,conf);
  ExecutorDeliveryEndPointWithQueue dep=new ExecutorDeliveryEndPointWithQueue();
  SubscriptionPreferences prefs=SubscriptionPreferences.newBuilder().build();
  PipelineFilter filter=new PipelineFilter();
  filter.addLast(new AllToAllTopologyFilter());
  filter.initialize(conf.getConf());
  filter.setSubscriptionPreferences(topic,subscriber,prefs);
  MessageSeqId startId=MessageSeqId.newBuilder().setLocalComponent(1).build();
  CountDownLatch l=new CountDownLatch(1);
  Message m=Message.newBuilder().setBody(ByteString.copyFromUtf8(String.valueOf(1))).build();
  TestCallback cb=new TestCallback(l);
  pm.persistMessage(new PersistRequest(topic,m,cb,null));
  assertTrue("Persistence never finished",l.await(10,TimeUnit.SECONDS));
  final CountDownLatch oplatch=new CountDownLatch(3);
  fdm.start();
  fdm.startServingSubscription(topic,subscriber,prefs,startId,dep,filter,new Callback<Void>(){
    @Override public void operationFinished(    Object ctx,    Void result){
      oplatch.countDown();
    }
    @Override public void operationFailed(    Object ctx,    PubSubException exception){
      oplatch.countDown();
    }
  }
,null);
  fdm.stopServingSubscriber(topic,subscriber,null,new Callback<Void>(){
    @Override public void operationFinished(    Object ctx,    Void result){
      oplatch.countDown();
    }
    @Override public void operationFailed(    Object ctx,    PubSubException exception){
      oplatch.countDown();
    }
  }
,null);
  fdm.startServingSubscription(topic,subscriber,prefs,startId,dep,filter,new Callback<Void>(){
    @Override public void operationFinished(    Object ctx,    Void result){
      oplatch.countDown();
    }
    @Override public void operationFailed(    Object ctx,    PubSubException exception){
      oplatch.countDown();
    }
  }
,null);
  assertTrue("Ops never finished",oplatch.await(10,TimeUnit.SECONDS));
  int seconds=5;
  while (dep.getNumResponses() < 2) {
    if (seconds-- == 0) {
      break;
    }
    Thread.sleep(1000);
  }
  PubSubResponse r=dep.getNextResponse();
  assertNotNull("There should be a response",r);
  assertTrue("Response should contain a message",r.hasMessage());
  r=dep.getNextResponse();
  assertNotNull("There should be a response",r);
  assertTrue("Response should contain a message",r.hasMessage());
  r=dep.getNextResponse();
  assertNull("There should only be 2 responses",r);
}

</code></pre>

<br>
<pre class="type-3 type-4 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test throttle race issue cause by messageConsumed and doDeliverNextMessage{@link https://issues.apache.org/jira/browse/BOOKKEEPER-503}
 */
@Test(timeout=60000) public void testFIFODeliveryThrottlingRace() throws Exception {
  final int numMessages=20;
  final int throttleSize=10;
  ServerConfiguration conf=new ServerConfiguration(){
    @Override public int getDefaultMessageWindowSize(){
      return throttleSize;
    }
  }
;
  ByteString topic=ByteString.copyFromUtf8("throttlingRaceTopic");
  ByteString subscriber=ByteString.copyFromUtf8("throttlingRaceSubscriber");
  PersistenceManager pm=new StubPersistenceManager();
  FIFODeliveryManager fdm=new FIFODeliveryManager(new StubTopicManager(conf),pm,conf);
  ExecutorDeliveryEndPoint dep=new ExecutorDeliveryEndPoint(fdm);
  SubscriptionPreferences prefs=SubscriptionPreferences.newBuilder().build();
  PipelineFilter filter=new PipelineFilter();
  filter.addLast(new AllToAllTopologyFilter());
  filter.initialize(conf.getConf());
  filter.setSubscriptionPreferences(topic,subscriber,prefs);
  CountDownLatch l=new CountDownLatch(numMessages);
  TestCallback firstCallback=null;
  for (int i=0; i < numMessages; i++) {
    Message m=Message.newBuilder().setBody(ByteString.copyFromUtf8(String.valueOf(i))).build();
    TestCallback cb=new TestCallback(l);
    if (firstCallback == null) {
      firstCallback=cb;
    }
    pm.persistMessage(new PersistRequest(topic,m,cb,null));
  }
  fdm.start();
  assertTrue("Persistence never finished",l.await(10,TimeUnit.SECONDS));
  fdm.startServingSubscription(topic,subscriber,prefs,firstCallback.getId(),dep,filter,new Callback<Void>(){
    @Override public void operationFinished(    Object ctx,    Void result){
    }
    @Override public void operationFailed(    Object ctx,    PubSubException exception){
    }
  }
,null);
  int count=30;
  while (dep.getNumDelivered() < numMessages) {
    Thread.sleep(1000);
    if (count-- == 0) {
      break;
    }
  }
  assertEquals("Should have delivered " + numMessages,numMessages,dep.getNumDelivered());
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hedwig.server.filter.TestMessageFilter </h4><pre class="type-8 type-4 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testInvalidServerSideMessageFilter() throws Exception {
  ByteString topic=ByteString.copyFromUtf8("TestInvalidMessageFilter");
  ByteString subid=ByteString.copyFromUtf8("mysub");
  SubscriptionOptions options=SubscriptionOptions.newBuilder().setCreateOrAttach(CreateOrAttach.CREATE_OR_ATTACH).setMessageFilter("Invalid_Message_Filter").build();
  try {
    subscriber.subscribe(topic,subid,options);
    fail("Should fail subscribe with invalid message filter");
  }
 catch (  PubSubException pse) {
    assertTrue("Should respond with INVALID_MESSAGE_FILTER",pse.getMessage().contains("INVALID_MESSAGE_FILTER"));
  }
}

</code></pre>

<br>
<pre class="type-8 type-4 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testFixInvalidServerSideMessageFilter() throws Exception {
  ByteString topic=ByteString.copyFromUtf8("TestFixMessageFilter");
  ByteString subid=ByteString.copyFromUtf8("mysub");
  SubscriptionOptions opts=SubscriptionOptions.newBuilder().setCreateOrAttach(CreateOrAttach.CREATE_OR_ATTACH).build();
  subscriber.subscribe(topic,subid,opts);
  subscriber.closeSubscription(topic,subid);
  publishNums(topic,0,100,3);
  try {
    receiveNumModM(topic,subid,"Invalid_Message_Filter",null,0,33,3,true);
    fail("Should fail subscribe with invalid message filter");
  }
 catch (  Exception pse) {
    assertTrue("Should respond with INVALID_MESSAGE_FILTER",pse.getMessage().contains("INVALID_MESSAGE_FILTER"));
  }
  receiveNumModM(topic,subid,HeaderMessageFilter.class.getName(),null,0,33,3,true);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hedwig.server.integration.TestHedwigHub </h4><pre class="type-11 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies boolean conditions
"></span><br>
@Test(timeout=10000) public void testManualConsumeClient() throws Exception {
  HedwigClient myClient=new HedwigClient(new TestClientConfiguration(){
    @Override public boolean isAutoSendConsumeMessageEnabled(){
      return false;
    }
  }
);
  Subscriber mySubscriber=myClient.getSubscriber();
  Publisher myPublisher=myClient.getPublisher();
  ByteString myTopic=getTopic(0);
  SubscriptionOptions opts=SubscriptionOptions.newBuilder().setCreateOrAttach(CreateOrAttach.CREATE_OR_ATTACH).build();
  mySubscriber.asyncSubscribe(myTopic,localSubscriberId,opts,new TestCallback(queue),null);
  assertTrue(queue.take());
  startDelivery(mySubscriber,myTopic,localSubscriberId,new TestMessageHandler(consumeQueue));
  int batchSize=10;
  for (int i=0; i < batchSize; i++) {
    myPublisher.asyncPublish(myTopic,getMsg(i),new TestCallback(queue),null);
    assertTrue(queue.take());
    assertTrue(consumeQueue.take());
  }
  for (int i=0; i < batchSize; i++) {
    boolean success=true;
    try {
      mySubscriber.consume(myTopic,localSubscriberId,MessageSeqId.newBuilder().setLocalComponent(i + 1).build());
    }
 catch (    ClientNotSubscribedException e) {
      success=false;
    }
    assertTrue(success);
  }
  try {
    Thread.sleep(1000);
  }
 catch (  InterruptedException e) {
    logger.error("Thread was interrupted while waiting to stop client for manual consume test!!",e);
  }
  myClient.close();
}

</code></pre>

<br>
<pre class="type-11 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies boolean conditions
"></span><br>
@Test(timeout=10000) public void testConsumedMessagesInOrder() throws Exception {
  ByteString topic=getTopic(0);
  SubscriptionOptions opts=SubscriptionOptions.newBuilder().setCreateOrAttach(CreateOrAttach.CREATE_OR_ATTACH).build();
  subscriber.asyncSubscribe(topic,localSubscriberId,opts,new TestCallback(queue),null);
  assertTrue(queue.take());
  startDelivery(topic,localSubscriberId,new TestMessageHandler(consumeQueue));
  int batchSize=100;
  for (int i=0; i < batchSize; i++) {
    publisher.asyncPublish(topic,getMsg(i),new TestCallback(queue),null);
  }
  for (int i=0; i < batchSize; i++) {
    assertTrue(queue.take());
    assertTrue(consumeQueue.take());
  }
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies boolean conditions
"></span><br>
@Test(timeout=10000) public void testAsyncSubscribeWithInvalidSubscriberId() throws Exception {
  SubscriptionOptions opts=SubscriptionOptions.newBuilder().setCreateOrAttach(CreateOrAttach.CREATE_OR_ATTACH).build();
  subscriber.asyncSubscribe(getTopic(0),hubSubscriberId,opts,new TestCallback(queue),null);
  assertFalse(queue.take());
}

</code></pre>

<br>
<pre class="type-11 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies boolean conditions
"></span><br>
@Test(timeout=10000) public void testCreateSubscriptionSuccess() throws Exception {
  ByteString topic=getTopic(0);
  SubscriptionOptions opts=SubscriptionOptions.newBuilder().setCreateOrAttach(CreateOrAttach.CREATE).build();
  subscriber.asyncSubscribe(topic,localSubscriberId,opts,new TestCallback(queue),null);
  assertTrue(queue.take());
  startDelivery(topic,localSubscriberId,new TestMessageHandler(consumeQueue));
  int batchSize=5;
  for (int i=0; i < batchSize; i++) {
    publisher.asyncPublish(topic,getMsg(i),new TestCallback(queue),null);
    assertTrue(queue.take());
    assertTrue(consumeQueue.take());
  }
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies boolean conditions
"></span><br>
@Test(timeout=10000) public void testAsyncHubUnsubscribeWithInvalidSubscriberId() throws Exception {
  Client hubClient=new HedwigHubClient(new HubClientConfiguration());
  Subscriber hubSubscriber=hubClient.getSubscriber();
  hubSubscriber.asyncUnsubscribe(getTopic(0),localSubscriberId,new TestCallback(queue),null);
  assertFalse(queue.take());
  hubClient.close();
}

</code></pre>

<br>
<pre class="type-11 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies boolean conditions
"></span><br>
@Test(timeout=10000) public void testAttachToSubscriptionSuccess() throws Exception {
  ByteString topic=getTopic(0);
  SubscriptionOptions opts1=SubscriptionOptions.newBuilder().setCreateOrAttach(CreateOrAttach.CREATE_OR_ATTACH).build();
  subscriber.asyncSubscribe(topic,localSubscriberId,opts1,new TestCallback(queue),null);
  assertTrue(queue.take());
  subscriber.asyncCloseSubscription(topic,localSubscriberId,new TestCallback(queue),null);
  assertTrue(queue.take());
  SubscriptionOptions opts2=SubscriptionOptions.newBuilder().setCreateOrAttach(CreateOrAttach.ATTACH).build();
  subscriber.asyncSubscribe(topic,localSubscriberId,opts2,new TestCallback(queue),null);
  assertTrue(queue.take());
  startDelivery(topic,localSubscriberId,new TestMessageHandler(consumeQueue));
  int batchSize=5;
  for (int i=0; i < batchSize; i++) {
    publisher.asyncPublish(topic,getMsg(i),new TestCallback(queue),null);
    assertTrue(queue.take());
    assertTrue(consumeQueue.take());
  }
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies boolean conditions
"></span><br>
@Test(timeout=10000) public void testSyncSubscribeWithInvalidSubscriberId() throws Exception {
  boolean subscribeSuccess=false;
  try {
    SubscriptionOptions opts=SubscriptionOptions.newBuilder().setCreateOrAttach(CreateOrAttach.CREATE_OR_ATTACH).build();
    subscriber.subscribe(getTopic(0),hubSubscriberId,opts);
  }
 catch (  InvalidSubscriberIdException e) {
    subscribeSuccess=true;
  }
catch (  Exception ex) {
    subscribeSuccess=false;
  }
  assertTrue(subscribeSuccess);
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies boolean conditions
"></span><br>
@Test(timeout=10000) public void testAttachToSubscriptionFailure() throws Exception {
  ByteString topic=getTopic(0);
  SubscriptionOptions opts=SubscriptionOptions.newBuilder().setCreateOrAttach(CreateOrAttach.ATTACH).build();
  subscriber.asyncSubscribe(topic,localSubscriberId,opts,new TestCallback(queue),null);
  assertFalse(queue.take());
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies boolean conditions
"></span><br>
@Test(timeout=10000) public void testSyncHubUnsubscribeWithInvalidSubscriberId() throws Exception {
  Client hubClient=new HedwigHubClient(new HubClientConfiguration());
  Subscriber hubSubscriber=hubClient.getSubscriber();
  boolean unsubscribeSuccess=false;
  try {
    hubSubscriber.unsubscribe(getTopic(0),localSubscriberId);
  }
 catch (  InvalidSubscriberIdException e) {
    unsubscribeSuccess=true;
  }
catch (  Exception ex) {
    unsubscribeSuccess=false;
  }
  assertTrue(unsubscribeSuccess);
  hubClient.close();
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies boolean conditions
"></span><br>
@Test(timeout=10000) public void testCreateSubscriptionFailure() throws Exception {
  ByteString topic=getTopic(0);
  SubscriptionOptions opts=SubscriptionOptions.newBuilder().setCreateOrAttach(CreateOrAttach.CREATE_OR_ATTACH).build();
  subscriber.asyncSubscribe(topic,localSubscriberId,opts,new TestCallback(queue),null);
  assertTrue(queue.take());
  subscriber.asyncCloseSubscription(topic,localSubscriberId,new TestCallback(queue),null);
  assertTrue(queue.take());
  SubscriptionOptions optsCreate=SubscriptionOptions.newBuilder().setCreateOrAttach(CreateOrAttach.CREATE).build();
  subscriber.asyncSubscribe(topic,localSubscriberId,optsCreate,new TestCallback(queue),null);
  assertFalse(queue.take());
}

</code></pre>

<br>
<pre class="type-11 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies boolean conditions
"></span><br>
@Test(timeout=10000) public void testStopDelivery() throws Exception {
  ByteString topic=getTopic(0);
  SubscriptionOptions opts=SubscriptionOptions.newBuilder().setCreateOrAttach(CreateOrAttach.CREATE_OR_ATTACH).build();
  subscriber.asyncSubscribe(topic,localSubscriberId,opts,new TestCallback(queue),null);
  assertTrue(queue.take());
  startDelivery(topic,localSubscriberId,new TestMessageHandler(consumeQueue));
  publisher.asyncPublish(topic,getMsg(0),new TestCallback(queue),null);
  assertTrue(queue.take());
  assertTrue(consumeQueue.take());
  stopDelivery(topic,localSubscriberId);
  int batchSize=10;
  for (int i=0; i < batchSize; i++) {
    publisher.asyncPublish(topic,getMsg(i + 1),new TestCallback(queue),null);
    assertTrue(queue.take());
  }
  Thread.sleep(1000);
  new Thread(new Runnable(){
    @Override public void run(){
      ConcurrencyUtils.put(consumeQueue,false);
    }
  }
).start();
  assertFalse(consumeQueue.take());
  startDelivery(topic,localSubscriberId,new TestMessageHandler(consumeQueue));
  for (int i=0; i < batchSize; i++) {
    assertTrue(consumeQueue.take());
  }
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies boolean conditions
"></span><br>
@Test(timeout=10000) public void testAsyncHubSubscribeWithInvalidSubscriberId() throws Exception {
  Client hubClient=new HedwigHubClient(new HubClientConfiguration());
  Subscriber hubSubscriber=hubClient.getSubscriber();
  SubscriptionOptions opts=SubscriptionOptions.newBuilder().setCreateOrAttach(CreateOrAttach.CREATE_OR_ATTACH).build();
  hubSubscriber.asyncSubscribe(getTopic(0),localSubscriberId,opts,new TestCallback(queue),null);
  assertFalse(queue.take());
  hubClient.close();
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies boolean conditions
"></span><br>
@Test(timeout=10000) public void testSyncHubSubscribeWithInvalidSubscriberId() throws Exception {
  Client hubClient=new HedwigHubClient(new HubClientConfiguration());
  Subscriber hubSubscriber=hubClient.getSubscriber();
  boolean subscribeSuccess=false;
  try {
    SubscriptionOptions opts=SubscriptionOptions.newBuilder().setCreateOrAttach(CreateOrAttach.CREATE_OR_ATTACH).build();
    hubSubscriber.subscribe(getTopic(0),localSubscriberId,opts);
  }
 catch (  InvalidSubscriberIdException e) {
    subscribeSuccess=true;
  }
catch (  Exception ex) {
    subscribeSuccess=false;
  }
  assertTrue(subscribeSuccess);
  hubClient.close();
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies boolean conditions
"></span><br>
@Test(timeout=10000) public void testUnsubscribe() throws Exception {
  ByteString topic=getTopic(0);
  SubscriptionOptions opts=SubscriptionOptions.newBuilder().setCreateOrAttach(CreateOrAttach.CREATE_OR_ATTACH).build();
  subscriber.asyncSubscribe(topic,localSubscriberId,opts,new TestCallback(queue),null);
  assertTrue(queue.take());
  startDelivery(topic,localSubscriberId,new TestMessageHandler(consumeQueue));
  publisher.asyncPublish(topic,getMsg(0),new TestCallback(queue),null);
  assertTrue(queue.take());
  assertTrue(consumeQueue.take());
  subscriber.asyncUnsubscribe(topic,localSubscriberId,new TestCallback(queue),null);
  assertTrue(queue.take());
  publisher.asyncPublish(topic,getMsg(1),new TestCallback(queue),null);
  assertTrue(queue.take());
  Thread.sleep(1000);
  new Thread(new Runnable(){
    @Override public void run(){
      ConcurrencyUtils.put(consumeQueue,false);
    }
  }
).start();
  assertFalse(consumeQueue.take());
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies boolean conditions
"></span><br>
@Test(timeout=10000) public void testAsyncUnsubscribeWithoutSubscription() throws Exception {
  subscriber.asyncUnsubscribe(getTopic(0),localSubscriberId,new TestCallback(queue),null);
  assertFalse(queue.take());
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies boolean conditions
"></span><br>
@Test(timeout=10000) public void testSyncUnsubscribeWithInvalidSubscriberId() throws Exception {
  boolean unsubscribeSuccess=false;
  try {
    subscriber.unsubscribe(getTopic(0),hubSubscriberId);
  }
 catch (  InvalidSubscriberIdException e) {
    unsubscribeSuccess=true;
  }
catch (  Exception ex) {
    unsubscribeSuccess=false;
  }
  assertTrue(unsubscribeSuccess);
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies boolean conditions
"></span><br>
@Test(timeout=10000) public void testAsyncUnsubscribeWithInvalidSubscriberId() throws Exception {
  subscriber.asyncUnsubscribe(getTopic(0),hubSubscriberId,new TestCallback(queue),null);
  assertFalse(queue.take());
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies boolean conditions
"></span><br>
@Test(timeout=10000) public void testSyncUnsubscribeWithoutSubscription() throws Exception {
  boolean unsubscribeSuccess=false;
  try {
    subscriber.unsubscribe(getTopic(0),localSubscriberId);
  }
 catch (  ClientNotSubscribedException e) {
    unsubscribeSuccess=true;
  }
catch (  Exception ex) {
    unsubscribeSuccess=false;
  }
  assertTrue(unsubscribeSuccess);
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies boolean conditions
"></span><br>
@Test(timeout=10000) public void testCloseSubscription() throws Exception {
  ByteString topic=getTopic(0);
  SubscriptionOptions opts=SubscriptionOptions.newBuilder().setCreateOrAttach(CreateOrAttach.CREATE_OR_ATTACH).build();
  subscriber.asyncSubscribe(topic,localSubscriberId,opts,new TestCallback(queue),null);
  assertTrue(queue.take());
  startDelivery(topic,localSubscriberId,new TestMessageHandler(consumeQueue));
  publisher.asyncPublish(topic,getMsg(0),new TestCallback(queue),null);
  assertTrue(queue.take());
  assertTrue(consumeQueue.take());
  subscriber.asyncCloseSubscription(topic,localSubscriberId,new TestCallback(queue),null);
  assertTrue(queue.take());
  publisher.asyncPublish(topic,getMsg(1),new TestCallback(queue),null);
  assertTrue(queue.take());
  Thread.sleep(1000);
  new Thread(new Runnable(){
    @Override public void run(){
      ConcurrencyUtils.put(consumeQueue,false);
    }
  }
).start();
  assertFalse(consumeQueue.take());
}

</code></pre>

<br>
<pre class="type-8 type-4 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=10000) public void testStartDeliveryTwice() throws Exception {
  ByteString topic=getTopic(0);
  SubscriptionOptions opts=SubscriptionOptions.newBuilder().setCreateOrAttach(CreateOrAttach.CREATE_OR_ATTACH).build();
  subscriber.asyncSubscribe(topic,localSubscriberId,opts,new TestCallback(queue),null);
  assertTrue(queue.take());
  startDelivery(topic,localSubscriberId,new TestMessageHandler(consumeQueue));
  try {
    startDelivery(topic,localSubscriberId,new TestMessageHandler(consumeQueue));
    fail("Should not reach here!");
  }
 catch (  AlreadyStartDeliveryException e) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hedwig.server.integration.TestHedwigRegion </h4><pre class="type-11 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies boolean conditions
"></span><br>
/** 
 * Test region shuts down when attaching existing subscriptions.
 * @throws Exception
 */
@Test(timeout=60000) public void testAttachExistingSubscriptionsWhenARegionDown() throws Exception {
  int batchSize=10;
  SubscriptionOptions opts=SubscriptionOptions.newBuilder().setCreateOrAttach(CreateOrAttach.CREATE_OR_ATTACH).build();
  for (  Map.Entry<String,HedwigClient> entry : regionClientsMap.entrySet()) {
    HedwigClient client=entry.getValue();
    for (int i=0; i < batchSize; i++) {
      client.getSubscriber().asyncSubscribe(ByteString.copyFromUtf8("Topic" + i),ByteString.copyFromUtf8("LocalSubscriber"),opts,new TestCallback(queue),null);
      assertTrue(queue.take());
    }
  }
  for (int i=0; i < numRegions; i++) {
    stopRegion(i);
  }
  for (int i=0; i < numRegions; i++) {
    startRegion(i);
  }
  Random r=new Random();
  int regionId=r.nextInt(numRegions);
  stopRegion(regionId);
  for (  HedwigClient client : regionClientsMap.values()) {
    for (int i=0; i < batchSize; i++) {
      client.getSubscriber().asyncSubscribe(ByteString.copyFromUtf8("Topic" + i),ByteString.copyFromUtf8("LocalSubscriber"),opts,new TestCallback(queue),null);
      assertTrue(queue.take());
    }
  }
  for (  Map.Entry<String,HedwigClient> entry : regionClientsMap.entrySet()) {
    HedwigClient client=entry.getValue();
    for (int i=0; i < batchSize; i++) {
      client.getSubscriber().startDelivery(ByteString.copyFromUtf8("Topic" + i),ByteString.copyFromUtf8("LocalSubscriber"),new TestMessageHandler(consumeQueue));
    }
  }
  startRegion(regionId);
  Thread.sleep(3 * TEST_RETRY_REMOTE_SUBSCRIBE_INTERVAL_VALUE);
  String regionName=REGION_PREFIX + regionId;
  HedwigClient client=regionClientsMap.get(regionName);
  for (int i=0; i < batchSize; i++) {
    client.getSubscriber().asyncSubscribe(ByteString.copyFromUtf8("Topic" + i),ByteString.copyFromUtf8("LocalSubscriber"),opts,new TestCallback(queue),null);
    assertTrue(queue.take());
    client.getSubscriber().startDelivery(ByteString.copyFromUtf8("Topic" + i),ByteString.copyFromUtf8("LocalSubscriber"),new TestMessageHandler(consumeQueue));
  }
  Publisher publisher=client.getPublisher();
  for (int i=0; i < batchSize; i++) {
    publisher.asyncPublish(ByteString.copyFromUtf8("Topic" + i),Message.newBuilder().setBody(ByteString.copyFromUtf8(regionName + "-Message" + i)).build(),new TestCallback(queue),null);
    assertTrue(queue.take());
  }
  for (int i=0; i < regionClientsMap.size(); i++) {
    for (int j=0; j < batchSize; j++) {
      assertTrue(consumeQueue.take());
    }
  }
}

</code></pre>

<br>
<pre class="type-11 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies boolean conditions
"></span><br>
/** 
 * Test region shuts down when first subscription.
 * @throws Exception
 */
@Test(timeout=60000) public void testSubscribeAndConsumeWhenARegionDown() throws Exception {
  int batchSize=10;
  SubscriptionOptions opts=SubscriptionOptions.newBuilder().setCreateOrAttach(CreateOrAttach.CREATE_OR_ATTACH).build();
  Random r=new Random();
  int regionId=r.nextInt(numRegions);
  stopRegion(regionId);
  for (  HedwigClient client : regionClientsMap.values()) {
    for (int i=0; i < batchSize; i++) {
      client.getSubscriber().asyncSubscribe(ByteString.copyFromUtf8("Topic" + i),ByteString.copyFromUtf8("LocalSubscriber"),opts,new TestCallback(queue),null);
      assertFalse(queue.take());
    }
  }
  startRegion(regionId);
  for (  Map.Entry<String,HedwigClient> entry : regionClientsMap.entrySet()) {
    HedwigClient client=entry.getValue();
    for (int i=0; i < batchSize; i++) {
      client.getSubscriber().asyncSubscribe(ByteString.copyFromUtf8("Topic" + i),ByteString.copyFromUtf8("LocalSubscriber"),opts,new TestCallback(queue),null);
      assertTrue(queue.take());
    }
  }
  for (  Map.Entry<String,HedwigClient> entry : regionClientsMap.entrySet()) {
    HedwigClient client=entry.getValue();
    for (int i=0; i < batchSize; i++) {
      client.getSubscriber().startDelivery(ByteString.copyFromUtf8("Topic" + i),ByteString.copyFromUtf8("LocalSubscriber"),new TestMessageHandler(consumeQueue));
    }
  }
  int rid=r.nextInt(numRegions);
  String regionName=REGION_PREFIX + rid;
  Publisher publisher=regionClientsMap.get(regionName).getPublisher();
  for (int i=0; i < batchSize; i++) {
    publisher.asyncPublish(ByteString.copyFromUtf8("Topic" + i),Message.newBuilder().setBody(ByteString.copyFromUtf8(regionName + "-Message" + i)).build(),new TestCallback(queue),null);
    assertTrue(queue.take());
  }
  for (int i=0; i < regionClientsMap.size(); i++) {
    for (int j=0; j < batchSize; j++) {
      assertTrue(consumeQueue.take());
    }
  }
}

</code></pre>

<br>
<pre class="type-11 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies boolean conditions
"></span><br>
@Test(timeout=60000) public void testMultiRegionSubscribeAndConsume() throws Exception {
  int batchSize=10;
  for (  HedwigClient client : regionClientsMap.values()) {
    for (int i=0; i < batchSize; i++) {
      SubscriptionOptions opts=SubscriptionOptions.newBuilder().setCreateOrAttach(CreateOrAttach.CREATE_OR_ATTACH).build();
      client.getSubscriber().asyncSubscribe(ByteString.copyFromUtf8("Topic" + i),ByteString.copyFromUtf8("LocalSubscriber"),opts,new TestCallback(queue),null);
      assertTrue(queue.take());
    }
  }
  for (  HedwigClient client : regionClientsMap.values()) {
    for (int i=0; i < batchSize; i++) {
      client.getSubscriber().startDelivery(ByteString.copyFromUtf8("Topic" + i),ByteString.copyFromUtf8("LocalSubscriber"),new TestMessageHandler(consumeQueue));
    }
  }
  Publisher publisher=regionClientsMap.values().iterator().next().getPublisher();
  for (int i=0; i < batchSize; i++) {
    publisher.asyncPublish(ByteString.copyFromUtf8("Topic" + i),Message.newBuilder().setBody(ByteString.copyFromUtf8("Message" + i)).build(),new TestCallback(queue),null);
    assertTrue(queue.take());
  }
  for (int i=0; i < regionClientsMap.size(); i++) {
    for (int j=0; j < batchSize; j++) {
      assertTrue(consumeQueue.take());
    }
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hedwig.server.meta.TestFactoryLayout </h4><pre class="type-2 type-3 type-4 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testFactoryLayout() throws Exception {
  ServerConfiguration conf=new ServerConfiguration();
  conf.setMetadataManagerFactoryName("org.apache.hedwig.server.meta.ZkMetadataManager");
  FactoryLayout layout=FactoryLayout.readLayout(zk,conf);
  Assert.assertTrue("Layout should be null",layout == null);
  String testName="foobar";
  int testVersion=0xdeadbeef;
  writeFactoryLayout(conf,testName,testVersion);
  layout=FactoryLayout.readLayout(zk,conf);
  Assert.assertEquals(testName,layout.getManagerMeta().getManagerImpl());
  Assert.assertEquals(testVersion,layout.getManagerMeta().getManagerVersion());
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hedwig.server.meta.TestMetadataManager </h4><pre class="type-3 type-4 type-7 type-9 type-13 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values related to public fields.">PublicFieldVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects are null
- Verifies whether objects/variable are equal to an expected value 
- Verifies values related to public fields.
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testPersistenceInfo() throws Exception {
  TopicPersistenceManager tpManager=metadataManagerFactory.newTopicPersistenceManager();
  ByteString topic=ByteString.copyFromUtf8("testPersistenceInfo");
  StubCallback<Versioned<LedgerRanges>> readCallback=new StubCallback<Versioned<LedgerRanges>>();
  StubCallback<Version> writeCallback=new StubCallback<Version>();
  StubCallback<Void> deleteCallback=new StubCallback<Void>();
  tpManager.writeTopicPersistenceInfo(topic,LedgerRanges.getDefaultInstance(),Version.NEW,writeCallback,null);
  Either<Version,PubSubException> res=writeCallback.queue.take();
  Assert.assertEquals(null,res.right());
  Version v1=res.left();
  tpManager.readTopicPersistenceInfo(topic,readCallback,null);
  Versioned<LedgerRanges> ranges=readCallback.queue.take().left();
  Assert.assertEquals(Version.Occurred.CONCURRENTLY,v1.compare(ranges.getVersion()));
  Assert.assertEquals(LedgerRanges.getDefaultInstance(),ranges.getValue());
  LedgerRange lastRange=LedgerRange.newBuilder().setLedgerId(1).build();
  LedgerRanges.Builder builder=LedgerRanges.newBuilder();
  builder.addRanges(lastRange);
  LedgerRanges newRanges=builder.build();
  tpManager.writeTopicPersistenceInfo(topic,newRanges,Version.NEW,writeCallback,null);
  res=writeCallback.queue.take();
  Assert.assertNotNull(res.right());
  Assert.assertTrue(res.right() instanceof PubSubException.TopicPersistenceInfoExistsException);
  tpManager.writeTopicPersistenceInfo(topic,newRanges,v1,writeCallback,null);
  res=writeCallback.queue.take();
  Assert.assertEquals(null,res.right());
  Version v2=res.left();
  Assert.assertEquals(Version.Occurred.AFTER,v2.compare(v1));
  tpManager.readTopicPersistenceInfo(topic,readCallback,null);
  ranges=readCallback.queue.take().left();
  Assert.assertEquals(Version.Occurred.CONCURRENTLY,v2.compare(ranges.getVersion()));
  Assert.assertEquals(newRanges,ranges.getValue());
  lastRange=LedgerRange.newBuilder().setLedgerId(2).build();
  builder=LedgerRanges.newBuilder();
  builder.addRanges(lastRange);
  LedgerRanges newRanges2=builder.build();
  tpManager.writeTopicPersistenceInfo(topic,newRanges2,v1,writeCallback,null);
  res=writeCallback.queue.take();
  Assert.assertNotNull(res.right());
  Assert.assertTrue(res.right() instanceof PubSubException.BadVersionException);
  tpManager.readTopicPersistenceInfo(topic,readCallback,null);
  ranges=readCallback.queue.take().left();
  Assert.assertEquals(Version.Occurred.CONCURRENTLY,v2.compare(ranges.getVersion()));
  Assert.assertEquals(newRanges,ranges.getValue());
  tpManager.deleteTopicPersistenceInfo(topic,v1,deleteCallback,null);
  Assert.assertTrue(deleteCallback.queue.take().right() instanceof PubSubException.BadVersionException);
  tpManager.readTopicPersistenceInfo(topic,readCallback,null);
  ranges=readCallback.queue.take().left();
  Assert.assertEquals(Version.Occurred.CONCURRENTLY,v2.compare(ranges.getVersion()));
  Assert.assertEquals(newRanges,ranges.getValue());
  tpManager.deleteTopicPersistenceInfo(topic,v2,deleteCallback,null);
  Assert.assertEquals(null,deleteCallback.queue.take().right());
  tpManager.readTopicPersistenceInfo(topic,readCallback,null);
  Assert.assertEquals(null,readCallback.queue.take().left());
  tpManager.deleteTopicPersistenceInfo(topic,Version.ANY,deleteCallback,null);
  Assert.assertTrue(deleteCallback.queue.take().right() instanceof PubSubException.NoTopicPersistenceInfoException);
  tpManager.close();
}

</code></pre>

<br>
<pre class="type-2 type-3 type-4 type-9 type-13 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values related to public fields.">PublicFieldVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Verifies values related to public fields.
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testSubscriptionData() throws Exception {
  SubscriptionDataManager subManager=metadataManagerFactory.newSubscriptionDataManager();
  ByteString topic=ByteString.copyFromUtf8("testSubscriptionData");
  ByteString subid=ByteString.copyFromUtf8("mysub");
  final StubCallback<Version> callback=new StubCallback<Version>();
  StubCallback<Versioned<SubscriptionData>> readCallback=new StubCallback<Versioned<SubscriptionData>>();
  StubCallback<Map<ByteString,Versioned<SubscriptionData>>> subsCallback=new StubCallback<Map<ByteString,Versioned<SubscriptionData>>>();
  subManager.readSubscriptionData(topic,subid,readCallback,null);
  Either<Versioned<SubscriptionData>,PubSubException> readRes=readCallback.queue.take();
  Assert.assertEquals("Found inconsistent subscription state",null,readRes.left());
  Assert.assertEquals("Should not fail with PubSubException",null,readRes.right());
  subManager.readSubscriptions(topic,subsCallback,null);
  Either<Map<ByteString,Versioned<SubscriptionData>>,PubSubException> res=subsCallback.queue.take();
  Assert.assertEquals("Found more than 0 subscribers",0,res.left().size());
  Assert.assertEquals("Should not fail with PubSubException",null,res.right());
  if (subManager.isPartialUpdateSupported()) {
    subManager.updateSubscriptionData(topic,subid,SubscriptionData.getDefaultInstance(),Version.ANY,callback,null);
  }
 else {
    subManager.replaceSubscriptionData(topic,subid,SubscriptionData.getDefaultInstance(),Version.ANY,callback,null);
  }
  Assert.assertTrue("Should fail to update a non-existed subscriber with PubSubException",callback.queue.take().right() instanceof PubSubException.NoSubscriptionStateException);
  Callback<Void> voidCallback=new Callback<Void>(){
    @Override public void operationFinished(    Object ctx,    Void resultOfOperation){
      callback.operationFinished(ctx,null);
    }
    @Override public void operationFailed(    Object ctx,    PubSubException exception){
      callback.operationFailed(ctx,exception);
    }
  }
;
  subManager.deleteSubscriptionData(topic,subid,Version.ANY,voidCallback,null);
  Assert.assertTrue("Should fail to delete a non-existed subscriber with PubSubException",callback.queue.take().right() instanceof PubSubException.NoSubscriptionStateException);
  long seqId=10;
  MessageSeqId.Builder builder=MessageSeqId.newBuilder();
  builder.setLocalComponent(seqId);
  MessageSeqId msgId=builder.build();
  SubscriptionState.Builder stateBuilder=SubscriptionState.newBuilder(SubscriptionState.getDefaultInstance()).setMsgId(msgId);
  SubscriptionData data=SubscriptionData.newBuilder().setState(stateBuilder).build();
  subManager.createSubscriptionData(topic,subid,data,callback,null);
  Either<Version,PubSubException> cbResult=callback.queue.take();
  Version v1=cbResult.left();
  Assert.assertEquals("Should not fail with PubSubException",null,cbResult.right());
  subManager.readSubscriptions(topic,subsCallback,null);
  res=subsCallback.queue.take();
  Assert.assertEquals("Should find just 1 subscriber",1,res.left().size());
  Assert.assertEquals("Should not fail with PubSubException",null,res.right());
  Versioned<SubscriptionData> versionedSubData=res.left().get(subid);
  Assert.assertEquals(Version.Occurred.CONCURRENTLY,v1.compare(versionedSubData.getVersion()));
  SubscriptionData imss=versionedSubData.getValue();
  Assert.assertEquals("Found inconsistent subscription state",data,imss);
  Assert.assertEquals("Found inconsistent last consumed seq id",seqId,imss.getState().getMsgId().getLocalComponent());
  seqId=99;
  builder=MessageSeqId.newBuilder();
  builder.setLocalComponent(seqId);
  msgId=builder.build();
  stateBuilder=SubscriptionState.newBuilder(data.getState()).setMsgId(msgId);
  data=SubscriptionData.newBuilder().setState(stateBuilder).build();
  if (subManager.isPartialUpdateSupported()) {
    subManager.updateSubscriptionData(topic,subid,data,versionedSubData.getVersion(),callback,null);
  }
 else {
    subManager.replaceSubscriptionData(topic,subid,data,versionedSubData.getVersion(),callback,null);
  }
  cbResult=callback.queue.take();
  Assert.assertEquals("Fail to update a subscription state",null,cbResult.right());
  Version v2=cbResult.left();
  subManager.readSubscriptionData(topic,subid,readCallback,null);
  Assert.assertEquals("Found inconsistent subscription state",data,readCallback.queue.take().left().getValue());
  subManager.readSubscriptions(topic,subsCallback,null);
  res=subsCallback.queue.take();
  Assert.assertEquals("Should find just 1 subscriber",1,res.left().size());
  Assert.assertEquals("Should not fail with PubSubException",null,res.right());
  versionedSubData=res.left().get(subid);
  Assert.assertEquals(Version.Occurred.CONCURRENTLY,v2.compare(versionedSubData.getVersion()));
  imss=res.left().get(subid).getValue();
  Assert.assertEquals("Found inconsistent subscription state",data,imss);
  Assert.assertEquals("Found inconsistent last consumed seq id",seqId,imss.getState().getMsgId().getLocalComponent());
  if (subManager.isPartialUpdateSupported()) {
    subManager.updateSubscriptionData(topic,subid,data,v1,callback,null);
  }
 else {
    subManager.replaceSubscriptionData(topic,subid,data,v1,callback,null);
  }
  Assert.assertTrue(callback.queue.take().right() instanceof PubSubException.BadVersionException);
  subManager.deleteSubscriptionData(topic,subid,v1,voidCallback,null);
  Assert.assertTrue(callback.queue.take().right() instanceof PubSubException.BadVersionException);
  subManager.deleteSubscriptionData(topic,subid,res.left().get(subid).getVersion(),voidCallback,null);
  Assert.assertEquals("Fail to delete an existed subscriber",null,callback.queue.take().right());
  subManager.readSubscriptions(topic,subsCallback,null);
  res=subsCallback.queue.take();
  Assert.assertEquals("Found more than 0 subscribers",0,res.left().size());
  Assert.assertEquals("Should not fail with PubSubException",null,res.right());
  subManager.close();
}

</code></pre>

<br>
<pre class="type-3 type-4 type-7 type-9 type-13 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values related to public fields.">PublicFieldVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects are null
- Verifies whether objects/variable are equal to an expected value 
- Verifies values related to public fields.
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testOwnerInfo() throws Exception {
  TopicOwnershipManager toManager=metadataManagerFactory.newTopicOwnershipManager();
  ByteString topic=ByteString.copyFromUtf8("testOwnerInfo");
  StubCallback<Versioned<HubInfo>> readCallback=new StubCallback<Versioned<HubInfo>>();
  StubCallback<Version> writeCallback=new StubCallback<Version>();
  StubCallback<Void> deleteCallback=new StubCallback<Void>();
  Either<Version,PubSubException> res;
  HubInfo owner=new HubInfo(new HedwigSocketAddress("127.0.0.1",8008),999);
  toManager.writeOwnerInfo(topic,owner,Version.NEW,writeCallback,null);
  res=writeCallback.queue.take();
  Assert.assertEquals(null,res.right());
  Version v1=res.left();
  toManager.readOwnerInfo(topic,readCallback,null);
  Versioned<HubInfo> hubInfo=readCallback.queue.take().left();
  Assert.assertEquals(Version.Occurred.CONCURRENTLY,v1.compare(hubInfo.getVersion()));
  Assert.assertEquals(owner,hubInfo.getValue());
  HubInfo newOwner=new HubInfo(new HedwigSocketAddress("127.0.0.1",8008),1000);
  toManager.writeOwnerInfo(topic,newOwner,Version.NEW,writeCallback,null);
  res=writeCallback.queue.take();
  Assert.assertNotNull(res.right());
  Assert.assertTrue(res.right() instanceof PubSubException.TopicOwnerInfoExistsException);
  toManager.writeOwnerInfo(topic,newOwner,v1,writeCallback,null);
  res=writeCallback.queue.take();
  Assert.assertEquals(null,res.right());
  Version v2=res.left();
  Assert.assertEquals(Version.Occurred.AFTER,v2.compare(v1));
  toManager.readOwnerInfo(topic,readCallback,null);
  hubInfo=readCallback.queue.take().left();
  Assert.assertEquals(Version.Occurred.CONCURRENTLY,v2.compare(hubInfo.getVersion()));
  Assert.assertEquals(newOwner,hubInfo.getValue());
  HubInfo newOwner2=new HubInfo(new HedwigSocketAddress("127.0.0.1",8008),1001);
  toManager.writeOwnerInfo(topic,newOwner2,v1,writeCallback,null);
  res=writeCallback.queue.take();
  Assert.assertNotNull(res.right());
  Assert.assertTrue(res.right() instanceof PubSubException.BadVersionException);
  toManager.readOwnerInfo(topic,readCallback,null);
  hubInfo=readCallback.queue.take().left();
  Assert.assertEquals(Version.Occurred.CONCURRENTLY,v2.compare(hubInfo.getVersion()));
  Assert.assertEquals(newOwner,hubInfo.getValue());
  toManager.deleteOwnerInfo(topic,v1,deleteCallback,null);
  Assert.assertTrue(deleteCallback.queue.take().right() instanceof PubSubException.BadVersionException);
  toManager.readOwnerInfo(topic,readCallback,null);
  hubInfo=readCallback.queue.take().left();
  Assert.assertEquals(Version.Occurred.CONCURRENTLY,v2.compare(hubInfo.getVersion()));
  toManager.deleteOwnerInfo(topic,v2,deleteCallback,null);
  Assert.assertEquals(null,deleteCallback.queue.take().right());
  toManager.readOwnerInfo(topic,readCallback,null);
  Assert.assertEquals(null,readCallback.queue.take().left());
  toManager.deleteOwnerInfo(topic,Version.ANY,deleteCallback,null);
  Assert.assertTrue(deleteCallback.queue.take().right() instanceof PubSubException.NoTopicOwnerInfoException);
  toManager.close();
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hedwig.server.meta.TestMetadataManagerFactory </h4><pre class="type-2 type-8 type-3 type-4 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test bad server configuration
 */
@Test(timeout=60000) public void testBadConf() throws Exception {
  TestServerConfiguration conf=new TestServerConfiguration();
  String root0="/goodconf";
  conf.setZkPrefix(root0);
  MetadataManagerFactory m=MetadataManagerFactory.newMetadataManagerFactory(conf,zk);
  Assert.assertTrue("MetadataManagerFactory is unexpected type",(m instanceof ZkMetadataManagerFactory));
  conf.setMetadataManagerFactoryName(DummyMetadataManagerFactory.class.getName());
  try {
    MetadataManagerFactory.newMetadataManagerFactory(conf,zk);
    Assert.fail("Shouldn't reach here");
  }
 catch (  Exception e) {
    Assert.assertTrue("Invalid exception",e.getMessage().contains("does not match existing factory"));
  }
  String root1="/badconf1";
  conf.setZkPrefix(root1);
  conf.setMetadataManagerFactoryName("DoesNotExist");
  try {
    MetadataManagerFactory.newMetadataManagerFactory(conf,zk);
    Assert.fail("Shouldn't reach here");
  }
 catch (  Exception e) {
    Assert.assertTrue("Invalid exception",e.getMessage().contains("Failed to get metadata manager factory class from configuration"));
  }
}

</code></pre>

<br>
<pre class="type-3 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
"></span><br>
@Test(timeout=60000) public void testConcurrent1() throws Exception {
  int numThreads=50;
  String root0="/lmroot0";
  CyclicBarrier barrier=new CyclicBarrier(numThreads + 1);
  List<CreateMMThread> threads=new ArrayList<CreateMMThread>(numThreads);
  for (int i=0; i < numThreads; i++) {
    CreateMMThread t=new CreateMMThread(root0,ZkMetadataManagerFactory.class.getName(),barrier);
    t.start();
    threads.add(t);
  }
  barrier.await();
  boolean success=true;
  for (  CreateMMThread t : threads) {
    t.join();
    t.close();
    success=t.isSuccessful() && success;
  }
  Assert.assertTrue("Not all metadata manager factories created",success);
}

</code></pre>

<br>
<pre class="type-8 type-4 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test bad zk configuration
 */
@Test(timeout=60000) public void testBadZkContents() throws Exception {
  TestServerConfiguration conf=new TestServerConfiguration();
  String root0="/badzk0";
  conf.setZkPrefix(root0);
  writeFactoryLayout(conf,"DoesNotExist",0xdeadbeef);
  try {
    MetadataManagerFactory.newMetadataManagerFactory(conf,zk);
    Assert.fail("Shouldn't reach here");
  }
 catch (  Exception e) {
    Assert.assertTrue("Invalid exception",e.getMessage().contains("No class found to instantiate metadata manager factory"));
  }
  String root1="/badzk1";
  conf.setZkPrefix(root1);
  writeFactoryLayout(conf,ZkMetadataManagerFactory.class.getName(),0xdeadbeef);
  try {
    MetadataManagerFactory.newMetadataManagerFactory(conf,zk);
    Assert.fail("Shouldn't reach here");
  }
 catch (  Exception e) {
    Assert.assertTrue("Invalid exception",e.getMessage().contains("Incompatible ZkMetadataManagerFactory version"));
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hedwig.server.netty.TestPubSubServer </h4><pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies boolean conditions
"></span><br>
@Test(timeout=60000) public void testValidServerConfiguration() throws Exception {
  boolean success=true;
  ServerConfiguration conf=new ServerConfiguration(){
    @Override public boolean isInterRegionSSLEnabled(){
      return conf.getBoolean(INTER_REGION_SSL_ENABLED,true);
    }
    @Override public List<String> getRegions(){
      List<String> regionsList=new LinkedList<String>();
      regionsList.add("regionHost1:4080:9876");
      regionsList.add("regionHost2:4080:2938");
      regionsList.add("regionHost3:4080:9876");
      return regionsList;
    }
  }
;
  try {
    conf.validate();
  }
 catch (  ConfigurationException e) {
    logger.error("Invalid configuration: ",e);
    success=false;
  }
  assertTrue(success);
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies boolean conditions
"></span><br>
@Test(timeout=60000) public void testInvalidServerConfiguration() throws Exception {
  boolean success=false;
  ServerConfiguration conf=new ServerConfiguration(){
    @Override public boolean isInterRegionSSLEnabled(){
      return conf.getBoolean(INTER_REGION_SSL_ENABLED,true);
    }
    @Override public List<String> getRegions(){
      List<String> regionsList=new LinkedList<String>();
      regionsList.add("regionHost1:4080:9876");
      regionsList.add("regionHost2:4080");
      regionsList.add("regionHost3:4080:9876");
      return regionsList;
    }
  }
;
  try {
    conf.validate();
  }
 catch (  ConfigurationException e) {
    logger.error("Invalid configuration: ",e);
    success=true;
  }
  assertTrue(success);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hedwig.server.persistence.TestBookKeeperPersistenceManager </h4><pre class="type-2 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies boolean conditions
"></span><br>
@Test(timeout=60000) public void testScanMessagesOnEmptyLedgerAfterDeleteLedger() throws Exception {
  ByteString topic=ByteString.copyFromUtf8("TestScanMessagesOnEmptyLedgerAfterDeleteLedger");
  List<Message> msgs=new ArrayList<Message>();
  acquireTopic(topic);
  msgs.addAll(publishMessages(topic,2));
  releaseTopic(topic);
  acquireTopic(topic);
  logger.info("Consumed messages.");
  consumedUntil(topic,2L);
  Thread.sleep(2000L);
  logger.info("Released topic with an empty ledger.");
  releaseTopic(topic);
  acquireTopic(topic);
  logger.info("Published more messages.");
  msgs.addAll(publishMessages(topic,2));
  releaseTopic(topic);
  acquireTopic(topic);
  LinkedBlockingQueue<Boolean> statusQueue=new LinkedBlockingQueue<Boolean>();
  long startSeqId=removeStartSeqId ? 1 : 3;
  manager.scanMessages(new RangeScanRequest(topic,startSeqId,2,Long.MAX_VALUE,new RangeScanVerifier(subMessages(msgs,2,3),null),statusQueue));
  Boolean b=statusQueue.poll(10 * readDelay,TimeUnit.MILLISECONDS);
  assertTrue("Should succeed to scan messages after deleted consumed ledger.",b);
}

</code></pre>

<br>
<pre class="type-2 type-6 type-8 type-4 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testReadWhenTopicChangeLedger() throws Exception {
  final ByteString topic=ByteString.copyFromUtf8("testReadWhenTopicChangeLedger");
  LinkedList<Message> msgs=new LinkedList<Message>();
  acquireTopic(topic);
  msgs.addAll(publishMessages(topic,maxEntriesPerLedger));
  Thread.sleep(2000);
  LinkedBlockingQueue<Boolean> statusQueue=new LinkedBlockingQueue<Boolean>();
  RangeScanRequest scan=new RangeScanRequest(topic,maxEntriesPerLedger + 1,1,Long.MAX_VALUE,new RangeScanVerifier(msgs,null),statusQueue);
  manager.scanMessages(scan);
  Boolean b=statusQueue.poll(10 * readDelay,TimeUnit.MILLISECONDS);
  if (b == null) {
    fail("Scan request timeout");
  }
  assertFalse("Expect none message is scanned on the new created ledger",b);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hedwig.server.persistence.TestBookkeeperPersistenceManagerWhiteBox </h4><pre class="type-2 type-11 type-6 type-3 type-4 type-7 type-9 type-13 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values related to public fields.">PublicFieldVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions in iterations
- Verifies assertions inside branch conditions
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects are null
- Verifies whether objects/variable are equal to an expected value 
- Verifies values related to public fields.
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testSyncChangeLedgers() throws Exception {
  int NUM_MESSAGES_TO_TEST=101;
  int SIZE_OF_MESSAGES_TO_TEST=100;
  int index=0;
  List<Message> messages=HelperMethods.getRandomPublishedMessages(NUM_MESSAGES_TO_TEST,SIZE_OF_MESSAGES_TO_TEST);
  bkpm=new BookkeeperPersistenceManager(bktb.bk,mm,tm,new ChangeLedgerServerConfiguration(),scheduler);
  StubCallback<Void> stubCallback=new StubCallback<Void>();
  bkpm.acquiredTopic(topic,stubCallback,null);
  assertNull(ConcurrencyUtils.take(stubCallback.queue).right());
  assertEquals(0,bkpm.topicInfos.get(topic).ledgerRanges.size());
  while (index < messages.size()) {
    logger.debug("Persist message {}",(index + 1));
    StubCallback<MessageSeqId> persistCallback=new StubCallback<MessageSeqId>();
    bkpm.persistMessage(new PersistRequest(topic,messages.get(index),persistCallback,null));
    assertEquals(index + 1,ConcurrencyUtils.take(persistCallback.queue).left().getLocalComponent());
    index++;
    if (index % maxEntriesPerLedger == 1) {
      assertEquals(index / maxEntriesPerLedger,bkpm.topicInfos.get(topic).ledgerRanges.size());
    }
  }
  assertEquals(NUM_MESSAGES_TO_TEST / maxEntriesPerLedger,bkpm.topicInfos.get(topic).ledgerRanges.size());
  StubScanCallback scanCallback=new StubScanCallback();
  bkpm.scanMessages(new RangeScanRequest(topic,1,NUM_MESSAGES_TO_TEST,Long.MAX_VALUE,scanCallback,null));
  for (int i=0; i < messages.size(); i++) {
    Message scannedMessage=ConcurrencyUtils.take(scanCallback.queue).left();
    assertTrue(messages.get(i).getBody().equals(scannedMessage.getBody()));
    assertEquals(i + 1,scannedMessage.getMsgId().getLocalComponent());
  }
  assertTrue(StubScanCallback.END_MESSAGE == ConcurrencyUtils.take(scanCallback.queue).left());
  bkpm.topicInfos.clear();
  stubCallback=new StubCallback<Void>();
  bkpm.acquiredTopic(topic,stubCallback,null);
  assertNull(ConcurrencyUtils.take(stubCallback.queue).right());
  assertEquals(NUM_MESSAGES_TO_TEST / maxEntriesPerLedger + 1,bkpm.topicInfos.get(topic).ledgerRanges.size());
}

</code></pre>

<br>
<pre class="type-2 type-11 type-3 type-4 type-7 type-9 type-13 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values related to public fields.">PublicFieldVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions in iterations
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects are null
- Verifies whether objects/variable are equal to an expected value 
- Verifies values related to public fields.
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testNonEmptyDirtyLedger() throws Exception {
  Random r=new Random();
  int NUM_MESSAGES_TO_TEST=100;
  int SIZE_OF_MESSAGES_TO_TEST=100;
  int index=0;
  int numPrevLedgers=0;
  List<Message> messages=HelperMethods.getRandomPublishedMessages(NUM_MESSAGES_TO_TEST,SIZE_OF_MESSAGES_TO_TEST);
  while (index < messages.size()) {
    StubCallback<Void> stubCallback=new StubCallback<Void>();
    bkpm.acquiredTopic(topic,stubCallback,null);
    assertNull(ConcurrencyUtils.take(stubCallback.queue).right());
    assertEquals(numPrevLedgers,bkpm.topicInfos.get(topic).ledgerRanges.size());
    StubCallback<PubSubProtocol.MessageSeqId> persistCallback=new StubCallback<PubSubProtocol.MessageSeqId>();
    bkpm.persistMessage(new PersistRequest(topic,messages.get(index),persistCallback,null));
    assertEquals(index + 1,ConcurrencyUtils.take(persistCallback.queue).left().getLocalComponent());
    index++;
    if (r.nextInt(10) == 9) {
      if (index < messages.size()) {
        bkpm.topicInfos.clear();
        numPrevLedgers++;
      }
    }
  }
  StubScanCallback scanCallback=new StubScanCallback();
  bkpm.scanMessages(new RangeScanRequest(topic,1,NUM_MESSAGES_TO_TEST,Long.MAX_VALUE,scanCallback,null));
  for (int i=0; i < messages.size(); i++) {
    Message scannedMessage=ConcurrencyUtils.take(scanCallback.queue).left();
    assertTrue(messages.get(i).getBody().equals(scannedMessage.getBody()));
    assertEquals(i + 1,scannedMessage.getMsgId().getLocalComponent());
  }
  assertTrue(StubScanCallback.END_MESSAGE == ConcurrencyUtils.take(scanCallback.queue).left());
}

</code></pre>

<br>
<pre class="type-2 type-11 type-3 type-4 type-7 type-9 type-13 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values related to public fields.">PublicFieldVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions in iterations
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects are null
- Verifies whether objects/variable are equal to an expected value 
- Verifies values related to public fields.
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testAsyncChangeLedgers() throws Exception {
  int NUM_MESSAGES_TO_TEST=101;
  int SIZE_OF_MESSAGES_TO_TEST=100;
  List<Message> messages=HelperMethods.getRandomPublishedMessages(NUM_MESSAGES_TO_TEST,SIZE_OF_MESSAGES_TO_TEST);
  bkpm=new BookkeeperPersistenceManager(bktb.bk,mm,tm,new ChangeLedgerServerConfiguration(),scheduler);
  StubCallback<Void> stubCallback=new StubCallback<Void>();
  bkpm.acquiredTopic(topic,stubCallback,null);
  assertNull(ConcurrencyUtils.take(stubCallback.queue).right());
  assertEquals(0,bkpm.topicInfos.get(topic).ledgerRanges.size());
  OrderCheckingCallback persistCallback=new OrderCheckingCallback(1,NUM_MESSAGES_TO_TEST);
  for (  Message message : messages) {
    bkpm.persistMessage(new PersistRequest(topic,message,persistCallback,null));
  }
  assertEquals(NUM_MESSAGES_TO_TEST + 1,ConcurrencyUtils.take(persistCallback.queue).left().getLocalComponent());
  assertEquals(NUM_MESSAGES_TO_TEST,persistCallback.numSuccess);
  assertEquals(0,persistCallback.numFailed);
  assertEquals(NUM_MESSAGES_TO_TEST / maxEntriesPerLedger,bkpm.topicInfos.get(topic).ledgerRanges.size());
  stubCallback=new StubCallback<Void>();
  bkpm.acquiredTopic(topic,stubCallback,null);
  StubScanCallback scanCallback=new StubScanCallback();
  bkpm.scanMessages(new RangeScanRequest(topic,1,NUM_MESSAGES_TO_TEST,Long.MAX_VALUE,scanCallback,null));
  for (int i=0; i < messages.size(); i++) {
    Either<Message,Exception> e=ConcurrencyUtils.take(scanCallback.queue);
    Message scannedMessage=e.left();
    if (scannedMessage == null) {
      throw e.right();
    }
    assertTrue(messages.get(i).getBody().equals(scannedMessage.getBody()));
    assertEquals(i + 1,scannedMessage.getMsgId().getLocalComponent());
  }
  assertTrue(StubScanCallback.END_MESSAGE == ConcurrencyUtils.take(scanCallback.queue).left());
  bkpm.topicInfos.clear();
  stubCallback=new StubCallback<Void>();
  bkpm.acquiredTopic(topic,stubCallback,null);
  assertNull(ConcurrencyUtils.take(stubCallback.queue).right());
  assertEquals(NUM_MESSAGES_TO_TEST / maxEntriesPerLedger + 1,bkpm.topicInfos.get(topic).ledgerRanges.size());
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hedwig.server.persistence.TestDeadlock </h4><pre class="type-11 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies boolean conditions
"></span><br>
@Test(timeout=60000) public void testDeadlock() throws Exception {
  int numMessages=5;
  SynchronousQueue<Boolean> consumeQueue=new SynchronousQueue<Boolean>();
  logger.info("Setup subscriptions");
  SubscriptionOptions opts=SubscriptionOptions.newBuilder().setCreateOrAttach(CreateOrAttach.CREATE_OR_ATTACH).build();
  subscriber.subscribe(topic,subscriberId,opts);
  subscriber.closeSubscription(topic,subscriberId);
  for (int i=0; i < numMessages; i++) {
    logger.info("Start publishing message {}",i);
    publisher.publish(topic,getMsg(i));
  }
  stopHubServers();
  Thread.sleep(1000);
  startHubServers();
  logger.info("Start publishing messages");
  for (int i=0; i < numMessages; i++) {
    logger.info("Start publishing message {}",i + 5);
    publisher.publish(topic,getMsg(i));
  }
  logger.info("Start subscribe topics again and receive messages");
  subscriber.subscribe(topic,subscriberId,opts);
  subscriber.startDelivery(topic,subscriberId,new TestMessageHandler(consumeQueue));
  for (int i=0; i < (2 * numMessages + 3); i++) {
    assertTrue(consumeQueue.take());
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hedwig.server.persistence.TestReadAheadCacheWhiteBox </h4><pre class="type-3 type-4 type-7 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testPersistMessage() throws Exception {
  StubCallback<PubSubProtocol.MessageSeqId> callback=new StubCallback<PubSubProtocol.MessageSeqId>();
  PersistRequest request=new PersistRequest(topic,messages.get(0),callback,null);
  stubPersistenceManager.failure=true;
  cacheBasedPersistenceManager.persistMessage(request);
  assertNotNull(ConcurrencyUtils.take(callback.queue).right());
  CacheKey key=new CacheKey(topic,cacheBasedPersistenceManager.getCurrentSeqIdForTopic(topic).getLocalComponent());
  assertFalse(cacheBasedPersistenceManager.cache.containsKey(key));
  stubPersistenceManager.failure=false;
  persistMessage(messages.get(0));
}

</code></pre>

<br>
<pre class="type-2 type-3 type-4 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testDeliveredUntil() throws Exception {
  for (  Message m : messages) {
    persistMessage(m);
  }
  assertEquals((long)NUM_MESSAGES * MSG_SIZE,cacheBasedPersistenceManager.presentCacheSize.get());
  long middle=messages.size() / 2;
  cacheBasedPersistenceManager.deliveredUntil(topic,middle);
  assertEquals(messages.size() - middle,cacheBasedPersistenceManager.cache.size());
  long middle2=middle - 1;
  cacheBasedPersistenceManager.deliveredUntil(topic,middle2);
  assertEquals(messages.size() - middle,cacheBasedPersistenceManager.cache.size());
  cacheBasedPersistenceManager.deliveredUntil(topic,(long)messages.size());
  assertTrue(cacheBasedPersistenceManager.cache.isEmpty());
  assertTrue(cacheBasedPersistenceManager.cacheSegment.get().timeIndexOfAddition.isEmpty());
  assertTrue(cacheBasedPersistenceManager.orderedIndexOnSeqId.isEmpty());
  assertTrue(0 == cacheBasedPersistenceManager.presentCacheSize.get());
}

</code></pre>

<br>
<pre class="type-2 type-3 type-4 type-9 type-13 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values related to public fields.">PublicFieldVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Verifies values related to public fields.
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testAddMessageToCache(){
  CacheKey key=new CacheKey(topic,1);
  cacheBasedPersistenceManager.addMessageToCache(key,messages.get(0),MathUtils.now());
  assertEquals(1,cacheBasedPersistenceManager.cache.size());
  assertEquals(MSG_SIZE,cacheBasedPersistenceManager.presentCacheSize.get());
  assertEquals(1,cacheBasedPersistenceManager.orderedIndexOnSeqId.get(topic).size());
  assertTrue(cacheBasedPersistenceManager.orderedIndexOnSeqId.get(topic).contains(1L));
  CacheValue value=cacheBasedPersistenceManager.cache.get(key);
  assertTrue(cacheBasedPersistenceManager.cacheSegment.get().timeIndexOfAddition.get(value.timeOfAddition).contains(key));
}

</code></pre>

<br>
<pre class="type-3 type-4 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testReadAheadSizeLimit() throws Exception {
  for (  Message m : messages) {
    persistMessage(m);
  }
  cacheBasedPersistenceManager.cache.clear();
  StubScanCallback callback=new StubScanCallback();
  ScanRequest request=new ScanRequest(topic,1,callback,null);
  cacheBasedPersistenceManager.scanSingleMessage(request);
  assertTrue(callback.isSuccess());
  assertEquals((int)Math.ceil(myConf.readAheadSize / (MSG_SIZE + 0.0)),cacheBasedPersistenceManager.cache.size());
}

</code></pre>

<br>
<pre class="type-3 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
"></span><br>
@Test(timeout=60000) public void testScanSingleMessage() throws Exception {
  StubScanCallback callback=new StubScanCallback();
  ScanRequest request=new ScanRequest(topic,1,callback,null);
  stubPersistenceManager.failure=true;
  cacheBasedPersistenceManager.scanSingleMessage(request);
  assertTrue(callback.isFailed());
  assertTrue(0 == cacheBasedPersistenceManager.cache.size());
  stubPersistenceManager.failure=false;
  cacheBasedPersistenceManager.scanSingleMessage(request);
  assertTrue(myConf.readAheadCount == cacheBasedPersistenceManager.cache.size());
  persistMessage(messages.get(0));
  assertTrue(callback.isSuccess());
}

</code></pre>

<br>
<pre class="type-3 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
"></span><br>
@Test(timeout=60000) public void testRemoveMessageFromCache(){
  CacheKey key=new CacheKey(topic,1);
  cacheBasedPersistenceManager.addMessageToCache(key,messages.get(0),MathUtils.now());
  cacheBasedPersistenceManager.removeMessageFromCache(key,new Exception(),true,true);
  assertTrue(cacheBasedPersistenceManager.cache.isEmpty());
  assertTrue(cacheBasedPersistenceManager.orderedIndexOnSeqId.isEmpty());
  assertTrue(cacheBasedPersistenceManager.cacheSegment.get().timeIndexOfAddition.isEmpty());
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hedwig.server.subscriptions.TestMMSubscriptionManager </h4><pre class="type-3 type-4 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testBasics() throws Exception {
  ByteString topic1=ByteString.copyFromUtf8("topic1");
  ByteString sub1=ByteString.copyFromUtf8("sub1");
  SubscribeRequest subRequest=SubscribeRequest.newBuilder().setSubscriberId(sub1).build();
  MessageSeqId msgId=MessageSeqId.newBuilder().setLocalComponent(100).build();
  sm.serveSubscribeRequest(topic1,subRequest,msgId,subDataCallback,null);
  Assert.assertEquals(ConcurrencyUtils.take(subDataCallbackQueue).right().getClass(),PubSubException.ServerNotResponsibleForTopicException.class);
  sm.unsubscribe(topic1,sub1,voidCallback,null);
  Assert.assertEquals(ConcurrencyUtils.take(BooleanCallbackQueue).right().getClass(),PubSubException.ServerNotResponsibleForTopicException.class);
  sm.acquiredTopic(topic1,voidCallback,null);
  Assert.assertTrue(BooleanCallbackQueue.take().left());
  Assert.assertTrue(sm.top2sub2seq.containsKey(topic1));
  Assert.assertEquals(0,sm.top2sub2seq.get(topic1).size());
  sm.unsubscribe(topic1,sub1,voidCallback,null);
  Assert.assertEquals(ConcurrencyUtils.take(BooleanCallbackQueue).right().getClass(),PubSubException.ClientNotSubscribedException.class);
  subRequest=SubscribeRequest.newBuilder().setCreateOrAttach(CreateOrAttach.ATTACH).setSubscriberId(sub1).build();
  sm.serveSubscribeRequest(topic1,subRequest,msgId,subDataCallback,null);
  Assert.assertEquals(ConcurrencyUtils.take(subDataCallbackQueue).right().getClass(),PubSubException.ClientNotSubscribedException.class);
  subRequest=SubscribeRequest.newBuilder().setCreateOrAttach(CreateOrAttach.CREATE).setSubscriberId(sub1).build();
  sm.serveSubscribeRequest(topic1,subRequest,msgId,subDataCallback,null);
  Assert.assertEquals(msgId.getLocalComponent(),ConcurrencyUtils.take(subDataCallbackQueue).left().getState().getMsgId().getLocalComponent());
  Assert.assertEquals(msgId.getLocalComponent(),sm.top2sub2seq.get(topic1).get(sub1).getLastConsumeSeqId().getLocalComponent());
  sm.serveSubscribeRequest(topic1,subRequest,msgId,subDataCallback,null);
  Assert.assertEquals(ConcurrencyUtils.take(subDataCallbackQueue).right().getClass(),PubSubException.ClientAlreadySubscribedException.class);
  Assert.assertEquals(msgId.getLocalComponent(),sm.top2sub2seq.get(topic1).get(sub1).getLastConsumeSeqId().getLocalComponent());
  sm.lostTopic(topic1);
  sm.acquiredTopic(topic1,voidCallback,null);
  Assert.assertTrue(BooleanCallbackQueue.take().left());
  subRequest=SubscribeRequest.newBuilder().setCreateOrAttach(CreateOrAttach.ATTACH).setSubscriberId(sub1).build();
  MessageSeqId msgId1=MessageSeqId.newBuilder().setLocalComponent(msgId.getLocalComponent() + 10).build();
  sm.serveSubscribeRequest(topic1,subRequest,msgId1,subDataCallback,null);
  Assert.assertEquals(msgId.getLocalComponent(),subDataCallbackQueue.take().left().getState().getMsgId().getLocalComponent());
  Assert.assertEquals(msgId.getLocalComponent(),sm.top2sub2seq.get(topic1).get(sub1).getLastConsumeSeqId().getLocalComponent());
  MessageSeqId msgId2=MessageSeqId.newBuilder().setLocalComponent(msgId.getLocalComponent() + cfg.getConsumeInterval() - 1).build();
  sm.setConsumeSeqIdForSubscriber(topic1,sub1,msgId2,voidCallback,null);
  Assert.assertTrue(BooleanCallbackQueue.take().left());
  Assert.assertEquals(msgId2.getLocalComponent(),sm.top2sub2seq.get(topic1).get(sub1).getLastConsumeSeqId().getLocalComponent());
  Assert.assertEquals(msgId.getLocalComponent(),sm.top2sub2seq.get(topic1).get(sub1).getSubscriptionState().getMsgId().getLocalComponent());
  MessageSeqId msgId3=MessageSeqId.newBuilder().setLocalComponent(msgId.getLocalComponent() + cfg.getConsumeInterval() + 1).build();
  sm.setConsumeSeqIdForSubscriber(topic1,sub1,msgId3,voidCallback,null);
  Assert.assertTrue(BooleanCallbackQueue.take().left());
  sm.lostTopic(topic1);
  sm.acquiredTopic(topic1,voidCallback,null);
  Assert.assertTrue(BooleanCallbackQueue.take().left());
  Assert.assertEquals(msgId3.getLocalComponent(),sm.top2sub2seq.get(topic1).get(sub1).getLastConsumeSeqId().getLocalComponent());
  Assert.assertEquals(msgId3.getLocalComponent(),sm.top2sub2seq.get(topic1).get(sub1).getSubscriptionState().getMsgId().getLocalComponent());
  sm.unsubscribe(topic1,sub1,voidCallback,null);
  Assert.assertTrue(BooleanCallbackQueue.take().left());
  sm.lostTopic(topic1);
  sm.acquiredTopic(topic1,voidCallback,null);
  Assert.assertTrue(BooleanCallbackQueue.take().left());
  Assert.assertFalse(sm.top2sub2seq.get(topic1).containsKey(sub1));
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hedwig.server.subscriptions.TestUpdateSubscriptionState </h4><pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies boolean conditions
"></span><br>
@Test(timeout=60000) public void testConsumeWhenHubShutdown() throws Exception {
  ByteString topic=ByteString.copyFromUtf8("TestConsumeWhenHubShutdown");
  ByteString subId=ByteString.copyFromUtf8("mysub");
  int startMsgId=0;
  int numMsgs=10;
  SubscriptionOptions opts=SubscriptionOptions.newBuilder().setCreateOrAttach(CreateOrAttach.CREATE_OR_ATTACH).build();
  subscriber.subscribe(topic,subId,opts);
  OrderCheckingMessageHandler ocm=new OrderCheckingMessageHandler(topic,subId,startMsgId,numMsgs);
  subscriber.startDelivery(topic,subId,ocm);
  for (int i=0; i < numMsgs; i++) {
    Message msg=Message.newBuilder().setBody(ByteString.copyFromUtf8(Integer.toString(startMsgId + i))).build();
    publisher.publish(topic,msg);
  }
  logger.info("Publish finished.");
  queue.take();
  logger.info("Deliver finished.");
  assertTrue(ocm.isInOrder());
  Thread.sleep(2000);
  subscriber.stopDelivery(topic,subId);
  subscriber.closeSubscription(topic,subId);
  stopHubServers();
  Thread.sleep(1000);
  startHubServers();
  startMsgId=20;
  subscriber.subscribe(topic,subId,opts);
  ocm=new OrderCheckingMessageHandler(topic,subId,startMsgId,numMsgs);
  subscriber.startDelivery(topic,subId,ocm);
  for (int i=0; i < numMsgs; i++) {
    Message msg=Message.newBuilder().setBody(ByteString.copyFromUtf8(Integer.toString(startMsgId + i))).build();
    publisher.publish(topic,msg);
  }
  queue.take();
  assertTrue(ocm.isInOrder());
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies boolean conditions
"></span><br>
@Test(timeout=60000) public void testConsumeWhenTopicRelease() throws Exception {
  ByteString topic=ByteString.copyFromUtf8("TestConsumeWhenTopicRelease");
  ByteString subId=ByteString.copyFromUtf8("mysub");
  int startMsgId=0;
  int numMsgs=10;
  SubscriptionOptions opts=SubscriptionOptions.newBuilder().setCreateOrAttach(CreateOrAttach.CREATE_OR_ATTACH).build();
  subscriber.subscribe(topic,subId,opts);
  OrderCheckingMessageHandler ocm=new OrderCheckingMessageHandler(topic,subId,startMsgId,numMsgs);
  subscriber.startDelivery(topic,subId,ocm);
  for (int i=0; i < numMsgs; i++) {
    Message msg=Message.newBuilder().setBody(ByteString.copyFromUtf8(Integer.toString(startMsgId + i))).build();
    publisher.publish(topic,msg);
  }
  logger.info("Publish finished.");
  queue.take();
  logger.info("Deliver finished.");
  assertTrue(ocm.isInOrder());
  Thread.sleep((RETENTION_SECS_VALUE + 2) * 1000);
  subscriber.stopDelivery(topic,subId);
  subscriber.closeSubscription(topic,subId);
  startMsgId=20;
  subscriber.subscribe(topic,subId,opts);
  ocm=new OrderCheckingMessageHandler(topic,subId,startMsgId,numMsgs);
  subscriber.startDelivery(topic,subId,ocm);
  for (int i=0; i < numMsgs; i++) {
    Message msg=Message.newBuilder().setBody(ByteString.copyFromUtf8(Integer.toString(startMsgId + i))).build();
    publisher.publish(topic,msg);
  }
  queue.take();
  assertTrue(ocm.isInOrder());
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hedwig.server.topics.TestMMTopicManager </h4><pre class="type-2 type-3 type-4 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testOwnershipChange() throws Exception {
  SynchronousQueue<Pair<ByteString,Boolean>> bsQueue=new SynchronousQueue<Pair<ByteString,Boolean>>();
  StubOwnershipChangeListener listener=new StubOwnershipChangeListener(bsQueue);
  tm.addTopicOwnershipChangeListener(listener);
  tm.getOwner(topic,true,addrCbq,null);
  Pair<ByteString,Boolean> pair=bsQueue.take();
  Assert.assertEquals(topic,pair.first());
  Assert.assertTrue(pair.second());
  Assert.assertEquals(me,check(addrCbq.take()));
  assertOwnershipNodeExists();
  tm.getOwner(topic,true,addrCbq,null);
  Assert.assertEquals(me,check(addrCbq.take()));
  Assert.assertTrue(bsQueue.isEmpty());
  assertOwnershipNodeExists();
  tm.releaseTopic(topic,cb,null);
  pair=bsQueue.take();
  Assert.assertEquals(topic,pair.first());
  Assert.assertFalse(pair.second());
  Assert.assertTrue(queue.take());
  assertOwnershipNodeDoesntExist();
  tm.releaseTopic(mkTopic(0),cb,null);
  Assert.assertTrue(queue.take());
  Assert.assertTrue(bsQueue.isEmpty());
  listener.setFailure(true);
  tm.getOwner(topic,true,addrCbq,null);
  pair=bsQueue.take();
  Assert.assertEquals(topic,pair.first());
  Assert.assertTrue(pair.second());
  Assert.assertEquals(PubSubException.ServiceDownException.class,((CompositeException)addrCbq.take().right()).getExceptions().iterator().next().getClass());
  Assert.assertFalse(null != tm.topics.getIfPresent(topic));
  Thread.sleep(100);
  assertOwnershipNodeDoesntExist();
}

</code></pre>

<br>
<pre class="type-3 type-4 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testZKClientDisconnected() throws Exception {
  tm.getOwner(topic,true,addrCbq,null);
  Assert.assertEquals(me,check(addrCbq.take()));
  tm.isSuspended=true;
  tm.getOwner(topic,true,addrCbq,null);
  Assert.assertEquals(PubSubException.ServiceDownException.class,addrCbq.take().right().getClass());
  tm.releaseTopic(topic,cb,null);
  Assert.assertTrue(queue.take());
  assertOwnershipNodeDoesntExist();
  tm.isSuspended=false;
  tm.getOwner(topic,true,addrCbq,null);
  Assert.assertEquals(me,check(addrCbq.take()));
  assertOwnershipNodeExists();
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hedwig.server.topics.TestTopicBasedLoadShedder </h4><pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies boolean conditions
"></span><br>
@Test(timeout=60000) public synchronized void testMaxLoadShed() throws Exception {
  initialize(20,10,getEqualLoadDistributionArray(9,10));
  MockTopicBasedLoadShedder tbls=new MockTopicBasedLoadShedder(null,mockTopicList,0.0,new HubLoad(5));
  tbls.shedLoad(mockLoadMap,getShedLoadCallback(tbls,new HubLoad(15),true,false),null);
  Assert.assertTrue(statusQueue.take());
  tbls=new MockTopicBasedLoadShedder(null,mockTopicList,0.0,new HubLoad(9));
  tbls.shedLoad(mockLoadMap,getShedLoadCallback(tbls,new HubLoad(11),true,false),null);
  Assert.assertTrue(statusQueue.take());
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies boolean conditions
"></span><br>
@Test(timeout=60000) public synchronized void testSingleHubLoadShed() throws Exception {
  initialize(20,1,null);
  MockTopicBasedLoadShedder tbls=new MockTopicBasedLoadShedder(null,mockTopicList,0.0,infiniteMaxLoad);
  tbls.shedLoad(mockLoadMap,getShedLoadCallback(tbls,null,false,false),null);
  Assert.assertTrue(statusQueue.take());
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies boolean conditions
"></span><br>
@Test(timeout=60000) public synchronized void testOneHubUnequalTopics() throws Exception {
  initialize(20,10,getEqualLoadDistributionArray(9,10));
  MockTopicBasedLoadShedder tbls=new MockTopicBasedLoadShedder(null,mockTopicList,0.0,infiniteMaxLoad);
  tbls.shedLoad(mockLoadMap,getShedLoadCallback(tbls,new HubLoad(11),true,false),null);
  Assert.assertTrue(statusQueue.take());
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies boolean conditions
"></span><br>
@Test(timeout=60000) public synchronized void testUnderloadedClusterLoadShed() throws Exception {
  initialize(5,10,getEqualLoadDistributionArray(9,0));
  MockTopicBasedLoadShedder tbls=new MockTopicBasedLoadShedder(null,mockTopicList,0.0,infiniteMaxLoad);
  tbls.shedLoad(mockLoadMap,getShedLoadCallback(tbls,new HubLoad(1),true,false),null);
  Assert.assertTrue(statusQueue.take());
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies boolean conditions
"></span><br>
@Test(timeout=60000) public synchronized void testAllHubsSameTopics() throws Exception {
  initialize(10,10,getEqualLoadDistributionArray(9,10));
  MockTopicBasedLoadShedder tbls=new MockTopicBasedLoadShedder(null,mockTopicList,0.0,infiniteMaxLoad);
  tbls.shedLoad(mockLoadMap,getShedLoadCallback(tbls,null,false,false),null);
  Assert.assertTrue(statusQueue.take());
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies boolean conditions
"></span><br>
@Test(timeout=60000) public synchronized void testOneHubUnequalTopicsWithTolerance() throws Exception {
  initialize(20,10,getEqualLoadDistributionArray(9,10));
  MockTopicBasedLoadShedder tbls=new MockTopicBasedLoadShedder(null,mockTopicList,50.0,infiniteMaxLoad);
  tbls.shedLoad(mockLoadMap,getShedLoadCallback(tbls,new HubLoad(11),true,false),null);
  Assert.assertTrue(statusQueue.take());
  tbls=new MockTopicBasedLoadShedder(null,mockTopicList,100.0,infiniteMaxLoad);
  tbls.shedLoad(mockLoadMap,getShedLoadCallback(tbls,null,false,false),null);
  Assert.assertTrue(statusQueue.take());
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hedwig.server.topics.TestZkTopicManager </h4><pre class="type-2 type-3 type-4 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testOwnershipChange() throws Exception {
  SynchronousQueue<Pair<ByteString,Boolean>> bsQueue=new SynchronousQueue<Pair<ByteString,Boolean>>();
  StubOwnershipChangeListener listener=new StubOwnershipChangeListener(bsQueue);
  tm.addTopicOwnershipChangeListener(listener);
  tm.getOwner(topic,true,addrCbq,null);
  Pair<ByteString,Boolean> pair=bsQueue.take();
  Assert.assertEquals(topic,pair.first());
  Assert.assertTrue(pair.second());
  Assert.assertEquals(me,check(addrCbq.take()));
  assertOwnershipNodeExists();
  tm.getOwner(topic,true,addrCbq,null);
  Assert.assertEquals(me,check(addrCbq.take()));
  Assert.assertTrue(bsQueue.isEmpty());
  assertOwnershipNodeExists();
  tm.releaseTopic(topic,cb,null);
  pair=bsQueue.take();
  Assert.assertEquals(topic,pair.first());
  Assert.assertFalse(pair.second());
  Assert.assertTrue(queue.take());
  assertOwnershipNodeDoesntExist();
  tm.releaseTopic(mkTopic(0),cb,null);
  Assert.assertTrue(queue.take());
  Assert.assertTrue(bsQueue.isEmpty());
  listener.setFailure(true);
  tm.getOwner(topic,true,addrCbq,null);
  pair=bsQueue.take();
  Assert.assertEquals(topic,pair.first());
  Assert.assertTrue(pair.second());
  Assert.assertEquals(PubSubException.ServiceDownException.class,((CompositeException)addrCbq.take().right()).getExceptions().iterator().next().getClass());
  Assert.assertFalse(null != tm.topics.getIfPresent(topic));
  Thread.sleep(100);
  assertOwnershipNodeDoesntExist();
}

</code></pre>

<br>
<pre class="type-3 type-4 type-9 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testZKClientDisconnected() throws Exception {
  tm.getOwner(topic,true,addrCbq,null);
  Assert.assertEquals(me,check(addrCbq.take()));
  tm.isSuspended=true;
  tm.getOwner(topic,true,addrCbq,null);
  Assert.assertEquals(PubSubException.ServiceDownException.class,addrCbq.take().right().getClass());
  tm.releaseTopic(topic,cb,null);
  Assert.assertTrue(queue.take());
  assertOwnershipNodeDoesntExist();
  tm.isSuspended=false;
  tm.getOwner(topic,true,addrCbq,null);
  Assert.assertEquals(me,check(addrCbq.take()));
  assertOwnershipNodeExists();
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hedwig.util.TestFileUtils </h4><pre class="type-2 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies boolean conditions
"></span><br>
@Test(timeout=60000) public void testCreateTmpDirectory() throws Exception {
  String prefix="abc";
  String suffix="def";
  File dir=FileUtils.createTempDirectory(prefix,suffix);
  assertTrue(dir.isDirectory());
  assertTrue(dir.getName().startsWith(prefix));
  assertTrue(dir.getName().endsWith(suffix));
  FileUtils.dirDeleterThread.start();
  FileUtils.dirDeleterThread.join();
  assertFalse(dir.exists());
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hedwig.util.TestHedwigSocketAddress </h4><pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies boolean conditions
"></span><br>
@Test(timeout=60000) public void testIsSSLEnabledFlag() throws Exception {
  HedwigSocketAddress sslAddr=new HedwigSocketAddress(hostname,port,sslPort);
  assertTrue(sslAddr.isSSLEnabled());
  HedwigSocketAddress addr=new HedwigSocketAddress(hostname,port);
  assertFalse(addr.isSSLEnabled());
}

</code></pre>

<br>
<pre class="type-3 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
"></span><br>
@Test(timeout=60000) public void testCreateWithNoSSLPort() throws Exception {
  HedwigSocketAddress addr=new HedwigSocketAddress(hostname,port);
  assertTrue(addr.getSocketAddress().equals(new InetSocketAddress(hostname,port)));
  assertTrue(addr.getSSLSocketAddress() == null);
}

</code></pre>

<br>
<pre class="type-3 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
"></span><br>
@Test(timeout=60000) public void testCreateFromStringWithSSLPort() throws Exception {
  HedwigSocketAddress addr=new HedwigSocketAddress(hostname + COLON + port+ COLON+ sslPort);
  assertTrue(addr.getSocketAddress().equals(new InetSocketAddress(hostname,port)));
  assertTrue(addr.getSSLSocketAddress().equals(new InetSocketAddress(hostname,sslPort)));
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies boolean conditions
"></span><br>
@Test(timeout=60000) public void testCreateWithInvalidSSLPort() throws Exception {
  boolean success=false;
  try {
    new HedwigSocketAddress(hostname,port,invalidPort);
  }
 catch (  IllegalArgumentException e) {
    success=true;
  }
  assertTrue(success);
}

</code></pre>

<br>
<pre class="type-3 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
"></span><br>
@Test(timeout=60000) public void testToStringConversion() throws Exception {
  HedwigSocketAddress addr=new HedwigSocketAddress(hostname,port,sslPort);
  HedwigSocketAddress addr2=new HedwigSocketAddress(addr.toString());
  assertTrue(addr.getSocketAddress().equals(addr2.getSocketAddress()));
  assertTrue(addr.getSSLSocketAddress().equals(addr2.getSSLSocketAddress()));
  addr.toString().equals(addr2.toString());
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies boolean conditions
"></span><br>
@Test(timeout=60000) public void testCreateWithInvalidRegularPort() throws Exception {
  boolean success=false;
  try {
    new HedwigSocketAddress(hostname + COLON + invalidPort);
  }
 catch (  IllegalArgumentException e) {
    success=true;
  }
  assertTrue(success);
}

</code></pre>

<br>
<pre class="type-3 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
"></span><br>
@Test(timeout=60000) public void testCreateFromStringWithNoSSLPort() throws Exception {
  HedwigSocketAddress addr=new HedwigSocketAddress(hostname + COLON + port);
  assertTrue(addr.getSocketAddress().equals(new InetSocketAddress(hostname,port)));
  assertTrue(addr.getSSLSocketAddress() == null);
}

</code></pre>

<br>
<pre class="type-3 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
"></span><br>
@Test(timeout=60000) public void testCreateWithSSLPort() throws Exception {
  HedwigSocketAddress addr=new HedwigSocketAddress(hostname,port,sslPort);
  assertTrue(addr.getSocketAddress().equals(new InetSocketAddress(hostname,port)));
  assertTrue(addr.getSSLSocketAddress().equals(new InetSocketAddress(hostname,sslPort)));
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hedwig.util.TestPathUtils </h4><pre class="type-11 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies boolean conditions
"></span><br>
@Test(timeout=60000) public void testIsPrefix(){
  String[] paths=new String[]{"/","/a","/a/b"};
  for (int i=0; i < paths.length; i++) {
    for (int j=0; j <= i; j++) {
      assertTrue(PathUtils.isPrefix(paths[j],paths[i]));
      assertTrue(PathUtils.isPrefix(paths[j],paths[i] + "/"));
      assertTrue(PathUtils.isPrefix(paths[j] + "/",paths[i]));
      assertTrue(PathUtils.isPrefix(paths[j] + "/",paths[i] + "/"));
    }
    for (int j=i + 1; j < paths.length; j++) {
      assertFalse(PathUtils.isPrefix(paths[j],paths[i]));
      assertFalse(PathUtils.isPrefix(paths[j],paths[i] + "/"));
      assertFalse(PathUtils.isPrefix(paths[j] + "/",paths[i]));
      assertFalse(PathUtils.isPrefix(paths[j] + "/",paths[i] + "/"));
    }
  }
}

</code></pre>

<br>
<script>$(document).ready(function() {
  $('pre code').each(function(i, block) {
    hljs.highlightBlock(block);
  });
});</script>
