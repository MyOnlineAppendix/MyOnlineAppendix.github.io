<h3><span class=" glyphicon glyphicon-tag"/>&nbspBranchVerifier</h3><kbd>Verifies assertions inside branch conditions</kbd><br><br><br><h4 style="margin:0px">Class: org.apache.nutch.analysis.lang.TestHTMLLanguageParser </h4><pre class="type-6 type-4 type-7 type-2 type-5 type-1 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions in iterations
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testLanguageIndentifier(){
  try {
    long total=0;
    LanguageIdentifier identifier;
    BufferedReader in=new BufferedReader(new InputStreamReader(this.getClass().getResourceAsStream("test-referencial.txt")));
    String line=null;
    while ((line=in.readLine()) != null) {
      String[] tokens=line.split(";");
      if (!tokens[0].equals("")) {
        StringBuilder content=new StringBuilder();
        BufferedReader testFile=new BufferedReader(new InputStreamReader(this.getClass().getResourceAsStream(tokens[0]),"UTF-8"));
        String testLine=null, lang=null;
        while ((testLine=testFile.readLine()) != null) {
          content.append(testLine + "\n");
          testLine=testLine.trim();
          if (testLine.length() > 256) {
            identifier=new LanguageIdentifier(testLine);
            lang=identifier.getLanguage();
            Assert.assertEquals(tokens[1],lang);
          }
        }
        testFile.close();
        long start=System.currentTimeMillis();
        System.out.println(content.toString());
        identifier=new LanguageIdentifier(content.toString());
        lang=identifier.getLanguage();
        System.out.println(lang);
        total+=System.currentTimeMillis() - start;
        Assert.assertEquals(tokens[1],lang);
      }
    }
    in.close();
    System.out.println("Total Time=" + total);
  }
 catch (  Exception e) {
    e.printStackTrace();
    Assert.fail(e.toString());
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.nutch.crawl.TODOTestCrawlDbStates </h4><pre class="type-7 type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * NUTCH-578: a fetch_retry should result in a db_gone if db.fetch.retry.max
 * is reached. Retry counter has to be reset appropriately.
 */
@Test public void testCrawlDbReducerPageRetrySchedule(){
  LOG.info("NUTCH-578: test long running continuous crawl with fetch_retry");
  ContinuousCrawlTestUtil crawlUtil=new ContinuousCrawlTestFetchRetry();
  if (!crawlUtil.run(150)) {
    fail("fetch_retry did not result in a db_gone if retry counter > maxRetries (NUTCH-578)");
  }
}

</code></pre>

<br>
<pre class="type-7 type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * NUTCH-1564 AdaptiveFetchSchedule: sync_delta forces immediate re-fetch for
 * documents not modified
 * <p>
 * Problem: documents not modified for a longer time are fetched in every
 * cycle because of an error in the SYNC_DELTA calculation of{@link AdaptiveFetchSchedule}. <br>
 * The next fetch time should always be in the future, never in the past.
 * </p>
 */
@Test public void testAdaptiveFetchScheduleSyncDelta(){
  LOG.info("NUTCH-1564 test SYNC_DELTA calculation of AdaptiveFetchSchedule");
  Configuration conf=CrawlDBTestUtil.createConfiguration();
  conf.setLong("db.fetch.interval.default",172800);
  conf.setLong("db.fetch.schedule.adaptive.min_interval",86400);
  conf.setLong("db.fetch.schedule.adaptive.max_interval",604800);
  conf.setLong("db.fetch.interval.max",604800);
  conf.set("db.fetch.schedule.class","org.apache.nutch.crawl.AdaptiveFetchSchedule");
  ContinuousCrawlTestUtil crawlUtil=new CrawlTestFetchScheduleNotModifiedFetchTime(conf);
  crawlUtil.setInterval(FetchSchedule.SECONDS_PER_DAY / 3);
  if (!crawlUtil.run(100)) {
    fail("failed: sync_delta calculation with AdaptiveFetchSchedule");
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.nutch.crawl.TestCrawlDbStates </h4><pre class="type-6 type-4 type-7 type-2 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions in iterations
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
"></span><br>
/** 
 * Test the matrix of state transitions:
 * <ul>
 * <li>for all available {@link FetchSchedule} implementations</li>
 * <li>for every possible status in CrawlDb (including "not in CrawlDb")</li>
 * <li>for every possible fetch status</li>
 * <li>and zero or more (0-3) additional in-links</li>
 * </ul>
 * call {@literal updatedb} and check whether the resulting CrawlDb status is
 * the expected one.
 */
@Test public void testCrawlDbStateTransitionMatrix(){
  LOG.info("Test CrawlDatum state transitions");
  Configuration conf=CrawlDBTestUtil.createConfiguration();
  CrawlDbUpdateUtil<CrawlDbReducer> updateDb=new CrawlDbUpdateUtil<CrawlDbReducer>(new CrawlDbReducer(),conf);
  int retryMax=conf.getInt("db.fetch.retry.max",3);
  for (  String sched : schedules) {
    LOG.info("Testing state transitions with " + sched);
    conf.set("db.fetch.schedule.class","org.apache.nutch.crawl." + sched);
    FetchSchedule schedule=FetchScheduleFactory.getFetchSchedule(new JobConf(conf));
    for (int i=0; i < fetchDbStatusPairs.length; i++) {
      byte fromDbStatus=fetchDbStatusPairs[i][1];
      for (int j=0; j < fetchDbStatusPairs.length; j++) {
        byte fetchStatus=fetchDbStatusPairs[j][0];
        CrawlDatum fromDb=null;
        if (fromDbStatus == -1) {
        }
 else {
          fromDb=new CrawlDatum();
          fromDb.setStatus(fromDbStatus);
          schedule.initializeSchedule(CrawlDbUpdateUtil.dummyURL,fromDb);
        }
        byte toDbStatus=fetchDbStatusPairs[j][1];
        if (fetchStatus == -1) {
          if (fromDbStatus == -1) {
            toDbStatus=STATUS_DB_UNFETCHED;
          }
 else {
            toDbStatus=fromDbStatus;
          }
        }
 else         if (fetchStatus == STATUS_FETCH_RETRY) {
          if (fromDb == null || fromDb.getRetriesSinceFetch() < retryMax) {
            toDbStatus=STATUS_DB_UNFETCHED;
          }
 else {
            toDbStatus=STATUS_DB_GONE;
          }
        }
        String fromDbStatusName=(fromDbStatus == -1 ? "<not in CrawlDb>" : getStatusName(fromDbStatus));
        String fetchStatusName=(fetchStatus == -1 ? "<only inlinks>" : CrawlDatum.getStatusName(fetchStatus));
        LOG.info(fromDbStatusName + " + " + fetchStatusName+ " => "+ getStatusName(toDbStatus));
        List<CrawlDatum> values=new ArrayList<CrawlDatum>();
        for (int l=0; l <= 2; l++) {
          CrawlDatum fetch=null;
          if (fetchStatus == -1) {
            if (l == 0)             continue;
          }
 else {
            fetch=new CrawlDatum();
            if (fromDb != null) {
              fetch.set(fromDb);
            }
 else {
              schedule.initializeSchedule(CrawlDbUpdateUtil.dummyURL,fetch);
            }
            fetch.setStatus(fetchStatus);
            fetch.setFetchTime(System.currentTimeMillis());
          }
          if (fromDb != null)           values.add(fromDb);
          if (fetch != null)           values.add(fetch);
          for (int n=0; n < l; n++) {
            values.add(linked);
          }
          List<CrawlDatum> res=updateDb.update(values);
          if (res.size() != 1) {
            fail("CrawlDb update didn't result in one single CrawlDatum per URL");
            continue;
          }
          byte status=res.get(0).getStatus();
          if (status != toDbStatus) {
            fail("CrawlDb update for " + fromDbStatusName + " and "+ fetchStatusName+ " and "+ l+ " inlinks results in "+ getStatusName(status)+ " (expected: "+ getStatusName(toDbStatus)+ ")");
          }
          values.clear();
        }
      }
    }
  }
}

</code></pre>

<br>
<pre class="type-7 type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * NUTCH-1245: a fetch_gone should always result in a db_gone.
 * <p>
 * As some kind of misconfiguration set db.fetch.interval.default to a value
 * &gt; (fetchIntervalMax * 1.5).
 * </p>
 */
@Test public void testCrawlDbReducerPageGoneSchedule2(){
  LOG.info("NUTCH-1245 (misconfiguration): test with db.fetch.interval.default > (1.5 * db.fetch.interval.max)");
  Configuration conf=CrawlDBTestUtil.createConfiguration();
  int fetchIntervalMax=conf.getInt("db.fetch.interval.max",0);
  conf.setInt("db.fetch.interval.default",3 + (int)(fetchIntervalMax * 1.5));
  ContinuousCrawlTestUtil crawlUtil=new ContinuousCrawlTestUtil(conf,STATUS_FETCH_GONE,STATUS_DB_GONE);
  if (!crawlUtil.run(0)) {
    fail("fetch_gone did not result in a db_gone (NUTCH-1245)");
  }
}

</code></pre>

<br>
<pre class="type-7 type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * NUTCH-1245: a fetch_gone should always result in a db_gone.
 * <p>
 * Even in a long-running continuous crawl, when a gone page is re-fetched
 * several times over time.
 * </p>
 */
@Test public void testCrawlDbReducerPageGoneSchedule1(){
  LOG.info("NUTCH-1245: test long running continuous crawl");
  ContinuousCrawlTestUtil crawlUtil=new ContinuousCrawlTestUtil(STATUS_FETCH_GONE,STATUS_DB_GONE);
  if (!crawlUtil.run(20)) {
    fail("fetch_gone did not result in a db_gone (NUTCH-1245)");
  }
}

</code></pre>

<br>
<pre class="type-7 type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * Test status db_notmodified detected by
 * <ul>
 * <li>signature comparison</li>
 * <li>or HTTP 304</li>
 * </ul>
 * In addition, test for all available {@link FetchSchedule} implementations
 * whether
 * <ul>
 * <li>modified time is set</li>
 * <li>re-fetch is triggered after a certain time to force the fetched content
 * to be in a recent segment (old segments are deleted, see comments in{@link CrawlDbReducer#reduce(Text,Iterator,OutputCollector,Reporter)}</li>
 * </ul>
 */
@Test public void testCrawlDbReducerNotModified(){
  LOG.info("Test state notmodified");
  Configuration conf=CrawlDBTestUtil.createConfiguration();
  for (  String sched : schedules) {
    String desc="test notmodified by signature comparison + " + sched;
    LOG.info(desc);
    conf.set("db.fetch.schedule.class","org.apache.nutch.crawl." + sched);
    ContinuousCrawlTestUtil crawlUtil=new CrawlTestFetchNotModified(conf);
    if (!crawlUtil.run(20)) {
      fail("failed: " + desc);
    }
  }
  for (  String sched : schedules) {
    String desc="test notmodified by HTTP 304 + " + sched;
    LOG.info(desc);
    conf.set("db.fetch.schedule.class","org.apache.nutch.crawl." + sched);
    ContinuousCrawlTestUtil crawlUtil=new CrawlTestFetchNotModifiedHttp304(conf);
    if (!crawlUtil.run(20)) {
      fail("failed: " + desc);
    }
  }
}

</code></pre>

<br>
<pre class="type-7 type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * Test whether signatures are reset for "content-less" states (gone,
 * redirect, etc.): otherwise, if this state is temporary and the document
 * appears again with the old content, it may get marked as not_modified in
 * CrawlDb just after the redirect state. In this case we cannot expect
 * content in segments. Cf. NUTCH-1422: reset signature for redirects.
 */
@Test public void testSignatureReset(){
  LOG.info("NUTCH-1422 must reset signature for redirects and similar states");
  Configuration conf=CrawlDBTestUtil.createConfiguration();
  for (  String sched : schedules) {
    LOG.info("Testing reset signature with " + sched);
    conf.set("db.fetch.schedule.class","org.apache.nutch.crawl." + sched);
    ContinuousCrawlTestUtil crawlUtil=new CrawlTestSignatureReset(conf);
    if (!crawlUtil.run(20)) {
      fail("failed: signature not reset");
    }
  }
}

</code></pre>

<br>
<pre class="type-6 type-4 type-7 type-2 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions in iterations
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
"></span><br>
/** 
 * Test states after inject: inject must not modify the status of CrawlDatums
 * already in CrawlDb. Newly injected elements have status "db_unfetched".
 * Inject is simulated by calling {@link Injector.InjectReducer#reduce()}.
 */
@Test public void testCrawlDbStatTransitionInject(){
  LOG.info("Test CrawlDatum states in Injector after inject");
  Configuration conf=CrawlDBTestUtil.createConfiguration();
  CrawlDbUpdateUtil<Injector.InjectReducer> inject=new CrawlDbUpdateUtil<Injector.InjectReducer>(new Injector.InjectReducer(),conf);
  ScoringFilters scfilters=new ScoringFilters(conf);
  for (  String sched : schedules) {
    LOG.info("Testing inject with " + sched);
    conf.set("db.fetch.schedule.class","org.apache.nutch.crawl." + sched);
    FetchSchedule schedule=FetchScheduleFactory.getFetchSchedule(new JobConf(conf));
    List<CrawlDatum> values=new ArrayList<CrawlDatum>();
    for (int i=0; i < fetchDbStatusPairs.length; i++) {
      byte fromDbStatus=fetchDbStatusPairs[i][1];
      byte toDbStatus=fromDbStatus;
      if (fromDbStatus == -1) {
        toDbStatus=STATUS_DB_UNFETCHED;
      }
 else {
        CrawlDatum fromDb=new CrawlDatum();
        fromDb.setStatus(fromDbStatus);
        schedule.initializeSchedule(CrawlDbUpdateUtil.dummyURL,fromDb);
        values.add(fromDb);
      }
      LOG.info("inject " + (fromDbStatus == -1 ? "<not in CrawlDb>" : CrawlDatum.getStatusName(fromDbStatus)) + " + "+ getStatusName(STATUS_INJECTED)+ " => "+ getStatusName(toDbStatus));
      CrawlDatum injected=new CrawlDatum(STATUS_INJECTED,conf.getInt("db.fetch.interval.default",2592000),0.1f);
      schedule.initializeSchedule(CrawlDbUpdateUtil.dummyURL,injected);
      try {
        scfilters.injectedScore(CrawlDbUpdateUtil.dummyURL,injected);
      }
 catch (      ScoringFilterException e) {
        LOG.error(StringUtils.stringifyException(e));
      }
      values.add(injected);
      List<CrawlDatum> res=inject.update(values);
      if (res.size() != 1) {
        fail("Inject didn't result in one single CrawlDatum per URL");
        continue;
      }
      byte status=res.get(0).getStatus();
      if (status != toDbStatus) {
        fail("Inject for " + (fromDbStatus == -1 ? "" : getStatusName(fromDbStatus) + " and ") + getStatusName(STATUS_INJECTED)+ " results in "+ getStatusName(status)+ " (expected: "+ getStatusName(toDbStatus)+ ")");
      }
      values.clear();
    }
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.nutch.crawl.TestInjector </h4><pre class="type-7 type-12 type-1 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions inside branch conditions
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testInject() throws IOException {
  ArrayList<String> urls=new ArrayList<String>();
  ArrayList<String> metadata=new ArrayList<String>();
  for (int i=0; i < 100; i++) {
    urls.add("http://zzz.com/" + i + ".html");
    metadata.add("\tnutch.score=2." + i + "\tnutch.fetchInterval=171717\tkey=value");
  }
  CrawlDBTestUtil.generateSeedList(fs,urlPath,urls,metadata);
  Injector injector=new Injector(conf);
  injector.inject(crawldbPath,urlPath);
  List<String> read=readCrawldb();
  Collections.sort(read);
  Collections.sort(urls);
  Assert.assertEquals(urls.size(),read.size());
  Assert.assertTrue(read.containsAll(urls));
  Assert.assertTrue(urls.containsAll(read));
  ArrayList<String> urls2=new ArrayList<String>();
  for (int i=0; i < 100; i++) {
    urls2.add("http://xxx.com/" + i + ".html");
    urls2.add("http://zzz.com/" + i + ".html");
  }
  CrawlDBTestUtil.generateSeedList(fs,urlPath,urls2);
  injector=new Injector(conf);
  conf.setBoolean("db.injector.update",true);
  injector.inject(crawldbPath,urlPath);
  urls.addAll(urls2);
  read=readCrawldb();
  Collections.sort(read);
  Collections.sort(urls);
  Assert.assertEquals(urls.size() - 100,read.size());
  Assert.assertTrue(read.containsAll(urls));
  Assert.assertTrue(urls.containsAll(read));
  Map<String,CrawlDatum> records=readCrawldbRecords();
  Text writableKey=new Text("key");
  Text writableValue=new Text("value");
  for (  String url : urls) {
    if (url.indexOf("http://zzz") == 0) {
      Assert.assertTrue(records.get(url).getFetchInterval() == 171717);
      Assert.assertTrue(records.get(url).getScore() != 1.0);
      Assert.assertEquals(writableValue,records.get(url).getMetaData().get(writableKey));
    }
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.nutch.indexer.filter.MimeTypeIndexingFilterTest </h4><pre class="type-4 type-7 type-5 type-13 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies assertions inside branch conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
"></span><br>
@Test public void testAllowOnlyImages() throws Exception {
  conf.set(MimeTypeIndexingFilter.MIMEFILTER_REGEX_FILE,"allow-images.txt");
  filter.setConf(conf);
  for (int i=0; i < parses.length; i++) {
    NutchDocument doc=filter.filter(new NutchDocument(),parses[i],new Text("http://www.example.com/"),new CrawlDatum(),new Inlinks());
    if (MIME_TYPES[i].contains("image")) {
      Assert.assertNotNull("Allow only images",doc);
    }
 else {
      Assert.assertNull("Block everything else",doc);
    }
  }
}

</code></pre>

<br>
<pre class="type-4 type-7 type-5 type-13 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies assertions inside branch conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
"></span><br>
@Test public void testBlockHTML() throws Exception {
  conf.set(MimeTypeIndexingFilter.MIMEFILTER_REGEX_FILE,"block-html.txt");
  filter.setConf(conf);
  for (int i=0; i < parses.length; i++) {
    NutchDocument doc=filter.filter(new NutchDocument(),parses[i],new Text("http://www.example.com/"),new CrawlDatum(),new Inlinks());
    if (MIME_TYPES[i].contains("html")) {
      Assert.assertNull("Block only HTML documents",doc);
    }
 else {
      Assert.assertNotNull("Allow everything else",doc);
    }
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.nutch.net.TestURLNormalizers </h4><pre class="type-7 type-2 type-12 type-5 type-1 type-13 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testURLNormalizers(){
  Configuration conf=NutchConfiguration.create();
  String clazz1="org.apache.nutch.net.urlnormalizer.regex.RegexURLNormalizer";
  String clazz2="org.apache.nutch.net.urlnormalizer.basic.BasicURLNormalizer";
  conf.set("urlnormalizer.order",clazz1 + " " + clazz2);
  URLNormalizers normalizers=new URLNormalizers(conf,URLNormalizers.SCOPE_DEFAULT);
  Assert.assertNotNull(normalizers);
  try {
    normalizers.normalize("http://www.example.com/",URLNormalizers.SCOPE_DEFAULT);
  }
 catch (  MalformedURLException mue) {
    Assert.fail(mue.toString());
  }
  try {
    String normalizedSlashes=normalizers.normalize("http://www.example.com//path/to//somewhere.html",URLNormalizers.SCOPE_DEFAULT);
    Assert.assertEquals(normalizedSlashes,"http://www.example.com/path/to/somewhere.html");
  }
 catch (  MalformedURLException mue) {
    Assert.fail(mue.toString());
  }
  try {
    String normalizedHost=normalizers.normalize("http://www.example.org//path/to//somewhere.html",URLNormalizers.SCOPE_DEFAULT);
    Assert.assertEquals(normalizedHost,"http://www.example.org/path/to/somewhere.html");
  }
 catch (  MalformedURLException mue) {
    Assert.fail(mue.toString());
  }
  int pos1=-1, pos2=-1;
  URLNormalizer[] impls=normalizers.getURLNormalizers(URLNormalizers.SCOPE_DEFAULT);
  for (int i=0; i < impls.length; i++) {
    if (impls[i].getClass().getName().equals(clazz1))     pos1=i;
    if (impls[i].getClass().getName().equals(clazz2))     pos2=i;
  }
  if (pos1 != -1 && pos2 != -1) {
    Assert.assertTrue("RegexURLNormalizer before BasicURLNormalizer",pos1 < pos2);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.nutch.parse.feed.TestFeedParser </h4><pre class="type-6 type-4 type-7 type-2 type-5 type-1 type-13 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions in iterations
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Calls the {@link FeedParser} on a sample RSS file and checks that there are
 * 3 {@link ParseResult} entries including the below 2 links:
 * <ul>
 * <li>http://www-scf.usc.edu/~mattmann/</li>
 * <li>http://www.nutch.org</li>
 * </ul>
 * @throws ProtocolNotFoundIf the {@link Protocol}Layer cannot be loaded (required to fetch
 * the {@link Content} for the RSS file).
 * @throws ParseExceptionIf the {@link Parser}Layer cannot be loaded.
 */
@Test public void testParseFetchChannel() throws ProtocolNotFound, ParseException {
  String urlString;
  Protocol protocol;
  Content content;
  ParseResult parseResult;
  Configuration conf=NutchConfiguration.create();
  for (int i=0; i < sampleFiles.length; i++) {
    urlString="file:" + sampleDir + fileSeparator+ sampleFiles[i];
    urlString=urlString.replace('\\','/');
    protocol=new ProtocolFactory(conf).getProtocol(urlString);
    content=protocol.getProtocolOutput(new Text(urlString),new CrawlDatum()).getContent();
    parseResult=new ParseUtil(conf).parseByExtensionId("feed",content);
    Assert.assertEquals(3,parseResult.size());
    boolean hasLink1=false, hasLink2=false, hasLink3=false;
    for (Iterator<Map.Entry<Text,Parse>> j=parseResult.iterator(); j.hasNext(); ) {
      Map.Entry<Text,Parse> entry=j.next();
      if (entry.getKey().toString().equals("http://www-scf.usc.edu/~mattmann/")) {
        hasLink1=true;
      }
 else       if (entry.getKey().toString().equals("http://www.nutch.org/")) {
        hasLink2=true;
      }
 else       if (entry.getKey().toString().equals(urlString)) {
        hasLink3=true;
      }
      Assert.assertNotNull(entry.getValue());
      Assert.assertNotNull(entry.getValue().getData());
    }
    if (!hasLink1 || !hasLink2 || !hasLink3) {
      Assert.fail("Outlinks read from sample rss file are not correct!");
    }
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.nutch.parse.html.TestHtmlParser </h4><pre class="type-6 type-7 type-12 type-5 type-1 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions inside branch conditions
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testEncodingDetection(){
  for (  String[] testPage : encodingTestPages) {
    String name=testPage[0];
    Charset charset=Charset.forName(testPage[1]);
    byte[] contentBytes=testPage[2].getBytes(charset);
    Parse parse=parse(contentBytes);
    String text=parse.getText();
    String title=parse.getData().getTitle();
    String keywords=parse.getData().getMeta("keywords");
    LOG.info(name);
    LOG.info("title:\t" + title);
    LOG.info("keywords:\t" + keywords);
    LOG.info("text:\t" + text);
    Assert.assertEquals("Title not extracted properly (" + name + ")",encodingTestKeywords,title);
    for (    String keyword : encodingTestKeywords.split(",\\s*")) {
      Assert.assertTrue(keyword + " not found in text (" + name+ ")",text.contains(keyword));
    }
    if (keywords != null) {
      Assert.assertEquals("Keywords not extracted properly (" + name + ")",encodingTestKeywords,keywords);
    }
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.nutch.plugin.TestPluginSystem </h4><pre class="type-4 type-7 type-2 type-5 type-1 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * @throws PluginRuntimeException
 */
@Test public void testGetExtensionInstances() throws PluginRuntimeException {
  Extension[] extensions=repository.getExtensionPoint(getGetExtensionId()).getExtensions();
  Assert.assertEquals(extensions.length,fPluginCount);
  for (int i=0; i < extensions.length; i++) {
    Extension extension=extensions[i];
    Object object=extension.getExtensionInstance();
    if (!(object instanceof HelloWorldExtension))     Assert.fail(" object is not a instance of HelloWorldExtension");
    ((ITestExtension)object).testGetExtension("Bla ");
    String string=((ITestExtension)object).testGetExtension("Hello");
    Assert.assertEquals("Hello World",string);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.nutch.segment.TestSegmentMerger </h4><pre class="type-4 type-7 type-12 type-5 type-1 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies assertions inside branch conditions
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testLargeMerge() throws Exception {
  SegmentMerger merger=new SegmentMerger(conf);
  merger.merge(out,new Path[]{seg1,seg2},false,false,-1);
  FileStatus[] stats=fs.listStatus(out);
  Assert.assertEquals(1,stats.length);
  Path outSeg=stats[0].getPath();
  Text k=new Text();
  ParseText v=new ParseText();
  MapFile.Reader[] readers=MapFileOutputFormat.getReaders(fs,new Path(outSeg,ParseText.DIR_NAME),conf);
  int cnt1=0, cnt2=0;
  for (  MapFile.Reader r : readers) {
    while (r.next(k,v)) {
      String ks=k.toString();
      String vs=v.getText();
      if (ks.startsWith("seg1-")) {
        cnt1++;
        Assert.assertTrue(vs.startsWith("seg1 "));
      }
 else       if (ks.startsWith("seg2-")) {
        cnt2++;
        Assert.assertTrue(vs.startsWith("seg2 "));
      }
    }
    r.close();
  }
  Assert.assertEquals(countSeg1,cnt1);
  Assert.assertEquals(countSeg2,cnt2);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.nutch.tika.TestFeedParser </h4><pre class="type-4 type-7 type-2 type-12 type-5 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * <p>
 * The test method: tests out the following 2 asserts:
 * </p>
 * <ul>
 * <li>There are 3 outlinks read from the sample rss file</li>
 * <li>The 3 outlinks read are in fact the correct outlinks from the sample
 * file</li>
 * </ul>
 */
@Test public void testIt() throws ProtocolException, ParseException {
  String urlString;
  Protocol protocol;
  Content content;
  Parse parse;
  Configuration conf=NutchConfiguration.create();
  for (int i=0; i < sampleFiles.length; i++) {
    urlString="file:" + sampleDir + fileSeparator+ sampleFiles[i];
    protocol=new ProtocolFactory(conf).getProtocol(urlString);
    content=protocol.getProtocolOutput(new Text(urlString),new CrawlDatum()).getContent();
    parse=new ParseUtil(conf).parseByExtensionId("parse-tika",content).get(content.getUrl());
    ParseData theParseData=parse.getData();
    Outlink[] theOutlinks=theParseData.getOutlinks();
    Assert.assertTrue("There aren't 2 outlinks read!",theOutlinks.length == 2);
    boolean hasLink1=false, hasLink2=false;
    for (int j=0; j < theOutlinks.length; j++) {
      if (theOutlinks[j].getToUrl().equals("http://www-scf.usc.edu/~mattmann/")) {
        hasLink1=true;
      }
      if (theOutlinks[j].getToUrl().equals("http://www.nutch.org/")) {
        hasLink2=true;
      }
    }
    if (!hasLink1 || !hasLink2) {
      Assert.fail("Outlinks read from sample rss file are not correct!");
    }
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.nutch.util.TestPrefixStringMatcher </h4><pre class="type-6 type-4 type-7 type-12 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions in iterations
- Verifies assertions inside branch conditions
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
"></span><br>
@Test public void testPrefixMatcher(){
  int numMatches=0;
  int numInputsTested=0;
  for (int round=0; round < NUM_TEST_ROUNDS; round++) {
    int numPrefixes=(int)(Math.random() * MAX_TEST_PREFIXES);
    String[] prefixes=new String[numPrefixes];
    for (int i=0; i < numPrefixes; i++) {
      prefixes[i]=makeRandString(0,MAX_PREFIX_LEN);
    }
    PrefixStringMatcher prematcher=new PrefixStringMatcher(prefixes);
    for (int i=0; i < NUM_TEST_INPUTS_PER_ROUND; i++) {
      String input=makeRandString(0,MAX_INPUT_LEN);
      boolean matches=false;
      int longestMatch=-1;
      int shortestMatch=-1;
      for (int j=0; j < prefixes.length; j++) {
        if ((prefixes[j].length() > 0) && input.startsWith(prefixes[j])) {
          matches=true;
          int matchSize=prefixes[j].length();
          if (matchSize > longestMatch)           longestMatch=matchSize;
          if ((matchSize < shortestMatch) || (shortestMatch == -1))           shortestMatch=matchSize;
        }
      }
      if (matches)       numMatches++;
      numInputsTested++;
      Assert.assertTrue("'" + input + "' should "+ (matches ? "" : "not ")+ "match!",matches == prematcher.matches(input));
      if (matches) {
        Assert.assertTrue(shortestMatch == prematcher.shortestMatch(input).length());
        Assert.assertTrue(input.substring(0,shortestMatch).equals(prematcher.shortestMatch(input)));
        Assert.assertTrue(longestMatch == prematcher.longestMatch(input).length());
        Assert.assertTrue(input.substring(0,longestMatch).equals(prematcher.longestMatch(input)));
      }
    }
  }
  System.out.println("got " + numMatches + " matches out of "+ numInputsTested+ " tests");
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.nutch.util.TestSuffixStringMatcher </h4><pre class="type-6 type-4 type-7 type-12 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions in iterations
- Verifies assertions inside branch conditions
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
"></span><br>
@Test public void testSuffixMatcher(){
  int numMatches=0;
  int numInputsTested=0;
  for (int round=0; round < NUM_TEST_ROUNDS; round++) {
    int numSuffixes=(int)(Math.random() * MAX_TEST_SUFFIXES);
    String[] suffixes=new String[numSuffixes];
    for (int i=0; i < numSuffixes; i++) {
      suffixes[i]=makeRandString(0,MAX_SUFFIX_LEN);
    }
    SuffixStringMatcher sufmatcher=new SuffixStringMatcher(suffixes);
    for (int i=0; i < NUM_TEST_INPUTS_PER_ROUND; i++) {
      String input=makeRandString(0,MAX_INPUT_LEN);
      boolean matches=false;
      int longestMatch=-1;
      int shortestMatch=-1;
      for (int j=0; j < suffixes.length; j++) {
        if ((suffixes[j].length() > 0) && input.endsWith(suffixes[j])) {
          matches=true;
          int matchSize=suffixes[j].length();
          if (matchSize > longestMatch)           longestMatch=matchSize;
          if ((matchSize < shortestMatch) || (shortestMatch == -1))           shortestMatch=matchSize;
        }
      }
      if (matches)       numMatches++;
      numInputsTested++;
      Assert.assertTrue("'" + input + "' should "+ (matches ? "" : "not ")+ "match!",matches == sufmatcher.matches(input));
      if (matches) {
        Assert.assertTrue(shortestMatch == sufmatcher.shortestMatch(input).length());
        Assert.assertTrue(input.substring(input.length() - shortestMatch).equals(sufmatcher.shortestMatch(input)));
        Assert.assertTrue(longestMatch == sufmatcher.longestMatch(input).length());
        Assert.assertTrue(input.substring(input.length() - longestMatch).equals(sufmatcher.longestMatch(input)));
      }
    }
  }
  System.out.println("got " + numMatches + " matches out of "+ numInputsTested+ " tests");
}

</code></pre>

<br>
<script>$(document).ready(function() {
  $('pre code').each(function(i, block) {
    hljs.highlightBlock(block);
  });
});</script>
