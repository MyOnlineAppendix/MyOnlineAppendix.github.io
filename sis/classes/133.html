<h3 style="margin:0px">Class: org.apache.sis.io.wkt.GeodeticObjectParserTest (18 methods) </h3><br><pre style="padding:0"><code class="html"><div id="tags"><button id="1"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('1')" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value "><kbd id="tag-1"class="label-info"style="display: inline-block;font-size:7pt" >EqualityVerifier&nbsp;(14)</kbd></button>&nbsp;<button id="3"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('3')" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls"><kbd id="tag-3"class="label-info"style="display: inline-block;font-size:7pt" >InternalCallVerifier&nbsp;(14)</kbd></button>&nbsp;<button id="5"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('5')" data-toggle="tooltip" title="Executes methods or other tests from the same test unit"><kbd id="tag-5"class="label-info"style="display: inline-block;font-size:7pt" >ExecutionTester&nbsp;(4)</kbd></button>&nbsp;<button id="9"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('9')" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) "><kbd id="tag-9"class="label-info"style="display: inline-block;font-size:7pt" >APIUtilityVerifier&nbsp;(4)</kbd></button>&nbsp;<button id="7"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('7')" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes"><kbd id="tag-7"class="label-info"style="display: inline-block;font-size:7pt" >HybridVerifier&nbsp;(2)</kbd></button>&nbsp;<button id="4"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('4')" data-toggle="tooltip" title="Verifies boolean conditions"><kbd id="tag-4"class="label-info"style="display: inline-block;font-size:7pt" >BooleanVerifier&nbsp;(2)</kbd></button>&nbsp;<button id="8"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('8')" data-toggle="tooltip" title="Verifies whether objects are null"><kbd id="tag-8"class="label-info"style="display: inline-block;font-size:7pt" >NullVerifier&nbsp;(1)</kbd></button>&nbsp;</div></code></pre><center><button onclick="showBlocks()" style="margin:6px">Update filter <span class="glyphicon glyphicon-refresh" aria-hidden="true"></span> </button></center><br>
<pre class="type-3 type-1 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
"></span><br>
/** 
 * Tests parsing geographic CRS with implicit axes in seconds instead of degrees.
 * @throws ParseException if the parsing failed.
 * @see #testGeographicWithImplicitAxes()
 */
@Test @DependsOnMethod("testGeographicWithImplicitAxes") public void testGeographicWithImplicitAxesInSeconds() throws ParseException {
  final GeographicCRS crs=parse(GeographicCRS.class,"GEOGCS[“NAD83 / NFIS Seconds”," + "DATUM[“North_American_Datum_1983”,\n" + "SPHEROID[“GRS 1980”, 6378137, 298.257222101]],\n"+ "PRIMEM[“Greenwich”, 0],\n"+ "UNIT[“Decimal_Second”, 4.84813681109536e-06],\n"+ "AUTHORITY[“EPSG”, “100001”]]");
  assertNameAndIdentifierEqual("NAD83 / NFIS Seconds",100001,crs);
  final GeodeticDatum datum=crs.getDatum();
  assertNameAndIdentifierEqual("North_American_Datum_1983",0,datum);
  assertNameAndIdentifierEqual("Greenwich",0,datum.getPrimeMeridian());
  final Ellipsoid ellipsoid=datum.getEllipsoid();
  assertNameAndIdentifierEqual("GRS 1980",0,ellipsoid);
  assertEquals("semiMajor",6378137,ellipsoid.getSemiMajorAxis(),STRICT);
  assertEquals("inverseFlattening",298.257222101,ellipsoid.getInverseFlattening(),STRICT);
  final EllipsoidalCS cs=crs.getCoordinateSystem();
  final double secondsIn90=90 * 60 * 60;
  CoordinateSystemAxis axis=cs.getAxis(0);
  assertEquals("name",AxisNames.GEODETIC_LONGITUDE,axis.getName().getCode());
  assertEquals("abbreviation","λ",axis.getAbbreviation());
  assertEquals("direction",AxisDirection.EAST,axis.getDirection());
  assertEquals("minimumValue",-secondsIn90 * 2,axis.getMinimumValue(),1E-9);
  assertEquals("maximumValue",+secondsIn90 * 2,axis.getMaximumValue(),1E-9);
  axis=cs.getAxis(1);
  assertEquals("name",AxisNames.GEODETIC_LATITUDE,axis.getName().getCode());
  assertEquals("abbreviation","φ",axis.getAbbreviation());
  assertEquals("direction",AxisDirection.NORTH,axis.getDirection());
  assertEquals("minimumValue",-secondsIn90,axis.getMinimumValue(),1E-9);
  assertEquals("maximumValue",+secondsIn90,axis.getMaximumValue(),1E-9);
}

</code></pre>

<pre class="type-3 type-1 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
"></span><br>
/** 
 * Tests parsing a WKT with a missing Geographic CRS name.
 * This should be considered invalid, but happen in practice.
 * <p>The WKT tested in this method contains also some other oddities compared to the usual WKT:</p>
 * <ul>
 * <li>The prime meridian is declared in the {@code "central_meridian"} projection parameter instead
 * than in the {@code PRIMEM[…]} element.</li>
 * <li>Some elements are not in the usual order.</li>
 * </ul>
 * @throws ParseException if the parsing failed.
 */
@Test @DependsOnMethod("testProjectedCRS") public void testProjectedWithMissingName() throws ParseException {
  final ProjectedCRS crs=parse(ProjectedCRS.class,"PROJCS[“FRANCE/NTF/Lambert III”," + "GEOGCS[“”," + "DATUM[“NTF=GR3DF97A”,TOWGS84[-168, -60, 320] ,"+ "SPHEROID[“Clarke 1880 (IGN)”,6378249.2,293.4660212936269]],"+ "PRIMEM[“Greenwich”,0],UNIT[“Degrees”,0.0174532925199433],"+ "AXIS[“Long”,East],AXIS[“Lat”,North]],"+ "PROJECTION[“Lambert_Conformal_Conic_1SP”],"+ "PARAMETER[“latitude_of_origin”,44.1],"+ "PARAMETER[“central_meridian”,2.33722917],"+ "PARAMETER[“scale_factor”,0.999877499],"+ "PARAMETER[“false_easting”,600000],"+ "PARAMETER[“false_northing”,200000],"+ "UNIT[“Meter”,1],"+ "AXIS[“Easting”,East],AXIS[“Northing”,North]]");
  assertNameAndIdentifierEqual("FRANCE/NTF/Lambert III",0,crs);
  verifyProjectedCS(crs.getCoordinateSystem(),SI.METRE);
  final GeographicCRS geoCRS=crs.getBaseCRS();
  assertNameAndIdentifierEqual("NTF=GR3DF97A",0,geoCRS);
  final GeodeticDatum datum=geoCRS.getDatum();
  assertNameAndIdentifierEqual("NTF=GR3DF97A",0,datum);
  assertNameAndIdentifierEqual("Greenwich",0,datum.getPrimeMeridian());
  assertArrayEquals("BursaWolfParameters",new double[]{-168,-60,320},((DefaultGeodeticDatum)datum).getBursaWolfParameters()[0].getValues(),STRICT);
  final Ellipsoid ellipsoid=datum.getEllipsoid();
  assertNameAndIdentifierEqual("Clarke 1880 (IGN)",0,ellipsoid);
  assertEquals("semiMajor",6378249.2,ellipsoid.getSemiMajorAxis(),STRICT);
  assertEquals("inverseFlattening",293.4660212936269,ellipsoid.getInverseFlattening(),STRICT);
  final EllipsoidalCS cs=geoCRS.getCoordinateSystem();
  assertEquals("dimension",2,cs.getDimension());
  assertLongitudeAxisEquals(cs.getAxis(0));
  assertLatitudeAxisEquals(cs.getAxis(1));
  final ParameterValueGroup param=crs.getConversionFromBase().getParameterValues();
  assertEquals("Lambert Conic Conformal (1SP)",param.getDescriptor().getName().getCode());
  assertEquals("semi_major",6378249.2,param.parameter("semi_major").doubleValue(SI.METRE),STRICT);
  assertEquals("semi_minor",6356515.0,param.parameter("semi_minor").doubleValue(SI.METRE),1E-12);
  assertEquals("latitude_of_origin",44.1,param.parameter("latitude_of_origin").doubleValue(NonSI.DEGREE_ANGLE),STRICT);
  assertEquals("central_meridian",2.33722917,param.parameter("central_meridian").doubleValue(NonSI.DEGREE_ANGLE),STRICT);
  assertEquals("scale_factor",0.999877499,param.parameter("scale_factor").doubleValue(Unit.ONE),STRICT);
  assertEquals("false_easting",600000.0,param.parameter("false_easting").doubleValue(SI.METRE),STRICT);
  assertEquals("false_northing",200000.0,param.parameter("false_northing").doubleValue(SI.METRE),STRICT);
}

</code></pre>

<pre class="type-3 type-1 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
"></span><br>
/** 
 * Tests the parsing of an axis.
 * @throws ParseException if the parsing failed.
 */
@Test public void testAxis() throws ParseException {
  CoordinateSystemAxis axis=parse(CoordinateSystemAxis.class,"AXIS[“(Y)”, geocentricY]");
  assertEquals("name","Y",axis.getName().getCode());
  assertEquals("abbreviation","Y",axis.getAbbreviation());
  assertEquals("direction",AxisDirection.GEOCENTRIC_Y,axis.getDirection());
  assertEquals("unit",SI.METRE,axis.getUnit());
  axis=parse(CoordinateSystemAxis.class,"AXIS[“latitude”,north,ORDER[1],ANGLEUNIT[“degree”,0.0174532925199433]]");
  assertEquals("name","Latitude",axis.getName().getCode());
  assertEquals("abbreviation","φ",axis.getAbbreviation());
  assertEquals("direction",AxisDirection.NORTH,axis.getDirection());
  assertEquals("unit",NonSI.DEGREE_ANGLE,axis.getUnit());
  axis=parse(CoordinateSystemAxis.class,"AXIS[“longitude”,EAST,order[2],UNIT[“degree”,0.0174532925199433]]");
  assertEquals("name","Longitude",axis.getName().getCode());
  assertEquals("abbreviation","λ",axis.getAbbreviation());
  assertEquals("direction",AxisDirection.EAST,axis.getDirection());
  assertEquals("unit",NonSI.DEGREE_ANGLE,axis.getUnit());
  axis=parse(CoordinateSystemAxis.class,"AXIS[“ellipsoidal height (h)”,up,ORDER[3],LengthUnit[“kilometre”,1000]]");
  assertEquals("name","Ellipsoidal height",axis.getName().getCode());
  assertEquals("abbreviation","h",axis.getAbbreviation());
  assertEquals("direction",AxisDirection.UP,axis.getDirection());
  assertEquals("unit",SI.KILOMETRE,axis.getUnit());
  axis=parse(CoordinateSystemAxis.class,"AXIS[“time (t)”,future,TimeUnit[“hour”,3600]]");
  assertEquals("name","Time",axis.getName().getCode());
  assertEquals("abbreviation","t",axis.getAbbreviation());
  assertEquals("direction",AxisDirection.FUTURE,axis.getDirection());
  assertEquals("unit",NonSI.HOUR,axis.getUnit());
  axis=parse(CoordinateSystemAxis.class,"AXIS[“easting (X)”,south,MERIDIAN[90,UNIT[“degree”,0.0174532925199433]]]");
  assertEquals("name","Easting",axis.getName().getCode());
  assertEquals("abbreviation","X",axis.getAbbreviation());
  assertEquals("direction",CoordinateSystems.directionAlongMeridian(AxisDirection.SOUTH,90),axis.getDirection());
  assertEquals("unit",SI.METRE,axis.getUnit());
}

</code></pre>

<pre class="type-3 type-1 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
"></span><br>
/** 
 * Tests the parsing of a projected CRS from a WKT 1 string.
 * @throws ParseException if the parsing failed.
 */
@Test @DependsOnMethod("testGeographicCRS") public void testProjectedCRS() throws ParseException {
  final ProjectedCRS crs=parse(ProjectedCRS.class,"PROJCS[“Mercator test”,\n" + "  GEOGCS[“WGS 84”,\n" + "    DATUM[“World Geodetic System 1984”,\n"+ "      SPHEROID[“WGS84”, 6378137.0, 298.257223563]],\n"+ "      PRIMEM[“Greenwich”, 0.0],\n"+ "    UNIT[“degree”, 0.017453292519943295],\n"+ "    AXIS[“Longitude”, EAST],\n"+ "    AXIS[“Latitude”, NORTH]],\n"+ "  PROJECTION[“Mercator_1SP”],\n"+ "  PARAMETER[“central_meridian”, -20.0],\n"+ "  PARAMETER[“scale_factor”, 1.0],\n"+ "  PARAMETER[“false_easting”, 500000.0],\n"+ "  PARAMETER[“false_northing”, 0.0],\n"+ "  UNIT[“metre”, 1.0],\n"+ "  AXIS[“Easting”, EAST],\n"+ "  AXIS[“Northing”, NORTH]]");
  assertNameAndIdentifierEqual("Mercator test",0,crs);
  verifyProjectedCS(crs.getCoordinateSystem(),SI.METRE);
  verifyGeographicCRS(0,crs.getBaseCRS());
  final GeodeticDatum datum=crs.getDatum();
  assertNameAndIdentifierEqual("World Geodetic System 1984",0,datum);
  assertNameAndIdentifierEqual("Greenwich",0,datum.getPrimeMeridian());
  final Ellipsoid ellipsoid=datum.getEllipsoid();
  assertNameAndIdentifierEqual("WGS84",0,ellipsoid);
  assertEquals("semiMajor",6378137,ellipsoid.getSemiMajorAxis(),STRICT);
  assertEquals("inverseFlattening",298.257223563,ellipsoid.getInverseFlattening(),STRICT);
  assertEquals("Mercator (variant A)",crs.getConversionFromBase().getMethod().getName().getCode());
  final ParameterValueGroup param=crs.getConversionFromBase().getParameterValues();
  assertEquals("semi_major",6378137.0,param.parameter("semi_major").doubleValue(SI.METRE),STRICT);
  assertEquals("semi_minor",6356752.3,param.parameter("semi_minor").doubleValue(SI.METRE),0.1);
  assertEquals("central_meridian",-20.0,param.parameter("central_meridian").doubleValue(NonSI.DEGREE_ANGLE),STRICT);
  assertEquals("scale_factor",1.0,param.parameter("scale_factor").doubleValue(Unit.ONE),STRICT);
  assertEquals("false_easting",500000.0,param.parameter("false_easting").doubleValue(SI.METRE),STRICT);
  assertEquals("false_northing",0.0,param.parameter("false_northing").doubleValue(SI.METRE),STRICT);
}

</code></pre>

<pre class="type-3 type-1 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
"></span><br>
/** 
 * Tests the parsing of a projected CRS from a WKT 1 string with authority and Bursa-Wolf parameters.
 * @throws ParseException if the parsing failed.
 */
@Test @DependsOnMethod("testProjectedCRS") public void testProjectedWithID() throws ParseException {
  final ProjectedCRS crs=parse(ProjectedCRS.class,"PROJCS[“OSGB 1936 / British National Grid”,\n" + "  GEOGCS[“OSGB 1936”,\n" + "    DATUM[“OSGB_1936”,\n"+ "      SPHEROID[“Airy 1830”, 6377563.396, 299.3249646, AUTHORITY[“EPSG”, “7001”]],\n"+ "      TOWGS84[375.0, -111.0, 431.0, 0.0, 0.0, 0.0, 0.0],\n"+ "      AUTHORITY[“EPSG”, “6277”]],\n"+ "      PRIMEM[“Greenwich”,0.0, AUTHORITY[“EPSG”, “8901”]],\n"+ "    UNIT[“DMSH”,0.0174532925199433],\n"+ "    AXIS[“Lat”,NORTH],AXIS[“Long”,EAST], AUTHORITY[“EPSG”, “4277”]],\n"+ "  PROJECTION[“Transverse_Mercator”],\n"+ "  PARAMETER[“latitude_of_origin”, 49.0],\n"+ "  PARAMETER[“central_meridian”, -2.0],\n"+ "  PARAMETER[“scale_factor”, 0.999601272],\n"+ "  PARAMETER[“false_easting”, 400000.0],\n"+ "  PARAMETER[“false_northing”, -100000.0],\n"+ "  UNIT[“metre”, 1.0, AUTHORITY[“EPSG”, “9001”]],\n"+ "  AXIS[“E”,EAST],\n"+ "  AXIS[“N”,NORTH],\n"+ "  AUTHORITY[“EPSG”, “27700”]]");
  assertNameAndIdentifierEqual("OSGB 1936 / British National Grid",27700,crs);
  assertNameAndIdentifierEqual("OSGB 1936",4277,crs.getBaseCRS());
  assertNameAndIdentifierEqual("OSGB_1936",6277,crs.getDatum());
  verifyProjectedCS(crs.getCoordinateSystem(),SI.METRE);
  final ParameterValueGroup param=crs.getConversionFromBase().getParameterValues();
  assertEquals("Transverse Mercator",crs.getConversionFromBase().getMethod().getName().getCode());
  assertEquals("semi_major",6377563.396,param.parameter("semi_major").doubleValue(),1E-4);
  assertEquals("semi_minor",6356256.909,param.parameter("semi_minor").doubleValue(),1E-3);
  assertEquals("latitude_of_origin",49.0,param.parameter("latitude_of_origin").doubleValue(),1E-8);
  assertEquals("central_meridian",-2.0,param.parameter("central_meridian").doubleValue(),1E-8);
  assertEquals("scale_factor",0.9996,param.parameter("scale_factor").doubleValue(),1E-5);
  assertEquals("false_easting",400000.0,param.parameter("false_easting").doubleValue(),1E-4);
  assertEquals("false_northing",-100000.0,param.parameter("false_northing").doubleValue(),1E-4);
  final BursaWolfParameters[] bwp=((DefaultGeodeticDatum)crs.getDatum()).getBursaWolfParameters();
  assertEquals("BursaWolfParameters",1,bwp.length);
  assertArrayEquals("BursaWolfParameters",new double[]{375,-111,431},bwp[0].getValues(),STRICT);
}

</code></pre>

<pre class="type-9 type-3 type-1 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
"></span><br>
/** 
 * Tests the parsing of a projected CRS using angular values in grades instead than degrees
 * and in lengths in kilometres instead than metres.
 * @throws ParseException if the parsing failed.
 */
@Test @DependsOnMethod({"testGeographicWithParisMeridian","testProjectedCRS"}) public void testProjectedWithGradUnits() throws ParseException {
  String wkt="PROJCS[“NTF (Paris) / Lambert zone II”," + "  GEOGCS[“NTF (Paris)”," + "    DATUM[“Nouvelle Triangulation Française (Paris)”,"+ "      SPHEROID[“Clarke 1880 (IGN)”, 6378249.2, 293.4660212936269],"+ "      TOWGS84[-168,-60,320,0,0,0,0]],"+ "    PRIMEM[“Paris”, 2.5969213, AUTHORITY[“EPSG”, “8903”]],"+ "    UNIT[“grad”, 0.01570796326794897]],"+ "  PROJECTION[“Lambert Conformal Conic (1SP)”],"+ "  PARAMETER[“latitude_of_origin”, 52.0],"+ "  PARAMETER[“scale_factor”, 0.99987742],"+ "  PARAMETER[“false_easting”, 600.0],"+ "  PARAMETER[“false_northing”, 2200.0],"+ "  UNIT[“metre”,1000]]";
  ProjectedCRS crs=parse(ProjectedCRS.class,wkt);
  assertNameAndIdentifierEqual("NTF (Paris) / Lambert zone II",0,crs);
  verifyProjectedCS(crs.getCoordinateSystem(),SI.KILOMETRE);
  PrimeMeridian pm=verifyNTF(crs.getDatum(),true);
  assertEquals("angularUnit",NonSI.GRADE,pm.getAngularUnit());
  assertEquals("greenwichLongitude",2.5969213,pm.getGreenwichLongitude(),STRICT);
  ParameterValue<?> param=verifyNTF(crs.getConversionFromBase().getParameterValues());
  assertEquals("angularUnit",NonSI.GRADE,param.getUnit());
  assertEquals("latitude_of_origin",52.0,param.doubleValue(),STRICT);
  wkt=wkt.replace("2.5969213","2.33722917");
  wkt=wkt.replace("52.0","46.8");
  wkt=wkt.replace("600.0","600000");
  wkt=wkt.replace("2200.0","2200000");
  newParser(Convention.WKT1_IGNORE_AXES);
  crs=parse(ProjectedCRS.class,wkt);
  assertNameAndIdentifierEqual("NTF (Paris) / Lambert zone II",0,crs);
  verifyProjectedCS(crs.getCoordinateSystem(),SI.KILOMETRE);
  pm=verifyNTF(crs.getDatum(),true);
  assertEquals("angularUnit",NonSI.DEGREE_ANGLE,pm.getAngularUnit());
  assertEquals("greenwichLongitude",2.33722917,pm.getGreenwichLongitude(),STRICT);
  param=verifyNTF(crs.getConversionFromBase().getParameterValues());
  assertEquals("angularUnit",NonSI.DEGREE_ANGLE,param.getUnit());
  assertEquals("latitude_of_origin",46.8,param.doubleValue(),STRICT);
}

</code></pre>

<pre class="type-3 type-1 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
"></span><br>
/** 
 * Tests the parsing of an engineering CRS from a WKT 2 string.
 * @throws ParseException if the parsing failed.
 */
@Test public void testEngineeringCRS() throws ParseException {
  final EngineeringCRS crs=parse(EngineeringCRS.class,"EngineeringCRS[“A building-centred CRS”,\n" + "  EngineeringDatum[“Building reference point”],\n" + "  CS[Cartesian, 3],\n"+ "    Axis[“x”, east],\n"+ "    Axis[“y”, north],\n"+ "    Axis[“z”, up],\n"+ "    Unit[“metre”, 1]]");
  assertNameAndIdentifierEqual("A building-centred CRS",0,crs);
  assertNameAndIdentifierEqual("Building reference point",0,crs.getDatum());
  final CoordinateSystem cs=crs.getCoordinateSystem();
  assertEquals("dimension",3,cs.getDimension());
  assertUnboundedAxisEquals("Easting","x",AxisDirection.EAST,SI.METRE,cs.getAxis(0));
  assertUnboundedAxisEquals("Northing","y",AxisDirection.NORTH,SI.METRE,cs.getAxis(1));
  assertUnboundedAxisEquals("z","z",AxisDirection.UP,SI.METRE,cs.getAxis(2));
}

</code></pre>

<pre class="type-3 type-4 type-1 type-8 type-7 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Tests the production of a warning messages when the WKT contains unknown elements.
 * @throws ParseException if the parsing failed.
 */
@Test @DependsOnMethod("testGeographicWithImplicitAxes") public void testWarnings() throws ParseException {
  newParser(Convention.DEFAULT);
  final ParsePosition position=new ParsePosition(0);
  final GeographicCRS crs=(GeographicCRS)parser.parseObject("GEOGCS[“WGS 84”,\n" + "  DATUM[“World Geodetic System 1984”,\n" + "    SPHEROID[“WGS84”, 6378137.0, 298.257223563, Ext1[“foo”], Ext2[“bla”]]],\n"+ "    PRIMEM[“Greenwich”, 0.0, Intruder[“unknown”]],\n"+ "  UNIT[“degree”, 0.017453292519943295], Intruder[“foo”]]",position);
  verifyGeographicCRS(0,crs);
  assertEquals("errorIndex",-1,position.getErrorIndex());
  final Warnings warnings=parser.getAndClearWarnings(crs);
  assertNotNull("warnings",warnings);
  assertTrue("warnings.getExceptions()",warnings.getExceptions().isEmpty());
  assertEquals("warnings.getRootElement()","WGS 84",warnings.getRootElement());
  assertArrayEquals("warnings.getUnknownElements()",new String[]{"Intruder","Ext1","Ext2"},warnings.getUnknownElements().toArray());
  assertArrayEquals("warnings.getUnknownElementLocations(…)",new String[]{"PRIMEM","GEOGCS"},warnings.getUnknownElementLocations("Intruder").toArray());
  assertArrayEquals("warnings.getUnknownElementLocations(…)",new String[]{"SPHEROID"},warnings.getUnknownElementLocations("Ext1").toArray());
  assertArrayEquals("warnings.getUnknownElementLocations(…)",new String[]{"SPHEROID"},warnings.getUnknownElementLocations("Ext2").toArray());
  assertMultilinesEquals("Parsing of “WGS 84” done, but some elements were ignored.\n" + " • The text contains unknown elements:\n" + "    ‣ “Intruder” in PRIMEM, GEOGCS.\n"+ "    ‣ “Ext1” in SPHEROID.\n"+ "    ‣ “Ext2” in SPHEROID.",warnings.toString(Locale.US));
  assertMultilinesEquals("La lecture de « WGS 84 » a été faite, mais en ignorant certains éléments.\n" + " • Le texte contient des éléments inconnus :\n" + "    ‣ « Intruder » dans PRIMEM, GEOGCS.\n"+ "    ‣ « Ext1 » dans SPHEROID.\n"+ "    ‣ « Ext2 » dans SPHEROID.",warnings.toString(Locale.FRANCE));
}

</code></pre>

<pre class="type-9 type-3 type-1 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
"></span><br>
/** 
 * Tests parsing of a CRS using a prime meridian other than Greenwich. The result depends on whether
 * the parsing is standard compliant or if the parsing use {@link Convention#WKT1_COMMON_UNITS}.
 * @throws ParseException if the parsing failed.
 */
@Test @DependsOnMethod("testGeographicCRS") public void testGeographicWithParisMeridian() throws ParseException {
  String wkt="GEOGCS[“NTF (Paris)”,\n" + "  DATUM[“Nouvelle Triangulation Française (Paris)”,\n" + "    SPHEROID[“Clarke 1880 (IGN)”, 6378249.2, 293.4660212936269]],\n"+ "    PRIMEM[“Paris”, 2.5969213, AUTHORITY[“EPSG”, “8903”]],\n"+ "  UNIT[“grade”, 0.015707963267948967],\n"+ "  AXIS[“Latitude”, NORTH],\n"+ "  AXIS[“Longitude”, EAST]]";
  GeographicCRS crs=parse(GeographicCRS.class,wkt);
  assertNameAndIdentifierEqual("NTF (Paris)",0,crs);
  PrimeMeridian pm=verifyNTF(crs.getDatum(),false);
  assertEquals("angularUnit",NonSI.GRADE,pm.getAngularUnit());
  assertEquals("greenwichLongitude",2.5969213,pm.getGreenwichLongitude(),STRICT);
  EllipsoidalCS cs=crs.getCoordinateSystem();
  assertEquals("dimension",2,cs.getDimension());
  assertAxisEquals(AxisNames.GEODETIC_LATITUDE,"φ",AxisDirection.NORTH,-100,+100,NonSI.GRADE,RangeMeaning.EXACT,cs.getAxis(0));
  assertAxisEquals(AxisNames.GEODETIC_LONGITUDE,"λ",AxisDirection.EAST,-200,+200,NonSI.GRADE,RangeMeaning.WRAPAROUND,cs.getAxis(1));
  wkt=wkt.replace("2.5969213","2.33722917");
  newParser(Convention.WKT1_IGNORE_AXES);
  crs=parse(GeographicCRS.class,wkt);
  assertNameAndIdentifierEqual("NTF (Paris)",0,crs);
  pm=verifyNTF(crs.getDatum(),false);
  assertEquals("angularUnit",NonSI.DEGREE_ANGLE,pm.getAngularUnit());
  assertEquals("greenwichLongitude",2.33722917,pm.getGreenwichLongitude(),STRICT);
  cs=crs.getCoordinateSystem();
  assertEquals("dimension",2,cs.getDimension());
  assertAxisEquals(AxisNames.GEODETIC_LONGITUDE,"λ",AxisDirection.EAST,-200,+200,NonSI.GRADE,RangeMeaning.WRAPAROUND,cs.getAxis(0));
  assertAxisEquals(AxisNames.GEODETIC_LATITUDE,"φ",AxisDirection.NORTH,-100,+100,NonSI.GRADE,RangeMeaning.EXACT,cs.getAxis(1));
}

</code></pre>

<pre class="type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Tests the parsing of a geographic CRS from a WKT 1 string using (latitude, longitude) axis order.
 * @throws ParseException if the parsing failed.
 */
@Test @DependsOnMethod("testGeographicCRS") public void testGeographicWithLatLonAxes() throws ParseException {
  verifyGeographicCRS(1,parse(GeographicCRS.class,"GEOGCS[“WGS 84”,\n" + "  DATUM[“World Geodetic System 1984”,\n" + "    SPHEROID[“WGS84”, 6378137.0, 298.257223563]],\n"+ "    PRIMEM[“Greenwich”, 0.0],\n"+ "  UNIT[“degree”, 0.017453292519943295],\n"+ "  AXIS[“Latitude”, NORTH],\n"+ "  AXIS[“Longitude”, EAST]]"));
}

</code></pre>

<pre class="type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Tests the parsing of a geographic CRS from a WKT 1 string that does not declare explicitly the axes.
 * @throws ParseException if the parsing failed.
 * @see #testGeographicWithImplicitAxesInSeconds()
 */
@Test @DependsOnMethod("testGeographicCRS") public void testGeographicWithImplicitAxes() throws ParseException {
  verifyGeographicCRS(0,parse(GeographicCRS.class,"GEOGCS[“WGS 84”,\n" + "  DATUM[“World Geodetic System 1984”,\n" + "    SPHEROID[“WGS84”, 6378137.0, 298.257223563]],\n"+ "    PRIMEM[“Greenwich”, 0.0],\n"+ "  UNIT[“degree”, 0.017453292519943295]]"));
}

</code></pre>

<pre class="type-9 type-3 type-4 type-1 type-7 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Tests the parsing of a compound CRS from a WKT 1 string, except the time dimension which is WKT 2.
 * @throws ParseException if the parsing failed.
 */
@Test @DependsOnMethod("testGeographicCRS") public void testCompoundCRS() throws ParseException {
  final CompoundCRS crs=parse(CompoundCRS.class,"COMPD_CS[“WGS 84 + height + time”,\n" + "  GEOGCS[“WGS 84”,\n" + "    DATUM[“World Geodetic System 1984”,\n"+ "      SPHEROID[“WGS84”, 6378137.0, 298.257223563]],\n"+ "    PRIMEM[“Greenwich”, 0.0],\n"+ "    UNIT[“degree”, 0.017453292519943295],\n"+ "    AXIS[“Longitude”, EAST],\n"+ "    AXIS[“Latitude”, NORTH]],\n"+ "  VERT_CS[“Gravity-related height”,\n"+ "    VERT_DATUM[“Mean Sea Level”, 2005],\n"+ "    UNIT[“metre”, 1],\n"+ "    AXIS[“Gravity-related height”, UP]],\n"+ "  TimeCRS[“Time”,\n"+ "    TimeDatum[“Modified Julian”, TimeOrigin[1858-11-17T00:00:00.0Z]],\n"+ "    Unit[“day”, 86400],\n"+ "    Axis[“Time”, FUTURE]]]");
  assertNameAndIdentifierEqual("WGS 84 + height + time",0,crs);
  final Iterator<CoordinateReferenceSystem> components=crs.getComponents().iterator();
  verifyGeographicCRS(0,(GeographicCRS)components.next());
  final VerticalCRS vertCRS=(VerticalCRS)components.next();
  assertNameAndIdentifierEqual("Gravity-related height",0,vertCRS);
  assertNameAndIdentifierEqual("Mean Sea Level",0,vertCRS.getDatum());
  final TemporalCRS timeCRS=(TemporalCRS)components.next();
  final TemporalDatum timeDatum=timeCRS.getDatum();
  assertNameAndIdentifierEqual("Time",0,timeCRS);
  assertNameAndIdentifierEqual("Modified Julian",0,timeDatum);
  assertEquals("epoch",new Date(-40587 * (24 * 60 * 60* 1000L)),timeDatum.getOrigin());
  assertFalse(components.hasNext());
  final CoordinateSystem cs=crs.getCoordinateSystem();
  assertEquals("dimension",4,cs.getDimension());
  assertLongitudeAxisEquals(cs.getAxis(0));
  assertLatitudeAxisEquals(cs.getAxis(1));
  assertUnboundedAxisEquals("Gravity-related height","H",AxisDirection.UP,SI.METRE,cs.getAxis(2));
  assertUnboundedAxisEquals("Time","t",AxisDirection.FUTURE,NonSI.DAY,cs.getAxis(3));
}

</code></pre>

<pre class="type-3 type-1 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
"></span><br>
/** 
 * Tests the parsing of a geocentric CRS from a WKT 1 string. The parser
 * shall replace the OGC 01-009 axis directions (OTHER, EAST, NORTH) by
 * ISO 19111 axis directions (Geocentric X, Geocentric Y, Geocentric Z).
 * @throws ParseException if the parsing failed.
 */
@Test @DependsOnMethod({"testAxis","testDatum"}) public void testGeocentricCRS() throws ParseException {
  final GeocentricCRS crs=parse(GeocentricCRS.class,"GEOCCS[“Geocentric”,\n" + "  DATUM[“World Geodetic System 1984”,\n" + "    SPHEROID[“WGS84”, 6378137.0, 298.257223563, AUTHORITY[“EPSG”, “7030”]],\n"+ "    AUTHORITY[“EPSG”, “6326”]],\n"+ "    PRIMEM[“Greenwich”, 0.0, AUTHORITY[“EPSG”, “8901”]],\n"+ "  UNIT[“metre”, 1.0],\n"+ "  AXIS[“X”, OTHER],\n"+ "  AXIS[“Y”, EAST],\n"+ "  AXIS[“Z”, NORTH]]");
  assertNameAndIdentifierEqual("Geocentric",0,crs);
  final GeodeticDatum datum=crs.getDatum();
  assertNameAndIdentifierEqual("World Geodetic System 1984",6326,datum);
  assertNameAndIdentifierEqual("Greenwich",8901,datum.getPrimeMeridian());
  final Ellipsoid ellipsoid=datum.getEllipsoid();
  assertNameAndIdentifierEqual("WGS84",7030,ellipsoid);
  assertEquals("semiMajor",6378137,ellipsoid.getSemiMajorAxis(),STRICT);
  assertEquals("inverseFlattening",298.257223563,ellipsoid.getInverseFlattening(),STRICT);
  final CartesianCS cs=(CartesianCS)crs.getCoordinateSystem();
  assertEquals("dimension",3,cs.getDimension());
  assertUnboundedAxisEquals(AxisNames.GEOCENTRIC_X,"X",AxisDirection.GEOCENTRIC_X,SI.METRE,cs.getAxis(0));
  assertUnboundedAxisEquals(AxisNames.GEOCENTRIC_Y,"Y",AxisDirection.GEOCENTRIC_Y,SI.METRE,cs.getAxis(1));
  assertUnboundedAxisEquals(AxisNames.GEOCENTRIC_Z,"Z",AxisDirection.GEOCENTRIC_Z,SI.METRE,cs.getAxis(2));
}

</code></pre>

<pre class="type-3 type-1 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
"></span><br>
/** 
 * Tests the parsing of a geodetic datum from a WKT 2 string.
 * @throws ParseException if the parsing failed.
 */
@Test public void testDatum() throws ParseException {
  final GeodeticDatum datum=parse(GeodeticDatum.class,"DATUM[“Tananarive 1925”,\n" + "  ELLIPSOID[“International 1924”, 6378.388, 297.0, LENGTHUNIT[“km”, 1000]],\n" + "  ANCHOR[“Tananarive observatory”]]");
  assertNameAndIdentifierEqual("Tananarive 1925",0,datum);
  assertEquals("anchor","Tananarive observatory",String.valueOf(datum.getAnchorPoint()));
  final Ellipsoid ellipsoid=datum.getEllipsoid();
  assertNameAndIdentifierEqual("International 1924",0,ellipsoid);
  assertEquals("unit",SI.KILOMETRE,ellipsoid.getAxisUnit());
  assertEquals("semiMajor",6378.388,ellipsoid.getSemiMajorAxis(),STRICT);
  assertEquals("inverseFlattening",297,ellipsoid.getInverseFlattening(),STRICT);
  assertEquals("greenwichLongitude",0,datum.getPrimeMeridian().getGreenwichLongitude(),STRICT);
}

</code></pre>

<pre class="type-9 type-3 type-1 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
"></span><br>
/** 
 * Tests the {@link MathTransform} between North-Orientated and South-Orientated cases.
 * @throws ParseException if the parsing failed.
 * @throws NoninvertibleTransformException if computation of the conversion from North-Orientated
 * to South-Orientated failed.
 */
@Test @DependsOnMethod("testProjectedCRS") public void testMathTransform() throws ParseException, NoninvertibleTransformException {
  ProjectedCRS north=parseTransverseMercator(false,false,1000);
  assertEquals(AxisDirection.WEST,north.getCoordinateSystem().getAxis(0).getDirection());
  assertEquals(AxisDirection.NORTH,north.getCoordinateSystem().getAxis(1).getDirection());
  ProjectedCRS south=parseTransverseMercator(false,true,1000);
  assertEquals(AxisDirection.WEST,south.getCoordinateSystem().getAxis(0).getDirection());
  assertEquals(AxisDirection.SOUTH,south.getCoordinateSystem().getAxis(1).getDirection());
  Matrix matrix=conversion(north,south);
  assertEquals("West direction should be unchanged. ",+1,matrix.getElement(0,0),STRICT);
  assertEquals("North-South direction should be reverted.",-1,matrix.getElement(1,1),STRICT);
  assertEquals("No easting expected.",0,matrix.getElement(0,2),STRICT);
  assertEquals("No northing expected.",0,matrix.getElement(1,2),STRICT);
  assertDiagonalEquals(new double[]{+1,-1,1},true,matrix,STRICT);
  south=parseTransverseMercator(true,true,1000);
  assertEquals(AxisDirection.WEST,south.getCoordinateSystem().getAxis(0).getDirection());
  assertEquals(AxisDirection.SOUTH,south.getCoordinateSystem().getAxis(1).getDirection());
  matrix=conversion(north,south);
  assertEquals("West direction should be unchanged. ",+1,matrix.getElement(0,0),STRICT);
  assertEquals("North-South direction should be reverted.",-1,matrix.getElement(1,1),STRICT);
  assertEquals("No easting expected.",0,matrix.getElement(0,2),STRICT);
  assertEquals("Northing expected.",2000,matrix.getElement(1,2),STRICT);
}

</code></pre>

<pre class="type-3 type-1 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
"></span><br>
/** 
 * Tests the parsing of a projected CRS with feet units.
 * @throws ParseException if the parsing failed.
 */
@Test @DependsOnMethod("testProjectedCRS") public void testProjectedWithFeetUnits() throws ParseException {
  final ProjectedCRS crs=parse(ProjectedCRS.class,"PROJCS[“TransverseMercator”,\n" + "  GEOGCS[“Sphere”,\n" + "    DATUM[“Sphere”,\n"+ "      SPHEROID[“Sphere”, 6370997.0, 0.0],\n"+ "      TOWGS84[0, 0, 0, 0, 0, 0, 0]],\n"+ "      PRIMEM[“Greenwich”, 0.0],\n"+ "    UNIT[“degree”, 0.017453292519943295],\n"+ "    AXIS[“Longitude”, EAST],\n"+ "    AXIS[“Latitude”, NORTH]],\n"+ "  PROJECTION[“Transverse_Mercator”,\n"+ "    AUTHORITY[“OGC”, “Transverse_Mercator”]],\n"+ "  PARAMETER[“central_meridian”, 170.0],\n"+ "  PARAMETER[“latitude_of_origin”, 50.0],\n"+ "  PARAMETER[“scale_factor”, 0.95],\n"+ "  PARAMETER[“false_easting”, 0.0],\n"+ "  PARAMETER[“false_northing”, 0.0],\n"+ "  UNIT[“feet”, 0.304800609601219],\n"+ "  AXIS[“E”, EAST],\n"+ "  AXIS[“N”, NORTH]]");
  assertNameAndIdentifierEqual("TransverseMercator",0,crs);
  assertNameAndIdentifierEqual("Sphere",0,crs.getBaseCRS());
  assertNameAndIdentifierEqual("Sphere",0,crs.getDatum());
  verifyProjectedCS(crs.getCoordinateSystem(),NonSI.FOOT_SURVEY_US);
  final ParameterValueGroup param=crs.getConversionFromBase().getParameterValues();
  assertEquals("Transverse Mercator",crs.getConversionFromBase().getMethod().getName().getCode());
  assertEquals("semi_major",6370997.0,param.parameter("semi_major").doubleValue(),1E-5);
  assertEquals("semi_minor",6370997.0,param.parameter("semi_minor").doubleValue(),1E-5);
  assertEquals("latitude_of_origin",50.0,param.parameter("latitude_of_origin").doubleValue(),1E-8);
  assertEquals("central_meridian",170.0,param.parameter("central_meridian").doubleValue(),1E-8);
  assertEquals("scale_factor",0.95,param.parameter("scale_factor").doubleValue(),1E-8);
  assertEquals("false_easting",0.0,param.parameter("false_easting").doubleValue(),1E-8);
  assertEquals("false_northing",0.0,param.parameter("false_northing").doubleValue(),1E-8);
}

</code></pre>

<pre class="type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Tests the parsing of a geographic CRS from a WKT 1 string using (longitude, latitude) axis order.
 * @throws ParseException if the parsing failed.
 */
@Test @DependsOnMethod({"testAxis","testDatum"}) public void testGeographicCRS() throws ParseException {
  verifyGeographicCRS(0,parse(GeographicCRS.class,"GEOGCS[“WGS 84”,\n" + "  DATUM[“World Geodetic System 1984”,\n" + "    SPHEROID[“WGS84”, 6378137.0, 298.257223563]],\n"+ "    PRIMEM[“Greenwich”, 0.0],\n"+ "  UNIT[“degree”, 0.017453292519943295],\n"+ "  AXIS[“Longitude”, EAST],\n"+ "  AXIS[“Latitude”, NORTH]]"));
}

</code></pre>

<pre class="type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Tests the parsing of a geographic CRS from a WKT string with axes in wrong order according the{@code ORDER} elements. The {@code ORDER} elements are defined in WKT 2 (they did not existed in WKT 1),
 * but the rest of the string is WKT 1. The SIS parser should sort the axes in the order declared
 * in the {@code ORDER} elements.
 * @throws ParseException if the parsing failed.
 */
@Test @DependsOnMethod("testGeographicWithLatLonAxes") public void testGeographicWithUnorderedAxes() throws ParseException {
  verifyGeographicCRS(1,parse(GeographicCRS.class,"GEOGCS[“WGS 84”,\n" + "  DATUM[“World Geodetic System 1984”,\n" + "    SPHEROID[“WGS84”, 6378137.0, 298.257223563]],\n"+ "    PRIMEM[“Greenwich”, 0.0],\n"+ "  UNIT[“degree”, 0.017453292519943295],\n"+ "  AXIS[“Longitude”, EAST, order[2]],\n"+ "  AXIS[“Latitude”, NORTH, order[1]]]"));
}

</code></pre>

<script>$(document).ready(function() {
  $('pre code').each(function(i, block) {
    hljs.highlightBlock(block);
  });
});</script>
