<h3><span class=" glyphicon glyphicon-tag"/>&nbspUtilityVerifier</h3><kbd>Verifies (un)successful execution of the test case by reporting explicitly a failure</kbd><br><br><br><h4 style="margin:0px">Class: org.apache.helix.TestConfigAccessor </h4><pre class="type-4 type-5 type-1 type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testBasic() throws Exception {
  String className=TestHelper.getTestClassName();
  String methodName=TestHelper.getTestMethodName();
  String clusterName=className + "_" + methodName;
  System.out.println("START " + clusterName + " at "+ new Date(System.currentTimeMillis()));
  TestHelper.setupCluster(clusterName,_zkaddr,12918,"localhost","TestDB",1,10,5,3,"MasterSlave",true);
  ConfigAccessor configAccessor=new ConfigAccessor(_zkclient);
  HelixConfigScope clusterScope=new HelixConfigScopeBuilder(ConfigScopeProperty.CLUSTER).forCluster(clusterName).build();
  String clusterConfigValue=configAccessor.get(clusterScope,"clusterConfigKey");
  Assert.assertNull(clusterConfigValue);
  for (int i=0; i < 2; i++) {
    configAccessor.set(clusterScope,"clusterConfigKey" + i,"clusterConfigValue" + i);
    clusterConfigValue=configAccessor.get(clusterScope,"clusterConfigKey" + i);
    Assert.assertEquals(clusterConfigValue,"clusterConfigValue" + i);
  }
  HelixConfigScope resourceScope=new HelixConfigScopeBuilder(ConfigScopeProperty.RESOURCE).forCluster(clusterName).forResource("testResource").build();
  configAccessor.set(resourceScope,"resourceConfigKey","resourceConfigValue");
  String resourceConfigValue=configAccessor.get(resourceScope,"resourceConfigKey");
  Assert.assertEquals(resourceConfigValue,"resourceConfigValue");
  HelixConfigScope partitionScope=new HelixConfigScopeBuilder(ConfigScopeProperty.PARTITION).forCluster(clusterName).forResource("testResource").forPartition("testPartition").build();
  configAccessor.set(partitionScope,"partitionConfigKey","partitionConfigValue");
  String partitionConfigValue=configAccessor.get(partitionScope,"partitionConfigKey");
  Assert.assertEquals(partitionConfigValue,"partitionConfigValue");
  HelixConfigScope participantScope=new HelixConfigScopeBuilder(ConfigScopeProperty.PARTICIPANT).forCluster(clusterName).forParticipant("localhost_12918").build();
  configAccessor.set(participantScope,"participantConfigKey","participantConfigValue");
  String participantConfigValue=configAccessor.get(participantScope,"participantConfigKey");
  Assert.assertEquals(participantConfigValue,"participantConfigValue");
  HelixConfigScope partialResourceScope=new HelixConfigScopeBuilder(ConfigScopeProperty.RESOURCE).forCluster(clusterName).build();
  List<String> keys=configAccessor.getKeys(partialResourceScope);
  Assert.assertEquals(keys.size(),1,"should be [testResource]");
  Assert.assertEquals(keys.get(0),"testResource");
  keys=configAccessor.getKeys(clusterScope);
  Assert.assertEquals(keys.size(),2,"should be [clusterConfigKey0, clusterConfigKey1]");
  Assert.assertEquals(keys.get(0),"clusterConfigKey0");
  Assert.assertEquals(keys.get(1),"clusterConfigKey1");
  HelixConfigScope partialParticipantScope=new HelixConfigScopeBuilder(ConfigScopeProperty.PARTICIPANT).forCluster(clusterName).build();
  keys=configAccessor.getKeys(partialParticipantScope);
  Assert.assertEquals(keys.size(),5,"should be [localhost_12918~22] sorted");
  Assert.assertEquals(keys.get(0),"localhost_12918");
  Assert.assertEquals(keys.get(4),"localhost_12922");
  HelixConfigScope partialPartitionScope=new HelixConfigScopeBuilder(ConfigScopeProperty.PARTITION).forCluster(clusterName).forResource("testResource").build();
  keys=configAccessor.getKeys(partialPartitionScope);
  Assert.assertEquals(keys.size(),1,"should be [testPartition]");
  Assert.assertEquals(keys.get(0),"testPartition");
  keys=configAccessor.getKeys(resourceScope);
  Assert.assertEquals(keys.size(),1,"should be [resourceConfigKey]");
  Assert.assertEquals(keys.get(0),"resourceConfigKey");
  keys=configAccessor.getKeys(participantScope);
  System.out.println((keys));
  Assert.assertEquals(keys.size(),4,"should be [HELIX_ENABLED, HELIX_HOST, HELIX_PORT, participantConfigKey]");
  Assert.assertEquals(keys.get(3),"participantConfigKey");
  keys=configAccessor.getKeys(partitionScope);
  Assert.assertEquals(keys.size(),1,"should be [partitionConfigKey]");
  Assert.assertEquals(keys.get(0),"partitionConfigKey");
  configAccessor.remove(clusterScope,"clusterConfigKey");
  clusterConfigValue=configAccessor.get(clusterScope,"clusterConfigKey");
  Assert.assertNull(clusterConfigValue,"Should be null since it's removed");
  configAccessor.remove(resourceScope,"resourceConfigKey");
  resourceConfigValue=configAccessor.get(resourceScope,"resourceConfigKey");
  Assert.assertNull(resourceConfigValue,"Should be null since it's removed");
  configAccessor.remove(partitionScope,"partitionConfigKey");
  partitionConfigValue=configAccessor.get(partitionScope,"partitionConfigKey");
  Assert.assertNull(partitionConfigValue,"Should be null since it's removed");
  configAccessor.remove(participantScope,"participantConfigKey");
  participantConfigValue=configAccessor.get(partitionScope,"participantConfigKey");
  Assert.assertNull(participantConfigValue,"Should be null since it's removed");
  try {
    new HelixConfigScopeBuilder(ConfigScopeProperty.PARTITION).forPartition("testPartition").build();
    Assert.fail("Should fail since cluster name is not set");
  }
 catch (  Exception e) {
  }
  try {
    new HelixConfigScopeBuilder(ConfigScopeProperty.PARTITION).forCluster("testCluster").forPartition("testPartition").build();
    Assert.fail("Should fail since resource name is not set");
  }
 catch (  Exception e) {
  }
  try {
    new HelixConfigScopeBuilder(ConfigScopeProperty.PARTICIPANT).forParticipant("testParticipant").build();
    Assert.fail("Should fail since cluster name is not set");
  }
 catch (  Exception e) {
  }
  System.out.println("END " + clusterName + " at "+ new Date(System.currentTimeMillis()));
}

</code></pre>

<br>
<pre class="type-5 type-1 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testSetNonexistentParticipantConfig() throws Exception {
  String className=TestHelper.getTestClassName();
  String methodName=TestHelper.getTestMethodName();
  String clusterName=className + "_" + methodName;
  System.out.println("START " + clusterName + " at "+ new Date(System.currentTimeMillis()));
  ZKHelixAdmin admin=new ZKHelixAdmin(_zkclient);
  admin.addCluster(clusterName,true);
  ConfigAccessor configAccessor=new ConfigAccessor(_zkclient);
  HelixConfigScope participantScope=new HelixConfigScopeBuilder(ConfigScopeProperty.PARTICIPANT).forCluster(clusterName).forParticipant("localhost_12918").build();
  try {
    configAccessor.set(participantScope,"participantConfigKey","participantConfigValue");
    Assert.fail("Except fail to set participant-config because participant: localhost_12918 is not added to cluster yet");
  }
 catch (  HelixException e) {
  }
  admin.addInstance(clusterName,new InstanceConfig("localhost_12918"));
  try {
    configAccessor.set(participantScope,"participantConfigKey","participantConfigValue");
  }
 catch (  Exception e) {
    Assert.fail("Except succeed to set participant-config because participant: localhost_12918 has been added to cluster");
  }
  String participantConfigValue=configAccessor.get(participantScope,"participantConfigKey");
  Assert.assertEquals(participantConfigValue,"participantConfigValue");
  System.out.println("END " + clusterName + " at "+ new Date(System.currentTimeMillis()));
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.helix.TestGetProperty </h4><pre class="type-7 type-5 type-2 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testGetProperty(){
  String version;
  Properties props=new Properties();
  try {
    InputStream stream=Thread.currentThread().getContextClassLoader().getResourceAsStream("cluster-manager-version.properties");
    props.load(stream);
    version=props.getProperty("clustermanager.version");
    Assert.assertNotNull(version);
    System.out.println("cluster-manager-version:" + version);
  }
 catch (  IOException e) {
    Assert.fail("could not open cluster-manager-version.properties. ",e);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.helix.TestHelixConfigAccessor </h4><pre class="type-5 type-1 type-8 type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects are null
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testBasic() throws Exception {
  String className=TestHelper.getTestClassName();
  String methodName=TestHelper.getTestMethodName();
  String clusterName=className + "_" + methodName;
  System.out.println("START " + clusterName + " at "+ new Date(System.currentTimeMillis()));
  TestHelper.setupCluster(clusterName,_zkaddr,12918,"localhost","TestDB",1,10,5,3,"MasterSlave",true);
  ConfigAccessor configAccessor=new ConfigAccessor(_zkclient);
  HelixConfigScope clusterScope=new HelixConfigScopeBuilder(ConfigScopeProperty.CLUSTER).forCluster(clusterName).build();
  String clusterConfigValue=configAccessor.get(clusterScope,"clusterConfigKey");
  Assert.assertNull(clusterConfigValue);
  configAccessor.set(clusterScope,"clusterConfigKey","clusterConfigValue");
  clusterConfigValue=configAccessor.get(clusterScope,"clusterConfigKey");
  Assert.assertEquals(clusterConfigValue,"clusterConfigValue");
  HelixConfigScope resourceScope=new HelixConfigScopeBuilder(ConfigScopeProperty.RESOURCE).forCluster(clusterName).forResource("testResource").build();
  configAccessor.set(resourceScope,"resourceConfigKey","resourceConfigValue");
  String resourceConfigValue=configAccessor.get(resourceScope,"resourceConfigKey");
  Assert.assertEquals(resourceConfigValue,"resourceConfigValue");
  HelixConfigScope partitionScope=new HelixConfigScopeBuilder(ConfigScopeProperty.PARTITION).forCluster(clusterName).forResource("testResource").forPartition("testPartition").build();
  configAccessor.set(partitionScope,"partitionConfigKey","partitionConfigValue");
  String partitionConfigValue=configAccessor.get(partitionScope,"partitionConfigKey");
  Assert.assertEquals(partitionConfigValue,"partitionConfigValue");
  HelixConfigScope participantScope=new HelixConfigScopeBuilder(ConfigScopeProperty.PARTICIPANT).forCluster(clusterName).forParticipant("localhost_12918").build();
  configAccessor.set(participantScope,"participantConfigKey","participantConfigValue");
  String participantConfigValue=configAccessor.get(participantScope,"participantConfigKey");
  Assert.assertEquals(participantConfigValue,"participantConfigValue");
  List<String> keys=configAccessor.getKeys(new HelixConfigScopeBuilder(ConfigScopeProperty.RESOURCE).forCluster(clusterName).build());
  Assert.assertEquals(keys.size(),1,"should be [testResource]");
  Assert.assertEquals(keys.get(0),"testResource");
  keys=configAccessor.getKeys(new HelixConfigScopeBuilder(ConfigScopeProperty.PARTICIPANT).forCluster(clusterName).build());
  Assert.assertEquals(keys.size(),5,"should be [localhost_12918~22] sorted");
  Assert.assertTrue(keys.contains("localhost_12918"));
  Assert.assertTrue(keys.contains("localhost_12922"));
  keys=configAccessor.getKeys(new HelixConfigScopeBuilder(ConfigScopeProperty.PARTITION).forCluster(clusterName).forResource("testResource").build());
  Assert.assertEquals(keys.size(),1,"should be [testPartition]");
  Assert.assertEquals(keys.get(0),"testPartition");
  keys=configAccessor.getKeys(new HelixConfigScopeBuilder(ConfigScopeProperty.RESOURCE).forCluster(clusterName).forResource("testResource").build());
  Assert.assertEquals(keys.size(),1,"should be [resourceConfigKey]");
  Assert.assertTrue(keys.contains("resourceConfigKey"));
  keys=configAccessor.getKeys(new HelixConfigScopeBuilder(ConfigScopeProperty.CLUSTER).forCluster(clusterName).build());
  Assert.assertEquals(keys.size(),1,"should be [clusterConfigKey]");
  Assert.assertTrue(keys.contains("clusterConfigKey"));
  keys=configAccessor.getKeys(new HelixConfigScopeBuilder(ConfigScopeProperty.PARTICIPANT).forCluster(clusterName).forParticipant("localhost_12918").build());
  Assert.assertEquals(keys.size(),4,"should be [HELIX_ENABLED, HELIX_PORT, HELIX_HOST, participantConfigKey]");
  Assert.assertTrue(keys.contains("participantConfigKey"));
  keys=configAccessor.getKeys(new HelixConfigScopeBuilder(ConfigScopeProperty.PARTITION).forCluster(clusterName).forResource("testResource").forPartition("testPartition").build());
  Assert.assertEquals(keys.size(),1,"should be [partitionConfigKey]");
  Assert.assertEquals(keys.get(0),"partitionConfigKey");
  configAccessor.remove(clusterScope,"clusterConfigKey");
  clusterConfigValue=configAccessor.get(clusterScope,"clusterConfigKey");
  Assert.assertNull(clusterConfigValue,"Should be null since it's removed");
  configAccessor.remove(resourceScope,"resourceConfigKey");
  resourceConfigValue=configAccessor.get(resourceScope,"resourceConfigKey");
  Assert.assertNull(resourceConfigValue,"Should be null since it's removed");
  configAccessor.remove(partitionScope,"partitionConfigKey");
  partitionConfigValue=configAccessor.get(partitionScope,"partitionConfigKey");
  Assert.assertNull(partitionConfigValue,"Should be null since it's removed");
  configAccessor.remove(participantScope,"participantConfigKey");
  participantConfigValue=configAccessor.get(partitionScope,"participantConfigKey");
  Assert.assertNull(participantConfigValue,"Should be null since it's removed");
  try {
    new HelixConfigScopeBuilder(ConfigScopeProperty.PARTITION).forPartition("testPartition").build();
    Assert.fail("Should fail since cluster name is not set");
  }
 catch (  Exception e) {
  }
  try {
    new HelixConfigScopeBuilder(ConfigScopeProperty.PARTICIPANT).forParticipant("testParticipant").build();
    Assert.fail("Should fail since cluster name is not set");
  }
 catch (  Exception e) {
  }
  try {
    new HelixConfigScopeBuilder(ConfigScopeProperty.PARTITION).forCluster("testCluster").forPartition("testPartition").build();
    Assert.fail("Should fail since resource name is not set");
  }
 catch (  Exception e) {
  }
  System.out.println("END " + clusterName + " at "+ new Date(System.currentTimeMillis()));
}

</code></pre>

<br>
<pre class="type-5 type-1 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testSetNonexistentParticipantConfig() throws Exception {
  String className=TestHelper.getTestClassName();
  String methodName=TestHelper.getTestMethodName();
  String clusterName=className + "_" + methodName;
  System.out.println("START " + clusterName + " at "+ new Date(System.currentTimeMillis()));
  ZKHelixAdmin admin=new ZKHelixAdmin(_zkclient);
  admin.addCluster(clusterName,true);
  ConfigAccessor configAccessor=new ConfigAccessor(_zkclient);
  HelixConfigScope participantScope=new HelixConfigScopeBuilder(ConfigScopeProperty.PARTICIPANT).forCluster(clusterName).forParticipant("localhost_12918").build();
  try {
    configAccessor.set(participantScope,"participantConfigKey","participantConfigValue");
    Assert.fail("Except fail to set participant-config because participant: localhost_12918 is not added to cluster yet");
  }
 catch (  HelixException e) {
  }
  admin.addInstance(clusterName,new InstanceConfig("localhost_12918"));
  try {
    configAccessor.set(participantScope,"participantConfigKey","participantConfigValue");
  }
 catch (  Exception e) {
    Assert.fail("Except succeed to set participant-config because participant: localhost_12918 has been added to cluster");
  }
  String participantConfigValue=configAccessor.get(participantScope,"participantConfigKey");
  Assert.assertEquals(participantConfigValue,"participantConfigValue");
  System.out.println("END " + clusterName + " at "+ new Date(System.currentTimeMillis()));
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.helix.api.accessor.TestAtomicAccessors </h4><pre class="type-14 type-5 type-1 type-8 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testClusterUpdates(){
  final ClusterId clusterId=ClusterId.from("TestAtomicAccessors!testCluster");
  final HelixDataAccessor helixAccessor=new ZKHelixDataAccessor(clusterId.stringify(),_baseAccessor);
  final LockProvider lockProvider=new LockProvider();
  final String key1="key1";
  final String key2="key2";
  ClusterAccessor accessor=new ClusterAccessor(clusterId,helixAccessor);
  ClusterConfig config=new ClusterConfig.Builder(clusterId).build();
  boolean created=accessor.createCluster(config);
  Assert.assertTrue(created);
  Thread t1=new Thread(){
    @Override public void run(){
      UserConfig userConfig=new UserConfig(Scope.cluster(clusterId));
      userConfig.setBooleanField(key1,true);
      ClusterConfig.Delta delta=new ClusterConfig.Delta(clusterId).addUserConfig(userConfig);
      ClusterAccessor accessor=new AtomicClusterAccessor(clusterId,helixAccessor,lockProvider);
      accessor.updateCluster(delta);
    }
  }
;
  Thread t2=new Thread(){
    @Override public void run(){
      UserConfig userConfig=new UserConfig(Scope.cluster(clusterId));
      userConfig.setBooleanField(key2,true);
      ClusterConfig.Delta delta=new ClusterConfig.Delta(clusterId).addUserConfig(userConfig);
      ClusterAccessor accessor=new AtomicClusterAccessor(clusterId,helixAccessor,lockProvider);
      accessor.updateCluster(delta);
    }
  }
;
  t1.start();
  t2.start();
  long startTime=System.currentTimeMillis();
  try {
    t1.join(TIMEOUT);
    t2.join(TIMEOUT);
  }
 catch (  InterruptedException e) {
    Assert.fail(e.getMessage());
    t1.interrupt();
    t2.interrupt();
  }
  long endTime=System.currentTimeMillis();
  if (endTime - startTime > TIMEOUT - EXTRA_WAIT) {
    Assert.fail("Test timed out");
    t1.interrupt();
    t2.interrupt();
  }
  Assert.assertTrue(lockProvider.hasLockBlocked());
  accessor.dropCluster();
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.helix.controller.stages.TestCompatibilityCheckStage </h4><pre class="type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testCompatible(){
  prepare("0.4.0","0.4.0");
  CompatibilityCheckStage stage=new CompatibilityCheckStage();
  StageContext context=new StageContext();
  stage.init(context);
  stage.preProcess();
  try {
    stage.process(event);
  }
 catch (  Exception e) {
    Assert.fail("Should not fail since versions are compatible",e);
  }
  stage.postProcess();
}

</code></pre>

<br>
<pre class="type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testNullControllerVersion(){
  prepare(null,"0.4.0");
  CompatibilityCheckStage stage=new CompatibilityCheckStage();
  StageContext context=new StageContext();
  stage.init(context);
  stage.preProcess();
  try {
    stage.process(event);
  }
 catch (  Exception e) {
    Assert.fail("Should not fail since compatibility check will be skipped if controller version is null");
  }
  stage.postProcess();
}

</code></pre>

<br>
<pre class="type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testNullParticipantVersion(){
  prepare("0.4.0",null);
  CompatibilityCheckStage stage=new CompatibilityCheckStage();
  StageContext context=new StageContext();
  stage.init(context);
  stage.preProcess();
  try {
    stage.process(event);
  }
 catch (  Exception e) {
    Assert.fail("Should not fail since compatibility check will be skipped if participant version is null");
  }
  stage.postProcess();
}

</code></pre>

<br>
<pre class="type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testIncompatible(){
  prepare("0.6.1-incubating-SNAPSHOT","0.3.4","0.4");
  CompatibilityCheckStage stage=new CompatibilityCheckStage();
  StageContext context=new StageContext();
  stage.init(context);
  stage.preProcess();
  try {
    stage.process(event);
    Assert.fail("Should fail since participant version is less than the minimum participant version supported by controller");
  }
 catch (  Exception e) {
  }
  stage.postProcess();
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.helix.controller.stages.TestMessageThrottleStage </h4><pre class="type-5 type-1 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testMsgThrottleBasic() throws Exception {
  String clusterName="CLUSTER_" + _className + "_basic";
  System.out.println("START " + clusterName + " at "+ new Date(System.currentTimeMillis()));
  HelixDataAccessor accessor=new ZKHelixDataAccessor(clusterName,_baseAccessor);
  TestHelper.setupEmptyCluster(_zkclient,clusterName);
  HelixManager manager=new DummyClusterManager(clusterName,accessor);
  List<IdealState> idealStates=HelixTestUtil.setupIdealState(_baseAccessor,clusterName,new int[]{0,1},new String[]{"TestDB"},1,2);
  HelixTestUtil.setupLiveInstances(_baseAccessor,clusterName,new int[]{0,1});
  HelixTestUtil.setupStateModel(_baseAccessor,clusterName);
  ClusterEvent event=new ClusterEvent("testEvent");
  event.addAttribute("helixmanager",manager);
  BestPossibleStateOutput bestPossOutput=getEmptyBestPossibleStateOutput(idealStates);
  event.addAttribute(AttributeName.BEST_POSSIBLE_STATE.toString(),bestPossOutput);
  MessageThrottleStage throttleStage=new MessageThrottleStage();
  try {
    HelixTestUtil.runStage(event,throttleStage);
    Assert.fail("Should throw exception since DATA_CACHE is null");
  }
 catch (  Exception e) {
  }
  Pipeline dataRefresh=new Pipeline();
  dataRefresh.addStage(new ReadClusterDataStage());
  HelixTestUtil.runPipeline(event,dataRefresh);
  try {
    HelixTestUtil.runStage(event,throttleStage);
    Assert.fail("Should throw exception since RESOURCE is null");
  }
 catch (  Exception e) {
  }
  HelixTestUtil.runStage(event,new ResourceComputationStage());
  try {
    HelixTestUtil.runStage(event,throttleStage);
    Assert.fail("Should throw exception since MESSAGE_SELECT is null");
  }
 catch (  Exception e) {
  }
  MessageOutput msgSelectOutput=new MessageOutput();
  List<Message> selectMessages=new ArrayList<Message>();
  Message msg=HelixTestUtil.newMessage(MessageType.STATE_TRANSITION,MessageId.from("msgId-001"),"OFFLINE","SLAVE","TestDB","localhost_0");
  selectMessages.add(msg);
  msgSelectOutput.setMessages(ResourceId.from("TestDB"),PartitionId.from("TestDB_0"),selectMessages);
  event.addAttribute(AttributeName.MESSAGES_SELECTED.toString(),msgSelectOutput);
  HelixTestUtil.runStage(event,throttleStage);
  MessageOutput msgThrottleOutput=event.getAttribute(AttributeName.MESSAGES_THROTTLE.toString());
  Assert.assertEquals(msgThrottleOutput.getMessages(ResourceId.from("TestDB"),PartitionId.from("TestDB_0")).size(),1);
  System.out.println("END " + clusterName + " at "+ new Date(System.currentTimeMillis()));
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.helix.controller.stages.TestStagesWithLogicalAccessors </h4><pre class="type-5 type-1 type-2 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testBasicBestPossibleStateCalcStage(){
  String className=TestHelper.getTestClassName();
  String methodName=TestHelper.getTestMethodName();
  String testName=className + "_" + methodName;
  System.out.println("START " + testName + " at "+ new Date(System.currentTimeMillis()));
  ClusterAccessor clusterAccessor=new ClusterAccessor(_clusterId,_dataAccessor);
  Cluster cluster=clusterAccessor.readCluster();
  ClusterEvent event=new ClusterEvent(testName);
  event.addAttribute(AttributeName.CURRENT_STATE.toString(),new ResourceCurrentState());
  Map<ResourceId,ResourceConfig> resourceConfigMap=Maps.transformValues(cluster.getResourceMap(),new Function<Resource,ResourceConfig>(){
    @Override public ResourceConfig apply(    Resource resource){
      return resource.getConfig();
    }
  }
);
  event.addAttribute(AttributeName.RESOURCES.toString(),resourceConfigMap);
  event.addAttribute("Cluster",cluster);
  try {
    new BestPossibleStateCalcStage().process(event);
  }
 catch (  Exception e) {
    Assert.fail(e.toString());
  }
  BestPossibleStateOutput bestPossibleStateOutput=event.getAttribute(AttributeName.BEST_POSSIBLE_STATE.toString());
  Assert.assertNotNull(bestPossibleStateOutput);
  ResourceId resourceId=ResourceId.from("TestDB0");
  ResourceAssignment assignment=bestPossibleStateOutput.getResourceAssignment(resourceId);
  Assert.assertNotNull(assignment);
  Resource resource=cluster.getResource(resourceId);
  verifySemiAutoRebalance(resource,assignment);
  System.out.println("END " + testName + " at "+ new Date(System.currentTimeMillis()));
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.helix.integration.TestClusterStartsup </h4><pre class="type-14 type-5 type-1 type-8 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test() public void testParticipantStartUp() throws Exception {
  setupCluster();
  String controllerMsgPath=HelixUtil.getControllerPropertyPath(CLUSTER_NAME,PropertyType.MESSAGES_CONTROLLER);
  _zkclient.deleteRecursive(controllerMsgPath);
  HelixManager manager=null;
  try {
    manager=HelixManagerFactory.getZKHelixManager(CLUSTER_NAME,"localhost_" + (START_PORT + 1),InstanceType.PARTICIPANT,_zkaddr);
    manager.connect();
    Assert.fail("Should fail on connect() since cluster structure is not set up");
  }
 catch (  HelixException e) {
  }
  if (manager != null) {
    AssertJUnit.assertFalse(manager.isConnected());
  }
  try {
    manager=HelixManagerFactory.getZKHelixManager(CLUSTER_NAME,"localhost_" + (START_PORT + 3),InstanceType.PARTICIPANT,_zkaddr);
    manager.connect();
    Assert.fail("Should fail on connect() since cluster structure is not set up");
  }
 catch (  HelixException e) {
  }
  if (manager != null) {
    AssertJUnit.assertFalse(manager.isConnected());
  }
  setupCluster();
  String stateModelPath=HelixUtil.getStateModelDefinitionPath(CLUSTER_NAME);
  _zkclient.deleteRecursive(stateModelPath);
  try {
    manager=HelixManagerFactory.getZKHelixManager(CLUSTER_NAME,"localhost_" + (START_PORT + 1),InstanceType.PARTICIPANT,_zkaddr);
    manager.connect();
    Assert.fail("Should fail on connect() since cluster structure is not set up");
  }
 catch (  HelixException e) {
  }
  if (manager != null) {
    AssertJUnit.assertFalse(manager.isConnected());
  }
  setupCluster();
  String instanceStatusUpdatePath=HelixUtil.getInstancePropertyPath(CLUSTER_NAME,"localhost_" + (START_PORT + 1),PropertyType.STATUSUPDATES);
  _zkclient.deleteRecursive(instanceStatusUpdatePath);
  try {
    manager=HelixManagerFactory.getZKHelixManager(CLUSTER_NAME,"localhost_" + (START_PORT + 1),InstanceType.PARTICIPANT,_zkaddr);
    manager.connect();
    Assert.fail("Should fail on connect() since cluster structure is not set up");
  }
 catch (  HelixException e) {
  }
  if (manager != null) {
    AssertJUnit.assertFalse(manager.isConnected());
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.helix.integration.TestMessageThrottle </h4><pre class="type-14 type-5 type-8 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test() public void testMessageThrottle() throws Exception {
  String clusterName=TestUtil.getTestName();
  MockParticipant[] participants=new MockParticipant[5];
  System.out.println("START " + clusterName + " at "+ new Date(System.currentTimeMillis()));
  TestHelper.setupCluster(clusterName,_zkaddr,12918,"localhost","TestDB",1,10,5,3,"MasterSlave",true);
  HelixAdmin admin=new ZKHelixAdmin(_zkclient);
  ConstraintItemBuilder builder=new ConstraintItemBuilder();
  builder.addConstraintAttribute("MESSAGE_TYPE","STATE_TRANSITION").addConstraintAttribute("INSTANCE",".*").addConstraintAttribute("CONSTRAINT_VALUE","1");
  admin.setConstraint(clusterName,ConstraintType.MESSAGE_CONSTRAINT,"constraint1",builder.build());
  final ZKHelixDataAccessor accessor=new ZKHelixDataAccessor(clusterName,_baseAccessor);
  final AtomicBoolean success=new AtomicBoolean(true);
  for (int i=0; i < 5; i++) {
    String instanceName="localhost_" + (12918 + i);
    String msgPath=PropertyPathConfig.getPath(PropertyType.MESSAGES,clusterName,instanceName);
    _zkclient.subscribeChildChanges(msgPath,new IZkChildListener(){
      @Override public void handleChildChange(      String parentPath,      List<String> currentChilds) throws Exception {
        if (currentChilds != null && currentChilds.size() > 1) {
          List<ZNRecord> records=accessor.getBaseDataAccessor().getChildren(parentPath,null,0);
          int transitionMsgCount=0;
          for (          ZNRecord record : records) {
            Message msg=new Message(record);
            if (msg.getMsgType().equals(Message.MessageType.STATE_TRANSITION.toString())) {
              transitionMsgCount++;
            }
          }
          if (transitionMsgCount > 1) {
            success.set(false);
            Assert.fail("Should not see more than 1 message");
          }
        }
      }
    }
);
  }
  MockController controller=new MockController(_zkaddr,clusterName,"controller_0");
  controller.syncStart();
  for (int i=0; i < 5; i++) {
    String instanceName="localhost_" + (12918 + i);
    participants[i]=new MockParticipant(_zkaddr,clusterName,instanceName);
    participants[i].syncStart();
  }
  boolean result=ClusterStateVerifier.verifyByZkCallback(new MasterNbInExtViewVerifier(_zkaddr,clusterName));
  Assert.assertTrue(result);
  result=ClusterStateVerifier.verifyByZkCallback(new BestPossAndExtViewZkVerifier(_zkaddr,clusterName));
  Assert.assertTrue(result);
  Assert.assertTrue(success.get());
  controller.syncStop();
  for (int i=0; i < 5; i++) {
    participants[i].syncStop();
  }
  System.out.println("END " + clusterName + " at "+ new Date(System.currentTimeMillis()));
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.helix.integration.TestReelectedPipelineCorrectness </h4><pre class="type-14 type-5 type-8 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testReelection() throws Exception {
  final int NUM_CONTROLLERS=2;
  final int NUM_PARTICIPANTS=4;
  final int NUM_PARTITIONS=8;
  final int NUM_REPLICAS=2;
  String className=TestHelper.getTestClassName();
  String methodName=TestHelper.getTestMethodName();
  String clusterName=className + "_" + methodName;
  System.out.println("START " + clusterName + " at "+ new Date(System.currentTimeMillis()));
  TestHelper.setupCluster(clusterName,_zkaddr,12918,"localhost","TestDB",1,NUM_PARTITIONS,NUM_PARTICIPANTS,NUM_REPLICAS,"MasterSlave",RebalanceMode.FULL_AUTO,true);
  String controllerCluster=clusterName + "_controllers";
  _setupTool.addCluster(controllerCluster,true);
  for (int i=0; i < NUM_CONTROLLERS; i++) {
    _setupTool.addInstanceToCluster(controllerCluster,"controller_" + i);
  }
  _setupTool.activateCluster(clusterName,controllerCluster,true);
  MockParticipant[] participants=new MockParticipant[NUM_PARTICIPANTS];
  for (int i=0; i < NUM_PARTICIPANTS; i++) {
    final String instanceName="localhost_" + (12918 + i);
    participants[i]=new MockParticipant(_zkaddr,clusterName,instanceName);
    participants[i].syncStart();
  }
  MockMultiClusterController[] controllers=new MockMultiClusterController[NUM_CONTROLLERS];
  for (int i=0; i < NUM_CONTROLLERS; i++) {
    controllers[i]=new MockMultiClusterController(_zkaddr,controllerCluster,"controller_" + i);
    controllers[i].syncStart();
  }
  Thread.sleep(1000);
  boolean result=ClusterStateVerifier.verifyByZkCallback(new BestPossAndExtViewZkVerifier(_zkaddr,clusterName));
  Assert.assertTrue(result);
  HelixDataAccessor accessor=participants[0].getHelixDataAccessor();
  LiveInstance leader=accessor.getProperty(accessor.keyBuilder().controllerLeader());
  int totalWait=0;
  while (leader == null && totalWait < CHECK_TIMEOUT) {
    Thread.sleep(CHECK_INTERVAL);
    totalWait+=CHECK_INTERVAL;
    leader=accessor.getProperty(accessor.keyBuilder().controllerLeader());
  }
  if (totalWait >= CHECK_TIMEOUT) {
    Assert.fail("No leader was ever elected!");
  }
  String leaderId=leader.getId();
  String standbyId=(leaderId.equals("controller_0")) ? "controller_1" : "controller_0";
  HelixAdmin admin=_setupTool.getClusterManagementTool();
  admin.enableInstance(controllerCluster,leaderId,false);
  Thread.sleep(500);
  participants[0].syncStop();
  Thread.sleep(500);
  result=ClusterStateVerifier.verifyByZkCallback(new BestPossAndExtViewZkVerifier(_zkaddr,clusterName));
  Assert.assertTrue(result);
  admin.enableInstance(controllerCluster,standbyId,false);
  Thread.sleep(500);
  participants[1].syncStop();
  IdealState idealState=admin.getResourceIdealState(clusterName,"TestDB0");
  idealState.setMaxPartitionsPerInstance(1);
  admin.setResourceIdealState(clusterName,"TestDB0",idealState);
  Thread.sleep(500);
  admin.enableInstance(clusterName,"localhost_12920",false);
  admin.enableInstance(controllerCluster,leaderId,true);
  Thread.sleep(500);
  result=ClusterStateVerifier.verifyByZkCallback(new BestPossAndExtViewZkVerifier(_zkaddr,clusterName));
  Assert.assertTrue(result);
  for (int i=0; i < NUM_CONTROLLERS; i++) {
    controllers[i].syncStop();
  }
  for (int i=2; i < NUM_PARTICIPANTS; i++) {
    participants[i].syncStop();
  }
  System.out.println("STOP " + clusterName + " at "+ new Date(System.currentTimeMillis()));
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.helix.integration.TestResetPartitionState </h4><pre class="type-5 type-8 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test() public void testResetPartitionState() throws Exception {
  String className=TestHelper.getTestClassName();
  String methodName=TestHelper.getTestMethodName();
  String clusterName=className + "_" + methodName;
  final int n=5;
  System.out.println("START " + clusterName + " at "+ new Date(System.currentTimeMillis()));
  TestHelper.setupCluster(clusterName,_zkaddr,12918,"localhost","TestDB",1,10,n,3,"MasterSlave",true);
  MockController controller=new MockController(_zkaddr,clusterName,"controller_0");
  controller.syncStart();
  Map<String,Set<String>> errPartitions=new HashMap<String,Set<String>>();
  errPartitions.put("SLAVE-MASTER",TestHelper.setOf("TestDB0_4"));
  errPartitions.put("OFFLINE-SLAVE",TestHelper.setOf("TestDB0_8"));
  MockParticipant[] participants=new MockParticipant[n];
  for (int i=0; i < n; i++) {
    String instanceName="localhost_" + (12918 + i);
    if (i == 0) {
      participants[i]=new MockParticipant(_zkaddr,clusterName,instanceName);
      participants[i].setTransition(new ErrTransition(errPartitions));
    }
 else {
      participants[i]=new MockParticipant(_zkaddr,clusterName,instanceName);
    }
    participants[i].syncStart();
  }
  Map<String,Map<String,String>> errStateMap=new HashMap<String,Map<String,String>>();
  errStateMap.put("TestDB0",new HashMap<String,String>());
  errStateMap.get("TestDB0").put("TestDB0_4","localhost_12918");
  errStateMap.get("TestDB0").put("TestDB0_8","localhost_12918");
  boolean result=ClusterStateVerifier.verifyByZkCallback((new ClusterStateVerifier.BestPossAndExtViewZkVerifier(_zkaddr,clusterName,errStateMap)));
  Assert.assertTrue(result,"Cluster verification fails");
  try {
    String command="--zkSvr " + _zkaddr + " --resetPartition "+ clusterName+ " localhost_12918 TestDB0 TestDB0_nonExist";
    ClusterSetup.processCommandLineArgs(command.split("\\s+"));
    Assert.fail("Should throw exception on reset a non-exist partition");
  }
 catch (  Exception e) {
  }
  errPartitions.remove("SLAVE-MASTER");
  participants[0].setTransition(new ErrTransitionWithResetCnt(errPartitions));
  clearStatusUpdate(clusterName,"localhost_12918","TestDB0","TestDB0_4");
  _errToOfflineInvoked=0;
  String command="--zkSvr " + _zkaddr + " --resetPartition "+ clusterName+ " localhost_12918 TestDB0 TestDB0_4";
  ClusterSetup.processCommandLineArgs(command.split("\\s+"));
  Thread.sleep(200);
  try {
    ClusterSetup.processCommandLineArgs(command.split("\\s+"));
    Assert.fail("Should throw exception on reset a partition not in ERROR state");
  }
 catch (  Exception e) {
  }
  errStateMap.get("TestDB0").remove("TestDB0_4");
  result=ClusterStateVerifier.verifyByZkCallback((new ClusterStateVerifier.BestPossAndExtViewZkVerifier(_zkaddr,clusterName,errStateMap)));
  Assert.assertTrue(result,"Cluster verification fails");
  Assert.assertEquals(_errToOfflineInvoked,1);
  participants[0].setTransition(new ErrTransitionWithResetCnt(null));
  clearStatusUpdate(clusterName,"localhost_12918","TestDB0","TestDB0_8");
  command="--zkSvr " + _zkaddr + " --resetPartition "+ clusterName+ " localhost_12918 TestDB0 TestDB0_8";
  ClusterSetup.processCommandLineArgs(command.split("\\s+"));
  result=ClusterStateVerifier.verifyByPolling(new ClusterStateVerifier.BestPossAndExtViewZkVerifier(_zkaddr,clusterName));
  Assert.assertTrue(result,"Cluster verification fails");
  Assert.assertEquals(_errToOfflineInvoked,2,"Should reset 2 partitions");
  controller.syncStop();
  for (int i=0; i < 5; i++) {
    participants[i].syncStop();
  }
  System.out.println("END " + clusterName + " at "+ new Date(System.currentTimeMillis()));
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.helix.manager.zk.TestZNRecordSizeLimit </h4><pre class="type-7 type-5 type-1 type-8 type-2 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testZNRecordSizeLimitUseZNRecordSerializer(){
  String className=TestUtil.getTestName();
  System.out.println("START testZNRecordSizeLimitUseZNRecordSerializer at " + new Date(System.currentTimeMillis()));
  String root=className;
  byte[] buf=new byte[1024];
  for (int i=0; i < 1024; i++) {
    buf[i]='a';
  }
  String bufStr=new String(buf);
  final ZNRecord smallRecord=new ZNRecord("normalsize");
  smallRecord.getSimpleFields().clear();
  for (int i=0; i < 900; i++) {
    smallRecord.setSimpleField(i + "",bufStr);
  }
  String path1="/" + root + "/test1";
  _zkclient.createPersistent(path1,true);
  _zkclient.writeData(path1,smallRecord);
  ZNRecordStreamingSerializer serializer=new ZNRecordStreamingSerializer();
  ZNRecord record=_zkclient.readData(path1);
  Assert.assertTrue(serializer.serialize(record).length > 900 * 1024);
  final ZNRecord largeRecord=new ZNRecord("oversize");
  largeRecord.getSimpleFields().clear();
  for (int i=0; i < 1024; i++) {
    largeRecord.setSimpleField(i + "",bufStr);
  }
  String path2="/" + root + "/test2";
  _zkclient.createPersistent(path2,true);
  try {
    _zkclient.writeData(path2,largeRecord);
    Assert.fail("Should fail because data size is larger than 1M");
  }
 catch (  HelixException e) {
  }
  record=_zkclient.readData(path2);
  Assert.assertNull(record);
  record=_zkclient.readData(path1);
  try {
    _zkclient.writeData(path1,largeRecord);
    Assert.fail("Should fail because data size is larger than 1M");
  }
 catch (  HelixException e) {
  }
  ZNRecord recordNew=_zkclient.readData(path1);
  byte[] arr=serializer.serialize(record);
  byte[] arrNew=serializer.serialize(recordNew);
  Assert.assertTrue(Arrays.equals(arr,arrNew));
  ZKHelixAdmin admin=new ZKHelixAdmin(_zkclient);
  admin.addCluster(className,true);
  InstanceConfig instanceConfig=new InstanceConfig("localhost_12918");
  admin.addInstance(className,instanceConfig);
  ZKHelixDataAccessor accessor=new ZKHelixDataAccessor(className,new ZkBaseDataAccessor<ZNRecord>(_zkclient));
  Builder keyBuilder=accessor.keyBuilder();
  IdealState idealState=new IdealState("currentState");
  idealState.setStateModelDefId(StateModelDefId.from("MasterSlave"));
  idealState.setRebalanceMode(RebalanceMode.SEMI_AUTO);
  idealState.setNumPartitions(10);
  for (int i=0; i < 1024; i++) {
    idealState.getRecord().setSimpleField(i + "",bufStr);
  }
  boolean succeed=accessor.setProperty(keyBuilder.idealStates("TestDB0"),idealState);
  Assert.assertFalse(succeed);
  HelixProperty property=accessor.getProperty(keyBuilder.stateTransitionStatus("localhost_12918","session_1","partition_1"));
  Assert.assertNull(property);
  idealState.getRecord().getSimpleFields().clear();
  idealState.setStateModelDefId(StateModelDefId.from("MasterSlave"));
  idealState.setRebalanceMode(RebalanceMode.SEMI_AUTO);
  idealState.setNumPartitions(10);
  for (int i=0; i < 900; i++) {
    idealState.getRecord().setSimpleField(i + "",bufStr);
  }
  succeed=accessor.setProperty(keyBuilder.idealStates("TestDB1"),idealState);
  Assert.assertTrue(succeed);
  record=accessor.getProperty(keyBuilder.idealStates("TestDB1")).getRecord();
  Assert.assertTrue(serializer.serialize(record).length > 900 * 1024);
  idealState.getRecord().getSimpleFields().clear();
  idealState.setStateModelDefId(StateModelDefId.from("MasterSlave"));
  idealState.setRebalanceMode(RebalanceMode.SEMI_AUTO);
  idealState.setNumPartitions(10);
  for (int i=900; i < 1024; i++) {
    idealState.getRecord().setSimpleField(i + "",bufStr);
  }
  succeed=accessor.updateProperty(keyBuilder.idealStates("TestDB1"),idealState);
  Assert.assertFalse(succeed);
  recordNew=accessor.getProperty(keyBuilder.idealStates("TestDB1")).getRecord();
  arr=serializer.serialize(record);
  arrNew=serializer.serialize(recordNew);
  Assert.assertTrue(Arrays.equals(arr,arrNew));
  System.out.println("END testZNRecordSizeLimitUseZNRecordSerializer at " + new Date(System.currentTimeMillis()));
}

</code></pre>

<br>
<pre class="type-7 type-5 type-1 type-8 type-2 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testZNRecordSizeLimitUseZNRecordStreamingSerializer(){
  String className=TestUtil.getTestName();
  System.out.println("START testZNRecordSizeLimitUseZNRecordStreamingSerializer at " + new Date(System.currentTimeMillis()));
  ZNRecordStreamingSerializer serializer=new ZNRecordStreamingSerializer();
  String root=className;
  byte[] buf=new byte[1024];
  for (int i=0; i < 1024; i++) {
    buf[i]='a';
  }
  String bufStr=new String(buf);
  final ZNRecord smallRecord=new ZNRecord("normalsize");
  smallRecord.getSimpleFields().clear();
  for (int i=0; i < 900; i++) {
    smallRecord.setSimpleField(i + "",bufStr);
  }
  String path1="/" + root + "/test1";
  _zkclient.createPersistent(path1,true);
  _zkclient.writeData(path1,smallRecord);
  ZNRecord record=_zkclient.readData(path1);
  Assert.assertTrue(serializer.serialize(record).length > 900 * 1024);
  final ZNRecord largeRecord=new ZNRecord("oversize");
  largeRecord.getSimpleFields().clear();
  for (int i=0; i < 1024; i++) {
    largeRecord.setSimpleField(i + "",bufStr);
  }
  String path2="/" + root + "/test2";
  _zkclient.createPersistent(path2,true);
  try {
    _zkclient.writeData(path2,largeRecord);
    Assert.fail("Should fail because data size is larger than 1M");
  }
 catch (  HelixException e) {
  }
  record=_zkclient.readData(path2);
  Assert.assertNull(record);
  record=_zkclient.readData(path1);
  try {
    _zkclient.writeData(path1,largeRecord);
    Assert.fail("Should fail because data size is larger than 1M");
  }
 catch (  HelixException e) {
  }
  ZNRecord recordNew=_zkclient.readData(path1);
  byte[] arr=serializer.serialize(record);
  byte[] arrNew=serializer.serialize(recordNew);
  Assert.assertTrue(Arrays.equals(arr,arrNew));
  ZKHelixAdmin admin=new ZKHelixAdmin(_zkclient);
  admin.addCluster(className,true);
  InstanceConfig instanceConfig=new InstanceConfig("localhost_12918");
  admin.addInstance(className,instanceConfig);
  ZKHelixDataAccessor accessor=new ZKHelixDataAccessor(className,new ZkBaseDataAccessor<ZNRecord>(_zkclient));
  Builder keyBuilder=accessor.keyBuilder();
  IdealState idealState=new IdealState("currentState");
  idealState.setStateModelDefId(StateModelDefId.from("MasterSlave"));
  idealState.setRebalanceMode(RebalanceMode.SEMI_AUTO);
  idealState.setNumPartitions(10);
  for (int i=0; i < 1024; i++) {
    idealState.getRecord().setSimpleField(i + "",bufStr);
  }
  boolean succeed=accessor.setProperty(keyBuilder.idealStates("TestDB_1"),idealState);
  Assert.assertFalse(succeed);
  HelixProperty property=accessor.getProperty(keyBuilder.idealStates("TestDB_1"));
  Assert.assertNull(property);
  idealState.getRecord().getSimpleFields().clear();
  idealState.setStateModelDefId(StateModelDefId.from("MasterSlave"));
  idealState.setRebalanceMode(RebalanceMode.SEMI_AUTO);
  idealState.setNumPartitions(10);
  for (int i=0; i < 900; i++) {
    idealState.getRecord().setSimpleField(i + "",bufStr);
  }
  succeed=accessor.setProperty(keyBuilder.idealStates("TestDB_2"),idealState);
  Assert.assertTrue(succeed);
  record=accessor.getProperty(keyBuilder.idealStates("TestDB_2")).getRecord();
  Assert.assertTrue(serializer.serialize(record).length > 900 * 1024);
  idealState.getRecord().getSimpleFields().clear();
  idealState.setStateModelDefId(StateModelDefId.from("MasterSlave"));
  idealState.setRebalanceMode(RebalanceMode.SEMI_AUTO);
  idealState.setNumPartitions(10);
  for (int i=900; i < 1024; i++) {
    idealState.getRecord().setSimpleField(i + "",bufStr);
  }
  succeed=accessor.updateProperty(keyBuilder.idealStates("TestDB_2"),idealState);
  Assert.assertFalse(succeed);
  recordNew=accessor.getProperty(keyBuilder.idealStates("TestDB_2")).getRecord();
  arr=serializer.serialize(record);
  arrNew=serializer.serialize(recordNew);
  Assert.assertTrue(Arrays.equals(arr,arrNew));
  System.out.println("END testZNRecordSizeLimitUseZNRecordStreamingSerializer at " + new Date(System.currentTimeMillis()));
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.helix.manager.zk.TestZkBaseDataAccessor </h4><pre class="type-7 type-5 type-1 type-8 type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects are null
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testSyncSetWithVersion(){
  String className=TestHelper.getTestClassName();
  String methodName=TestHelper.getTestMethodName();
  String testName=className + "_" + methodName;
  System.out.println("START " + testName + " at "+ new Date(System.currentTimeMillis()));
  String path=String.format("/%s/%s",testName,"msg_0");
  ZNRecord record=new ZNRecord("msg_0");
  boolean success=_baseAccessor.set(path,record,0,AccessOption.PERSISTENT);
  Assert.assertFalse(success,"Should fail since version not match");
  try {
    _zkclient.readData(path,false);
    Assert.fail("Should get no node exception");
  }
 catch (  Exception e) {
  }
  success=_baseAccessor.set(path,record,-1,AccessOption.PERSISTENT);
  Assert.assertTrue(success);
  ZNRecord getRecord=_zkclient.readData(path);
  Assert.assertNotNull(getRecord);
  Assert.assertEquals(getRecord.getId(),"msg_0");
  path=String.format("/%s/%s",testName,"msg_1");
  record=new ZNRecord("msg_1");
  success=_baseAccessor.set(path,record,0,AccessOption.EPHEMERAL);
  Assert.assertFalse(success);
  try {
    _zkclient.readData(path,false);
    Assert.fail("Should get no node exception");
  }
 catch (  Exception e) {
  }
  success=_baseAccessor.set(path,record,-1,AccessOption.EPHEMERAL);
  Assert.assertTrue(success);
  getRecord=_zkclient.readData(path);
  Assert.assertNotNull(getRecord);
  Assert.assertEquals(getRecord.getId(),"msg_1");
  record.setSimpleField("key0","value0");
  success=_baseAccessor.set(path,record,0,AccessOption.PERSISTENT);
  Assert.assertTrue(success,"Should pass. AccessOption.PERSISTENT is ignored");
  getRecord=_zkclient.readData(path);
  Assert.assertNotNull(getRecord);
  Assert.assertEquals(getRecord.getSimpleFields().size(),1);
  Assert.assertNotNull(getRecord.getSimpleField("key0"));
  Assert.assertEquals(getRecord.getSimpleField("key0"),"value0");
  System.out.println("END " + testName + " at "+ new Date(System.currentTimeMillis()));
}

</code></pre>

<br>
<pre class="type-7 type-5 type-1 type-8 type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects are null
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testSyncGet(){
  String className=TestHelper.getTestClassName();
  String methodName=TestHelper.getTestMethodName();
  String testName=className + "_" + methodName;
  System.out.println("START " + testName + " at "+ new Date(System.currentTimeMillis()));
  String path=String.format("/%s/%s",testName,"msg_0");
  ZNRecord record=new ZNRecord("msg_0");
  ZkBaseDataAccessor<ZNRecord> accessor=new ZkBaseDataAccessor<ZNRecord>(_zkclient);
  Stat stat=new Stat();
  ZNRecord getRecord=accessor.get(path,stat,0);
  Assert.assertNull(getRecord);
  try {
    accessor.get(path,stat,AccessOption.THROW_EXCEPTION_IFNOTEXIST);
    Assert.fail("Should throw exception if not exist");
  }
 catch (  Exception e) {
  }
  boolean success=accessor.create(path,record,AccessOption.PERSISTENT);
  Assert.assertTrue(success);
  getRecord=accessor.get(path,stat,0);
  Assert.assertNotNull(getRecord);
  Assert.assertEquals(getRecord.getId(),"msg_0");
  Assert.assertEquals(stat.getVersion(),0);
  record.setSimpleField("key0","value0");
  success=accessor.set(path,record,AccessOption.PERSISTENT);
  Assert.assertTrue(success);
  getRecord=accessor.get(path,stat,0);
  Assert.assertNotNull(getRecord);
  Assert.assertEquals(record.getSimpleFields().size(),1);
  Assert.assertNotNull(getRecord.getSimpleField("key0"));
  Assert.assertEquals(getRecord.getSimpleField("key0"),"value0");
  Assert.assertEquals(stat.getVersion(),1);
  ZNRecord newRecord=new ZNRecord("msg_0");
  newRecord.setSimpleField("key1","value1");
  success=accessor.update(path,new ZNRecordUpdater(newRecord),AccessOption.PERSISTENT);
  Assert.assertTrue(success);
  getRecord=accessor.get(path,stat,0);
  Assert.assertNotNull(getRecord);
  Assert.assertEquals(getRecord.getSimpleFields().size(),2);
  Assert.assertNotNull(getRecord.getSimpleField("key0"));
  Assert.assertEquals(getRecord.getSimpleField("key0"),"value0");
  Assert.assertNotNull(getRecord.getSimpleField("key1"));
  Assert.assertEquals(getRecord.getSimpleField("key1"),"value1");
  Assert.assertEquals(stat.getVersion(),2);
  System.out.println("END " + testName + " at "+ new Date(System.currentTimeMillis()));
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.helix.manager.zk.TestZkClusterManager </h4><pre class="type-5 type-1 type-8 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test() public void testController() throws Exception {
  final String clusterName=TestUtil.getTestName();
  System.out.println("START " + clusterName + " at "+ new Date(System.currentTimeMillis()));
  MockController controller=new MockController(_zkaddr,clusterName,"controller");
  try {
    controller.connect();
    Assert.fail("Should throw HelixException if initial cluster structure is not setup");
  }
 catch (  HelixException e) {
  }
  TestHelper.setupEmptyCluster(_zkclient,clusterName);
  controller.connect();
  AssertJUnit.assertTrue(controller.isConnected());
  controller.connect();
  AssertJUnit.assertTrue(controller.isConnected());
  MockListener listener=new MockListener();
  listener.reset();
  try {
    controller.addControllerListener(null);
    Assert.fail("Should throw HelixException");
  }
 catch (  HelixException e) {
  }
  Builder keyBuilder=new Builder(controller.getClusterName());
  controller.addControllerListener(listener);
  AssertJUnit.assertTrue(listener.isControllerChangeListenerInvoked);
  controller.removeListener(keyBuilder.controller(),listener);
  ZkHelixPropertyStore<ZNRecord> store=controller.getHelixPropertyStore();
  ZNRecord record=new ZNRecord("node_1");
  int options=0;
  store.set("/node_1",record,AccessOption.PERSISTENT);
  Stat stat=new Stat();
  record=store.get("/node_1",stat,options);
  AssertJUnit.assertEquals("node_1",record.getId());
  controller.getMessagingService();
  controller.getClusterManagmentTool();
  controller.getConn().handleNewSession();
  controller.disconnect();
  AssertJUnit.assertFalse(controller.isConnected());
  System.out.println("END " + clusterName + " at "+ new Date(System.currentTimeMillis()));
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.helix.manager.zk.TestZkHelixAdmin </h4><pre class="type-5 type-1 type-8 type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects are null
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testAddRemoveMsgConstraint(){
  String className=TestHelper.getTestClassName();
  String methodName=TestHelper.getTestMethodName();
  String clusterName=className + "_" + methodName;
  System.out.println("START " + clusterName + " at "+ new Date(System.currentTimeMillis()));
  HelixAdmin tool=new ZKHelixAdmin(_zkclient);
  tool.addCluster(clusterName,true);
  Assert.assertTrue(ZKUtil.isClusterSetup(clusterName,_zkclient),"Cluster should be setup");
  ClusterConstraints constraints=tool.getConstraints(clusterName,ConstraintType.MESSAGE_CONSTRAINT);
  Assert.assertNull(constraints,"message-constraint should NOT exist for cluster: " + className);
  try {
    tool.removeConstraint(clusterName,ConstraintType.MESSAGE_CONSTRAINT,"constraint1");
  }
 catch (  Exception e) {
    Assert.fail("Should not throw exception when remove a non-exist constraint.");
  }
  ConstraintItemBuilder builder=new ConstraintItemBuilder();
  builder.addConstraintAttribute(ConstraintAttribute.RESOURCE.toString(),"MyDB").addConstraintAttribute(ConstraintAttribute.CONSTRAINT_VALUE.toString(),"1");
  tool.setConstraint(clusterName,ConstraintType.MESSAGE_CONSTRAINT,"constraint1",builder.build());
  HelixDataAccessor accessor=new ZKHelixDataAccessor(clusterName,new ZkBaseDataAccessor<ZNRecord>(_zkclient));
  PropertyKey.Builder keyBuilder=new PropertyKey.Builder(clusterName);
  constraints=accessor.getProperty(keyBuilder.constraint(ConstraintType.MESSAGE_CONSTRAINT.toString()));
  Assert.assertNotNull(constraints,"message-constraint should exist");
  ConstraintItem item=constraints.getConstraintItem(ConstraintId.from("constraint1"));
  Assert.assertNotNull(item,"message-constraint for constraint1 should exist");
  Assert.assertEquals(item.getConstraintValue(),"1");
  Assert.assertEquals(item.getAttributeValue(ConstraintAttribute.RESOURCE),"MyDB");
  constraints=tool.getConstraints(clusterName,ConstraintType.MESSAGE_CONSTRAINT);
  Assert.assertNotNull(constraints,"message-constraint should exist");
  item=constraints.getConstraintItem(ConstraintId.from("constraint1"));
  Assert.assertNotNull(item,"message-constraint for constraint1 should exist");
  Assert.assertEquals(item.getConstraintValue(),"1");
  Assert.assertEquals(item.getAttributeValue(ConstraintAttribute.RESOURCE),"MyDB");
  tool.removeConstraint(clusterName,ConstraintType.MESSAGE_CONSTRAINT,"constraint1");
  constraints=accessor.getProperty(keyBuilder.constraint(ConstraintType.MESSAGE_CONSTRAINT.toString()));
  Assert.assertNotNull(constraints,"message-constraint should exist");
  item=constraints.getConstraintItem(ConstraintId.from("constraint1"));
  Assert.assertNull(item,"message-constraint for constraint1 should NOT exist");
  System.out.println("END " + clusterName + " at "+ new Date(System.currentTimeMillis()));
}

</code></pre>

<br>
<pre class="type-4 type-7 type-5 type-1 type-8 type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects are null
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test() public void testZkHelixAdmin(){
  System.out.println("START testZkHelixAdmin at " + new Date(System.currentTimeMillis()));
  final String clusterName=TestUtil.getTestName();
  String rootPath="/" + clusterName;
  if (_zkclient.exists(rootPath)) {
    _zkclient.deleteRecursive(rootPath);
  }
  HelixAdmin tool=new ZKHelixAdmin(_zkclient);
  tool.addCluster(clusterName,true);
  Assert.assertTrue(ZKUtil.isClusterSetup(clusterName,_zkclient));
  tool.addCluster(clusterName,true);
  Assert.assertTrue(ZKUtil.isClusterSetup(clusterName,_zkclient));
  List<String> list=tool.getClusters();
  AssertJUnit.assertTrue(list.size() > 0);
  try {
    Stat oldstat=_zkclient.getStat(rootPath);
    Assert.assertNotNull(oldstat);
    boolean success=tool.addCluster(clusterName,false);
    Assert.assertTrue(success);
    Stat newstat=_zkclient.getStat(rootPath);
    Assert.assertEquals(oldstat,newstat);
  }
 catch (  HelixException e) {
  }
  InstanceConfig config=new InstanceConfig("host1_9999");
  config.setHostName("host1");
  config.setPort("9999");
  tool.addInstance(clusterName,config);
  tool.enableInstance(clusterName,"host1_9999",true);
  String path=PropertyPathConfig.getPath(PropertyType.INSTANCES,clusterName,"host1_9999");
  AssertJUnit.assertTrue(_zkclient.exists(path));
  try {
    tool.addInstance(clusterName,config);
    Assert.fail("should fail if add an alredy-existing instance");
  }
 catch (  HelixException e) {
  }
  config=tool.getInstanceConfig(clusterName,"host1_9999");
  AssertJUnit.assertEquals(config.getId(),"host1_9999");
  tool.dropInstance(clusterName,config);
  try {
    tool.getInstanceConfig(clusterName,"host1_9999");
    Assert.fail("should fail if get a non-existent instance");
  }
 catch (  HelixException e) {
  }
  try {
    tool.dropInstance(clusterName,config);
    Assert.fail("should fail if drop on a non-existent instance");
  }
 catch (  HelixException e) {
  }
  try {
    tool.enableInstance(clusterName,"host1_9999",false);
    Assert.fail("should fail if enable a non-existent instance");
  }
 catch (  HelixException e) {
  }
  ZNRecord stateModelRecord=new ZNRecord("id1");
  try {
    tool.addStateModelDef(clusterName,"id1",new StateModelDefinition(stateModelRecord));
    path=PropertyPathConfig.getPath(PropertyType.STATEMODELDEFS,clusterName,"id1");
    AssertJUnit.assertTrue(_zkclient.exists(path));
    Assert.fail("should fail");
  }
 catch (  HelixException e) {
  }
catch (  IllegalArgumentException ex) {
  }
  tool.addStateModelDef(clusterName,"MasterSlave",new StateModelDefinition(StateModelConfigGenerator.generateConfigForMasterSlave()));
  stateModelRecord=StateModelConfigGenerator.generateConfigForMasterSlave();
  try {
    tool.addStateModelDef(clusterName,stateModelRecord.getId(),new StateModelDefinition(stateModelRecord));
    Assert.fail("should fail if add an already-existing state model");
  }
 catch (  HelixException e) {
  }
  list=tool.getStateModelDefs(clusterName);
  AssertJUnit.assertEquals(list.size(),1);
  try {
    tool.addResource(clusterName,"resource",10,"nonexistStateModelDef");
    Assert.fail("should fail if add a resource without an existing state model");
  }
 catch (  HelixException e) {
  }
  try {
    tool.addResource(clusterName,"resource",10,"id1");
    Assert.fail("should fail");
  }
 catch (  HelixException e) {
  }
  list=tool.getResourcesInCluster(clusterName);
  AssertJUnit.assertEquals(list.size(),0);
  try {
    tool.addResource(clusterName,"resource",10,"id1");
    Assert.fail("should fail");
  }
 catch (  HelixException e) {
  }
  list=tool.getResourcesInCluster(clusterName);
  AssertJUnit.assertEquals(list.size(),0);
  ExternalView resourceExternalView=tool.getResourceExternalView(clusterName,"resource");
  AssertJUnit.assertNull(resourceExternalView);
  HelixConfigScope scope=new HelixConfigScopeBuilder(ConfigScopeProperty.PARTITION).forCluster(clusterName).forResource("testResource").forPartition("testPartition").build();
  Map<String,String> properties=new HashMap<String,String>();
  properties.put("pKey1","pValue1");
  properties.put("pKey2","pValue2");
  for (int i=0; i < 100; i++) {
    tool.setConfig(scope,properties);
    Map<String,String> newProperties=tool.getConfig(scope,new ArrayList<String>(properties.keySet()));
    Assert.assertEquals(newProperties.size(),2);
    Assert.assertEquals(newProperties.get("pKey1"),"pValue1");
    Assert.assertEquals(newProperties.get("pKey2"),"pValue2");
  }
  System.out.println("END testZkHelixAdmin at " + new Date(System.currentTimeMillis()));
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.helix.manager.zk.serializer.TestJacksonPayloadSerializer </h4><pre class="type-5 type-1 type-8 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test that the payload is not included whenever it is not null. This is mainly to maintain
 * backward
 * compatibility.
 */
@Test public void testRawPayloadMissingIfUnspecified(){
  final String RECORD_ID="testRawPayloadMissingIfUnspecified";
  ZNRecord znRecord=new ZNRecord(RECORD_ID);
  ZNRecordSerializer znRecordSerializer=new ZNRecordSerializer();
  byte[] serialized=znRecordSerializer.serialize(znRecord);
  ZNRecordStreamingSerializer znRecordStreamingSerializer=new ZNRecordStreamingSerializer();
  byte[] streamingSerialized=znRecordStreamingSerializer.serialize(znRecord);
  ObjectMapper mapper=new ObjectMapper();
  try {
    JsonNode jsonNode=mapper.readTree(new String(serialized));
    Assert.assertFalse(jsonNode.has("rawPayload"));
    JsonNode streamingJsonNode=mapper.readTree(new String(streamingSerialized));
    Assert.assertFalse(streamingJsonNode.has("rawPayload"));
  }
 catch (  JsonProcessingException e) {
    Assert.fail();
  }
catch (  IOException e) {
    Assert.fail();
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.helix.model.TestStateModelValidity </h4><pre class="type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * There should be an initial state, otherwise instantiation should fail
 */
@Test public void testNoInitialState(){
  try {
    new StateModelDefinition.Builder("stateModel").addState("OFFLINE").addState("MASTER").addState("SLAVE").addState("DROPPED").addTransition("OFFLINE","SLAVE").addTransition("SLAVE","MASTER").addTransition("SLAVE","OFFLINE").addTransition("OFFLINE","DROPPED").addTransition("MASTER","SLAVE").build();
    Assert.fail("StateModelDefinition creation should fail if no initial state");
  }
 catch (  IllegalArgumentException e) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.helix.model.builder.TestIdealStateBuilder </h4><pre class="type-5 type-1 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testCustomModeISBuilder(){
  CustomModeISBuilder builder=new CustomModeISBuilder("test-db");
  builder.setStateModel("MasterSlave").setNumPartitions(2).setNumReplica(2);
  builder.assignInstanceAndState("test-db_0","node_0","MASTER").assignInstanceAndState("test-db_0","node_1","SLAVE").assignInstanceAndState("test-db_1","node_0","SLAVE").assignInstanceAndState("test-db_1","node_1","MASTER");
  IdealState idealState=null;
  try {
    idealState=builder.build();
  }
 catch (  Exception e) {
    Assert.fail("fail to build a custom mode ideal-state.",e);
  }
  Assert.assertEquals(idealState.getRebalanceMode(),IdealState.RebalanceMode.CUSTOMIZED,"rebalancer mode should be customized");
}

</code></pre>

<br>
<pre class="type-5 type-1 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testAutoISBuilder(){
  AutoModeISBuilder builder=new AutoModeISBuilder("test-db");
  builder.setStateModel("MasterSlave").setNumPartitions(2).setNumReplica(2);
  builder.assignPreferenceList("test-db_0","node_0","node_1").assignPreferenceList("test-db_1","node_1","node_0");
  IdealState idealState=null;
  try {
    idealState=builder.build();
  }
 catch (  Exception e) {
    Assert.fail("fail to build an auto mode ideal-state.",e);
  }
  Assert.assertEquals(idealState.getRebalanceMode(),IdealState.RebalanceMode.SEMI_AUTO,"rebalancer mode should be semi-auto");
}

</code></pre>

<br>
<pre class="type-5 type-1 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testAutoRebalanceISModeBuilder(){
  AutoRebalanceModeISBuilder builder=new AutoRebalanceModeISBuilder("test-db");
  builder.setStateModel("MasterSlave").setNumPartitions(2).setNumReplica(2);
  builder.add("test-db_0").add("test-db_1");
  IdealState idealState=null;
  try {
    idealState=builder.build();
  }
 catch (  Exception e) {
    Assert.fail("fail to build an auto-rebalance mode ideal-state.",e);
  }
  Assert.assertEquals(idealState.getRebalanceMode(),IdealState.RebalanceMode.FULL_AUTO,"rebalancer mode should be auto");
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.helix.monitoring.mbeans.TestClusterStatusMonitor </h4><pre class="type-7 type-5 type-1 type-8 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test() public void testReportData() throws Exception {
  String className=TestHelper.getTestClassName();
  String methodName=TestHelper.getTestMethodName();
  String clusterName=className + "_" + methodName;
  int n=5;
  String testDB="TestDB";
  String testDB_0=testDB + "_0";
  System.out.println("START " + clusterName + " at "+ new Date(System.currentTimeMillis()));
  ClusterStatusMonitor monitor=new ClusterStatusMonitor(clusterName);
  ObjectName clusterMonitorObjName=monitor.getObjectName(monitor.clusterBeanName());
  try {
    _server.getMBeanInfo(clusterMonitorObjName);
  }
 catch (  Exception e) {
    Assert.fail("Fail to register ClusterStatusMonitor");
  }
  BestPossibleStateOutput bestPossibleStates=new BestPossibleStateOutput();
  ResourceAssignment assignment=new ResourceAssignment(ResourceId.from(testDB));
  Map<ParticipantId,State> replicaMap=Maps.newHashMap();
  replicaMap.put(ParticipantId.from("localhost_12918"),State.from("MASTER"));
  replicaMap.put(ParticipantId.from("localhost_12919"),State.from("SLAVE"));
  replicaMap.put(ParticipantId.from("localhost_12920"),State.from("SLAVE"));
  replicaMap.put(ParticipantId.from("localhost_12921"),State.from("OFFLINE"));
  replicaMap.put(ParticipantId.from("localhost_12922"),State.from("DROPPED"));
  assignment.addReplicaMap(PartitionId.from(testDB_0),replicaMap);
  bestPossibleStates.setResourceAssignment(ResourceId.from(testDB),assignment);
  Map<String,InstanceConfig> instanceConfigMap=Maps.newHashMap();
  for (int i=0; i < n; i++) {
    String instanceName="localhost_" + (12918 + i);
    InstanceConfig config=new InstanceConfig(instanceName);
    instanceConfigMap.put(instanceName,config);
  }
  Map<ResourceId,ResourceConfig> resourceMap=Maps.newHashMap();
  ResourceId resourceId=ResourceId.from(testDB);
  AutoModeISBuilder idealStateBuilder=new AutoModeISBuilder(resourceId).add(testDB_0);
  idealStateBuilder.setStateModel("MasterSlave");
  IdealState idealState=idealStateBuilder.build();
  ResourceConfig resourceConfig=new ResourceConfig.Builder(resourceId).idealState(idealState).build();
  resourceMap.put(resourceId,resourceConfig);
  Map<String,StateModelDefinition> stateModelDefMap=Maps.newHashMap();
  StateModelDefinition msStateModelDef=new StateModelDefinition(StateModelConfigGenerator.generateConfigForMasterSlave());
  stateModelDefMap.put("MasterSlave",msStateModelDef);
  monitor.setPerInstanceResourceStatus(bestPossibleStates,instanceConfigMap,resourceMap,stateModelDefMap);
  ObjectName objName=monitor.getObjectName(monitor.getPerInstanceResourceBeanName("localhost_12918",testDB));
  Object value=_server.getAttribute(objName,"PartitionGauge");
  Assert.assertTrue(value instanceof Long);
  Assert.assertEquals((Long)value,new Long(1));
  value=_server.getAttribute(objName,"SensorName");
  Assert.assertTrue(value instanceof String);
  Assert.assertEquals((String)value,String.format("%s.%s.%s.%s.%s",ClusterStatusMonitor.PARTICIPANT_STATUS_KEY,clusterName,ClusterStatusMonitor.DEFAULT_TAG,"localhost_12918",testDB));
  objName=monitor.getObjectName(monitor.getPerInstanceResourceBeanName("localhost_12919",testDB));
  value=_server.getAttribute(objName,"PartitionGauge");
  Assert.assertTrue(value instanceof Long);
  Assert.assertEquals((Long)value,new Long(1));
  objName=monitor.getObjectName(monitor.getPerInstanceResourceBeanName("localhost_12921",testDB));
  value=_server.getAttribute(objName,"PartitionGauge");
  Assert.assertTrue(value instanceof Long);
  Assert.assertEquals((Long)value,new Long(0));
  objName=monitor.getObjectName(monitor.getPerInstanceResourceBeanName("localhost_12922",testDB));
  value=_server.getAttribute(objName,"PartitionGauge");
  Assert.assertTrue(value instanceof Long);
  Assert.assertEquals((Long)value,new Long(0));
  replicaMap.remove(ParticipantId.from("localhost_12918"));
  assignment.addReplicaMap(PartitionId.from(testDB_0),replicaMap);
  bestPossibleStates.setResourceAssignment(ResourceId.from(testDB),assignment);
  monitor.setPerInstanceResourceStatus(bestPossibleStates,instanceConfigMap,resourceMap,stateModelDefMap);
  try {
    objName=monitor.getObjectName(monitor.getPerInstanceResourceBeanName("localhost_12918",testDB));
    _server.getMBeanInfo(objName);
    Assert.fail("Fail to unregister PerInstanceResource mbean for localhost_12918");
  }
 catch (  InstanceNotFoundException e) {
  }
  monitor.reset();
  try {
    objName=monitor.getObjectName(monitor.getPerInstanceResourceBeanName("localhost_12920",testDB));
    _server.getMBeanInfo(objName);
    Assert.fail("Fail to unregister PerInstanceResource mbean for localhost_12920");
  }
 catch (  InstanceNotFoundException e) {
  }
  try {
    _server.getMBeanInfo(clusterMonitorObjName);
    Assert.fail("Fail to unregister ClusterStatusMonitor");
  }
 catch (  InstanceNotFoundException e) {
  }
  System.out.println("END " + clusterName + " at "+ new Date(System.currentTimeMillis()));
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.helix.store.zk.TestZkHelixPropertyStore </h4><pre class="type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testSetInvalidPath(){
  String subRoot=_root + "/" + "setInvalidPath";
  ZkHelixPropertyStore<ZNRecord> store=new ZkHelixPropertyStore<ZNRecord>(new ZkBaseDataAccessor<ZNRecord>(_zkclient),subRoot,null);
  try {
    store.set("abc/xyz",new ZNRecord("testInvalid"),AccessOption.PERSISTENT);
    Assert.fail("Should throw illegal-argument-exception since path doesn't start with /");
  }
 catch (  IllegalArgumentException e) {
  }
catch (  Exception e) {
    Assert.fail("Should not throw exceptions other than illegal-argument");
  }
}

</code></pre>

<br>
<pre class="type-5 type-1 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testBackToBackRemoveAndSet() throws Exception {
  System.out.println("START testBackToBackRemoveAndSet() at " + new Date(System.currentTimeMillis()));
  String subRoot=_root + "/" + "backToBackRemoveAndSet";
  List<String> subscribedPaths=new ArrayList<String>();
  subscribedPaths.add(subRoot);
  ZkHelixPropertyStore<ZNRecord> store=new ZkHelixPropertyStore<ZNRecord>(new ZkBaseDataAccessor<ZNRecord>(_zkclient),subRoot,subscribedPaths);
  store.set("/child0",new ZNRecord("child0"),AccessOption.PERSISTENT);
  ZNRecord record=store.get("/child0",null,0);
  Assert.assertEquals(record.getId(),"child0");
  String child0Path=subRoot + "/child0";
  for (int i=0; i < 2; i++) {
    _zkclient.delete(child0Path);
    _zkclient.createPersistent(child0Path,new ZNRecord("child0-new-" + i));
  }
  Thread.sleep(500);
  record=store.get("/child0",null,0);
  Assert.assertEquals(record.getId(),"child0-new-1","Cache shoulde be updated to latest create");
  _zkclient.delete(child0Path);
  Thread.sleep(500);
  try {
    record=store.get("/child0",null,AccessOption.THROW_EXCEPTION_IFNOTEXIST);
    Assert.fail("/child0 should have been removed");
  }
 catch (  ZkNoNodeException e) {
  }
  store.stop();
  System.out.println("END testBackToBackRemoveAndSet() at " + new Date(System.currentTimeMillis()));
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.helix.tools.TestClusterSetup </h4><pre class="type-5 type-1 type-8 type-2 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testDropInstance() throws Exception {
  String className=TestHelper.getTestClassName();
  String methodName=TestHelper.getTestMethodName();
  String clusterName=className + "_" + methodName;
  System.out.println("START " + clusterName + " at "+ new Date(System.currentTimeMillis()));
  TestHelper.setupCluster(clusterName,_zkaddr,12918,"localhost","TestDB",1,10,5,3,"MasterSlave",true);
  ZKHelixDataAccessor accessor=new ZKHelixDataAccessor(clusterName,new ZkBaseDataAccessor<ZNRecord>(_zkclient));
  Builder keyBuilder=new Builder(clusterName);
  LiveInstance liveInstance=new LiveInstance("localhost_12918");
  liveInstance.setSessionId("session_0");
  liveInstance.setHelixVersion("version_0");
  accessor.setProperty(keyBuilder.liveInstance("localhost_12918"),liveInstance);
  try {
    ClusterSetup.processCommandLineArgs(new String[]{"--zkSvr",_zkaddr,"--dropNode",clusterName,"localhost:12918"});
    Assert.fail("Should throw exception since localhost_12918 is still in LIVEINSTANCES/");
  }
 catch (  Exception e) {
  }
  accessor.removeProperty(keyBuilder.liveInstance("localhost_12918"));
  try {
    ClusterSetup.processCommandLineArgs(new String[]{"--zkSvr",_zkaddr,"--dropNode",clusterName,"localhost:12918"});
    Assert.fail("Should throw exception since localhost_12918 is enabled");
  }
 catch (  Exception e) {
  }
  ClusterSetup.processCommandLineArgs(new String[]{"--zkSvr",_zkaddr,"--enableInstance",clusterName,"localhost_12918","false"});
  ClusterSetup.processCommandLineArgs(new String[]{"--zkSvr",_zkaddr,"--dropNode",clusterName,"localhost:12918"});
  Assert.assertNull(accessor.getProperty(keyBuilder.instanceConfig("localhost_12918")),"Instance config should be dropped");
  Assert.assertFalse(_zkclient.exists(PropertyPathConfig.getPath(PropertyType.INSTANCES,clusterName,"localhost_12918")),"Instance/host should be dropped");
  System.out.println("END " + clusterName + " at "+ new Date(System.currentTimeMillis()));
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.helix.tools.TestHelixAdminCli </h4><pre class="type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testAddResource() throws Exception {
  String className=TestHelper.getTestClassName();
  String methodName=TestHelper.getTestMethodName();
  String clusterName=className + "_" + methodName;
  System.out.println("START " + clusterName + " at "+ new Date(System.currentTimeMillis()));
  String command="-zkSvr localhost:2183 -addCluster " + clusterName;
  ClusterSetup.processCommandLineArgs(command.split("\\s+"));
  command="-zkSvr localhost:2183 -addResource " + clusterName + " db_22 144 MasterSlave";
  ClusterSetup.processCommandLineArgs(command.split("\\s+"));
  command="-zkSvr localhost:2183 -addResource " + clusterName + " db_11 44 MasterSlave";
  ClusterSetup.processCommandLineArgs(command.split("\\s+"));
  command="-zkSvr localhost:2183 -addResource " + clusterName + " db_22 55 OnlineOffline";
  try {
    ClusterSetup.processCommandLineArgs(command.split("\\s+"));
    Assert.fail("ClusterSetup should fail since resource db_22 already exists");
  }
 catch (  Exception e) {
  }
  command="-zkSvr localhost:2183 -dropResource " + clusterName + " db_11 ";
  ClusterSetup.processCommandLineArgs(command.split("\\s+"));
  System.out.println("END " + clusterName + " at "+ new Date(System.currentTimeMillis()));
}

</code></pre>

<br>
<pre class="type-5 type-1 type-8 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testDeactivateCluster() throws Exception {
  String className=TestHelper.getTestClassName();
  String methodName=TestHelper.getTestMethodName();
  String clusterName=className + "_" + methodName;
  String grandClusterName=clusterName + "_grand";
  final int n=6;
  System.out.println("START " + clusterName + " at "+ new Date(System.currentTimeMillis()));
  MockParticipant[] participants=new MockParticipant[n];
  MockMultiClusterController[] controllers=new MockMultiClusterController[2];
  setupCluster(clusterName,grandClusterName,n,participants,controllers);
  String command="-zkSvr " + _zkaddr + " -activateCluster "+ clusterName+ " "+ grandClusterName+ " true";
  ClusterSetup.processCommandLineArgs(command.split("\\s+"));
  Thread.sleep(500);
  command="-zkSvr " + _zkaddr + " -activateCluster "+ clusterName+ " "+ grandClusterName+ " false";
  ClusterSetup.processCommandLineArgs(command.split("\\s+"));
  BaseDataAccessor<ZNRecord> baseAccessor=new ZkBaseDataAccessor<ZNRecord>(_zkclient);
  HelixDataAccessor accessor=new ZKHelixDataAccessor(clusterName,baseAccessor);
  String path=accessor.keyBuilder().controllerLeader().getPath();
  for (int i=0; i < 10; i++) {
    Thread.sleep(1000);
    if (!_zkclient.exists(path)) {
      break;
    }
  }
  Assert.assertFalse(_zkclient.exists(path),"leader should be gone after deactivate the cluster");
  command="-zkSvr " + _zkaddr + " -dropCluster "+ clusterName;
  try {
    ClusterSetup.processCommandLineArgs(command.split("\\s+"));
    Assert.fail("dropCluster should fail since there are still instances running");
  }
 catch (  Exception e) {
  }
  for (int i=0; i < participants.length; i++) {
    participants[i].syncStop();
  }
  command="-zkSvr localhost:2183 -dropCluster " + clusterName;
  ClusterSetup.processCommandLineArgs(command.split("\\s"));
  for (int i=0; i < controllers.length; i++) {
    controllers[i].syncStop();
  }
  command="-zkSvr localhost:2183 -dropCluster " + grandClusterName;
  ClusterSetup.processCommandLineArgs(command.split("\\s+"));
  System.out.println("END " + clusterName + " at "+ new Date(System.currentTimeMillis()));
}

</code></pre>

<br>
<pre class="type-5 type-1 type-8 type-2 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testStartCluster() throws Exception {
  String className=TestHelper.getTestClassName();
  String methodName=TestHelper.getTestMethodName();
  String clusterName=className + "_" + methodName;
  String grandClusterName=clusterName + "_grand";
  final int n=6;
  System.out.println("START " + clusterName + " at "+ new Date(System.currentTimeMillis()));
  MockParticipant[] participants=new MockParticipant[n];
  MockMultiClusterController[] controllers=new MockMultiClusterController[2];
  setupCluster(clusterName,grandClusterName,n,participants,controllers);
  String command="-zkSvr localhost:2183 -activateCluster " + clusterName + " nonExistGrandCluster true";
  try {
    ClusterSetup.processCommandLineArgs(command.split("\\s+"));
    Assert.fail("add " + clusterName + " to grandCluster should fail since grandCluster doesn't exists");
  }
 catch (  Exception e) {
  }
  command="-zkSvr localhost:2183 -activateCluster nonExistCluster " + grandClusterName + " true";
  try {
    ClusterSetup.processCommandLineArgs(command.split("\\s+"));
    Assert.fail("add nonExistCluster to " + grandClusterName + " should fail since nonExistCluster doesn't exists");
  }
 catch (  Exception e) {
  }
  command="-zkSvr localhost:2183 -activateCluster " + clusterName + " "+ grandClusterName+ " true";
  ClusterSetup.processCommandLineArgs(command.split("\\s+"));
  Thread.sleep(500);
  command="-zkSvr localhost:2183 -dropCluster " + clusterName;
  try {
    ClusterSetup.processCommandLineArgs(command.split("\\s+"));
    Assert.fail("drop " + clusterName + " should fail since it's still running");
  }
 catch (  Exception e) {
  }
  BaseDataAccessor<ZNRecord> baseAccessor=new ZkBaseDataAccessor<ZNRecord>(_zkclient);
  HelixDataAccessor accessor=new ZKHelixDataAccessor(grandClusterName,baseAccessor);
  LiveInstance controllerLeader=accessor.getProperty(accessor.keyBuilder().controllerLeader());
  Assert.assertNotNull(controllerLeader,"controllerLeader should be either controller_9000 or controller_9001");
  Assert.assertTrue(controllerLeader.getInstanceName().startsWith("controller_900"));
  accessor=new ZKHelixDataAccessor(clusterName,baseAccessor);
  LiveInstance leader=accessor.getProperty(accessor.keyBuilder().controllerLeader());
  for (int i=0; i < 20; i++) {
    if (leader != null) {
      break;
    }
    Thread.sleep(200);
    leader=accessor.getProperty(accessor.keyBuilder().controllerLeader());
  }
  Assert.assertTrue(leader.getInstanceName().startsWith("controller_900"));
  boolean verifyResult=ClusterStateVerifier.verifyByZkCallback(new MasterNbInExtViewVerifier(_zkaddr,clusterName));
  Assert.assertTrue(verifyResult);
  verifyResult=ClusterStateVerifier.verifyByZkCallback(new BestPossAndExtViewZkVerifier(_zkaddr,clusterName));
  Assert.assertTrue(verifyResult);
  for (  MockMultiClusterController controller : controllers) {
    controller.syncStop();
  }
  for (int i=0; i < participants.length; i++) {
    participants[i].syncStop();
  }
  System.out.println("END " + clusterName + " at "+ new Date(System.currentTimeMillis()));
}

</code></pre>

<br>
<pre class="type-5 type-8 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testAddCluster() throws Exception {
  String command="--zkSvr " + _zkaddr + " -addCluster clusterTest";
  ClusterSetup.processCommandLineArgs(command.split("\\s+"));
  command="--zkSvr " + _zkaddr + " -addCluster /ClusterTest";
  try {
    ClusterSetup.processCommandLineArgs(command.split("\\s+"));
    Assert.fail("ClusterSetup should fail since /ClusterTest is not a valid name");
  }
 catch (  Exception e) {
  }
  command="--zkSvr " + _zkaddr + " -addCluster \"Klazt3rz";
  ClusterSetup.processCommandLineArgs(command.split("\\s+"));
  command="--zkSvr " + _zkaddr + " -addCluster \\ClusterTest";
  ClusterSetup.processCommandLineArgs(command.split("\\s+"));
  command="--zkSvr " + _zkaddr + " -addCluster clusterTest";
  try {
    ClusterSetup.processCommandLineArgs(command.split("\\s+"));
    Assert.fail("ClusterSetup should fail since clusterTest already exists");
  }
 catch (  Exception e) {
  }
  Assert.assertTrue(ZKUtil.isClusterSetup("Klazt3rz",_zkclient));
  Assert.assertTrue(ZKUtil.isClusterSetup("clusterTest",_zkclient));
  Assert.assertTrue(ZKUtil.isClusterSetup("\\ClusterTest",_zkclient));
  command="-zkSvr localhost:2183 -dropCluster \\ClusterTest";
  ClusterSetup.processCommandLineArgs(command.split("\\s+"));
  command="-zkSvr localhost:2183 -dropCluster clusterTest1";
  ClusterSetup.processCommandLineArgs(command.split("\\s+"));
  command="-zkSvr localhost:2183 -dropCluster clusterTest";
  ClusterSetup.processCommandLineArgs(command.split("\\s+"));
  Assert.assertFalse(_zkclient.exists("/clusterTest"));
  Assert.assertFalse(_zkclient.exists("/\\ClusterTest"));
  Assert.assertFalse(_zkclient.exists("/clusterTest1"));
}

</code></pre>

<br>
<pre class="type-5 type-1 type-8 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testInstanceOperations() throws Exception {
  String className=TestHelper.getTestClassName();
  String methodName=TestHelper.getTestMethodName();
  String clusterName=className + "_" + methodName;
  String grandClusterName=clusterName + "_grand";
  final int n=6;
  System.out.println("START " + clusterName + " at "+ new Date(System.currentTimeMillis()));
  MockParticipant[] participants=new MockParticipant[n];
  MockMultiClusterController[] controllers=new MockMultiClusterController[2];
  setupCluster(clusterName,grandClusterName,n,participants,controllers);
  String command="-zkSvr " + _zkaddr + " -activateCluster "+ clusterName+ " "+ grandClusterName+ " true";
  ClusterSetup.processCommandLineArgs(command.split("\\s+"));
  Thread.sleep(500);
  command="-zkSvr " + _zkaddr + " -dropNode "+ clusterName+ " localhost:1232";
  try {
    ClusterSetup.processCommandLineArgs(command.split("\\s+"));
    Assert.fail("dropNode should fail since the node is not disabled");
  }
 catch (  Exception e) {
  }
  command="-zkSvr " + _zkaddr + " -enableInstance "+ clusterName+ " localhost:1232 false";
  ClusterSetup.processCommandLineArgs(command.split("\\s+"));
  command="-zkSvr " + _zkaddr + " -dropNode "+ clusterName+ " localhost:1232";
  try {
    ClusterSetup.processCommandLineArgs(command.split("\\s+"));
    Assert.fail("dropNode should fail since the node is not disconnected");
  }
 catch (  Exception e) {
  }
  command="-zkSvr " + _zkaddr + " -swapInstance "+ clusterName+ " localhost_1232 localhost_12320";
  try {
    ClusterSetup.processCommandLineArgs(command.split("\\s+"));
    Assert.fail("swapInstance should fail since the node is not disconnected");
  }
 catch (  Exception e) {
  }
  participants[2].syncStop();
  command="-zkSvr " + _zkaddr + " -addNode "+ clusterName+ " localhost:12320";
  ClusterSetup.processCommandLineArgs(command.split("\\s+"));
  command="-zkSvr " + _zkaddr + " -swapInstance "+ clusterName+ " localhost_1232 localhost_12320";
  ClusterSetup.processCommandLineArgs(command.split("\\s+"));
  BaseDataAccessor<ZNRecord> baseAccessor=new ZkBaseDataAccessor<ZNRecord>(_zkclient);
  HelixDataAccessor accessor=new ZKHelixDataAccessor(clusterName,baseAccessor);
  String path=accessor.keyBuilder().instanceConfig("localhost_1232").getPath();
  Assert.assertFalse(_zkclient.exists(path),path + " should not exist since localhost_1232 has been swapped by localhost_12320");
  for (int i=0; i < controllers.length; i++) {
    controllers[i].syncStop();
  }
  for (int i=0; i < participants.length; i++) {
    participants[i].syncStop();
  }
  System.out.println("END " + clusterName + " at "+ new Date(System.currentTimeMillis()));
}

</code></pre>

<br>
<pre class="type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testAddInstance() throws Exception {
  String className=TestHelper.getTestClassName();
  String methodName=TestHelper.getTestMethodName();
  String clusterName=className + "_" + methodName;
  System.out.println("START " + clusterName + " at "+ new Date(System.currentTimeMillis()));
  String command="-zkSvr localhost:2183 -addCluster " + clusterName;
  ClusterSetup.processCommandLineArgs(command.split("\\s+"));
  for (int i=0; i < 3; i++) {
    command="-zkSvr localhost:2183 -addNode " + clusterName + " localhost:123"+ i;
    ClusterSetup.processCommandLineArgs(command.split("\\s+"));
  }
  command="-zkSvr localhost:2183 -addNode " + clusterName + " localhost:1233;localhost:1234;localhost:1235;localhost:1236";
  ClusterSetup.processCommandLineArgs(command.split("\\s+"));
  command="-zkSvr localhost:2183 -dropNode " + clusterName + " localhost:1236";
  try {
    ClusterSetup.processCommandLineArgs(command.split("\\s+"));
    Assert.fail("delete node localhost:1236 should fail since it's not disabled");
  }
 catch (  Exception e) {
  }
  command="-zkSvr localhost:2183 -dropNode " + clusterName + " localhost:12367";
  try {
    ClusterSetup.processCommandLineArgs(command.split("\\s+"));
    Assert.fail("delete node localhost:1237 should fail since it doesn't exist");
  }
 catch (  Exception e) {
  }
  command="-zkSvr localhost:2183 -enableInstance " + clusterName + " localhost:1236 false";
  ClusterSetup.processCommandLineArgs(command.split("\\s+"));
  command="-zkSvr localhost:2183 -dropNode " + clusterName + " localhost:1236";
  ClusterSetup.processCommandLineArgs(command.split("\\s+"));
  command="-zkSvr localhost:2183 -addNode " + clusterName + " localhost:1234";
  try {
    ClusterSetup.processCommandLineArgs(command.split("\\s+"));
    Assert.fail("add node localhost:1234 should fail since it already exists");
  }
 catch (  Exception e) {
  }
  System.out.println("END " + clusterName + " at "+ new Date(System.currentTimeMillis()));
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.helix.util.TestZKClientPool </h4><pre class="type-7 type-5 type-1 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void test() throws Exception {
  String testName="TestZKClientPool";
  System.out.println("START " + testName + " at "+ new Date(System.currentTimeMillis()));
  String zkAddr="localhost:2189";
  ZkServer zkServer=TestHelper.startZkServer(zkAddr);
  ZkClient zkClient=ZKClientPool.getZkClient(zkAddr);
  zkClient.createPersistent("/" + testName,new ZNRecord(testName));
  ZNRecord record=zkClient.readData("/" + testName);
  Assert.assertEquals(record.getId(),testName);
  TestHelper.stopZkServer(zkServer);
  zkServer=TestHelper.startZkServer(zkAddr);
  try {
    zkClient=ZKClientPool.getZkClient(zkAddr);
    record=zkClient.readData("/" + testName);
    Assert.fail("should fail on zk no node exception");
  }
 catch (  ZkNoNodeException e) {
  }
catch (  Exception e) {
    Assert.fail("should not fail on exception other than ZkNoNodeException");
  }
  zkClient.createPersistent("/" + testName,new ZNRecord(testName));
  record=zkClient.readData("/" + testName);
  Assert.assertEquals(record.getId(),testName);
  zkClient.close();
  TestHelper.stopZkServer(zkServer);
  System.out.println("END " + testName + " at "+ new Date(System.currentTimeMillis()));
}

</code></pre>

<br>
<script>$(document).ready(function() {
  $('pre code').each(function(i, block) {
    hljs.highlightBlock(block);
  });
});</script>
