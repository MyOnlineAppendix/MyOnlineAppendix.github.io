<h3 style="margin:0px">Class: org.apache.ambari.server.actionmanager.TestActionScheduler (25 methods) </h3><br><pre style="padding:0"><code class="html"><div id="tags"><button id="1"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('1')" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value "><kbd id="tag-1"class="label-info"style="display: inline-block;font-size:7pt" >EqualityVerifier&nbsp;(20)</kbd></button>&nbsp;<button id="2"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('2')" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls"><kbd id="tag-2"class="label-info"style="display: inline-block;font-size:7pt" >InternalCallVerifier&nbsp;(7)</kbd></button>&nbsp;<button id="5"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('5')" data-toggle="tooltip" title="Verifies boolean conditions"><kbd id="tag-5"class="label-info"style="display: inline-block;font-size:7pt" >BooleanVerifier&nbsp;(5)</kbd></button>&nbsp;<button id="3"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('3')" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes"><kbd id="tag-3"class="label-info"style="display: inline-block;font-size:7pt" >HybridVerifier&nbsp;(4)</kbd></button>&nbsp;<button id="4"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('4')" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) "><kbd id="tag-4"class="label-info"style="display: inline-block;font-size:7pt" >APIUtilityVerifier&nbsp;(4)</kbd></button>&nbsp;<button id="7"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('7')" data-toggle="tooltip" title="Allocates resources before the execution of the test cases"><kbd id="tag-7"class="label-info"style="display: inline-block;font-size:7pt" >TestInitializer&nbsp;(1)</kbd></button>&nbsp;<button id="8"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('8')" data-toggle="tooltip" title="Releases resources used by the test cases"><kbd id="tag-8"class="label-info"style="display: inline-block;font-size:7pt" >TestCleaner&nbsp;(1)</kbd></button>&nbsp;<button id="12"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('12')" data-toggle="tooltip" title="Verifies assertions in iterations"><kbd id="tag-12"class="label-info"style="display: inline-block;font-size:7pt" >IterativeVerifier&nbsp;(1)</kbd></button>&nbsp;<button id="9"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('9')" data-toggle="tooltip" title="Executes methods or other tests from the same test unit"><kbd id="tag-9"class="label-info"style="display: inline-block;font-size:7pt" >ExecutionTester&nbsp;(1)</kbd></button>&nbsp;<button id="11"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('11')" data-toggle="tooltip" title="Verifies whether objects are null"><kbd id="tag-11"class="label-info"style="display: inline-block;font-size:7pt" >NullVerifier&nbsp;(1)</kbd></button>&nbsp;</div></code></pre><center><button onclick="showBlocks()" style="margin:6px">Update filter <span class="glyphicon glyphicon-refresh" aria-hidden="true"></span> </button></center><br>
<pre class="type-7 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Allocates resources before the execution of the test cases">TestInitializer</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Allocates resources before the execution of the test cases
"></span><br>
@Before public void setup() throws Exception {
  injector=Guice.createInjector(new InMemoryDefaultTestModule());
  injector.getInstance(GuiceJpaInitializer.class);
  injector.injectMembers(this);
}

</code></pre>

<pre class="type-9 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test public void testAbortHolding(){
  UnitOfWork unitOfWork=EasyMock.createMock(UnitOfWork.class);
  ActionDBAccessor db=EasyMock.createMock(ActionDBAccessor.class);
  ActionQueue aq=new ActionQueue();
  Clusters fsm=EasyMock.createMock(Clusters.class);
  Configuration conf=new Configuration(new Properties());
  HostEntity hostEntity1=new HostEntity();
  hostEntity1.setHostName("h1");
  hostDAO.merge(hostEntity1);
  db.abortHostRole("h1",-1L,-1L,"AMBARI_SERVER_ACTION");
  EasyMock.expectLastCall();
  EasyMock.replay(db);
  ActionScheduler scheduler=new ActionScheduler(100,50,db,aq,fsm,3,new HostsMap((String)null),unitOfWork,null,conf);
  HostRoleCommand hrc1=hostRoleCommandFactory.create("h1",Role.NAMENODE,null,RoleCommand.EXECUTE);
  hrc1.setStatus(HostRoleStatus.COMPLETED);
  HostRoleCommand hrc3=hostRoleCommandFactory.create("h1",Role.AMBARI_SERVER_ACTION,null,RoleCommand.CUSTOM_COMMAND);
  hrc3.setStatus(HostRoleStatus.HOLDING);
  HostRoleCommand hrc4=hostRoleCommandFactory.create("h1",Role.FLUME_HANDLER,null,RoleCommand.EXECUTE);
  hrc4.setStatus(HostRoleStatus.PENDING);
  List<HostRoleCommand> hostRoleCommands=Arrays.asList(hrc1,hrc3,hrc4);
  scheduler.cancelHostRoleCommands(hostRoleCommands,"foo");
  EasyMock.verify(db);
}

</code></pre>

<pre class="type-1 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies whether objects/variable are equal to an expected value 
"></span><br>
@Test public void testServerActionWOService() throws Exception {
  ActionQueue aq=new ActionQueue();
  Properties properties=new Properties();
  Configuration conf=new Configuration(properties);
  Clusters fsm=mock(Clusters.class);
  UnitOfWork unitOfWork=mock(UnitOfWork.class);
  List<Stage> stages=new ArrayList<Stage>();
  Map<String,String> payload=new HashMap<String,String>();
  final Stage s=getStageWithServerAction(1,977,payload,"test",300);
  stages.add(s);
  ActionDBAccessor db=mock(ActionDBAccessor.class);
  RequestEntity request=mock(RequestEntity.class);
  when(request.isExclusive()).thenReturn(false);
  when(db.getRequestEntity(anyLong())).thenReturn(request);
  when(db.getCommandsInProgressCount()).thenReturn(stages.size());
  when(db.getStagesInProgress()).thenReturn(stages);
  doAnswer(new Answer<Void>(){
    @Override public Void answer(    InvocationOnMock invocation) throws Throwable {
      String host=(String)invocation.getArguments()[0];
      String role=(String)invocation.getArguments()[3];
      CommandReport commandReport=(CommandReport)invocation.getArguments()[4];
      HostRoleCommand command=null;
      if (null == host) {
        command=s.getHostRoleCommand(null,role);
      }
 else {
        command=s.getHostRoleCommand(host,role);
      }
      command.setStatus(HostRoleStatus.valueOf(commandReport.getStatus()));
      return null;
    }
  }
).when(db).updateHostRoleState(anyString(),anyLong(),anyLong(),anyString(),any(CommandReport.class));
  doAnswer(new Answer<List<HostRoleCommand>>(){
    @Override public List<HostRoleCommand> answer(    InvocationOnMock invocation) throws Throwable {
      String role=(String)invocation.getArguments()[1];
      HostRoleStatus status=(HostRoleStatus)invocation.getArguments()[2];
      HostRoleCommand task=s.getHostRoleCommand(null,role);
      if (task.getStatus() == status) {
        return Arrays.asList(task);
      }
 else {
        return Collections.emptyList();
      }
    }
  }
).when(db).getTasksByHostRoleAndStatus(anyString(),anyString(),any(HostRoleStatus.class));
  doAnswer(new Answer<HostRoleCommand>(){
    @Override public HostRoleCommand answer(    InvocationOnMock invocation) throws Throwable {
      return s.getHostRoleCommand(null,"AMBARI_SERVER_ACTION");
    }
  }
).when(db).getTask(anyLong());
  ServerActionExecutor.init(injector);
  ActionScheduler scheduler=new ActionScheduler(100,50,db,aq,fsm,3,new HostsMap((String)null),unitOfWork,null,conf);
  int cycleCount=0;
  while (!stages.get(0).getHostRoleStatus(null,"AMBARI_SERVER_ACTION").equals(HostRoleStatus.COMPLETED) && cycleCount++ <= MAX_CYCLE_ITERATIONS) {
    scheduler.doWork();
    scheduler.getServerActionExecutor().doWork();
  }
  assertEquals(stages.get(0).getHostRoleStatus(null,"AMBARI_SERVER_ACTION"),HostRoleStatus.COMPLETED);
}

</code></pre>

<pre class="type-1 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies whether objects/variable are equal to an expected value 
"></span><br>
/** 
 * Verifies that stages that are executed on different hosts and
 * rely to different requests are scheduled to be  executed in parallel
 */
@Test public void testIndependentStagesExecution() throws Exception {
  ActionQueue aq=new ActionQueue();
  Clusters fsm=mock(Clusters.class);
  Cluster oneClusterMock=mock(Cluster.class);
  Service serviceObj=mock(Service.class);
  ServiceComponent scomp=mock(ServiceComponent.class);
  ServiceComponentHost sch=mock(ServiceComponentHost.class);
  UnitOfWork unitOfWork=mock(UnitOfWork.class);
  when(fsm.getCluster(anyString())).thenReturn(oneClusterMock);
  when(oneClusterMock.getService(anyString())).thenReturn(serviceObj);
  when(serviceObj.getServiceComponent(anyString())).thenReturn(scomp);
  when(scomp.getServiceComponentHost(anyString())).thenReturn(sch);
  when(serviceObj.getCluster()).thenReturn(oneClusterMock);
  String hostname1="ahost.ambari.apache.org";
  String hostname2="bhost.ambari.apache.org";
  String hostname3="chost.ambari.apache.org";
  String hostname4="chost.ambari.apache.org";
  HashMap<String,ServiceComponentHost> hosts=new HashMap<String,ServiceComponentHost>();
  hosts.put(hostname1,sch);
  hosts.put(hostname2,sch);
  hosts.put(hostname3,sch);
  hosts.put(hostname4,sch);
  when(scomp.getServiceComponentHosts()).thenReturn(hosts);
  List<Stage> stages=new ArrayList<Stage>();
  stages.add(getStageWithSingleTask(hostname1,"cluster1",Role.DATANODE,RoleCommand.START,Service.Type.HDFS,1,1,1));
  stages.add(getStageWithSingleTask(hostname1,"cluster1",Role.GANGLIA_MONITOR,RoleCommand.START,Service.Type.GANGLIA,2,2,2));
  stages.add(getStageWithSingleTask(hostname2,"cluster1",Role.DATANODE,RoleCommand.START,Service.Type.HDFS,3,3,3));
  stages.add(getStageWithSingleTask(hostname3,"cluster1",Role.DATANODE,RoleCommand.START,Service.Type.HDFS,4,4,4));
  stages.add(getStageWithSingleTask(hostname4,"cluster1",Role.GANGLIA_MONITOR,RoleCommand.START,Service.Type.GANGLIA,5,5,4));
  ActionDBAccessor db=mock(ActionDBAccessor.class);
  RequestEntity request=mock(RequestEntity.class);
  when(request.isExclusive()).thenReturn(false);
  when(db.getRequestEntity(anyLong())).thenReturn(request);
  when(db.getCommandsInProgressCount()).thenReturn(stages.size());
  when(db.getStagesInProgress()).thenReturn(stages);
  Properties properties=new Properties();
  Configuration conf=new Configuration(properties);
  ActionScheduler scheduler=new ActionScheduler(100,50,db,aq,fsm,3,new HostsMap((String)null),unitOfWork,null,conf);
  scheduler.doWork();
  Assert.assertEquals(HostRoleStatus.QUEUED,stages.get(0).getHostRoleStatus(hostname1,"DATANODE"));
  Assert.assertEquals(HostRoleStatus.PENDING,stages.get(1).getHostRoleStatus(hostname1,"GANGLIA_MONITOR"));
  Assert.assertEquals(HostRoleStatus.QUEUED,stages.get(2).getHostRoleStatus(hostname2,"DATANODE"));
  Assert.assertEquals(HostRoleStatus.QUEUED,stages.get(3).getHostRoleStatus(hostname3,"DATANODE"));
  Assert.assertEquals(HostRoleStatus.PENDING,stages.get(4).getHostRoleStatus(hostname4,"GANGLIA_MONITOR"));
}

</code></pre>

<pre class="type-4 type-1 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies whether objects/variable are equal to an expected value 
"></span><br>
/** 
 * Verifies that ActionScheduler allows to execute background tasks in parallel
 */
@Test public void testBackgroundStagesExecutionEnable() throws Exception {
  ActionQueue aq=new ActionQueue();
  Clusters fsm=mock(Clusters.class);
  Cluster oneClusterMock=mock(Cluster.class);
  Service serviceObj=mock(Service.class);
  ServiceComponent scomp=mock(ServiceComponent.class);
  ServiceComponentHost sch=mock(ServiceComponentHost.class);
  UnitOfWork unitOfWork=mock(UnitOfWork.class);
  when(fsm.getCluster(anyString())).thenReturn(oneClusterMock);
  when(oneClusterMock.getService(anyString())).thenReturn(serviceObj);
  when(serviceObj.getServiceComponent(anyString())).thenReturn(scomp);
  when(scomp.getServiceComponentHost(anyString())).thenReturn(sch);
  when(serviceObj.getCluster()).thenReturn(oneClusterMock);
  String hostname1="ahost.ambari.apache.org";
  String hostname2="bhost.ambari.apache.org";
  HashMap<String,ServiceComponentHost> hosts=new HashMap<String,ServiceComponentHost>();
  hosts.put(hostname1,sch);
  hosts.put(hostname2,sch);
  when(scomp.getServiceComponentHosts()).thenReturn(hosts);
  List<Stage> stages=new ArrayList<Stage>();
  Stage backgroundStage=null;
  stages.add(backgroundStage=getStageWithSingleTask(hostname1,"cluster1",Role.NAMENODE,RoleCommand.CUSTOM_COMMAND,"REBALANCEHDFS",Service.Type.HDFS,1,1,1));
  Assert.assertEquals(AgentCommandType.BACKGROUND_EXECUTION_COMMAND,backgroundStage.getExecutionCommands(hostname1).get(0).getExecutionCommand().getCommandType());
  stages.add(getStageWithSingleTask(hostname1,"cluster1",Role.GANGLIA_MONITOR,RoleCommand.START,Service.Type.GANGLIA,2,2,2));
  stages.add(getStageWithSingleTask(hostname2,"cluster1",Role.DATANODE,RoleCommand.START,Service.Type.HDFS,3,3,3));
  ActionDBAccessor db=mock(ActionDBAccessor.class);
  RequestEntity request=mock(RequestEntity.class);
  when(request.isExclusive()).thenReturn(false);
  when(db.getRequestEntity(anyLong())).thenReturn(request);
  when(db.getCommandsInProgressCount()).thenReturn(stages.size());
  when(db.getStagesInProgress()).thenReturn(stages);
  Properties properties=new Properties();
  properties.put(Configuration.PARALLEL_STAGE_EXECUTION_KEY,"true");
  Configuration conf=new Configuration(properties);
  ActionScheduler scheduler=new ActionScheduler(100,50,db,aq,fsm,3,new HostsMap((String)null),unitOfWork,null,conf);
  scheduler.doWork();
  Assert.assertEquals(HostRoleStatus.QUEUED,stages.get(0).getHostRoleStatus(hostname1,"NAMENODE"));
  Assert.assertEquals(HostRoleStatus.QUEUED,stages.get(2).getHostRoleStatus(hostname2,"DATANODE"));
  Assert.assertEquals(HostRoleStatus.QUEUED,stages.get(1).getHostRoleStatus(hostname1,"GANGLIA_MONITOR"));
}

</code></pre>

<pre class="type-4 type-2 type-5 type-1 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * This test sends verifies that ActionScheduler returns up-to-date cluster host info and caching works correctly.
 */
@Test public void testClusterHostInfoCache() throws Exception {
  Type type=new TypeToken<Map<String,Set<String>>>(){
  }
.getType();
  Map<String,Set<String>> clusterHostInfo1=StageUtils.getGson().fromJson(CLUSTER_HOST_INFO,type);
  Map<String,Set<String>> clusterHostInfo2=StageUtils.getGson().fromJson(CLUSTER_HOST_INFO_UPDATED,type);
  int stageId=1;
  int requestId1=1;
  int requestId2=2;
  ActionQueue aq=new ActionQueue();
  Properties properties=new Properties();
  Configuration conf=new Configuration(properties);
  Clusters fsm=mock(Clusters.class);
  Cluster oneClusterMock=mock(Cluster.class);
  Service serviceObj=mock(Service.class);
  ServiceComponent scomp=mock(ServiceComponent.class);
  ServiceComponentHost sch=mock(ServiceComponentHost.class);
  UnitOfWork unitOfWork=mock(UnitOfWork.class);
  when(fsm.getCluster(anyString())).thenReturn(oneClusterMock);
  when(oneClusterMock.getService(anyString())).thenReturn(serviceObj);
  when(serviceObj.getServiceComponent(anyString())).thenReturn(scomp);
  when(scomp.getServiceComponentHost(anyString())).thenReturn(sch);
  when(serviceObj.getCluster()).thenReturn(oneClusterMock);
  Host host=mock(Host.class);
  HashMap<String,ServiceComponentHost> hosts=new HashMap<String,ServiceComponentHost>();
  hosts.put(hostname,sch);
  when(scomp.getServiceComponentHosts()).thenReturn(hosts);
  when(fsm.getHost(anyString())).thenReturn(host);
  when(host.getState()).thenReturn(HostState.HEALTHY);
  when(host.getHostName()).thenReturn(hostname);
  ActionDBAccessor db=mock(ActionDBAccessorImpl.class);
  RequestEntity request=mock(RequestEntity.class);
  when(request.isExclusive()).thenReturn(false);
  when(db.getRequestEntity(anyLong())).thenReturn(request);
  Stage s1=StageUtils.getATestStage(requestId1,stageId,hostname,CLUSTER_HOST_INFO,"{\"host_param\":\"param_value\"}","{\"stage_param\":\"param_value\"}");
  Stage s2=StageUtils.getATestStage(requestId2,stageId,hostname,CLUSTER_HOST_INFO_UPDATED,"{\"host_param\":\"param_value\"}","{\"stage_param\":\"param_value\"}");
  when(db.getCommandsInProgressCount()).thenReturn(1);
  when(db.getStagesInProgress()).thenReturn(Collections.singletonList(s1));
  ActionScheduler scheduler=new ActionScheduler(100,100,db,aq,fsm,10000,new HostsMap((String)null),unitOfWork,null,conf);
  scheduler.setTaskTimeoutAdjustment(false);
  List<AgentCommand> ac=waitForQueueSize(hostname,aq,1,scheduler);
  assertTrue(ac.get(0) instanceof ExecutionCommand);
  assertEquals(String.valueOf(requestId1) + "-" + stageId,((ExecutionCommand)(ac.get(0))).getCommandId());
  assertEquals(clusterHostInfo1,((ExecutionCommand)(ac.get(0))).getClusterHostInfo());
  when(db.getCommandsInProgressCount()).thenReturn(1);
  when(db.getStagesInProgress()).thenReturn(Collections.singletonList(s2));
  ac=waitForQueueSize(hostname,aq,1,scheduler);
  assertTrue(ac.get(0) instanceof ExecutionCommand);
  assertEquals(String.valueOf(requestId2) + "-" + stageId,((ExecutionCommand)(ac.get(0))).getCommandId());
  assertEquals(clusterHostInfo2,((ExecutionCommand)(ac.get(0))).getClusterHostInfo());
}

</code></pre>

<pre class="type-1 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies whether objects/variable are equal to an expected value 
"></span><br>
/** 
 * Test server action
 */
@Test public void testServerActionTimeOut() throws Exception {
  ActionQueue aq=new ActionQueue();
  Properties properties=new Properties();
  Configuration conf=new Configuration(properties);
  Clusters fsm=mock(Clusters.class);
  UnitOfWork unitOfWork=mock(UnitOfWork.class);
  List<Stage> stages=new ArrayList<Stage>();
  Map<String,String> payload=new HashMap<String,String>();
  payload.put(MockServerAction.PAYLOAD_FORCE_FAIL,"timeout");
  final Stage s=getStageWithServerAction(1,977,payload,"test",2);
  stages.add(s);
  ActionDBAccessor db=mock(ActionDBAccessor.class);
  RequestEntity request=mock(RequestEntity.class);
  when(request.isExclusive()).thenReturn(false);
  when(db.getRequestEntity(anyLong())).thenReturn(request);
  when(db.getCommandsInProgressCount()).thenReturn(stages.size());
  when(db.getStagesInProgress()).thenReturn(stages);
  doAnswer(new Answer<Void>(){
    @Override public Void answer(    InvocationOnMock invocation) throws Throwable {
      String host=(String)invocation.getArguments()[0];
      String role=(String)invocation.getArguments()[3];
      CommandReport commandReport=(CommandReport)invocation.getArguments()[4];
      HostRoleCommand command=null;
      if (null == host) {
        command=s.getHostRoleCommand(null,role);
      }
 else {
        command=s.getHostRoleCommand(host,role);
      }
      command.setStatus(HostRoleStatus.valueOf(commandReport.getStatus()));
      return null;
    }
  }
).when(db).updateHostRoleState(anyString(),anyLong(),anyLong(),anyString(),any(CommandReport.class));
  doAnswer(new Answer<HostRoleCommand>(){
    @Override public HostRoleCommand answer(    InvocationOnMock invocation) throws Throwable {
      return s.getHostRoleCommand(null,"AMBARI_SERVER_ACTION");
    }
  }
).when(db).getTask(anyLong());
  doAnswer(new Answer<List<HostRoleCommand>>(){
    @Override public List<HostRoleCommand> answer(    InvocationOnMock invocation) throws Throwable {
      String role=(String)invocation.getArguments()[1];
      HostRoleStatus status=(HostRoleStatus)invocation.getArguments()[2];
      HostRoleCommand task=s.getHostRoleCommand(null,role);
      if (task.getStatus() == status) {
        return Arrays.asList(task);
      }
 else {
        return Collections.emptyList();
      }
    }
  }
).when(db).getTasksByHostRoleAndStatus(anyString(),anyString(),any(HostRoleStatus.class));
  ServerActionExecutor.init(injector);
  ActionScheduler scheduler=new ActionScheduler(100,50,db,aq,fsm,3,new HostsMap((String)null),unitOfWork,null,conf);
  int cycleCount=0;
  while (!stages.get(0).getHostRoleStatus(null,"AMBARI_SERVER_ACTION").isCompletedState() && cycleCount++ <= MAX_CYCLE_ITERATIONS) {
    scheduler.doWork();
    scheduler.getServerActionExecutor().doWork();
  }
  assertEquals(HostRoleStatus.TIMEDOUT,stages.get(0).getHostRoleStatus(null,"AMBARI_SERVER_ACTION"));
}

</code></pre>

<pre class="type-4 type-2 type-1 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
"></span><br>
@Test public void testSuccessFactors(){
  Stage s=StageUtils.getATestStage(1,1,CLUSTER_HOST_INFO,"{\"host_param\":\"param_value\"}","{\"stage_param\":\"param_value\"}");
  assertEquals(new Float(0.5),new Float(s.getSuccessFactor(Role.DATANODE)));
  assertEquals(new Float(0.5),new Float(s.getSuccessFactor(Role.TASKTRACKER)));
  assertEquals(new Float(0.5),new Float(s.getSuccessFactor(Role.GANGLIA_MONITOR)));
  assertEquals(new Float(0.5),new Float(s.getSuccessFactor(Role.HBASE_REGIONSERVER)));
  assertEquals(new Float(1.0),new Float(s.getSuccessFactor(Role.NAMENODE)));
  assertEquals(new Float(1.0),new Float(s.getSuccessFactor(Role.GANGLIA_SERVER)));
}

</code></pre>

<pre class="type-1 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies whether objects/variable are equal to an expected value 
"></span><br>
/** 
 * Tests that command failures in skippable stages do not cause the request to
 * be aborted.
 */
@Test public void testSkippableCommandFailureDoesNotAbortRequest() throws Exception {
  Properties properties=new Properties();
  Configuration conf=new Configuration(properties);
  ActionQueue aq=new ActionQueue();
  Clusters fsm=mock(Clusters.class);
  Cluster oneClusterMock=mock(Cluster.class);
  Service serviceObj=mock(Service.class);
  ServiceComponent scomp=mock(ServiceComponent.class);
  ServiceComponentHost sch=mock(ServiceComponentHost.class);
  UnitOfWork unitOfWork=mock(UnitOfWork.class);
  when(fsm.getCluster(anyString())).thenReturn(oneClusterMock);
  when(oneClusterMock.getService(anyString())).thenReturn(serviceObj);
  when(serviceObj.getServiceComponent(anyString())).thenReturn(scomp);
  when(scomp.getServiceComponentHost(anyString())).thenReturn(sch);
  when(serviceObj.getCluster()).thenReturn(oneClusterMock);
  String hostname1="ahost.ambari.apache.org";
  HashMap<String,ServiceComponentHost> hosts=new HashMap<String,ServiceComponentHost>();
  hosts.put(hostname1,sch);
  when(scomp.getServiceComponentHosts()).thenReturn(hosts);
  Stage stage=null;
  Stage stage2=null;
  final List<Stage> stages=new ArrayList<Stage>();
  stages.add(stage=getStageWithSingleTask(hostname1,"cluster1",Role.NAMENODE,RoleCommand.STOP,Service.Type.HDFS,1,1,1));
  addInstallTaskToStage(stage,hostname1,"cluster1",Role.HBASE_MASTER,RoleCommand.INSTALL,Service.Type.HBASE,1);
  stages.add(stage2=getStageWithSingleTask(hostname1,"cluster1",Role.DATANODE,RoleCommand.STOP,Service.Type.HDFS,1,1,1));
  for (  Stage stageToMakeSkippable : stages) {
    stageToMakeSkippable.setSkippable(true);
  }
  HostRoleCommand command=stage.getOrderedHostRoleCommands().iterator().next();
  command.setStatus(HostRoleStatus.FAILED);
  ActionDBAccessor db=mock(ActionDBAccessor.class);
  RequestEntity request=mock(RequestEntity.class);
  when(request.isExclusive()).thenReturn(false);
  when(db.getRequestEntity(anyLong())).thenReturn(request);
  when(db.getCommandsInProgressCount()).thenReturn(stages.size());
  when(db.getStagesInProgress()).thenReturn(stages);
  doAnswer(new Answer<Void>(){
    @Override public Void answer(    InvocationOnMock invocation) throws Throwable {
      List<CommandReport> reports=(List<CommandReport>)invocation.getArguments()[0];
      for (      CommandReport report : reports) {
        String actionId=report.getActionId();
        long[] requestStageIds=StageUtils.getRequestStage(actionId);
        Long requestId=requestStageIds[0];
        Long stageId=requestStageIds[1];
        Long id=report.getTaskId();
        for (        Stage stage : stages) {
          if (requestId.equals(stage.getRequestId()) && stageId.equals(stage.getStageId())) {
            for (            HostRoleCommand hostRoleCommand : stage.getOrderedHostRoleCommands()) {
              if (hostRoleCommand.getTaskId() == id) {
                hostRoleCommand.setStatus(HostRoleStatus.valueOf(report.getStatus()));
              }
            }
          }
        }
      }
      return null;
    }
  }
).when(db).updateHostRoleStates(anyCollectionOf(CommandReport.class));
  when(db.getTask(anyLong())).thenAnswer(new Answer(){
    @Override public Object answer(    InvocationOnMock invocation) throws Throwable {
      Long taskId=(Long)invocation.getArguments()[0];
      for (      Stage stage : stages) {
        for (        HostRoleCommand command : stage.getOrderedHostRoleCommands()) {
          if (taskId.equals(command.getTaskId())) {
            return command;
          }
        }
      }
      return null;
    }
  }
);
  doAnswer(new Answer<Void>(){
    @Override public Void answer(    InvocationOnMock invocation) throws Throwable {
      Long requestId=(Long)invocation.getArguments()[0];
      for (      Stage stage : stages) {
        if (requestId.equals(stage.getRequestId())) {
          for (          HostRoleCommand command : stage.getOrderedHostRoleCommands()) {
            if (command.getStatus() == HostRoleStatus.QUEUED || command.getStatus() == HostRoleStatus.IN_PROGRESS || command.getStatus() == HostRoleStatus.PENDING) {
              command.setStatus(HostRoleStatus.ABORTED);
            }
          }
        }
      }
      return null;
    }
  }
).when(db).abortOperation(anyLong());
  ActionScheduler scheduler=new ActionScheduler(100,50,db,aq,fsm,3,new HostsMap((String)null),unitOfWork,null,conf);
  scheduler.doWork();
  Assert.assertEquals(HostRoleStatus.FAILED,stages.get(0).getHostRoleStatus(hostname1,"NAMENODE"));
  Assert.assertEquals(HostRoleStatus.QUEUED,stages.get(0).getHostRoleStatus(hostname1,"HBASE_MASTER"));
  Assert.assertEquals(HostRoleStatus.PENDING,stages.get(1).getHostRoleStatus(hostname1,"DATANODE"));
}

</code></pre>

<pre class="type-2 type-1 type-11 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testOpFailedEventRaisedForAbortedHostRole() throws Exception {
  ActionQueue aq=new ActionQueue();
  Properties properties=new Properties();
  Configuration conf=new Configuration(properties);
  Clusters fsm=mock(Clusters.class);
  Cluster oneClusterMock=mock(Cluster.class);
  Service serviceObj=mock(Service.class);
  ServiceComponent scomp=mock(ServiceComponent.class);
  ServiceComponentHost sch1=mock(ServiceComponentHost.class);
  ServiceComponentHost sch2=mock(ServiceComponentHost.class);
  String hostname1="host1";
  String hostname2="host2";
  Host host1=mock(Host.class);
  Host host2=mock(Host.class);
  HostEntity hostEntity1=new HostEntity();
  hostEntity1.setHostName(hostname1);
  HostEntity hostEntity2=new HostEntity();
  hostEntity2.setHostName(hostname2);
  hostDAO.merge(hostEntity1);
  hostDAO.merge(hostEntity2);
  HashMap<String,ServiceComponentHost> hosts=new HashMap<String,ServiceComponentHost>();
  hosts.put(hostname1,sch1);
  hosts.put(hostname2,sch2);
  when(scomp.getServiceComponentHosts()).thenReturn(hosts);
  when(fsm.getHost(hostname1)).thenReturn(host1);
  when(fsm.getHost(hostname2)).thenReturn(host2);
  when(host1.getState()).thenReturn(HostState.HEARTBEAT_LOST);
  when(host2.getState()).thenReturn(HostState.HEALTHY);
  when(host1.getHostName()).thenReturn(hostname1);
  when(host2.getHostName()).thenReturn(hostname2);
  when(scomp.getServiceComponentHost(hostname1)).thenReturn(sch1);
  when(scomp.getServiceComponentHost(hostname2)).thenReturn(sch2);
  UnitOfWork unitOfWork=mock(UnitOfWork.class);
  when(fsm.getCluster(anyString())).thenReturn(oneClusterMock);
  when(oneClusterMock.getService(anyString())).thenReturn(serviceObj);
  when(serviceObj.getServiceComponent(anyString())).thenReturn(scomp);
  when(serviceObj.getCluster()).thenReturn(oneClusterMock);
  final List<Stage> stages=new ArrayList<Stage>();
  Stage stage=stageFactory.createNew(1,"/tmp","cluster1",1L,"stageWith2Tasks",CLUSTER_HOST_INFO,"{\"command_param\":\"param_value\"}","{\"host_param\":\"param_value\"}");
  addInstallTaskToStage(stage,hostname1,"cluster1",Role.DATANODE,RoleCommand.INSTALL,Service.Type.HDFS,1);
  addInstallTaskToStage(stage,hostname2,"cluster1",Role.NAMENODE,RoleCommand.INSTALL,Service.Type.HDFS,2);
  stages.add(stage);
  ActionDBAccessor db=mock(ActionDBAccessor.class);
  RequestEntity request=mock(RequestEntity.class);
  when(request.isExclusive()).thenReturn(false);
  when(db.getRequestEntity(anyLong())).thenReturn(request);
  when(db.getCommandsInProgressCount()).thenReturn(stages.size());
  when(db.getStagesInProgress()).thenReturn(stages);
  doAnswer(new Answer<Void>(){
    @Override public Void answer(    InvocationOnMock invocation) throws Throwable {
      String host=(String)invocation.getArguments()[0];
      String role=(String)invocation.getArguments()[3];
      for (      HostRoleCommand command : stages.get(0).getOrderedHostRoleCommands()) {
        if (command.getHostName().equals(host) && command.getRole().name().equals(role)) {
          command.setStatus(HostRoleStatus.TIMEDOUT);
        }
      }
      return null;
    }
  }
).when(db).timeoutHostRole(anyString(),anyLong(),anyLong(),anyString());
  doAnswer(new Answer<Void>(){
    @Override public Void answer(    InvocationOnMock invocation) throws Throwable {
      Long requestId=(Long)invocation.getArguments()[0];
      for (      Stage stage : stages) {
        if (requestId.equals(stage.getRequestId())) {
          for (          HostRoleCommand command : stage.getOrderedHostRoleCommands()) {
            if (command.getStatus() == HostRoleStatus.QUEUED || command.getStatus() == HostRoleStatus.IN_PROGRESS || command.getStatus() == HostRoleStatus.PENDING) {
              command.setStatus(HostRoleStatus.ABORTED);
            }
          }
        }
      }
      return null;
    }
  }
).when(db).abortOperation(anyLong());
  ArgumentCaptor<ServiceComponentHostEvent> eventsCapture1=ArgumentCaptor.forClass(ServiceComponentHostEvent.class);
  ArgumentCaptor<ServiceComponentHostEvent> eventsCapture2=ArgumentCaptor.forClass(ServiceComponentHostEvent.class);
  ActionScheduler scheduler=new ActionScheduler(100,50000,db,aq,fsm,3,new HostsMap((String)null),unitOfWork,null,conf);
  scheduler.setTaskTimeoutAdjustment(false);
  int cycleCount=0;
  while (!(stages.get(0).getHostRoleStatus(hostname1,"DATANODE").equals(HostRoleStatus.TIMEDOUT) && stages.get(0).getHostRoleStatus(hostname2,"NAMENODE").equals(HostRoleStatus.ABORTED)) && cycleCount++ <= MAX_CYCLE_ITERATIONS) {
    scheduler.doWork();
  }
  Assert.assertEquals(HostRoleStatus.TIMEDOUT,stages.get(0).getHostRoleStatus(hostname1,"DATANODE"));
  Assert.assertEquals(HostRoleStatus.ABORTED,stages.get(0).getHostRoleStatus(hostname2,"NAMENODE"));
  verify(sch1,atLeastOnce()).handleEvent(eventsCapture1.capture());
  verify(sch2,atLeastOnce()).handleEvent(eventsCapture2.capture());
  List<ServiceComponentHostEvent> eventTypes=eventsCapture1.getAllValues();
  eventTypes.addAll(eventsCapture2.getAllValues());
  Assert.assertNotNull(eventTypes);
  ServiceComponentHostOpFailedEvent datanodeFailedEvent=null;
  ServiceComponentHostOpFailedEvent namenodeFailedEvent=null;
  for (  ServiceComponentHostEvent eventType : eventTypes) {
    if (eventType instanceof ServiceComponentHostOpFailedEvent) {
      ServiceComponentHostOpFailedEvent event=(ServiceComponentHostOpFailedEvent)eventType;
      if (event.getServiceComponentName().equals("DATANODE")) {
        datanodeFailedEvent=event;
      }
 else       if (event.getServiceComponentName().equals("NAMENODE")) {
        namenodeFailedEvent=event;
      }
    }
  }
  Assert.assertNotNull("Datanode should be in Install failed state.",datanodeFailedEvent);
  Assert.assertNotNull("Namenode should be in Install failed state.",namenodeFailedEvent);
}

</code></pre>

<pre class="type-2 type-1 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
"></span><br>
@Test public void testCancelRequests() throws Exception {
  ActionQueue aq=new ActionQueue();
  Clusters fsm=mock(Clusters.class);
  Cluster oneClusterMock=mock(Cluster.class);
  Service serviceObj=mock(Service.class);
  ServiceComponent scomp=mock(ServiceComponent.class);
  ServiceComponentHost sch=mock(ServiceComponentHost.class);
  UnitOfWork unitOfWork=mock(UnitOfWork.class);
  when(fsm.getCluster(anyString())).thenReturn(oneClusterMock);
  when(oneClusterMock.getService(anyString())).thenReturn(serviceObj);
  when(serviceObj.getServiceComponent(anyString())).thenReturn(scomp);
  when(scomp.getServiceComponentHost(anyString())).thenReturn(sch);
  when(serviceObj.getCluster()).thenReturn(oneClusterMock);
  HostEntity hostEntity=new HostEntity();
  hostEntity.setHostName(hostname);
  hostDAO.create(hostEntity);
  HashMap<String,ServiceComponentHost> hosts=new HashMap<String,ServiceComponentHost>();
  hosts.put(hostname,sch);
  when(scomp.getServiceComponentHosts()).thenReturn(hosts);
  long requestId=1;
  final List<Stage> stages=new ArrayList<Stage>();
  int namenodeCmdTaskId=1;
  stages.add(getStageWithSingleTask(hostname,"cluster1",Role.NAMENODE,RoleCommand.START,Service.Type.HDFS,namenodeCmdTaskId,1,(int)requestId));
  stages.add(getStageWithSingleTask(hostname,"cluster1",Role.DATANODE,RoleCommand.START,Service.Type.HDFS,2,2,(int)requestId));
  Host host=mock(Host.class);
  when(fsm.getHost(anyString())).thenReturn(host);
  when(host.getState()).thenReturn(HostState.HEALTHY);
  when(host.getHostName()).thenReturn(hostname);
  ActionDBAccessor db=mock(ActionDBAccessor.class);
  RequestEntity request=mock(RequestEntity.class);
  when(request.isExclusive()).thenReturn(false);
  when(db.getRequestEntity(anyLong())).thenReturn(request);
  when(db.getCommandsInProgressCount()).thenReturn(stages.size());
  when(db.getStagesInProgress()).thenReturn(stages);
  List<HostRoleCommand> requestTasks=new ArrayList<HostRoleCommand>();
  for (  Stage stage : stages) {
    requestTasks.addAll(stage.getOrderedHostRoleCommands());
  }
  when(db.getRequestTasks(anyLong())).thenReturn(requestTasks);
  when(db.getAllStages(anyLong())).thenReturn(stages);
  doAnswer(new Answer<Void>(){
    @Override public Void answer(    InvocationOnMock invocation) throws Throwable {
      List<CommandReport> reports=(List<CommandReport>)invocation.getArguments()[0];
      for (      CommandReport report : reports) {
        String actionId=report.getActionId();
        long[] requestStageIds=StageUtils.getRequestStage(actionId);
        Long requestId=requestStageIds[0];
        Long stageId=requestStageIds[1];
        Long id=report.getTaskId();
        for (        Stage stage : stages) {
          if (requestId.equals(stage.getRequestId()) && stageId.equals(stage.getStageId())) {
            for (            HostRoleCommand hostRoleCommand : stage.getOrderedHostRoleCommands()) {
              if (hostRoleCommand.getTaskId() == id) {
                hostRoleCommand.setStatus(HostRoleStatus.valueOf(report.getStatus()));
              }
            }
          }
        }
      }
      return null;
    }
  }
).when(db).updateHostRoleStates(anyCollectionOf(CommandReport.class));
  when(db.getTask(anyLong())).thenAnswer(new Answer(){
    @Override public Object answer(    InvocationOnMock invocation) throws Throwable {
      Long taskId=(Long)invocation.getArguments()[0];
      for (      Stage stage : stages) {
        for (        HostRoleCommand command : stage.getOrderedHostRoleCommands()) {
          if (taskId.equals(command.getTaskId())) {
            return command;
          }
        }
      }
      return null;
    }
  }
);
  doAnswer(new Answer<Void>(){
    @Override public Void answer(    InvocationOnMock invocation) throws Throwable {
      Long requestId=(Long)invocation.getArguments()[0];
      for (      Stage stage : stages) {
        if (requestId.equals(stage.getRequestId())) {
          for (          HostRoleCommand command : stage.getOrderedHostRoleCommands()) {
            if (command.getStatus() == HostRoleStatus.QUEUED || command.getStatus() == HostRoleStatus.IN_PROGRESS || command.getStatus() == HostRoleStatus.PENDING) {
              command.setStatus(HostRoleStatus.ABORTED);
            }
          }
        }
      }
      return null;
    }
  }
).when(db).abortOperation(anyLong());
  Properties properties=new Properties();
  Configuration conf=new Configuration(properties);
  ActionScheduler scheduler=new ActionScheduler(100,50,db,aq,fsm,3,new HostsMap((String)null),unitOfWork,null,conf);
  scheduler.doWork();
  String reason="Some reason";
  scheduler.scheduleCancellingRequest(requestId,reason);
  scheduler.doWork();
  Assert.assertEquals(HostRoleStatus.ABORTED,stages.get(0).getHostRoleStatus(hostname,"NAMENODE"));
  Assert.assertEquals(HostRoleStatus.ABORTED,stages.get(1).getHostRoleStatus(hostname,"DATANODE"));
  Assert.assertEquals(aq.size(hostname),1);
  CancelCommand cancelCommand=(CancelCommand)aq.dequeue(hostname);
  Assert.assertEquals(cancelCommand.getTargetTaskId(),namenodeCmdTaskId);
  Assert.assertEquals(cancelCommand.getReason(),reason);
}

</code></pre>

<pre class="type-12 type-2 type-1 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
"></span><br>
/** 
 * Tests that the whole request is aborted when there are no QUEUED tasks for a role and
 * success factor is not met. As long as there is one QUEUED task the request is not
 * aborted.
 * @throws Exception
 */
@Test public void testRequestAbortsOnlyWhenNoQueuedTaskAndSuccessFactorUnmet() throws Exception {
  ActionQueue aq=new ActionQueue();
  Clusters fsm=mock(Clusters.class);
  Cluster oneClusterMock=mock(Cluster.class);
  Service serviceObj=mock(Service.class);
  ServiceComponent scomp=mock(ServiceComponent.class);
  ServiceComponentHost sch=mock(ServiceComponentHost.class);
  UnitOfWork unitOfWork=mock(UnitOfWork.class);
  when(fsm.getCluster(anyString())).thenReturn(oneClusterMock);
  when(oneClusterMock.getService(anyString())).thenReturn(serviceObj);
  when(serviceObj.getServiceComponent(anyString())).thenReturn(scomp);
  when(scomp.getServiceComponentHost(anyString())).thenReturn(sch);
  when(serviceObj.getCluster()).thenReturn(oneClusterMock);
  String host1="host1";
  String host2="host2";
  Host host=mock(Host.class);
  HashMap<String,ServiceComponentHost> hosts=new HashMap<String,ServiceComponentHost>();
  hosts.put(host1,sch);
  hosts.put(host2,sch);
  when(scomp.getServiceComponentHosts()).thenReturn(hosts);
  when(fsm.getHost(anyString())).thenReturn(host);
  when(host.getState()).thenReturn(HostState.HEALTHY);
  when(host.getHostName()).thenReturn(host1);
  HostEntity hostEntity1=new HostEntity();
  HostEntity hostEntity2=new HostEntity();
  hostEntity1.setHostName(host1);
  hostEntity2.setHostName(host2);
  hostDAO.create(hostEntity1);
  hostDAO.create(hostEntity2);
  final List<Stage> stages=new ArrayList<Stage>();
  long now=System.currentTimeMillis();
  Stage stage=stageFactory.createNew(1,"/tmp","cluster1",1L,"testRequestFailureBasedOnSuccessFactor",CLUSTER_HOST_INFO,"","");
  stage.setStageId(1);
  addHostRoleExecutionCommand(now,stage,Role.SQOOP,Service.Type.SQOOP,RoleCommand.INSTALL,host1,"cluster1");
  addHostRoleExecutionCommand(now,stage,Role.OOZIE_CLIENT,Service.Type.OOZIE,RoleCommand.INSTALL,host1,"cluster1");
  addHostRoleExecutionCommand(now,stage,Role.MAPREDUCE_CLIENT,Service.Type.MAPREDUCE,RoleCommand.INSTALL,host1,"cluster1");
  addHostRoleExecutionCommand(now,stage,Role.HBASE_CLIENT,Service.Type.HBASE,RoleCommand.INSTALL,host1,"cluster1");
  addHostRoleExecutionCommand(now,stage,Role.GANGLIA_MONITOR,Service.Type.GANGLIA,RoleCommand.INSTALL,host1,"cluster1");
  addHostRoleExecutionCommand(now,stage,Role.HBASE_CLIENT,Service.Type.HBASE,RoleCommand.INSTALL,host2,"cluster1");
  addHostRoleExecutionCommand(now,stage,Role.GANGLIA_MONITOR,Service.Type.GANGLIA,RoleCommand.INSTALL,host2,"cluster1");
  stages.add(stage);
  HostRoleStatus[] statusesAtIterOne={HostRoleStatus.QUEUED,HostRoleStatus.QUEUED,HostRoleStatus.QUEUED,HostRoleStatus.QUEUED,HostRoleStatus.FAILED,HostRoleStatus.FAILED,HostRoleStatus.QUEUED,HostRoleStatus.QUEUED};
  for (int index=0; index < stage.getOrderedHostRoleCommands().size(); index++) {
    stage.getOrderedHostRoleCommands().get(index).setTaskId(index + 1);
    stage.getOrderedHostRoleCommands().get(index).setStatus(statusesAtIterOne[index]);
  }
  stage.setLastAttemptTime(host1,Role.SQOOP.toString(),now);
  stage.setLastAttemptTime(host1,Role.MAPREDUCE_CLIENT.toString(),now);
  stage.setLastAttemptTime(host1,Role.OOZIE_CLIENT.toString(),now);
  stage.setLastAttemptTime(host1,Role.GANGLIA_MONITOR.toString(),now);
  stage.setLastAttemptTime(host1,Role.HBASE_CLIENT.toString(),now);
  stage.setLastAttemptTime(host2,Role.GANGLIA_MONITOR.toString(),now);
  stage.setLastAttemptTime(host2,Role.HBASE_CLIENT.toString(),now);
  ActionDBAccessor db=mock(ActionDBAccessor.class);
  RequestEntity request=mock(RequestEntity.class);
  when(request.isExclusive()).thenReturn(false);
  when(db.getRequestEntity(anyLong())).thenReturn(request);
  when(db.getCommandsInProgressCount()).thenReturn(stages.size());
  when(db.getStagesInProgress()).thenReturn(stages);
  doAnswer(new Answer<Void>(){
    @Override public Void answer(    InvocationOnMock invocation) throws Throwable {
      String host=(String)invocation.getArguments()[0];
      Long requestId=(Long)invocation.getArguments()[1];
      Long stageId=(Long)invocation.getArguments()[2];
      String role=(String)invocation.getArguments()[3];
      CommandReport commandReport=(CommandReport)invocation.getArguments()[4];
      for (      Stage stage : stages) {
        if (requestId.equals(stage.getRequestId()) && stageId.equals(stage.getStageId())) {
          HostRoleCommand command=stage.getHostRoleCommand(host,role);
          command.setStatus(HostRoleStatus.valueOf(commandReport.getStatus()));
        }
      }
      return null;
    }
  }
).when(db).updateHostRoleState(anyString(),anyLong(),anyLong(),anyString(),any(CommandReport.class));
  when(db.getTask(anyLong())).thenAnswer(new Answer(){
    @Override public Object answer(    InvocationOnMock invocation) throws Throwable {
      Long taskId=(Long)invocation.getArguments()[0];
      for (      Stage stage : stages) {
        for (        HostRoleCommand command : stage.getOrderedHostRoleCommands()) {
          if (taskId.equals(command.getTaskId())) {
            return command;
          }
        }
      }
      return null;
    }
  }
);
  doAnswer(new Answer<Void>(){
    @Override public Void answer(    InvocationOnMock invocation) throws Throwable {
      Long requestId=(Long)invocation.getArguments()[0];
      for (      Stage stage : stages) {
        if (requestId.equals(stage.getRequestId())) {
          for (          HostRoleCommand command : stage.getOrderedHostRoleCommands()) {
            if (command.getStatus() == HostRoleStatus.QUEUED || command.getStatus() == HostRoleStatus.IN_PROGRESS || command.getStatus() == HostRoleStatus.PENDING) {
              command.setStatus(HostRoleStatus.ABORTED);
            }
          }
        }
      }
      return null;
    }
  }
).when(db).abortOperation(anyLong());
  Properties properties=new Properties();
  Configuration conf=new Configuration(properties);
  ActionScheduler scheduler=new ActionScheduler(100,10000,db,aq,fsm,3,new HostsMap((String)null),unitOfWork,null,conf);
  scheduler.doWork();
  HostRoleStatus[] expectedStatusesAtIterOne={HostRoleStatus.QUEUED,HostRoleStatus.QUEUED,HostRoleStatus.QUEUED,HostRoleStatus.QUEUED,HostRoleStatus.FAILED,HostRoleStatus.FAILED,HostRoleStatus.QUEUED,HostRoleStatus.QUEUED};
  for (int index=0; index < stage.getOrderedHostRoleCommands().size(); index++) {
    log.info(stage.getOrderedHostRoleCommands().get(index).toString());
    Assert.assertEquals(expectedStatusesAtIterOne[index],stage.getOrderedHostRoleCommands().get(index).getStatus());
  }
  HostRoleStatus[] statusesAtIterTwo={HostRoleStatus.QUEUED,HostRoleStatus.QUEUED,HostRoleStatus.QUEUED,HostRoleStatus.QUEUED,HostRoleStatus.FAILED,HostRoleStatus.FAILED,HostRoleStatus.QUEUED,HostRoleStatus.COMPLETED};
  for (int index=0; index < stage.getOrderedHostRoleCommands().size(); index++) {
    stage.getOrderedHostRoleCommands().get(index).setStatus(statusesAtIterTwo[index]);
  }
  scheduler.doWork();
  HostRoleStatus[] expectedStatusesAtIterTwo={HostRoleStatus.QUEUED,HostRoleStatus.QUEUED,HostRoleStatus.QUEUED,HostRoleStatus.QUEUED,HostRoleStatus.FAILED,HostRoleStatus.FAILED,HostRoleStatus.QUEUED,HostRoleStatus.COMPLETED};
  for (int index=0; index < stage.getOrderedHostRoleCommands().size(); index++) {
    log.info(stage.getOrderedHostRoleCommands().get(index).toString());
    Assert.assertEquals(expectedStatusesAtIterTwo[index],stage.getOrderedHostRoleCommands().get(index).getStatus());
  }
  HostRoleStatus[] statusesAtIterThree={HostRoleStatus.QUEUED,HostRoleStatus.QUEUED,HostRoleStatus.QUEUED,HostRoleStatus.QUEUED,HostRoleStatus.FAILED,HostRoleStatus.FAILED,HostRoleStatus.FAILED,HostRoleStatus.COMPLETED};
  for (int index=0; index < stage.getOrderedHostRoleCommands().size(); index++) {
    stage.getOrderedHostRoleCommands().get(index).setStatus(statusesAtIterThree[index]);
  }
  scheduler.doWork();
  HostRoleStatus[] expectedStatusesAtIterThree={HostRoleStatus.ABORTED,HostRoleStatus.ABORTED,HostRoleStatus.ABORTED,HostRoleStatus.ABORTED,HostRoleStatus.FAILED,HostRoleStatus.FAILED,HostRoleStatus.FAILED,HostRoleStatus.COMPLETED};
  for (int index=0; index < stage.getOrderedHostRoleCommands().size(); index++) {
    log.info(stage.getOrderedHostRoleCommands().get(index).toString());
    Assert.assertEquals(expectedStatusesAtIterThree[index],stage.getOrderedHostRoleCommands().get(index).getStatus());
  }
}

</code></pre>

<pre class="type-4 type-2 type-5 type-1 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * This test sends a new action to the action scheduler and verifies that the action
 * shows up in the action queue.
 */
@Test public void testActionSchedule() throws Exception {
  Type type=new TypeToken<Map<String,Set<String>>>(){
  }
.getType();
  Map<String,List<String>> clusterHostInfo=StageUtils.getGson().fromJson(CLUSTER_HOST_INFO,type);
  ActionQueue aq=new ActionQueue();
  Properties properties=new Properties();
  Configuration conf=new Configuration(properties);
  Clusters fsm=mock(Clusters.class);
  Cluster oneClusterMock=mock(Cluster.class);
  Service serviceObj=mock(Service.class);
  ServiceComponent scomp=mock(ServiceComponent.class);
  ServiceComponentHost sch=mock(ServiceComponentHost.class);
  UnitOfWork unitOfWork=mock(UnitOfWork.class);
  when(fsm.getCluster(anyString())).thenReturn(oneClusterMock);
  when(fsm.getClusterById(anyLong())).thenReturn(oneClusterMock);
  when(oneClusterMock.getService(anyString())).thenReturn(serviceObj);
  when(oneClusterMock.getClusterId()).thenReturn(Long.valueOf(1L));
  when(serviceObj.getServiceComponent(anyString())).thenReturn(scomp);
  when(scomp.getServiceComponentHost(anyString())).thenReturn(sch);
  when(serviceObj.getCluster()).thenReturn(oneClusterMock);
  Host host=mock(Host.class);
  HashMap<String,ServiceComponentHost> hosts=new HashMap<String,ServiceComponentHost>();
  hosts.put(hostname,sch);
  HostEntity hostEntity=new HostEntity();
  hostEntity.setHostName(hostname);
  hostDAO.merge(hostEntity);
  when(scomp.getServiceComponentHosts()).thenReturn(hosts);
  when(fsm.getHost(anyString())).thenReturn(host);
  when(host.getState()).thenReturn(HostState.HEALTHY);
  when(host.getHostName()).thenReturn(hostname);
  ActionDBAccessor db=mock(ActionDBAccessorImpl.class);
  List<Stage> stages=new ArrayList<Stage>();
  Stage s=StageUtils.getATestStage(1,977,hostname,CLUSTER_HOST_INFO,"{\"host_param\":\"param_value\"}","{\"stage_param\":\"param_value\"}");
  stages.add(s);
  when(db.getCommandsInProgressCount()).thenReturn(stages.size());
  when(db.getStagesInProgress()).thenReturn(stages);
  RequestEntity request=mock(RequestEntity.class);
  when(request.isExclusive()).thenReturn(false);
  when(db.getRequestEntity(anyLong())).thenReturn(request);
  ActionScheduler scheduler=new ActionScheduler(100,5,db,aq,fsm,10000,new HostsMap((String)null),unitOfWork,null,conf);
  scheduler.setTaskTimeoutAdjustment(false);
  List<AgentCommand> ac=waitForQueueSize(hostname,aq,1,scheduler);
  assertTrue(ac.get(0) instanceof ExecutionCommand);
  assertEquals("1-977",((ExecutionCommand)(ac.get(0))).getCommandId());
  assertEquals(clusterHostInfo,((ExecutionCommand)(ac.get(0))).getClusterHostInfo());
  ac=waitForQueueSize(hostname,aq,1,scheduler);
  assertTrue(ac.get(0) instanceof ExecutionCommand);
  assertEquals("1-977",((ExecutionCommand)(ac.get(0))).getCommandId());
  assertEquals(clusterHostInfo,((ExecutionCommand)(ac.get(0))).getClusterHostInfo());
  s.setHostRoleStatus(hostname,"NAMENODE",HostRoleStatus.COMPLETED);
  ac=aq.dequeueAll(hostname);
  ac=waitForQueueSize(hostname,aq,0,scheduler);
}

</code></pre>

<pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Releases resources used by the test cases">TestCleaner</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Releases resources used by the test cases
"></span><br>
@After public void teardown(){
  injector.getInstance(PersistService.class).stop();
  injector=null;
}

</code></pre>

<pre class="type-5 type-1 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Verifies that ActionScheduler respects "disable parallel stage execution option"
 */
@Test public void testIndependentStagesExecutionDisabled() throws Exception {
  ActionQueue aq=new ActionQueue();
  Clusters fsm=mock(Clusters.class);
  Cluster oneClusterMock=mock(Cluster.class);
  Service serviceObj=mock(Service.class);
  ServiceComponent scomp=mock(ServiceComponent.class);
  ServiceComponentHost sch=mock(ServiceComponentHost.class);
  UnitOfWork unitOfWork=mock(UnitOfWork.class);
  when(fsm.getCluster(anyString())).thenReturn(oneClusterMock);
  when(oneClusterMock.getService(anyString())).thenReturn(serviceObj);
  when(serviceObj.getServiceComponent(anyString())).thenReturn(scomp);
  when(scomp.getServiceComponentHost(anyString())).thenReturn(sch);
  when(serviceObj.getCluster()).thenReturn(oneClusterMock);
  String hostname1="ahost.ambari.apache.org";
  String hostname2="bhost.ambari.apache.org";
  String hostname3="chost.ambari.apache.org";
  String hostname4="chost.ambari.apache.org";
  HashMap<String,ServiceComponentHost> hosts=new HashMap<String,ServiceComponentHost>();
  hosts.put(hostname1,sch);
  hosts.put(hostname2,sch);
  hosts.put(hostname3,sch);
  hosts.put(hostname4,sch);
  when(scomp.getServiceComponentHosts()).thenReturn(hosts);
  List<Stage> stages=new ArrayList<Stage>();
  Stage stage=getStageWithSingleTask(hostname1,"cluster1",Role.HIVE_CLIENT,RoleCommand.INSTALL,Service.Type.HIVE,1,1,1);
  Map<String,String> hiveSite=new TreeMap<String,String>();
  hiveSite.put("javax.jdo.option.ConnectionPassword","password");
  hiveSite.put("hive.server2.thrift.port","10000");
  Map<String,Map<String,String>> configurations=new TreeMap<String,Map<String,String>>();
  configurations.put("hive-site",hiveSite);
  stage.getExecutionCommands(hostname1).get(0).getExecutionCommand().setConfigurations(configurations);
  stages.add(stage);
  stages.add(getStageWithSingleTask(hostname1,"cluster1",Role.GANGLIA_MONITOR,RoleCommand.START,Service.Type.GANGLIA,2,2,2));
  stages.add(getStageWithSingleTask(hostname2,"cluster1",Role.HIVE_CLIENT,RoleCommand.INSTALL,Service.Type.HIVE,3,3,3));
  stages.add(getStageWithSingleTask(hostname3,"cluster1",Role.DATANODE,RoleCommand.START,Service.Type.HDFS,4,4,4));
  stages.add(getStageWithSingleTask(hostname4,"cluster1",Role.GANGLIA_MONITOR,RoleCommand.START,Service.Type.GANGLIA,5,5,4));
  ActionDBAccessor db=mock(ActionDBAccessor.class);
  RequestEntity request=mock(RequestEntity.class);
  when(request.isExclusive()).thenReturn(false);
  when(db.getRequestEntity(anyLong())).thenReturn(request);
  when(db.getCommandsInProgressCount()).thenReturn(stages.size());
  when(db.getStagesInProgress()).thenReturn(stages);
  Properties properties=new Properties();
  properties.put(Configuration.PARALLEL_STAGE_EXECUTION_KEY,"false");
  Configuration conf=new Configuration(properties);
  ActionScheduler scheduler=new ActionScheduler(100,50,db,aq,fsm,3,new HostsMap((String)null),unitOfWork,null,conf);
  scheduler.doWork();
  Assert.assertEquals(HostRoleStatus.QUEUED,stages.get(0).getHostRoleStatus(hostname1,"HIVE_CLIENT"));
  Assert.assertEquals(HostRoleStatus.PENDING,stages.get(1).getHostRoleStatus(hostname1,"GANGLIA_MONITOR"));
  Assert.assertEquals(HostRoleStatus.PENDING,stages.get(2).getHostRoleStatus(hostname2,"HIVE_CLIENT"));
  Assert.assertEquals(HostRoleStatus.PENDING,stages.get(3).getHostRoleStatus(hostname3,"DATANODE"));
  Assert.assertEquals(HostRoleStatus.PENDING,stages.get(4).getHostRoleStatus(hostname4,"GANGLIA_MONITOR"));
  Assert.assertFalse(stages.get(0).getExecutionCommands(hostname1).get(0).getExecutionCommand().getConfigurations().containsKey("javax.jdo.option.ConnectionPassword"));
}

</code></pre>

<pre class="type-1 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies whether objects/variable are equal to an expected value 
"></span><br>
/** 
 * Test server actions in multiple requests.
 * This is used to make sure the server-side actions do not get filtered out from{@link org.apache.ambari.server.actionmanager.ActionScheduler#filterParallelPerHostStages(java.util.List)}
 */
@Test public void testServerActionInMultipleRequests() throws Exception {
  ActionQueue aq=new ActionQueue();
  Clusters fsm=mock(Clusters.class);
  Cluster oneClusterMock=mock(Cluster.class);
  Service serviceObj=mock(Service.class);
  ServiceComponent scomp=mock(ServiceComponent.class);
  ServiceComponentHost sch=mock(ServiceComponentHost.class);
  UnitOfWork unitOfWork=mock(UnitOfWork.class);
  when(fsm.getCluster(anyString())).thenReturn(oneClusterMock);
  when(oneClusterMock.getService(anyString())).thenReturn(serviceObj);
  when(serviceObj.getServiceComponent(anyString())).thenReturn(scomp);
  when(scomp.getServiceComponentHost(anyString())).thenReturn(sch);
  when(serviceObj.getCluster()).thenReturn(oneClusterMock);
  String clusterName="cluster1";
  String hostname1="ahost.ambari.apache.org";
  String hostname2="bhost.ambari.apache.org";
  HashMap<String,ServiceComponentHost> hosts=new HashMap<String,ServiceComponentHost>();
  hosts.put(hostname1,sch);
  hosts.put(hostname2,sch);
  hosts.put(Stage.INTERNAL_HOSTNAME,sch);
  when(scomp.getServiceComponentHosts()).thenReturn(hosts);
  List<Stage> stages=new ArrayList<Stage>();
  Stage stage01=createStage(clusterName,0,1);
  addTask(stage01,Stage.INTERNAL_HOSTNAME,clusterName,Role.AMBARI_SERVER_ACTION,RoleCommand.ACTIONEXECUTE,"AMBARI",1);
  Stage stage11=createStage("cluster1",1,1);
  addTask(stage11,hostname1,clusterName,Role.KERBEROS_CLIENT,RoleCommand.CUSTOM_COMMAND,"KERBEROS",2);
  Stage stage02=createStage("cluster1",0,2);
  addTask(stage02,Stage.INTERNAL_HOSTNAME,clusterName,Role.AMBARI_SERVER_ACTION,RoleCommand.ACTIONEXECUTE,"AMBARI",3);
  Stage stage12=createStage("cluster1",1,2);
  addTask(stage12,hostname2,clusterName,Role.KERBEROS_CLIENT,RoleCommand.CUSTOM_COMMAND,"KERBEROS",4);
  stages.add(stage01);
  stages.add(stage11);
  stages.add(stage02);
  stages.add(stage12);
  ActionDBAccessor db=mock(ActionDBAccessor.class);
  RequestEntity request=mock(RequestEntity.class);
  when(request.isExclusive()).thenReturn(false);
  when(db.getRequestEntity(anyLong())).thenReturn(request);
  when(db.getCommandsInProgressCount()).thenReturn(stages.size());
  when(db.getStagesInProgress()).thenReturn(stages);
  Properties properties=new Properties();
  properties.put(Configuration.PARALLEL_STAGE_EXECUTION_KEY,"true");
  Configuration conf=new Configuration(properties);
  ActionScheduler scheduler=new ActionScheduler(100,50,db,aq,fsm,3,new HostsMap((String)null),unitOfWork,EasyMock.createNiceMock(AmbariEventPublisher.class),conf);
  scheduler.doWork();
  Assert.assertEquals(HostRoleStatus.QUEUED,stages.get(0).getHostRoleStatus(Stage.INTERNAL_HOSTNAME,Role.AMBARI_SERVER_ACTION.name()));
  Assert.assertEquals(HostRoleStatus.PENDING,stages.get(1).getHostRoleStatus(hostname1,Role.KERBEROS_CLIENT.name()));
  Assert.assertEquals(HostRoleStatus.QUEUED,stages.get(2).getHostRoleStatus(Stage.INTERNAL_HOSTNAME,Role.AMBARI_SERVER_ACTION.name()));
  Assert.assertEquals(HostRoleStatus.PENDING,stages.get(3).getHostRoleStatus(hostname2,Role.KERBEROS_CLIENT.name()));
}

</code></pre>

<pre class="type-1 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies whether objects/variable are equal to an expected value 
"></span><br>
/** 
 * Test whether scheduler times out an action
 */
@Test public void testActionTimeout() throws Exception {
  ActionQueue aq=new ActionQueue();
  Properties properties=new Properties();
  Configuration conf=new Configuration(properties);
  Clusters fsm=mock(Clusters.class);
  Cluster oneClusterMock=mock(Cluster.class);
  Service serviceObj=mock(Service.class);
  ServiceComponent scomp=mock(ServiceComponent.class);
  ServiceComponentHost sch=mock(ServiceComponentHost.class);
  UnitOfWork unitOfWork=mock(UnitOfWork.class);
  when(fsm.getCluster(anyString())).thenReturn(oneClusterMock);
  when(oneClusterMock.getService(anyString())).thenReturn(serviceObj);
  when(serviceObj.getServiceComponent(anyString())).thenReturn(scomp);
  when(scomp.getServiceComponentHost(anyString())).thenReturn(sch);
  when(serviceObj.getCluster()).thenReturn(oneClusterMock);
  Host host=mock(Host.class);
  HashMap<String,ServiceComponentHost> hosts=new HashMap<String,ServiceComponentHost>();
  hosts.put(hostname,sch);
  when(scomp.getServiceComponentHosts()).thenReturn(hosts);
  when(fsm.getHost(anyString())).thenReturn(host);
  when(host.getState()).thenReturn(HostState.HEALTHY);
  when(host.getHostName()).thenReturn(hostname);
  HostEntity hostEntity=new HostEntity();
  hostEntity.setHostName(hostname);
  hostDAO.create(hostEntity);
  List<Stage> stages=new ArrayList<Stage>();
  final Stage s=StageUtils.getATestStage(1,977,hostname,CLUSTER_HOST_INFO,"{\"host_param\":\"param_value\"}","{\"stage_param\":\"param_value\"}");
  s.addHostRoleExecutionCommand(hostname,Role.SECONDARY_NAMENODE,RoleCommand.INSTALL,new ServiceComponentHostInstallEvent("SECONDARY_NAMENODE",hostname,System.currentTimeMillis(),"HDP-1.2.0"),"cluster1","HDFS",false,false);
  s.setHostRoleStatus(hostname,"SECONDARY_NAMENODE",HostRoleStatus.IN_PROGRESS);
  stages.add(s);
  ActionDBAccessor db=mock(ActionDBAccessor.class);
  when(db.getCommandsInProgressCount()).thenReturn(stages.size());
  when(db.getStagesInProgress()).thenReturn(stages);
  RequestEntity request=mock(RequestEntity.class);
  when(request.isExclusive()).thenReturn(false);
  when(db.getRequestEntity(anyLong())).thenReturn(request);
  doAnswer(new Answer<Void>(){
    @Override public Void answer(    InvocationOnMock invocation) throws Throwable {
      String host=(String)invocation.getArguments()[0];
      String role=(String)invocation.getArguments()[3];
      HostRoleCommand command=s.getHostRoleCommand(host,role);
      command.setStatus(HostRoleStatus.TIMEDOUT);
      return null;
    }
  }
).when(db).timeoutHostRole(anyString(),anyLong(),anyLong(),anyString());
  ActionScheduler scheduler=new ActionScheduler(100,0,db,aq,fsm,3,new HostsMap((String)null),unitOfWork,null,conf);
  scheduler.setTaskTimeoutAdjustment(false);
  int cycleCount=0;
  scheduler.doWork();
  assertEquals(HostRoleStatus.QUEUED,stages.get(0).getHostRoleStatus(hostname,"SECONDARY_NAMENODE"));
  stages.get(0).setHostRoleStatus(hostname,"SECONDARY_NAMENODE",HostRoleStatus.IN_PROGRESS);
  scheduler.doWork();
  assertEquals(1,stages.get(0).getAttemptCount(hostname,"NAMENODE"));
  assertEquals(2,stages.get(0).getAttemptCount(hostname,"SECONDARY_NAMENODE"));
  while (!stages.get(0).getHostRoleStatus(hostname,"SECONDARY_NAMENODE").equals(HostRoleStatus.TIMEDOUT) && cycleCount++ <= MAX_CYCLE_ITERATIONS) {
    scheduler.doWork();
  }
  assertEquals(HostRoleStatus.TIMEDOUT,stages.get(0).getHostRoleStatus(hostname,"SECONDARY_NAMENODE"));
  verify(db,times(1)).startRequest(eq(1L));
  verify(db,times(1)).abortOperation(1L);
}

</code></pre>

<pre class="type-1 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies whether objects/variable are equal to an expected value 
"></span><br>
/** 
 * Test server action
 */
@Test public void testServerAction() throws Exception {
  ActionQueue aq=new ActionQueue();
  Properties properties=new Properties();
  Configuration conf=new Configuration(properties);
  Clusters fsm=mock(Clusters.class);
  UnitOfWork unitOfWork=mock(UnitOfWork.class);
  List<Stage> stages=new ArrayList<Stage>();
  Map<String,String> payload=new HashMap<String,String>();
  final Stage s=getStageWithServerAction(1,977,payload,"test",1200);
  stages.add(s);
  ActionDBAccessor db=mock(ActionDBAccessor.class);
  RequestEntity request=mock(RequestEntity.class);
  when(request.isExclusive()).thenReturn(false);
  when(db.getRequestEntity(anyLong())).thenReturn(request);
  when(db.getCommandsInProgressCount()).thenReturn(stages.size());
  when(db.getStagesInProgress()).thenReturn(stages);
  doAnswer(new Answer<Void>(){
    @Override public Void answer(    InvocationOnMock invocation) throws Throwable {
      String host=(String)invocation.getArguments()[0];
      String role=(String)invocation.getArguments()[3];
      CommandReport commandReport=(CommandReport)invocation.getArguments()[4];
      HostRoleCommand command=null;
      if (null == host) {
        command=s.getHostRoleCommand(null,role);
      }
 else {
        command=s.getHostRoleCommand(host,role);
      }
      command.setStatus(HostRoleStatus.valueOf(commandReport.getStatus()));
      return null;
    }
  }
).when(db).updateHostRoleState(anyString(),anyLong(),anyLong(),anyString(),any(CommandReport.class));
  doAnswer(new Answer<HostRoleCommand>(){
    @Override public HostRoleCommand answer(    InvocationOnMock invocation) throws Throwable {
      return s.getHostRoleCommand(null,"AMBARI_SERVER_ACTION");
    }
  }
).when(db).getTask(anyLong());
  doAnswer(new Answer<List<HostRoleCommand>>(){
    @Override public List<HostRoleCommand> answer(    InvocationOnMock invocation) throws Throwable {
      String role=(String)invocation.getArguments()[1];
      HostRoleStatus status=(HostRoleStatus)invocation.getArguments()[2];
      HostRoleCommand task=s.getHostRoleCommand(null,role);
      if (task.getStatus() == status) {
        return Arrays.asList(task);
      }
 else {
        return Collections.emptyList();
      }
    }
  }
).when(db).getTasksByHostRoleAndStatus(anyString(),anyString(),any(HostRoleStatus.class));
  ServerActionExecutor.init(injector);
  ActionScheduler scheduler=new ActionScheduler(100,50,db,aq,fsm,3,new HostsMap((String)null),unitOfWork,null,conf);
  int cycleCount=0;
  while (!stages.get(0).getHostRoleStatus(null,"AMBARI_SERVER_ACTION").equals(HostRoleStatus.COMPLETED) && cycleCount++ <= MAX_CYCLE_ITERATIONS) {
    scheduler.doWork();
    scheduler.getServerActionExecutor().doWork();
  }
  assertEquals(stages.get(0).getHostRoleStatus(null,"AMBARI_SERVER_ACTION"),HostRoleStatus.COMPLETED);
}

</code></pre>

<pre class="type-1 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies whether objects/variable are equal to an expected value 
"></span><br>
@Test public void testRequestFailureBasedOnSuccessFactor() throws Exception {
  ActionQueue aq=new ActionQueue();
  Clusters fsm=mock(Clusters.class);
  Cluster oneClusterMock=mock(Cluster.class);
  Service serviceObj=mock(Service.class);
  ServiceComponent scomp=mock(ServiceComponent.class);
  ServiceComponentHost sch=mock(ServiceComponentHost.class);
  UnitOfWork unitOfWork=mock(UnitOfWork.class);
  RequestFactory requestFactory=mock(RequestFactory.class);
  when(fsm.getCluster(anyString())).thenReturn(oneClusterMock);
  when(oneClusterMock.getService(anyString())).thenReturn(serviceObj);
  when(serviceObj.getServiceComponent(anyString())).thenReturn(scomp);
  when(scomp.getServiceComponentHost(anyString())).thenReturn(sch);
  when(serviceObj.getCluster()).thenReturn(oneClusterMock);
  final List<Stage> stages=new ArrayList<Stage>();
  long now=System.currentTimeMillis();
  Stage stage=stageFactory.createNew(1,"/tmp","cluster1",1L,"testRequestFailureBasedOnSuccessFactor",CLUSTER_HOST_INFO,"","");
  stage.setStageId(1);
  stage.addHostRoleExecutionCommand("host1",Role.DATANODE,RoleCommand.UPGRADE,new ServiceComponentHostUpgradeEvent(Role.DATANODE.toString(),"host1",now,"HDP-0.2"),"cluster1",Service.Type.HDFS.toString(),false,false);
  stage.getExecutionCommandWrapper("host1",Role.DATANODE.toString()).getExecutionCommand();
  stage.addHostRoleExecutionCommand("host2",Role.DATANODE,RoleCommand.UPGRADE,new ServiceComponentHostUpgradeEvent(Role.DATANODE.toString(),"host2",now,"HDP-0.2"),"cluster1",Service.Type.HDFS.toString(),false,false);
  stage.getExecutionCommandWrapper("host2",Role.DATANODE.toString()).getExecutionCommand();
  stage.addHostRoleExecutionCommand("host3",Role.DATANODE,RoleCommand.UPGRADE,new ServiceComponentHostUpgradeEvent(Role.DATANODE.toString(),"host3",now,"HDP-0.2"),"cluster1",Service.Type.HDFS.toString(),false,false);
  stage.getExecutionCommandWrapper("host3",Role.DATANODE.toString()).getExecutionCommand();
  stages.add(stage);
  stage.getOrderedHostRoleCommands().get(0).setTaskId(1);
  stage.getOrderedHostRoleCommands().get(1).setTaskId(2);
  stage.getOrderedHostRoleCommands().get(2).setTaskId(3);
  stages.add(getStageWithSingleTask("host1","cluster1",Role.HDFS_CLIENT,RoleCommand.UPGRADE,Service.Type.HDFS,4,2,1));
  ActionDBAccessor db=mock(ActionDBAccessor.class);
  RequestEntity request=mock(RequestEntity.class);
  when(request.isExclusive()).thenReturn(false);
  when(db.getRequestEntity(anyLong())).thenReturn(request);
  when(db.getCommandsInProgressCount()).thenReturn(stages.size());
  when(db.getStagesInProgress()).thenReturn(stages);
  doAnswer(new Answer<Void>(){
    @Override public Void answer(    InvocationOnMock invocation) throws Throwable {
      List<CommandReport> reports=(List<CommandReport>)invocation.getArguments()[0];
      for (      CommandReport report : reports) {
        String actionId=report.getActionId();
        long[] requestStageIds=StageUtils.getRequestStage(actionId);
        Long requestId=requestStageIds[0];
        Long stageId=requestStageIds[1];
        Long id=report.getTaskId();
        for (        Stage stage : stages) {
          if (requestId.equals(stage.getRequestId()) && stageId.equals(stage.getStageId())) {
            for (            HostRoleCommand hostRoleCommand : stage.getOrderedHostRoleCommands()) {
              if (hostRoleCommand.getTaskId() == id) {
                hostRoleCommand.setStatus(HostRoleStatus.valueOf(report.getStatus()));
              }
            }
          }
        }
      }
      return null;
    }
  }
).when(db).updateHostRoleStates(anyCollectionOf(CommandReport.class));
  when(db.getTask(anyLong())).thenAnswer(new Answer(){
    @Override public Object answer(    InvocationOnMock invocation) throws Throwable {
      Long taskId=(Long)invocation.getArguments()[0];
      for (      Stage stage : stages) {
        for (        HostRoleCommand command : stage.getOrderedHostRoleCommands()) {
          if (taskId.equals(command.getTaskId())) {
            return command;
          }
        }
      }
      return null;
    }
  }
);
  doAnswer(new Answer<Void>(){
    @Override public Void answer(    InvocationOnMock invocation) throws Throwable {
      Long requestId=(Long)invocation.getArguments()[0];
      for (      Stage stage : stages) {
        if (requestId.equals(stage.getRequestId())) {
          for (          HostRoleCommand command : stage.getOrderedHostRoleCommands()) {
            if (command.getStatus() == HostRoleStatus.QUEUED || command.getStatus() == HostRoleStatus.IN_PROGRESS || command.getStatus() == HostRoleStatus.PENDING) {
              command.setStatus(HostRoleStatus.ABORTED);
            }
          }
        }
      }
      return null;
    }
  }
).when(db).abortOperation(anyLong());
  Properties properties=new Properties();
  Configuration conf=new Configuration(properties);
  ActionScheduler scheduler=new ActionScheduler(100,50,db,aq,fsm,3,new HostsMap((String)null),unitOfWork,null,conf);
  ActionManager am=new ActionManager(2,2,aq,fsm,db,new HostsMap((String)null),unitOfWork,requestFactory,conf,null);
  scheduler.doWork();
  List<CommandReport> reports=new ArrayList<CommandReport>();
  reports.add(getCommandReport(HostRoleStatus.FAILED,Role.DATANODE,Service.Type.HDFS,"1-1",1));
  am.processTaskResponse("host1",reports,stage.getOrderedHostRoleCommands());
  reports.clear();
  reports.add(getCommandReport(HostRoleStatus.FAILED,Role.DATANODE,Service.Type.HDFS,"1-1",2));
  am.processTaskResponse("host2",reports,stage.getOrderedHostRoleCommands());
  reports.clear();
  reports.add(getCommandReport(HostRoleStatus.COMPLETED,Role.DATANODE,Service.Type.HDFS,"1-1",3));
  am.processTaskResponse("host3",reports,stage.getOrderedHostRoleCommands());
  scheduler.doWork();
  Assert.assertEquals(HostRoleStatus.ABORTED,stages.get(1).getHostRoleStatus("host1","HDFS_CLIENT"));
}

</code></pre>

<pre class="type-1 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies whether objects/variable are equal to an expected value 
"></span><br>
@Test public void testServerActionFailed() throws Exception {
  ActionQueue aq=new ActionQueue();
  Properties properties=new Properties();
  Configuration conf=new Configuration(properties);
  Clusters fsm=mock(Clusters.class);
  UnitOfWork unitOfWork=mock(UnitOfWork.class);
  List<Stage> stages=new ArrayList<Stage>();
  Map<String,String> payload=new HashMap<String,String>();
  payload.put(MockServerAction.PAYLOAD_FORCE_FAIL,"exception");
  final Stage s=getStageWithServerAction(1,977,payload,"test",300);
  stages.add(s);
  ActionDBAccessor db=mock(ActionDBAccessor.class);
  RequestEntity request=mock(RequestEntity.class);
  when(request.isExclusive()).thenReturn(false);
  when(db.getRequestEntity(anyLong())).thenReturn(request);
  when(db.getCommandsInProgressCount()).thenReturn(stages.size());
  when(db.getStagesInProgress()).thenReturn(stages);
  doAnswer(new Answer<Void>(){
    @Override public Void answer(    InvocationOnMock invocation) throws Throwable {
      String host=(String)invocation.getArguments()[0];
      String role=(String)invocation.getArguments()[3];
      CommandReport commandReport=(CommandReport)invocation.getArguments()[4];
      HostRoleCommand command=null;
      if (null == host) {
        command=s.getHostRoleCommand(null,role);
      }
 else {
        command=s.getHostRoleCommand(host,role);
      }
      command.setStatus(HostRoleStatus.valueOf(commandReport.getStatus()));
      return null;
    }
  }
).when(db).updateHostRoleState(anyString(),anyLong(),anyLong(),anyString(),any(CommandReport.class));
  doAnswer(new Answer<HostRoleCommand>(){
    @Override public HostRoleCommand answer(    InvocationOnMock invocation) throws Throwable {
      return s.getHostRoleCommand(null,"AMBARI_SERVER_ACTION");
    }
  }
).when(db).getTask(anyLong());
  doAnswer(new Answer<List<HostRoleCommand>>(){
    @Override public List<HostRoleCommand> answer(    InvocationOnMock invocation) throws Throwable {
      String role=(String)invocation.getArguments()[1];
      HostRoleStatus status=(HostRoleStatus)invocation.getArguments()[2];
      HostRoleCommand task=s.getHostRoleCommand(null,role);
      if (task.getStatus() == status) {
        return Arrays.asList(task);
      }
 else {
        return Collections.emptyList();
      }
    }
  }
).when(db).getTasksByHostRoleAndStatus(anyString(),anyString(),any(HostRoleStatus.class));
  ActionScheduler scheduler=new ActionScheduler(100,50,db,aq,fsm,3,new HostsMap((String)null),unitOfWork,null,conf);
  int cycleCount=0;
  while (!stages.get(0).getHostRoleStatus(null,"AMBARI_SERVER_ACTION").equals(HostRoleStatus.FAILED) && cycleCount++ <= MAX_CYCLE_ITERATIONS) {
    scheduler.doWork();
    scheduler.getServerActionExecutor().doWork();
  }
  assertEquals(stages.get(0).getHostRoleStatus(null,"AMBARI_SERVER_ACTION"),HostRoleStatus.FAILED);
  assertEquals("test",stages.get(0).getRequestContext());
}

</code></pre>

<pre class="type-1 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies whether objects/variable are equal to an expected value 
"></span><br>
@Test public void testRequestFailureOnStageFailure() throws Exception {
  ActionQueue aq=new ActionQueue();
  Clusters fsm=mock(Clusters.class);
  Cluster oneClusterMock=mock(Cluster.class);
  Service serviceObj=mock(Service.class);
  ServiceComponent scomp=mock(ServiceComponent.class);
  ServiceComponentHost sch=mock(ServiceComponentHost.class);
  UnitOfWork unitOfWork=mock(UnitOfWork.class);
  RequestFactory requestFactory=mock(RequestFactory.class);
  when(fsm.getCluster(anyString())).thenReturn(oneClusterMock);
  when(oneClusterMock.getService(anyString())).thenReturn(serviceObj);
  when(serviceObj.getServiceComponent(anyString())).thenReturn(scomp);
  when(scomp.getServiceComponentHost(anyString())).thenReturn(sch);
  when(serviceObj.getCluster()).thenReturn(oneClusterMock);
  HashMap<String,ServiceComponentHost> hosts=new HashMap<String,ServiceComponentHost>();
  hosts.put(hostname,sch);
  when(scomp.getServiceComponentHosts()).thenReturn(hosts);
  final List<Stage> stages=new ArrayList<Stage>();
  stages.add(getStageWithSingleTask(hostname,"cluster1",Role.NAMENODE,RoleCommand.UPGRADE,Service.Type.HDFS,1,1,1));
  stages.add(getStageWithSingleTask(hostname,"cluster1",Role.DATANODE,RoleCommand.UPGRADE,Service.Type.HDFS,2,2,1));
  Host host=mock(Host.class);
  when(fsm.getHost(anyString())).thenReturn(host);
  when(host.getState()).thenReturn(HostState.HEALTHY);
  when(host.getHostName()).thenReturn(hostname);
  ActionDBAccessor db=mock(ActionDBAccessor.class);
  RequestEntity request=mock(RequestEntity.class);
  when(request.isExclusive()).thenReturn(false);
  when(db.getRequestEntity(anyLong())).thenReturn(request);
  when(db.getCommandsInProgressCount()).thenReturn(stages.size());
  when(db.getStagesInProgress()).thenReturn(stages);
  doAnswer(new Answer<Void>(){
    @Override public Void answer(    InvocationOnMock invocation) throws Throwable {
      List<CommandReport> reports=(List<CommandReport>)invocation.getArguments()[0];
      for (      CommandReport report : reports) {
        String actionId=report.getActionId();
        long[] requestStageIds=StageUtils.getRequestStage(actionId);
        Long requestId=requestStageIds[0];
        Long stageId=requestStageIds[1];
        Long id=report.getTaskId();
        for (        Stage stage : stages) {
          if (requestId.equals(stage.getRequestId()) && stageId.equals(stage.getStageId())) {
            for (            HostRoleCommand hostRoleCommand : stage.getOrderedHostRoleCommands()) {
              if (hostRoleCommand.getTaskId() == id) {
                hostRoleCommand.setStatus(HostRoleStatus.valueOf(report.getStatus()));
              }
            }
          }
        }
      }
      return null;
    }
  }
).when(db).updateHostRoleStates(anyCollectionOf(CommandReport.class));
  when(db.getTask(anyLong())).thenAnswer(new Answer(){
    @Override public Object answer(    InvocationOnMock invocation) throws Throwable {
      Long taskId=(Long)invocation.getArguments()[0];
      for (      Stage stage : stages) {
        for (        HostRoleCommand command : stage.getOrderedHostRoleCommands()) {
          if (taskId.equals(command.getTaskId())) {
            return command;
          }
        }
      }
      return null;
    }
  }
);
  doAnswer(new Answer<Void>(){
    @Override public Void answer(    InvocationOnMock invocation) throws Throwable {
      Long requestId=(Long)invocation.getArguments()[0];
      for (      Stage stage : stages) {
        if (requestId.equals(stage.getRequestId())) {
          for (          HostRoleCommand command : stage.getOrderedHostRoleCommands()) {
            if (command.getStatus() == HostRoleStatus.QUEUED || command.getStatus() == HostRoleStatus.IN_PROGRESS || command.getStatus() == HostRoleStatus.PENDING) {
              command.setStatus(HostRoleStatus.ABORTED);
            }
          }
        }
      }
      return null;
    }
  }
).when(db).abortOperation(anyLong());
  Properties properties=new Properties();
  Configuration conf=new Configuration(properties);
  Capture<Collection<HostRoleCommand>> cancelCommandList=new Capture<Collection<HostRoleCommand>>();
  ActionScheduler scheduler=EasyMock.createMockBuilder(ActionScheduler.class).withConstructor((long)100,(long)50,db,aq,fsm,3,new HostsMap((String)null),unitOfWork,EasyMock.createNiceMock(AmbariEventPublisher.class),conf).addMockedMethod("cancelHostRoleCommands").createMock();
  scheduler.cancelHostRoleCommands(EasyMock.capture(cancelCommandList),EasyMock.eq(ActionScheduler.FAILED_TASK_ABORT_REASONING));
  EasyMock.expectLastCall().once();
  EasyMock.replay(scheduler);
  ActionManager am=new ActionManager(2,2,aq,fsm,db,new HostsMap((String)null),unitOfWork,requestFactory,conf,EasyMock.createNiceMock(AmbariEventPublisher.class));
  scheduler.doWork();
  List<CommandReport> reports=new ArrayList<CommandReport>();
  reports.add(getCommandReport(HostRoleStatus.FAILED,Role.NAMENODE,Service.Type.HDFS,"1-1",1));
  am.processTaskResponse(hostname,reports,stages.get(0).getOrderedHostRoleCommands());
  scheduler.doWork();
  Assert.assertEquals(HostRoleStatus.FAILED,stages.get(0).getHostRoleStatus(hostname,"NAMENODE"));
  Assert.assertEquals(HostRoleStatus.ABORTED,stages.get(1).getHostRoleStatus(hostname,"DATANODE"));
  Assert.assertEquals(cancelCommandList.getValue().size(),1);
  EasyMock.verify(scheduler);
}

</code></pre>

<pre class="type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies boolean conditions
"></span><br>
@Test public void testExclusiveRequests() throws Exception {
  ActionQueue aq=new ActionQueue();
  Clusters fsm=mock(Clusters.class);
  Cluster oneClusterMock=mock(Cluster.class);
  Service serviceObj=mock(Service.class);
  ServiceComponent scomp=mock(ServiceComponent.class);
  ServiceComponentHost sch=mock(ServiceComponentHost.class);
  UnitOfWork unitOfWork=mock(UnitOfWork.class);
  when(fsm.getCluster(anyString())).thenReturn(oneClusterMock);
  when(oneClusterMock.getService(anyString())).thenReturn(serviceObj);
  when(serviceObj.getServiceComponent(anyString())).thenReturn(scomp);
  when(scomp.getServiceComponentHost(anyString())).thenReturn(sch);
  when(serviceObj.getCluster()).thenReturn(oneClusterMock);
  HashMap<String,ServiceComponentHost> hosts=new HashMap<String,ServiceComponentHost>();
  String hostname1="hostname1";
  String hostname2="hostname2";
  String hostname3="hostname3";
  hosts.put(hostname1,sch);
  hosts.put(hostname2,sch);
  hosts.put(hostname3,sch);
  when(scomp.getServiceComponentHosts()).thenReturn(hosts);
  long requestId1=1;
  long requestId2=2;
  long requestId3=3;
  final List<Stage> stagesInProgress=new ArrayList<Stage>();
  int namenodeCmdTaskId=1;
  stagesInProgress.add(getStageWithSingleTask(hostname1,"cluster1",Role.NAMENODE,RoleCommand.START,Service.Type.HDFS,namenodeCmdTaskId,1,(int)requestId1));
  stagesInProgress.add(getStageWithSingleTask(hostname1,"cluster1",Role.DATANODE,RoleCommand.START,Service.Type.HDFS,2,2,(int)requestId1));
  stagesInProgress.add(getStageWithSingleTask(hostname2,"cluster1",Role.DATANODE,RoleCommand.STOP,Service.Type.HDFS,3,3,(int)requestId2));
  stagesInProgress.add(getStageWithSingleTask(hostname3,"cluster1",Role.DATANODE,RoleCommand.START,Service.Type.HDFS,4,4,(int)requestId3));
  Host host1=mock(Host.class);
  when(fsm.getHost(anyString())).thenReturn(host1);
  when(host1.getState()).thenReturn(HostState.HEALTHY);
  when(host1.getHostName()).thenReturn(hostname);
  Host host2=mock(Host.class);
  when(fsm.getHost(anyString())).thenReturn(host2);
  when(host2.getState()).thenReturn(HostState.HEALTHY);
  when(host2.getHostName()).thenReturn(hostname);
  Host host3=mock(Host.class);
  when(fsm.getHost(anyString())).thenReturn(host3);
  when(host3.getState()).thenReturn(HostState.HEALTHY);
  when(host3.getHostName()).thenReturn(hostname);
  ActionDBAccessor db=mock(ActionDBAccessor.class);
  when(db.getCommandsInProgressCount()).thenReturn(stagesInProgress.size());
  when(db.getStagesInProgress()).thenReturn(stagesInProgress);
  List<HostRoleCommand> requestTasks=new ArrayList<HostRoleCommand>();
  for (  Stage stage : stagesInProgress) {
    requestTasks.addAll(stage.getOrderedHostRoleCommands());
  }
  when(db.getRequestTasks(anyLong())).thenReturn(requestTasks);
  when(db.getAllStages(anyLong())).thenReturn(stagesInProgress);
  doAnswer(new Answer<Void>(){
    @Override public Void answer(    InvocationOnMock invocation) throws Throwable {
      List<CommandReport> reports=(List<CommandReport>)invocation.getArguments()[0];
      for (      CommandReport report : reports) {
        String actionId=report.getActionId();
        long[] requestStageIds=StageUtils.getRequestStage(actionId);
        Long requestId=requestStageIds[0];
        Long stageId=requestStageIds[1];
        Long id=report.getTaskId();
        for (        Stage stage : stagesInProgress) {
          if (requestId.equals(stage.getRequestId()) && stageId.equals(stage.getStageId())) {
            for (            HostRoleCommand hostRoleCommand : stage.getOrderedHostRoleCommands()) {
              if (hostRoleCommand.getTaskId() == id) {
                hostRoleCommand.setStatus(HostRoleStatus.valueOf(report.getStatus()));
              }
            }
          }
        }
      }
      return null;
    }
  }
).when(db).updateHostRoleStates(anyCollectionOf(CommandReport.class));
  when(db.getTask(anyLong())).thenAnswer(new Answer(){
    @Override public Object answer(    InvocationOnMock invocation) throws Throwable {
      Long taskId=(Long)invocation.getArguments()[0];
      for (      Stage stage : stagesInProgress) {
        for (        HostRoleCommand command : stage.getOrderedHostRoleCommands()) {
          if (taskId.equals(command.getTaskId())) {
            return command;
          }
        }
      }
      return null;
    }
  }
);
  final Map<Long,Boolean> startedRequests=new HashMap<Long,Boolean>();
  doAnswer(new Answer<Void>(){
    @Override public Void answer(    InvocationOnMock invocation) throws Throwable {
      startedRequests.put((Long)invocation.getArguments()[0],true);
      return null;
    }
  }
).when(db).startRequest(anyLong());
  RequestEntity request1=mock(RequestEntity.class);
  when(request1.isExclusive()).thenReturn(false);
  RequestEntity request2=mock(RequestEntity.class);
  when(request2.isExclusive()).thenReturn(true);
  RequestEntity request3=mock(RequestEntity.class);
  when(request3.isExclusive()).thenReturn(false);
  when(db.getRequestEntity(requestId1)).thenReturn(request1);
  when(db.getRequestEntity(requestId2)).thenReturn(request2);
  when(db.getRequestEntity(requestId3)).thenReturn(request3);
  Properties properties=new Properties();
  Configuration conf=new Configuration(properties);
  ActionScheduler scheduler=new ActionScheduler(100,50,db,aq,fsm,3,new HostsMap((String)null),unitOfWork,null,conf);
  scheduler.doWork();
  Assert.assertTrue(startedRequests.containsKey(requestId1));
  Assert.assertFalse(startedRequests.containsKey(requestId2));
  Assert.assertFalse(startedRequests.containsKey(requestId3));
  stagesInProgress.remove(0);
  scheduler.doWork();
  Assert.assertTrue(startedRequests.containsKey(requestId1));
  Assert.assertFalse(startedRequests.containsKey(requestId2));
  Assert.assertFalse(startedRequests.containsKey(requestId3));
  stagesInProgress.remove(0);
  scheduler.doWork();
  Assert.assertTrue(startedRequests.containsKey(requestId1));
  Assert.assertTrue(startedRequests.containsKey(requestId2));
  Assert.assertFalse(startedRequests.containsKey(requestId3));
  stagesInProgress.remove(0);
  scheduler.doWork();
  Assert.assertTrue(startedRequests.containsKey(requestId1));
  Assert.assertTrue(startedRequests.containsKey(requestId2));
  Assert.assertTrue(startedRequests.containsKey(requestId3));
}

</code></pre>

<pre class="type-1 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies whether objects/variable are equal to an expected value 
"></span><br>
/** 
 * Checks what happens when stage has an execution command for
 * host component that has been recently deleted
 * @throws Exception
 */
@Test public void testCommandAbortForDeletedComponent() throws Exception {
  ActionQueue aq=new ActionQueue();
  Properties properties=new Properties();
  Configuration conf=new Configuration(properties);
  Clusters fsm=mock(Clusters.class);
  Cluster oneClusterMock=mock(Cluster.class);
  Service serviceObj=mock(Service.class);
  ServiceComponent scomp=mock(ServiceComponent.class);
  ServiceComponent scWithDeletedSCH=mock(ServiceComponent.class);
  ServiceComponentHost sch1=mock(ServiceComponentHost.class);
  String hostname1="host1";
  Host host1=mock(Host.class);
  when(fsm.getHost(hostname1)).thenReturn(host1);
  when(host1.getState()).thenReturn(HostState.HEALTHY);
  when(host1.getHostName()).thenReturn(hostname1);
  when(scomp.getServiceComponentHost(hostname1)).thenReturn(sch1);
  HashMap<String,ServiceComponentHost> hosts=new HashMap<String,ServiceComponentHost>();
  hosts.put(hostname1,sch1);
  when(scomp.getServiceComponentHosts()).thenReturn(hosts);
  HostEntity hostEntity=new HostEntity();
  hostEntity.setHostName(hostname1);
  hostDAO.create(hostEntity);
  UnitOfWork unitOfWork=mock(UnitOfWork.class);
  when(fsm.getCluster(anyString())).thenReturn(oneClusterMock);
  when(oneClusterMock.getService(anyString())).thenReturn(serviceObj);
  when(serviceObj.getServiceComponent(Role.HBASE_MASTER.toString())).thenReturn(scWithDeletedSCH);
  when(serviceObj.getServiceComponent(Role.HBASE_REGIONSERVER.toString())).thenReturn(scomp);
  when(scWithDeletedSCH.getServiceComponentHost(anyString())).thenThrow(new ServiceComponentHostNotFoundException("dummyCluster","dummyService","dummyComponent","dummyHostname"));
  when(serviceObj.getCluster()).thenReturn(oneClusterMock);
  final List<Stage> stages=new ArrayList<Stage>();
  Stage stage1=stageFactory.createNew(1,"/tmp","cluster1",1L,"stageWith2Tasks",CLUSTER_HOST_INFO,"","");
  addInstallTaskToStage(stage1,hostname1,"cluster1",Role.HBASE_MASTER,RoleCommand.INSTALL,Service.Type.HBASE,1);
  addInstallTaskToStage(stage1,hostname1,"cluster1",Role.HBASE_REGIONSERVER,RoleCommand.INSTALL,Service.Type.HBASE,2);
  stages.add(stage1);
  ActionDBAccessor db=mock(ActionDBAccessor.class);
  RequestEntity request=mock(RequestEntity.class);
  when(request.isExclusive()).thenReturn(false);
  when(db.getRequestEntity(anyLong())).thenReturn(request);
  when(db.getCommandsInProgressCount()).thenReturn(stages.size());
  when(db.getStagesInProgress()).thenReturn(stages);
  ActionScheduler scheduler=new ActionScheduler(100,50000,db,aq,fsm,3,new HostsMap((String)null),unitOfWork,null,conf);
  final CountDownLatch abortCalls=new CountDownLatch(2);
  doAnswer(new Answer(){
    @Override public Object answer(    InvocationOnMock invocation) throws Throwable {
      Long requestId=(Long)invocation.getArguments()[0];
      for (      Stage stage : stages) {
        if (requestId.equals(stage.getRequestId())) {
          for (          HostRoleCommand command : stage.getOrderedHostRoleCommands()) {
            if (command.getStatus() == HostRoleStatus.QUEUED || command.getStatus() == HostRoleStatus.IN_PROGRESS || command.getStatus() == HostRoleStatus.PENDING) {
              command.setStatus(HostRoleStatus.ABORTED);
            }
          }
        }
      }
      abortCalls.countDown();
      return null;
    }
  }
).when(db).abortOperation(anyLong());
  scheduler.setTaskTimeoutAdjustment(false);
  scheduler.start();
  long timeout=60;
  abortCalls.await(timeout,TimeUnit.SECONDS);
  Assert.assertEquals(HostRoleStatus.ABORTED,stages.get(0).getHostRoleStatus(hostname1,"HBASE_MASTER"));
  Assert.assertEquals(HostRoleStatus.ABORTED,stages.get(0).getHostRoleStatus(hostname1,"HBASE_REGIONSERVER"));
  verify(db,times(2)).abortOperation(anyLong());
  scheduler.stop();
}

</code></pre>

<pre class="type-1 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies whether objects/variable are equal to an expected value 
"></span><br>
@Test public void testActionTimeoutForLostHost() throws Exception {
  ActionQueue aq=new ActionQueue();
  Properties properties=new Properties();
  Configuration conf=new Configuration(properties);
  Clusters fsm=mock(Clusters.class);
  Cluster oneClusterMock=mock(Cluster.class);
  Service serviceObj=mock(Service.class);
  ServiceComponent scomp=mock(ServiceComponent.class);
  ServiceComponentHost sch=mock(ServiceComponentHost.class);
  UnitOfWork unitOfWork=mock(UnitOfWork.class);
  when(fsm.getCluster(anyString())).thenReturn(oneClusterMock);
  when(oneClusterMock.getService(anyString())).thenReturn(serviceObj);
  when(serviceObj.getServiceComponent(anyString())).thenReturn(scomp);
  when(scomp.getServiceComponentHost(anyString())).thenReturn(sch);
  when(serviceObj.getCluster()).thenReturn(oneClusterMock);
  Host host=mock(Host.class);
  HashMap<String,ServiceComponentHost> hosts=new HashMap<String,ServiceComponentHost>();
  hosts.put(hostname,sch);
  when(scomp.getServiceComponentHosts()).thenReturn(hosts);
  when(fsm.getHost(anyString())).thenReturn(host);
  when(host.getState()).thenReturn(HostState.HEARTBEAT_LOST);
  when(host.getHostName()).thenReturn(hostname);
  List<Stage> stages=new ArrayList<Stage>();
  final Stage s=StageUtils.getATestStage(1,977,hostname,CLUSTER_HOST_INFO,"{\"host_param\":\"param_value\"}","{\"stage_param\":\"param_value\"}");
  stages.add(s);
  ActionDBAccessor db=mock(ActionDBAccessor.class);
  RequestEntity request=mock(RequestEntity.class);
  when(request.isExclusive()).thenReturn(false);
  when(db.getRequestEntity(anyLong())).thenReturn(request);
  when(db.getCommandsInProgressCount()).thenReturn(stages.size());
  when(db.getStagesInProgress()).thenReturn(stages);
  doAnswer(new Answer<Void>(){
    @Override public Void answer(    InvocationOnMock invocation) throws Throwable {
      String host=(String)invocation.getArguments()[0];
      String role=(String)invocation.getArguments()[3];
      HostRoleCommand command=s.getHostRoleCommand(host,role);
      command.setStatus(HostRoleStatus.TIMEDOUT);
      return null;
    }
  }
).when(db).timeoutHostRole(anyString(),anyLong(),anyLong(),anyString());
  AmbariEventPublisher aep=EasyMock.createNiceMock(AmbariEventPublisher.class);
  ActionScheduler scheduler=EasyMock.createMockBuilder(ActionScheduler.class).withConstructor((long)100,(long)50,db,aq,fsm,3,new HostsMap((String)null),unitOfWork,aep,conf).addMockedMethod("cancelHostRoleCommands").createMock();
  scheduler.cancelHostRoleCommands((Collection<HostRoleCommand>)EasyMock.anyObject(),EasyMock.anyObject(String.class));
  EasyMock.expectLastCall();
  EasyMock.replay(scheduler);
  scheduler.setTaskTimeoutAdjustment(false);
  int cycleCount=0;
  while (!stages.get(0).getHostRoleStatus(hostname,"NAMENODE").equals(HostRoleStatus.TIMEDOUT) && cycleCount++ <= MAX_CYCLE_ITERATIONS) {
    scheduler.doWork();
  }
  Assert.assertEquals(HostRoleStatus.TIMEDOUT,stages.get(0).getHostRoleStatus(hostname,"NAMENODE"));
  EasyMock.verify(scheduler);
}

</code></pre>

<pre class="type-2 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
"></span><br>
@Test public void testSuccessCriteria(){
  RoleStats rs1=new RoleStats(1,(float)0.5);
  rs1.numSucceeded=1;
  assertTrue(rs1.isSuccessFactorMet());
  rs1.numSucceeded=0;
  assertFalse(rs1.isSuccessFactorMet());
  RoleStats rs2=new RoleStats(2,(float)0.5);
  rs2.numSucceeded=1;
  assertTrue(rs2.isSuccessFactorMet());
  RoleStats rs3=new RoleStats(3,(float)0.5);
  rs3.numSucceeded=2;
  assertTrue(rs2.isSuccessFactorMet());
  rs3.numSucceeded=1;
  assertFalse(rs3.isSuccessFactorMet());
  RoleStats rs4=new RoleStats(3,(float)1.0);
  rs4.numSucceeded=2;
  assertFalse(rs3.isSuccessFactorMet());
}

</code></pre>

<script>$(document).ready(function() {
  $('pre code').each(function(i, block) {
    hljs.highlightBlock(block);
  });
});</script>
