<h3><span class=" glyphicon glyphicon-tag"/>&nbspUtilityVerifier</h3><kbd>Verifies (un)successful execution of the test case by reporting explicitly a failure</kbd><br><br><br><h4 style="margin:0px">Class: org.apache.hc.client5.http.auth.util.TestByteArrayBuilder </h4><pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testInvalidAppendBytes() throws Exception {
  final ByteArrayBuilder buffer=new ByteArrayBuilder();
  buffer.append((byte[])null,0,0);
  final byte[] tmp=new byte[]{1,2,3,4};
  try {
    buffer.append(tmp,-1,0);
    Assert.fail("IndexOutOfBoundsException should have been thrown");
  }
 catch (  final IndexOutOfBoundsException ex) {
  }
  try {
    buffer.append(tmp,0,-1);
    Assert.fail("IndexOutOfBoundsException should have been thrown");
  }
 catch (  final IndexOutOfBoundsException ex) {
  }
  try {
    buffer.append(tmp,0,8);
    Assert.fail("IndexOutOfBoundsException should have been thrown");
  }
 catch (  final IndexOutOfBoundsException ex) {
  }
  try {
    buffer.append(tmp,10,Integer.MAX_VALUE);
    Assert.fail("IndexOutOfBoundsException should have been thrown");
  }
 catch (  final IndexOutOfBoundsException ex) {
  }
  try {
    buffer.append(tmp,2,4);
    Assert.fail("IndexOutOfBoundsException should have been thrown");
  }
 catch (  final IndexOutOfBoundsException ex) {
  }
}

</code></pre>

<br>
<pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testInvalidAppendChars() throws Exception {
  final ByteArrayBuilder buffer=new ByteArrayBuilder();
  buffer.append((char[])null,0,0);
  final char[] tmp=new char[]{1,2,3,4};
  try {
    buffer.append(tmp,-1,0);
    Assert.fail("IndexOutOfBoundsException should have been thrown");
  }
 catch (  final IndexOutOfBoundsException ex) {
  }
  try {
    buffer.append(tmp,0,-1);
    Assert.fail("IndexOutOfBoundsException should have been thrown");
  }
 catch (  final IndexOutOfBoundsException ex) {
  }
  try {
    buffer.append(tmp,0,8);
    Assert.fail("IndexOutOfBoundsException should have been thrown");
  }
 catch (  final IndexOutOfBoundsException ex) {
  }
  try {
    buffer.append(tmp,10,Integer.MAX_VALUE);
    Assert.fail("IndexOutOfBoundsException should have been thrown");
  }
 catch (  final IndexOutOfBoundsException ex) {
  }
  try {
    buffer.append(tmp,2,4);
    Assert.fail("IndexOutOfBoundsException should have been thrown");
  }
 catch (  final IndexOutOfBoundsException ex) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hc.client5.http.cache.TestHttpCacheEntry </h4><pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@SuppressWarnings("unused") @Test public void mustProvideRequestDate(){
  try {
    new HttpCacheEntry(null,new Date(),statusLine,new Header[]{},mockResource,HeaderConstants.GET_METHOD);
    fail("Should have thrown exception");
  }
 catch (  final IllegalArgumentException expected) {
  }
}

</code></pre>

<br>
<pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@SuppressWarnings("unused") @Test public void mustProvideStatusLine(){
  try {
    new HttpCacheEntry(new Date(),new Date(),null,new Header[]{},mockResource,HeaderConstants.GET_METHOD);
    fail("Should have thrown exception");
  }
 catch (  final IllegalArgumentException expected) {
  }
}

</code></pre>

<br>
<pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@SuppressWarnings("unused") @Test public void mustProvideResponseDate(){
  try {
    new HttpCacheEntry(new Date(),null,statusLine,new Header[]{},mockResource,HeaderConstants.GET_METHOD);
    fail("Should have thrown exception");
  }
 catch (  final IllegalArgumentException expected) {
  }
}

</code></pre>

<br>
<pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@SuppressWarnings("unused") @Test public void mustProvideResponseHeaders(){
  try {
    new HttpCacheEntry(new Date(),new Date(),statusLine,null,mockResource,HeaderConstants.GET_METHOD);
    fail("Should have thrown exception");
  }
 catch (  final IllegalArgumentException expected) {
  }
}

</code></pre>

<br>
<pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void retrievedVariantMapIsNotModifiable(){
  final Map<String,String> variantMap=new HashMap<>();
  variantMap.put("A","B");
  variantMap.put("C","D");
  entry=new HttpCacheEntry(new Date(),new Date(),statusLine,new Header[]{},mockResource,variantMap,HeaderConstants.GET_METHOD);
  final Map<String,String> result=entry.getVariantMap();
  try {
    result.remove("A");
    fail("Should have thrown exception");
  }
 catch (  final UnsupportedOperationException expected) {
  }
  try {
    result.put("E","F");
    fail("Should have thrown exception");
  }
 catch (  final UnsupportedOperationException expected) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hc.client5.http.impl.TestAbstractResponseHandler </h4><pre class="type-8 type-4 type-1 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@SuppressWarnings("boxing") @Test public void testUnsuccessfulResponse() throws Exception {
  final InputStream instream=Mockito.mock(InputStream.class);
  final HttpEntity entity=Mockito.mock(HttpEntity.class);
  Mockito.when(entity.isStreaming()).thenReturn(true);
  Mockito.when(entity.getContent()).thenReturn(instream);
  final StatusLine sl=new BasicStatusLine(HttpVersion.HTTP_1_1,404,"Not Found");
  final HttpResponse response=Mockito.mock(HttpResponse.class);
  Mockito.when(response.getStatusLine()).thenReturn(sl);
  Mockito.when(response.getEntity()).thenReturn(entity);
  final BasicResponseHandler handler=new BasicResponseHandler();
  try {
    handler.handleResponse(response);
    Assert.fail("HttpResponseException expected");
  }
 catch (  final HttpResponseException ex) {
    Assert.assertEquals(404,ex.getStatusCode());
    Assert.assertEquals("Not Found",ex.getMessage());
  }
  Mockito.verify(entity).getContent();
  Mockito.verify(instream).close();
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hc.client5.http.impl.TestBasicResponseHandler </h4><pre class="type-8 type-4 type-1 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testUnsuccessfulResponse() throws Exception {
  final InputStream instream=Mockito.mock(InputStream.class);
  final HttpEntity entity=Mockito.mock(HttpEntity.class);
  Mockito.when(entity.isStreaming()).thenReturn(true);
  Mockito.when(entity.getContent()).thenReturn(instream);
  final StatusLine sl=new BasicStatusLine(HttpVersion.HTTP_1_1,404,"Not Found");
  final HttpResponse response=Mockito.mock(HttpResponse.class);
  Mockito.when(response.getStatusLine()).thenReturn(sl);
  Mockito.when(response.getEntity()).thenReturn(entity);
  final BasicResponseHandler handler=new BasicResponseHandler();
  try {
    handler.handleResponse(response);
    Assert.fail("HttpResponseException expected");
  }
 catch (  final HttpResponseException ex) {
    Assert.assertEquals(404,ex.getStatusCode());
    Assert.assertEquals("Not Found",ex.getMessage());
  }
  Mockito.verify(entity).getContent();
  Mockito.verify(instream).close();
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hc.client5.http.impl.auth.TestDigestScheme </h4><pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testDigestAuthenticationInvalidInput() throws Exception {
  final HttpHost host=new HttpHost("somehost",80);
  final AuthScope authScope=new AuthScope(host,"realm1",null);
  final BasicCredentialsProvider credentialsProvider=new BasicCredentialsProvider();
  final Credentials creds=new UsernamePasswordCredentials("username","password".toCharArray());
  credentialsProvider.setCredentials(authScope,creds);
  final String challenge="Digest realm=\"realm1\", nonce=\"f2a3f18799759d4f1a1c068b92b573cb\"";
  final AuthChallenge authChallenge=parse(challenge);
  final DigestScheme authscheme=new DigestScheme();
  authscheme.processChallenge(authChallenge,null);
  try {
    authscheme.isResponseReady(null,credentialsProvider,null);
    Assert.fail("IllegalArgumentException should have been thrown");
  }
 catch (  final IllegalArgumentException ex) {
  }
  try {
    authscheme.isResponseReady(host,null,null);
    Assert.fail("IllegalArgumentException should have been thrown");
  }
 catch (  final IllegalArgumentException ex) {
  }
  try {
    authscheme.generateAuthResponse(host,null,null);
    Assert.fail("IllegalArgumentException should have been thrown");
  }
 catch (  final IllegalArgumentException ex) {
  }
}

</code></pre>

<br>
<pre class="type-8 type-4 type-1 type-6 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testHttpEntityDigest() throws Exception {
  final HttpEntityDigester digester=new HttpEntityDigester(MessageDigest.getInstance("MD5"));
  Assert.assertNull(digester.getDigest());
  digester.write('a');
  digester.write('b');
  digester.write('c');
  digester.write(0xe4);
  digester.write(0xf6);
  digester.write(0xfc);
  digester.write(new byte[]{'a','b','c'});
  Assert.assertNull(digester.getDigest());
  digester.close();
  Assert.assertEquals("acd2b59cd01c7737d8069015584c6cac",DigestScheme.formatHex(digester.getDigest()));
  try {
    digester.write('a');
    Assert.fail("IOException should have been thrown");
  }
 catch (  final IOException ex) {
  }
  try {
    digester.write(new byte[]{'a','b','c'});
    Assert.fail("IOException should have been thrown");
  }
 catch (  final IOException ex) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hc.client5.http.impl.cache.TestCacheEntryUpdater </h4><pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void cannotUpdateFromANon304OriginResponse() throws Exception {
  entry=HttpTestUtils.makeCacheEntry();
  response=new BasicHttpResponse(HttpVersion.HTTP_1_1,HttpStatus.SC_OK,"OK");
  try {
    impl.updateCacheEntry("A",entry,new Date(),new Date(),response);
    fail("should have thrown exception");
  }
 catch (  final IllegalArgumentException expected) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hc.client5.http.impl.cache.TestCachingExecChain </h4><pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testSocketTimeoutExceptionIsNotSilentlyCatched() throws Exception {
  impl=createCachingExecChain(mockBackend,new BasicHttpCache(),CacheConfig.DEFAULT);
  final Date now=new Date();
  final HttpRequestWrapper req1=HttpRequestWrapper.wrap(new HttpGet("http://foo.example.com"),host);
  final HttpResponse resp1=new BasicHttpResponse(HttpVersion.HTTP_1_1,HttpStatus.SC_OK,"OK");
  resp1.setEntity(new InputStreamEntity(new InputStream(){
    private boolean closed=false;
    @Override public void close() throws IOException {
      closed=true;
    }
    @Override public int read() throws IOException {
      if (closed) {
        throw new SocketException("Socket closed");
      }
      throw new SocketTimeoutException("Read timed out");
    }
  }
,128));
  resp1.setHeader("Date",DateUtils.formatDate(now));
  backendExpectsAnyRequestAndReturn(resp1);
  replayMocks();
  try {
    final HttpResponse result1=impl.execute(route,req1,context,null);
    EntityUtils.toString(result1.getEntity());
    Assert.fail("We should have had a SocketTimeoutException");
  }
 catch (  final SocketTimeoutException e) {
  }
  verifyMocks();
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hc.client5.http.impl.cache.TestProtocolRequirements </h4><pre class="type-16 type-8 type-4 type-1 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testOrderOfMultipleTransferEncodingHeadersIsPreserved() throws Exception {
  originResponse.addHeader("Transfer-Encoding","chunked");
  originResponse.addHeader("Transfer-Encoding","x-transfer");
  backendExpectsAnyRequest().andReturn(originResponse);
  replayMocks();
  final HttpResponse result=impl.execute(route,request,context,null);
  verifyMocks();
  int transfer_encodings=0;
  for (  final Header h : result.getHeaders("Transfer-Encoding")) {
    for (    final HeaderElement elt : h.getElements()) {
switch (transfer_encodings) {
case 0:
        Assert.assertEquals("chunked",elt.getName());
      break;
case 1:
    Assert.assertEquals("x-transfer",elt.getName());
  break;
default :
Assert.fail("too many transfer encodings");
}
transfer_encodings++;
}
}
Assert.assertEquals(2,transfer_encodings);
}

</code></pre>

<br>
<pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void test100ContinueResponsesAreNotForwardedTo1_0ClientsWhoDidNotAskForThem() throws Exception {
  final BasicHttpRequest post=new BasicHttpRequest("POST","/",new ProtocolVersion("HTTP",1,0));
  post.setEntity(body);
  post.setHeader("Content-Length","128");
  originResponse=Proxies.enhanceResponse(new BasicHttpResponse(HttpVersion.HTTP_1_1,100,"Continue"));
  EasyMock.expect(mockBackend.execute(EasyMock.eq(route),EasyMock.isA(HttpRequestWrapper.class),EasyMock.isA(HttpClientContext.class),EasyMock.<HttpExecutionAware>isNull())).andReturn(originResponse);
  replayMocks();
  try {
    impl.execute(route,HttpRequestWrapper.wrap(post,host),context,null);
    Assert.fail("should have thrown an exception");
  }
 catch (  final ClientProtocolException expected) {
  }
  verifyMocks();
}

</code></pre>

<br>
<pre class="type-16 type-8 type-4 type-1 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testOrderOfMultipleTransferEncodingsInSingleHeadersIsPreserved() throws Exception {
  originResponse.addHeader("Transfer-Encoding","chunked, x-transfer");
  backendExpectsAnyRequest().andReturn(originResponse);
  replayMocks();
  final HttpResponse result=impl.execute(route,request,context,null);
  verifyMocks();
  int transfer_encodings=0;
  for (  final Header h : result.getHeaders("Transfer-Encoding")) {
    for (    final HeaderElement elt : h.getElements()) {
switch (transfer_encodings) {
case 0:
        Assert.assertEquals("chunked",elt.getName());
      break;
case 1:
    Assert.assertEquals("x-transfer",elt.getName());
  break;
default :
Assert.fail("too many transfer encodings");
}
transfer_encodings++;
}
}
Assert.assertEquals(2,transfer_encodings);
}

</code></pre>

<br>
<pre class="type-16 type-8 type-4 type-1 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testOrderOfMultipleParametersInContentEncodingHeaderIsPreserved() throws Exception {
  originResponse.addHeader("Content-Encoding","gzip,deflate");
  backendExpectsAnyRequest().andReturn(originResponse);
  replayMocks();
  final HttpResponse result=impl.execute(route,request,context,null);
  verifyMocks();
  int total_encodings=0;
  for (  final Header hdr : result.getHeaders("Content-Encoding")) {
    for (    final HeaderElement elt : hdr.getElements()) {
switch (total_encodings) {
case 0:
        Assert.assertEquals("gzip",elt.getName());
      break;
case 1:
    Assert.assertEquals("deflate",elt.getName());
  break;
default :
Assert.fail("too many encodings");
}
total_encodings++;
}
}
Assert.assertEquals(2,total_encodings);
}

</code></pre>

<br>
<pre class="type-16 type-8 type-4 type-1 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testOrderOfMultipleContentEncodingHeaderValuesIsPreserved() throws Exception {
  originResponse.addHeader("Content-Encoding","gzip");
  originResponse.addHeader("Content-Encoding","deflate");
  backendExpectsAnyRequest().andReturn(originResponse);
  replayMocks();
  final HttpResponse result=impl.execute(route,request,context,null);
  verifyMocks();
  int total_encodings=0;
  for (  final Header hdr : result.getHeaders("Content-Encoding")) {
    for (    final HeaderElement elt : hdr.getElements()) {
switch (total_encodings) {
case 0:
        Assert.assertEquals("gzip",elt.getName());
      break;
case 1:
    Assert.assertEquals("deflate",elt.getName());
  break;
default :
Assert.fail("too many encodings");
}
total_encodings++;
}
}
Assert.assertEquals(2,total_encodings);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hc.client5.http.impl.cache.ehcache.TestEhcacheHttpCacheStorage </h4><pre class="type-8 type-1 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testCacheUpdateFail() throws IOException {
  final String key="foo";
  final HttpCacheEntry existingValue=HttpTestUtils.makeCacheEntry();
  final HttpCacheEntry updatedValue=HttpTestUtils.makeCacheEntry();
  final Element existingElement=new Element(key,new byte[]{});
  final HttpCacheUpdateCallback callback=new HttpCacheUpdateCallback(){
    @Override public HttpCacheEntry update(    final HttpCacheEntry old){
      assertEquals(existingValue,old);
      return updatedValue;
    }
  }
;
  when(mockCache.get(key)).thenReturn(existingElement);
  when(mockSerializer.readFrom(isA(InputStream.class))).thenReturn(existingValue);
  when(mockCache.replace(same(existingElement),isA(Element.class))).thenReturn(false);
  try {
    impl.updateEntry(key,callback);
    fail("Expected HttpCacheUpdateException");
  }
 catch (  final HttpCacheUpdateException e) {
  }
  verify(mockCache,times(2)).get(key);
  verify(mockSerializer,times(2)).readFrom(isA(InputStream.class));
  verify(mockSerializer,times(2)).writeTo(same(updatedValue),isA(OutputStream.class));
  verify(mockCache,times(2)).replace(same(existingElement),isA(Element.class));
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hc.client5.http.impl.cache.memcached.TestMemcachedHttpCacheStorage </h4><pre class="type-8 type-3 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether two objects/variables are the same">IdentityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether two objects/variables are the same
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testCacheUpdateThrowsExceptionsIfCASFailsEnoughTimes() throws IOException {
  final String url="foo";
  final String key="key";
  final HttpCacheEntry existingValue=HttpTestUtils.makeCacheEntry();
  final HttpCacheEntry updatedValue=HttpTestUtils.makeCacheEntry();
  final byte[] oldBytes=HttpTestUtils.getRandomBytes(128);
  final CASValue casValue=new CASValue(1,oldBytes);
  final byte[] newBytes=HttpTestUtils.getRandomBytes(128);
  final CacheConfig config=CacheConfig.custom().setMaxUpdateRetries(0).build();
  impl=new MemcachedHttpCacheStorage(mockMemcachedClient,config,mockMemcachedCacheEntryFactory,mockKeyHashingScheme);
  final HttpCacheUpdateCallback callback=new HttpCacheUpdateCallback(){
    @Override public HttpCacheEntry update(    final HttpCacheEntry old){
      assertSame(existingValue,old);
      return updatedValue;
    }
  }
;
  when(mockKeyHashingScheme.hash(url)).thenReturn(key);
  when(mockMemcachedClient.gets(key)).thenReturn(casValue);
  when(mockMemcachedCacheEntryFactory.getUnsetCacheEntry()).thenReturn(mockMemcachedCacheEntry);
  when(mockMemcachedCacheEntry.getStorageKey()).thenReturn(url);
  when(mockMemcachedCacheEntry.getHttpCacheEntry()).thenReturn(existingValue);
  when(mockMemcachedCacheEntryFactory.getMemcachedCacheEntry(url,updatedValue)).thenReturn(mockMemcachedCacheEntry2);
  when(mockMemcachedCacheEntry2.toByteArray()).thenReturn(newBytes);
  when(mockMemcachedClient.cas(key,casValue.getCas(),newBytes)).thenReturn(CASResponse.EXISTS);
  try {
    impl.updateEntry(url,callback);
    fail("should have thrown exception");
  }
 catch (  final HttpCacheUpdateException expected) {
  }
  verify(mockKeyHashingScheme).hash(url);
  verify(mockMemcachedClient).gets(key);
  verify(mockMemcachedCacheEntryFactory).getUnsetCacheEntry();
  verify(mockMemcachedCacheEntry).getStorageKey();
  verify(mockMemcachedCacheEntry).getHttpCacheEntry();
  verify(mockMemcachedCacheEntryFactory).getMemcachedCacheEntry(url,updatedValue);
  verify(mockMemcachedCacheEntry2).toByteArray();
  verify(mockMemcachedClient).cas(key,casValue.getCas(),newBytes);
}

</code></pre>

<br>
<pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testThrowsIOExceptionIfMemcachedTimesOutOnGet(){
  final String url="foo";
  final String key="key";
  when(mockKeyHashingScheme.hash(url)).thenReturn(key);
  when(mockMemcachedClient.get(key)).thenThrow(new OperationTimeoutException(""));
  try {
    impl.getEntry(url);
    fail("should have thrown exception");
  }
 catch (  final IOException expected) {
  }
  verify(mockKeyHashingScheme).hash(url);
  verify(mockMemcachedClient).get(key);
}

</code></pre>

<br>
<pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testCacheRemoveThrowsIOExceptionOnMemcachedTimeout(){
  final String url="foo";
  final String key="key";
  when(mockKeyHashingScheme.hash(url)).thenReturn(key);
  when(mockMemcachedClient.delete(key)).thenThrow(new OperationTimeoutException(""));
  try {
    impl.removeEntry(url);
    fail("should have thrown exception");
  }
 catch (  final IOException expected) {
  }
  verify(mockKeyHashingScheme).hash(url);
  verify(mockMemcachedClient).delete(key);
}

</code></pre>

<br>
<pre class="type-8 type-6 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testUpdateThrowsIOExceptionIfMemcachedTimesOut() throws HttpCacheUpdateException {
  final String url="foo";
  final String key="key";
  final HttpCacheEntry updatedValue=HttpTestUtils.makeCacheEntry();
  final HttpCacheUpdateCallback callback=new HttpCacheUpdateCallback(){
    @Override public HttpCacheEntry update(    final HttpCacheEntry old){
      assertNull(old);
      return updatedValue;
    }
  }
;
  when(mockKeyHashingScheme.hash(url)).thenReturn(key);
  when(mockMemcachedClient.gets(key)).thenThrow(new OperationTimeoutException(""));
  try {
    impl.updateEntry(url,callback);
    fail("should have thrown exception");
  }
 catch (  final IOException expected) {
  }
  verify(mockKeyHashingScheme).hash(url);
  verify(mockMemcachedClient).gets(key);
}

</code></pre>

<br>
<pre class="type-8 type-13 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies that exceptions are thrown during the test case execution">ExceptionVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies that exceptions are thrown during the test case execution
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(expected=HttpCacheUpdateException.class) public void testThrowsExceptionOnUpdateIfCannotHashStorageKey() throws Exception {
  final String url="foo";
  when(mockKeyHashingScheme.hash(url)).thenThrow(new MemcachedKeyHashingException(new Exception()));
  try {
    impl.updateEntry(url,null);
    fail("should have thrown exception");
  }
 catch (  final HttpCacheUpdateException expected) {
  }
  verify(mockKeyHashingScheme).hash(url);
}

</code></pre>

<br>
<pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testCachePutThrowsIOExceptionIfCannotSerializeEntry(){
  final String url="foo";
  final String key="key";
  final HttpCacheEntry value=HttpTestUtils.makeCacheEntry();
  when(mockMemcachedCacheEntryFactory.getMemcachedCacheEntry(url,value)).thenReturn(mockMemcachedCacheEntry);
  when(mockMemcachedCacheEntry.toByteArray()).thenThrow(new MemcachedSerializationException(new Exception()));
  try {
    impl.putEntry(url,value);
    fail("should have thrown exception");
  }
 catch (  final IOException expected) {
  }
  verify(mockMemcachedCacheEntryFactory).getMemcachedCacheEntry(url,value);
  verify(mockMemcachedCacheEntry).toByteArray();
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hc.client5.http.impl.cookie.TestBasicClientCookie </h4><pre class="type-8 type-4 type-1 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@SuppressWarnings("unused") @Test public void testConstructor(){
  final BasicClientCookie cookie=new BasicClientCookie("name","value");
  Assert.assertEquals("name",cookie.getName());
  Assert.assertEquals("value",cookie.getValue());
  try {
    new BasicClientCookie(null,null);
    Assert.fail("IllegalArgumentException should have been thrown");
  }
 catch (  final IllegalArgumentException ex) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hc.client5.http.impl.cookie.TestBasicCookieAttribHandlers </h4><pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testBasicMaxAgeInvalidInput() throws Exception {
  final CookieAttributeHandler h=new BasicMaxAgeHandler();
  try {
    h.parse(null,null);
    Assert.fail("IllegalArgumentException must have been thrown");
  }
 catch (  final IllegalArgumentException ex) {
  }
}

</code></pre>

<br>
<pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testBasicPathValidate() throws Exception {
  final BasicClientCookie cookie=new BasicClientCookie("name","value");
  final CookieOrigin origin=new CookieOrigin("somehost",80,"/stuff",false);
  final CookieAttributeHandler h=new BasicPathHandler();
  cookie.setPath("/stuff");
  h.validate(cookie,origin);
  cookie.setPath("/stuffed");
  try {
    h.validate(cookie,origin);
    Assert.fail("MalformedCookieException must have been thrown");
  }
 catch (  final MalformedCookieException ex) {
  }
}

</code></pre>

<br>
<pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testBasicPathInvalidInput() throws Exception {
  final CookieAttributeHandler h=new BasicPathHandler();
  try {
    h.parse(null,null);
    Assert.fail("IllegalArgumentException must have been thrown");
  }
 catch (  final IllegalArgumentException ex) {
  }
  try {
    h.match(null,null);
    Assert.fail("IllegalArgumentException must have been thrown");
  }
 catch (  final IllegalArgumentException ex) {
  }
  try {
    h.match(new BasicClientCookie("name","value"),null);
    Assert.fail("IllegalArgumentException must have been thrown");
  }
 catch (  final IllegalArgumentException ex) {
  }
}

</code></pre>

<br>
<pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testBasicExpiresParseInvalid() throws Exception {
  final BasicClientCookie cookie=new BasicClientCookie("name","value");
  final CookieAttributeHandler h=new BasicExpiresHandler(new String[]{DateUtils.PATTERN_RFC1123});
  try {
    h.parse(cookie,"garbage");
    Assert.fail("MalformedCookieException must have been thrown");
  }
 catch (  final MalformedCookieException ex) {
  }
  try {
    h.parse(cookie,null);
    Assert.fail("MalformedCookieException must have been thrown");
  }
 catch (  final MalformedCookieException ex) {
  }
}

</code></pre>

<br>
<pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testBasicDomainValidate2() throws Exception {
  final BasicClientCookie cookie=new BasicClientCookie("name","value");
  final CookieOrigin origin=new CookieOrigin("somehost",80,"/",false);
  final CookieAttributeHandler h=new BasicDomainHandler();
  cookie.setDomain("somehost");
  h.validate(cookie,origin);
  cookie.setDomain("otherhost");
  try {
    h.validate(cookie,origin);
    Assert.fail("MalformedCookieException should have been thrown");
  }
 catch (  final MalformedCookieException ex) {
  }
}

</code></pre>

<br>
<pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testBasicSecureInvalidInput() throws Exception {
  final CookieAttributeHandler h=new BasicSecureHandler();
  try {
    h.parse(null,null);
    Assert.fail("IllegalArgumentException must have been thrown");
  }
 catch (  final IllegalArgumentException ex) {
  }
  try {
    h.match(null,null);
    Assert.fail("IllegalArgumentException must have been thrown");
  }
 catch (  final IllegalArgumentException ex) {
  }
  try {
    h.match(new BasicClientCookie("name","value"),null);
    Assert.fail("IllegalArgumentException must have been thrown");
  }
 catch (  final IllegalArgumentException ex) {
  }
}

</code></pre>

<br>
<pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testBasicMaxAgeParseInvalid() throws Exception {
  final BasicClientCookie cookie=new BasicClientCookie("name","value");
  final CookieAttributeHandler h=new BasicMaxAgeHandler();
  try {
    h.parse(cookie,"garbage");
    Assert.fail("MalformedCookieException must have been thrown");
  }
 catch (  final MalformedCookieException ex) {
  }
  try {
    h.parse(cookie,null);
    Assert.fail("MalformedCookieException must have been thrown");
  }
 catch (  final MalformedCookieException ex) {
  }
}

</code></pre>

<br>
<pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testBasicDomainInvalidInput() throws Exception {
  final CookieAttributeHandler h=new BasicDomainHandler();
  try {
    h.parse(null,null);
    Assert.fail("IllegalArgumentException must have been thrown");
  }
 catch (  final IllegalArgumentException ex) {
  }
  try {
    h.validate(null,null);
    Assert.fail("IllegalArgumentException must have been thrown");
  }
 catch (  final IllegalArgumentException ex) {
  }
  try {
    h.validate(new BasicClientCookie("name","value"),null);
    Assert.fail("IllegalArgumentException must have been thrown");
  }
 catch (  final IllegalArgumentException ex) {
  }
  try {
    h.match(null,null);
    Assert.fail("IllegalArgumentException must have been thrown");
  }
 catch (  final IllegalArgumentException ex) {
  }
  try {
    h.match(new BasicClientCookie("name","value"),null);
    Assert.fail("IllegalArgumentException must have been thrown");
  }
 catch (  final IllegalArgumentException ex) {
  }
}

</code></pre>

<br>
<pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testBasicDomainValidate1() throws Exception {
  final BasicClientCookie cookie=new BasicClientCookie("name","value");
  final CookieOrigin origin=new CookieOrigin("www.somedomain.com",80,"/",false);
  final CookieAttributeHandler h=new BasicDomainHandler();
  cookie.setDomain(".somedomain.com");
  h.validate(cookie,origin);
  cookie.setDomain(".otherdomain.com");
  try {
    h.validate(cookie,origin);
    Assert.fail("MalformedCookieException should have been thrown");
  }
 catch (  final MalformedCookieException ex) {
  }
  cookie.setDomain("www.otherdomain.com");
  try {
    h.validate(cookie,origin);
    Assert.fail("MalformedCookieException should have been thrown");
  }
 catch (  final MalformedCookieException ex) {
  }
}

</code></pre>

<br>
<pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testBasicDomainValidate4() throws Exception {
  final BasicClientCookie cookie=new BasicClientCookie("name","value");
  final CookieOrigin origin=new CookieOrigin("somedomain.com",80,"/",false);
  final CookieAttributeHandler h=new BasicDomainHandler();
  cookie.setDomain(null);
  try {
    h.validate(cookie,origin);
    Assert.fail("MalformedCookieException should have been thrown");
  }
 catch (  final MalformedCookieException ex) {
  }
}

</code></pre>

<br>
<pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@SuppressWarnings("unused") @Test public void testBasicExpiresInvalidInput() throws Exception {
  try {
    new BasicExpiresHandler(null);
    Assert.fail("IllegalArgumentException must have been thrown");
  }
 catch (  final IllegalArgumentException ex) {
  }
  final CookieAttributeHandler h=new BasicExpiresHandler(new String[]{DateUtils.PATTERN_RFC1123});
  try {
    h.parse(null,null);
    Assert.fail("IllegalArgumentException must have been thrown");
  }
 catch (  final IllegalArgumentException ex) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hc.client5.http.impl.cookie.TestLaxCookieAttribHandlers </h4><pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testBasicMaxAgeInvalidInput() throws Exception {
  final CookieAttributeHandler h=new LaxMaxAgeHandler();
  try {
    h.parse(null,"stuff");
    Assert.fail("IllegalArgumentException must have been thrown");
  }
 catch (  final IllegalArgumentException ex) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hc.client5.http.impl.integration.TestAbortHandling </h4><pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * Tests that if a socket fails to connect, the allocated connection is
 * properly released back to the connection manager.
 */
@Test public void testSocketConnectFailureReleasesConnection() throws Exception {
  final HttpClientConnection conn=Mockito.mock(HttpClientConnection.class);
  final ConnectionRequest connrequest=Mockito.mock(ConnectionRequest.class);
  Mockito.when(connrequest.get(Mockito.anyInt(),Mockito.any(TimeUnit.class))).thenReturn(conn);
  final HttpClientConnectionManager connmgr=Mockito.mock(HttpClientConnectionManager.class);
  Mockito.doThrow(new ConnectException()).when(connmgr).connect(Mockito.any(HttpClientConnection.class),Mockito.any(HttpRoute.class),Mockito.anyInt(),Mockito.any(HttpContext.class));
  Mockito.when(connmgr.requestConnection(Mockito.any(HttpRoute.class),Mockito.any())).thenReturn(connrequest);
  final CloseableHttpClient client=HttpClients.custom().setConnectionManager(connmgr).build();
  final HttpContext context=new BasicHttpContext();
  final HttpGet httpget=new HttpGet("http://www.example.com/a");
  try {
    client.execute(httpget,context);
    Assert.fail("expected IOException");
  }
 catch (  final IOException expected) {
  }
  Mockito.verify(connmgr).releaseConnection(conn,null,0,TimeUnit.MILLISECONDS);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hc.client5.http.impl.integration.TestClientAuthentication </h4><pre class="type-8 type-2 type-4 type-6 type-13 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies that exceptions are thrown during the test case execution">ExceptionVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
- Verifies that exceptions are thrown during the test case execution
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(expected=ClientProtocolException.class) public void testBasicAuthenticationFailureOnNonRepeatablePost() throws Exception {
  this.serverBootstrap.registerHandler("*",new AuthHandler());
  final HttpHost target=start();
  final HttpPost httppost=new HttpPost("/");
  httppost.setEntity(new InputStreamEntity(new ByteArrayInputStream(new byte[]{0,1,2,3,4,5,6,7,8,9}),-1));
  final HttpClientContext context=HttpClientContext.create();
  final TestCredentialsProvider credsProvider=new TestCredentialsProvider(new UsernamePasswordCredentials("test","test".toCharArray()));
  context.setCredentialsProvider(credsProvider);
  try {
    this.httpclient.execute(target,httppost,context);
    Assert.fail("ClientProtocolException should have been thrown");
  }
 catch (  final ClientProtocolException ex) {
    final Throwable cause=ex.getCause();
    Assert.assertNotNull(cause);
    Assert.assertTrue(cause instanceof NonRepeatableRequestException);
    throw ex;
  }
}

</code></pre>

<br>
<pre class="type-8 type-2 type-4 type-6 type-13 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies that exceptions are thrown during the test case execution">ExceptionVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
- Verifies that exceptions are thrown during the test case execution
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(expected=ClientProtocolException.class) public void testBasicAuthenticationFailureOnNonRepeatablePutDontExpectContinue() throws Exception {
  this.serverBootstrap.registerHandler("*",new AuthHandler());
  final HttpHost target=start();
  final RequestConfig config=RequestConfig.custom().setExpectContinueEnabled(true).build();
  final HttpPut httpput=new HttpPut("/");
  httpput.setConfig(config);
  httpput.setEntity(new InputStreamEntity(new ByteArrayInputStream(new byte[]{1,2,3,4,5,6,7,8,9}),-1));
  final HttpClientContext context=HttpClientContext.create();
  final TestCredentialsProvider credsProvider=new TestCredentialsProvider(new UsernamePasswordCredentials("test","boom".toCharArray()));
  context.setCredentialsProvider(credsProvider);
  try {
    this.httpclient.execute(target,httpput,context);
    Assert.fail("ClientProtocolException should have been thrown");
  }
 catch (  final ClientProtocolException ex) {
    final Throwable cause=ex.getCause();
    Assert.assertNotNull(cause);
    Assert.assertTrue(cause instanceof NonRepeatableRequestException);
    throw ex;
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hc.client5.http.impl.integration.TestConnectionAutoRelease </h4><pre class="type-7 type-8 type-4 type-1 type-6 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testReleaseOnEntityWriteTo() throws Exception {
  this.connManager.setDefaultMaxPerRoute(1);
  this.connManager.setMaxTotal(1);
  PoolStats stats=this.connManager.getTotalStats();
  Assert.assertEquals(0,stats.getAvailable());
  final HttpHost target=start();
  final HttpGet httpget=new HttpGet("/random/20000");
  final HttpResponse response=this.httpclient.execute(target,httpget);
  ConnectionRequest connreq=this.connManager.requestConnection(new HttpRoute(target),null);
  try {
    connreq.get(250,TimeUnit.MILLISECONDS);
    Assert.fail("ConnectionPoolTimeoutException should have been thrown");
  }
 catch (  final ConnectionPoolTimeoutException expected) {
  }
  final HttpEntity e=response.getEntity();
  Assert.assertNotNull(e);
  final ByteArrayOutputStream outsteam=new ByteArrayOutputStream();
  e.writeTo(outsteam);
  stats=this.connManager.getTotalStats();
  Assert.assertEquals(1,stats.getAvailable());
  connreq=this.connManager.requestConnection(new HttpRoute(target),null);
  final HttpClientConnection conn=connreq.get(250,TimeUnit.MILLISECONDS);
  this.connManager.releaseConnection(conn,null,-1,null);
}

</code></pre>

<br>
<pre class="type-7 type-8 type-4 type-1 type-6 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testReleaseOnIOException() throws Exception {
  this.serverBootstrap.registerHandler("/dropdead",new HttpRequestHandler(){
    @Override public void handle(    final HttpRequest request,    final HttpResponse response,    final HttpContext context) throws HttpException, IOException {
      final BasicHttpEntity entity=new BasicHttpEntity(){
        @Override public void writeTo(        final OutputStream outstream) throws IOException {
          final byte[] tmp=new byte[5];
          outstream.write(tmp);
          outstream.flush();
          final DefaultBHttpServerConnection conn=(DefaultBHttpServerConnection)context.getAttribute(HttpCoreContext.HTTP_CONNECTION);
          try {
            conn.sendResponseHeader(response);
          }
 catch (          final HttpException ignore) {
          }
        }
      }
;
      entity.setChunked(true);
      response.setEntity(entity);
    }
  }
);
  this.connManager.setDefaultMaxPerRoute(1);
  this.connManager.setMaxTotal(1);
  Assert.assertEquals(0,this.connManager.getTotalStats().getAvailable());
  final HttpHost target=start();
  final HttpGet httpget=new HttpGet("/dropdead");
  final HttpResponse response=this.httpclient.execute(target,httpget);
  ConnectionRequest connreq=this.connManager.requestConnection(new HttpRoute(target),null);
  try {
    connreq.get(250,TimeUnit.MILLISECONDS);
    Assert.fail("ConnectionPoolTimeoutException should have been thrown");
  }
 catch (  final ConnectionPoolTimeoutException expected) {
  }
  final HttpEntity e=response.getEntity();
  Assert.assertNotNull(e);
  try {
    EntityUtils.toByteArray(e);
    Assert.fail("MalformedChunkCodingException should have been thrown");
  }
 catch (  final MalformedChunkCodingException expected) {
  }
  Assert.assertEquals(0,this.connManager.getTotalStats().getAvailable());
  connreq=this.connManager.requestConnection(new HttpRoute(target),null);
  final HttpClientConnection conn=connreq.get(250,TimeUnit.MILLISECONDS);
  this.connManager.releaseConnection(conn,null,-1,null);
}

</code></pre>

<br>
<pre class="type-7 type-8 type-4 type-1 type-6 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testReleaseOnAbort() throws Exception {
  this.connManager.setDefaultMaxPerRoute(1);
  this.connManager.setMaxTotal(1);
  final PoolStats stats=this.connManager.getTotalStats();
  Assert.assertEquals(0,stats.getAvailable());
  final HttpHost target=start();
  final HttpGet httpget=new HttpGet("/random/20000");
  final HttpResponse response=this.httpclient.execute(target,httpget);
  ConnectionRequest connreq=this.connManager.requestConnection(new HttpRoute(target),null);
  try {
    connreq.get(250,TimeUnit.MILLISECONDS);
    Assert.fail("ConnectionPoolTimeoutException should have been thrown");
  }
 catch (  final ConnectionPoolTimeoutException expected) {
  }
  final HttpEntity e=response.getEntity();
  Assert.assertNotNull(e);
  httpget.abort();
  Assert.assertEquals(0,this.connManager.getTotalStats().getAvailable());
  connreq=this.connManager.requestConnection(new HttpRoute(target),null);
  final HttpClientConnection conn=connreq.get(250,TimeUnit.MILLISECONDS);
  this.connManager.releaseConnection(conn,null,-1,null);
}

</code></pre>

<br>
<pre class="type-7 type-8 type-4 type-1 type-6 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testReleaseOnEntityConsumeContent() throws Exception {
  this.connManager.setDefaultMaxPerRoute(1);
  this.connManager.setMaxTotal(1);
  PoolStats stats=this.connManager.getTotalStats();
  Assert.assertEquals(0,stats.getAvailable());
  final HttpHost target=start();
  final HttpGet httpget=new HttpGet("/random/20000");
  final HttpResponse response=this.httpclient.execute(target,httpget);
  ConnectionRequest connreq=this.connManager.requestConnection(new HttpRoute(target),null);
  try {
    connreq.get(250,TimeUnit.MILLISECONDS);
    Assert.fail("ConnectionPoolTimeoutException should have been thrown");
  }
 catch (  final ConnectionPoolTimeoutException expected) {
  }
  final HttpEntity e=response.getEntity();
  Assert.assertNotNull(e);
  EntityUtils.consume(e);
  stats=this.connManager.getTotalStats();
  Assert.assertEquals(1,stats.getAvailable());
  connreq=this.connManager.requestConnection(new HttpRoute(target),null);
  final HttpClientConnection conn=connreq.get(250,TimeUnit.MILLISECONDS);
  this.connManager.releaseConnection(conn,null,-1,null);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hc.client5.http.impl.integration.TestConnectionManagement </h4><pre class="type-7 type-8 type-2 type-4 type-1 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Tests releasing connection from #abort method called from the
 * main execution thread while there is no blocking I/O operation.
 */
@Test public void testReleaseConnectionOnAbort() throws Exception {
  this.connManager.setMaxTotal(1);
  final HttpHost target=start();
  final HttpRoute route=new HttpRoute(target,null,false);
  final int rsplen=8;
  final String uri="/random/" + rsplen;
  final HttpContext context=new BasicHttpContext();
  final HttpRequest request=new BasicHttpRequest("GET",uri,HttpVersion.HTTP_1_1);
  HttpClientConnection conn=getConnection(this.connManager,route);
  this.connManager.connect(conn,route,0,context);
  this.connManager.routeComplete(conn,route,context);
  context.setAttribute(HttpCoreContext.HTTP_CONNECTION,conn);
  context.setAttribute(HttpCoreContext.HTTP_TARGET_HOST,target);
  final HttpProcessor httpProcessor=new ImmutableHttpProcessor(new RequestTargetHost(),new RequestContent(),new RequestConnControl());
  final HttpRequestExecutor exec=new HttpRequestExecutor();
  exec.preProcess(request,httpProcessor,context);
  final HttpResponse response=exec.execute(request,conn,context);
  Assert.assertEquals("wrong status in first response",HttpStatus.SC_OK,response.getStatusLine().getStatusCode());
  try {
    getConnection(this.connManager,route,100L,TimeUnit.MILLISECONDS);
    Assert.fail("ConnectionPoolTimeoutException should have been thrown");
  }
 catch (  final ConnectionPoolTimeoutException e) {
  }
  Assert.assertTrue(conn instanceof HttpClientConnection);
  conn.shutdown();
  this.connManager.releaseConnection(conn,null,-1,null);
  conn=getConnection(this.connManager,route,5L,TimeUnit.SECONDS);
  Assert.assertFalse("connection should have been closed",conn.isOpen());
  this.connManager.releaseConnection(conn,null,-1,null);
  this.connManager.shutdown();
}

</code></pre>

<br>
<pre class="type-7 type-8 type-2 type-4 type-1 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Tests releasing with time limits.
 */
@Test public void testReleaseConnectionWithTimeLimits() throws Exception {
  this.connManager.setMaxTotal(1);
  final HttpHost target=start();
  final HttpRoute route=new HttpRoute(target,null,false);
  final int rsplen=8;
  final String uri="/random/" + rsplen;
  final HttpRequest request=new BasicHttpRequest("GET",uri,HttpVersion.HTTP_1_1);
  final HttpContext context=new BasicHttpContext();
  HttpClientConnection conn=getConnection(this.connManager,route);
  this.connManager.connect(conn,route,0,context);
  this.connManager.routeComplete(conn,route,context);
  context.setAttribute(HttpCoreContext.HTTP_CONNECTION,conn);
  context.setAttribute(HttpCoreContext.HTTP_TARGET_HOST,target);
  final HttpProcessor httpProcessor=new ImmutableHttpProcessor(new RequestTargetHost(),new RequestContent(),new RequestConnControl());
  final HttpRequestExecutor exec=new HttpRequestExecutor();
  exec.preProcess(request,httpProcessor,context);
  HttpResponse response=exec.execute(request,conn,context);
  Assert.assertEquals("wrong status in first response",HttpStatus.SC_OK,response.getStatusLine().getStatusCode());
  byte[] data=EntityUtils.toByteArray(response.getEntity());
  Assert.assertEquals("wrong length of first response entity",rsplen,data.length);
  try {
    getConnection(this.connManager,route,10L,TimeUnit.MILLISECONDS);
    Assert.fail("ConnectionPoolTimeoutException should have been thrown");
  }
 catch (  final ConnectionPoolTimeoutException e) {
  }
  conn.close();
  this.connManager.releaseConnection(conn,null,100,TimeUnit.MILLISECONDS);
  conn=getConnection(this.connManager,route);
  Assert.assertFalse("connection should have been closed",conn.isOpen());
  this.connManager.connect(conn,route,0,context);
  this.connManager.routeComplete(conn,route,context);
  context.setAttribute(HttpCoreContext.HTTP_CONNECTION,conn);
  response=exec.execute(request,conn,context);
  Assert.assertEquals("wrong status in second response",HttpStatus.SC_OK,response.getStatusLine().getStatusCode());
  data=EntityUtils.toByteArray(response.getEntity());
  Assert.assertEquals("wrong length of second response entity",rsplen,data.length);
  this.connManager.releaseConnection(conn,null,100,TimeUnit.MILLISECONDS);
  conn=getConnection(this.connManager,route);
  Assert.assertTrue("connection should have been open",conn.isOpen());
  context.setAttribute(HttpCoreContext.HTTP_CONNECTION,conn);
  response=exec.execute(request,conn,context);
  Assert.assertEquals("wrong status in third response",HttpStatus.SC_OK,response.getStatusLine().getStatusCode());
  data=EntityUtils.toByteArray(response.getEntity());
  Assert.assertEquals("wrong length of third response entity",rsplen,data.length);
  this.connManager.releaseConnection(conn,null,100,TimeUnit.MILLISECONDS);
  Thread.sleep(150);
  conn=getConnection(this.connManager,route);
  Assert.assertTrue("connection should have been closed",!conn.isOpen());
  this.connManager.connect(conn,route,0,context);
  this.connManager.routeComplete(conn,route,context);
  context.setAttribute(HttpCoreContext.HTTP_CONNECTION,conn);
  response=exec.execute(request,conn,context);
  Assert.assertEquals("wrong status in third response",HttpStatus.SC_OK,response.getStatusLine().getStatusCode());
  data=EntityUtils.toByteArray(response.getEntity());
  Assert.assertEquals("wrong length of fourth response entity",rsplen,data.length);
  this.connManager.shutdown();
}

</code></pre>

<br>
<pre class="type-7 type-8 type-2 type-4 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testAbortDuringConnecting() throws Exception {
  final CountDownLatch connectLatch=new CountDownLatch(1);
  final StallingSocketFactory stallingSocketFactory=new StallingSocketFactory(connectLatch,WaitPolicy.BEFORE_CONNECT,PlainConnectionSocketFactory.getSocketFactory());
  final Registry<ConnectionSocketFactory> registry=RegistryBuilder.<ConnectionSocketFactory>create().register("http",stallingSocketFactory).build();
  this.connManager=new PoolingHttpClientConnectionManager(registry);
  this.clientBuilder.setConnectionManager(this.connManager);
  this.connManager.setMaxTotal(1);
  final HttpHost target=start();
  final HttpRoute route=new HttpRoute(target,null,false);
  final HttpContext context=new BasicHttpContext();
  final HttpClientConnection conn=getConnection(this.connManager,route);
  final AtomicReference<Throwable> throwRef=new AtomicReference<>();
  final Thread abortingThread=new Thread(new Runnable(){
    @Override public void run(){
      try {
        stallingSocketFactory.waitForState();
        conn.shutdown();
        connManager.releaseConnection(conn,null,-1,null);
        connectLatch.countDown();
      }
 catch (      final Throwable e) {
        throwRef.set(e);
      }
    }
  }
);
  abortingThread.start();
  try {
    this.connManager.connect(conn,route,0,context);
    this.connManager.routeComplete(conn,route,context);
    Assert.fail("expected SocketException");
  }
 catch (  final SocketException expected) {
  }
  abortingThread.join(5000);
  if (throwRef.get() != null) {
    throw new RuntimeException(throwRef.get());
  }
  Assert.assertFalse(conn.isOpen());
  final HttpClientConnection conn2=getConnection(this.connManager,route,5L,TimeUnit.SECONDS);
  Assert.assertFalse("connection should have been closed",conn2.isOpen());
  this.connManager.releaseConnection(conn2,null,-1,null);
  this.connManager.shutdown();
}

</code></pre>

<br>
<pre class="type-7 type-8 type-2 type-4 type-1 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Tests releasing and re-using a connection after a response is read.
 */
@Test public void testReleaseConnection() throws Exception {
  this.connManager.setMaxTotal(1);
  final HttpHost target=start();
  final HttpRoute route=new HttpRoute(target,null,false);
  final int rsplen=8;
  final String uri="/random/" + rsplen;
  final HttpRequest request=new BasicHttpRequest("GET",uri,HttpVersion.HTTP_1_1);
  final HttpContext context=new BasicHttpContext();
  HttpClientConnection conn=getConnection(this.connManager,route);
  this.connManager.connect(conn,route,0,context);
  this.connManager.routeComplete(conn,route,context);
  context.setAttribute(HttpCoreContext.HTTP_CONNECTION,conn);
  context.setAttribute(HttpCoreContext.HTTP_TARGET_HOST,target);
  final HttpProcessor httpProcessor=new ImmutableHttpProcessor(new RequestTargetHost(),new RequestContent(),new RequestConnControl());
  final HttpRequestExecutor exec=new HttpRequestExecutor();
  exec.preProcess(request,httpProcessor,context);
  HttpResponse response=exec.execute(request,conn,context);
  Assert.assertEquals("wrong status in first response",HttpStatus.SC_OK,response.getStatusLine().getStatusCode());
  byte[] data=EntityUtils.toByteArray(response.getEntity());
  Assert.assertEquals("wrong length of first response entity",rsplen,data.length);
  try {
    getConnection(this.connManager,route,10L,TimeUnit.MILLISECONDS);
    Assert.fail("ConnectionPoolTimeoutException should have been thrown");
  }
 catch (  final ConnectionPoolTimeoutException e) {
  }
  conn.close();
  this.connManager.releaseConnection(conn,null,-1,null);
  conn=getConnection(this.connManager,route);
  Assert.assertFalse("connection should have been closed",conn.isOpen());
  this.connManager.connect(conn,route,0,context);
  this.connManager.routeComplete(conn,route,context);
  context.setAttribute(HttpCoreContext.HTTP_CONNECTION,conn);
  response=exec.execute(request,conn,context);
  Assert.assertEquals("wrong status in second response",HttpStatus.SC_OK,response.getStatusLine().getStatusCode());
  data=EntityUtils.toByteArray(response.getEntity());
  Assert.assertEquals("wrong length of second response entity",rsplen,data.length);
  this.connManager.releaseConnection(conn,null,-1,null);
  conn=getConnection(this.connManager,route);
  Assert.assertTrue("connection should have been open",conn.isOpen());
  context.setAttribute(HttpCoreContext.HTTP_CONNECTION,conn);
  response=exec.execute(request,conn,context);
  Assert.assertEquals("wrong status in third response",HttpStatus.SC_OK,response.getStatusLine().getStatusCode());
  data=EntityUtils.toByteArray(response.getEntity());
  Assert.assertEquals("wrong length of third response entity",rsplen,data.length);
  this.connManager.releaseConnection(conn,null,-1,null);
  this.connManager.shutdown();
}

</code></pre>

<br>
<pre class="type-7 type-8 type-2 type-4 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testAbortAfterSocketConnect() throws Exception {
  final CountDownLatch connectLatch=new CountDownLatch(1);
  final StallingSocketFactory stallingSocketFactory=new StallingSocketFactory(connectLatch,WaitPolicy.AFTER_CONNECT,PlainConnectionSocketFactory.getSocketFactory());
  final Registry<ConnectionSocketFactory> registry=RegistryBuilder.<ConnectionSocketFactory>create().register("http",stallingSocketFactory).build();
  this.connManager=new PoolingHttpClientConnectionManager(registry);
  this.clientBuilder.setConnectionManager(this.connManager);
  this.connManager.setMaxTotal(1);
  final HttpHost target=start();
  final HttpRoute route=new HttpRoute(target,null,false);
  final HttpContext context=new BasicHttpContext();
  final HttpClientConnection conn=getConnection(this.connManager,route);
  final AtomicReference<Throwable> throwRef=new AtomicReference<>();
  final Thread abortingThread=new Thread(new Runnable(){
    @Override public void run(){
      try {
        stallingSocketFactory.waitForState();
        conn.shutdown();
        connManager.releaseConnection(conn,null,-1,null);
        connectLatch.countDown();
      }
 catch (      final Throwable e) {
        throwRef.set(e);
      }
    }
  }
);
  abortingThread.start();
  try {
    this.connManager.connect(conn,route,0,context);
    this.connManager.routeComplete(conn,route,context);
    Assert.fail("IOException expected");
  }
 catch (  final IOException expected) {
  }
  abortingThread.join(5000);
  if (throwRef.get() != null) {
    throw new RuntimeException(throwRef.get());
  }
  Assert.assertFalse(conn.isOpen());
  final HttpClientConnection conn2=getConnection(this.connManager,route,5L,TimeUnit.SECONDS);
  Assert.assertFalse("connection should have been closed",conn2.isOpen());
  this.connManager.releaseConnection(conn2,null,-1,null);
  this.connManager.shutdown();
}

</code></pre>

<br>
<pre class="type-7 type-8 type-2 type-4 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testAbortBeforeSocketCreate() throws Exception {
  final CountDownLatch connectLatch=new CountDownLatch(1);
  final StallingSocketFactory stallingSocketFactory=new StallingSocketFactory(connectLatch,WaitPolicy.BEFORE_CREATE,PlainConnectionSocketFactory.getSocketFactory());
  final Registry<ConnectionSocketFactory> registry=RegistryBuilder.<ConnectionSocketFactory>create().register("http",stallingSocketFactory).build();
  this.connManager=new PoolingHttpClientConnectionManager(registry);
  this.clientBuilder.setConnectionManager(this.connManager);
  this.connManager.setMaxTotal(1);
  final HttpHost target=start();
  final HttpRoute route=new HttpRoute(target,null,false);
  final HttpContext context=new BasicHttpContext();
  final HttpClientConnection conn=getConnection(this.connManager,route);
  final AtomicReference<Throwable> throwRef=new AtomicReference<>();
  final Thread abortingThread=new Thread(new Runnable(){
    @Override public void run(){
      try {
        stallingSocketFactory.waitForState();
        conn.shutdown();
        connManager.releaseConnection(conn,null,-1,null);
        connectLatch.countDown();
      }
 catch (      final Throwable e) {
        throwRef.set(e);
      }
    }
  }
);
  abortingThread.start();
  try {
    this.connManager.connect(conn,route,0,context);
    this.connManager.routeComplete(conn,route,context);
    Assert.fail("IOException expected");
  }
 catch (  final IOException expected) {
  }
  abortingThread.join(5000);
  if (throwRef.get() != null) {
    throw new RuntimeException(throwRef.get());
  }
  Assert.assertFalse(conn.isOpen());
  final HttpClientConnection conn2=getConnection(this.connManager,route,5L,TimeUnit.SECONDS);
  Assert.assertFalse("connection should have been closed",conn2.isOpen());
  this.connManager.releaseConnection(conn2,null,-1,null);
  this.connManager.shutdown();
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hc.client5.http.impl.integration.TestContentCodings </h4><pre class="type-16 type-8 type-4 type-1 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Try with a bunch of client threads, to check that it's thread-safe.
 * @throws Exceptionif there was a problem
 */
@Test public void testThreadSafetyOfContentCodings() throws Exception {
  final String entityText="Hello, this is some plain text coming back.";
  this.serverBootstrap.registerHandler("*",createGzipEncodingRequestHandler(entityText));
  final int clients=100;
  this.connManager.setMaxTotal(clients);
  final HttpHost target=start();
  final ExecutorService executor=Executors.newFixedThreadPool(clients);
  final CountDownLatch startGate=new CountDownLatch(1);
  final CountDownLatch endGate=new CountDownLatch(clients);
  final List<WorkerTask> workers=new ArrayList<>();
  for (int i=0; i < clients; ++i) {
    workers.add(new WorkerTask(this.httpclient,target,i % 2 == 0,startGate,endGate));
  }
  for (  final WorkerTask workerTask : workers) {
    executor.execute(workerTask);
  }
  startGate.countDown();
  endGate.await();
  for (  final WorkerTask workerTask : workers) {
    if (workerTask.isFailed()) {
      Assert.fail("A worker failed");
    }
    Assert.assertEquals(entityText,workerTask.getText());
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hc.client5.http.impl.integration.TestCookieVirtualHost </h4><pre class="type-16 type-8 type-4 type-1 type-6 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testCookieMatchingWithVirtualHosts() throws Exception {
  this.serverBootstrap.registerHandler("*",new HttpRequestHandler(){
    @Override public void handle(    final HttpRequest request,    final HttpResponse response,    final HttpContext context) throws HttpException, IOException {
      final int n=Integer.parseInt(request.getFirstHeader("X-Request").getValue());
switch (n) {
case 1:
        Assert.assertEquals("app.mydomain.fr",request.getFirstHeader("Host").getValue());
      response.setStatusLine(HttpVersion.HTTP_1_1,HttpStatus.SC_OK);
    response.addHeader(new BasicHeader("Set-Cookie","name1=value1; domain=mydomain.fr; path=/"));
  break;
case 2:
Assert.assertEquals("app.mydomain.fr",request.getFirstHeader("Host").getValue());
Assert.assertNotNull("We must get a cookie header",request.getFirstHeader("Cookie"));
response.setStatusLine(HttpVersion.HTTP_1_1,HttpStatus.SC_OK);
break;
case 3:
Assert.assertEquals("app.mydomain.fr",request.getFirstHeader("Host").getValue());
response.setStatusLine(HttpVersion.HTTP_1_1,HttpStatus.SC_OK);
break;
default :
Assert.fail("Unexpected value: " + n);
break;
}
}
}
);
final HttpHost target=start();
final CookieStore cookieStore=new BasicCookieStore();
final HttpClientContext context=HttpClientContext.create();
context.setCookieStore(cookieStore);
URI uri=new URI("http://app.mydomain.fr");
HttpRequest httpRequest=new HttpGet(uri);
httpRequest.addHeader("X-Request","1");
try (CloseableHttpResponse response1=this.httpclient.execute(target,httpRequest,context)){
EntityUtils.consume(response1.getEntity());
}
 final List<Cookie> cookies=cookieStore.getCookies();
Assert.assertNotNull(cookies);
Assert.assertEquals(1,cookies.size());
Assert.assertEquals("name1",cookies.get(0).getName());
uri=new URI("http://app.mydomain.fr");
httpRequest=new HttpGet(uri);
httpRequest.addHeader("X-Request","2");
try (CloseableHttpResponse response2=this.httpclient.execute(target,httpRequest,context)){
EntityUtils.consume(response2.getEntity());
}
 uri=new URI("http://app.mydomain.fr");
httpRequest=new HttpGet(uri);
httpRequest.addHeader("X-Request","3");
try (CloseableHttpResponse response3=this.httpclient.execute(target,httpRequest,context)){
EntityUtils.consume(response3.getEntity());
}
 }

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hc.client5.http.impl.io.TestBasicHttpClientConnectionManager </h4><pre class="type-8 type-4 type-6 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testShutdown() throws Exception {
  final HttpHost target=new HttpHost("somehost",80);
  final HttpRoute route=new HttpRoute(target);
  Mockito.when(connFactory.create(Mockito.eq(route),Mockito.<ConnectionConfig>any())).thenReturn(conn);
  final ConnectionRequest connRequest1=mgr.requestConnection(route,null);
  final HttpClientConnection conn1=connRequest1.get(0,TimeUnit.MILLISECONDS);
  Assert.assertNotNull(conn1);
  Mockito.verify(connFactory,Mockito.times(1)).create(Mockito.eq(route),Mockito.<ConnectionConfig>any());
  Mockito.when(conn.isOpen()).thenReturn(Boolean.TRUE);
  mgr.releaseConnection(conn1,null,0,TimeUnit.MILLISECONDS);
  mgr.shutdown();
  Mockito.verify(conn,Mockito.times(1)).shutdown();
  try {
    final ConnectionRequest connRequest2=mgr.requestConnection(route,null);
    connRequest2.get(0,TimeUnit.MILLISECONDS);
    Assert.fail("IllegalStateException expected");
  }
 catch (  final IllegalStateException ex) {
  }
  mgr.closeExpiredConnections();
  mgr.closeIdleConnections(0L,TimeUnit.MILLISECONDS);
  mgr.shutdown();
  Mockito.verify(conn,Mockito.times(1)).shutdown();
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hc.client5.http.impl.protocol.TestAuthenticationStrategy </h4><pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testSelectInvalidInput() throws Exception {
  final DefaultAuthenticationStrategy authStrategy=new DefaultAuthenticationStrategy();
  final HttpClientContext context=HttpClientContext.create();
  try {
    authStrategy.select(null,Collections.<String,AuthChallenge>emptyMap(),context);
    Assert.fail("IllegalArgumentException expected");
  }
 catch (  final IllegalArgumentException ex) {
  }
  try {
    authStrategy.select(ChallengeType.TARGET,null,context);
    Assert.fail("IllegalArgumentException expected");
  }
 catch (  final IllegalArgumentException ex) {
  }
  try {
    authStrategy.select(ChallengeType.TARGET,Collections.<String,AuthChallenge>emptyMap(),null);
    Assert.fail("IllegalArgumentException expected");
  }
 catch (  final IllegalArgumentException ex) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hc.client5.http.impl.protocol.TestDefaultRedirectStrategy </h4><pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testIsRedirectedInvalidInput() throws Exception {
  final DefaultRedirectStrategy redirectStrategy=new DefaultRedirectStrategy();
  final HttpClientContext context=HttpClientContext.create();
  final HttpGet httpget=new HttpGet("http://localhost/");
  final HttpResponse response=new BasicHttpResponse(HttpVersion.HTTP_1_1,HttpStatus.SC_SEE_OTHER,"Redirect");
  try {
    redirectStrategy.isRedirected(null,response,context);
    Assert.fail("IllegalArgumentException expected");
  }
 catch (  final IllegalArgumentException expected) {
  }
  try {
    redirectStrategy.isRedirected(httpget,null,context);
    Assert.fail("IllegalArgumentException expected");
  }
 catch (  final IllegalArgumentException expected) {
  }
}

</code></pre>

<br>
<pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testGetLocationUriInvalidInput() throws Exception {
  final DefaultRedirectStrategy redirectStrategy=new DefaultRedirectStrategy();
  final HttpClientContext context=HttpClientContext.create();
  final HttpGet httpget=new HttpGet("http://localhost/");
  final HttpResponse response=new BasicHttpResponse(HttpVersion.HTTP_1_1,HttpStatus.SC_MOVED_TEMPORARILY,"Redirect");
  response.addHeader("Location","http://localhost/stuff");
  try {
    redirectStrategy.getLocationURI(null,response,context);
    Assert.fail("IllegalArgumentException expected");
  }
 catch (  final IllegalArgumentException expected) {
  }
  try {
    redirectStrategy.getLocationURI(httpget,null,context);
    Assert.fail("IllegalArgumentException expected");
  }
 catch (  final IllegalArgumentException expected) {
  }
  try {
    redirectStrategy.getLocationURI(httpget,response,null);
    Assert.fail("IllegalArgumentException expected");
  }
 catch (  final IllegalArgumentException expected) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hc.client5.http.impl.routing.TestRouteTracker </h4><pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testIllegalStates(){
  final RouteTracker rt=new RouteTracker(TARGET1,null);
  try {
    rt.tunnelTarget(false);
    Assert.fail("unconnectedness not detected (tunnelTarget)");
  }
 catch (  final IllegalStateException isx) {
  }
  try {
    rt.tunnelProxy(PROXY1,false);
    Assert.fail("unconnectedness not detected (tunnelProxy)");
  }
 catch (  final IllegalStateException isx) {
  }
  try {
    rt.layerProtocol(true);
    Assert.fail("unconnectedness not detected (layerProtocol)");
  }
 catch (  final IllegalStateException isx) {
  }
  rt.connectTarget(false);
  try {
    rt.connectTarget(false);
    Assert.fail("connectedness not detected (connectTarget)");
  }
 catch (  final IllegalStateException isx) {
  }
  try {
    rt.connectProxy(PROXY2,false);
    Assert.fail("connectedness not detected (connectProxy)");
  }
 catch (  final IllegalStateException isx) {
  }
  try {
    rt.tunnelTarget(false);
    Assert.fail("unproxiedness not detected (tunnelTarget)");
  }
 catch (  final IllegalStateException isx) {
  }
  try {
    rt.tunnelProxy(PROXY1,false);
    Assert.fail("unproxiedness not detected (tunnelProxy)");
  }
 catch (  final IllegalStateException isx) {
  }
}

</code></pre>

<br>
<pre class="type-8 type-4 type-1 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@SuppressWarnings("unused") @Test public void testCstrRoute(){
  HttpRoute r=new HttpRoute(TARGET1);
  RouteTracker rt=new RouteTracker(r);
  Assert.assertEquals("wrong target (r1)",TARGET1,rt.getTargetHost());
  Assert.assertEquals("wrong local address (r1)",null,rt.getLocalAddress());
  Assert.assertEquals("wrong hop count (r1)",0,rt.getHopCount());
  Assert.assertEquals("wrong proxy (r1)",null,rt.getProxyHost());
  Assert.assertEquals("wrong route (r1)",null,rt.toRoute());
  checkCTLS(rt,false,false,false,false);
  r=new HttpRoute(TARGET2,LOCAL61,true);
  rt=new RouteTracker(r);
  Assert.assertEquals("wrong target (r2)",TARGET2,rt.getTargetHost());
  Assert.assertEquals("wrong local address (r2)",LOCAL61,rt.getLocalAddress());
  Assert.assertEquals("wrong hop count (r2)",0,rt.getHopCount());
  Assert.assertEquals("wrong proxy (r2)",null,rt.getProxyHost());
  Assert.assertEquals("wrong route (r2)",null,rt.toRoute());
  checkCTLS(rt,false,false,false,false);
  r=new HttpRoute(TARGET1,LOCAL42,PROXY3,true);
  rt=new RouteTracker(r);
  Assert.assertEquals("wrong target (r3)",TARGET1,rt.getTargetHost());
  Assert.assertEquals("wrong local address (r3)",LOCAL42,rt.getLocalAddress());
  Assert.assertEquals("wrong hop count (r3)",0,rt.getHopCount());
  Assert.assertEquals("wrong proxy (r3)",null,rt.getProxyHost());
  Assert.assertEquals("wrong route (r3)",null,rt.toRoute());
  checkCTLS(rt,false,false,false,false);
  rt=null;
  try {
    new RouteTracker(null);
    Assert.fail("null route not detected");
  }
 catch (  final NullPointerException npx) {
  }
}

</code></pre>

<br>
<pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testIllegalArgs(){
  final RouteTracker rt=new RouteTracker(TARGET2,null);
  try {
    rt.connectProxy(null,true);
    Assert.fail("missing proxy argument not detected (connect/false)");
  }
 catch (  final IllegalArgumentException iax) {
  }
  try {
    rt.connectProxy(null,false);
    Assert.fail("missing proxy argument not detected (connect/true)");
  }
 catch (  final IllegalArgumentException iax) {
  }
  rt.connectProxy(PROXY1,false);
  try {
    rt.tunnelProxy(null,false);
    Assert.fail("missing proxy argument not detected (tunnel/false)");
  }
 catch (  final IllegalArgumentException iax) {
  }
  try {
    rt.tunnelProxy(null,true);
    Assert.fail("missing proxy argument not detected (tunnel/true)");
  }
 catch (  final IllegalArgumentException iax) {
  }
  try {
    rt.getHopTarget(-1);
    Assert.fail("negative hop index not detected");
  }
 catch (  final IllegalArgumentException iax) {
  }
  try {
    rt.getHopTarget(2);
    Assert.fail("excessive hop index not detected");
  }
 catch (  final IllegalArgumentException iax) {
  }
}

</code></pre>

<br>
<pre class="type-8 type-4 type-1 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@SuppressWarnings("unused") @Test public void testCstrTargetLocal(){
  RouteTracker rt=new RouteTracker(TARGET1,null);
  Assert.assertEquals("wrong target (target,null)",TARGET1,rt.getTargetHost());
  Assert.assertEquals("wrong local address (target,null)",null,rt.getLocalAddress());
  Assert.assertEquals("wrong hop count (target,null)",0,rt.getHopCount());
  Assert.assertEquals("wrong proxy (target,null)",null,rt.getProxyHost());
  Assert.assertEquals("wrong route (target,null)",null,rt.toRoute());
  checkCTLS(rt,false,false,false,false);
  rt=new RouteTracker(TARGET2,LOCAL61);
  Assert.assertEquals("wrong target (target,local)",TARGET2,rt.getTargetHost());
  Assert.assertEquals("wrong local address (target,local)",LOCAL61,rt.getLocalAddress());
  Assert.assertEquals("wrong hop count (target,local)",0,rt.getHopCount());
  Assert.assertEquals("wrong proxy (target,local)",null,rt.getProxyHost());
  Assert.assertEquals("wrong route (target,local)",null,rt.toRoute());
  checkCTLS(rt,false,false,false,false);
  rt=null;
  try {
    new RouteTracker(null,LOCAL41);
    Assert.fail("null target not detected");
  }
 catch (  final IllegalArgumentException iax) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hc.client5.http.impl.sync.TestResponseEntityWrapper </h4><pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testReusableEntityEndOfStreamIOError() throws Exception {
  Mockito.when(instream.read()).thenReturn(-1);
  Mockito.when(entity.isStreaming()).thenReturn(true);
  Mockito.when(connHolder.isReusable()).thenReturn(true);
  Mockito.doThrow(new IOException()).when(instream).close();
  final InputStream content=wrapper.getContent();
  try {
    content.read();
    Assert.fail("IOException expected");
  }
 catch (  final IOException ex) {
  }
  Mockito.verify(connHolder).abortConnection();
}

</code></pre>

<br>
<pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testReusableEntityWriteToIOError() throws Exception {
  final OutputStream outstream=Mockito.mock(OutputStream.class);
  Mockito.when(entity.isStreaming()).thenReturn(true);
  Mockito.when(connHolder.isReusable()).thenReturn(true);
  Mockito.doThrow(new IOException()).when(entity).writeTo(outstream);
  try {
    wrapper.writeTo(outstream);
    Assert.fail("IOException expected");
  }
 catch (  final IOException ex) {
  }
  Mockito.verify(connHolder,Mockito.never()).releaseConnection();
  Mockito.verify(connHolder).abortConnection();
}

</code></pre>

<br>
<pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testReusableEntityStreamClosedIOError() throws Exception {
  Mockito.when(entity.isStreaming()).thenReturn(true);
  Mockito.when(connHolder.isReusable()).thenReturn(true);
  Mockito.doThrow(new IOException()).when(instream).close();
  try {
    EntityUtils.consume(wrapper);
    Assert.fail("IOException expected");
  }
 catch (  final IOException ex) {
  }
  Mockito.verify(connHolder).abortConnection();
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hc.client5.http.io.TestEofSensorInputStream </h4><pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testReadAfterAbort() throws Exception {
  Mockito.when(eofwatcher.streamAbort(Mockito.<InputStream>any())).thenReturn(Boolean.TRUE);
  eofstream.abortConnection();
  try {
    eofstream.read();
    Assert.fail("IOException expected");
  }
 catch (  final IOException ex) {
  }
  final byte[] tmp=new byte[1];
  try {
    eofstream.read(tmp);
    Assert.fail("IOException expected");
  }
 catch (  final IOException ex) {
  }
}

</code></pre>

<br>
<pre class="type-8 type-2 type-4 type-6 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testCloseIOError() throws Exception {
  Mockito.when(eofwatcher.streamClosed(Mockito.<InputStream>any())).thenThrow(new IOException());
  try {
    eofstream.close();
    Assert.fail("IOException expected");
  }
 catch (  final IOException ex) {
  }
  Assert.assertTrue(eofstream.isSelfClosed());
  Assert.assertNull(eofstream.getWrappedStream());
  Mockito.verify(eofwatcher).streamClosed(instream);
}

</code></pre>

<br>
<pre class="type-8 type-2 type-4 type-6 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testAbortConnectionIOError() throws Exception {
  Mockito.when(eofwatcher.streamAbort(Mockito.<InputStream>any())).thenThrow(new IOException());
  try {
    eofstream.abortConnection();
    Assert.fail("IOException expected");
  }
 catch (  final IOException ex) {
  }
  Assert.assertTrue(eofstream.isSelfClosed());
  Assert.assertNull(eofstream.getWrappedStream());
  Mockito.verify(eofwatcher).streamAbort(instream);
}

</code></pre>

<br>
<pre class="type-8 type-2 type-4 type-6 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testReadIOError() throws Exception {
  Mockito.when(eofwatcher.eofDetected(Mockito.<InputStream>any())).thenReturn(Boolean.TRUE);
  Mockito.when(instream.read()).thenThrow(new IOException());
  try {
    eofstream.read();
    Assert.fail("IOException expected");
  }
 catch (  final IOException ex) {
  }
  Assert.assertFalse(eofstream.isSelfClosed());
  Assert.assertNull(eofstream.getWrappedStream());
  Mockito.verify(eofwatcher).streamAbort(instream);
}

</code></pre>

<br>
<pre class="type-8 type-2 type-4 type-6 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testReadByteArrayIOError() throws Exception {
  Mockito.when(eofwatcher.eofDetected(Mockito.<InputStream>any())).thenReturn(Boolean.TRUE);
  Mockito.when(instream.read(Mockito.<byte[]>any(),Mockito.anyInt(),Mockito.anyInt())).thenThrow(new IOException());
  final byte[] tmp=new byte[1];
  try {
    eofstream.read(tmp);
    Assert.fail("IOException expected");
  }
 catch (  final IOException ex) {
  }
  Assert.assertFalse(eofstream.isSelfClosed());
  Assert.assertNull(eofstream.getWrappedStream());
  Mockito.verify(eofwatcher).streamAbort(instream);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hc.client5.http.protocol.TestRequestExpectContinue </h4><pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testRequestExpectContinueInvalidInput() throws Exception {
  final RequestExpectContinue interceptor=new RequestExpectContinue();
  try {
    interceptor.process(null,null);
    Assert.fail("IllegalArgumentException should have been thrown");
  }
 catch (  final IllegalArgumentException ex) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hc.client5.http.routing.TestHttpRoute </h4><pre class="type-8 type-4 type-1 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testHopping(){
  HttpHost[] proxies=null;
  HttpRoute route=new HttpRoute(TARGET1,null,proxies,true,TunnelType.PLAIN,LayerType.PLAIN);
  Assert.assertEquals("A: hop count",1,route.getHopCount());
  Assert.assertEquals("A: hop 0",TARGET1,route.getHopTarget(0));
  try {
    final HttpHost beyond=route.getHopTarget(1);
    Assert.fail("A: hop 1 is " + beyond);
  }
 catch (  final IllegalArgumentException iax) {
  }
  try {
    final HttpHost before=route.getHopTarget(-1);
    Assert.fail("A: hop -1 is " + before);
  }
 catch (  final IllegalArgumentException iax) {
  }
  proxies=new HttpHost[]{PROXY3};
  route=new HttpRoute(TARGET1,LOCAL62,proxies,false,TunnelType.TUNNELLED,LayerType.PLAIN);
  Assert.assertEquals("B: hop count",2,route.getHopCount());
  Assert.assertEquals("B: hop 0",PROXY3,route.getHopTarget(0));
  Assert.assertEquals("B: hop 1",TARGET1,route.getHopTarget(1));
  try {
    final HttpHost beyond=route.getHopTarget(2);
    Assert.fail("B: hop 2 is " + beyond);
  }
 catch (  final IllegalArgumentException iax) {
  }
  try {
    final HttpHost before=route.getHopTarget(-2);
    Assert.fail("B: hop -2 is " + before);
  }
 catch (  final IllegalArgumentException iax) {
  }
  proxies=new HttpHost[]{PROXY3,PROXY1,PROXY2};
  route=new HttpRoute(TARGET1,LOCAL42,proxies,false,TunnelType.PLAIN,LayerType.LAYERED);
  Assert.assertEquals("C: hop count",4,route.getHopCount());
  Assert.assertEquals("C: hop 0",PROXY3,route.getHopTarget(0));
  Assert.assertEquals("C: hop 1",PROXY1,route.getHopTarget(1));
  Assert.assertEquals("C: hop 2",PROXY2,route.getHopTarget(2));
  Assert.assertEquals("C: hop 3",TARGET1,route.getHopTarget(3));
  try {
    final HttpHost beyond=route.getHopTarget(4);
    Assert.fail("C: hop 4 is " + beyond);
  }
 catch (  final IllegalArgumentException iax) {
  }
  try {
    final HttpHost before=route.getHopTarget(Integer.MIN_VALUE);
    Assert.fail("C: hop -<min> is " + before);
  }
 catch (  final IllegalArgumentException iax) {
  }
}

</code></pre>

<br>
<pre class="type-8 type-1 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@SuppressWarnings("unused") @Test public void testCstr4(){
  HttpRoute route=new HttpRoute(TARGET2,null,PROXY2,false);
  HttpRoute should=new HttpRoute(TARGET2,null,new HttpHost[]{PROXY2},false,TunnelType.PLAIN,LayerType.PLAIN);
  Assert.assertEquals("bad convenience route 4/insecure",route,should);
  route=new HttpRoute(TARGET2,LOCAL42,PROXY1,true);
  should=new HttpRoute(TARGET2,LOCAL42,new HttpHost[]{PROXY1},true,TunnelType.TUNNELLED,LayerType.LAYERED);
  Assert.assertEquals("bad convenience route 4/secure",route,should);
  try {
    new HttpRoute(TARGET1,LOCAL61,null,false);
    Assert.fail("missing proxy not detected");
  }
 catch (  final IllegalArgumentException iax) {
  }
}

</code></pre>

<br>
<pre class="type-8 type-6 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@SuppressWarnings("unused") @Test public void testInvalidArguments(){
  final HttpHost[] chain1={PROXY1};
  final HttpRoute route=new HttpRoute(TARGET1,null,chain1,false,TunnelType.TUNNELLED,LayerType.PLAIN);
  Assert.assertNotNull(route);
  try {
    new HttpRoute(null,null,chain1,false,TunnelType.TUNNELLED,LayerType.PLAIN);
    Assert.fail("missing target not detected");
  }
 catch (  final IllegalArgumentException iax) {
  }
  try {
    new HttpRoute(TARGET1,null,(HttpHost[])null,false,TunnelType.TUNNELLED,LayerType.PLAIN);
    Assert.fail("missing proxy for tunnel not detected");
  }
 catch (  final IllegalArgumentException iax) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hc.client5.http.ssl.TestDefaultHostnameVerifier </h4><pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testHTTPCLIENT_1316() throws Exception {
  final String host1="2001:0db8:aaaa:bbbb:cccc:0:0:0001";
  DefaultHostnameVerifier.matchIPv6Address(host1,Arrays.asList("2001:0db8:aaaa:bbbb:cccc:0:0:0001"));
  DefaultHostnameVerifier.matchIPv6Address(host1,Arrays.asList("2001:0db8:aaaa:bbbb:cccc::1"));
  try {
    DefaultHostnameVerifier.matchIPv6Address(host1,Arrays.asList("2001:0db8:aaaa:bbbb:cccc::10"));
    Assert.fail("SSLException expected");
  }
 catch (  final SSLException expected) {
  }
  final String host2="2001:0db8:aaaa:bbbb:cccc::1";
  DefaultHostnameVerifier.matchIPv6Address(host2,Arrays.asList("2001:0db8:aaaa:bbbb:cccc:0:0:0001"));
  DefaultHostnameVerifier.matchIPv6Address(host2,Arrays.asList("2001:0db8:aaaa:bbbb:cccc::1"));
  try {
    DefaultHostnameVerifier.matchIPv6Address(host2,Arrays.asList("2001:0db8:aaaa:bbbb:cccc::10"));
    Assert.fail("SSLException expected");
  }
 catch (  final SSLException expected) {
  }
}

</code></pre>

<br>
<pre class="type-7 type-8 type-1 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testSubjectAlt() throws Exception {
  final CertificateFactory cf=CertificateFactory.getInstance("X.509");
  final InputStream in=new ByteArrayInputStream(CertificatesToPlayWith.X509_MULTIPLE_SUBJECT_ALT);
  final X509Certificate x509=(X509Certificate)cf.generateCertificate(in);
  Assert.assertEquals("CN=localhost, OU=Unknown, O=Unknown, L=Unknown, ST=Unknown, C=CH",x509.getSubjectDN().getName());
  impl.verify("localhost.localdomain",x509);
  impl.verify("127.0.0.1",x509);
  try {
    impl.verify("localhost",x509);
    Assert.fail("SSLException should have been thrown");
  }
 catch (  final SSLException ex) {
  }
  try {
    impl.verify("local.host",x509);
    Assert.fail("SSLException should have been thrown");
  }
 catch (  final SSLException ex) {
  }
  try {
    impl.verify("127.0.0.2",x509);
    Assert.fail("SSLException should have been thrown");
  }
 catch (  final SSLException ex) {
  }
}

</code></pre>

<br>
<pre class="type-8 type-1 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testExtractCN() throws Exception {
  Assert.assertEquals("blah",DefaultHostnameVerifier.extractCN("cn=blah, ou=blah, o=blah"));
  Assert.assertEquals("blah",DefaultHostnameVerifier.extractCN("cn=blah, cn=yada, cn=booh"));
  Assert.assertEquals("blah",DefaultHostnameVerifier.extractCN("c = pampa ,  cn  =    blah    , ou = blah , o = blah"));
  Assert.assertEquals("blah",DefaultHostnameVerifier.extractCN("cn=\"blah\", ou=blah, o=blah"));
  Assert.assertEquals("blah  blah",DefaultHostnameVerifier.extractCN("cn=\"blah  blah\", ou=blah, o=blah"));
  Assert.assertEquals("blah, blah",DefaultHostnameVerifier.extractCN("cn=\"blah, blah\", ou=blah, o=blah"));
  Assert.assertEquals("blah, blah",DefaultHostnameVerifier.extractCN("cn=blah\\, blah, ou=blah, o=blah"));
  Assert.assertEquals("blah",DefaultHostnameVerifier.extractCN("c = cn=uuh, cn=blah, ou=blah, o=blah"));
  try {
    DefaultHostnameVerifier.extractCN("blah,blah");
    Assert.fail("SSLException expected");
  }
 catch (  final SSLException expected) {
  }
  try {
    DefaultHostnameVerifier.extractCN("cn,o=blah");
    Assert.fail("SSLException expected");
  }
 catch (  final SSLException expected) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hc.client5.http.utils.TestDateUtils </h4><pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testInvalidInput() throws Exception {
  try {
    DateUtils.parseDate(null,null,null);
    Assert.fail("IllegalArgumentException should habe been thrown");
  }
 catch (  final IllegalArgumentException ex) {
  }
  try {
    DateUtils.formatDate(null);
    Assert.fail("IllegalArgumentException should habe been thrown");
  }
 catch (  final IllegalArgumentException ex) {
  }
  try {
    DateUtils.formatDate(new Date(),null);
    Assert.fail("IllegalArgumentException should habe been thrown");
  }
 catch (  final IllegalArgumentException ex) {
  }
}

</code></pre>

<br>
<script>$(document).ready(function() {
  $('pre code').each(function(i, block) {
    hljs.highlightBlock(block);
  });
});</script>
