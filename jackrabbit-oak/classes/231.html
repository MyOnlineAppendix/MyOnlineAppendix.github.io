<h3 style="margin:0px">Class: org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreTest (54 methods) </h3><br><pre style="padding:0"><code class="html"><div id="tags"><button id="6"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('6')" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls"><kbd id="tag-6"class="label-info"style="display: inline-block;font-size:7pt" >InternalCallVerifier&nbsp;(34)</kbd></button>&nbsp;<button id="7"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('7')" data-toggle="tooltip" title="Verifies boolean conditions"><kbd id="tag-7"class="label-info"style="display: inline-block;font-size:7pt" >BooleanVerifier&nbsp;(31)</kbd></button>&nbsp;<button id="9"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('9')" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) "><kbd id="tag-9"class="label-info"style="display: inline-block;font-size:7pt" >APIUtilityVerifier&nbsp;(27)</kbd></button>&nbsp;<button id="3"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('3')" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes"><kbd id="tag-3"class="label-info"style="display: inline-block;font-size:7pt" >HybridVerifier&nbsp;(24)</kbd></button>&nbsp;<button id="4"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('4')" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value "><kbd id="tag-4"class="label-info"style="display: inline-block;font-size:7pt" >EqualityVerifier&nbsp;(19)</kbd></button>&nbsp;<button id="8"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('8')" data-toggle="tooltip" title="Verifies whether objects are null"><kbd id="tag-8"class="label-info"style="display: inline-block;font-size:7pt" >NullVerifier&nbsp;(15)</kbd></button>&nbsp;<button id="10"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('10')" data-toggle="tooltip" title="Executes methods or other tests from the same test unit"><kbd id="tag-10"class="label-info"style="display: inline-block;font-size:7pt" >ExecutionTester&nbsp;(10)</kbd></button>&nbsp;<button id="5"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('5')" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure"><kbd id="tag-5"class="label-info"style="display: inline-block;font-size:7pt" >UtilityVerifier&nbsp;(8)</kbd></button>&nbsp;<button id="13"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('13')" data-toggle="tooltip" title="Verifies assertions in iterations"><kbd id="tag-13"class="label-info"style="display: inline-block;font-size:7pt" >IterativeVerifier&nbsp;(3)</kbd></button>&nbsp;<button id="12"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('12')" data-toggle="tooltip" title="Verifies assertions inside branch conditions"><kbd id="tag-12"class="label-info"style="display: inline-block;font-size:7pt" >BranchVerifier&nbsp;(1)</kbd></button>&nbsp;<button id="1"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('1')" data-toggle="tooltip" title="Releases resources used by the test cases"><kbd id="tag-1"class="label-info"style="display: inline-block;font-size:7pt" >TestCleaner&nbsp;(1)</kbd></button>&nbsp;</div></code></pre><center><button onclick="showBlocks()" style="margin:6px">Update filter <span class="glyphicon glyphicon-refresh" aria-hidden="true"></span> </button></center><br>
<pre class="type-9 type-6 type-4 type-8 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void concurrentChildOperations() throws Exception {
  Clock clock=new Clock.Virtual();
  Revision.setClock(clock);
  MemoryDocumentStore store=new MemoryDocumentStore();
  DocumentNodeStore ns1=builderProvider.newBuilder().setAsyncDelay(0).clock(clock).setDocumentStore(store).setClusterId(1).getNodeStore();
  DocumentNodeStore ns2=builderProvider.newBuilder().setAsyncDelay(0).clock(clock).setDocumentStore(store).setClusterId(2).getNodeStore();
  NodeBuilder b1=ns1.getRoot().builder();
  NodeBuilder node=b1.child("foo").child("bar");
  node.child("child-0");
  node.child("child-1");
  node.child("child-2");
  merge(ns1,b1);
  ns1.runBackgroundOperations();
  ns2.runBackgroundOperations();
  b1=ns1.getRoot().builder();
  b1.child("foo").child("bar").getChildNode("child-0").remove();
  merge(ns1,b1);
  ns1.runBackgroundOperations();
  NodeBuilder b2=ns2.getRoot().builder();
  b2.child("foo").child("bar").getChildNode("child-1").remove();
  merge(ns2,b2);
  List<ChildNodeEntry> children=Lists.newArrayList(ns2.getRoot().getChildNode("foo").getChildNode("bar").getChildNodeEntries());
  assertEquals(2,Iterables.size(children));
  RevisionVector invalidate=null;
  for (  ChildNodeEntry entry : children) {
    if (entry.getName().equals("child-0")) {
      invalidate=asDocumentNodeState(entry.getNodeState()).getRevision();
    }
  }
  assertNotNull(invalidate);
  ns2.runBackgroundOperations();
  clock.waitUntil(clock.getTime() + TimeUnit.HOURS.toMillis(2));
  ns1.getVersionGarbageCollector().gc(1,TimeUnit.HOURS);
  ns2.invalidateNodeCache("/foo/bar/child-0",invalidate);
  children=Lists.newArrayList(ns2.getRoot().getChildNode("foo").getChildNode("bar").getChildNodeEntries());
  assertEquals(1,Iterables.size(children));
}

</code></pre>

<pre class="type-7 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies boolean conditions
"></span><br>
@Test public void readChildrenWithDeletedSiblings() throws Exception {
  final AtomicInteger maxLimit=new AtomicInteger(0);
  DocumentStore docStore=new MemoryDocumentStore(){
    @Nonnull @Override public <T extends Document>List<T> query(    Collection<T> collection,    String fromKey,    String toKey,    int limit){
      if (collection == NODES) {
        maxLimit.set(Math.max(limit,maxLimit.get()));
      }
      return super.query(collection,fromKey,toKey,limit);
    }
  }
;
  DocumentNodeStore ns=builderProvider.newBuilder().setDocumentStore(docStore).setAsyncDelay(0).getNodeStore();
  NodeBuilder builder=ns.getRoot().builder();
  for (int i=0; i < 1000; i++) {
    builder.child("node-" + i);
  }
  ns.merge(builder,EmptyHook.INSTANCE,CommitInfo.EMPTY);
  for (int i=0; i < 999; i++) {
    builder=ns.getRoot().builder();
    builder.getChildNode("node-" + i).remove();
    ns.merge(builder,EmptyHook.INSTANCE,CommitInfo.EMPTY);
  }
  for (  ChildNodeEntry entry : ns.getRoot().getChildNodeEntries()) {
    entry.getName();
  }
  assertTrue(maxLimit.get() + " > " + (DocumentNodeState.INITIAL_FETCH_SIZE + 1),maxLimit.get() <= DocumentNodeState.INITIAL_FETCH_SIZE + 1);
}

</code></pre>

<pre class="type-6 type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
"></span><br>
@Test public void retrieve() throws Exception {
  DocumentNodeStore store=new DocumentMK.Builder().getNodeStore();
  String ref=store.checkpoint(60000);
  assertNotNull(store.retrieve(ref));
  ref=Revision.newRevision(1).toString();
  assertNull(store.retrieve(ref));
  ref=UUID.randomUUID().toString();
  assertNull(store.retrieve(ref));
  store.dispose();
}

</code></pre>

<pre class="type-9 type-7 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
"></span><br>
@Test public void lastRevWithRevisionVector() throws Exception {
  MemoryDocumentStore store=new MemoryDocumentStore();
  DocumentNodeStore ns1=builderProvider.newBuilder().setClusterId(1).setDocumentStore(store).setAsyncDelay(0).getNodeStore();
  DocumentNodeStore ns2=builderProvider.newBuilder().setClusterId(2).setDocumentStore(store).setAsyncDelay(0).getNodeStore();
  NodeBuilder b1=ns1.getRoot().builder();
  b1.child("parent");
  merge(ns1,b1);
  b1=ns1.getRoot().builder();
  NodeBuilder parent=b1.child("parent");
  parent.setProperty("p",1);
  parent.child("child");
  merge(ns1,b1);
  ns1.runBackgroundOperations();
  ns2.runBackgroundOperations();
  NodeBuilder b2=ns2.getRoot().builder();
  b2.child("parent").setProperty("p",2);
  merge(ns2,b2);
  ns2.runBackgroundOperations();
  ns1.runBackgroundOperations();
  assertTrue(ns1.getRoot().getChildNode("parent").hasChildNode("child"));
}

</code></pre>

<pre class="type-13 type-9 type-6 type-4 type-8 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void ignoreUncommitted() throws Exception {
  final AtomicLong numPreviousFinds=new AtomicLong();
  MemoryDocumentStore store=new MemoryDocumentStore(){
    @Override public <T extends Document>T find(    Collection<T> collection,    String key){
      if (Utils.getPathFromId(key).startsWith("p")) {
        numPreviousFinds.incrementAndGet();
      }
      return super.find(collection,key);
    }
  }
;
  DocumentNodeStore ns=builderProvider.newBuilder().setDocumentStore(store).setAsyncDelay(0).getNodeStore();
  String id=Utils.getIdFromPath("/test");
  NodeBuilder b=ns.getRoot().builder();
  b.child("test").setProperty("p","a");
  merge(ns,b);
  NodeDocument doc;
  int i=0;
  do {
    b=ns.getRoot().builder();
    b.child("test").setProperty("q",i++);
    merge(ns,b);
    doc=store.find(NODES,id);
    assertNotNull(doc);
    if (i % 100 == 0) {
      ns.runBackgroundOperations();
    }
  }
 while (doc.getPreviousRanges().isEmpty());
  Revision r=ns.newRevision();
  UpdateOp op=new UpdateOp(id,false);
  NodeDocument.setCommitRoot(op,r,0);
  op.setMapEntry("p",r,"b");
  assertNotNull(store.findAndUpdate(NODES,op));
  doc=store.find(NODES,id);
  numPreviousFinds.set(0);
  doc.getNodeAtRevision(ns,ns.getHeadRevision(),null);
  assertEquals(0,numPreviousFinds.get());
}

</code></pre>

<pre class="type-9 type-6 type-4 type-8 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void getNewestRevision2() throws Exception {
  DocumentStore docStore=new MemoryDocumentStore();
  DocumentNodeStore ns1=builderProvider.newBuilder().setDocumentStore(docStore).setAsyncDelay(0).setClusterId(1).getNodeStore();
  ns1.getRoot();
  Revision r1=ns1.getHeadRevision().getRevision(ns1.getClusterId());
  ns1.runBackgroundOperations();
  DocumentNodeStore ns2=builderProvider.newBuilder().setDocumentStore(docStore).setAsyncDelay(0).setClusterId(2).getNodeStore();
  ns2.getRoot();
  NodeBuilder b1=ns1.getRoot().builder();
  for (int i=0; i < NodeDocument.NUM_REVS_THRESHOLD; i++) {
    b1.setProperty("p",String.valueOf(i));
    ns1.merge(b1,EmptyHook.INSTANCE,CommitInfo.EMPTY);
  }
  ns1.runBackgroundOperations();
  NodeDocument doc=docStore.find(NODES,Utils.getIdFromPath("/"));
  assertNotNull(doc);
  Revision newest=doc.getNewestRevision(ns2,ns2.getHeadRevision(),Revision.newRevision(ns2.getClusterId()),null,Sets.<Revision>newHashSet());
  assertEquals(r1,newest);
}

</code></pre>

<pre class="type-5 type-7 type-6 type-8 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void notYetVisibleExceptionMessage() throws Exception {
  MemoryDocumentStore store=new MemoryDocumentStore();
  DocumentNodeStore ns1=builderProvider.newBuilder().setDocumentStore(store).setAsyncDelay(0).setClusterId(1).getNodeStore();
  DocumentNodeStore ns2=builderProvider.newBuilder().setDocumentStore(store).setAsyncDelay(0).setClusterId(2).getNodeStore();
  ns2.setMaxBackOffMillis(0);
  NodeBuilder b1=ns1.getRoot().builder();
  b1.child("test").setProperty("p","v");
  merge(ns1,b1);
  NodeBuilder b2=ns2.getRoot().builder();
  b2.child("test").setProperty("q","v");
  try {
    merge(ns2,b2);
    fail("Must throw CommitFailedException");
  }
 catch (  CommitFailedException e) {
    assertNotNull(e.getCause());
    assertTrue(e.getCause().getMessage().contains("not yet visible"));
  }
}

</code></pre>

<pre class="type-10 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test public void mergeDeleteDeleteNonEmptyInternalDocShouldFail() throws Exception {
  final DocumentNodeStore store=builderProvider.newBuilder().getNodeStore();
  store.setEnableConcurrentAddRemove(true);
  NodeBuilder builder=store.getRoot().builder();
  builder.child(":a").setProperty("foo","bar");
  builder.child(":b");
  merge(store,builder);
  SingleInstanceConflictUtility.generateConflict(store,new String[]{":1"},new String[]{":a"},new String[]{":2"},new String[]{":b"},new String[]{":3"},new String[]{":a",":b"},false,"Delete-delete merge conflicts for non-empty internal docs should fail");
}

</code></pre>

<pre class="type-10 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test public void mergeDeleteDeleteNormalDocShouldFail() throws Exception {
  final DocumentNodeStore store=builderProvider.newBuilder().getNodeStore();
  store.setEnableConcurrentAddRemove(true);
  NodeBuilder builder=store.getRoot().builder();
  builder.child("a");
  builder.child("b");
  merge(store,builder);
  SingleInstanceConflictUtility.generateConflict(store,new String[]{":1"},new String[]{"a"},new String[]{":2"},new String[]{"b"},new String[]{":3"},new String[]{"a","b"},false,"Delete-delete merge conflicts for normal docs should fail");
}

</code></pre>

<pre class="type-13 type-5 type-7 type-6 type-4 type-8 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void commitHookChangesOnBranch() throws Exception {
  final int NUM_NODES=DocumentRootBuilder.UPDATE_LIMIT / 2;
  final int NUM_PROPS=10;
  DocumentNodeStore ns=builderProvider.newBuilder().getNodeStore();
  NodeBuilder builder=ns.getRoot().builder();
  for (int i=0; i < NUM_NODES; i++) {
    NodeBuilder c=builder.child("n" + i);
    for (int j=0; j < NUM_PROPS; j++) {
      c.setProperty("q" + j,"value");
      c.setProperty("p" + j,"value");
    }
  }
  try {
    ns.merge(builder,CompositeHook.compose(Arrays.asList(new TestHook("p"),new TestHook("q"),FAILING_HOOK)),CommitInfo.EMPTY);
    fail("merge must fail and reset changes done by commit hooks");
  }
 catch (  CommitFailedException e) {
  }
  for (int i=0; i < NUM_NODES; i++) {
    NodeBuilder c=builder.getChildNode("n" + i);
    assertTrue(c.exists());
    for (int j=0; j < NUM_PROPS; j++) {
      PropertyState p=c.getProperty("p" + j);
      assertNotNull(p);
      assertEquals("value",p.getValue(Type.STRING));
      p=c.getProperty("q" + j);
      assertNotNull(p);
      assertEquals("value",p.getValue(Type.STRING));
    }
  }
  ns.merge(builder,CompositeHook.compose(Arrays.<CommitHook>asList(new TestHook("p"),new TestHook("q"))),CommitInfo.EMPTY);
  builder=ns.getRoot().builder();
  for (int i=0; i < NUM_NODES; i++) {
    NodeBuilder c=builder.getChildNode("n" + i);
    assertTrue(c.exists());
    for (int j=0; j < NUM_PROPS; j++) {
      PropertyState p=c.getProperty("p" + j);
      assertNotNull(p);
      assertEquals("test",p.getValue(Type.STRING));
      p=c.getProperty("q" + j);
      assertNotNull(p);
      assertEquals("test",p.getValue(Type.STRING));
    }
  }
}

</code></pre>

<pre class="type-10 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test public void mergeDeleteChangedInternalDocShouldFail() throws Exception {
  final DocumentNodeStore store=builderProvider.newBuilder().getNodeStore();
  store.setEnableConcurrentAddRemove(true);
  NodeBuilder builder=store.getRoot().builder();
  builder.child(":a");
  builder.child(":b");
  merge(store,builder);
  SingleInstanceConflictUtility.generateConflict(store,new String[]{":1",":a"},new String[]{},true,new String[]{":2",":b"},new String[]{},true,new String[]{":3"},new String[]{":a",":b"},false,false,"Delete changed merge conflicts for internal docs should fail");
}

</code></pre>

<pre class="type-9 type-5 type-7 type-6 type-4 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void dispose() throws CommitFailedException, InterruptedException {
  final BlockingQueue<String> updates=new ArrayBlockingQueue<String>(1);
  final AtomicBoolean throttleUpdates=new AtomicBoolean(true);
  MemoryDocumentStore docStore=new MemoryDocumentStore(){
    @Override public <T extends Document>void update(    Collection<T> collection,    List<String> keys,    UpdateOp updateOp){
      if (throttleUpdates.get()) {
        for (        String k : keys) {
          try {
            updates.put(k);
          }
 catch (          InterruptedException e) {
            throw new RuntimeException(e);
          }
        }
      }
      super.update(collection,keys,updateOp);
    }
  }
;
  final DocumentNodeStore store=builderProvider.newBuilder().setClusterId(1).setAsyncDelay(0).setDocumentStore(docStore).getNodeStore();
  updates.clear();
  NodeBuilder builder=store.getRoot().builder();
  builder.child("test").child("node");
  merge(store,builder);
  builder=store.getRoot().builder();
  builder.child("test").child("node").child("child-1");
  merge(store,builder);
  Thread t=new Thread(new Runnable(){
    @Override public void run(){
      store.dispose();
    }
  }
);
  t.start();
  String p=updates.take();
  assertEquals("2:/test/node",p);
  assertTrue(t.isAlive());
  for (; ; ) {
    if (updates.peek() != null) {
      break;
    }
  }
  try {
    builder=store.getRoot().builder();
    builder.child("test").child("node").child("child-2");
    merge(store,builder);
    fail("Merge must fail with CommitFailedException");
  }
 catch (  CommitFailedException e) {
  }
  while (t.isAlive()) {
    updates.poll(10,TimeUnit.MILLISECONDS);
  }
  updates.clear();
  throttleUpdates.set(false);
  DocumentNodeStore store2=builderProvider.newBuilder().setClusterId(2).setAsyncDelay(0).setDocumentStore(docStore).getNodeStore();
  LastRevRecoveryAgent agent=new LastRevRecoveryAgent(store2);
  if (agent.isRecoveryNeeded()) {
    agent.recover(1);
  }
  builder=store2.getRoot().builder();
  NodeBuilder test=builder.getChildNode("test");
  assertTrue(test.exists());
  NodeBuilder node=test.getChildNode("node");
  assertTrue(node.exists());
  if (!node.hasChildNode("child-2")) {
    node.child("child-2");
    merge(store2,builder);
  }
}

</code></pre>

<pre class="type-7 type-6 type-4 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void rootRevision() throws Exception {
  DocumentNodeStore ns=builderProvider.newBuilder().getNodeStore();
  NodeBuilder builder=ns.getRoot().builder();
  builder.child("foo").child("child");
  builder.child("bar").child("child");
  merge(ns,builder);
  builder=ns.getRoot().builder();
  builder.child("foo").child("child").child("node");
  merge(ns,builder);
  RevisionVector head=ns.getHeadRevision();
  NodeState child=ns.getRoot().getChildNode("bar").getChildNode("child");
  assertTrue(child instanceof DocumentNodeState);
  DocumentNodeState state=(DocumentNodeState)child;
  assertEquals(head,state.getRootRevision());
}

</code></pre>

<pre class="type-9 type-7 type-6 type-4 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void backgroundLeaseUpdateThread() throws Exception {
  int clusterId=-1;
  Random random=new Random();
  for (int i=0; i < 10; i++) {
    int id=random.nextInt(1000) + 1000;
    if (!backgroundLeaseUpdateThreadRunning(id)) {
      clusterId=id;
      break;
    }
  }
  assertNotEquals(-1,clusterId);
  DocumentNodeStore ns=builderProvider.newBuilder().setAsyncDelay(0).setClusterId(clusterId).getNodeStore();
  for (int i=0; i < 10; i++) {
    if (!backgroundLeaseUpdateThreadRunning(clusterId)) {
      Thread.sleep(100);
    }
  }
  assertTrue(backgroundLeaseUpdateThreadRunning(clusterId));
  assertEquals(clusterId,ns.getClusterId());
}

</code></pre>

<pre class="type-9 type-7 type-6 type-4 type-8 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void readFromPreviousDoc() throws CommitFailedException {
  DocumentStore docStore=new MemoryDocumentStore();
  DocumentNodeStore ns=builderProvider.newBuilder().setDocumentStore(docStore).getNodeStore();
  NodeBuilder builder=ns.getRoot().builder();
  builder.child("test").setProperty("prop","initial");
  ns.merge(builder,EmptyHook.INSTANCE,CommitInfo.EMPTY);
  ns.dispose();
  ns=builderProvider.newBuilder().setClusterId(2).setAsyncDelay(0).setDocumentStore(docStore).getNodeStore();
  builder=ns.getRoot().builder();
  builder.child("test").setProperty("prop","value");
  ns.merge(builder,EmptyHook.INSTANCE,CommitInfo.EMPTY);
  RevisionVector rev=ns.getHeadRevision();
  NodeDocument doc=docStore.find(NODES,Utils.getIdFromPath("/test"));
  assertNotNull(doc);
  DocumentNodeState state=doc.getNodeAtRevision(ns,rev,null);
  assertNotNull(state);
  assertTrue(state.hasProperty("prop"));
  assertEquals("value",state.getProperty("prop").getValue(Type.STRING));
  for (int i=0; i < NUM_REVS_THRESHOLD; i++) {
    builder=ns.getRoot().builder();
    builder.child("test").setProperty("prop","v-" + i);
    ns.merge(builder,EmptyHook.INSTANCE,CommitInfo.EMPTY);
  }
  ns.runBackgroundOperations();
  doc=docStore.find(NODES,Utils.getIdFromPath("/test"));
  assertNotNull(doc);
  state=doc.getNodeAtRevision(ns,rev,null);
  assertNotNull(state);
  assertTrue(state.hasProperty("prop"));
  assertEquals("value",state.getProperty("prop").getValue(Type.STRING));
}

</code></pre>

<pre class="type-9 type-7 type-6 type-4 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void docChildCacheWithIncompatiblDocStoreSort() throws CommitFailedException {
  final Set<String> reads=Sets.newHashSet();
  final ConcurrentSkipListMap<String,NodeDocument> nodes=new ConcurrentSkipListMap<String,NodeDocument>(new Comparator<String>(){
    @Override public int compare(    String o1,    String o2){
      int ret=o1.compareTo(o2);
      if (o1.indexOf("child") > 0 && o2.indexOf("child") > 0) {
        ret=(-ret);
      }
      return ret;
    }
  }
);
  MemoryDocumentStore docStore=new MemoryDocumentStore(){
    @Override @SuppressWarnings("unchecked") protected <T extends Document>ConcurrentSkipListMap<String,T> getMap(    Collection<T> collection){
      if (collection == Collection.NODES) {
        return (ConcurrentSkipListMap<String,T>)nodes;
      }
 else {
        return super.getMap(collection);
      }
    }
    @Override public <T extends Document>T find(    Collection<T> collection,    String key){
      reads.add(key);
      return super.find(collection,key);
    }
  }
;
  DocumentNodeStore store=builderProvider.newBuilder().setUseSimpleRevision(true).setClusterId(1).setAsyncDelay(0).setDocumentStore(docStore).getNodeStore();
  NodeBuilder builder=store.getRoot().builder();
  NodeBuilder parentBuilder=builder.child("parent");
  int numChildren=DocumentNodeState.INITIAL_FETCH_SIZE - 2;
  for (int i=0; i < numChildren; i++) {
    parentBuilder.child("child" + (i + 1));
  }
  merge(store,builder);
  store.invalidateNodeChildrenCache();
  NodeState parentNodeState=store.getRoot().getChildNode("parent");
  Iterables.size(parentNodeState.getChildNodeEntries());
  reads.clear();
  NodeState nonExistingChild=parentNodeState.getChildNode("child501-non-existing-child");
  assertEquals("Fully cached entry in doc child cache should be able to find non existing children" + " even if doc store sort order is incompatible to that of Java",0,reads.size());
  assertFalse("Non existing children should be reported as such",nonExistingChild.exists());
  store.invalidateNodeCache("/parent/child25",store.getHeadRevision());
  reads.clear();
  NodeState existingChild=parentNodeState.getChildNode("child25");
  assertTrue("Fully cached entry in doc child cache should be able to find existing children" + " even if doc store sort order is incompatible to that of Java",reads.size() > 0);
  assertTrue("Existing children should be reported as such",existingChild.exists());
}

</code></pre>

<pre class="type-9 type-7 type-6 type-4 type-8 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void rollback() throws Exception {
  final Map<Thread,Semaphore> locks=Collections.synchronizedMap(new HashMap<Thread,Semaphore>());
  final Semaphore created=new Semaphore(0);
  DocumentStore docStore=new MemoryDocumentStore(){
    @Override public <T extends Document>List<T> createOrUpdate(    Collection<T> collection,    List<UpdateOp> updateOps){
      Semaphore semaphore=locks.get(Thread.currentThread());
      List<T> result=super.createOrUpdate(collection,updateOps);
      if (semaphore != null) {
        created.release();
        semaphore.acquireUninterruptibly();
      }
      return result;
    }
  }
;
  final List<Exception> exceptions=new ArrayList<Exception>();
  final DocumentMK mk=builderProvider.newBuilder().setDocumentStore(docStore).setAsyncDelay(0).open();
  final DocumentNodeStore store=mk.getNodeStore();
  NodeBuilder builder=store.getRoot().builder();
  builder.child("deletedNode");
  builder.child("updateNode").setProperty("foo","bar");
  merge(store,builder);
  builder=store.getRoot().builder();
  builder.child("deletedNode").remove();
  merge(store,builder);
  final RevisionVector head=store.getHeadRevision();
  Thread writer=new Thread(new Runnable(){
    @Override public void run(){
      try {
        Revision r=store.newRevision();
        Commit c=new Commit(store,r,head,null);
        c.addNode(new DocumentNodeState(store,"/newConflictingNode",new RevisionVector(r)));
        c.addNode(new DocumentNodeState(store,"/deletedNode",new RevisionVector(r)));
        c.updateProperty("/updateNode","foo","baz");
        c.apply();
      }
 catch (      DocumentStoreException e) {
        exceptions.add(e);
      }
    }
  }
);
  final Semaphore s=new Semaphore(0);
  locks.put(writer,s);
  writer.start();
  created.acquireUninterruptibly();
  Revision r=store.newRevision();
  Commit c=new Commit(store,r,head,null);
  c.addNode(new DocumentNodeState(store,"/newConflictingNode",new RevisionVector(r)));
  c.addNode(new DocumentNodeState(store,"/newNonConflictingNode",new RevisionVector(r)));
  c.apply();
  s.release();
  writer.join();
  assertEquals("expected exception",1,exceptions.size());
  String id=Utils.getIdFromPath("/newConflictingNode");
  NodeDocument doc=docStore.find(NODES,id);
  assertNotNull("document with id " + id + " does not exist",doc);
  assertTrue("document with id " + id + " should get _deletedOnce marked due to rollback",doc.wasDeletedOnce());
  id=Utils.getIdFromPath("/newNonConflictingNode");
  doc=docStore.find(NODES,id);
  assertNull("document with id " + id + " must not have _deletedOnce",doc.get(NodeDocument.DELETED_ONCE));
  id=Utils.getIdFromPath("/deletedNode");
  doc=docStore.find(NODES,id);
  assertTrue("document with id " + id + " should get _deletedOnce marked due to rollback",doc.wasDeletedOnce());
  id=Utils.getIdFromPath("/updateNode");
  doc=docStore.find(NODES,id);
  assertNull("document with id " + id + " must not have _deletedOnce despite rollback",doc.get(NodeDocument.DELETED_ONCE));
}

</code></pre>

<pre class="type-10 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test public void mergeChangeDeletedInternalDocShouldFail() throws Exception {
  final DocumentNodeStore store=builderProvider.newBuilder().getNodeStore();
  store.setEnableConcurrentAddRemove(true);
  NodeBuilder builder=store.getRoot().builder();
  builder.child(":a");
  builder.child(":b");
  merge(store,builder);
  SingleInstanceConflictUtility.generateConflict(store,new String[]{":1"},new String[]{":a"},false,new String[]{":2"},new String[]{":b"},false,new String[]{":3",":a",":b"},new String[]{},true,false,"Change deleted merge conflicts for internal docs should fail");
}

</code></pre>

<pre class="type-9 type-7 type-6 type-4 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void clusterWithClockDifferences2() throws Exception {
  MemoryDocumentStore store=new MemoryDocumentStore();
  long now=System.currentTimeMillis();
  Clock c1=new Clock.Virtual();
  c1.waitUntil(now);
  Revision.setClock(c1);
  DocumentNodeStore ns1=builderProvider.newBuilder().clock(c1).setDocumentStore(store).setAsyncDelay(0).setClusterId(1).getNodeStore();
  NodeBuilder b1=ns1.getRoot().builder();
  b1.child("node").setProperty("p",1);
  merge(ns1,b1);
  ns1.runBackgroundOperations();
  Revision.resetClockToDefault();
  Clock c2=new Clock.Virtual();
  c2.waitUntil(now + 5000);
  Revision.setClock(c2);
  DocumentNodeStore ns2=builderProvider.newBuilder().clock(c2).setDocumentStore(store).setAsyncDelay(0).setClusterId(2).getNodeStore();
  assertTrue(ns2.getRoot().hasChildNode("node"));
  assertEquals(1,ns2.getRoot().getChildNode("node").getProperty("p").getValue(Type.LONG).longValue());
  NodeBuilder b2=ns2.getRoot().builder();
  b2.child("node").setProperty("p",2);
  merge(ns2,b2);
  ns2.runBackgroundOperations();
  Revision.resetClockToDefault();
  Revision.setClock(c1);
  ns1.runBackgroundOperations();
  b1=ns1.getRoot().builder();
  assertEquals(2,b1.getChildNode("node").getProperty("p").getValue(Type.LONG).longValue());
  b1.child("node").setProperty("p",3);
  merge(ns1,b1);
  ns1.runBackgroundOperations();
  Revision.resetClockToDefault();
  Revision.setClock(c2);
  ns2.runBackgroundOperations();
  b2=ns2.getRoot().builder();
  assertEquals(3,b2.getChildNode("node").getProperty("p").getValue(Type.LONG).longValue());
}

</code></pre>

<pre class="type-7 type-6 type-8 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void mergedBranchVisibility() throws Exception {
  final DocumentNodeStore store=builderProvider.newBuilder().setAsyncDelay(0).getNodeStore();
  DocumentStore docStore=store.getDocumentStore();
  NodeBuilder builder1=store.getRoot().builder();
  builder1.child("test");
  merge(store,builder1);
  builder1=store.getRoot().builder();
  NodeBuilder node=builder1.getChildNode("test").child("node");
  String id=Utils.getIdFromPath("/test/node");
  int i=0;
  while (docStore.find(NODES,id) == null) {
    node.setProperty("foo",i++);
  }
  NodeDocument doc=docStore.find(NODES,id);
  assertNotNull(doc);
  RevisionVector rev=new RevisionVector(doc.getLocalDeleted().firstKey());
  merge(store,builder1);
  assertFalse(store.getRoot(rev).getChildNode("test").getChildNode("node").exists());
  assertTrue(store.getRoot().getChildNode("test").getChildNode("node").exists());
}

</code></pre>

<pre class="type-7 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies boolean conditions
"></span><br>
@Test public void compareOnBranch() throws Exception {
  long modifiedResMillis=SECONDS.toMillis(MODIFIED_IN_SECS_RESOLUTION);
  Clock clock=new Clock.Virtual();
  clock.waitUntil(System.currentTimeMillis());
  Revision.setClock(clock);
  DocumentNodeStore ns=builderProvider.newBuilder().clock(clock).setAsyncDelay(0).getNodeStore();
  NodeBuilder builder=ns.getRoot().builder();
  NodeBuilder p=builder.child("parent");
  for (int i=0; i < DocumentMK.MANY_CHILDREN_THRESHOLD * 2; i++) {
    p.child("node-" + i);
  }
  p.child("node-x").child("child");
  merge(ns,builder);
  ns.runBackgroundOperations();
  clock.waitUntil(clock.getTime() + modifiedResMillis * 2);
  builder=ns.getRoot().builder();
  builder.child("a");
  merge(ns,builder);
  DocumentNodeState root=ns.getRoot();
  final DocumentNodeStoreBranch b=ns.createBranch(root);
  builder=root.builder();
  builder.child("parent").child("node-x").child("child").child("x");
  b.setRoot(builder.getNodeState());
  builder.child("b");
  b.setRoot(builder.getNodeState());
  builder.child("c");
  b.setRoot(builder.getNodeState());
  DocumentNodeState head=asDocumentNodeState(b.getHead());
  TrackingDiff diff=new TrackingDiff();
  head.compareAgainstBaseState(root,diff);
  assertTrue(diff.modified.contains("/parent/node-x/child"));
}

</code></pre>

<pre class="type-9 type-7 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
"></span><br>
@Test public void branchBaseBeforeClusterJoin() throws Exception {
  MemoryDocumentStore store=new MemoryDocumentStore();
  DocumentNodeStore ns1=builderProvider.newBuilder().setClusterId(1).setDocumentStore(store).setAsyncDelay(0).getNodeStore();
  NodeBuilder b1=ns1.getRoot().builder();
  b1.child("parent");
  merge(ns1,b1);
  ns1.runBackgroundOperations();
  DocumentNodeStore ns2=builderProvider.newBuilder().setClusterId(2).setDocumentStore(store).setAsyncDelay(0).getNodeStore();
  NodeBuilder b2=ns2.getRoot().builder();
  b2.child("parent").child("baz");
  merge(ns2,b2);
  ns2.runBackgroundOperations();
  DocumentNodeState root=ns1.getRoot();
  DocumentNodeStoreBranch b=ns1.createBranch(root);
  NodeBuilder builder=root.builder();
  builder.child("parent").child("foo");
  b.setRoot(builder.getNodeState());
  builder.child("parent").child("bar");
  b.setRoot(builder.getNodeState());
  b.rebase();
  NodeState parent=b.getHead().getChildNode("parent");
  assertTrue(parent.exists());
  assertTrue(parent.hasChildNode("foo"));
  assertTrue(parent.hasChildNode("bar"));
  assertFalse(parent.hasChildNode("baz"));
  ns1.runBackgroundOperations();
  b.merge(EmptyHook.INSTANCE,CommitInfo.EMPTY);
  parent=ns1.getRoot().getChildNode("parent");
  assertTrue(parent.exists());
  assertTrue(parent.hasChildNode("foo"));
  assertTrue(parent.hasChildNode("bar"));
  assertTrue(parent.hasChildNode("baz"));
}

</code></pre>

<pre class="type-10 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test public void mergeDeleteDeleteEmptyInternalDoc() throws Exception {
  final DocumentNodeStore store=builderProvider.newBuilder().getNodeStore();
  store.setEnableConcurrentAddRemove(true);
  NodeBuilder builder=store.getRoot().builder();
  builder.child(":a");
  builder.child(":b");
  merge(store,builder);
  SingleInstanceConflictUtility.generateConflict(store,new String[]{":1"},new String[]{":a"},new String[]{":2"},new String[]{":b"},new String[]{":3"},new String[]{":a",":b"},true,"Delete-delete merge conflicts for internal docs should be resolved");
}

</code></pre>

<pre class="type-6 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
"></span><br>
@Test public void childNodeCache() throws Exception {
  DocumentNodeStore store=builderProvider.newBuilder().getNodeStore();
  NodeBuilder builder=store.getRoot().builder();
  int max=(int)(100 * 1.5);
  SortedSet<String> children=new TreeSet<String>();
  for (int i=0; i < max; i++) {
    String name="c" + i;
    children.add(name);
    builder.child(name);
  }
  store.merge(builder,EmptyHook.INSTANCE,CommitInfo.EMPTY);
  builder=store.getRoot().builder();
  String name=new ArrayList<String>(children).get(100 / 2);
  builder.child(name).remove();
  store.merge(builder,EmptyHook.INSTANCE,CommitInfo.EMPTY);
  int numEntries=Iterables.size(store.getRoot().getChildNodeEntries());
  assertEquals(max - 1,numEntries);
}

</code></pre>

<pre class="type-9 type-5 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void parentWithUnseenChildrenMustNotBeDeleted() throws Exception {
  final MemoryDocumentStore docStore=new MemoryDocumentStore();
  final DocumentNodeStore store1=builderProvider.newBuilder().setDocumentStore(docStore).setAsyncDelay(0).setClusterId(1).getNodeStore();
  store1.setEnableConcurrentAddRemove(true);
  final DocumentNodeStore store2=builderProvider.newBuilder().setDocumentStore(docStore).setAsyncDelay(0).setClusterId(2).getNodeStore();
  store2.setEnableConcurrentAddRemove(true);
  NodeBuilder builder=store1.getRoot().builder();
  builder.child(":hidden");
  merge(store1,builder);
  store1.runBackgroundOperations();
  store2.runBackgroundOperations();
  builder=store1.getRoot().builder();
  builder.child(":hidden").child("parent").child("node1");
  merge(store1,builder);
  builder=store2.getRoot().builder();
  builder.child(":hidden").child("parent").child("node2");
  merge(store2,builder);
  builder=store1.getRoot().builder();
  builder.child(":hidden").child("parent").remove();
  try {
    merge(store1,builder);
    fail("parent node of unseen children must not get deleted");
  }
 catch (  CommitFailedException cfe) {
  }
  String parentPath="/:hidden/parent";
  NodeDocument parentDoc=docStore.find(Collection.NODES,Utils.getIdFromPath(parentPath));
  assertFalse("parent node of unseen children must not get deleted",isDocDeleted(parentDoc));
  builder=store2.getRoot().builder();
  builder.child(":hidden").child("parent").remove();
  try {
    merge(store2,builder);
    fail("parent node of unseen children must not get deleted");
  }
 catch (  CommitFailedException cfe) {
  }
  parentDoc=docStore.find(Collection.NODES,Utils.getIdFromPath(parentPath));
  assertFalse("parent node of unseen children must not get deleted",isDocDeleted(parentDoc));
  store1.runBackgroundOperations();
  store2.runBackgroundOperations();
  builder=store1.getRoot().builder();
  builder.child(":hidden").child("parent").remove();
  builder.child(":hidden").child("parent1");
  store1.runBackgroundOperations();
  store2.runBackgroundOperations();
  builder=store1.getRoot().builder();
  builder.child(":hidden").child("parent1").child("node1");
  merge(store1,builder);
  builder=store2.getRoot().builder();
  builder.child(":hidden").child("parent1").child("node2");
  merge(store2,builder);
  builder=store1.getRoot().builder();
  builder.child(":hidden").child("parent1").remove();
  try {
    merge(store1,builder);
  }
 catch (  CommitFailedException cfe) {
  }
  parentPath="/:hidden/parent1";
  parentDoc=docStore.find(Collection.NODES,Utils.getIdFromPath(parentPath));
  assertFalse("parent node of unseen children must not get deleted",isDocDeleted(parentDoc));
  builder=store2.getRoot().builder();
  builder.child(":hidden").child("parent1").remove();
  try {
    merge(store2,builder);
  }
 catch (  CommitFailedException cfe) {
  }
  parentDoc=docStore.find(Collection.NODES,Utils.getIdFromPath(parentPath));
  assertFalse("parent node of unseen children must not get deleted",isDocDeleted(parentDoc));
}

</code></pre>

<pre class="type-10 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test public void mergeAddAddNormalDocShouldFail() throws Exception {
  final DocumentNodeStore store=builderProvider.newBuilder().getNodeStore();
  store.setEnableConcurrentAddRemove(true);
  SingleInstanceConflictUtility.generateConflict(store,new String[]{":1","a"},new String[]{},new String[]{":2","b"},new String[]{},new String[]{":3","a","b"},new String[]{},false,"Add-add merge conflicts for normal docs should fail");
}

</code></pre>

<pre class="type-9 type-7 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
"></span><br>
@Test public void backgroundRead() throws Exception {
  final Semaphore semaphore=new Semaphore(1);
  DocumentStore docStore=new MemoryDocumentStore();
  DocumentStore testStore=new TimingDocumentStoreWrapper(docStore){
    @Override public CacheInvalidationStats invalidateCache(    Iterable<String> keys){
      super.invalidateCache(keys);
      semaphore.acquireUninterruptibly();
      semaphore.release();
      return null;
    }
  }
;
  final DocumentNodeStore store1=builderProvider.newBuilder().setAsyncDelay(0).setDocumentStore(testStore).setClusterId(1).getNodeStore();
  DocumentNodeStore store2=builderProvider.newBuilder().setAsyncDelay(0).setDocumentStore(docStore).setClusterId(2).getNodeStore();
  NodeBuilder builder=store2.getRoot().builder();
  builder.child("node2");
  store2.merge(builder,EmptyHook.INSTANCE,CommitInfo.EMPTY);
  store2.runBackgroundOperations();
  assertFalse(store1.getRoot().hasChildNode("node2"));
  builder=store1.getRoot().builder();
  builder.child("node1");
  NodeState root=store1.merge(builder,EmptyHook.INSTANCE,CommitInfo.EMPTY);
  semaphore.acquireUninterruptibly();
  Thread t=new Thread(new Runnable(){
    @Override public void run(){
      store1.runBackgroundOperations();
    }
  }
);
  t.start();
  while (!semaphore.hasQueuedThreads()) {
    Thread.sleep(10);
  }
  try {
    assertFalse(root.hasChildNode("node2"));
  }
  finally {
    semaphore.release();
  }
  t.join();
  root=store1.getRoot();
  assertTrue(root.hasChildNode("node2"));
}

</code></pre>

<pre class="type-1 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Releases resources used by the test cases">TestCleaner</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Releases resources used by the test cases
"></span><br>
@After public void tearDown(){
  Revision.resetClockToDefault();
}

</code></pre>

<pre class="type-9 type-6 type-4 type-8 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void diffMany() throws Exception {
  Clock clock=new Clock.Virtual();
  clock.waitUntil(System.currentTimeMillis());
  Revision.setClock(clock);
  final List<Long> startValues=Lists.newArrayList();
  MemoryDocumentStore ds=new MemoryDocumentStore(){
    @Nonnull @Override public <T extends Document>List<T> query(    Collection<T> collection,    String fromKey,    String toKey,    String indexedProperty,    long startValue,    int limit){
      if (indexedProperty != null) {
        startValues.add(startValue);
      }
      return super.query(collection,fromKey,toKey,indexedProperty,startValue,limit);
    }
  }
;
  DocumentNodeStore ns=builderProvider.newBuilder().clock(clock).setDocumentStore(ds).setAsyncDelay(0).getNodeStore();
  NodeBuilder builder=ns.getRoot().builder();
  NodeBuilder test=builder.child("test");
  for (int i=0; i < DocumentMK.MANY_CHILDREN_THRESHOLD * 2; i++) {
    test.child("node-" + i);
  }
  merge(ns,builder);
  clock.waitUntil(clock.getTime() + TimeUnit.HOURS.toMillis(1));
  builder=ns.getRoot().builder();
  builder.child("foo");
  DocumentNodeState before=asDocumentNodeState(merge(ns,builder));
  NodeState beforeTest=before.getChildNode("test");
  builder=ns.getRoot().builder();
  builder.child("bar");
  merge(ns,builder);
  builder=ns.getRoot().builder();
  builder.child("test").child("bar");
  NodeState after=merge(ns,builder);
  NodeState afterTest=after.getChildNode("test");
  startValues.clear();
  afterTest.compareAgainstBaseState(beforeTest,new DefaultNodeStateDiff());
  assertEquals(1,startValues.size());
  Revision localHead=before.getRevision().getRevision(ns.getClusterId());
  assertNotNull(localHead);
  long beforeModified=getModifiedInSecs(localHead.getTimestamp());
  assertEquals(beforeModified,(long)startValues.get(0));
}

</code></pre>

<pre class="type-9 type-7 type-6 type-4 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void updateClusterState(){
  DocumentStore docStore=new MemoryDocumentStore();
  DocumentNodeStore ns1=builderProvider.newBuilder().setAsyncDelay(0).setClusterId(1).setDocumentStore(docStore).getNodeStore();
  int cId1=ns1.getClusterId();
  DocumentNodeStore ns2=builderProvider.newBuilder().setAsyncDelay(0).setClusterId(2).setDocumentStore(docStore).getNodeStore();
  int cId2=ns2.getClusterId();
  ns1.updateClusterState();
  ns2.updateClusterState();
  assertEquals(0,ns1.getMBean().getInactiveClusterNodes().length);
  assertEquals(0,ns2.getMBean().getInactiveClusterNodes().length);
  assertEquals(2,ns1.getMBean().getActiveClusterNodes().length);
  assertEquals(2,ns2.getMBean().getActiveClusterNodes().length);
  ns1.dispose();
  ns2.updateClusterState();
  String[] inactive=ns2.getMBean().getInactiveClusterNodes();
  String[] active=ns2.getMBean().getActiveClusterNodes();
  assertEquals(1,inactive.length);
  assertTrue(inactive[0].startsWith(cId1 + "="));
  assertEquals(1,active.length);
  assertTrue(active[0].startsWith(cId2 + "="));
}

</code></pre>

<pre class="type-9 type-6 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
"></span><br>
@Test public void concurrentChildOperations2() throws Exception {
  Clock clock=new Clock.Virtual();
  Revision.setClock(clock);
  MemoryDocumentStore store=new MemoryDocumentStore();
  DocumentNodeStore ns1=builderProvider.newBuilder().setClusterId(1).setAsyncDelay(0).clock(clock).setDocumentStore(store).getNodeStore();
  DocumentNodeStore ns2=builderProvider.newBuilder().setClusterId(2).setAsyncDelay(0).clock(clock).setDocumentStore(store).getNodeStore();
  NodeBuilder b1=ns1.getRoot().builder();
  b1.child("foo");
  merge(ns1,b1);
  ns1.runBackgroundOperations();
  ns2.runBackgroundOperations();
  b1=ns1.getRoot().builder();
  b1.child("foo").child("child-1");
  merge(ns1,b1);
  ns1.runBackgroundOperations();
  NodeBuilder b2=ns2.getRoot().builder();
  b2.child("foo").child("child-2");
  merge(ns2,b2);
  List<ChildNodeEntry> children=Lists.newArrayList(ns2.getRoot().getChildNode("foo").getChildNodeEntries());
  assertEquals(1,Iterables.size(children));
  ns2.runBackgroundOperations();
  children=Lists.newArrayList(ns2.getRoot().getChildNode("foo").getChildNodeEntries());
  assertEquals(2,Iterables.size(children));
}

</code></pre>

<pre class="type-9 type-7 type-6 type-4 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void useDocChildCacheForFindingNodes() throws CommitFailedException {
  final Set<String> reads=Sets.newHashSet();
  MemoryDocumentStore docStore=new MemoryDocumentStore(){
    @Override public <T extends Document>T find(    Collection<T> collection,    String key){
      reads.add(key);
      return super.find(collection,key);
    }
  }
;
  DocumentNodeStore store=builderProvider.newBuilder().setClusterId(1).setAsyncDelay(0).setDocumentStore(docStore).getNodeStore();
  NodeBuilder builder=store.getRoot().builder();
  builder.child("a");
  builder.child("b").child("c");
  merge(store,builder);
  NodeState parentState=store.getRoot().getChildNode("b");
  reads.clear();
  NodeState nonExistingChild=parentState.getChildNode("non-existing-node-1");
  assertEquals("Should not go to DocStore::find for a known non-existent child",0,reads.size());
  assertFalse("Non existing children should be reported as such",nonExistingChild.exists());
  builder=store.getRoot().builder();
  NodeBuilder childPropBuilder=builder.child("a");
  childPropBuilder.setProperty("foo","bar");
  merge(store,builder);
  parentState=store.getRoot().getChildNode("b");
  reads.clear();
  nonExistingChild=parentState.getChildNode("non-existing-node-2");
  assertEquals("Should not go to DocStore::find for a known non-existent child," + " even if another merge has happened (on another sub-tree)",0,reads.size());
  assertFalse("Non existing children should be reported as such",nonExistingChild.exists());
  store.invalidateNodeChildrenCache();
  parentState=store.getRoot().getChildNode("b");
  Iterables.size(parentState.getChildNodeEntries());
  reads.clear();
  nonExistingChild=parentState.getChildNode("non-existing-node-3");
  assertEquals("Should not go to DocStore::find when doc child cache is filled by reading",0,reads.size());
  assertFalse("Non existing children should be reported as such",nonExistingChild.exists());
}

</code></pre>

<pre class="type-7 type-4 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void diffExternalChanges() throws Exception {
  long modifiedResMillis=SECONDS.toMillis(MODIFIED_IN_SECS_RESOLUTION);
  Clock clock=new Clock.Virtual();
  clock.waitUntil(System.currentTimeMillis());
  Revision.setClock(clock);
  DocumentStore docStore=new MemoryDocumentStore();
  DocumentNodeStore ns1=builderProvider.newBuilder().setAsyncDelay(0).clock(clock).setDocumentStore(docStore).setClusterId(1).getNodeStore();
  DocumentNodeStore ns2=builderProvider.newBuilder().setAsyncDelay(0).clock(clock).setDocumentStore(docStore).setClusterId(2).getNodeStore();
  NodeBuilder builder=ns1.getRoot().builder();
  NodeBuilder test=builder.child("test");
  for (int i=0; i < DocumentMK.MANY_CHILDREN_THRESHOLD * 2; i++) {
    test.child("node-" + i);
  }
  ns1.merge(builder,EmptyHook.INSTANCE,CommitInfo.EMPTY);
  ns1.runBackgroundOperations();
  ns2.runBackgroundOperations();
  clock.waitUntil(clock.getTime() + modifiedResMillis * 2);
  builder=ns2.getRoot().builder();
  builder.child("test").child("foo");
  ns2.merge(builder,EmptyHook.INSTANCE,CommitInfo.EMPTY);
  clock.waitUntil(clock.getTime() + modifiedResMillis * 2);
  builder=ns1.getRoot().builder();
  builder.child("test").child("bar");
  ns1.merge(builder,EmptyHook.INSTANCE,CommitInfo.EMPTY);
  NodeState r1=ns1.getRoot();
  ns2.runBackgroundOperations();
  ns1.runBackgroundOperations();
  NodeState r2=ns1.getRoot();
  boolean found=false;
  for (  ChildNodeEntry entry : r2.getChildNode("test").getChildNodeEntries()) {
    if (entry.getName().equals("foo")) {
      found=true;
      break;
    }
  }
  assertTrue(found);
  TrackingDiff diff=new TrackingDiff();
  r2.compareAgainstBaseState(r1,diff);
  assertEquals(1,diff.modified.size());
  assertTrue(diff.modified.contains("/test"));
  assertEquals(1,diff.added.size());
  assertTrue(diff.added.contains("/test/foo"));
}

</code></pre>

<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies whether objects/variable are equal to an expected value 
"></span><br>
@Test public void diffCache() throws Exception {
  final AtomicInteger numQueries=new AtomicInteger();
  MemoryDocumentStore store=new MemoryDocumentStore(){
    @Nonnull @Override public <T extends Document>List<T> query(    Collection<T> collection,    String fromKey,    String toKey,    int limit){
      numQueries.incrementAndGet();
      return super.query(collection,fromKey,toKey,limit);
    }
  }
;
  DocumentNodeStore ns=builderProvider.newBuilder().setDocumentStore(store).setAsyncDelay(0).getNodeStore();
  NodeBuilder builder=ns.getRoot().builder();
  builder.child("foo").child("child");
  merge(ns,builder);
  builder=ns.getRoot().builder();
  builder.child("bar");
  merge(ns,builder);
  DocumentNodeState before=ns.getRoot();
  builder=ns.getRoot().builder();
  builder.child("foo").child("child").child("node");
  merge(ns,builder);
  DocumentNodeState after=ns.getRoot();
  numQueries.set(0);
  final List<String> added=Lists.newArrayList();
  ns.compare(asDocumentNodeState(after.getChildNode("foo").getChildNode("child")),asDocumentNodeState(before.getChildNode("foo").getChildNode("child")),new DefaultNodeStateDiff(){
    @Override public boolean childNodeAdded(    String name,    NodeState after){
      added.add(name);
      return super.childNodeAdded(name,after);
    }
  }
);
  assertEquals(1,added.size());
  assertEquals("node",added.get(0));
  assertEquals("must not run queries",0,numQueries.get());
}

</code></pre>

<pre class="type-9 type-7 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
"></span><br>
@Test public void clusterWithClockDifferences() throws Exception {
  MemoryDocumentStore store=new MemoryDocumentStore();
  long now=System.currentTimeMillis();
  Clock c1=new Clock.Virtual();
  c1.waitUntil(now);
  Revision.setClock(c1);
  DocumentNodeStore ns1=builderProvider.newBuilder().clock(c1).setDocumentStore(store).setAsyncDelay(0).setClusterId(1).getNodeStore();
  NodeBuilder b1=ns1.getRoot().builder();
  b1.child("node");
  merge(ns1,b1);
  ns1.runBackgroundOperations();
  Revision.resetClockToDefault();
  Clock c2=new Clock.Virtual();
  c2.waitUntil(now + 5000);
  Revision.setClock(c2);
  DocumentNodeStore ns2=builderProvider.newBuilder().clock(c2).setDocumentStore(store).setAsyncDelay(0).setClusterId(2).getNodeStore();
  assertTrue(ns2.getRoot().hasChildNode("node"));
  NodeBuilder b2=ns2.getRoot().builder();
  b2.child("node").remove();
  merge(ns2,b2);
  ns2.runBackgroundOperations();
  Revision.resetClockToDefault();
  Revision.setClock(c1);
  ns1.runBackgroundOperations();
  b1=ns1.getRoot().builder();
  assertFalse(b1.hasChildNode("node"));
  b1.child("node");
  merge(ns1,b1);
  ns1.runBackgroundOperations();
  Revision.resetClockToDefault();
  Revision.setClock(c2);
  ns2.runBackgroundOperations();
  b2=ns2.getRoot().builder();
  assertTrue(b2.hasChildNode("node"));
}

</code></pre>

<pre class="type-9 type-6 type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
"></span><br>
@Test public void readNullEntry() throws CommitFailedException {
  final Set<String> reads=Sets.newHashSet();
  MemoryDocumentStore docStore=new MemoryDocumentStore(){
    @Override public <T extends Document>T find(    Collection<T> collection,    String key){
      reads.add(key);
      return super.find(collection,key);
    }
  }
;
  DocumentNodeStore store=builderProvider.newBuilder().setClusterId(1).setAsyncDelay(0).setDocumentStore(docStore).getNodeStore();
  NodeBuilder builder=store.getRoot().builder();
  builder.child("test").setProperty("foo","bar");
  merge(store,builder);
  builder=store.getRoot().builder();
  builder.child("test").remove();
  merge(store,builder);
  RevisionVector removedAt=store.getHeadRevision();
  String id=Utils.getIdFromPath("/test");
  int count=0;
  while (docStore.find(NODES,id).getPreviousRanges().size() <= PREV_SPLIT_FACTOR) {
    builder=store.getRoot().builder();
    builder.child("test").setProperty("count",count++);
    merge(store,builder);
    store.runBackgroundOperations();
  }
  NodeDocument doc=docStore.find(NODES,id);
  assertNotNull(doc);
  reads.clear();
  doc.getNodeAtRevision(store,store.getHeadRevision(),null);
  assertNoPreviousDocs(reads);
  reads.clear();
  doc.getValueMap("foo").get(removedAt.getRevision(store.getClusterId()));
  assertNoPreviousDocs(reads);
}

</code></pre>

<pre class="type-10 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test public void mergeAddAddNonEmptyInternalDocShouldFail() throws Exception {
  final DocumentNodeStore store=builderProvider.newBuilder().getNodeStore();
  store.setEnableConcurrentAddRemove(true);
  SingleInstanceConflictUtility.generateConflict(store,new String[]{":1",":a"},new String[]{},true,new String[]{":2",":b"},new String[]{},true,new String[]{":3",":a",":b"},new String[]{},false,false,"Add-add merge conflicts for non empty internal docs should fail");
}

</code></pre>

<pre class="type-9 type-7 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
"></span><br>
@Test public void ignoreDocChildCacheForIncompleteEntry() throws CommitFailedException {
  final Set<String> reads=Sets.newHashSet();
  MemoryDocumentStore docStore=new MemoryDocumentStore(){
    @Override public <T extends Document>T find(    Collection<T> collection,    String key){
      reads.add(key);
      return super.find(collection,key);
    }
  }
;
  DocumentNodeStore store=builderProvider.newBuilder().setUseSimpleRevision(true).setClusterId(1).setAsyncDelay(0).setDocumentStore(docStore).getNodeStore();
  NodeBuilder builder=store.getRoot().builder();
  NodeBuilder parentBuilder=builder.child("a");
  int numChildren=DocumentNodeState.INITIAL_FETCH_SIZE + 2;
  for (int i=0; i < numChildren; i++) {
    parentBuilder.child("child" + i);
  }
  merge(store,builder);
  store.invalidateNodeChildrenCache();
  NodeState parentNodeState=store.getRoot().getChildNode("a");
  Iterables.size(parentNodeState.getChildNodeEntries());
  reads.clear();
  NodeState nonExistingChild=parentNodeState.getChildNode("non-existing-child-1");
  assertTrue("DocStore should be queried when no doc child cache entry has all children",reads.size() > 0);
  assertFalse("Non existing children should be reported as such",nonExistingChild.exists());
}

</code></pre>

<pre class="type-9 type-12 type-5 type-6 type-8 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void readBranchCommit() throws Exception {
  final Set<String> readSet=Sets.newHashSet();
  DocumentStore store=new MemoryDocumentStore(){
    @Override public <T extends Document>T find(    Collection<T> collection,    String key){
      readSet.add(key);
      return super.find(collection,key);
    }
  }
;
  DocumentNodeStore ns=builderProvider.newBuilder().setDocumentStore(store).setAsyncDelay(0).getNodeStore();
  NodeBuilder builder=ns.getRoot().builder();
  String testId=Utils.getIdFromPath("/test");
  NodeBuilder test=builder.child("test");
  test.setProperty("p","value");
  int q=0;
  while (store.find(NODES,testId) == null) {
    test.setProperty("q",q++);
  }
  merge(ns,builder);
  for (int i=0; i < NUM_REVS_THRESHOLD; i++) {
    builder=ns.getRoot().builder();
    builder.child("test").setProperty("q",i);
    merge(ns,builder);
  }
  ns.runBackgroundOperations();
  NodeDocument doc=store.find(NODES,Utils.getIdFromPath("/test"));
  assertNotNull(doc);
  readSet.clear();
  doc.getNodeAtRevision(ns,ns.getHeadRevision(),null);
  for (  String id : Sets.newHashSet(readSet)) {
    doc=store.find(NODES,id);
    assertNotNull(doc);
    if (doc.isSplitDocument() && !doc.getMainPath().equals("/")) {
      fail("must not access previous document: " + id);
    }
  }
}

</code></pre>

<pre class="type-9 type-5 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void nonBlockingReset() throws Exception {
  final List<String> failure=Lists.newArrayList();
  final AtomicReference<ReentrantReadWriteLock> mergeLock=new AtomicReference<ReentrantReadWriteLock>();
  MemoryDocumentStore store=new MemoryDocumentStore(){
    @Override public <T extends Document>T findAndUpdate(    Collection<T> collection,    UpdateOp update){
      for (      Map.Entry<Key,Operation> entry : update.getChanges().entrySet()) {
        if (entry.getKey().getName().equals(NodeDocument.COLLISIONS)) {
          ReentrantReadWriteLock rwLock=mergeLock.get();
          if (rwLock.getReadHoldCount() > 0 || rwLock.getWriteHoldCount() > 0) {
            failure.add("Branch reset still holds merge lock");
            break;
          }
        }
      }
      return super.findAndUpdate(collection,update);
    }
  }
;
  DocumentNodeStore ds=builderProvider.newBuilder().setDocumentStore(store).setAsyncDelay(0).getNodeStore();
  ds.setMaxBackOffMillis(0);
  DocumentNodeState root=ds.getRoot();
  final DocumentNodeStoreBranch b=ds.createBranch(root);
  assertTrue(b.getMergeLock() instanceof ReentrantReadWriteLock);
  mergeLock.set((ReentrantReadWriteLock)b.getMergeLock());
  NodeBuilder builder=root.builder();
  builder.child("foo");
  b.setRoot(builder.getNodeState());
  builder.child("bar");
  b.setRoot(builder.getNodeState());
  try {
    b.merge(new CommitHook(){
      @Nonnull @Override public NodeState processCommit(      NodeState before,      NodeState after,      CommitInfo info) throws CommitFailedException {
        NodeBuilder foo=after.builder().child("foo");
        for (int i=0; i <= DocumentRootBuilder.UPDATE_LIMIT; i++) {
          foo.setProperty("prop",i);
        }
        throw new CommitFailedException("Fail",0,"");
      }
    }
,CommitInfo.EMPTY);
  }
 catch (  CommitFailedException e) {
  }
  for (  String s : failure) {
    fail(s);
  }
}

</code></pre>

<pre class="type-13 type-7 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies boolean conditions
"></span><br>
@Test public void resolveMultipleConflictedRevisions() throws Exception {
  MemoryDocumentStore store=new MemoryDocumentStore();
  final DocumentNodeStore ds=builderProvider.newBuilder().setDocumentStore(store).setAsyncDelay(0).getNodeStore();
  DocumentNodeState root=ds.getRoot();
  final DocumentNodeStoreBranch b=ds.createBranch(root);
  NodeBuilder builder=root.builder();
  builder.child("foo");
  b.setRoot(builder.getNodeState());
  final Set<Revision> revisions=new HashSet<Revision>();
  final List<Commit> commits=new ArrayList<Commit>();
  for (int i=0; i < 10; i++) {
    Revision revision=ds.newRevision();
    Commit commit=ds.newCommit(new RevisionVector(revision),ds.createBranch(root));
    commits.add(commit);
    revisions.add(revision);
  }
  final AtomicBoolean merged=new AtomicBoolean();
  Thread t=new Thread(new Runnable(){
    public void run(){
      try {
        CommitFailedException exception=new ConflictException("Can't merge",revisions).asCommitFailedException();
        b.merge(new HookFailingOnce(exception),CommitInfo.EMPTY);
        merged.set(true);
      }
 catch (      CommitFailedException e) {
        LOG.error("Can't commit",e);
      }
    }
  }
);
  t.start();
  for (int i=0; i < 6; i++) {
    assertFalse("The branch can't be merged yet",merged.get());
    ds.done(commits.get(i),false,CommitInfo.EMPTY);
  }
  for (int i=6; i < 8; i++) {
    assertFalse("The branch can't be merged yet",merged.get());
    ds.canceled(commits.get(i));
  }
  for (int i=8; i < 10; i++) {
    assertFalse("The branch can't be merged yet",merged.get());
    ds.done(commits.get(i),true,CommitInfo.EMPTY);
  }
  for (int i=0; i < 100; i++) {
    if (merged.get()) {
      break;
    }
    Thread.sleep(10);
  }
  assertTrue("The branch should be merged by now",merged.get());
  t.join();
}

</code></pre>

<pre class="type-10 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test public void getNewestRevision() throws Exception {
  DocumentStore docStore=new MemoryDocumentStore();
  DocumentNodeStore ns1=builderProvider.newBuilder().setDocumentStore(docStore).setAsyncDelay(0).setClusterId(1).getNodeStore();
  ns1.getRoot();
  ns1.runBackgroundOperations();
  DocumentNodeStore ns2=builderProvider.newBuilder().setDocumentStore(docStore).setAsyncDelay(0).setClusterId(2).getNodeStore();
  ns2.getRoot();
  NodeBuilder b1=ns1.getRoot().builder();
  for (int i=0; i < NodeDocument.NUM_REVS_THRESHOLD; i++) {
    b1.setProperty("p",String.valueOf(i));
    ns1.merge(b1,EmptyHook.INSTANCE,CommitInfo.EMPTY);
  }
  ns1.runBackgroundOperations();
  NodeBuilder b2=ns2.getRoot().builder();
  b2.setProperty("q","value");
  ns2.merge(b2,EmptyHook.INSTANCE,CommitInfo.EMPTY);
}

</code></pre>

<pre class="type-7 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies boolean conditions
"></span><br>
@Test public void mergeInternalDocAcrossCluster() throws Exception {
  MemoryDocumentStore docStore=new MemoryDocumentStore();
  final DocumentNodeStore store1=builderProvider.newBuilder().setDocumentStore(docStore).setAsyncDelay(0).setClusterId(1).getNodeStore();
  store1.setEnableConcurrentAddRemove(true);
  final DocumentNodeStore store2=builderProvider.newBuilder().setDocumentStore(docStore).setAsyncDelay(0).setClusterId(2).getNodeStore();
  store2.setEnableConcurrentAddRemove(true);
  NodeState root;
  NodeBuilder builder;
  root=store1.getRoot();
  builder=root.builder();
  builder.child(":hidden").child("deleteDeleted");
  builder.child(":hidden").child("deleteChanged");
  builder.child(":hidden").child("changeDeleted");
  merge(store1,builder);
  store1.runBackgroundOperations();
  store2.runBackgroundOperations();
  root=store1.getRoot();
  builder=root.builder();
  builder.child("visible");
  builder.child(":hidden").child("b");
  builder.child(":hidden").child("deleteDeleted").remove();
  builder.child(":hidden").child("changeDeleted").remove();
  builder.child(":hidden").child("deleteChanged").setProperty("foo","bar");
  builder.child(":dynHidden").child("c");
  builder.child(":dynHidden").child("childWithProp").setProperty("foo","bar");
  merge(store1,builder);
  root=store2.getRoot();
  builder=root.builder();
  builder.child(":hidden").child("b");
  builder.child(":dynHidden").child("c");
  merge(store2,builder);
  builder=root.builder();
  builder.child(":hidden").child("deleteDeleted").remove();
  merge(store2,builder);
  store2.setMaxBackOffMillis(0);
  boolean commitFailed=false;
  try {
    builder=root.builder();
    builder.child("visible");
    merge(store2,builder);
  }
 catch (  CommitFailedException cfe) {
    commitFailed=true;
  }
  assertTrue("Concurrent creation of visible node across cluster must fail",commitFailed);
  commitFailed=false;
  try {
    builder=root.builder();
    builder.child(":dynHidden").child("childWithProp").setProperty("foo","bar");
    merge(store2,builder);
  }
 catch (  CommitFailedException cfe) {
    commitFailed=true;
  }
  assertTrue("Concurrent creation of hidden node with properties across cluster must fail",commitFailed);
  commitFailed=false;
  try {
    builder=root.builder();
    builder.child(":hidden").child("deleteChanged").remove();
    merge(store2,builder);
  }
 catch (  CommitFailedException cfe) {
    commitFailed=true;
  }
  assertTrue("Delete changed merge across cluster must fail even under hidden tree",commitFailed);
  commitFailed=false;
  try {
    builder=root.builder();
    builder.child(":hidden").child("changeDeleted").setProperty("foo","bar");
    merge(store2,builder);
  }
 catch (  CommitFailedException cfe) {
    commitFailed=true;
  }
  assertTrue("Change deleted merge across cluster must fail even under hidden tree",commitFailed);
}

</code></pre>

<pre class="type-9 type-7 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
"></span><br>
@Test public void recoverBranchCommit() throws Exception {
  Clock clock=new Clock.Virtual();
  clock.waitUntil(System.currentTimeMillis());
  MemoryDocumentStore docStore=new MemoryDocumentStore();
  DocumentNodeStore store1=builderProvider.newBuilder().setDocumentStore(docStore).setAsyncDelay(0).clock(clock).setClusterId(1).getNodeStore();
  NodeBuilder builder=store1.getRoot().builder();
  builder.child("test");
  merge(store1,builder);
  store1.runBackgroundOperations();
  builder=store1.getRoot().builder();
  NodeBuilder node=builder.getChildNode("test").child("node");
  String id=Utils.getIdFromPath("/test/node");
  int i=0;
  while (docStore.find(NODES,id) == null) {
    node.setProperty("foo",i++);
  }
  merge(store1,builder);
  clock.waitUntil(clock.getTime() + store1.getClusterInfo().getLeaseTime() + 1000);
  LastRevRecoveryAgent agent=store1.getLastRevRecoveryAgent();
  assertTrue(agent.isRecoveryNeeded());
  agent.recover(store1.getClusterId());
  DocumentNodeStore store2=builderProvider.newBuilder().setDocumentStore(docStore).setAsyncDelay(0).clock(clock).setClusterId(2).getNodeStore();
  assertTrue(store2.getRoot().getChildNode("test").getChildNode("node").exists());
}

</code></pre>

<pre class="type-9 type-7 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
"></span><br>
@Test public void sameSeenAtRevision2() throws Exception {
  MemoryDocumentStore store=new MemoryDocumentStore();
  DocumentNodeStore ns1=builderProvider.newBuilder().setDocumentStore(store).setAsyncDelay(0).setClusterId(1).getNodeStore();
  DocumentNodeStore ns2=builderProvider.newBuilder().setDocumentStore(store).setAsyncDelay(0).setClusterId(2).getNodeStore();
  NodeBuilder b2=ns2.getRoot().builder();
  b2.child("test");
  merge(ns2,b2);
  b2=ns2.getRoot().builder();
  b2.child("test").remove();
  merge(ns2,b2);
  ns2.runBackgroundOperations();
  ns1.runBackgroundOperations();
  NodeBuilder b1=ns1.getRoot().builder();
  assertFalse(b1.hasChildNode("test"));
  b1.child("test");
  merge(ns1,b1);
  ns1.runBackgroundOperations();
  DocumentNodeStore ns3=builderProvider.newBuilder().setDocumentStore(store).setAsyncDelay(0).setClusterId(3).getNodeStore();
  ns3.setMaxBackOffMillis(0);
  NodeBuilder b3=ns3.getRoot().builder();
  assertTrue(b3.hasChildNode("test"));
  b3.child("test").remove();
  merge(ns3,b3);
}

</code></pre>

<pre class="type-5 type-7 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void failFastOnBranchConflict() throws Exception {
  final AtomicInteger mergeAttempts=new AtomicInteger();
  MemoryDocumentStore store=new MemoryDocumentStore(){
    @Override public <T extends Document>T findAndUpdate(    Collection<T> collection,    UpdateOp update){
      for (      Key k : update.getConditions().keySet()) {
        if (k.getName().equals(NodeDocument.COLLISIONS)) {
          mergeAttempts.incrementAndGet();
          break;
        }
      }
      return super.findAndUpdate(collection,update);
    }
  }
;
  DocumentNodeStore ds=builderProvider.newBuilder().setDocumentStore(store).setAsyncDelay(0).getNodeStore();
  DocumentNodeState root=ds.getRoot();
  DocumentNodeStoreBranch b=ds.createBranch(root);
  NodeBuilder builder=root.builder();
  builder.child("foo");
  b.setRoot(builder.getNodeState());
  builder.child("bar").setProperty("p","foo");
  b.setRoot(builder.getNodeState());
  NodeBuilder nb=ds.getRoot().builder();
  nb.child("bar").setProperty("p","bar");
  merge(ds,nb);
  mergeAttempts.set(0);
  try {
    b.merge(EmptyHook.INSTANCE,CommitInfo.EMPTY);
    fail("must fail with CommitFailedException");
  }
 catch (  CommitFailedException e) {
  }
  assertTrue("too many merge attempts: " + mergeAttempts.get(),mergeAttempts.get() <= 1);
}

</code></pre>

<pre class="type-9 type-7 type-6 type-8 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void diffOnce() throws Exception {
  final AtomicInteger numQueries=new AtomicInteger();
  MemoryDocumentStore store=new MemoryDocumentStore(){
    @Nonnull @Override public <T extends Document>List<T> query(    Collection<T> collection,    String fromKey,    String toKey,    String indexedProperty,    long startValue,    int limit){
      numQueries.getAndIncrement();
      return super.query(collection,fromKey,toKey,indexedProperty,startValue,limit);
    }
  }
;
  final DocumentMK mk=builderProvider.newBuilder().setDocumentStore(store).open();
  final DocumentNodeStore ns=mk.getNodeStore();
  NodeBuilder builder=ns.getRoot().builder();
  for (int i=0; i < DocumentMK.MANY_CHILDREN_THRESHOLD * 2; i++) {
    builder.child("node-" + i);
  }
  merge(ns,builder);
  final RevisionVector head=ns.getHeadRevision();
  Revision localHead=head.getRevision(ns.getClusterId());
  assertNotNull(localHead);
  final RevisionVector to=new RevisionVector(new Revision(localHead.getTimestamp() + 1000,0,localHead.getClusterId()));
  int numReaders=10;
  final CountDownLatch ready=new CountDownLatch(numReaders);
  final CountDownLatch go=new CountDownLatch(1);
  List<Thread> readers=Lists.newArrayList();
  for (int i=0; i < numReaders; i++) {
    Thread t=new Thread(new Runnable(){
      @Override public void run(){
        try {
          ready.countDown();
          go.await();
          mk.diff(head.toString(),to.toString(),"/",0);
        }
 catch (        InterruptedException e) {
        }
      }
    }
);
    readers.add(t);
    t.start();
  }
  ready.await();
  numQueries.set(0);
  go.countDown();
  for (  Thread t : readers) {
    t.join();
  }
  assertTrue(numQueries.get() <= 2);
}

</code></pre>

<pre class="type-9 type-5 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void conflictDetectionWithClockDifference() throws Exception {
  MemoryDocumentStore store=new MemoryDocumentStore();
  long now=System.currentTimeMillis();
  Clock c1=new Clock.Virtual();
  c1.waitUntil(now);
  Revision.setClock(c1);
  DocumentNodeStore ns1=builderProvider.newBuilder().clock(c1).setDocumentStore(store).setAsyncDelay(0).setClusterId(1).getNodeStore();
  NodeBuilder b1=ns1.getRoot().builder();
  b1.child("node");
  merge(ns1,b1);
  ns1.runBackgroundOperations();
  Revision.resetClockToDefault();
  Clock c2=new Clock.Virtual();
  c2.waitUntil(now + 5000);
  Revision.setClock(c2);
  DocumentNodeStore ns2=builderProvider.newBuilder().clock(c2).setDocumentStore(store).setAsyncDelay(0).setClusterId(2).getNodeStore();
  assertTrue(ns2.getRoot().hasChildNode("node"));
  NodeBuilder b2=ns2.getRoot().builder();
  b2.child("node").child("foo");
  merge(ns2,b2);
  ns2.runBackgroundOperations();
  Revision.resetClockToDefault();
  Revision.setClock(c1);
  ns1.runBackgroundOperations();
  b1=ns1.getRoot().builder();
  assertTrue(b1.getChildNode("node").hasChildNode("foo"));
  b1.child("node").remove();
  merge(ns1,b1);
  Revision.resetClockToDefault();
  Revision.setClock(c2);
  b2=ns2.getRoot().builder();
  b2.child("node").child("bar");
  try {
    merge(ns2,b2);
    fail("must fail with CommitFailedException");
  }
 catch (  CommitFailedException e) {
  }
}

</code></pre>

<pre class="type-7 type-6 type-8 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void modifiedReset() throws Exception {
  Clock clock=new Clock.Virtual();
  clock.waitUntil(System.currentTimeMillis());
  Revision.setClock(clock);
  MemoryDocumentStore docStore=new MemoryDocumentStore();
  DocumentNodeStore ns1=builderProvider.newBuilder().setDocumentStore(docStore).setClusterId(1).setAsyncDelay(0).clock(clock).getNodeStore();
  NodeBuilder builder1=ns1.getRoot().builder();
  builder1.child("node");
  ns1.merge(builder1,EmptyHook.INSTANCE,CommitInfo.EMPTY);
  ns1.runBackgroundOperations();
  DocumentNodeStore ns2=builderProvider.newBuilder().setDocumentStore(docStore).setClusterId(2).setAsyncDelay(0).clock(clock).getNodeStore();
  NodeBuilder builder2=ns2.getRoot().builder();
  builder2.child("node").child("child-2");
  ns2.merge(builder2,EmptyHook.INSTANCE,CommitInfo.EMPTY);
  clock.waitUntil(System.currentTimeMillis() + SECONDS.toMillis(MODIFIED_IN_SECS_RESOLUTION + 1));
  builder1=ns1.getRoot().builder();
  builder1.child("node").child("child-1");
  ns1.merge(builder1,EmptyHook.INSTANCE,CommitInfo.EMPTY);
  ns1.runBackgroundOperations();
  NodeDocument doc=docStore.find(NODES,Utils.getIdFromPath("/node"));
  Long mod1=(Long)doc.get(MODIFIED_IN_SECS);
  assertNotNull(mod1);
  ns2.runBackgroundOperations();
  doc=docStore.find(NODES,Utils.getIdFromPath("/node"));
  Long mod2=(Long)doc.get(MODIFIED_IN_SECS);
  assertTrue("" + mod2 + " < "+ mod1,mod2 >= mod1);
}

</code></pre>

<pre class="type-10 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test public void slowRebase() throws Exception {
  final int NUM_NODES=DocumentRootBuilder.UPDATE_LIMIT / 2;
  final int NUM_PROPS=10;
  final int REBASE_COUNT=5;
  final DocumentNodeStore ns=builderProvider.newBuilder().getNodeStore();
  NodeBuilder builder=ns.getRoot().builder();
  for (int i=0; i < NUM_NODES / 2; i++) {
    NodeBuilder c=deepTree(builder.child("n" + i),5);
    for (int j=0; j < NUM_PROPS; j++) {
      c.setProperty("p" + j,"value");
    }
  }
  merge(ns,builder);
  builder=ns.getRoot().builder();
  int[] rebaseCounts={2,3,1,8,3};
  for (int r=0; r < REBASE_COUNT; r++) {
    for (int i=0; i < NUM_NODES / 2; i++) {
      NodeBuilder c=deepTree(builder.child("n" + i),5);
      for (int j=0; j < NUM_PROPS; j++) {
        c.setProperty("q" + r + ""+ j,"value");
      }
    }
    for (int k=0; k < rebaseCounts[r]; k++) {
      doSomeChange(ns);
      ns.rebase(builder);
    }
  }
  LOG.info("Starting the final merge {}",new Date());
  merge(ns,builder);
}

</code></pre>

<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies whether objects/variable are equal to an expected value 
"></span><br>
@Test public void childNodeEntries() throws Exception {
  final AtomicInteger counter=new AtomicInteger();
  DocumentStore docStore=new MemoryDocumentStore(){
    @Nonnull @Override public <T extends Document>List<T> query(    Collection<T> collection,    String fromKey,    String toKey,    int limit){
      counter.incrementAndGet();
      return super.query(collection,fromKey,toKey,limit);
    }
  }
;
  DocumentNodeStore store=builderProvider.newBuilder().setDocumentStore(docStore).getNodeStore();
  NodeBuilder root=store.getRoot().builder();
  for (int i=0; i < 10; i++) {
    root.child("node-" + i);
  }
  store.merge(root,EmptyHook.INSTANCE,CommitInfo.EMPTY);
  counter.set(0);
  for (  ChildNodeEntry e : store.getRoot().getChildNodeEntries()) {
    e.getNodeState();
  }
  assertEquals(1,counter.get());
  counter.set(0);
  for (  ChildNodeEntry e : store.getRoot().getChildNodeEntries()) {
    e.getNodeState();
  }
  assertEquals(0,counter.get());
}

</code></pre>

<pre class="type-10 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test public void mergeAddAddEmptyInternalDoc() throws Exception {
  final DocumentNodeStore store=builderProvider.newBuilder().getNodeStore();
  store.setEnableConcurrentAddRemove(true);
  SingleInstanceConflictUtility.generateConflict(store,new String[]{":1",":a"},new String[]{},new String[]{":2",":b"},new String[]{},new String[]{":3",":a",":b"},new String[]{},true,"Add-add merge conflicts for internal docs should be resolvable");
}

</code></pre>

<pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies whether objects are null
"></span><br>
@Test public void dispatch() throws Exception {
  DocumentNodeStore ns=builderProvider.newBuilder().getNodeStore();
  RevisionVector from=ns.getHeadRevision();
  NodeBuilder builder=ns.getRoot().builder();
  builder.child("test");
  merge(ns,builder);
  RevisionVector to=ns.getHeadRevision();
  DiffCache.Entry entry=ns.getDiffCache().newEntry(from,to,true);
  entry.append("/","-\"foo\"");
  entry.done();
  ns.compare(ns.getRoot(),ns.getRoot(from),new DefaultNodeStateDiff(){
    @Override public boolean childNodeDeleted(    String name,    NodeState before){
      assertNotNull(before);
      return true;
    }
  }
);
}

</code></pre>

<pre class="type-9 type-7 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
"></span><br>
@Test public void sameSeenAtRevision() throws Exception {
  MemoryDocumentStore store=new MemoryDocumentStore();
  DocumentNodeStore ns1=builderProvider.newBuilder().setDocumentStore(store).setAsyncDelay(0).setClusterId(1).getNodeStore();
  DocumentNodeStore ns2=builderProvider.newBuilder().setDocumentStore(store).setAsyncDelay(0).setClusterId(2).getNodeStore();
  NodeBuilder b2=ns2.getRoot().builder();
  b2.child("test");
  merge(ns2,b2);
  ns2.runBackgroundOperations();
  ns1.runBackgroundOperations();
  NodeBuilder b1=ns1.getRoot().builder();
  assertTrue(b1.hasChildNode("test"));
  b1.child("test").remove();
  merge(ns1,b1);
  ns1.runBackgroundOperations();
  DocumentNodeStore ns3=builderProvider.newBuilder().setDocumentStore(store).setAsyncDelay(0).setClusterId(3).getNodeStore();
  ns3.setMaxBackOffMillis(0);
  NodeBuilder b3=ns3.getRoot().builder();
  assertFalse(b3.hasChildNode("test"));
  b3.child("test");
  merge(ns3,b3);
}

</code></pre>

<script>$(document).ready(function() {
  $('pre code').each(function(i, block) {
    hljs.highlightBlock(block);
  });
});</script>
