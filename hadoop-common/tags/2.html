<h3><span class=" glyphicon glyphicon-tag"/>&nbspUtilityVerifier</h3><kbd>Verifies (un)successful execution of the test case by reporting explicitly a failure</kbd><br><br><br><h4 style="margin:0px">Class: TestFuseDFS </h4><pre class="type-2 type-1 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test concurrent creation and access of the mount 
 */
@Test public void testMultipleThreads() throws IOException {
  ArrayList<Thread> threads=new ArrayList<Thread>();
  final AtomicReference<String> errorMessage=new AtomicReference<String>();
  for (int i=0; i < 10; i++) {
    Thread t=new Thread(){
      public void run(){
        try {
          File d=new File(mountPoint,"dir" + getId());
          execWaitRet("mkdir " + d.getAbsolutePath());
          for (int j=0; j < 10; j++) {
            File f=new File(d,"file" + j);
            final String contents="thread " + getId() + " "+ j;
            createFile(f,contents);
          }
          for (int j=0; j < 10; j++) {
            File f=new File(d,"file" + j);
            execWaitRet("cat " + f.getAbsolutePath());
            execWaitRet("rm " + f.getAbsolutePath());
          }
          execWaitRet("rmdir " + d.getAbsolutePath());
        }
 catch (        IOException ie) {
          errorMessage.set(String.format("Exception %s",StringUtils.stringifyException(ie)));
        }
      }
    }
;
    t.start();
    threads.add(t);
  }
  for (  Thread t : threads) {
    try {
      t.join();
    }
 catch (    InterruptedException ie) {
      fail("Thread interrupted: " + ie.getMessage());
    }
  }
  assertNull(errorMessage.get(),errorMessage.get());
}

</code></pre>

<br>
<pre class="type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test random access to a file 
 */
@Test public void testRandomAccess() throws IOException {
  final String contents="hello world";
  File f=new File(mountPoint,"file1");
  createFile(f,contents);
  RandomAccessFile raf=new RandomAccessFile(f,"rw");
  raf.seek(f.length());
  try {
    raf.write('b');
  }
 catch (  IOException e) {
    assertEquals("Operation not supported",e.getMessage());
  }
 finally {
    raf.close();
  }
  raf=new RandomAccessFile(f,"rw");
  raf.seek(0);
  try {
    raf.write('b');
    fail("Over-wrote existing bytes");
  }
 catch (  IOException e) {
    assertEquals("Invalid argument",e.getMessage());
  }
 finally {
    raf.close();
  }
  execAssertSucceeds("rm " + f.getAbsolutePath());
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.TestRefreshCallQueue </h4><pre class="type-2 type-7 type-10 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testRefresh() throws Exception {
  assertTrue("Mock queue should have been constructed",mockQueueConstructions > 0);
  assertTrue("Puts are routed through MockQueue",canPutInMockQueue());
  int lastMockQueueConstructions=mockQueueConstructions;
  DFSAdmin admin=new DFSAdmin(config);
  String[] args=new String[]{"-refreshCallQueue"};
  int exitCode=admin.run(args);
  assertEquals("DFSAdmin should return 0",0,exitCode);
  assertEquals("Mock queue should have no additional constructions",lastMockQueueConstructions,mockQueueConstructions);
  try {
    assertFalse("Puts are routed through LBQ instead of MockQueue",canPutInMockQueue());
  }
 catch (  IOException ioe) {
    fail("Could not put into queue at all");
  }
}

</code></pre>

<br>
<pre class="type-11 type-8 type-2 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Allocates resources before the execution of the test cases">TestInitializer</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions inside branch conditions
- Allocates resources before the execution of the test cases
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Before public void setUp() throws Exception {
  mockQueueConstructions=0;
  mockQueuePuts=0;
  int portRetries=5;
  int nnPort;
  for (; portRetries > 0; --portRetries) {
    nnPort=30000 + rand.nextInt(30000);
    config=new Configuration();
    callQueueConfigKey="ipc." + nnPort + ".callqueue.impl";
    config.setClass(callQueueConfigKey,MockCallQueue.class,BlockingQueue.class);
    config.set("hadoop.security.authorization","true");
    FileSystem.setDefaultUri(config,"hdfs://localhost:" + nnPort);
    fs=FileSystem.get(config);
    try {
      cluster=new MiniDFSCluster.Builder(config).nameNodePort(nnPort).build();
      cluster.waitActive();
      break;
    }
 catch (    BindException be) {
    }
  }
  if (portRetries == 0) {
    fail("Failed to pick an ephemeral port for the NameNode RPC server.");
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.conf.TestConfServlet </h4><pre class="type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testBadFormat() throws Exception {
  StringWriter sw=new StringWriter();
  try {
    ConfServlet.writeResponse(getTestConf(),sw,"not a format");
    fail("writeResponse with bad format didn't throw!");
  }
 catch (  ConfServlet.BadFormatException bfe) {
  }
  assertEquals("",sw.toString());
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.contrib.bkjournal.TestBookKeeperAsHASharedDir </h4><pre class="type-9 type-2 type-7 type-10 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test HA failover, where BK, as the shared storage, fails.
 * Once it becomes available again, a standby can come up.
 * Verify that any write happening after the BK fail is not
 * available on the standby.
 */
@Test public void testFailoverWithFailingBKCluster() throws Exception {
  int ensembleSize=numBookies + 1;
  BookieServer newBookie=bkutil.newBookie();
  assertEquals("New bookie didn't start",ensembleSize,bkutil.checkBookiesUp(ensembleSize,10));
  BookieServer replacementBookie=null;
  MiniDFSCluster cluster=null;
  try {
    Configuration conf=new Configuration();
    conf.setInt(DFSConfigKeys.DFS_HA_TAILEDITS_PERIOD_KEY,1);
    conf.set(DFSConfigKeys.DFS_NAMENODE_SHARED_EDITS_DIR_KEY,BKJMUtil.createJournalURI("/hotfailoverWithFail").toString());
    conf.setInt(BookKeeperJournalManager.BKJM_BOOKKEEPER_ENSEMBLE_SIZE,ensembleSize);
    conf.setInt(BookKeeperJournalManager.BKJM_BOOKKEEPER_QUORUM_SIZE,ensembleSize);
    BKJMUtil.addJournalManagerDefinition(conf);
    cluster=new MiniDFSCluster.Builder(conf).nnTopology(MiniDFSNNTopology.simpleHATopology()).numDataNodes(0).manageNameDfsSharedDirs(false).checkExitOnShutdown(false).build();
    NameNode nn1=cluster.getNameNode(0);
    NameNode nn2=cluster.getNameNode(1);
    cluster.waitActive();
    cluster.transitionToActive(0);
    Path p1=new Path("/testBKJMFailingBKCluster1");
    Path p2=new Path("/testBKJMFailingBKCluster2");
    FileSystem fs=HATestUtil.configureFailoverFs(cluster,conf);
    fs.mkdirs(p1);
    newBookie.shutdown();
    assertEquals("New bookie didn't stop",numBookies,bkutil.checkBookiesUp(numBookies,10));
    try {
      fs.mkdirs(p2);
      fail("mkdirs should result in the NN exiting");
    }
 catch (    RemoteException re) {
      assertTrue(re.getClassName().contains("ExitException"));
    }
    cluster.shutdownNameNode(0);
    try {
      cluster.transitionToActive(1);
      fail("Shouldn't have been able to transition with bookies down");
    }
 catch (    ExitException ee) {
      assertTrue("Should shutdown due to required journal failure",ee.getMessage().contains("starting log segment 3 failed for required journal"));
    }
    replacementBookie=bkutil.newBookie();
    assertEquals("Replacement bookie didn't start",ensembleSize,bkutil.checkBookiesUp(ensembleSize,10));
    cluster.transitionToActive(1);
    assertTrue(fs.exists(p1));
    assertFalse(fs.exists(p2));
  }
  finally {
    newBookie.shutdown();
    if (replacementBookie != null) {
      replacementBookie.shutdown();
    }
    if (cluster != null) {
      cluster.shutdown();
    }
  }
}

</code></pre>

<br>
<pre class="type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test that two namenodes can't continue as primary
 */
@Test public void testMultiplePrimariesStarted() throws Exception {
  Path p1=new Path("/testBKJMMultiplePrimary");
  MiniDFSCluster cluster=null;
  try {
    Configuration conf=new Configuration();
    conf.setInt(DFSConfigKeys.DFS_HA_TAILEDITS_PERIOD_KEY,1);
    conf.set(DFSConfigKeys.DFS_NAMENODE_SHARED_EDITS_DIR_KEY,BKJMUtil.createJournalURI("/hotfailoverMultiple").toString());
    BKJMUtil.addJournalManagerDefinition(conf);
    cluster=new MiniDFSCluster.Builder(conf).nnTopology(MiniDFSNNTopology.simpleHATopology()).numDataNodes(0).manageNameDfsSharedDirs(false).checkExitOnShutdown(false).build();
    NameNode nn1=cluster.getNameNode(0);
    NameNode nn2=cluster.getNameNode(1);
    cluster.waitActive();
    cluster.transitionToActive(0);
    FileSystem fs=HATestUtil.configureFailoverFs(cluster,conf);
    fs.mkdirs(p1);
    nn1.getRpcServer().rollEditLog();
    cluster.transitionToActive(1);
    fs=cluster.getFileSystem(0);
    try {
      fs.delete(p1,true);
      fail("Log update on older active should cause it to exit");
    }
 catch (    RemoteException re) {
      assertTrue(re.getClassName().contains("ExitException"));
    }
  }
  finally {
    if (cluster != null) {
      cluster.shutdown();
    }
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.contrib.bkjournal.TestBookKeeperEditLogStreams </h4><pre class="type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test that bkjm will refuse open a stream on an empty
 * ledger.
 */
@Test public void testEmptyInputStream() throws Exception {
  ZooKeeper zk=BKJMUtil.connectZooKeeper();
  BookKeeper bkc=new BookKeeper(new ClientConfiguration(),zk);
  try {
    LedgerHandle lh=bkc.createLedger(BookKeeper.DigestType.CRC32,"foobar".getBytes());
    lh.close();
    EditLogLedgerMetadata metadata=new EditLogLedgerMetadata("/foobar",HdfsConstants.NAMENODE_LAYOUT_VERSION,lh.getId(),0x1234);
    try {
      new BookKeeperEditLogInputStream(lh,metadata,-1);
      fail("Shouldn't get this far, should have thrown");
    }
 catch (    IOException ioe) {
      assertTrue(ioe.getMessage().contains("Invalid first bk entry to read"));
    }
    metadata=new EditLogLedgerMetadata("/foobar",HdfsConstants.NAMENODE_LAYOUT_VERSION,lh.getId(),0x1234);
    try {
      new BookKeeperEditLogInputStream(lh,metadata,0);
      fail("Shouldn't get this far, should have thrown");
    }
 catch (    IOException ioe) {
      assertTrue(ioe.getMessage().contains("Invalid first bk entry to read"));
    }
  }
  finally {
    bkc.close();
    zk.close();
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.contrib.bkjournal.TestBookKeeperJournalManager </h4><pre class="type-2 type-7 type-10 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test that if enough bookies fail to prevent an ensemble,
 * writes the bookkeeper will fail. Test that when once again
 * an ensemble is available, it can continue to write.
 */
@Test public void testAllBookieFailure() throws Exception {
  BookieServer bookieToFail=bkutil.newBookie();
  BookieServer replacementBookie=null;
  try {
    int ensembleSize=numBookies + 1;
    assertEquals("New bookie didn't start",ensembleSize,bkutil.checkBookiesUp(ensembleSize,10));
    Configuration conf=new Configuration();
    conf.setInt(BookKeeperJournalManager.BKJM_BOOKKEEPER_ENSEMBLE_SIZE,ensembleSize);
    conf.setInt(BookKeeperJournalManager.BKJM_BOOKKEEPER_QUORUM_SIZE,ensembleSize);
    long txid=1;
    NamespaceInfo nsi=newNSInfo();
    BookKeeperJournalManager bkjm=new BookKeeperJournalManager(conf,BKJMUtil.createJournalURI("/hdfsjournal-allbookiefailure"),nsi);
    bkjm.format(nsi);
    EditLogOutputStream out=bkjm.startLogSegment(txid,NameNodeLayoutVersion.CURRENT_LAYOUT_VERSION);
    for (long i=1; i <= 3; i++) {
      FSEditLogOp op=FSEditLogTestUtil.getNoOpInstance();
      op.setTransactionId(txid++);
      out.write(op);
    }
    out.setReadyToFlush();
    out.flush();
    bookieToFail.shutdown();
    assertEquals("New bookie didn't die",numBookies,bkutil.checkBookiesUp(numBookies,10));
    try {
      for (long i=1; i <= 3; i++) {
        FSEditLogOp op=FSEditLogTestUtil.getNoOpInstance();
        op.setTransactionId(txid++);
        out.write(op);
      }
      out.setReadyToFlush();
      out.flush();
      fail("should not get to this stage");
    }
 catch (    IOException ioe) {
      LOG.debug("Error writing to bookkeeper",ioe);
      assertTrue("Invalid exception message",ioe.getMessage().contains("Failed to write to bookkeeper"));
    }
    replacementBookie=bkutil.newBookie();
    assertEquals("New bookie didn't start",numBookies + 1,bkutil.checkBookiesUp(numBookies + 1,10));
    bkjm.recoverUnfinalizedSegments();
    out=bkjm.startLogSegment(txid,NameNodeLayoutVersion.CURRENT_LAYOUT_VERSION);
    for (long i=1; i <= 3; i++) {
      FSEditLogOp op=FSEditLogTestUtil.getNoOpInstance();
      op.setTransactionId(txid++);
      out.write(op);
    }
    out.setReadyToFlush();
    out.flush();
  }
 catch (  Exception e) {
    LOG.error("Exception in test",e);
    throw e;
  }
 finally {
    if (replacementBookie != null) {
      replacementBookie.shutdown();
    }
    bookieToFail.shutdown();
    if (bkutil.checkBookiesUp(numBookies,30) != numBookies) {
      LOG.warn("Not all bookies from this test shut down, expect errors");
    }
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testTwoWriters() throws Exception {
  long start=1;
  NamespaceInfo nsi=newNSInfo();
  BookKeeperJournalManager bkjm1=new BookKeeperJournalManager(conf,BKJMUtil.createJournalURI("/hdfsjournal-dualWriter"),nsi);
  bkjm1.format(nsi);
  BookKeeperJournalManager bkjm2=new BookKeeperJournalManager(conf,BKJMUtil.createJournalURI("/hdfsjournal-dualWriter"),nsi);
  EditLogOutputStream out1=bkjm1.startLogSegment(start,NameNodeLayoutVersion.CURRENT_LAYOUT_VERSION);
  try {
    bkjm2.startLogSegment(start,NameNodeLayoutVersion.CURRENT_LAYOUT_VERSION);
    fail("Shouldn't have been able to open the second writer");
  }
 catch (  IOException ioe) {
    LOG.info("Caught exception as expected",ioe);
  }
 finally {
    out1.close();
  }
}

</code></pre>

<br>
<pre class="type-13 type-2 type-7 type-1 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testNumberOfTransactionsWithGaps() throws Exception {
  NamespaceInfo nsi=newNSInfo();
  BookKeeperJournalManager bkjm=new BookKeeperJournalManager(conf,BKJMUtil.createJournalURI("/hdfsjournal-gaps"),nsi);
  bkjm.format(nsi);
  long txid=1;
  for (long i=0; i < 3; i++) {
    long start=txid;
    EditLogOutputStream out=bkjm.startLogSegment(start,NameNodeLayoutVersion.CURRENT_LAYOUT_VERSION);
    for (long j=1; j <= DEFAULT_SEGMENT_SIZE; j++) {
      FSEditLogOp op=FSEditLogTestUtil.getNoOpInstance();
      op.setTransactionId(txid++);
      out.write(op);
    }
    out.close();
    bkjm.finalizeLogSegment(start,txid - 1);
    assertNotNull(zkc.exists(bkjm.finalizedLedgerZNode(start,txid - 1),false));
  }
  zkc.delete(bkjm.finalizedLedgerZNode(DEFAULT_SEGMENT_SIZE + 1,DEFAULT_SEGMENT_SIZE * 2),-1);
  long numTrans=bkjm.getNumberOfTransactions(1,true);
  assertEquals(DEFAULT_SEGMENT_SIZE,numTrans);
  try {
    numTrans=bkjm.getNumberOfTransactions(DEFAULT_SEGMENT_SIZE + 1,true);
    fail("Should have thrown corruption exception by this point");
  }
 catch (  JournalManager.CorruptionException ce) {
  }
  numTrans=bkjm.getNumberOfTransactions((DEFAULT_SEGMENT_SIZE * 2) + 1,true);
  assertEquals(DEFAULT_SEGMENT_SIZE,numTrans);
}

</code></pre>

<br>
<pre class="type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * If a journal manager has an corrupt inprogress node, ensure that we throw
 * an error, as this should not be possible, and some third party has
 * corrupted the zookeeper state
 */
@Test public void testCorruptInprogressNode() throws Exception {
  URI uri=BKJMUtil.createJournalURI("/hdfsjournal-corruptInprogress");
  NamespaceInfo nsi=newNSInfo();
  BookKeeperJournalManager bkjm=new BookKeeperJournalManager(conf,uri,nsi);
  bkjm.format(nsi);
  EditLogOutputStream out=bkjm.startLogSegment(1,NameNodeLayoutVersion.CURRENT_LAYOUT_VERSION);
  ;
  for (long i=1; i <= 100; i++) {
    FSEditLogOp op=FSEditLogTestUtil.getNoOpInstance();
    op.setTransactionId(i);
    out.write(op);
  }
  out.close();
  bkjm.finalizeLogSegment(1,100);
  out=bkjm.startLogSegment(101,NameNodeLayoutVersion.CURRENT_LAYOUT_VERSION);
  out.close();
  bkjm.close();
  String inprogressZNode=bkjm.inprogressZNode(101);
  zkc.setData(inprogressZNode,"WholeLottaJunk".getBytes(),-1);
  bkjm=new BookKeeperJournalManager(conf,uri,nsi);
  try {
    bkjm.recoverUnfinalizedSegments();
    fail("Should have failed. There should be no way of creating" + " an empty inprogess znode");
  }
 catch (  IOException e) {
    assertTrue("Exception different than expected",e.getMessage().contains("has no field named"));
  }
 finally {
    bkjm.close();
  }
}

</code></pre>

<br>
<pre class="type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * If a journal manager has an empty inprogress node, ensure that we throw an
 * error, as this should not be possible, and some third party has corrupted
 * the zookeeper state
 */
@Test public void testEmptyInprogressNode() throws Exception {
  URI uri=BKJMUtil.createJournalURI("/hdfsjournal-emptyInprogress");
  NamespaceInfo nsi=newNSInfo();
  BookKeeperJournalManager bkjm=new BookKeeperJournalManager(conf,uri,nsi);
  bkjm.format(nsi);
  EditLogOutputStream out=bkjm.startLogSegment(1,NameNodeLayoutVersion.CURRENT_LAYOUT_VERSION);
  ;
  for (long i=1; i <= 100; i++) {
    FSEditLogOp op=FSEditLogTestUtil.getNoOpInstance();
    op.setTransactionId(i);
    out.write(op);
  }
  out.close();
  bkjm.finalizeLogSegment(1,100);
  out=bkjm.startLogSegment(101,NameNodeLayoutVersion.CURRENT_LAYOUT_VERSION);
  out.close();
  bkjm.close();
  String inprogressZNode=bkjm.inprogressZNode(101);
  zkc.setData(inprogressZNode,new byte[0],-1);
  bkjm=new BookKeeperJournalManager(conf,uri,nsi);
  try {
    bkjm.recoverUnfinalizedSegments();
    fail("Should have failed. There should be no way of creating" + " an empty inprogess znode");
  }
 catch (  IOException e) {
    assertTrue("Exception different than expected",e.getMessage().contains("Invalid/Incomplete data in znode"));
  }
 finally {
    bkjm.close();
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-1 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Create a bkjm namespace, write a journal from txid 1, close stream.
 * Try to create a new journal from txid 1. Should throw an exception.
 */
@Test public void testWriteRestartFrom1() throws Exception {
  NamespaceInfo nsi=newNSInfo();
  BookKeeperJournalManager bkjm=new BookKeeperJournalManager(conf,BKJMUtil.createJournalURI("/hdfsjournal-restartFrom1"),nsi);
  bkjm.format(nsi);
  long txid=1;
  long start=txid;
  EditLogOutputStream out=bkjm.startLogSegment(txid,NameNodeLayoutVersion.CURRENT_LAYOUT_VERSION);
  for (long j=1; j <= DEFAULT_SEGMENT_SIZE; j++) {
    FSEditLogOp op=FSEditLogTestUtil.getNoOpInstance();
    op.setTransactionId(txid++);
    out.write(op);
  }
  out.close();
  bkjm.finalizeLogSegment(start,(txid - 1));
  txid=1;
  try {
    out=bkjm.startLogSegment(txid,NameNodeLayoutVersion.CURRENT_LAYOUT_VERSION);
    fail("Shouldn't be able to start another journal from " + txid + " when one already exists");
  }
 catch (  Exception ioe) {
    LOG.info("Caught exception as expected",ioe);
  }
  txid=DEFAULT_SEGMENT_SIZE;
  try {
    out=bkjm.startLogSegment(txid,NameNodeLayoutVersion.CURRENT_LAYOUT_VERSION);
    fail("Shouldn't be able to start another journal from " + txid + " when one already exists");
  }
 catch (  IOException ioe) {
    LOG.info("Caught exception as expected",ioe);
  }
  txid=DEFAULT_SEGMENT_SIZE + 1;
  start=txid;
  out=bkjm.startLogSegment(start,NameNodeLayoutVersion.CURRENT_LAYOUT_VERSION);
  assertNotNull(out);
  for (long j=1; j <= DEFAULT_SEGMENT_SIZE; j++) {
    FSEditLogOp op=FSEditLogTestUtil.getNoOpInstance();
    op.setTransactionId(txid++);
    out.write(op);
  }
  out.close();
  bkjm.finalizeLogSegment(start,(txid - 1));
  txid=DEFAULT_SEGMENT_SIZE * 4;
  out=bkjm.startLogSegment(txid,NameNodeLayoutVersion.CURRENT_LAYOUT_VERSION);
  assertNotNull(out);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.crypto.CryptoStreamsTestBase </h4><pre class="type-9 type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test skip. 
 */
@Test(timeout=120000) public void testSkip() throws Exception {
  OutputStream out=getOutputStream(defaultBufferSize);
  writeData(out);
  InputStream in=getInputStream(defaultBufferSize);
  byte[] result=new byte[dataLen];
  int n1=readAll(in,result,0,dataLen / 3);
  Assert.assertEquals(n1,((Seekable)in).getPos());
  long skipped=in.skip(dataLen / 3);
  int n2=readAll(in,result,0,dataLen);
  Assert.assertEquals(dataLen,n1 + skipped + n2);
  byte[] readData=new byte[n2];
  System.arraycopy(result,0,readData,0,n2);
  byte[] expectedData=new byte[n2];
  System.arraycopy(data,dataLen - n2,expectedData,0,n2);
  Assert.assertArrayEquals(readData,expectedData);
  try {
    skipped=in.skip(-3);
    Assert.fail("Skip Negative length should fail.");
  }
 catch (  IllegalArgumentException e) {
    GenericTestUtils.assertExceptionContains("Negative skip length",e);
  }
  skipped=in.skip(3);
  Assert.assertEquals(skipped,0);
  in.close();
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test(timeout=120000) public void testSeekToNewSource() throws Exception {
  OutputStream out=getOutputStream(defaultBufferSize);
  writeData(out);
  InputStream in=getInputStream(defaultBufferSize);
  final int len1=dataLen / 8;
  byte[] readData=new byte[len1];
  readAll(in,readData,0,len1);
  seekToNewSourceCheck(in,dataLen / 3);
  seekToNewSourceCheck(in,0);
  seekToNewSourceCheck(in,dataLen / 2);
  try {
    seekToNewSourceCheck(in,-3);
    Assert.fail("Seek to negative offset should fail.");
  }
 catch (  IllegalArgumentException e) {
    GenericTestUtils.assertExceptionContains("Cannot seek to negative " + "offset",e);
  }
  try {
    seekToNewSourceCheck(in,dataLen + 3);
    Assert.fail("Seek after EOF should fail.");
  }
 catch (  IOException e) {
    GenericTestUtils.assertExceptionContains("Attempted to read past " + "end of file",e);
  }
  in.close();
}

</code></pre>

<br>
<pre class="type-9 type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test seek to different position. 
 */
@Test(timeout=120000) public void testSeek() throws Exception {
  OutputStream out=getOutputStream(defaultBufferSize);
  writeData(out);
  InputStream in=getInputStream(defaultBufferSize);
  seekCheck(in,dataLen / 3);
  seekCheck(in,0);
  seekCheck(in,dataLen / 2);
  final long pos=((Seekable)in).getPos();
  try {
    seekCheck(in,-3);
    Assert.fail("Seek to negative offset should fail.");
  }
 catch (  IllegalArgumentException e) {
    GenericTestUtils.assertExceptionContains("Cannot seek to negative " + "offset",e);
  }
  Assert.assertEquals(pos,((Seekable)in).getPos());
  try {
    seekCheck(in,dataLen + 3);
    Assert.fail("Seek after EOF should fail.");
  }
 catch (  IOException e) {
    GenericTestUtils.assertExceptionContains("Cannot seek after EOF",e);
  }
  Assert.assertEquals(pos,((Seekable)in).getPos());
  in.close();
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.crypto.TestOpensslCipher </h4><pre class="type-2 type-10 type-15 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Sets implicit assumptions ">AssumptionSetter</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Sets implicit assumptions 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=120000) public void testGetInstance() throws Exception {
  Assume.assumeTrue(OpensslCipher.getLoadingFailureReason() == null);
  OpensslCipher cipher=OpensslCipher.getInstance("AES/CTR/NoPadding");
  Assert.assertTrue(cipher != null);
  try {
    cipher=OpensslCipher.getInstance("AES2/CTR/NoPadding");
    Assert.fail("Should specify correct algorithm.");
  }
 catch (  NoSuchAlgorithmException e) {
  }
  try {
    cipher=OpensslCipher.getInstance("AES/CTR/NoPadding2");
    Assert.fail("Should specify correct padding.");
  }
 catch (  NoSuchPaddingException e) {
  }
}

</code></pre>

<br>
<pre class="type-2 type-10 type-15 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Sets implicit assumptions ">AssumptionSetter</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Sets implicit assumptions 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=120000) public void testDoFinalArguments() throws Exception {
  Assume.assumeTrue(OpensslCipher.getLoadingFailureReason() == null);
  OpensslCipher cipher=OpensslCipher.getInstance("AES/CTR/NoPadding");
  Assert.assertTrue(cipher != null);
  cipher.init(OpensslCipher.ENCRYPT_MODE,key,iv);
  ByteBuffer output=ByteBuffer.allocate(1024);
  try {
    cipher.doFinal(output);
    Assert.fail("Output buffer should be direct buffer.");
  }
 catch (  IllegalArgumentException e) {
    GenericTestUtils.assertExceptionContains("Direct buffer is required",e);
  }
}

</code></pre>

<br>
<pre class="type-2 type-10 type-15 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Sets implicit assumptions ">AssumptionSetter</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Sets implicit assumptions 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=120000) public void testUpdateArguments() throws Exception {
  Assume.assumeTrue(OpensslCipher.getLoadingFailureReason() == null);
  OpensslCipher cipher=OpensslCipher.getInstance("AES/CTR/NoPadding");
  Assert.assertTrue(cipher != null);
  cipher.init(OpensslCipher.ENCRYPT_MODE,key,iv);
  ByteBuffer input=ByteBuffer.allocate(1024);
  ByteBuffer output=ByteBuffer.allocate(1024);
  try {
    cipher.update(input,output);
    Assert.fail("Input and output buffer should be direct buffer.");
  }
 catch (  IllegalArgumentException e) {
    GenericTestUtils.assertExceptionContains("Direct buffers are required",e);
  }
  input=ByteBuffer.allocateDirect(1024);
  output=ByteBuffer.allocateDirect(1000);
  try {
    cipher.update(input,output);
    Assert.fail("Output buffer length should be sufficient " + "to store output data");
  }
 catch (  ShortBufferException e) {
    GenericTestUtils.assertExceptionContains("Output buffer is not sufficient",e);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.crypto.key.TestKeyProviderCryptoExtension </h4><pre class="type-11 type-2 type-7 type-1 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testGenerateEncryptedKey() throws Exception {
  KeyProviderCryptoExtension.EncryptedKeyVersion ek1=kpExt.generateEncryptedKey(encryptionKey.getName());
  assertEquals("Version name of EEK should be EEK",KeyProviderCryptoExtension.EEK,ek1.getEncryptedKeyVersion().getVersionName());
  assertEquals("Name of EEK should be encryption key name",ENCRYPTION_KEY_NAME,ek1.getEncryptionKeyName());
  assertNotNull("Expected encrypted key material",ek1.getEncryptedKeyVersion().getMaterial());
  assertEquals("Length of encryption key material and EEK material should " + "be the same",encryptionKey.getMaterial().length,ek1.getEncryptedKeyVersion().getMaterial().length);
  KeyVersion k1=kpExt.decryptEncryptedKey(ek1);
  assertEquals(KeyProviderCryptoExtension.EK,k1.getVersionName());
  assertEquals(encryptionKey.getMaterial().length,k1.getMaterial().length);
  if (Arrays.equals(k1.getMaterial(),encryptionKey.getMaterial())) {
    fail("Encrypted key material should not equal encryption key material");
  }
  if (Arrays.equals(ek1.getEncryptedKeyVersion().getMaterial(),encryptionKey.getMaterial())) {
    fail("Encrypted key material should not equal decrypted key material");
  }
  KeyVersion k1a=kpExt.decryptEncryptedKey(ek1);
  assertArrayEquals(k1.getMaterial(),k1a.getMaterial());
  KeyProviderCryptoExtension.EncryptedKeyVersion ek2=kpExt.generateEncryptedKey(encryptionKey.getName());
  KeyVersion k2=kpExt.decryptEncryptedKey(ek2);
  if (Arrays.equals(k1.getMaterial(),k2.getMaterial())) {
    fail("Generated EEKs should have different material!");
  }
  if (Arrays.equals(ek1.getEncryptedKeyIv(),ek2.getEncryptedKeyIv())) {
    fail("Generated EEKs should have different IVs!");
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.crypto.key.TestKeyProviderFactory </h4><pre class="type-9 type-2 type-7 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testJksProvider() throws Exception {
  Configuration conf=new Configuration();
  final String ourUrl=JavaKeyStoreProvider.SCHEME_NAME + "://file" + tmpDir+ "/test.jks";
  File file=new File(tmpDir,"test.jks");
  file.delete();
  conf.set(KeyProviderFactory.KEY_PROVIDER_PATH,ourUrl);
  checkSpecificProvider(conf,ourUrl);
  Path path=ProviderUtils.unnestUri(new URI(ourUrl));
  FileSystem fs=path.getFileSystem(conf);
  FileStatus s=fs.getFileStatus(path);
  assertTrue(s.getPermission().toString().equals("rwx------"));
  assertTrue(file + " should exist",file.isFile());
  File oldFile=new File(file.getPath() + "_OLD");
  file.renameTo(oldFile);
  file.delete();
  file.createNewFile();
  assertTrue(oldFile.exists());
  KeyProvider provider=KeyProviderFactory.getProviders(conf).get(0);
  assertTrue(file.exists());
  assertTrue(oldFile + "should be deleted",!oldFile.exists());
  verifyAfterReload(file,provider);
  assertTrue(!oldFile.exists());
  File newFile=new File(file.getPath() + "_NEW");
  newFile.createNewFile();
  try {
    provider=KeyProviderFactory.getProviders(conf).get(0);
    Assert.fail("_NEW and current file should not exist together !!");
  }
 catch (  Exception e) {
  }
 finally {
    if (newFile.exists()) {
      newFile.delete();
    }
  }
  file.renameTo(newFile);
  file.delete();
  try {
    provider=KeyProviderFactory.getProviders(conf).get(0);
    Assert.assertFalse(newFile.exists());
    Assert.assertFalse(oldFile.exists());
  }
 catch (  Exception e) {
    Assert.fail("JKS should load from _NEW file !!");
  }
  verifyAfterReload(file,provider);
  newFile.createNewFile();
  file.renameTo(oldFile);
  file.delete();
  try {
    provider=KeyProviderFactory.getProviders(conf).get(0);
    Assert.assertFalse(newFile.exists());
    Assert.assertFalse(oldFile.exists());
  }
 catch (  Exception e) {
    Assert.fail("JKS should load from _OLD file !!");
  }
 finally {
    if (newFile.exists()) {
      newFile.delete();
    }
  }
  verifyAfterReload(file,provider);
  fs.setPermission(path,new FsPermission("777"));
  checkPermissionRetention(conf,ourUrl,path);
}

</code></pre>

<br>
<pre class="type-9 type-2 type-7 type-1 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testJksProviderPasswordViaConfig() throws Exception {
  Configuration conf=new Configuration();
  final String ourUrl=JavaKeyStoreProvider.SCHEME_NAME + "://file" + tmpDir+ "/test.jks";
  File file=new File(tmpDir,"test.jks");
  file.delete();
  try {
    conf.set(KeyProviderFactory.KEY_PROVIDER_PATH,ourUrl);
    conf.set(JavaKeyStoreProvider.KEYSTORE_PASSWORD_FILE_KEY,"javakeystoreprovider.password");
    KeyProvider provider=KeyProviderFactory.getProviders(conf).get(0);
    provider.createKey("key3",new byte[16],KeyProvider.options(conf));
    provider.flush();
  }
 catch (  Exception ex) {
    Assert.fail("could not create keystore with password file");
  }
  KeyProvider provider=KeyProviderFactory.getProviders(conf).get(0);
  Assert.assertNotNull(provider.getCurrentKey("key3"));
  try {
    conf.set(JavaKeyStoreProvider.KEYSTORE_PASSWORD_FILE_KEY,"bar");
    KeyProviderFactory.getProviders(conf).get(0);
    Assert.fail("using non existing password file, it should fail");
  }
 catch (  IOException ex) {
  }
  try {
    conf.set(JavaKeyStoreProvider.KEYSTORE_PASSWORD_FILE_KEY,"core-site.xml");
    KeyProviderFactory.getProviders(conf).get(0);
    Assert.fail("using different password file, it should fail");
  }
 catch (  IOException ex) {
  }
  try {
    conf.unset(JavaKeyStoreProvider.KEYSTORE_PASSWORD_FILE_KEY);
    KeyProviderFactory.getProviders(conf).get(0);
    Assert.fail("No password file property, env not set, it should fail");
  }
 catch (  IOException ex) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.crypto.key.kms.server.TestKMS </h4><pre class="type-2 type-7 type-1 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testACLs() throws Exception {
  Configuration conf=new Configuration();
  conf.set("hadoop.security.authentication","kerberos");
  UserGroupInformation.setConfiguration(conf);
  final File testDir=getTestDir();
  conf=createBaseKMSConf(testDir);
  conf.set("hadoop.kms.authentication.type","kerberos");
  conf.set("hadoop.kms.authentication.kerberos.keytab",keytab.getAbsolutePath());
  conf.set("hadoop.kms.authentication.kerberos.principal","HTTP/localhost");
  conf.set("hadoop.kms.authentication.kerberos.name.rules","DEFAULT");
  for (  KMSACLs.Type type : KMSACLs.Type.values()) {
    conf.set(type.getConfigKey(),type.toString());
  }
  conf.set(KMSACLs.Type.CREATE.getConfigKey(),KMSACLs.Type.CREATE.toString() + ",SET_KEY_MATERIAL");
  conf.set(KMSACLs.Type.ROLLOVER.getConfigKey(),KMSACLs.Type.ROLLOVER.toString() + ",SET_KEY_MATERIAL");
  writeConf(testDir,conf);
  runServer(null,null,testDir,new KMSCallable(){
    @Override public Void call() throws Exception {
      final Configuration conf=new Configuration();
      conf.setInt(KeyProvider.DEFAULT_BITLENGTH_NAME,128);
      final URI uri=createKMSUri(getKMSUrl());
      doAs("client",new PrivilegedExceptionAction<Void>(){
        @Override public Void run() throws Exception {
          KeyProvider kp=new KMSClientProvider(uri,conf);
          try {
            kp.createKey("k",new KeyProvider.Options(conf));
            Assert.fail();
          }
 catch (          AuthorizationException ex) {
          }
catch (          Exception ex) {
            Assert.fail(ex.getMessage());
          }
          try {
            kp.createKey("k",new byte[16],new KeyProvider.Options(conf));
            Assert.fail();
          }
 catch (          AuthorizationException ex) {
          }
catch (          Exception ex) {
            Assert.fail(ex.getMessage());
          }
          try {
            kp.rollNewVersion("k");
            Assert.fail();
          }
 catch (          AuthorizationException ex) {
          }
catch (          Exception ex) {
            Assert.fail(ex.getMessage());
          }
          try {
            kp.rollNewVersion("k",new byte[16]);
            Assert.fail();
          }
 catch (          AuthorizationException ex) {
          }
catch (          Exception ex) {
            Assert.fail(ex.getMessage());
          }
          try {
            kp.getKeys();
            Assert.fail();
          }
 catch (          AuthorizationException ex) {
          }
catch (          Exception ex) {
            Assert.fail(ex.getMessage());
          }
          try {
            kp.getKeysMetadata("k");
            Assert.fail();
          }
 catch (          AuthorizationException ex) {
          }
catch (          Exception ex) {
            Assert.fail(ex.getMessage());
          }
          try {
            kp.getKeyVersion("k@0");
            Assert.fail();
          }
 catch (          AuthorizationException ex) {
          }
catch (          Exception ex) {
            Assert.fail(ex.getMessage());
          }
          try {
            kp.getCurrentKey("k");
            Assert.fail();
          }
 catch (          AuthorizationException ex) {
          }
catch (          Exception ex) {
            Assert.fail(ex.getMessage());
          }
          try {
            kp.getMetadata("k");
            Assert.fail();
          }
 catch (          AuthorizationException ex) {
          }
catch (          Exception ex) {
            Assert.fail(ex.getMessage());
          }
          try {
            kp.getKeyVersions("k");
            Assert.fail();
          }
 catch (          AuthorizationException ex) {
          }
catch (          Exception ex) {
            Assert.fail(ex.getMessage());
          }
          return null;
        }
      }
);
      doAs("CREATE",new PrivilegedExceptionAction<Void>(){
        @Override public Void run() throws Exception {
          KeyProvider kp=new KMSClientProvider(uri,conf);
          try {
            KeyProvider.KeyVersion kv=kp.createKey("k0",new KeyProvider.Options(conf));
            Assert.assertNull(kv.getMaterial());
          }
 catch (          Exception ex) {
            Assert.fail(ex.getMessage());
          }
          return null;
        }
      }
);
      doAs("DELETE",new PrivilegedExceptionAction<Void>(){
        @Override public Void run() throws Exception {
          KeyProvider kp=new KMSClientProvider(uri,conf);
          try {
            kp.deleteKey("k0");
          }
 catch (          Exception ex) {
            Assert.fail(ex.getMessage());
          }
          return null;
        }
      }
);
      doAs("SET_KEY_MATERIAL",new PrivilegedExceptionAction<Void>(){
        @Override public Void run() throws Exception {
          KeyProvider kp=new KMSClientProvider(uri,conf);
          try {
            KeyProvider.KeyVersion kv=kp.createKey("k1",new byte[16],new KeyProvider.Options(conf));
            Assert.assertNull(kv.getMaterial());
          }
 catch (          Exception ex) {
            Assert.fail(ex.getMessage());
          }
          return null;
        }
      }
);
      doAs("ROLLOVER",new PrivilegedExceptionAction<Void>(){
        @Override public Void run() throws Exception {
          KeyProvider kp=new KMSClientProvider(uri,conf);
          try {
            KeyProvider.KeyVersion kv=kp.rollNewVersion("k1");
            Assert.assertNull(kv.getMaterial());
          }
 catch (          Exception ex) {
            Assert.fail(ex.getMessage());
          }
          return null;
        }
      }
);
      doAs("SET_KEY_MATERIAL",new PrivilegedExceptionAction<Void>(){
        @Override public Void run() throws Exception {
          KeyProvider kp=new KMSClientProvider(uri,conf);
          try {
            KeyProvider.KeyVersion kv=kp.rollNewVersion("k1",new byte[16]);
            Assert.assertNull(kv.getMaterial());
          }
 catch (          Exception ex) {
            Assert.fail(ex.getMessage());
          }
          return null;
        }
      }
);
      final KeyVersion currKv=doAs("GET",new PrivilegedExceptionAction<KeyVersion>(){
        @Override public KeyVersion run() throws Exception {
          KeyProvider kp=new KMSClientProvider(uri,conf);
          try {
            kp.getKeyVersion("k1@0");
            KeyVersion kv=kp.getCurrentKey("k1");
            return kv;
          }
 catch (          Exception ex) {
            Assert.fail(ex.toString());
          }
          return null;
        }
      }
);
      final EncryptedKeyVersion encKv=doAs("GENERATE_EEK",new PrivilegedExceptionAction<EncryptedKeyVersion>(){
        @Override public EncryptedKeyVersion run() throws Exception {
          KeyProvider kp=new KMSClientProvider(uri,conf);
          try {
            KeyProviderCryptoExtension kpCE=KeyProviderCryptoExtension.createKeyProviderCryptoExtension(kp);
            EncryptedKeyVersion ek1=kpCE.generateEncryptedKey(currKv.getName());
            return ek1;
          }
 catch (          Exception ex) {
            Assert.fail(ex.toString());
          }
          return null;
        }
      }
);
      doAs("DECRYPT_EEK",new PrivilegedExceptionAction<Void>(){
        @Override public Void run() throws Exception {
          KeyProvider kp=new KMSClientProvider(uri,conf);
          try {
            KeyProviderCryptoExtension kpCE=KeyProviderCryptoExtension.createKeyProviderCryptoExtension(kp);
            kpCE.decryptEncryptedKey(encKv);
          }
 catch (          Exception ex) {
            Assert.fail(ex.getMessage());
          }
          return null;
        }
      }
);
      doAs("GET_KEYS",new PrivilegedExceptionAction<Void>(){
        @Override public Void run() throws Exception {
          KeyProvider kp=new KMSClientProvider(uri,conf);
          try {
            kp.getKeys();
          }
 catch (          Exception ex) {
            Assert.fail(ex.getMessage());
          }
          return null;
        }
      }
);
      doAs("GET_METADATA",new PrivilegedExceptionAction<Void>(){
        @Override public Void run() throws Exception {
          KeyProvider kp=new KMSClientProvider(uri,conf);
          try {
            kp.getMetadata("k1");
            kp.getKeysMetadata("k1");
          }
 catch (          Exception ex) {
            Assert.fail(ex.getMessage());
          }
          return null;
        }
      }
);
      KMSWebApp.getACLs().stopReloader();
      Thread.sleep(10);
      conf.set(KMSACLs.Type.CREATE.getConfigKey(),"foo");
      writeConf(testDir,conf);
      Thread.sleep(1000);
      KMSWebApp.getACLs().run();
      doAs("CREATE",new PrivilegedExceptionAction<Void>(){
        @Override public Void run() throws Exception {
          try {
            KeyProvider kp=new KMSClientProvider(uri,conf);
            KeyProvider.KeyVersion kv=kp.createKey("k2",new KeyProvider.Options(conf));
            Assert.fail();
          }
 catch (          AuthorizationException ex) {
          }
catch (          Exception ex) {
            Assert.fail(ex.getMessage());
          }
          return null;
        }
      }
);
      return null;
    }
  }
);
}

</code></pre>

<br>
<pre class="type-2 type-7 type-1 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testServicePrincipalACLs() throws Exception {
  Configuration conf=new Configuration();
  conf.set("hadoop.security.authentication","kerberos");
  UserGroupInformation.setConfiguration(conf);
  File testDir=getTestDir();
  conf=createBaseKMSConf(testDir);
  conf.set("hadoop.kms.authentication.type","kerberos");
  conf.set("hadoop.kms.authentication.kerberos.keytab",keytab.getAbsolutePath());
  conf.set("hadoop.kms.authentication.kerberos.principal","HTTP/localhost");
  conf.set("hadoop.kms.authentication.kerberos.name.rules","DEFAULT");
  for (  KMSACLs.Type type : KMSACLs.Type.values()) {
    conf.set(type.getConfigKey()," ");
  }
  conf.set(KMSACLs.Type.CREATE.getConfigKey(),"client");
  writeConf(testDir,conf);
  runServer(null,null,testDir,new KMSCallable(){
    @Override public Void call() throws Exception {
      final Configuration conf=new Configuration();
      conf.setInt(KeyProvider.DEFAULT_BITLENGTH_NAME,128);
      conf.setInt(KeyProvider.DEFAULT_BITLENGTH_NAME,64);
      final URI uri=createKMSUri(getKMSUrl());
      doAs("client",new PrivilegedExceptionAction<Void>(){
        @Override public Void run() throws Exception {
          try {
            KeyProvider kp=new KMSClientProvider(uri,conf);
            KeyProvider.KeyVersion kv=kp.createKey("ck0",new KeyProvider.Options(conf));
            Assert.assertNull(kv.getMaterial());
          }
 catch (          Exception ex) {
            Assert.fail(ex.getMessage());
          }
          return null;
        }
      }
);
      doAs("client/host",new PrivilegedExceptionAction<Void>(){
        @Override public Void run() throws Exception {
          try {
            KeyProvider kp=new KMSClientProvider(uri,conf);
            KeyProvider.KeyVersion kv=kp.createKey("ck1",new KeyProvider.Options(conf));
            Assert.assertNull(kv.getMaterial());
          }
 catch (          Exception ex) {
            Assert.fail(ex.getMessage());
          }
          return null;
        }
      }
);
      return null;
    }
  }
);
}

</code></pre>

<br>
<pre class="type-2 type-7 type-1 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testProxyUser() throws Exception {
  Configuration conf=new Configuration();
  conf.set("hadoop.security.authentication","kerberos");
  UserGroupInformation.setConfiguration(conf);
  final File testDir=getTestDir();
  conf=createBaseKMSConf(testDir);
  conf.set("hadoop.kms.authentication.type","kerberos");
  conf.set("hadoop.kms.authentication.kerberos.keytab",keytab.getAbsolutePath());
  conf.set("hadoop.kms.authentication.kerberos.principal","HTTP/localhost");
  conf.set("hadoop.kms.authentication.kerberos.name.rules","DEFAULT");
  conf.set("hadoop.kms.proxyuser.client.users","foo");
  conf.set("hadoop.kms.proxyuser.client.hosts","*");
  writeConf(testDir,conf);
  runServer(null,null,testDir,new KMSCallable(){
    @Override public Void call() throws Exception {
      final Configuration conf=new Configuration();
      conf.setInt(KeyProvider.DEFAULT_BITLENGTH_NAME,64);
      final URI uri=createKMSUri(getKMSUrl());
      UserGroupInformation clientUgi=UserGroupInformation.loginUserFromKeytabAndReturnUGI("client",keytab.getAbsolutePath());
      clientUgi.doAs(new PrivilegedExceptionAction<Void>(){
        @Override public Void run() throws Exception {
          final KeyProvider kp=new KMSClientProvider(uri,conf);
          kp.createKey("kAA",new KeyProvider.Options(conf));
          UserGroupInformation fooUgi=UserGroupInformation.createRemoteUser("foo");
          fooUgi.doAs(new PrivilegedExceptionAction<Void>(){
            @Override public Void run() throws Exception {
              Assert.assertNotNull(kp.createKey("kBB",new KeyProvider.Options(conf)));
              return null;
            }
          }
);
          UserGroupInformation foo1Ugi=UserGroupInformation.createRemoteUser("foo1");
          foo1Ugi.doAs(new PrivilegedExceptionAction<Void>(){
            @Override public Void run() throws Exception {
              try {
                kp.createKey("kCC",new KeyProvider.Options(conf));
                Assert.fail();
              }
 catch (              AuthorizationException ex) {
              }
catch (              Exception ex) {
                Assert.fail(ex.getMessage());
              }
              return null;
            }
          }
);
          return null;
        }
      }
);
      return null;
    }
  }
);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.fs.FSMainOperationsBaseTest </h4><pre class="type-9 type-2 type-7 type-10 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testOverwrite() throws IOException {
  Path path=getTestRootPath(fSys,"test/hadoop/file");
  fSys.mkdirs(path.getParent());
  createFile(path);
  Assert.assertTrue("Exists",exists(fSys,path));
  Assert.assertEquals("Length",data.length,fSys.getFileStatus(path).getLen());
  try {
    createFile(path);
    Assert.fail("Should throw IOException.");
  }
 catch (  IOException e) {
  }
  FSDataOutputStream out=fSys.create(path,true,4096);
  out.write(data,0,data.length);
  out.close();
  Assert.assertTrue("Exists",exists(fSys,path));
  Assert.assertEquals("Length",data.length,fSys.getFileStatus(path).getLen());
}

</code></pre>

<br>
<pre class="type-9 type-2 type-7 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testMkdirsFailsForSubdirectoryOfExistingFile() throws Exception {
  Path testDir=getTestRootPath(fSys,"test/hadoop");
  Assert.assertFalse(exists(fSys,testDir));
  fSys.mkdirs(testDir);
  Assert.assertTrue(exists(fSys,testDir));
  createFile(getTestRootPath(fSys,"test/hadoop/file"));
  Path testSubDir=getTestRootPath(fSys,"test/hadoop/file/subdir");
  try {
    fSys.mkdirs(testSubDir);
    Assert.fail("Should throw IOException.");
  }
 catch (  IOException e) {
  }
  Assert.assertFalse(exists(fSys,testSubDir));
  Path testDeepSubDir=getTestRootPath(fSys,"test/hadoop/file/deep/sub/dir");
  try {
    fSys.mkdirs(testDeepSubDir);
    Assert.fail("Should throw IOException.");
  }
 catch (  IOException e) {
  }
  Assert.assertFalse(exists(fSys,testDeepSubDir));
}

</code></pre>

<br>
<pre class="type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testRenameDirectoryToItself() throws Exception {
  if (!renameSupported())   return;
  Path src=getTestRootPath(fSys,"test/hadoop/dir");
  fSys.mkdirs(src);
  try {
    rename(src,src,false,true,false,Rename.NONE);
    Assert.fail("Renamed directory to itself");
  }
 catch (  IOException e) {
    Assert.assertTrue(unwrapException(e) instanceof FileAlreadyExistsException);
  }
  try {
    rename(src,src,false,true,false,Rename.OVERWRITE);
    Assert.fail("Renamed directory to itself");
  }
 catch (  IOException e) {
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testRenameFileToDestinationWithParentFile() throws Exception {
  if (!renameSupported())   return;
  Path src=getTestRootPath(fSys,"test/hadoop/file");
  createFile(src);
  Path dst=getTestRootPath(fSys,"test/parentFile/newfile");
  createFile(dst.getParent());
  try {
    rename(src,dst,false,true,false,Rename.NONE);
    Assert.fail("Expected exception was not thrown");
  }
 catch (  IOException e) {
  }
  try {
    rename(src,dst,false,true,false,Rename.OVERWRITE);
    Assert.fail("Expected exception was not thrown");
  }
 catch (  IOException e) {
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testListStatusThrowsExceptionForNonExistentFile() throws Exception {
  try {
    fSys.listStatus(getTestRootPath(fSys,"test/hadoop/file"));
    Assert.fail("Should throw FileNotFoundException");
  }
 catch (  FileNotFoundException fnfe) {
  }
}

</code></pre>

<br>
<pre class="type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testRenameDirectoryAsEmptyDirectory() throws Exception {
  if (!renameSupported())   return;
  Path src=getTestRootPath(fSys,"test/hadoop/dir");
  fSys.mkdirs(src);
  createFile(getTestRootPath(fSys,"test/hadoop/dir/file1"));
  createFile(getTestRootPath(fSys,"test/hadoop/dir/subdir/file2"));
  Path dst=getTestRootPath(fSys,"test/new/newdir");
  fSys.mkdirs(dst);
  try {
    rename(src,dst,false,true,false,Rename.NONE);
    Assert.fail("Expected exception was not thrown");
  }
 catch (  IOException e) {
    Assert.assertTrue(unwrapException(e) instanceof FileAlreadyExistsException);
  }
  rename(src,dst,true,false,true,Rename.OVERWRITE);
}

</code></pre>

<br>
<pre class="type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testRenameFileToNonExistentDirectory() throws Exception {
  if (!renameSupported())   return;
  Path src=getTestRootPath(fSys,"test/hadoop/file");
  createFile(src);
  Path dst=getTestRootPath(fSys,"test/nonExistent/newfile");
  try {
    rename(src,dst,false,true,false,Rename.NONE);
    Assert.fail("Expected exception was not thrown");
  }
 catch (  IOException e) {
    Assert.assertTrue(unwrapException(e) instanceof FileNotFoundException);
  }
  try {
    rename(src,dst,false,true,false,Rename.OVERWRITE);
    Assert.fail("Expected exception was not thrown");
  }
 catch (  IOException e) {
    Assert.assertTrue(unwrapException(e) instanceof FileNotFoundException);
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testListStatusThrowsExceptionForUnreadableDir() throws Exception {
  Path testRootDir=getTestRootPath(fSys,"test/hadoop/dir");
  Path obscuredDir=new Path(testRootDir,"foo");
  Path subDir=new Path(obscuredDir,"bar");
  fSys.mkdirs(subDir);
  fSys.setPermission(obscuredDir,new FsPermission((short)0));
  try {
    fSys.listStatus(obscuredDir);
    Assert.fail("Should throw IOException");
  }
 catch (  IOException ioe) {
  }
 finally {
    fSys.setPermission(obscuredDir,new FsPermission((short)0755));
  }
}

</code></pre>

<br>
<pre class="type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testRenameFileToItself() throws Exception {
  if (!renameSupported())   return;
  Path src=getTestRootPath(fSys,"test/hadoop/file");
  createFile(src);
  try {
    rename(src,src,false,true,false,Rename.NONE);
    Assert.fail("Renamed file to itself");
  }
 catch (  IOException e) {
    Assert.assertTrue(unwrapException(e) instanceof FileAlreadyExistsException);
  }
  try {
    rename(src,src,false,true,false,Rename.OVERWRITE);
    Assert.fail("Renamed file to itself");
  }
 catch (  IOException e) {
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testRenameDirectoryToNonExistentParent() throws Exception {
  if (!renameSupported())   return;
  Path src=getTestRootPath(fSys,"test/hadoop/dir");
  fSys.mkdirs(src);
  Path dst=getTestRootPath(fSys,"test/nonExistent/newdir");
  try {
    rename(src,dst,false,true,false,Rename.NONE);
    Assert.fail("Expected exception was not thrown");
  }
 catch (  IOException e) {
    IOException ioException=unwrapException(e);
    if (!(ioException instanceof FileNotFoundException)) {
      throw ioException;
    }
  }
  try {
    rename(src,dst,false,true,false,Rename.OVERWRITE);
    Assert.fail("Expected exception was not thrown");
  }
 catch (  IOException e) {
    IOException ioException=unwrapException(e);
    if (!(ioException instanceof FileNotFoundException)) {
      throw ioException;
    }
  }
}

</code></pre>

<br>
<pre class="type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testRenameNonExistentPath() throws Exception {
  if (!renameSupported())   return;
  Path src=getTestRootPath(fSys,"test/hadoop/nonExistent");
  Path dst=getTestRootPath(fSys,"test/new/newpath");
  try {
    rename(src,dst,false,false,false,Rename.NONE);
    Assert.fail("Should throw FileNotFoundException");
  }
 catch (  IOException e) {
    Log.info("XXX",e);
    Assert.assertTrue(unwrapException(e) instanceof FileNotFoundException);
  }
  try {
    rename(src,dst,false,false,false,Rename.OVERWRITE);
    Assert.fail("Should throw FileNotFoundException");
  }
 catch (  IOException e) {
    Assert.assertTrue(unwrapException(e) instanceof FileNotFoundException);
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testRenameDirectoryAsFile() throws Exception {
  if (!renameSupported())   return;
  Path src=getTestRootPath(fSys,"test/hadoop/dir");
  fSys.mkdirs(src);
  Path dst=getTestRootPath(fSys,"test/new/newfile");
  createFile(dst);
  try {
    rename(src,dst,false,true,true,Rename.NONE);
    Assert.fail("Expected exception was not thrown");
  }
 catch (  IOException e) {
  }
  try {
    rename(src,dst,false,true,true,Rename.OVERWRITE);
    Assert.fail("Expected exception was not thrown");
  }
 catch (  IOException ex) {
  }
}

</code></pre>

<br>
<pre class="type-9 type-2 type-7 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testDeleteRecursively() throws IOException {
  Path dir=getTestRootPath(fSys,"test/hadoop");
  Path file=getTestRootPath(fSys,"test/hadoop/file");
  Path subdir=getTestRootPath(fSys,"test/hadoop/subdir");
  createFile(file);
  fSys.mkdirs(subdir);
  Assert.assertTrue("File exists",exists(fSys,file));
  Assert.assertTrue("Dir exists",exists(fSys,dir));
  Assert.assertTrue("Subdir exists",exists(fSys,subdir));
  try {
    fSys.delete(dir,false);
    Assert.fail("Should throw IOException.");
  }
 catch (  IOException e) {
  }
  Assert.assertTrue("File still exists",exists(fSys,file));
  Assert.assertTrue("Dir still exists",exists(fSys,dir));
  Assert.assertTrue("Subdir still exists",exists(fSys,subdir));
  Assert.assertTrue("Deleted",fSys.delete(dir,true));
  Assert.assertFalse("File doesn't exist",exists(fSys,file));
  Assert.assertFalse("Dir doesn't exist",exists(fSys,dir));
  Assert.assertFalse("Subdir doesn't exist",exists(fSys,subdir));
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testRenameFileAsExistingDirectory() throws Exception {
  if (!renameSupported())   return;
  Path src=getTestRootPath(fSys,"test/hadoop/file");
  createFile(src);
  Path dst=getTestRootPath(fSys,"test/new/existingDir");
  fSys.mkdirs(dst);
  try {
    rename(src,dst,false,false,true,Rename.NONE);
    Assert.fail("Expected exception was not thrown");
  }
 catch (  IOException e) {
  }
  try {
    rename(src,dst,false,false,true,Rename.OVERWRITE);
    Assert.fail("Expected exception was not thrown");
  }
 catch (  IOException e) {
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testGetFileStatusThrowsExceptionForNonExistentFile() throws Exception {
  try {
    fSys.getFileStatus(getTestRootPath(fSys,"test/hadoop/file"));
    Assert.fail("Should throw FileNotFoundException");
  }
 catch (  FileNotFoundException e) {
  }
}

</code></pre>

<br>
<pre class="type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testRenameDirectoryAsNonEmptyDirectory() throws Exception {
  if (!renameSupported())   return;
  Path src=getTestRootPath(fSys,"test/hadoop/dir");
  fSys.mkdirs(src);
  createFile(getTestRootPath(fSys,"test/hadoop/dir/file1"));
  createFile(getTestRootPath(fSys,"test/hadoop/dir/subdir/file2"));
  Path dst=getTestRootPath(fSys,"test/new/newdir");
  fSys.mkdirs(dst);
  createFile(getTestRootPath(fSys,"test/new/newdir/file1"));
  try {
    rename(src,dst,false,true,false,Rename.NONE);
    Assert.fail("Expected exception was not thrown");
  }
 catch (  IOException e) {
    Assert.assertTrue(unwrapException(e) instanceof FileAlreadyExistsException);
  }
  try {
    rename(src,dst,false,true,false,Rename.OVERWRITE);
    Assert.fail("Expected exception was not thrown");
  }
 catch (  IOException ex) {
  }
}

</code></pre>

<br>
<pre class="type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testRenameFileAsExistingFile() throws Exception {
  if (!renameSupported())   return;
  Path src=getTestRootPath(fSys,"test/hadoop/file");
  createFile(src);
  Path dst=getTestRootPath(fSys,"test/new/existingFile");
  createFile(dst);
  try {
    rename(src,dst,false,true,false,Rename.NONE);
    Assert.fail("Expected exception was not thrown");
  }
 catch (  IOException e) {
    Assert.assertTrue(unwrapException(e) instanceof FileAlreadyExistsException);
  }
  rename(src,dst,true,false,true,Rename.OVERWRITE);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.fs.FileContextCreateMkdirBaseTest </h4><pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testMkdirNonRecursiveWithNonExistingDir(){
  try {
    fc.mkdir(getTestRootPath(fc,"NonExistant/aDir"),FileContext.DEFAULT_PERM,false);
    Assert.fail("Mkdir with non existing parent dir should have failed");
  }
 catch (  IOException e) {
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testCreateNonRecursiveWithNonExistingDir(){
  try {
    createFileNonRecursive(fc,getTestRootPath(fc,"NonExisting/foo"));
    Assert.fail("Create with non existing parent dir should have failed");
  }
 catch (  IOException e) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.fs.FileContextMainOperationsBaseTest </h4><pre class="type-2 type-14 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies that exceptions are thrown during the test case execution">ExceptionVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies that exceptions are thrown during the test case execution
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(expected=FileAlreadyExistsException.class) public void testCreateFlagCreateExistingFile() throws IOException {
  Path p=getTestRootPath(fc,"test/testCreateFlagCreateExistingFile");
  createFile(p);
  fc.create(p,EnumSet.of(CREATE));
  Assert.fail("Excepted exception not thrown");
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testGetFileStatusThrowsExceptionForNonExistentFile() throws Exception {
  try {
    fc.getFileStatus(getTestRootPath(fc,"test/hadoop/file"));
    Assert.fail("Should throw FileNotFoundException");
  }
 catch (  FileNotFoundException e) {
  }
}

</code></pre>

<br>
<pre class="type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testRenameNonExistentPath() throws Exception {
  if (!renameSupported())   return;
  Path src=getTestRootPath(fc,"test/hadoop/nonExistent");
  Path dst=getTestRootPath(fc,"test/new/newpath");
  try {
    rename(src,dst,false,false,false,Rename.NONE);
    Assert.fail("Should throw FileNotFoundException");
  }
 catch (  IOException e) {
    Assert.assertTrue(unwrapException(e) instanceof FileNotFoundException);
  }
  try {
    rename(src,dst,false,false,false,Rename.OVERWRITE);
    Assert.fail("Should throw FileNotFoundException");
  }
 catch (  IOException e) {
    Assert.assertTrue(unwrapException(e) instanceof FileNotFoundException);
  }
}

</code></pre>

<br>
<pre class="type-2 type-14 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies that exceptions are thrown during the test case execution">ExceptionVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies that exceptions are thrown during the test case execution
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(expected=HadoopIllegalArgumentException.class) public void testEmptyCreateFlag() throws IOException {
  Path p=getTestRootPath(fc,"test/file");
  fc.create(p,EnumSet.noneOf(CreateFlag.class));
  Assert.fail("Excepted exception not thrown");
}

</code></pre>

<br>
<pre class="type-2 type-14 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies that exceptions are thrown during the test case execution">ExceptionVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies that exceptions are thrown during the test case execution
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(expected=HadoopIllegalArgumentException.class) public void testCreateFlagAppendOverwrite() throws IOException {
  Path p=getTestRootPath(fc,"test/nonExistent");
  fc.create(p,EnumSet.of(APPEND,OVERWRITE));
  Assert.fail("Excepted exception not thrown");
}

</code></pre>

<br>
<pre class="type-2 type-14 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies that exceptions are thrown during the test case execution">ExceptionVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies that exceptions are thrown during the test case execution
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(expected=HadoopIllegalArgumentException.class) public void testCreateFlagAppendCreateOverwrite() throws IOException {
  Path p=getTestRootPath(fc,"test/nonExistent");
  fc.create(p,EnumSet.of(CREATE,APPEND,OVERWRITE));
  Assert.fail("Excepted exception not thrown");
}

</code></pre>

<br>
<pre class="type-9 type-11 type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testUnsupportedSymlink() throws IOException {
  Path file=getTestRootPath(fc,"file");
  Path link=getTestRootPath(fc,"linkToFile");
  if (!fc.getDefaultFileSystem().supportsSymlinks()) {
    try {
      fc.createSymlink(file,link,false);
      Assert.fail("Created a symlink on a file system that " + "does not support symlinks.");
    }
 catch (    IOException e) {
    }
    createFile(file);
    try {
      fc.getLinkTarget(file);
      Assert.fail("Got a link target on a file system that " + "does not support symlinks.");
    }
 catch (    IOException e) {
    }
    Assert.assertEquals(fc.getFileStatus(file),fc.getFileLinkStatus(file));
  }
}

</code></pre>

<br>
<pre class="type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testRenameFileToNonExistentDirectory() throws Exception {
  if (!renameSupported())   return;
  Path src=getTestRootPath(fc,"test/hadoop/file");
  createFile(src);
  Path dst=getTestRootPath(fc,"test/nonExistent/newfile");
  try {
    rename(src,dst,false,true,false,Rename.NONE);
    Assert.fail("Expected exception was not thrown");
  }
 catch (  IOException e) {
    Assert.assertTrue(unwrapException(e) instanceof FileNotFoundException);
  }
  try {
    rename(src,dst,false,true,false,Rename.OVERWRITE);
    Assert.fail("Expected exception was not thrown");
  }
 catch (  IOException e) {
    Assert.assertTrue(unwrapException(e) instanceof FileNotFoundException);
  }
}

</code></pre>

<br>
<pre class="type-9 type-2 type-7 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testDeleteRecursively() throws IOException {
  Path dir=getTestRootPath(fc,"test/hadoop");
  Path file=getTestRootPath(fc,"test/hadoop/file");
  Path subdir=getTestRootPath(fc,"test/hadoop/subdir");
  createFile(file);
  fc.mkdir(subdir,FsPermission.getDefault(),true);
  Assert.assertTrue("File exists",exists(fc,file));
  Assert.assertTrue("Dir exists",exists(fc,dir));
  Assert.assertTrue("Subdir exists",exists(fc,subdir));
  try {
    fc.delete(dir,false);
    Assert.fail("Should throw IOException.");
  }
 catch (  IOException e) {
  }
  Assert.assertTrue("File still exists",exists(fc,file));
  Assert.assertTrue("Dir still exists",exists(fc,dir));
  Assert.assertTrue("Subdir still exists",exists(fc,subdir));
  Assert.assertTrue("Deleted",fc.delete(dir,true));
  Assert.assertFalse("File doesn't exist",exists(fc,file));
  Assert.assertFalse("Dir doesn't exist",exists(fc,dir));
  Assert.assertFalse("Subdir doesn't exist",exists(fc,subdir));
}

</code></pre>

<br>
<pre class="type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testRenameDirectoryAsNonEmptyDirectory() throws Exception {
  if (!renameSupported())   return;
  Path src=getTestRootPath(fc,"test/hadoop/dir");
  fc.mkdir(src,FileContext.DEFAULT_PERM,true);
  createFile(getTestRootPath(fc,"test/hadoop/dir/file1"));
  createFile(getTestRootPath(fc,"test/hadoop/dir/subdir/file2"));
  Path dst=getTestRootPath(fc,"test/new/newdir");
  fc.mkdir(dst,FileContext.DEFAULT_PERM,true);
  createFile(getTestRootPath(fc,"test/new/newdir/file1"));
  try {
    rename(src,dst,false,true,false,Rename.NONE);
    Assert.fail("Expected exception was not thrown");
  }
 catch (  IOException e) {
    Assert.assertTrue(unwrapException(e) instanceof FileAlreadyExistsException);
  }
  try {
    rename(src,dst,false,true,false,Rename.OVERWRITE);
    Assert.fail("Expected exception was not thrown");
  }
 catch (  IOException ex) {
  }
}

</code></pre>

<br>
<pre class="type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testRenameDirectoryAsEmptyDirectory() throws Exception {
  if (!renameSupported())   return;
  Path src=getTestRootPath(fc,"test/hadoop/dir");
  fc.mkdir(src,FileContext.DEFAULT_PERM,true);
  createFile(getTestRootPath(fc,"test/hadoop/dir/file1"));
  createFile(getTestRootPath(fc,"test/hadoop/dir/subdir/file2"));
  Path dst=getTestRootPath(fc,"test/new/newdir");
  fc.mkdir(dst,FileContext.DEFAULT_PERM,true);
  try {
    rename(src,dst,false,true,false,Rename.NONE);
    Assert.fail("Expected exception was not thrown");
  }
 catch (  IOException e) {
    Assert.assertTrue(unwrapException(e) instanceof FileAlreadyExistsException);
  }
  rename(src,dst,true,false,true,Rename.OVERWRITE);
}

</code></pre>

<br>
<pre class="type-2 type-14 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies that exceptions are thrown during the test case execution">ExceptionVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies that exceptions are thrown during the test case execution
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(expected=FileNotFoundException.class) public void testCreateFlagAppendNonExistingFile() throws IOException {
  Path p=getTestRootPath(fc,"test/testCreateFlagAppendNonExistingFile");
  fc.create(p,EnumSet.of(APPEND));
  Assert.fail("Excepted exception not thrown");
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testRenameDirectoryAsFile() throws Exception {
  if (!renameSupported())   return;
  Path src=getTestRootPath(fc,"test/hadoop/dir");
  fc.mkdir(src,FileContext.DEFAULT_PERM,true);
  Path dst=getTestRootPath(fc,"test/new/newfile");
  createFile(dst);
  try {
    rename(src,dst,false,true,true,Rename.NONE);
    Assert.fail("Expected exception was not thrown");
  }
 catch (  IOException e) {
  }
  try {
    rename(src,dst,false,true,true,Rename.OVERWRITE);
    Assert.fail("Expected exception was not thrown");
  }
 catch (  IOException ex) {
  }
}

</code></pre>

<br>
<pre class="type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testRenameDirectoryToItself() throws Exception {
  if (!renameSupported())   return;
  Path src=getTestRootPath(fc,"test/hadoop/dir");
  fc.mkdir(src,FileContext.DEFAULT_PERM,true);
  try {
    rename(src,src,false,true,false,Rename.NONE);
    Assert.fail("Renamed directory to itself");
  }
 catch (  IOException e) {
    Assert.assertTrue(unwrapException(e) instanceof FileAlreadyExistsException);
  }
  try {
    rename(src,src,false,true,false,Rename.OVERWRITE);
    Assert.fail("Renamed directory to itself");
  }
 catch (  IOException e) {
    Assert.assertTrue(unwrapException(e) instanceof FileAlreadyExistsException);
  }
}

</code></pre>

<br>
<pre class="type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testRenameDirectoryToNonExistentParent() throws Exception {
  if (!renameSupported())   return;
  Path src=getTestRootPath(fc,"test/hadoop/dir");
  fc.mkdir(src,FileContext.DEFAULT_PERM,true);
  Path dst=getTestRootPath(fc,"test/nonExistent/newdir");
  try {
    rename(src,dst,false,true,false,Rename.NONE);
    Assert.fail("Expected exception was not thrown");
  }
 catch (  IOException e) {
    Assert.assertTrue(unwrapException(e) instanceof FileNotFoundException);
  }
  try {
    rename(src,dst,false,true,false,Rename.OVERWRITE);
    Assert.fail("Expected exception was not thrown");
  }
 catch (  IOException e) {
    Assert.assertTrue(unwrapException(e) instanceof FileNotFoundException);
  }
}

</code></pre>

<br>
<pre class="type-2 type-14 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies that exceptions are thrown during the test case execution">ExceptionVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies that exceptions are thrown during the test case execution
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(expected=FileNotFoundException.class) public void testCreateFlagOverwriteNonExistingFile() throws IOException {
  Path p=getTestRootPath(fc,"test/testCreateFlagOverwriteNonExistingFile");
  fc.create(p,EnumSet.of(OVERWRITE));
  Assert.fail("Excepted exception not thrown");
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testRenameFileAsExistingDirectory() throws Exception {
  if (!renameSupported())   return;
  Path src=getTestRootPath(fc,"test/hadoop/file");
  createFile(src);
  Path dst=getTestRootPath(fc,"test/new/existingDir");
  fc.mkdir(dst,FileContext.DEFAULT_PERM,true);
  try {
    rename(src,dst,false,false,true,Rename.NONE);
    Assert.fail("Expected exception was not thrown");
  }
 catch (  IOException e) {
  }
  try {
    rename(src,dst,false,false,true,Rename.OVERWRITE);
    Assert.fail("Expected exception was not thrown");
  }
 catch (  IOException e) {
  }
}

</code></pre>

<br>
<pre class="type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testRenameFileToItself() throws Exception {
  if (!renameSupported())   return;
  Path src=getTestRootPath(fc,"test/hadoop/file");
  createFile(src);
  try {
    rename(src,src,false,true,false,Rename.NONE);
    Assert.fail("Renamed file to itself");
  }
 catch (  IOException e) {
    Assert.assertTrue(unwrapException(e) instanceof FileAlreadyExistsException);
  }
  try {
    rename(src,src,false,true,false,Rename.OVERWRITE);
    Assert.fail("Renamed file to itself");
  }
 catch (  IOException e) {
    Assert.assertTrue(unwrapException(e) instanceof FileAlreadyExistsException);
  }
}

</code></pre>

<br>
<pre class="type-9 type-2 type-7 type-10 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testWorkingDirectory() throws Exception {
  Path workDir=new Path(fileContextTestHelper.getAbsoluteTestRootPath(fc),new Path("test"));
  fc.setWorkingDirectory(workDir);
  Assert.assertEquals(workDir,fc.getWorkingDirectory());
  fc.setWorkingDirectory(new Path("."));
  Assert.assertEquals(workDir,fc.getWorkingDirectory());
  fc.setWorkingDirectory(new Path(".."));
  Assert.assertEquals(workDir.getParent(),fc.getWorkingDirectory());
  workDir=new Path(fileContextTestHelper.getAbsoluteTestRootPath(fc),new Path("test"));
  fc.setWorkingDirectory(workDir);
  Assert.assertEquals(workDir,fc.getWorkingDirectory());
  Path relativeDir=new Path("existingDir1");
  Path absoluteDir=new Path(workDir,"existingDir1");
  fc.mkdir(absoluteDir,FileContext.DEFAULT_PERM,true);
  fc.setWorkingDirectory(relativeDir);
  Assert.assertEquals(absoluteDir,fc.getWorkingDirectory());
  absoluteDir=getTestRootPath(fc,"test/existingDir2");
  fc.mkdir(absoluteDir,FileContext.DEFAULT_PERM,true);
  fc.setWorkingDirectory(absoluteDir);
  Assert.assertEquals(absoluteDir,fc.getWorkingDirectory());
  Path absolutePath=new Path(absoluteDir,"foo");
  fc.create(absolutePath,EnumSet.of(CREATE)).close();
  fc.open(new Path("foo")).close();
  fc.mkdir(new Path("newDir"),FileContext.DEFAULT_PERM,true);
  Assert.assertTrue(isDir(fc,new Path(absoluteDir,"newDir")));
  absoluteDir=getTestRootPath(fc,"nonexistingPath");
  try {
    fc.setWorkingDirectory(absoluteDir);
    Assert.fail("cd to non existing dir should have failed");
  }
 catch (  Exception e) {
  }
  absoluteDir=new Path(localFsRootPath,"existingDir");
  fc.mkdir(absoluteDir,FileContext.DEFAULT_PERM,true);
  fc.setWorkingDirectory(absoluteDir);
  Assert.assertEquals(absoluteDir,fc.getWorkingDirectory());
  Path aRegularFile=new Path("aRegularFile");
  createFile(aRegularFile);
  try {
    fc.setWorkingDirectory(aRegularFile);
    fail("An IOException expected.");
  }
 catch (  IOException ioe) {
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testRenameFileToDestinationWithParentFile() throws Exception {
  if (!renameSupported())   return;
  Path src=getTestRootPath(fc,"test/hadoop/file");
  createFile(src);
  Path dst=getTestRootPath(fc,"test/parentFile/newfile");
  createFile(dst.getParent());
  try {
    rename(src,dst,false,true,false,Rename.NONE);
    Assert.fail("Expected exception was not thrown");
  }
 catch (  IOException e) {
  }
  try {
    rename(src,dst,false,true,false,Rename.OVERWRITE);
    Assert.fail("Expected exception was not thrown");
  }
 catch (  IOException e) {
  }
}

</code></pre>

<br>
<pre class="type-9 type-2 type-7 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testMkdirsFailsForSubdirectoryOfExistingFile() throws Exception {
  Path testDir=getTestRootPath(fc,"test/hadoop");
  Assert.assertFalse(exists(fc,testDir));
  fc.mkdir(testDir,FsPermission.getDefault(),true);
  Assert.assertTrue(exists(fc,testDir));
  createFile(getTestRootPath(fc,"test/hadoop/file"));
  Path testSubDir=getTestRootPath(fc,"test/hadoop/file/subdir");
  try {
    fc.mkdir(testSubDir,FsPermission.getDefault(),true);
    Assert.fail("Should throw IOException.");
  }
 catch (  IOException e) {
  }
  Assert.assertFalse(exists(fc,testSubDir));
  Path testDeepSubDir=getTestRootPath(fc,"test/hadoop/file/deep/sub/dir");
  try {
    fc.mkdir(testDeepSubDir,FsPermission.getDefault(),true);
    Assert.fail("Should throw IOException.");
  }
 catch (  IOException e) {
  }
  Assert.assertFalse(exists(fc,testDeepSubDir));
}

</code></pre>

<br>
<pre class="type-9 type-11 type-2 type-7 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testListCorruptFileBlocks() throws IOException {
  final Path rootPath=getTestRootPath(fc,"test");
  final Path path=new Path(rootPath,"zoo");
  createFile(path);
  try {
    final RemoteIterator<Path> remoteIterator=fc.listCorruptFileBlocks(path);
    if (listCorruptedBlocksSupported()) {
      assertTrue(remoteIterator != null);
      Path p;
      while (remoteIterator.hasNext()) {
        p=remoteIterator.next();
        System.out.println("corrupted block: " + p);
      }
      try {
        remoteIterator.next();
        fail();
      }
 catch (      NoSuchElementException nsee) {
      }
    }
 else {
      fail();
    }
  }
 catch (  UnsupportedOperationException uoe) {
    if (listCorruptedBlocksSupported()) {
      fail(uoe.toString());
    }
 else {
    }
  }
}

</code></pre>

<br>
<pre class="type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testRenameFileAsExistingFile() throws Exception {
  if (!renameSupported())   return;
  Path src=getTestRootPath(fc,"test/hadoop/file");
  createFile(src);
  Path dst=getTestRootPath(fc,"test/new/existingFile");
  createFile(dst);
  try {
    rename(src,dst,false,true,false,Rename.NONE);
    Assert.fail("Expected exception was not thrown");
  }
 catch (  IOException e) {
    Assert.assertTrue(unwrapException(e) instanceof FileAlreadyExistsException);
  }
  rename(src,dst,true,false,true,Rename.OVERWRITE);
}

</code></pre>

<br>
<pre class="type-2 type-14 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies that exceptions are thrown during the test case execution">ExceptionVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies that exceptions are thrown during the test case execution
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(expected=HadoopIllegalArgumentException.class) public void testNullCreateFlag() throws IOException {
  Path p=getTestRootPath(fc,"test/file");
  fc.create(p,null);
  Assert.fail("Excepted exception not thrown");
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.fs.FileContextPermissionBase </h4><pre class="type-9 type-11 type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testSetOwner() throws IOException {
  if (Path.WINDOWS) {
    System.out.println("Cannot run test for Windows");
    return;
  }
  String filename="bar";
  Path f=fileContextTestHelper.getTestRootPath(fc,filename);
  createFile(fc,f);
  List<String> groups=null;
  try {
    groups=getGroups();
    System.out.println(filename + ": " + fc.getFileStatus(f).getPermission());
  }
 catch (  IOException e) {
    System.out.println(StringUtils.stringifyException(e));
    System.out.println("Cannot run test");
    return;
  }
  if (groups == null || groups.size() < 1) {
    System.out.println("Cannot run test: need at least one group.  groups=" + groups);
    return;
  }
  try {
    String g0=groups.get(0);
    fc.setOwner(f,null,g0);
    Assert.assertEquals(g0,fc.getFileStatus(f).getGroup());
    if (groups.size() > 1) {
      String g1=groups.get(1);
      fc.setOwner(f,null,g1);
      Assert.assertEquals(g1,fc.getFileStatus(f).getGroup());
    }
 else {
      System.out.println("Not testing changing the group since user " + "belongs to only one group.");
    }
    try {
      fc.setOwner(f,null,null);
      fail("Exception expected.");
    }
 catch (    IllegalArgumentException iae) {
    }
  }
  finally {
    cleanupFile(fc,f);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.fs.FileContextURIBase </h4><pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testListStatusThrowsExceptionForNonExistentFile() throws Exception {
  String testFile="test/hadoop/file";
  Path testPath=qualifiedPath(testFile,fc2);
  try {
    fc1.listStatus(testPath);
    Assert.fail("Should throw FileNotFoundException");
  }
 catch (  FileNotFoundException fnfe) {
  }
}

</code></pre>

<br>
<pre class="type-9 type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testCreateFileWithNullName() throws IOException {
  String fileName=null;
  try {
    Path testPath=qualifiedPath(fileName,fc2);
    Assert.assertFalse(exists(fc2,testPath));
    createFile(fc1,testPath);
    Assert.fail("Create file with null name should throw IllegalArgumentException.");
  }
 catch (  IllegalArgumentException e) {
  }
}

</code></pre>

<br>
<pre class="type-9 type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testCreateExistingFile() throws IOException {
  String fileName="testFile";
  Path testPath=qualifiedPath(fileName,fc2);
  Assert.assertFalse(exists(fc2,testPath));
  createFile(fc1,testPath);
  try {
    createFile(fc2,testPath);
    Assert.fail("Create existing file should throw an IOException.");
  }
 catch (  IOException e) {
  }
  Assert.assertTrue(exists(fc2,testPath));
}

</code></pre>

<br>
<pre class="type-9 type-2 type-7 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testMkdirsFailsForSubdirectoryOfExistingFile() throws Exception {
  Path testDir=qualifiedPath("test/hadoop",fc2);
  Assert.assertFalse(exists(fc2,testDir));
  fc2.mkdir(testDir,FsPermission.getDefault(),true);
  Assert.assertTrue(exists(fc2,testDir));
  createFile(fc1,qualifiedPath("test/hadoop/file",fc2));
  Path testSubDir=qualifiedPath("test/hadoop/file/subdir",fc2);
  try {
    fc1.mkdir(testSubDir,FsPermission.getDefault(),true);
    Assert.fail("Should throw IOException.");
  }
 catch (  IOException e) {
  }
  Assert.assertFalse(exists(fc1,testSubDir));
  Path testDeepSubDir=qualifiedPath("test/hadoop/file/deep/sub/dir",fc1);
  try {
    fc2.mkdir(testDeepSubDir,FsPermission.getDefault(),true);
    Assert.fail("Should throw IOException.");
  }
 catch (  IOException e) {
  }
  Assert.assertFalse(exists(fc1,testDeepSubDir));
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testGetFileStatusThrowsExceptionForNonExistentFile() throws Exception {
  String testFile="test/hadoop/fileDoesNotExist";
  Path testPath=qualifiedPath(testFile,fc2);
  try {
    fc1.getFileStatus(testPath);
    Assert.fail("Should throw FileNotFoundException");
  }
 catch (  FileNotFoundException e) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.fs.SymlinkBaseTest </h4><pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test(timeout=10000) public void testCreateFileViaDanglingLinkParent() throws IOException {
  Path dir=new Path(testBaseDir1() + "/dangling");
  Path file=new Path(testBaseDir1() + "/dangling/file");
  wrapper.createSymlink(new Path("/doesNotExist"),dir,false);
  FSDataOutputStream out;
  try {
    out=wrapper.create(file,EnumSet.of(CreateFlag.CREATE),CreateOpts.repFac((short)1),CreateOpts.blockSize(blockSize));
    out.close();
    fail("Created a link with dangling link parent");
  }
 catch (  FileNotFoundException e) {
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=10000) public void testRenameDirToSymlinkToFile() throws IOException {
  Path dir1=new Path(testBaseDir1());
  Path file=new Path(testBaseDir2(),"file");
  Path linkToFile=new Path(testBaseDir2(),"linkToFile");
  createAndWriteFile(file);
  wrapper.createSymlink(file,linkToFile,false);
  try {
    wrapper.rename(dir1,linkToFile,Rename.OVERWRITE);
    fail("Renamed directory to a symlink");
  }
 catch (  IOException e) {
    assertTrue(unwrapException(e) instanceof IOException);
  }
  assertTrue(wrapper.exists(dir1));
  assertTrue(wrapper.exists(linkToFile));
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test(timeout=10000) public void testStatNonExistentFiles() throws IOException {
  Path fileAbs=new Path("/doesNotExist");
  try {
    wrapper.getFileLinkStatus(fileAbs);
    fail("Got FileStatus for non-existant file");
  }
 catch (  FileNotFoundException f) {
  }
  try {
    wrapper.getLinkTarget(fileAbs);
    fail("Got link target for non-existant file");
  }
 catch (  FileNotFoundException f) {
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test(timeout=10000) public void testCreateLinkToDot() throws IOException {
  Path dir=new Path(testBaseDir1());
  Path file=new Path(testBaseDir1(),"file");
  Path link=new Path(testBaseDir1(),"linkToDot");
  createAndWriteFile(file);
  wrapper.setWorkingDirectory(dir);
  try {
    wrapper.createSymlink(new Path("."),link,false);
    fail("Created symlink to dot");
  }
 catch (  IOException x) {
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-10 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=10000) public void testRenameSymlinkToDirItLinksTo() throws IOException {
  if ("file".equals(getScheme())) {
    return;
  }
  Path dir=new Path(testBaseDir1(),"dir");
  Path link=new Path(testBaseDir1(),"linkToDir");
  wrapper.mkdir(dir,FileContext.DEFAULT_PERM,false);
  wrapper.createSymlink(dir,link,false);
  try {
    wrapper.rename(link,dir);
    fail("Renamed symlink to its target");
  }
 catch (  IOException e) {
    assertTrue(unwrapException(e) instanceof FileAlreadyExistsException);
  }
  assertTrue(wrapper.isDir(dir));
  assertTrue(wrapper.exists(link));
  assertTrue(wrapper.isSymlink(link));
  assertEquals(dir,wrapper.getLinkTarget(link));
  try {
    wrapper.rename(link,dir,Rename.OVERWRITE);
    fail("Renamed symlink to its target");
  }
 catch (  IOException e) {
    assertTrue(unwrapException(e) instanceof FileAlreadyExistsException);
  }
  assertTrue(wrapper.isDir(dir));
  assertTrue(wrapper.exists(link));
  assertTrue(wrapper.isSymlink(link));
  assertEquals(dir,wrapper.getLinkTarget(link));
}

</code></pre>

<br>
<pre class="type-2 type-7 type-10 type-15 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Sets implicit assumptions ">AssumptionSetter</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Sets implicit assumptions 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=10000) public void testRenameSymlink() throws IOException {
  assumeTrue(!emulatingSymlinksOnWindows());
  Path file=new Path(testBaseDir1(),"file");
  Path link1=new Path(testBaseDir1(),"linkToFile1");
  Path link2=new Path(testBaseDir1(),"linkToFile2");
  createAndWriteFile(file);
  wrapper.createSymlink(file,link1,false);
  wrapper.rename(link1,link2);
  assertTrue(wrapper.getFileLinkStatus(link2).isSymlink());
  assertFalse(wrapper.getFileStatus(link2).isDirectory());
  readFile(link2);
  readFile(file);
  try {
    createAndWriteFile(link2);
    fail("link was not renamed");
  }
 catch (  IOException x) {
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=10000) public void testRenameDirToDanglingSymlink() throws IOException {
  Path dir=new Path(testBaseDir1());
  Path link=new Path(testBaseDir2(),"linkToFile");
  wrapper.createSymlink(new Path("/doesNotExist"),link,false);
  try {
    wrapper.rename(dir,link,Rename.OVERWRITE);
    fail("Renamed directory to a symlink");
  }
 catch (  IOException e) {
    assertTrue(unwrapException(e) instanceof IOException);
  }
  assertTrue(wrapper.exists(dir));
  assertTrue(wrapper.getFileLinkStatus(link) != null);
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test(timeout=10000) public void testDeleteLink() throws IOException {
  Path file=new Path(testBaseDir1() + "/file");
  Path link=new Path(testBaseDir1() + "/linkToFile");
  createAndWriteFile(file);
  wrapper.createSymlink(file,link,false);
  readFile(link);
  wrapper.delete(link,false);
  try {
    readFile(link);
    fail("Symlink should have been deleted");
  }
 catch (  IOException x) {
  }
  wrapper.createSymlink(file,link,false);
}

</code></pre>

<br>
<pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=10000) public void testCreateLinkUsingFullyQualPaths() throws IOException {
  Path fileAbs=new Path(testBaseDir1(),"file");
  Path linkAbs=new Path(testBaseDir1(),"linkToFile");
  Path fileQual=new Path(testURI().toString(),fileAbs);
  Path linkQual=new Path(testURI().toString(),linkAbs);
  createAndWriteFile(fileAbs);
  wrapper.createSymlink(fileQual,linkQual,false);
  checkLink(linkAbs,"file".equals(getScheme()) ? fileAbs : fileQual,fileQual);
  Path dir1=new Path(testBaseDir1());
  Path dir2=new Path(testBaseDir2());
  Path linkViaDir2=new Path(testBaseDir2(),"linkToFile");
  wrapper.rename(dir1,dir2,Rename.OVERWRITE);
  assertEquals(fileQual,wrapper.getFileLinkStatus(linkViaDir2).getSymlink());
  try {
    readFile(linkViaDir2);
    fail("The target should not exist");
  }
 catch (  FileNotFoundException x) {
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=10000) public void testCreateLinkCanCreateParent() throws IOException {
  Path file=new Path(testBaseDir1() + "/file");
  Path link=new Path(testBaseDir2() + "/linkToFile");
  createAndWriteFile(file);
  wrapper.delete(new Path(testBaseDir2()),true);
  try {
    wrapper.createSymlink(file,link,false);
    fail("Created link without first creating parent dir");
  }
 catch (  IOException x) {
  }
  assertFalse(wrapper.exists(new Path(testBaseDir2())));
  wrapper.createSymlink(file,link,true);
  readFile(link);
}

</code></pre>

<br>
<pre class="type-2 type-15 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Sets implicit assumptions ">AssumptionSetter</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Sets implicit assumptions 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=10000) public void testCreateLinkTwice() throws IOException {
  assumeTrue(!emulatingSymlinksOnWindows());
  Path file=new Path(testBaseDir1(),"file");
  Path link=new Path(testBaseDir1(),"linkToFile");
  createAndWriteFile(file);
  wrapper.createSymlink(file,link,false);
  try {
    wrapper.createSymlink(file,link,false);
    fail("link already exists");
  }
 catch (  IOException x) {
  }
}

</code></pre>

<br>
<pre class="type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=10000) public void testRecursiveLinks() throws IOException {
  Path link1=new Path(testBaseDir1() + "/link1");
  Path link2=new Path(testBaseDir1() + "/link2");
  wrapper.createSymlink(link1,link2,false);
  wrapper.createSymlink(link2,link1,false);
  try {
    readFile(link1);
    fail("Read recursive link");
  }
 catch (  FileNotFoundException f) {
  }
catch (  IOException x) {
    assertEquals("Possible cyclic loop while following symbolic link " + link1.toString(),x.getMessage());
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-10 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=10000) public void testRenameSymlinkToFileItLinksTo() throws IOException {
  if ("file".equals(getScheme())) {
    return;
  }
  Path file=new Path(testBaseDir1(),"file");
  Path link=new Path(testBaseDir1(),"linkToFile");
  createAndWriteFile(file);
  wrapper.createSymlink(file,link,false);
  try {
    wrapper.rename(link,file);
    fail("Renamed symlink to its target");
  }
 catch (  IOException e) {
    assertTrue(unwrapException(e) instanceof FileAlreadyExistsException);
  }
  assertTrue(wrapper.isFile(file));
  assertTrue(wrapper.exists(link));
  assertTrue(wrapper.isSymlink(link));
  assertEquals(file,wrapper.getLinkTarget(link));
  try {
    wrapper.rename(link,file,Rename.OVERWRITE);
    fail("Renamed symlink to its target");
  }
 catch (  IOException e) {
    assertTrue(unwrapException(e) instanceof FileAlreadyExistsException);
  }
  assertTrue(wrapper.isFile(file));
  assertTrue(wrapper.exists(link));
  assertTrue(wrapper.isSymlink(link));
  assertEquals(file,wrapper.getLinkTarget(link));
}

</code></pre>

<br>
<pre class="type-2 type-7 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=10000) public void testRenameFileToSymlinkToFile() throws IOException {
  Path file1=new Path(testBaseDir1(),"file1");
  Path file2=new Path(testBaseDir1(),"file2");
  Path link=new Path(testBaseDir1(),"linkToFile");
  createAndWriteFile(file1);
  createAndWriteFile(file2);
  wrapper.createSymlink(file2,link,false);
  try {
    wrapper.rename(file1,link);
    fail("Renamed file to symlink w/o overwrite");
  }
 catch (  IOException e) {
    assertTrue(unwrapException(e) instanceof FileAlreadyExistsException);
  }
  wrapper.rename(file1,link,Rename.OVERWRITE);
  assertFalse(wrapper.exists(file1));
  assertTrue(wrapper.exists(link));
  assertTrue(wrapper.isFile(link));
  assertFalse(wrapper.getFileLinkStatus(link).isSymlink());
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test(timeout=10000) public void testUseLinkAferDeleteLink() throws IOException {
  Path file=new Path(testBaseDir1(),"file");
  Path link=new Path(testBaseDir1(),"linkToFile");
  createAndWriteFile(file);
  wrapper.createSymlink(file,link,false);
  wrapper.delete(link,false);
  try {
    readFile(link);
    fail("link was deleted");
  }
 catch (  IOException x) {
  }
  readFile(file);
  wrapper.createSymlink(file,link,false);
  readFile(link);
}

</code></pre>

<br>
<pre class="type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=10000) public void testRenameSymlinkToItself() throws IOException {
  Path file=new Path(testBaseDir1(),"file");
  createAndWriteFile(file);
  Path link=new Path(testBaseDir1(),"linkToFile1");
  wrapper.createSymlink(file,link,false);
  try {
    wrapper.rename(link,link);
    fail("Failed to get expected IOException");
  }
 catch (  IOException e) {
    assertTrue(unwrapException(e) instanceof FileAlreadyExistsException);
  }
  try {
    wrapper.rename(link,link,Rename.OVERWRITE);
    fail("Failed to get expected IOException");
  }
 catch (  IOException e) {
    assertTrue(unwrapException(e) instanceof FileAlreadyExistsException);
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=10000) public void testRenameDirToSymlinkToDir() throws IOException {
  Path dir1=new Path(testBaseDir1());
  Path subDir=new Path(testBaseDir2(),"subDir");
  Path linkToDir=new Path(testBaseDir2(),"linkToDir");
  wrapper.mkdir(subDir,FileContext.DEFAULT_PERM,false);
  wrapper.createSymlink(subDir,linkToDir,false);
  try {
    wrapper.rename(dir1,linkToDir,Rename.OVERWRITE);
    fail("Renamed directory to a symlink");
  }
 catch (  IOException e) {
    assertTrue(unwrapException(e) instanceof IOException);
  }
  assertTrue(wrapper.exists(dir1));
  assertTrue(wrapper.exists(linkToDir));
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test(timeout=10000) public void testCreateLinkToNullEmpty() throws IOException {
  Path link=new Path(testBaseDir1() + "/link");
  try {
    wrapper.createSymlink(null,link,false);
    fail("Can't create symlink to null");
  }
 catch (  java.lang.NullPointerException e) {
  }
  try {
    wrapper.createSymlink(new Path(""),link,false);
    fail("Can't create symlink to empty string");
  }
 catch (  java.lang.IllegalArgumentException e) {
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=10000) public void testCreateLinkUsingAbsPaths() throws IOException {
  Path fileAbs=new Path(testBaseDir1() + "/file");
  Path linkAbs=new Path(testBaseDir1() + "/linkToFile");
  Path schemeAuth=new Path(testURI().toString());
  Path fileQual=new Path(schemeAuth,testBaseDir1() + "/file");
  createAndWriteFile(fileAbs);
  wrapper.createSymlink(fileAbs,linkAbs,false);
  checkLink(linkAbs,fileAbs,fileQual);
  Path dir1=new Path(testBaseDir1());
  Path dir2=new Path(testBaseDir2());
  Path linkViaDir2=new Path(testBaseDir2(),"linkToFile");
  wrapper.rename(dir1,dir2,Rename.OVERWRITE);
  assertEquals(fileQual,wrapper.getFileLinkStatus(linkViaDir2).getSymlink());
  try {
    readFile(linkViaDir2);
    fail("The target should not exist");
  }
 catch (  FileNotFoundException x) {
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test(timeout=10000) public void testStatNonLinks() throws IOException {
  Path dir=new Path(testBaseDir1());
  Path file=new Path(testBaseDir1() + "/file");
  createAndWriteFile(file);
  try {
    wrapper.getLinkTarget(dir);
    fail("Lstat'd a non-symlink");
  }
 catch (  IOException e) {
  }
  try {
    wrapper.getLinkTarget(file);
    fail("Lstat'd a non-symlink");
  }
 catch (  IOException e) {
  }
}

</code></pre>

<br>
<pre class="type-2 type-15 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Sets implicit assumptions ">AssumptionSetter</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Sets implicit assumptions 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=10000) public void testRenameLinkTarget() throws IOException {
  assumeTrue(!emulatingSymlinksOnWindows());
  Path file=new Path(testBaseDir1(),"file");
  Path fileNew=new Path(testBaseDir1(),"fileNew");
  Path link=new Path(testBaseDir1(),"linkToFile");
  createAndWriteFile(file);
  wrapper.createSymlink(file,link,false);
  wrapper.rename(file,fileNew,Rename.OVERWRITE);
  try {
    readFile(link);
    fail("Link should be dangling");
  }
 catch (  IOException x) {
  }
  wrapper.rename(fileNew,file,Rename.OVERWRITE);
  readFile(link);
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test(timeout=10000) public void testCreateFileDirExistingLink() throws IOException {
  Path file=new Path(testBaseDir1(),"file");
  Path link=new Path(testBaseDir1(),"linkToFile");
  createAndWriteFile(file);
  wrapper.createSymlink(file,link,false);
  try {
    createAndWriteFile(link);
    fail("link already exists");
  }
 catch (  IOException x) {
  }
  try {
    wrapper.mkdir(link,FsPermission.getDefault(),false);
    fail("link already exists");
  }
 catch (  IOException x) {
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=10000) public void testRenameFileToDestViaSymlink() throws IOException {
  Path dir=new Path(testBaseDir1());
  Path file=new Path(testBaseDir1(),"file");
  Path linkToDir=new Path(testBaseDir2(),"linkToDir");
  Path subDir=new Path(linkToDir,"subDir");
  createAndWriteFile(file);
  wrapper.createSymlink(dir,linkToDir,false);
  wrapper.mkdir(subDir,FileContext.DEFAULT_PERM,false);
  try {
    wrapper.rename(file,subDir);
    fail("Renamed file to a directory");
  }
 catch (  IOException e) {
    assertTrue(unwrapException(e) instanceof IOException);
  }
  assertTrue(wrapper.exists(file));
}

</code></pre>

<br>
<pre class="type-2 type-7 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=10000) public void testRenameFileToSymlinkToDir() throws IOException {
  Path file=new Path(testBaseDir1(),"file");
  Path subDir=new Path(testBaseDir1(),"subDir");
  Path link=new Path(testBaseDir1(),"link");
  wrapper.mkdir(subDir,FileContext.DEFAULT_PERM,false);
  wrapper.createSymlink(subDir,link,false);
  createAndWriteFile(file);
  try {
    wrapper.rename(file,link);
    fail("Renamed file to symlink w/o overwrite");
  }
 catch (  IOException e) {
    assertTrue(unwrapException(e) instanceof FileAlreadyExistsException);
  }
  wrapper.rename(file,link,Rename.OVERWRITE);
  assertFalse(wrapper.exists(file));
  assertTrue(wrapper.exists(link));
  assertTrue(wrapper.isFile(link));
  assertFalse(wrapper.getFileLinkStatus(link).isSymlink());
}

</code></pre>

<br>
<pre class="type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=10000) public void testRenameSymlinkToExistingDir() throws IOException {
  Path dir1=new Path(testBaseDir1());
  Path dir2=new Path(testBaseDir2());
  Path subDir=new Path(testBaseDir2(),"subDir");
  Path link=new Path(testBaseDir1(),"linkToDir");
  wrapper.createSymlink(dir1,link,false);
  try {
    wrapper.rename(link,dir2);
    fail("Renamed link to a directory");
  }
 catch (  IOException e) {
    assertTrue(unwrapException(e) instanceof IOException);
  }
  try {
    wrapper.rename(link,dir2,Rename.OVERWRITE);
    fail("Renamed link to a directory");
  }
 catch (  IOException e) {
    assertTrue(unwrapException(e) instanceof IOException);
  }
  wrapper.mkdir(subDir,FsPermission.getDefault(),false);
  try {
    wrapper.rename(link,dir2,Rename.OVERWRITE);
    fail("Renamed link to a directory");
  }
 catch (  IOException e) {
    assertTrue(unwrapException(e) instanceof IOException);
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test(timeout=10000) public void testOpenResolvesLinks() throws IOException {
  Path file=new Path(testBaseDir1() + "/noSuchFile");
  Path link=new Path(testBaseDir1() + "/link");
  wrapper.createSymlink(file,link,false);
  try {
    wrapper.open(link);
    fail("link target does not exist");
  }
 catch (  FileNotFoundException x) {
  }
  wrapper.delete(link,false);
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test(timeout=10000) public void testCreateDanglingLink() throws IOException {
  Path file=new Path("/noSuchFile");
  Path link=new Path(testBaseDir1() + "/link");
  wrapper.createSymlink(file,link,false);
  try {
    wrapper.getFileStatus(link);
    fail("Got file status of non-existant file");
  }
 catch (  FileNotFoundException f) {
  }
  wrapper.delete(link,false);
}

</code></pre>

<br>
<pre class="type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=10000) public void testMkdirExistingLink() throws IOException {
  Path file=new Path(testBaseDir1() + "/targetFile");
  createAndWriteFile(file);
  Path dir=new Path(testBaseDir1() + "/link");
  wrapper.createSymlink(file,dir,false);
  try {
    wrapper.mkdir(dir,FileContext.DEFAULT_PERM,false);
    fail("Created a dir where a symlink exists");
  }
 catch (  FileAlreadyExistsException e) {
  }
catch (  IOException e) {
    assertEquals("file",getScheme());
  }
}

</code></pre>

<br>
<pre class="type-11 type-2 type-7 type-10 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=10000) public void testRenameSymlinkToExistingFile() throws IOException {
  Path file1=new Path(testBaseDir1(),"file");
  Path file2=new Path(testBaseDir1(),"someFile");
  Path link=new Path(testBaseDir1(),"linkToFile");
  createAndWriteFile(file1);
  createAndWriteFile(file2);
  wrapper.createSymlink(file2,link,false);
  try {
    wrapper.rename(link,file1);
    fail("Renamed w/o passing overwrite");
  }
 catch (  IOException e) {
    assertTrue(unwrapException(e) instanceof FileAlreadyExistsException);
  }
  wrapper.rename(link,file1,Rename.OVERWRITE);
  assertFalse(wrapper.exists(link));
  if (!emulatingSymlinksOnWindows()) {
    assertTrue(wrapper.getFileLinkStatus(file1).isSymlink());
    assertEquals(file2,wrapper.getLinkTarget(file1));
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=10000) public void testLinkStatusAndTargetWithNonLink() throws IOException {
  Path schemeAuth=new Path(testURI().toString());
  Path dir=new Path(testBaseDir1());
  Path dirQual=new Path(schemeAuth,dir.toString());
  Path file=new Path(testBaseDir1(),"file");
  Path fileQual=new Path(schemeAuth,file.toString());
  createAndWriteFile(file);
  assertEquals(wrapper.getFileStatus(file),wrapper.getFileLinkStatus(file));
  assertEquals(wrapper.getFileStatus(dir),wrapper.getFileLinkStatus(dir));
  try {
    wrapper.getLinkTarget(file);
    fail("Get link target on non-link should throw an IOException");
  }
 catch (  IOException x) {
    assertEquals("Path " + fileQual + " is not a symbolic link",x.getMessage());
  }
  try {
    wrapper.getLinkTarget(dir);
    fail("Get link target on non-link should throw an IOException");
  }
 catch (  IOException x) {
    assertEquals("Path " + dirQual + " is not a symbolic link",x.getMessage());
  }
}

</code></pre>

<br>
<pre class="type-11 type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=10000) public void testCreateLinkUsingPartQualPath2() throws IOException {
  Path link=new Path(testBaseDir1(),"linkToFile");
  Path fileWoScheme=new Path("//" + testURI().getAuthority() + testBaseDir1()+ "/file");
  if ("file".equals(getScheme())) {
    return;
  }
  wrapper.createSymlink(fileWoScheme,link,false);
  assertEquals(fileWoScheme,wrapper.getLinkTarget(link));
  assertEquals(fileWoScheme.toString(),wrapper.getFileLinkStatus(link).getSymlink().toString());
  try {
    readFile(link);
    fail("Accessed a file with w/o scheme");
  }
 catch (  IOException e) {
    if (wrapper instanceof FileContextTestWrapper) {
      assertEquals("No AbstractFileSystem for scheme: null",e.getMessage());
    }
 else     if (wrapper instanceof FileSystemTestWrapper) {
      assertEquals("No FileSystem for scheme: null",e.getMessage());
    }
  }
}

</code></pre>

<br>
<pre class="type-11 type-2 type-7 type-10 type-15 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Sets implicit assumptions ">AssumptionSetter</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Sets implicit assumptions 
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=10000) public void testCreateLinkUsingPartQualPath1() throws IOException {
  assumeTrue(!"file".equals(getScheme()));
  Path schemeAuth=new Path(testURI().toString());
  Path fileWoHost=new Path(getScheme() + "://" + testBaseDir1()+ "/file");
  Path link=new Path(testBaseDir1() + "/linkToFile");
  Path linkQual=new Path(schemeAuth,testBaseDir1() + "/linkToFile");
  FSTestWrapper localWrapper=wrapper.getLocalFSWrapper();
  wrapper.createSymlink(fileWoHost,link,false);
  assertEquals(fileWoHost,wrapper.getLinkTarget(linkQual));
  assertEquals(fileWoHost.toString(),wrapper.getFileLinkStatus(link).getSymlink().toString());
  assertEquals(fileWoHost.toString(),wrapper.getFileLinkStatus(linkQual).getSymlink().toString());
  if (wrapper instanceof FileContextTestWrapper) {
    assertEquals(fileWoHost.toString(),localWrapper.getFileLinkStatus(linkQual).getSymlink().toString());
  }
  try {
    readFile(link);
    fail("DFS requires URIs with schemes have an authority");
  }
 catch (  java.lang.RuntimeException e) {
    assertTrue(wrapper instanceof FileContextTestWrapper);
  }
catch (  FileNotFoundException e) {
    assertTrue(wrapper instanceof FileSystemTestWrapper);
    GenericTestUtils.assertExceptionContains("File does not exist: /test1/file",e);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.fs.TestChecksumFileSystem </h4><pre class="type-9 type-2 type-7 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test to ensure that if the checksum file is truncated, a
 * ChecksumException is thrown
 */
@Test public void testTruncatedChecksum() throws Exception {
  Path testPath=new Path(TEST_ROOT_DIR,"testtruncatedcrc");
  FSDataOutputStream fout=localFs.create(testPath);
  fout.write("testing truncation".getBytes());
  fout.close();
  Path checksumFile=localFs.getChecksumFile(testPath);
  FileSystem rawFs=localFs.getRawFileSystem();
  FSDataInputStream checksumStream=rawFs.open(checksumFile);
  byte buf[]=new byte[8192];
  int read=checksumStream.read(buf,0,buf.length);
  checksumStream.close();
  FSDataOutputStream replaceStream=rawFs.create(checksumFile);
  replaceStream.write(buf,0,read - 1);
  replaceStream.close();
  try {
    readFile(localFs,testPath,1024);
    fail("Did not throw a ChecksumException when reading truncated " + "crc file");
  }
 catch (  ChecksumException ie) {
  }
  localFs.setVerifyChecksum(false);
  String str=readFile(localFs,testPath,1024).toString();
  assertTrue("read","testing truncation".equals(str));
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.fs.TestDFVariations </h4><pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test(timeout=5000) public void testDFMalformedOutput() throws Exception {
  DF df=new DF(new File("/"),0l);
  BufferedReader reader=new BufferedReader(new StringReader("Filesystem     1K-blocks     Used Available Use% Mounted on\n" + "/dev/sda5       19222656 10597036   7649060  59% /"));
  df.parseExecResult(reader);
  df.parseOutput();
  reader=new BufferedReader(new StringReader("Filesystem     1K-blocks     Used Available Use% Mounted on"));
  df.parseExecResult(reader);
  try {
    df.parseOutput();
    fail("Expected exception with missing line!");
  }
 catch (  IOException e) {
    GenericTestUtils.assertExceptionContains("Fewer lines of output than expected",e);
    System.out.println(e.toString());
  }
  reader=new BufferedReader(new StringReader("Filesystem     1K-blocks     Used Available Use% Mounted on\n" + " "));
  df.parseExecResult(reader);
  try {
    df.parseOutput();
    fail("Expected exception with empty line!");
  }
 catch (  IOException e) {
    GenericTestUtils.assertExceptionContains("Unexpected empty line",e);
    System.out.println(e.toString());
  }
  reader=new BufferedReader(new StringReader("Filesystem     1K-blocks     Used Available Use% Mounted on\n" + "       19222656 10597036   7649060  59% /"));
  df.parseExecResult(reader);
  try {
    df.parseOutput();
    fail("Expected exception with missing field!");
  }
 catch (  IOException e) {
    GenericTestUtils.assertExceptionContains("Could not parse line: ",e);
    System.out.println(e.toString());
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.fs.TestEnhancedByteBufferAccess </h4><pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testShortZeroCopyReads() throws Exception {
  HdfsConfiguration conf=initZeroCopyTest();
  MiniDFSCluster cluster=null;
  final Path TEST_PATH=new Path("/a");
  FSDataInputStream fsIn=null;
  final int TEST_FILE_LENGTH=12345;
  FileSystem fs=null;
  try {
    cluster=new MiniDFSCluster.Builder(conf).numDataNodes(1).build();
    cluster.waitActive();
    fs=cluster.getFileSystem();
    DFSTestUtil.createFile(fs,TEST_PATH,TEST_FILE_LENGTH,(short)1,7567L);
    try {
      DFSTestUtil.waitReplication(fs,TEST_PATH,(short)1);
    }
 catch (    InterruptedException e) {
      Assert.fail("unexpected InterruptedException during " + "waitReplication: " + e);
    }
catch (    TimeoutException e) {
      Assert.fail("unexpected TimeoutException during " + "waitReplication: " + e);
    }
    fsIn=fs.open(TEST_PATH);
    byte original[]=new byte[TEST_FILE_LENGTH];
    IOUtils.readFully(fsIn,original,0,TEST_FILE_LENGTH);
    fsIn.close();
    fsIn=fs.open(TEST_PATH);
    HdfsDataInputStream dfsIn=(HdfsDataInputStream)fsIn;
    ByteBuffer result=dfsIn.read(null,8192,EnumSet.of(ReadOption.SKIP_CHECKSUMS));
    Assert.assertEquals(4096,result.remaining());
    Assert.assertEquals(4096,dfsIn.getReadStatistics().getTotalBytesRead());
    Assert.assertEquals(4096,dfsIn.getReadStatistics().getTotalZeroCopyBytesRead());
    Assert.assertArrayEquals(Arrays.copyOfRange(original,0,4096),byteBufferToArray(result));
    dfsIn.releaseBuffer(result);
    result=dfsIn.read(null,4097,EnumSet.of(ReadOption.SKIP_CHECKSUMS));
    Assert.assertEquals(4096,result.remaining());
    Assert.assertArrayEquals(Arrays.copyOfRange(original,4096,8192),byteBufferToArray(result));
    dfsIn.releaseBuffer(result);
  }
  finally {
    if (fsIn != null)     fsIn.close();
    if (fs != null)     fs.close();
    if (cluster != null)     cluster.shutdown();
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testClientMmapDisable() throws Exception {
  HdfsConfiguration conf=initZeroCopyTest();
  conf.setBoolean(DFS_CLIENT_MMAP_ENABLED,false);
  MiniDFSCluster cluster=null;
  final Path TEST_PATH=new Path("/a");
  final int TEST_FILE_LENGTH=16385;
  final int RANDOM_SEED=23453;
  final String CONTEXT="testClientMmapDisable";
  FSDataInputStream fsIn=null;
  DistributedFileSystem fs=null;
  conf.set(DFSConfigKeys.DFS_CLIENT_CONTEXT,CONTEXT);
  try {
    cluster=new MiniDFSCluster.Builder(conf).numDataNodes(1).build();
    cluster.waitActive();
    fs=cluster.getFileSystem();
    DFSTestUtil.createFile(fs,TEST_PATH,TEST_FILE_LENGTH,(short)1,RANDOM_SEED);
    DFSTestUtil.waitReplication(fs,TEST_PATH,(short)1);
    fsIn=fs.open(TEST_PATH);
    try {
      fsIn.read(null,1,EnumSet.of(ReadOption.SKIP_CHECKSUMS));
      Assert.fail("expected zero-copy read to fail when client mmaps " + "were disabled.");
    }
 catch (    UnsupportedOperationException e) {
    }
  }
  finally {
    if (fsIn != null)     fsIn.close();
    if (fs != null)     fs.close();
    if (cluster != null)     cluster.shutdown();
  }
  fsIn=null;
  fs=null;
  cluster=null;
  try {
    conf.setBoolean(DFS_CLIENT_MMAP_ENABLED,true);
    conf.setInt(DFS_CLIENT_MMAP_CACHE_SIZE,0);
    conf.set(DFSConfigKeys.DFS_CLIENT_CONTEXT,CONTEXT + ".1");
    cluster=new MiniDFSCluster.Builder(conf).numDataNodes(1).build();
    cluster.waitActive();
    fs=cluster.getFileSystem();
    DFSTestUtil.createFile(fs,TEST_PATH,TEST_FILE_LENGTH,(short)1,RANDOM_SEED);
    DFSTestUtil.waitReplication(fs,TEST_PATH,(short)1);
    fsIn=fs.open(TEST_PATH);
    ByteBuffer buf=fsIn.read(null,1,EnumSet.of(ReadOption.SKIP_CHECKSUMS));
    fsIn.releaseBuffer(buf);
    IOUtils.skipFully(fsIn,TEST_FILE_LENGTH - 1);
    buf=fsIn.read(null,1,EnumSet.of(ReadOption.SKIP_CHECKSUMS));
    Assert.assertEquals(null,buf);
  }
  finally {
    if (fsIn != null)     fsIn.close();
    if (fs != null)     fs.close();
    if (cluster != null)     cluster.shutdown();
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * Test HDFS fallback reads.  HDFS streams support the ByteBufferReadable
 * interface.
 */
@Test public void testHdfsFallbackReads() throws Exception {
  HdfsConfiguration conf=initZeroCopyTest();
  MiniDFSCluster cluster=null;
  final Path TEST_PATH=new Path("/a");
  final int TEST_FILE_LENGTH=16385;
  final int RANDOM_SEED=23453;
  FSDataInputStream fsIn=null;
  DistributedFileSystem fs=null;
  try {
    cluster=new MiniDFSCluster.Builder(conf).numDataNodes(1).build();
    cluster.waitActive();
    fs=cluster.getFileSystem();
    DFSTestUtil.createFile(fs,TEST_PATH,TEST_FILE_LENGTH,(short)1,RANDOM_SEED);
    try {
      DFSTestUtil.waitReplication(fs,TEST_PATH,(short)1);
    }
 catch (    InterruptedException e) {
      Assert.fail("unexpected InterruptedException during " + "waitReplication: " + e);
    }
catch (    TimeoutException e) {
      Assert.fail("unexpected TimeoutException during " + "waitReplication: " + e);
    }
    fsIn=fs.open(TEST_PATH);
    byte original[]=new byte[TEST_FILE_LENGTH];
    IOUtils.readFully(fsIn,original,0,TEST_FILE_LENGTH);
    fsIn.close();
    fsIn=fs.open(TEST_PATH);
    testFallbackImpl(fsIn,original);
  }
  finally {
    if (fsIn != null)     fsIn.close();
    if (fs != null)     fs.close();
    if (cluster != null)     cluster.shutdown();
  }
}

</code></pre>

<br>
<pre class="type-9 type-2 type-7 type-10 type-1 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testZeroCopyMmapCache() throws Exception {
  HdfsConfiguration conf=initZeroCopyTest();
  MiniDFSCluster cluster=null;
  final Path TEST_PATH=new Path("/a");
  final int TEST_FILE_LENGTH=16385;
  final int RANDOM_SEED=23453;
  final String CONTEXT="testZeroCopyMmapCacheContext";
  FSDataInputStream fsIn=null;
  ByteBuffer results[]={null,null,null,null};
  DistributedFileSystem fs=null;
  conf.set(DFSConfigKeys.DFS_CLIENT_CONTEXT,CONTEXT);
  cluster=new MiniDFSCluster.Builder(conf).numDataNodes(1).build();
  cluster.waitActive();
  fs=cluster.getFileSystem();
  DFSTestUtil.createFile(fs,TEST_PATH,TEST_FILE_LENGTH,(short)1,RANDOM_SEED);
  try {
    DFSTestUtil.waitReplication(fs,TEST_PATH,(short)1);
  }
 catch (  InterruptedException e) {
    Assert.fail("unexpected InterruptedException during " + "waitReplication: " + e);
  }
catch (  TimeoutException e) {
    Assert.fail("unexpected TimeoutException during " + "waitReplication: " + e);
  }
  fsIn=fs.open(TEST_PATH);
  byte original[]=new byte[TEST_FILE_LENGTH];
  IOUtils.readFully(fsIn,original,0,TEST_FILE_LENGTH);
  fsIn.close();
  fsIn=fs.open(TEST_PATH);
  final ShortCircuitCache cache=ClientContext.get(CONTEXT,new DFSClient.Conf(conf)).getShortCircuitCache();
  cache.accept(new CountingVisitor(0,5,5,0));
  results[0]=fsIn.read(null,4096,EnumSet.of(ReadOption.SKIP_CHECKSUMS));
  fsIn.seek(0);
  results[1]=fsIn.read(null,4096,EnumSet.of(ReadOption.SKIP_CHECKSUMS));
  final ExtendedBlock firstBlock=DFSTestUtil.getFirstBlock(fs,TEST_PATH);
  cache.accept(new CacheVisitor(){
    @Override public void visit(    int numOutstandingMmaps,    Map<ExtendedBlockId,ShortCircuitReplica> replicas,    Map<ExtendedBlockId,InvalidToken> failedLoads,    Map<Long,ShortCircuitReplica> evictable,    Map<Long,ShortCircuitReplica> evictableMmapped){
      ShortCircuitReplica replica=replicas.get(new ExtendedBlockId(firstBlock.getBlockId(),firstBlock.getBlockPoolId()));
      Assert.assertNotNull(replica);
      Assert.assertTrue(replica.hasMmap());
      Assert.assertNull(replica.getEvictableTimeNs());
    }
  }
);
  results[2]=fsIn.read(null,4096,EnumSet.of(ReadOption.SKIP_CHECKSUMS));
  results[3]=fsIn.read(null,4096,EnumSet.of(ReadOption.SKIP_CHECKSUMS));
  cache.accept(new CountingVisitor(3,5,2,0));
  for (  ByteBuffer buffer : results) {
    if (buffer != null) {
      fsIn.releaseBuffer(buffer);
    }
  }
  fsIn.close();
  GenericTestUtils.waitFor(new Supplier<Boolean>(){
    public Boolean get(){
      final MutableBoolean finished=new MutableBoolean(false);
      cache.accept(new CacheVisitor(){
        @Override public void visit(        int numOutstandingMmaps,        Map<ExtendedBlockId,ShortCircuitReplica> replicas,        Map<ExtendedBlockId,InvalidToken> failedLoads,        Map<Long,ShortCircuitReplica> evictable,        Map<Long,ShortCircuitReplica> evictableMmapped){
          finished.setValue(evictableMmapped.isEmpty());
        }
      }
);
      return finished.booleanValue();
    }
  }
,10,60000);
  cache.accept(new CountingVisitor(0,-1,-1,-1));
  fs.close();
  cluster.shutdown();
}

</code></pre>

<br>
<pre class="type-9 type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test that we can zero-copy read cached data even without disabling
 * checksums.
 */
@Test(timeout=120000) public void testZeroCopyReadOfCachedData() throws Exception {
  BlockReaderTestUtil.enableShortCircuitShmTracing();
  BlockReaderTestUtil.enableBlockReaderFactoryTracing();
  BlockReaderTestUtil.enableHdfsCachingTracing();
  final int TEST_FILE_LENGTH=16385;
  final Path TEST_PATH=new Path("/a");
  final int RANDOM_SEED=23453;
  HdfsConfiguration conf=initZeroCopyTest();
  conf.setBoolean(DFSConfigKeys.DFS_CLIENT_READ_SHORTCIRCUIT_SKIP_CHECKSUM_KEY,false);
  final String CONTEXT="testZeroCopyReadOfCachedData";
  conf.set(DFSConfigKeys.DFS_CLIENT_CONTEXT,CONTEXT);
  conf.setLong(DFS_DATANODE_MAX_LOCKED_MEMORY_KEY,DFSTestUtil.roundUpToMultiple(TEST_FILE_LENGTH,4096));
  MiniDFSCluster cluster=null;
  ByteBuffer result=null, result2=null;
  cluster=new MiniDFSCluster.Builder(conf).numDataNodes(1).build();
  cluster.waitActive();
  FsDatasetSpi<?> fsd=cluster.getDataNodes().get(0).getFSDataset();
  DistributedFileSystem fs=cluster.getFileSystem();
  DFSTestUtil.createFile(fs,TEST_PATH,TEST_FILE_LENGTH,(short)1,RANDOM_SEED);
  DFSTestUtil.waitReplication(fs,TEST_PATH,(short)1);
  byte original[]=DFSTestUtil.calculateFileContentsFromSeed(RANDOM_SEED,TEST_FILE_LENGTH);
  FSDataInputStream fsIn=fs.open(TEST_PATH);
  try {
    result=fsIn.read(null,TEST_FILE_LENGTH / 2,EnumSet.noneOf(ReadOption.class));
    Assert.fail("expected UnsupportedOperationException");
  }
 catch (  UnsupportedOperationException e) {
  }
  fs.addCachePool(new CachePoolInfo("pool1"));
  long directiveId=fs.addCacheDirective(new CacheDirectiveInfo.Builder().setPath(TEST_PATH).setReplication((short)1).setPool("pool1").build());
  int numBlocks=(int)Math.ceil((double)TEST_FILE_LENGTH / BLOCK_SIZE);
  DFSTestUtil.verifyExpectedCacheUsage(DFSTestUtil.roundUpToMultiple(TEST_FILE_LENGTH,BLOCK_SIZE),numBlocks,cluster.getDataNodes().get(0).getFSDataset());
  try {
    result=fsIn.read(null,TEST_FILE_LENGTH,EnumSet.noneOf(ReadOption.class));
  }
 catch (  UnsupportedOperationException e) {
    Assert.fail("expected to be able to read cached file via zero-copy");
  }
  Assert.assertArrayEquals(Arrays.copyOfRange(original,0,BLOCK_SIZE),byteBufferToArray(result));
  FSDataInputStream fsIn2=fs.open(TEST_PATH);
  try {
    result2=fsIn2.read(null,TEST_FILE_LENGTH,EnumSet.noneOf(ReadOption.class));
  }
 catch (  UnsupportedOperationException e) {
    Assert.fail("expected to be able to read cached file via zero-copy");
  }
  Assert.assertArrayEquals(Arrays.copyOfRange(original,0,BLOCK_SIZE),byteBufferToArray(result2));
  fsIn2.releaseBuffer(result2);
  fsIn2.close();
  final ExtendedBlock firstBlock=DFSTestUtil.getFirstBlock(fs,TEST_PATH);
  final ShortCircuitCache cache=ClientContext.get(CONTEXT,new DFSClient.Conf(conf)).getShortCircuitCache();
  waitForReplicaAnchorStatus(cache,firstBlock,true,true,1);
  fs.removeCacheDirective(directiveId);
  waitForReplicaAnchorStatus(cache,firstBlock,false,true,1);
  fsIn.releaseBuffer(result);
  waitForReplicaAnchorStatus(cache,firstBlock,false,false,1);
  DFSTestUtil.verifyExpectedCacheUsage(0,0,fsd);
  fsIn.close();
  fs.close();
  cluster.shutdown();
}

</code></pre>

<br>
<pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testZeroCopyReads() throws Exception {
  HdfsConfiguration conf=initZeroCopyTest();
  MiniDFSCluster cluster=null;
  final Path TEST_PATH=new Path("/a");
  FSDataInputStream fsIn=null;
  final int TEST_FILE_LENGTH=12345;
  FileSystem fs=null;
  try {
    cluster=new MiniDFSCluster.Builder(conf).numDataNodes(1).build();
    cluster.waitActive();
    fs=cluster.getFileSystem();
    DFSTestUtil.createFile(fs,TEST_PATH,TEST_FILE_LENGTH,(short)1,7567L);
    try {
      DFSTestUtil.waitReplication(fs,TEST_PATH,(short)1);
    }
 catch (    InterruptedException e) {
      Assert.fail("unexpected InterruptedException during " + "waitReplication: " + e);
    }
catch (    TimeoutException e) {
      Assert.fail("unexpected TimeoutException during " + "waitReplication: " + e);
    }
    fsIn=fs.open(TEST_PATH);
    byte original[]=new byte[TEST_FILE_LENGTH];
    IOUtils.readFully(fsIn,original,0,TEST_FILE_LENGTH);
    fsIn.close();
    fsIn=fs.open(TEST_PATH);
    ByteBuffer result=fsIn.read(null,4096,EnumSet.of(ReadOption.SKIP_CHECKSUMS));
    Assert.assertEquals(4096,result.remaining());
    HdfsDataInputStream dfsIn=(HdfsDataInputStream)fsIn;
    Assert.assertEquals(4096,dfsIn.getReadStatistics().getTotalBytesRead());
    Assert.assertEquals(4096,dfsIn.getReadStatistics().getTotalZeroCopyBytesRead());
    Assert.assertArrayEquals(Arrays.copyOfRange(original,0,4096),byteBufferToArray(result));
    fsIn.releaseBuffer(result);
  }
  finally {
    if (fsIn != null)     fsIn.close();
    if (fs != null)     fs.close();
    if (cluster != null)     cluster.shutdown();
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-15 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Sets implicit assumptions ">AssumptionSetter</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Sets implicit assumptions 
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void test2GBMmapLimit() throws Exception {
  Assume.assumeTrue(BlockReaderTestUtil.shouldTestLargeFiles());
  HdfsConfiguration conf=initZeroCopyTest();
  final long TEST_FILE_LENGTH=2469605888L;
  conf.set(DFSConfigKeys.DFS_CHECKSUM_TYPE_KEY,"NULL");
  conf.setLong(DFSConfigKeys.DFS_BLOCK_SIZE_KEY,TEST_FILE_LENGTH);
  MiniDFSCluster cluster=null;
  final Path TEST_PATH=new Path("/a");
  final String CONTEXT="test2GBMmapLimit";
  conf.set(DFSConfigKeys.DFS_CLIENT_CONTEXT,CONTEXT);
  FSDataInputStream fsIn=null, fsIn2=null;
  ByteBuffer buf1=null, buf2=null;
  try {
    cluster=new MiniDFSCluster.Builder(conf).numDataNodes(1).build();
    cluster.waitActive();
    DistributedFileSystem fs=cluster.getFileSystem();
    DFSTestUtil.createFile(fs,TEST_PATH,TEST_FILE_LENGTH,(short)1,0xB);
    DFSTestUtil.waitReplication(fs,TEST_PATH,(short)1);
    fsIn=fs.open(TEST_PATH);
    buf1=fsIn.read(null,1,EnumSet.of(ReadOption.SKIP_CHECKSUMS));
    Assert.assertEquals(1,buf1.remaining());
    fsIn.releaseBuffer(buf1);
    buf1=null;
    fsIn.seek(2147483640L);
    buf1=fsIn.read(null,1024,EnumSet.of(ReadOption.SKIP_CHECKSUMS));
    Assert.assertEquals(7,buf1.remaining());
    Assert.assertEquals(Integer.MAX_VALUE,buf1.limit());
    fsIn.releaseBuffer(buf1);
    buf1=null;
    Assert.assertEquals(2147483647L,fsIn.getPos());
    try {
      buf1=fsIn.read(null,1024,EnumSet.of(ReadOption.SKIP_CHECKSUMS));
      Assert.fail("expected UnsupportedOperationException");
    }
 catch (    UnsupportedOperationException e) {
    }
    fsIn.close();
    fsIn=null;
    final Path TEST_PATH2=new Path("/b");
    conf.setLong(DFSConfigKeys.DFS_BLOCK_SIZE_KEY,268435456L);
    DFSTestUtil.createFile(fs,TEST_PATH2,1024 * 1024,TEST_FILE_LENGTH,268435456L,(short)1,0xA);
    fsIn2=fs.open(TEST_PATH2);
    fsIn2.seek(2147483640L);
    buf2=fsIn2.read(null,1024,EnumSet.of(ReadOption.SKIP_CHECKSUMS));
    Assert.assertEquals(8,buf2.remaining());
    Assert.assertEquals(2147483648L,fsIn2.getPos());
    fsIn2.releaseBuffer(buf2);
    buf2=null;
    buf2=fsIn2.read(null,1024,EnumSet.of(ReadOption.SKIP_CHECKSUMS));
    Assert.assertEquals(1024,buf2.remaining());
    Assert.assertEquals(2147484672L,fsIn2.getPos());
    fsIn2.releaseBuffer(buf2);
    buf2=null;
  }
  finally {
    if (buf1 != null) {
      fsIn.releaseBuffer(buf1);
    }
    if (buf2 != null) {
      fsIn2.releaseBuffer(buf2);
    }
    IOUtils.cleanup(null,fsIn,fsIn2);
    if (cluster != null) {
      cluster.shutdown();
    }
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * Test the {@link ByteBufferUtil#fallbackRead} function directly.
 */
@Test public void testFallbackRead() throws Exception {
  HdfsConfiguration conf=initZeroCopyTest();
  MiniDFSCluster cluster=null;
  final Path TEST_PATH=new Path("/a");
  final int TEST_FILE_LENGTH=16385;
  final int RANDOM_SEED=23453;
  FSDataInputStream fsIn=null;
  DistributedFileSystem fs=null;
  try {
    cluster=new MiniDFSCluster.Builder(conf).numDataNodes(1).build();
    cluster.waitActive();
    fs=cluster.getFileSystem();
    DFSTestUtil.createFile(fs,TEST_PATH,TEST_FILE_LENGTH,(short)1,RANDOM_SEED);
    try {
      DFSTestUtil.waitReplication(fs,TEST_PATH,(short)1);
    }
 catch (    InterruptedException e) {
      Assert.fail("unexpected InterruptedException during " + "waitReplication: " + e);
    }
catch (    TimeoutException e) {
      Assert.fail("unexpected TimeoutException during " + "waitReplication: " + e);
    }
    fsIn=fs.open(TEST_PATH);
    byte original[]=new byte[TEST_FILE_LENGTH];
    IOUtils.readFully(fsIn,original,0,TEST_FILE_LENGTH);
    fsIn.close();
    fsIn=fs.open(TEST_PATH);
    testFallbackImpl(fsIn,original);
  }
  finally {
    if (fsIn != null)     fsIn.close();
    if (fs != null)     fs.close();
    if (cluster != null)     cluster.shutdown();
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testZeroCopyReadsNoFallback() throws Exception {
  HdfsConfiguration conf=initZeroCopyTest();
  MiniDFSCluster cluster=null;
  final Path TEST_PATH=new Path("/a");
  FSDataInputStream fsIn=null;
  final int TEST_FILE_LENGTH=12345;
  FileSystem fs=null;
  try {
    cluster=new MiniDFSCluster.Builder(conf).numDataNodes(1).build();
    cluster.waitActive();
    fs=cluster.getFileSystem();
    DFSTestUtil.createFile(fs,TEST_PATH,TEST_FILE_LENGTH,(short)1,7567L);
    try {
      DFSTestUtil.waitReplication(fs,TEST_PATH,(short)1);
    }
 catch (    InterruptedException e) {
      Assert.fail("unexpected InterruptedException during " + "waitReplication: " + e);
    }
catch (    TimeoutException e) {
      Assert.fail("unexpected TimeoutException during " + "waitReplication: " + e);
    }
    fsIn=fs.open(TEST_PATH);
    byte original[]=new byte[TEST_FILE_LENGTH];
    IOUtils.readFully(fsIn,original,0,TEST_FILE_LENGTH);
    fsIn.close();
    fsIn=fs.open(TEST_PATH);
    HdfsDataInputStream dfsIn=(HdfsDataInputStream)fsIn;
    ByteBuffer result;
    try {
      result=dfsIn.read(null,4097,EnumSet.noneOf(ReadOption.class));
      Assert.fail("expected UnsupportedOperationException");
    }
 catch (    UnsupportedOperationException e) {
    }
    result=dfsIn.read(null,4096,EnumSet.of(ReadOption.SKIP_CHECKSUMS));
    Assert.assertEquals(4096,result.remaining());
    Assert.assertEquals(4096,dfsIn.getReadStatistics().getTotalBytesRead());
    Assert.assertEquals(4096,dfsIn.getReadStatistics().getTotalZeroCopyBytesRead());
    Assert.assertArrayEquals(Arrays.copyOfRange(original,0,4096),byteBufferToArray(result));
  }
  finally {
    if (fsIn != null)     fsIn.close();
    if (fs != null)     fs.close();
    if (cluster != null)     cluster.shutdown();
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.fs.TestFiListPath </h4><pre class="type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Remove the target directory after the getListing RPC 
 */
@Test public void testTargetDeletionForListStatus() throws Exception {
  LOG.info("Test Target Delete For listStatus");
  try {
    fs.listStatus(TEST_PATH);
    fail("Test should fail with FileNotFoundException");
  }
 catch (  FileNotFoundException e) {
    assertEquals("File " + TEST_PATH + " does not exist.",e.getMessage());
    LOG.info(StringUtils.stringifyException(e));
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.fs.TestFileSystemCaching </h4><pre class="type-9 type-2 type-7 type-19 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether two objects/variables are the same">IdentityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether two objects/variables are the same
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testDefaultFsUris() throws Exception {
  final Configuration conf=new Configuration();
  conf.set("fs.defaultfs.impl",DefaultFs.class.getName());
  final URI defaultUri=URI.create("defaultfs://host");
  FileSystem.setDefaultUri(conf,defaultUri);
  FileSystem fs=null;
  final FileSystem defaultFs=FileSystem.get(conf);
  assertEquals(defaultUri,defaultFs.getUri());
  fs=FileSystem.get(URI.create("defaultfs:/"),conf);
  assertSame(defaultFs,fs);
  fs=FileSystem.get(URI.create("defaultfs:///"),conf);
  assertSame(defaultFs,fs);
  fs=FileSystem.get(URI.create("defaultfs://host"),conf);
  assertSame(defaultFs,fs);
  fs=FileSystem.get(URI.create("defaultfs://host2"),conf);
  assertNotSame(defaultFs,fs);
  fs=FileSystem.get(URI.create("/"),conf);
  assertSame(defaultFs,fs);
  try {
    fs=FileSystem.get(URI.create("//host"),conf);
    fail("got fs with auth but no scheme");
  }
 catch (  Exception e) {
    assertEquals("No FileSystem for scheme: null",e.getMessage());
  }
  try {
    fs=FileSystem.get(URI.create("//host2"),conf);
    fail("got fs with auth but no scheme");
  }
 catch (  Exception e) {
    assertEquals("No FileSystem for scheme: null",e.getMessage());
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.fs.TestFileUtil </h4><pre class="type-9 type-2 type-10 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=30000) public void testListAPI() throws IOException {
  setupDirs();
  String[] files=FileUtil.list(partitioned);
  Assert.assertEquals("Unexpected number of pre-existing files",2,files.length);
  File newDir=new File(tmp.getPath(),"test");
  newDir.mkdir();
  Assert.assertTrue("Failed to create test dir",newDir.exists());
  files=FileUtil.list(newDir);
  Assert.assertEquals("New directory unexpectedly contains files",0,files.length);
  newDir.delete();
  Assert.assertFalse("Failed to delete test dir",newDir.exists());
  try {
    files=FileUtil.list(newDir);
    Assert.fail("IOException expected on list() for non-existent dir " + newDir.toString());
  }
 catch (  IOException ioe) {
  }
}

</code></pre>

<br>
<pre class="type-9 type-2 type-10 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=30000) public void testListFiles() throws IOException {
  setupDirs();
  File[] files=FileUtil.listFiles(partitioned);
  Assert.assertEquals(2,files.length);
  File newDir=new File(tmp.getPath(),"test");
  newDir.mkdir();
  Assert.assertTrue("Failed to create test dir",newDir.exists());
  files=FileUtil.listFiles(newDir);
  Assert.assertEquals(0,files.length);
  newDir.delete();
  Assert.assertFalse("Failed to delete test dir",newDir.exists());
  try {
    files=FileUtil.listFiles(newDir);
    Assert.fail("IOException expected on listFiles() for non-existent dir " + newDir.toString());
  }
 catch (  IOException ioe) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.fs.TestHDFSFileContextMainOperations </h4><pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testCrossFileSystemRename() throws IOException {
  try {
    fc.rename(new Path("hdfs://127.0.0.1/aaa/bbb/Foo"),new Path("file://aaa/bbb/Moo"),Options.Rename.OVERWRITE);
    fail("IOexception expected.");
  }
 catch (  IOException ioe) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.fs.TestHarFileSystemBasics </h4><pre class="type-2 type-7 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
"></span><br>
@Test public void testNegativeGetHarVersionOnNotInitializedFS() throws Exception {
  final HarFileSystem hfs=new HarFileSystem(localFileSystem);
  try {
    int version=hfs.getHarVersion();
    Assert.fail("Exception expected, but got a Har version " + version + ".");
  }
 catch (  IOException ioe) {
  }
}

</code></pre>

<br>
<pre class="type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testNegativeInitWithAnUnsupportedVersion() throws Exception {
  Thread.sleep(1000);
  writeVersionToMasterIndexImpl(7777,new Path(harPath,"_masterindex"));
  final HarFileSystem hfs=new HarFileSystem(localFileSystem);
  assertFalse(hfs.getMetadata() == harFileSystem.getMetadata());
  final URI uri=new URI("har://" + harPath.toString());
  try {
    hfs.initialize(uri,new Configuration());
    Assert.fail("IOException expected.");
  }
 catch (  IOException ioe) {
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testNegativeHarFsModifications() throws Exception {
  final Path fooPath=new Path(rootPath,"foo/bar");
  localFileSystem.createNewFile(fooPath);
  try {
    harFileSystem.create(fooPath,new FsPermission("+rwx"),true,1024,(short)88,1024,null);
    Assert.fail("IOException expected.");
  }
 catch (  IOException ioe) {
  }
  try {
    harFileSystem.setReplication(fooPath,(short)55);
    Assert.fail("IOException expected.");
  }
 catch (  IOException ioe) {
  }
  try {
    harFileSystem.delete(fooPath,true);
    Assert.fail("IOException expected.");
  }
 catch (  IOException ioe) {
  }
  try {
    harFileSystem.mkdirs(fooPath,new FsPermission("+rwx"));
    Assert.fail("IOException expected.");
  }
 catch (  IOException ioe) {
  }
  final Path indexPath=new Path(harPath,"_index");
  try {
    harFileSystem.copyFromLocalFile(false,indexPath,fooPath);
    Assert.fail("IOException expected.");
  }
 catch (  IOException ioe) {
  }
  try {
    harFileSystem.startLocalOutput(fooPath,indexPath);
    Assert.fail("IOException expected.");
  }
 catch (  IOException ioe) {
  }
  try {
    harFileSystem.completeLocalOutput(fooPath,indexPath);
    Assert.fail("IOException expected.");
  }
 catch (  IOException ioe) {
  }
  try {
    harFileSystem.setOwner(fooPath,"user","group");
    Assert.fail("IOException expected.");
  }
 catch (  IOException ioe) {
  }
  try {
    harFileSystem.setPermission(fooPath,new FsPermission("+x"));
    Assert.fail("IOException expected.");
  }
 catch (  IOException ioe) {
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testNegativeInitWithoutIndex() throws Exception {
  final Path indexPath=new Path(harPath,"_index");
  localFileSystem.delete(indexPath,false);
  final HarFileSystem hfs=new HarFileSystem(localFileSystem);
  final URI uri=new URI("har://" + harPath.toString());
  try {
    hfs.initialize(uri,new Configuration());
    Assert.fail("Exception expected.");
  }
 catch (  IOException ioe) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.fs.TestHdfsNativeCodeLoader </h4><pre class="type-11 type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testNativeCodeLoaded(){
  if (requireTestJni() == false) {
    LOG.info("TestNativeCodeLoader: libhadoop.so testing is not required.");
    return;
  }
  if (!NativeCodeLoader.isNativeCodeLoaded()) {
    String LD_LIBRARY_PATH=System.getenv().get("LD_LIBRARY_PATH");
    if (LD_LIBRARY_PATH == null)     LD_LIBRARY_PATH="";
    fail("TestNativeCodeLoader: libhadoop.so testing was required, but " + "libhadoop.so was not loaded.  LD_LIBRARY_PATH = " + LD_LIBRARY_PATH);
  }
  LOG.info("TestHdfsNativeCodeLoader: libhadoop.so is loaded.");
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.fs.TestLocalDirAllocator </h4><pre class="type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=30000) public void testShouldNotthrowNPE() throws Exception {
  Configuration conf1=new Configuration();
  try {
    dirAllocator.getLocalPathForWrite("/test",conf1);
    fail("Exception not thrown when " + CONTEXT + " is not set");
  }
 catch (  IOException e) {
    assertEquals(CONTEXT + " not configured",e.getMessage());
  }
catch (  NullPointerException e) {
    fail("Lack of configuration should not have thrown an NPE.");
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.fs.TestLocalFileSystem </h4><pre class="type-2 type-7 type-10 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=1000) public void testCreateFileAndMkdirs() throws IOException {
  Path test_dir=new Path(TEST_ROOT_DIR,"test_dir");
  Path test_file=new Path(test_dir,"file1");
  assertTrue(fileSys.mkdirs(test_dir));
  final int fileSize=new Random().nextInt(1 << 20) + 1;
  writeFile(fileSys,test_file,fileSize);
{
    final FileStatus status=fileSys.getFileStatus(test_file);
    Assert.assertEquals(fileSize,status.getLen());
    final ContentSummary summary=fileSys.getContentSummary(test_dir);
    Assert.assertEquals(fileSize,summary.getLength());
  }
  Path bad_dir=new Path(test_file,"another_dir");
  try {
    fileSys.mkdirs(bad_dir);
    fail("Failed to detect existing file in path");
  }
 catch (  ParentNotDirectoryException e) {
  }
  try {
    fileSys.mkdirs(null);
    fail("Failed to detect null in mkdir arg");
  }
 catch (  IllegalArgumentException e) {
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=10000) public void testCopy() throws IOException {
  Path src=new Path(TEST_ROOT_DIR,"dingo");
  Path dst=new Path(TEST_ROOT_DIR,"yak");
  writeFile(fileSys,src,1);
  assertTrue(FileUtil.copy(fileSys,src,fileSys,dst,true,false,conf));
  assertTrue(!fileSys.exists(src) && fileSys.exists(dst));
  assertTrue(FileUtil.copy(fileSys,dst,fileSys,src,false,false,conf));
  assertTrue(fileSys.exists(src) && fileSys.exists(dst));
  assertTrue(FileUtil.copy(fileSys,src,fileSys,dst,true,true,conf));
  assertTrue(!fileSys.exists(src) && fileSys.exists(dst));
  fileSys.mkdirs(src);
  assertTrue(FileUtil.copy(fileSys,dst,fileSys,src,false,false,conf));
  Path tmp=new Path(src,dst.getName());
  assertTrue(fileSys.exists(tmp) && fileSys.exists(dst));
  assertTrue(FileUtil.copy(fileSys,dst,fileSys,src,false,true,conf));
  assertTrue(fileSys.delete(tmp,true));
  fileSys.mkdirs(tmp);
  try {
    FileUtil.copy(fileSys,dst,fileSys,src,true,true,conf);
    fail("Failed to detect existing dir");
  }
 catch (  IOException e) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.fs.TestPath </h4><pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * Test invalid paths on Windows are correctly rejected 
 */
@Test(timeout=5000) public void testInvalidWindowsPaths() throws URISyntaxException, IOException {
  if (!Path.WINDOWS) {
    return;
  }
  String[] invalidPaths={"hdfs:\\\\\\tmp"};
  for (  String path : invalidPaths) {
    try {
      Path item=new Path(path);
      fail("Did not throw for invalid path " + path);
    }
 catch (    IllegalArgumentException iae) {
    }
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.fs.TestResolveHdfsSymlink </h4><pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * Verifies that attempting to resolve a non-symlink results in client
 * exception
 */
@Test public void testLinkTargetNonSymlink() throws UnsupportedFileSystemException, IOException {
  FileContext fc=null;
  Path notSymlink=new Path("/notasymlink");
  try {
    fc=FileContext.getFileContext(cluster.getFileSystem().getUri());
    fc.create(notSymlink,EnumSet.of(CreateFlag.CREATE));
    DFSClient client=new DFSClient(cluster.getFileSystem().getUri(),cluster.getConfiguration(0));
    try {
      client.getLinkTarget(notSymlink.toString());
      fail("Expected exception for resolving non-symlink");
    }
 catch (    IOException e) {
      GenericTestUtils.assertExceptionContains("is not a symbolic link",e);
    }
  }
  finally {
    if (fc != null) {
      fc.delete(notSymlink,false);
    }
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * Tests that attempting to resolve a non-existent-file
 */
@Test public void testLinkTargetNonExistent() throws IOException {
  Path doesNotExist=new Path("/filethatdoesnotexist");
  DFSClient client=new DFSClient(cluster.getFileSystem().getUri(),cluster.getConfiguration(0));
  try {
    client.getLinkTarget(doesNotExist.toString());
    fail("Expected exception for resolving non-existent file");
  }
 catch (  FileNotFoundException e) {
    GenericTestUtils.assertExceptionContains("File does not exist: " + doesNotExist.toString(),e);
  }
}

</code></pre>

<br>
<pre class="type-11 type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Tests resolution of an hdfs symlink to the local file system.
 * @throws IOException
 * @throws InterruptedException
 */
@Test public void testFcResolveAfs() throws IOException, InterruptedException {
  Configuration conf=new Configuration();
  FileContext fcLocal=FileContext.getLocalFSFileContext();
  FileContext fcHdfs=FileContext.getFileContext(cluster.getFileSystem().getUri());
  final String localTestRoot=helper.getAbsoluteTestRootDir(fcLocal);
  Path alphaLocalPath=new Path(fcLocal.getDefaultFileSystem().getUri().toString(),new File(localTestRoot,"alpha").getAbsolutePath());
  DFSTestUtil.createFile(FileSystem.getLocal(conf),alphaLocalPath,16,(short)1,2);
  Path linkTarget=new Path(fcLocal.getDefaultFileSystem().getUri().toString(),localTestRoot);
  Path hdfsLink=new Path(fcHdfs.getDefaultFileSystem().getUri().toString(),"/tmp/link");
  fcHdfs.createSymlink(linkTarget,hdfsLink,true);
  Path alphaHdfsPathViaLink=new Path(fcHdfs.getDefaultFileSystem().getUri().toString() + "/tmp/link/alpha");
  Set<AbstractFileSystem> afsList=fcHdfs.resolveAbstractFileSystems(alphaHdfsPathViaLink);
  Assert.assertEquals(2,afsList.size());
  for (  AbstractFileSystem afs : afsList) {
    if ((!afs.equals(fcHdfs.getDefaultFileSystem())) && (!afs.equals(fcLocal.getDefaultFileSystem()))) {
      Assert.fail("Failed to resolve AFS correctly");
    }
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.fs.TestStat </h4><pre class="type-2 type-15 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Sets implicit assumptions ">AssumptionSetter</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Sets implicit assumptions 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=10000) public void testStatFileNotFound() throws Exception {
  Assume.assumeTrue(Stat.isAvailable());
  try {
    stat.getFileStatus();
    fail("Expected FileNotFoundException");
  }
 catch (  FileNotFoundException e) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.fs.TestSymlinkHdfs </h4><pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test(timeout=10000) public void testRenameAcrossFileSystemsViaLink() throws IOException {
  Path localDir=new Path("file://" + wrapper.getAbsoluteTestRootDir() + "/test");
  Path hdfsFile=new Path(testBaseDir1(),"file");
  Path link=new Path(testBaseDir1(),"link");
  Path hdfsFileNew=new Path(testBaseDir1(),"fileNew");
  Path hdfsFileNewViaLink=new Path(link,"fileNew");
  FSTestWrapper localWrapper=wrapper.getLocalFSWrapper();
  localWrapper.delete(localDir,true);
  localWrapper.mkdir(localDir,FileContext.DEFAULT_PERM,true);
  localWrapper.setWorkingDirectory(localDir);
  createAndWriteFile(hdfsFile);
  wrapper.createSymlink(localDir,link,false);
  try {
    wrapper.rename(hdfsFile,hdfsFileNewViaLink);
    fail("Renamed across file systems");
  }
 catch (  InvalidPathException ipe) {
  }
catch (  IllegalArgumentException e) {
    GenericTestUtils.assertExceptionContains("Wrong FS: ",e);
  }
  createAndWriteFile(hdfsFileNewViaLink);
  try {
    wrapper.rename(hdfsFileNewViaLink,hdfsFileNew);
    fail("Renamed across file systems");
  }
 catch (  InvalidPathException ipe) {
  }
catch (  IllegalArgumentException e) {
    GenericTestUtils.assertExceptionContains("Wrong FS: ",e);
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test(timeout=10000) public void testCreateWithPartQualPathFails() throws IOException {
  Path fileWoAuth=new Path("hdfs:///test/file");
  Path linkWoAuth=new Path("hdfs:///test/link");
  try {
    createAndWriteFile(fileWoAuth);
    fail("HDFS requires URIs with schemes have an authority");
  }
 catch (  RuntimeException e) {
  }
  try {
    wrapper.createSymlink(new Path("foo"),linkWoAuth,false);
    fail("HDFS requires URIs with schemes have an authority");
  }
 catch (  RuntimeException e) {
  }
}

</code></pre>

<br>
<pre class="type-9 type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=10000) public void testCreateLinkMaxPathLink() throws IOException {
  Path dir=new Path(testBaseDir1());
  Path file=new Path(testBaseDir1(),"file");
  final int maxPathLen=HdfsConstants.MAX_PATH_LENGTH;
  final int dirLen=dir.toString().length() + 1;
  int len=maxPathLen - dirLen;
  StringBuilder sb=new StringBuilder("");
  for (int i=0; i < (len / 10); i++) {
    sb.append("0123456789");
  }
  for (int i=0; i < (len % 10); i++) {
    sb.append("x");
  }
  Path link=new Path(sb.toString());
  assertEquals(maxPathLen,dirLen + link.toString().length());
  createAndWriteFile(file);
  wrapper.setWorkingDirectory(dir);
  wrapper.createSymlink(file,link,false);
  readFile(link);
  link=new Path(sb.toString() + "x");
  try {
    wrapper.createSymlink(file,link,false);
    fail("Path name should be too long");
  }
 catch (  IOException x) {
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test(timeout=10000) public void testQuota() throws IOException {
  final Path dir=new Path(testBaseDir1());
  dfs.setQuota(dir,3,HdfsConstants.QUOTA_DONT_SET);
  final Path file=new Path(dir,"file");
  createAndWriteFile(file);
  final Path link1=new Path(dir,"link1");
  wrapper.createSymlink(file,link1,false);
  try {
    final Path link2=new Path(dir,"link2");
    wrapper.createSymlink(file,link2,false);
    fail("Created symlink despite quota violation");
  }
 catch (  QuotaExceededException qee) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.fs.TestSymlinkHdfsDisable </h4><pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test(timeout=60000) public void testSymlinkHdfsDisable() throws Exception {
  Configuration conf=new HdfsConfiguration();
  conf.setBoolean(CommonConfigurationKeys.FS_CLIENT_RESOLVE_REMOTE_SYMLINKS_KEY,false);
  MiniDFSCluster cluster=new MiniDFSCluster.Builder(conf).build();
  DistributedFileSystem dfs=cluster.getFileSystem();
  FileContext fc=FileContext.getFileContext(cluster.getURI(0),conf);
  FileContextTestHelper helper=new FileContextTestHelper("/tmp/TestSymlinkHdfsDisable");
  Path root=helper.getTestRootPath(fc);
  Path target=new Path(root,"target");
  Path link=new Path(root,"link");
  DFSTestUtil.createFile(dfs,target,4096,(short)1,0xDEADDEAD);
  fc.createSymlink(target,link,false);
  try {
    fc.open(link);
    fail("Expected error when attempting to resolve link");
  }
 catch (  IOException e) {
    GenericTestUtils.assertExceptionContains("resolution is disabled",e);
  }
  try {
    dfs.open(link);
    fail("Expected error when attempting to resolve link");
  }
 catch (  IOException e) {
    GenericTestUtils.assertExceptionContains("resolution is disabled",e);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.fs.TestSymlinkHdfsFileContext </h4><pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test(timeout=1000) public void testAccessLinkFromAbstractFileSystem() throws IOException {
  Path file=new Path(testBaseDir1(),"file");
  Path link=new Path(testBaseDir1(),"linkToFile");
  createAndWriteFile(file);
  wrapper.createSymlink(file,link,false);
  try {
    AbstractFileSystem afs=fc.getDefaultFileSystem();
    afs.open(link);
    fail("Opened a link using AFS");
  }
 catch (  UnresolvedLinkException x) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.fs.TestSymlinkLocalFS </h4><pre class="type-2 type-15 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Sets implicit assumptions ">AssumptionSetter</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Sets implicit assumptions 
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=1000) public void testGetLinkStatusPartQualTarget() throws IOException {
  assumeTrue(!emulatingSymlinksOnWindows());
  Path fileAbs=new Path(testBaseDir1() + "/file");
  Path fileQual=new Path(testURI().toString(),fileAbs);
  Path dir=new Path(testBaseDir1());
  Path link=new Path(testBaseDir1() + "/linkToFile");
  Path dirNew=new Path(testBaseDir2());
  Path linkNew=new Path(testBaseDir2() + "/linkToFile");
  wrapper.delete(dirNew,true);
  createAndWriteFile(fileQual);
  wrapper.setWorkingDirectory(dir);
  wrapper.createSymlink(fileQual,link,false);
  assertEquals(fileQual,wrapper.getFileLinkStatus(link).getSymlink());
  wrapper.rename(dir,dirNew);
  assertEquals(fileQual,wrapper.getFileLinkStatus(linkNew).getSymlink());
  try {
    readFile(linkNew);
    fail("The link should be dangling now.");
  }
 catch (  FileNotFoundException x) {
  }
  Path anotherFs=new Path("hdfs://host:1000/dir/file");
  FileUtil.fullyDelete(new File(linkNew.toString()));
  try {
    wrapper.createSymlink(anotherFs,linkNew,false);
    fail("Created a local fs link to a non-local fs");
  }
 catch (  IOException x) {
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test(timeout=1000) public void testDanglingLinkFilePartQual() throws IOException {
  Path filePartQual=new Path(getScheme() + ":///doesNotExist");
  try {
    wrapper.getFileLinkStatus(filePartQual);
    fail("Got FileStatus for non-existant file");
  }
 catch (  FileNotFoundException f) {
  }
  try {
    wrapper.getLinkTarget(filePartQual);
    fail("Got link target for non-existant file");
  }
 catch (  FileNotFoundException f) {
  }
}

</code></pre>

<br>
<pre class="type-9 type-2 type-7 type-10 type-15 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Sets implicit assumptions ">AssumptionSetter</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Sets implicit assumptions 
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=1000) public void testDanglingLink() throws IOException {
  assumeTrue(!Path.WINDOWS);
  Path fileAbs=new Path(testBaseDir1() + "/file");
  Path fileQual=new Path(testURI().toString(),fileAbs);
  Path link=new Path(testBaseDir1() + "/linkToFile");
  Path linkQual=new Path(testURI().toString(),link.toString());
  wrapper.createSymlink(fileAbs,link,false);
  FileUtil.fullyDelete(new File(link.toUri().getPath()));
  wrapper.createSymlink(fileAbs,link,false);
  try {
    wrapper.getFileStatus(link);
    fail("Got FileStatus for dangling link");
  }
 catch (  FileNotFoundException f) {
  }
  UserGroupInformation user=UserGroupInformation.getCurrentUser();
  FileStatus fsd=wrapper.getFileLinkStatus(link);
  assertEquals(fileQual,fsd.getSymlink());
  assertTrue(fsd.isSymlink());
  assertFalse(fsd.isDirectory());
  assertEquals(user.getUserName(),fsd.getOwner());
  assertEquals(user.getGroupNames()[0],fsd.getGroup());
  assertEquals(linkQual,fsd.getPath());
  try {
    readFile(link);
    fail("Got FileStatus for dangling link");
  }
 catch (  FileNotFoundException f) {
  }
  createAndWriteFile(fileAbs);
  wrapper.getFileStatus(link);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.fs.TestSymlinkLocalFSFileSystem </h4><pre class="type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Override @Test(timeout=10000) public void testRenameSymlinkToItself() throws IOException {
  Path file=new Path(testBaseDir1(),"file");
  createAndWriteFile(file);
  Path link=new Path(testBaseDir1(),"linkToFile1");
  wrapper.createSymlink(file,link,false);
  try {
    wrapper.rename(link,link);
    fail("Failed to get expected IOException");
  }
 catch (  IOException e) {
    assertTrue(unwrapException(e) instanceof FileAlreadyExistsException);
  }
  try {
    wrapper.rename(link,link,Rename.OVERWRITE);
    fail("Failed to get expected IOException");
  }
 catch (  IOException e) {
    assertTrue(unwrapException(e) instanceof FileAlreadyExistsException || unwrapException(e) instanceof FileNotFoundException);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.fs.azure.TestAzureConcurrentOutOfBandIo </h4><pre class="type-9 type-13 type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions in iterations
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testReadOOBWrites() throws Exception {
  byte[] dataBlockWrite=new byte[UPLOAD_BLOCK_SIZE];
  byte[] dataBlockRead=new byte[UPLOAD_BLOCK_SIZE];
  DataOutputStream outputStream=testAccount.getStore().storefile("WASB_String.txt",new PermissionStatus("","",FsPermission.getDefault()));
  Arrays.fill(dataBlockWrite,(byte)255);
  for (int i=0; i < NUMBER_OF_BLOCKS; i++) {
    outputStream.write(dataBlockWrite);
  }
  outputStream.flush();
  outputStream.close();
  DataBlockWriter writeBlockTask=new DataBlockWriter(testAccount,"WASB_String.txt");
  writeBlockTask.startWriting();
  int count=0;
  DataInputStream inputStream=null;
  for (int i=0; i < 5; i++) {
    try {
      inputStream=testAccount.getStore().retrieve("WASB_String.txt",0);
      count=0;
      int c=0;
      while (c >= 0) {
        c=inputStream.read(dataBlockRead,0,UPLOAD_BLOCK_SIZE);
        if (c < 0) {
          break;
        }
        count+=c;
      }
    }
 catch (    IOException e) {
      System.out.println(e.getCause().toString());
      e.printStackTrace();
      fail();
    }
    if (null != inputStream) {
      inputStream.close();
    }
  }
  writeBlockTask.stopWriting();
  assertEquals(NUMBER_OF_BLOCKS * UPLOAD_BLOCK_SIZE,count);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.fs.azure.TestNativeAzureFileSystemFileNameCheck </h4><pre class="type-2 type-7 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testRename() throws Exception {
  Path testFile1=new Path(root + "/testFile1");
  assertTrue(fs.createNewFile(testFile1));
  Path testFile2=new Path(root + "/testFile2");
  fs.rename(testFile1,testFile2);
  assertTrue(!fs.exists(testFile1) && fs.exists(testFile2));
  Path testFile3=new Path(root + "/testFile3:3");
  try {
    fs.rename(testFile2,testFile3);
    fail("Should've thrown.");
  }
 catch (  IOException e) {
  }
  assertTrue(fs.exists(testFile2));
}

</code></pre>

<br>
<pre class="type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testCreate() throws Exception {
  Path testFile1=new Path(root + "/testFile1");
  assertTrue(fs.createNewFile(testFile1));
  Path testFile2=new Path(root + "/testFile2:2");
  try {
    fs.createNewFile(testFile2);
    fail("Should've thrown.");
  }
 catch (  IOException e) {
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testMkdirs() throws Exception {
  Path testFolder1=new Path(root + "/testFolder1");
  assertTrue(fs.mkdirs(testFolder1));
  Path testFolder2=new Path(root + "/testFolder2:2");
  try {
    assertTrue(fs.mkdirs(testFolder2));
    fail("Should've thrown.");
  }
 catch (  IOException e) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.fs.azure.TestShellDecryptionKeyProvider </h4><pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testScriptPathNotSpecified() throws Exception {
  if (!Shell.WINDOWS) {
    return;
  }
  ShellDecryptionKeyProvider provider=new ShellDecryptionKeyProvider();
  Configuration conf=new Configuration();
  String account="testacct";
  String key="key";
  conf.set(SimpleKeyProvider.KEY_ACCOUNT_KEY_PREFIX + account,key);
  try {
    provider.getStorageAccountKey(account,conf);
    Assert.fail("fs.azure.shellkeyprovider.script is not specified, we should throw");
  }
 catch (  KeyProviderException e) {
    LOG.info("Received an expected exception: " + e.getMessage());
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.fs.azure.TestWasbUriAndConfiguration </h4><pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testInvalidKeyProviderNonexistantClass() throws Exception {
  Configuration conf=new Configuration();
  String account="testacct";
  conf.set("fs.azure.account.keyprovider." + account,"org.apache.Nonexistant.Class");
  try {
    AzureNativeFileSystemStore.getAccountKeyFromConfiguration(account,conf);
    Assert.fail("Nonexistant key provider class should have thrown a " + "KeyProviderException");
  }
 catch (  KeyProviderException e) {
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testInvalidKeyProviderWrongClass() throws Exception {
  Configuration conf=new Configuration();
  String account="testacct";
  conf.set("fs.azure.account.keyprovider." + account,"java.lang.String");
  try {
    AzureNativeFileSystemStore.getAccountKeyFromConfiguration(account,conf);
    Assert.fail("Key provider class that doesn't implement KeyProvider " + "should have thrown a KeyProviderException");
  }
 catch (  KeyProviderException e) {
  }
}

</code></pre>

<br>
<pre class="type-9 type-2 type-7 type-1 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Tests the cases when the URI is specified with no authority, i.e.
 * wasb:///path/to/file.
 */
@Test public void testNoUriAuthority() throws Exception {
  String[] wasbAliases=new String[]{"wasb","wasbs"};
  for (  String defaultScheme : wasbAliases) {
    for (    String wantedScheme : wasbAliases) {
      testAccount=AzureBlobStorageTestAccount.createMock();
      Configuration conf=testAccount.getFileSystem().getConf();
      String authority=testAccount.getFileSystem().getUri().getAuthority();
      URI defaultUri=new URI(defaultScheme,authority,null,null,null);
      conf.set("fs.default.name",defaultUri.toString());
      URI wantedUri=new URI(wantedScheme + ":///random/path");
      NativeAzureFileSystem obtained=(NativeAzureFileSystem)FileSystem.get(wantedUri,conf);
      assertNotNull(obtained);
      assertEquals(new URI(wantedScheme,authority,null,null,null),obtained.getUri());
      Path qualified=obtained.makeQualified(new Path(wantedUri));
      assertEquals(new URI(wantedScheme,authority,wantedUri.getPath(),null,null),qualified.toUri());
      testAccount.cleanup();
      FileSystem.closeAll();
    }
  }
  testAccount=AzureBlobStorageTestAccount.createMock();
  Configuration conf=testAccount.getFileSystem().getConf();
  conf.set("fs.default.name","file:///");
  try {
    FileSystem.get(new URI("wasb:///random/path"),conf);
    fail("Should've thrown.");
  }
 catch (  IllegalArgumentException e) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.fs.contract.AbstractContractAppendTest </h4><pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testAppendMissingTarget() throws Throwable {
  try {
    FSDataOutputStream out=getFileSystem().append(target);
    out.close();
    fail("expected a failure");
  }
 catch (  Exception e) {
    handleExpectedException(e);
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testAppendNonexistentFile() throws Throwable {
  try {
    FSDataOutputStream out=getFileSystem().append(target);
    out.close();
    fail("expected a failure");
  }
 catch (  Exception e) {
    handleExpectedException(e);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.fs.contract.AbstractContractConcatTest </h4><pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testConcatMissingTarget() throws Throwable {
  try {
    getFileSystem().concat(target,new Path[]{zeroByteFile});
    fail("expected a failure");
  }
 catch (  Exception e) {
    handleExpectedException(e);
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testConcatEmptyFiles() throws Throwable {
  touch(getFileSystem(),target);
  try {
    getFileSystem().concat(target,new Path[0]);
    fail("expected a failure");
  }
 catch (  Exception e) {
    handleExpectedException(e);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.fs.contract.AbstractContractCreateTest </h4><pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testOverwriteEmptyDirectory() throws Throwable {
  describe("verify trying to create a file over an empty dir fails");
  Path path=path("testOverwriteEmptyDirectory");
  mkdirs(path);
  assertIsDirectory(path);
  byte[] data=dataset(256,'a','z');
  try {
    writeDataset(getFileSystem(),path,data,data.length,1024,true);
    assertIsDirectory(path);
    fail("write of file over empty dir succeeded");
  }
 catch (  FileAlreadyExistsException expected) {
    handleExpectedException(expected);
  }
catch (  FileNotFoundException e) {
    handleRelaxedException("overwriting a dir with a file ","FileAlreadyExistsException",e);
  }
catch (  IOException e) {
    handleRelaxedException("overwriting a dir with a file ","FileAlreadyExistsException",e);
  }
  assertIsDirectory(path);
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testCreateFileOverExistingFileNoOverwrite() throws Throwable {
  describe("Verify overwriting an existing file fails");
  Path path=path("testCreateFileOverExistingFileNoOverwrite");
  byte[] data=dataset(256,'a','z');
  writeDataset(getFileSystem(),path,data,data.length,1024,false);
  byte[] data2=dataset(10 * 1024,'A','Z');
  try {
    writeDataset(getFileSystem(),path,data2,data2.length,1024,false);
    fail("writing without overwrite unexpectedly succeeded");
  }
 catch (  FileAlreadyExistsException expected) {
    handleExpectedException(expected);
  }
catch (  IOException relaxed) {
    handleRelaxedException("Creating a file over a file with overwrite==false","FileAlreadyExistsException",relaxed);
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testOverwriteNonEmptyDirectory() throws Throwable {
  describe("verify trying to create a file over a non-empty dir fails");
  Path path=path("testOverwriteNonEmptyDirectory");
  mkdirs(path);
  try {
    assertIsDirectory(path);
  }
 catch (  AssertionError failure) {
    if (isSupported(IS_BLOBSTORE)) {
      throw new AssumptionViolatedException(failure.toString()).initCause(failure);
    }
    throw failure;
  }
  Path child=new Path(path,"child");
  writeTextFile(getFileSystem(),child,"child file",true);
  byte[] data=dataset(256,'a','z');
  try {
    writeDataset(getFileSystem(),path,data,data.length,1024,true);
    FileStatus status=getFileSystem().getFileStatus(path);
    boolean isDir=status.isDirectory();
    if (!isDir && isSupported(IS_BLOBSTORE)) {
      skip("Object store allows a file to overwrite a directory");
    }
    fail("write of file over dir succeeded");
  }
 catch (  FileAlreadyExistsException expected) {
    handleExpectedException(expected);
  }
catch (  FileNotFoundException e) {
    handleRelaxedException("overwriting a dir with a file ","FileAlreadyExistsException",e);
  }
catch (  IOException e) {
    handleRelaxedException("overwriting a dir with a file ","FileAlreadyExistsException",e);
  }
  assertIsDirectory(path);
  assertIsFile(child);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.fs.contract.AbstractContractDeleteTest </h4><pre class="type-9 type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testDeleteNonEmptyDirNonRecursive() throws Throwable {
  Path path=path("testDeleteNonEmptyDirNonRecursive");
  mkdirs(path);
  Path file=new Path(path,"childfile");
  ContractTestUtils.writeTextFile(getFileSystem(),file,"goodbye, world",true);
  try {
    ContractTestUtils.rejectRootOperation(path);
    boolean deleted=getFileSystem().delete(path,false);
    fail("non recursive delete should have raised an exception," + " but completed with exit code " + deleted);
  }
 catch (  IOException expected) {
    handleExpectedException(expected);
  }
  ContractTestUtils.assertIsDirectory(getFileSystem(),path);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.fs.contract.AbstractContractMkdirTest </h4><pre class="type-2 type-7 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
"></span><br>
@Test public void testNoMkdirOverFile() throws Throwable {
  describe("try to mkdir over a file");
  FileSystem fs=getFileSystem();
  Path path=path("testNoMkdirOverFile");
  byte[] dataset=dataset(1024,' ','z');
  createFile(getFileSystem(),path,false,dataset);
  try {
    boolean made=fs.mkdirs(path);
    fail("mkdirs did not fail over a file but returned " + made + "; "+ ls(path));
  }
 catch (  ParentNotDirectoryException e) {
    handleExpectedException(e);
  }
catch (  FileAlreadyExistsException e) {
    handleExpectedException(e);
    ;
  }
catch (  IOException e) {
    handleRelaxedException("mkdirs","FileAlreadyExistsException",e);
  }
  assertIsFile(path);
  byte[] bytes=ContractTestUtils.readDataset(getFileSystem(),path,dataset.length);
  ContractTestUtils.compareByteArrays(dataset,bytes,dataset.length);
  assertPathExists("mkdir failed",path);
  assertDeleted(path,true);
}

</code></pre>

<br>
<pre class="type-2 type-7 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
"></span><br>
@Test public void testMkdirOverParentFile() throws Throwable {
  describe("try to mkdir where a parent is a file");
  FileSystem fs=getFileSystem();
  Path path=path("testMkdirOverParentFile");
  byte[] dataset=dataset(1024,' ','z');
  createFile(getFileSystem(),path,false,dataset);
  Path child=new Path(path,"child-to-mkdir");
  try {
    boolean made=fs.mkdirs(child);
    fail("mkdirs did not fail over a file but returned " + made + "; "+ ls(path));
  }
 catch (  ParentNotDirectoryException e) {
    handleExpectedException(e);
  }
catch (  FileAlreadyExistsException e) {
    handleExpectedException(e);
  }
catch (  IOException e) {
    handleRelaxedException("mkdirs","ParentNotDirectoryException",e);
  }
  assertIsFile(path);
  byte[] bytes=ContractTestUtils.readDataset(getFileSystem(),path,dataset.length);
  ContractTestUtils.compareByteArrays(dataset,bytes,dataset.length);
  assertPathExists("mkdir failed",path);
  assertDeleted(path,true);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.fs.contract.AbstractContractOpenTest </h4><pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testOpenReadDir() throws Throwable {
  describe("create & read a directory");
  Path path=path("zero.dir");
  mkdirs(path);
  try {
    instream=getFileSystem().open(path);
    fail("A directory has been opened for reading");
  }
 catch (  FileNotFoundException e) {
    handleExpectedException(e);
  }
catch (  IOException e) {
    handleRelaxedException("opening a directory for reading","FileNotFoundException",e);
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testOpenReadDirWithChild() throws Throwable {
  describe("create & read a directory which has a child");
  Path path=path("zero.dir");
  mkdirs(path);
  Path path2=new Path(path,"child");
  mkdirs(path2);
  try {
    instream=getFileSystem().open(path);
    fail("A directory has been opened for reading");
  }
 catch (  FileNotFoundException e) {
    handleExpectedException(e);
  }
catch (  IOException e) {
    handleRelaxedException("opening a directory for reading","FileNotFoundException",e);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.fs.contract.AbstractContractRenameTest </h4><pre class="type-9 type-11 type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Rename test -handles filesystems that will overwrite the destination
 * as well as those that do not (i.e. HDFS).
 * @throws Throwable
 */
@Test public void testRenameFileOverExistingFile() throws Throwable {
  describe("Verify renaming a file onto an existing file matches expectations");
  Path srcFile=path("source-256.txt");
  byte[] srcData=dataset(256,'a','z');
  writeDataset(getFileSystem(),srcFile,srcData,srcData.length,1024,false);
  Path destFile=path("dest-512.txt");
  byte[] destData=dataset(512,'A','Z');
  writeDataset(getFileSystem(),destFile,destData,destData.length,1024,false);
  assertIsFile(destFile);
  boolean renameOverwritesDest=isSupported(RENAME_OVERWRITES_DEST);
  boolean renameReturnsFalseOnRenameDestExists=!isSupported(RENAME_RETURNS_FALSE_IF_DEST_EXISTS);
  boolean destUnchanged=true;
  try {
    boolean renamed=rename(srcFile,destFile);
    if (renameOverwritesDest) {
      assertTrue("Rename returned false",renamed);
      destUnchanged=false;
    }
 else {
      if (renamed && !renameReturnsFalseOnRenameDestExists) {
        String destDirLS=generateAndLogErrorListing(srcFile,destFile);
        getLog().error("dest dir {}",destDirLS);
        fail("expected rename(" + srcFile + ", "+ destFile+ " ) to fail,"+ " but got success and destination of "+ destDirLS);
      }
    }
  }
 catch (  FileAlreadyExistsException e) {
    handleExpectedException(e);
  }
  ContractTestUtils.verifyFileContents(getFileSystem(),destFile,destUnchanged ? destData : srcData);
}

</code></pre>

<br>
<pre class="type-9 type-11 type-2 type-7 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testRenameNonexistentFile() throws Throwable {
  describe("rename a file into a new file in the same directory");
  Path missing=path("testRenameNonexistentFileSrc");
  Path target=path("testRenameNonexistentFileDest");
  boolean renameReturnsFalseOnFailure=isSupported(ContractOptions.RENAME_RETURNS_FALSE_IF_SOURCE_MISSING);
  mkdirs(missing.getParent());
  try {
    boolean renamed=rename(missing,target);
    if (!renameReturnsFalseOnFailure) {
      String destDirLS=generateAndLogErrorListing(missing,target);
      fail("expected rename(" + missing + ", "+ target+ " ) to fail,"+ " got a result of "+ renamed+ " and a destination directory of "+ destDirLS);
    }
 else {
      getLog().warn("Rename returned {} renaming a nonexistent file",renamed);
      assertFalse("Renaming a missing file returned true",renamed);
    }
  }
 catch (  FileNotFoundException e) {
    if (renameReturnsFalseOnFailure) {
      ContractTestUtils.fail("Renaming a missing file unexpectedly threw an exception",e);
    }
    handleExpectedException(e);
  }
catch (  IOException e) {
    handleRelaxedException("rename nonexistent file","FileNotFoundException",e);
  }
  assertPathDoesNotExist("rename nonexistent file created a destination file",target);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.fs.contract.AbstractContractRootDirectoryTest </h4><pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testCreateFileOverRoot() throws Throwable {
  Path root=new Path("/");
  byte[] dataset=dataset(1024,' ','z');
  try {
    createFile(getFileSystem(),root,false,dataset);
    fail("expected an exception, got a file created over root: " + ls(root));
  }
 catch (  IOException e) {
    handleExpectedException(e);
  }
  assertIsDirectory(root);
}

</code></pre>

<br>
<pre class="type-9 type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testRmNonEmptyRootDirNonRecursive() throws Throwable {
  skipIfUnsupported(TEST_ROOT_TESTS_ENABLED);
  Path root=new Path("/");
  String touchfile="/testRmNonEmptyRootDirNonRecursive";
  Path file=new Path(touchfile);
  ContractTestUtils.touch(getFileSystem(),file);
  ContractTestUtils.assertIsDirectory(getFileSystem(),root);
  try {
    boolean deleted=getFileSystem().delete(root,false);
    fail("non recursive delete should have raised an exception," + " but completed with exit code " + deleted);
  }
 catch (  IOException e) {
    handleExpectedException(e);
  }
 finally {
    getFileSystem().delete(file,false);
  }
  ContractTestUtils.assertIsDirectory(getFileSystem(),root);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.fs.contract.AbstractContractSeekTest </h4><pre class="type-9 type-11 type-2 type-7 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
"></span><br>
/** 
 * Seek and read on a closed file.
 * Some filesystems let callers seek on a closed file -these must
 * still fail on the subsequent reads.
 * @throws Throwable
 */
@Test public void testSeekReadClosedFile() throws Throwable {
  boolean supportsSeekOnClosedFiles=isSupported(SUPPORTS_SEEK_ON_CLOSED_FILE);
  instream=getFileSystem().open(smallSeekFile);
  getLog().debug("Stream is of type " + instream.getClass().getCanonicalName());
  instream.close();
  try {
    instream.seek(0);
    if (!supportsSeekOnClosedFiles) {
      fail("seek succeeded on a closed stream");
    }
  }
 catch (  IOException e) {
  }
  try {
    int data=instream.available();
    fail("read() succeeded on a closed stream, got " + data);
  }
 catch (  IOException e) {
  }
  try {
    int data=instream.read();
    fail("read() succeeded on a closed stream, got " + data);
  }
 catch (  IOException e) {
  }
  try {
    byte[] buffer=new byte[1];
    int result=instream.read(buffer,0,1);
    fail("read(buffer, 0, 1) succeeded on a closed stream, got " + result);
  }
 catch (  IOException e) {
  }
  try {
    long offset=instream.getPos();
  }
 catch (  IOException e) {
  }
  instream.close();
}

</code></pre>

<br>
<pre class="type-9 type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testNegativeSeek() throws Throwable {
  instream=getFileSystem().open(smallSeekFile);
  assertEquals(0,instream.getPos());
  try {
    instream.seek(-1);
    long p=instream.getPos();
    LOG.warn("Seek to -1 returned a position of " + p);
    int result=instream.read();
    fail("expected an exception, got data " + result + " at a position of "+ p);
  }
 catch (  EOFException e) {
    handleExpectedException(e);
  }
catch (  IOException e) {
    handleRelaxedException("a negative seek","EOFException",e);
  }
  assertEquals(0,instream.getPos());
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.fs.shell.TestPathData </h4><pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test(timeout=5000) public void testInvalidWindowsPath() throws Exception {
  if (!Path.WINDOWS) {
    return;
  }
  String[] winPaths={"N:\\foo/bar"};
  for (  String path : winPaths) {
    try {
      PathData item=new PathData(path,conf);
      fail("Did not throw for invalid path " + path);
    }
 catch (    IOException ioe) {
    }
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.fs.swift.TestSeek </h4><pre class="type-9 type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=SWIFT_TEST_TIMEOUT) public void testNegativeSeek() throws Throwable {
  instream=fs.open(smallSeekFile);
  assertEquals(0,instream.getPos());
  try {
    instream.seek(-1);
    long p=instream.getPos();
    LOG.warn("Seek to -1 returned a position of " + p);
    int result=instream.read();
    fail("expected an exception, got data " + result + " at a position of "+ p);
  }
 catch (  IOException e) {
  }
  assertEquals(0,instream.getPos());
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.fs.swift.TestSwiftFileSystemBasicOps </h4><pre class="type-9 type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test(timeout=SWIFT_TEST_TIMEOUT) public void testLongObjectNamesForbidden() throws Throwable {
  StringBuilder buffer=new StringBuilder(1200);
  buffer.append("/");
  for (int i=0; i < (1200 / 4); i++) {
    buffer.append(String.format("%04x",i));
  }
  String pathString=buffer.toString();
  Path path=new Path(pathString);
  try {
    writeTextFile(fs,path,pathString,true);
    fs.delete(path,false);
    fail("Managed to create an object with a name of length " + pathString.length());
  }
 catch (  SwiftBadRequestException e) {
  }
}

</code></pre>

<br>
<pre class="type-9 type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test(timeout=SWIFT_TEST_TIMEOUT) public void testLsNonExistentFile() throws Exception {
  try {
    Path path=new Path("/test/hadoop/file");
    FileStatus[] statuses=fs.listStatus(path);
    fail("Should throw FileNotFoundException on " + path + " but got list of length "+ statuses.length);
  }
 catch (  FileNotFoundException fnfe) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.fs.swift.TestSwiftFileSystemBlockLocation </h4><pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test(timeout=SWIFT_TEST_TIMEOUT) public void testLocateNegativeLen() throws Throwable {
  describe("verify that a negative length is illegal");
  try {
    BlockLocation[] locations=getFs().getFileBlockLocations(createFileAndGetStatus(),0,-1);
    fail("Expected an exception, got " + locations.length + " locations");
  }
 catch (  IllegalArgumentException e) {
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test(timeout=SWIFT_TEST_TIMEOUT) public void testLocateNegativeSeek() throws Throwable {
  describe("verify that a negative offset is illegal");
  try {
    BlockLocation[] locations=getFs().getFileBlockLocations(createFileAndGetStatus(),-1,1);
    fail("Expected an exception, got " + locations.length + " locations");
  }
 catch (  IllegalArgumentException e) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.fs.swift.TestSwiftFileSystemDirectories </h4><pre class="type-9 type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test(timeout=SWIFT_TEST_TIMEOUT) public void testNoStatusForMissingDirectories() throws Throwable {
  Path missing=path("/test/testNoStatusForMissingDirectories");
  assertPathDoesNotExist("leftover?",missing);
  try {
    FileStatus[] statuses=fs.listStatus(missing);
    fail("Expected a FileNotFoundException, got the status " + statuses);
  }
 catch (  FileNotFoundException expected) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.fs.swift.TestSwiftFileSystemExtendedContract </h4><pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test(timeout=SWIFT_TEST_TIMEOUT) public void testOpenNonExistingFile() throws IOException {
  final Path p=new Path("/test/testOpenNonExistingFile");
  try {
    final FSDataInputStream in=fs.open(p);
    in.close();
    fail("didn't expect to get here");
  }
 catch (  FileNotFoundException fnfe) {
    LOG.debug("Expected: " + fnfe,fnfe);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.fs.swift.TestSwiftFileSystemRead </h4><pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * Read past the end of a file: expect the operation to fail
 * @throws IOException
 */
@Test(timeout=SWIFT_TEST_TIMEOUT) public void testOverRead() throws IOException {
  final String message="message";
  final Path filePath=new Path("/test/file.txt");
  writeTextFile(fs,filePath,message,false);
  try {
    readBytesToString(fs,filePath,20);
    fail("expected an exception");
  }
 catch (  EOFException e) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.fs.swift.TestSwiftFileSystemRename </h4><pre class="type-9 type-11 type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Rename a file into a directory
 * @throws Exception
 */
@Test(timeout=SWIFT_TEST_TIMEOUT) public void testRenameFileIntoExistingDirectory() throws Exception {
  assumeRenameSupported();
  Path src=path("/test/olddir/file");
  createFile(src);
  Path dst=path("/test/new/newdir");
  fs.mkdirs(dst);
  rename(src,dst,true,false,true);
  Path newFile=path("/test/new/newdir/file");
  if (!fs.exists(newFile)) {
    String ls=ls(dst);
    LOG.info(ls(path("/test/new")));
    LOG.info(ls(path("/test/hadoop")));
    fail("did not find " + newFile + " - directory: "+ ls);
  }
  assertTrue("Destination changed",fs.exists(path("/test/new/newdir/file")));
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.fs.swift.http.TestSwiftRestClient </h4><pre class="type-9 type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test(timeout=SWIFT_TEST_TIMEOUT) public void testPutAndDelete() throws Throwable {
  assumeEnabled();
  SwiftRestClient client=createClient();
  client.authenticate();
  Path path=new Path("restTestPutAndDelete");
  SwiftObjectPath sobject=SwiftObjectPath.fromPath(serviceURI,path);
  byte[] stuff=new byte[1];
  stuff[0]='a';
  client.upload(sobject,new ByteArrayInputStream(stuff),stuff.length);
  Duration head=new Duration();
  Header[] responseHeaders=client.headRequest("expect success",sobject,SwiftRestClient.NEWEST);
  head.finished();
  LOG.info("head request duration " + head);
  for (  Header header : responseHeaders) {
    LOG.info(header.toString());
  }
  client.delete(sobject);
  try {
    Header[] headers=client.headRequest("expect fail",sobject,SwiftRestClient.NEWEST);
    Assert.fail("Expected deleted file, but object is still present: " + sobject);
  }
 catch (  FileNotFoundException e) {
  }
  for (  DurationStats stats : client.getOperationStatistics()) {
    LOG.info(stats);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.fs.viewfs.TestChRootedFs </h4><pre class="type-2 type-7 type-10 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testWorkingDirectory() throws Exception {
  fc.mkdir(new Path("/testWd"),FileContext.DEFAULT_PERM,false);
  Path workDir=new Path("/testWd");
  Path fqWd=fc.makeQualified(workDir);
  fc.setWorkingDirectory(workDir);
  Assert.assertEquals(fqWd,fc.getWorkingDirectory());
  fc.setWorkingDirectory(new Path("."));
  Assert.assertEquals(fqWd,fc.getWorkingDirectory());
  fc.setWorkingDirectory(new Path(".."));
  Assert.assertEquals(fqWd.getParent(),fc.getWorkingDirectory());
  workDir=new Path("/testWd");
  fqWd=fc.makeQualified(workDir);
  fc.setWorkingDirectory(workDir);
  Assert.assertEquals(fqWd,fc.getWorkingDirectory());
  Path relativeDir=new Path("existingDir1");
  Path absoluteDir=new Path(workDir,"existingDir1");
  fc.mkdir(absoluteDir,FileContext.DEFAULT_PERM,true);
  Path fqAbsoluteDir=fc.makeQualified(absoluteDir);
  fc.setWorkingDirectory(relativeDir);
  Assert.assertEquals(fqAbsoluteDir,fc.getWorkingDirectory());
  absoluteDir=new Path("/test/existingDir2");
  fqAbsoluteDir=fc.makeQualified(absoluteDir);
  fc.mkdir(absoluteDir,FileContext.DEFAULT_PERM,true);
  fc.setWorkingDirectory(absoluteDir);
  Assert.assertEquals(fqAbsoluteDir,fc.getWorkingDirectory());
  Path absolutePath=new Path(absoluteDir,"foo");
  fc.create(absolutePath,EnumSet.of(CreateFlag.CREATE)).close();
  fc.open(new Path("foo")).close();
  fc.mkdir(new Path("newDir"),FileContext.DEFAULT_PERM,true);
  Assert.assertTrue(isDir(fc,new Path(absoluteDir,"newDir")));
  absoluteDir=fileContextTestHelper.getTestRootPath(fc,"nonexistingPath");
  try {
    fc.setWorkingDirectory(absoluteDir);
    Assert.fail("cd to non existing dir should have failed");
  }
 catch (  Exception e) {
  }
  final String LOCAL_FS_ROOT_URI="file:///tmp/test";
  absoluteDir=new Path(LOCAL_FS_ROOT_URI + "/existingDir");
  fc.mkdir(absoluteDir,FileContext.DEFAULT_PERM,true);
  fc.setWorkingDirectory(absoluteDir);
  Assert.assertEquals(absoluteDir,fc.getWorkingDirectory());
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.fs.viewfs.TestViewFsDefaultValue </h4><pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test that default blocksize values can be retrieved on the client side.
 */
@Test public void testGetDefaultBlockSize() throws IOException, URISyntaxException {
  try {
    vfs.getDefaultBlockSize();
    fail("getServerDefaults on viewFs did not throw excetion!");
  }
 catch (  NotInMountpointException e) {
    assertEquals(vfs.getDefaultBlockSize(testFilePath),DFS_BLOCK_SIZE_DEFAULT);
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test that server default values can be retrieved on the client side.
 */
@Test public void testServerDefaults() throws IOException {
  try {
    FsServerDefaults serverDefaults=vfs.getServerDefaults();
    fail("getServerDefaults on viewFs did not throw excetion!");
  }
 catch (  NotInMountpointException e) {
    FsServerDefaults serverDefaults=vfs.getServerDefaults(testFilePath);
    assertEquals(DFS_BLOCK_SIZE_DEFAULT,serverDefaults.getBlockSize());
    assertEquals(DFS_BYTES_PER_CHECKSUM_DEFAULT,serverDefaults.getBytesPerChecksum());
    assertEquals(DFS_CLIENT_WRITE_PACKET_SIZE_DEFAULT,serverDefaults.getWritePacketSize());
    assertEquals(IO_FILE_BUFFER_SIZE_DEFAULT,serverDefaults.getFileBufferSize());
    assertEquals(DFS_REPLICATION_DEFAULT + 1,serverDefaults.getReplication());
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test that default replication values can be retrieved on the client side.
 */
@Test public void testGetDefaultReplication() throws IOException, URISyntaxException {
  try {
    vfs.getDefaultReplication();
    fail("getDefaultReplication on viewFs did not throw excetion!");
  }
 catch (  NotInMountpointException e) {
    assertEquals(vfs.getDefaultReplication(testFilePath),DFS_REPLICATION_DEFAULT + 1);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.fs.viewfs.ViewFsBaseTest </h4><pre class="type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testFileStatusOnMountLink() throws IOException {
  Assert.assertTrue("Slash should appear as dir",fcView.getFileStatus(new Path("/")).isDirectory());
  checkFileStatus(fcView,"/",fileType.isDir);
  checkFileStatus(fcView,"/user",fileType.isDir);
  checkFileStatus(fcView,"/data",fileType.isDir);
  checkFileStatus(fcView,"/internalDir",fileType.isDir);
  checkFileStatus(fcView,"/internalDir/linkToDir2",fileType.isDir);
  checkFileStatus(fcView,"/internalDir/internalDir2/linkToDir3",fileType.isDir);
  checkFileStatus(fcView,"/linkToAFile",fileType.isFile);
  try {
    fcView.getFileStatus(new Path("/danglingLink"));
    Assert.fail("Excepted a not found exception here");
  }
 catch (  FileNotFoundException e) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.ha.TestActiveStandbyElector </h4><pre class="type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * verify that receiveActiveData gives data when active exists, tells that
 * active does not exist and reports error in getting active information
 * @throws IOException
 * @throws InterruptedException
 * @throws KeeperException
 * @throws ActiveNotFoundException
 */
@Test public void testGetActiveData() throws ActiveNotFoundException, KeeperException, InterruptedException, IOException {
  byte[] data=new byte[8];
  Mockito.when(mockZK.getData(Mockito.eq(ZK_LOCK_NAME),Mockito.eq(false),Mockito.<Stat>anyObject())).thenReturn(data);
  Assert.assertEquals(data,elector.getActiveData());
  Mockito.verify(mockZK,Mockito.times(1)).getData(Mockito.eq(ZK_LOCK_NAME),Mockito.eq(false),Mockito.<Stat>anyObject());
  Mockito.when(mockZK.getData(Mockito.eq(ZK_LOCK_NAME),Mockito.eq(false),Mockito.<Stat>anyObject())).thenThrow(new KeeperException.NoNodeException());
  try {
    elector.getActiveData();
    Assert.fail("ActiveNotFoundException expected");
  }
 catch (  ActiveNotFoundException e) {
    Mockito.verify(mockZK,Mockito.times(2)).getData(Mockito.eq(ZK_LOCK_NAME),Mockito.eq(false),Mockito.<Stat>anyObject());
  }
  try {
    Mockito.when(mockZK.getData(Mockito.eq(ZK_LOCK_NAME),Mockito.eq(false),Mockito.<Stat>anyObject())).thenThrow(new KeeperException.AuthFailedException());
    elector.getActiveData();
    Assert.fail("KeeperException.AuthFailedException expected");
  }
 catch (  KeeperException.AuthFailedException ke) {
    Mockito.verify(mockZK,Mockito.times(3)).getData(Mockito.eq(ZK_LOCK_NAME),Mockito.eq(false),Mockito.<Stat>anyObject());
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * Test for a bug encountered during development of HADOOP-8163:
 * ensureBaseNode() should throw an exception if it has to retry
 * more than 3 times to create any part of the path.
 */
@Test public void testEnsureBaseNodeFails() throws Exception {
  Mockito.doThrow(new KeeperException.ConnectionLossException()).when(mockZK).create(Mockito.eq(ZK_PARENT_NAME),Mockito.<byte[]>any(),Mockito.eq(Ids.OPEN_ACL_UNSAFE),Mockito.eq(CreateMode.PERSISTENT));
  try {
    elector.ensureParentZNode();
    Assert.fail("Did not throw!");
  }
 catch (  IOException ioe) {
    if (!(ioe.getCause() instanceof KeeperException.ConnectionLossException)) {
      throw ioe;
    }
  }
  Mockito.verify(mockZK,Mockito.times(3)).create(Mockito.eq(ZK_PARENT_NAME),Mockito.<byte[]>any(),Mockito.eq(Ids.OPEN_ACL_UNSAFE),Mockito.eq(CreateMode.PERSISTENT));
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * verify the zookeeper connection establishment
 */
@Test public void testWithoutZKServer() throws Exception {
  try {
    new ActiveStandbyElector("127.0.0.1",2000,ZK_PARENT_NAME,Ids.OPEN_ACL_UNSAFE,Collections.<ZKAuthInfo>emptyList(),mockApp,CommonConfigurationKeys.HA_FC_ELECTOR_ZK_OP_RETRIES_DEFAULT);
    Assert.fail("Did not throw zookeeper connection loss exceptions!");
  }
 catch (  KeeperException ke) {
    GenericTestUtils.assertExceptionContains("ConnectionLoss",ke);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.ha.TestFailoverController </h4><pre class="type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testFailoverToUnhealthyServiceFailsAndFailsback() throws Exception {
  DummyHAService svc1=new DummyHAService(HAServiceState.ACTIVE,svc1Addr);
  DummyHAService svc2=new DummyHAService(HAServiceState.STANDBY,svc2Addr);
  Mockito.doThrow(new HealthCheckFailedException("Failed!")).when(svc2.proxy).monitorHealth();
  svc1.fencer=svc2.fencer=setupFencer(AlwaysSucceedFencer.class.getName());
  try {
    doFailover(svc1,svc2,false,false);
    fail("Failover to unhealthy service");
  }
 catch (  FailoverFailedException ffe) {
  }
  assertEquals(HAServiceState.ACTIVE,svc1.state);
  assertEquals(HAServiceState.STANDBY,svc2.state);
}

</code></pre>

<br>
<pre class="type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testFailoverFromNonExistantServiceWithFencer() throws Exception {
  DummyHAService svc1=spy(new DummyHAService(null,svc1Addr));
  HAServiceProtocol errorThrowingProxy=Mockito.mock(HAServiceProtocol.class,Mockito.withSettings().defaultAnswer(new ThrowsException(new IOException("Could not connect to host"))).extraInterfaces(Closeable.class));
  Mockito.doNothing().when((Closeable)errorThrowingProxy).close();
  Mockito.doReturn(errorThrowingProxy).when(svc1).getProxy(Mockito.<Configuration>any(),Mockito.anyInt());
  DummyHAService svc2=new DummyHAService(HAServiceState.STANDBY,svc2Addr);
  svc1.fencer=svc2.fencer=setupFencer(AlwaysSucceedFencer.class.getName());
  try {
    doFailover(svc1,svc2,false,false);
  }
 catch (  FailoverFailedException ffe) {
    fail("Non-existant active prevented failover");
  }
  Mockito.verify(svc1).getProxy(Mockito.<Configuration>any(),Mockito.eq(CommonConfigurationKeys.HA_FC_GRACEFUL_FENCE_TIMEOUT_DEFAULT));
  assertEquals(HAServiceState.ACTIVE,svc2.state);
}

</code></pre>

<br>
<pre class="type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testFailoverToFaultyServiceFailsbackOK() throws Exception {
  DummyHAService svc1=spy(new DummyHAService(HAServiceState.ACTIVE,svc1Addr));
  DummyHAService svc2=new DummyHAService(HAServiceState.STANDBY,svc2Addr);
  Mockito.doThrow(new ServiceFailedException("Failed!")).when(svc2.proxy).transitionToActive(anyReqInfo());
  svc1.fencer=svc2.fencer=setupFencer(AlwaysSucceedFencer.class.getName());
  try {
    doFailover(svc1,svc2,false,false);
    fail("Failover to already active service");
  }
 catch (  FailoverFailedException ffe) {
  }
  verify(svc1.proxy).transitionToStandby(anyReqInfo());
  verify(svc1.proxy).transitionToActive(anyReqInfo());
  assertEquals(HAServiceState.ACTIVE,svc1.state);
  assertEquals(HAServiceState.STANDBY,svc2.state);
}

</code></pre>

<br>
<pre class="type-2 type-19 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether two objects/variables are the same">IdentityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether two objects/variables are the same
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testFailureToFenceOnFailbackFailsTheFailback() throws Exception {
  DummyHAService svc1=new DummyHAService(HAServiceState.ACTIVE,svc1Addr);
  DummyHAService svc2=new DummyHAService(HAServiceState.STANDBY,svc2Addr);
  Mockito.doThrow(new IOException("Failed!")).when(svc2.proxy).transitionToActive(anyReqInfo());
  svc1.fencer=svc2.fencer=setupFencer(AlwaysFailFencer.class.getName());
  AlwaysFailFencer.fenceCalled=0;
  try {
    doFailover(svc1,svc2,false,false);
    fail("Failed over to service that won't transition to active");
  }
 catch (  FailoverFailedException ffe) {
  }
  assertEquals(HAServiceState.STANDBY,svc1.state);
  assertEquals(1,AlwaysFailFencer.fenceCalled);
  assertSame(svc2,AlwaysFailFencer.fencedSvc);
}

</code></pre>

<br>
<pre class="type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testWeDontFailbackIfActiveWasFenced() throws Exception {
  DummyHAService svc1=new DummyHAService(HAServiceState.ACTIVE,svc1Addr);
  DummyHAService svc2=new DummyHAService(HAServiceState.STANDBY,svc2Addr);
  Mockito.doThrow(new ServiceFailedException("Failed!")).when(svc2.proxy).transitionToActive(anyReqInfo());
  svc1.fencer=svc2.fencer=setupFencer(AlwaysSucceedFencer.class.getName());
  try {
    doFailover(svc1,svc2,true,false);
    fail("Failed over to service that won't transition to active");
  }
 catch (  FailoverFailedException ffe) {
  }
  assertEquals(HAServiceState.STANDBY,svc1.state);
  assertEquals(HAServiceState.STANDBY,svc2.state);
}

</code></pre>

<br>
<pre class="type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testFailoverWithoutPermission() throws Exception {
  DummyHAService svc1=new DummyHAService(HAServiceState.ACTIVE,svc1Addr);
  Mockito.doThrow(new AccessControlException("Access denied")).when(svc1.proxy).getServiceStatus();
  DummyHAService svc2=new DummyHAService(HAServiceState.STANDBY,svc2Addr);
  Mockito.doThrow(new AccessControlException("Access denied")).when(svc2.proxy).getServiceStatus();
  svc1.fencer=svc2.fencer=setupFencer(AlwaysSucceedFencer.class.getName());
  try {
    doFailover(svc1,svc2,false,false);
    fail("Can't failover when access is denied");
  }
 catch (  FailoverFailedException ffe) {
    assertTrue(ffe.getCause().getMessage().contains("Access denied"));
  }
}

</code></pre>

<br>
<pre class="type-2 type-19 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether two objects/variables are the same">IdentityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether two objects/variables are the same
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testFencingFailureDuringFailover() throws Exception {
  DummyHAService svc1=new DummyHAService(HAServiceState.ACTIVE,svc1Addr);
  DummyHAService svc2=new DummyHAService(HAServiceState.STANDBY,svc2Addr);
  svc1.fencer=svc2.fencer=setupFencer(AlwaysFailFencer.class.getName());
  AlwaysFailFencer.fenceCalled=0;
  try {
    doFailover(svc1,svc2,true,false);
    fail("Failed over even though fencing requested and failed");
  }
 catch (  FailoverFailedException ffe) {
  }
  assertEquals(1,AlwaysFailFencer.fenceCalled);
  assertSame(svc1,AlwaysFailFencer.fencedSvc);
  assertEquals(HAServiceState.STANDBY,svc1.state);
  assertEquals(HAServiceState.STANDBY,svc2.state);
}

</code></pre>

<br>
<pre class="type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testFailoverToNonExistantServiceFails() throws Exception {
  DummyHAService svc1=new DummyHAService(HAServiceState.ACTIVE,svc1Addr);
  DummyHAService svc2=spy(new DummyHAService(null,svc2Addr));
  Mockito.doThrow(new IOException("Failed to connect")).when(svc2).getProxy(Mockito.<Configuration>any(),Mockito.anyInt());
  svc1.fencer=svc2.fencer=setupFencer(AlwaysSucceedFencer.class.getName());
  try {
    doFailover(svc1,svc2,false,false);
    fail("Failed over to a non-existant standby");
  }
 catch (  FailoverFailedException ffe) {
  }
  assertEquals(HAServiceState.ACTIVE,svc1.state);
}

</code></pre>

<br>
<pre class="type-2 type-19 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether two objects/variables are the same">IdentityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether two objects/variables are the same
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testFailoverFromFaultyServiceFencingFailure() throws Exception {
  DummyHAService svc1=new DummyHAService(HAServiceState.ACTIVE,svc1Addr);
  Mockito.doThrow(new ServiceFailedException("Failed!")).when(svc1.proxy).transitionToStandby(anyReqInfo());
  DummyHAService svc2=new DummyHAService(HAServiceState.STANDBY,svc2Addr);
  svc1.fencer=svc2.fencer=setupFencer(AlwaysFailFencer.class.getName());
  AlwaysFailFencer.fenceCalled=0;
  try {
    doFailover(svc1,svc2,false,false);
    fail("Failed over even though fencing failed");
  }
 catch (  FailoverFailedException ffe) {
  }
  assertEquals(1,AlwaysFailFencer.fenceCalled);
  assertSame(svc1,AlwaysFailFencer.fencedSvc);
  assertEquals(HAServiceState.ACTIVE,svc1.state);
  assertEquals(HAServiceState.STANDBY,svc2.state);
}

</code></pre>

<br>
<pre class="type-2 type-19 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether two objects/variables are the same">IdentityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether two objects/variables are the same
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testWeFenceOnFailbackIfTransitionToActiveFails() throws Exception {
  DummyHAService svc1=new DummyHAService(HAServiceState.ACTIVE,svc1Addr);
  DummyHAService svc2=new DummyHAService(HAServiceState.STANDBY,svc2Addr);
  Mockito.doThrow(new ServiceFailedException("Failed!")).when(svc2.proxy).transitionToActive(anyReqInfo());
  svc1.fencer=svc2.fencer=setupFencer(AlwaysSucceedFencer.class.getName());
  AlwaysSucceedFencer.fenceCalled=0;
  try {
    doFailover(svc1,svc2,false,false);
    fail("Failed over to service that won't transition to active");
  }
 catch (  FailoverFailedException ffe) {
  }
  assertEquals(HAServiceState.ACTIVE,svc1.state);
  assertEquals(1,AlwaysSucceedFencer.fenceCalled);
  assertSame(svc2,AlwaysSucceedFencer.fencedSvc);
}

</code></pre>

<br>
<pre class="type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testFailoverToUnreadyService() throws Exception {
  DummyHAService svc1=new DummyHAService(HAServiceState.ACTIVE,svc1Addr);
  DummyHAService svc2=new DummyHAService(HAServiceState.STANDBY,svc2Addr);
  Mockito.doReturn(STATE_NOT_READY).when(svc2.proxy).getServiceStatus();
  svc1.fencer=svc2.fencer=setupFencer(AlwaysSucceedFencer.class.getName());
  try {
    doFailover(svc1,svc2,false,false);
    fail("Can't failover to a service that's not ready");
  }
 catch (  FailoverFailedException ffe) {
    if (!ffe.getMessage().contains("injected not ready")) {
      throw ffe;
    }
  }
  assertEquals(HAServiceState.ACTIVE,svc1.state);
  assertEquals(HAServiceState.STANDBY,svc2.state);
  doFailover(svc1,svc2,false,true);
  assertEquals(HAServiceState.STANDBY,svc1.state);
  assertEquals(HAServiceState.ACTIVE,svc2.state);
}

</code></pre>

<br>
<pre class="type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testFailbackToFaultyServiceFails() throws Exception {
  DummyHAService svc1=new DummyHAService(HAServiceState.ACTIVE,svc1Addr);
  Mockito.doThrow(new ServiceFailedException("Failed!")).when(svc1.proxy).transitionToActive(anyReqInfo());
  DummyHAService svc2=new DummyHAService(HAServiceState.STANDBY,svc2Addr);
  Mockito.doThrow(new ServiceFailedException("Failed!")).when(svc2.proxy).transitionToActive(anyReqInfo());
  svc1.fencer=svc2.fencer=setupFencer(AlwaysSucceedFencer.class.getName());
  try {
    doFailover(svc1,svc2,false,false);
    fail("Failover to already active service");
  }
 catch (  FailoverFailedException ffe) {
  }
  assertEquals(HAServiceState.STANDBY,svc1.state);
  assertEquals(HAServiceState.STANDBY,svc2.state);
}

</code></pre>

<br>
<pre class="type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testSelfFailoverFails() throws Exception {
  DummyHAService svc1=new DummyHAService(HAServiceState.ACTIVE,svc1Addr);
  DummyHAService svc2=new DummyHAService(HAServiceState.STANDBY,svc2Addr);
  svc1.fencer=svc2.fencer=setupFencer(AlwaysSucceedFencer.class.getName());
  AlwaysSucceedFencer.fenceCalled=0;
  try {
    doFailover(svc1,svc1,false,false);
    fail("Can't failover to yourself");
  }
 catch (  FailoverFailedException ffe) {
  }
  assertEquals(0,TestNodeFencer.AlwaysSucceedFencer.fenceCalled);
  assertEquals(HAServiceState.ACTIVE,svc1.state);
  try {
    doFailover(svc2,svc2,false,false);
    fail("Can't failover to yourself");
  }
 catch (  FailoverFailedException ffe) {
  }
  assertEquals(0,TestNodeFencer.AlwaysSucceedFencer.fenceCalled);
  assertEquals(HAServiceState.STANDBY,svc2.state);
}

</code></pre>

<br>
<pre class="type-2 type-19 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether two objects/variables are the same">IdentityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether two objects/variables are the same
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testFailoverFromFaultyServiceSucceeds() throws Exception {
  DummyHAService svc1=new DummyHAService(HAServiceState.ACTIVE,svc1Addr);
  Mockito.doThrow(new ServiceFailedException("Failed!")).when(svc1.proxy).transitionToStandby(anyReqInfo());
  DummyHAService svc2=new DummyHAService(HAServiceState.STANDBY,svc2Addr);
  svc1.fencer=svc2.fencer=setupFencer(AlwaysSucceedFencer.class.getName());
  AlwaysSucceedFencer.fenceCalled=0;
  try {
    doFailover(svc1,svc2,false,false);
  }
 catch (  FailoverFailedException ffe) {
    fail("Faulty active prevented failover");
  }
  assertEquals(1,AlwaysSucceedFencer.fenceCalled);
  assertSame(svc1,AlwaysSucceedFencer.fencedSvc);
  assertEquals(HAServiceState.ACTIVE,svc1.state);
  assertEquals(HAServiceState.ACTIVE,svc2.state);
}

</code></pre>

<br>
<pre class="type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testFailoverFromActiveToActive() throws Exception {
  DummyHAService svc1=new DummyHAService(HAServiceState.ACTIVE,svc1Addr);
  DummyHAService svc2=new DummyHAService(HAServiceState.ACTIVE,svc2Addr);
  svc1.fencer=svc2.fencer=setupFencer(AlwaysSucceedFencer.class.getName());
  try {
    doFailover(svc1,svc2,false,false);
    fail("Can't failover to an already active service");
  }
 catch (  FailoverFailedException ffe) {
  }
  assertEquals(HAServiceState.ACTIVE,svc1.state);
  assertEquals(HAServiceState.ACTIVE,svc2.state);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.ha.TestShellCommandFencer </h4><pre class="type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testCheckParensNoArgs(){
  try {
    Configuration conf=new Configuration();
    new NodeFencer(conf,"shell()");
    fail("Didn't throw when passing no args to shell");
  }
 catch (  BadFencingConfigurationException confe) {
    assertTrue("Unexpected exception:" + StringUtils.stringifyException(confe),confe.getMessage().contains("Unable to parse line: 'shell()'"));
  }
}

</code></pre>

<br>
<pre class="type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testCheckNoArgs(){
  try {
    Configuration conf=new Configuration();
    new NodeFencer(conf,"shell");
    fail("Didn't throw when passing no args to shell");
  }
 catch (  BadFencingConfigurationException confe) {
    assertTrue("Unexpected exception:" + StringUtils.stringifyException(confe),confe.getMessage().contains("No argument passed"));
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.ha.TestZKFailoverController </h4><pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test(timeout=15000) public void testGracefulFailoverToUnhealthy() throws Exception {
  try {
    cluster.start();
    cluster.waitForActiveLockHolder(0);
    cluster.setHealthy(1,false);
    cluster.waitForElectorState(1,ActiveStandbyElector.State.INIT);
    try {
      cluster.getService(1).getZKFCProxy(conf,5000).gracefulFailover();
      fail("Did not fail to graceful failover to unhealthy service!");
    }
 catch (    ServiceFailedException sfe) {
      GenericTestUtils.assertExceptionContains(cluster.getService(1).toString() + " is not currently healthy.",sfe);
    }
  }
  finally {
    cluster.stop();
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test(timeout=15000) public void testGracefulFailoverFailBecomingStandbyAndFailFence() throws Exception {
  try {
    cluster.start();
    cluster.waitForActiveLockHolder(0);
    cluster.setFailToBecomeStandby(0,true);
    cluster.setFailToFence(0,true);
    try {
      cluster.getService(1).getZKFCProxy(conf,5000).gracefulFailover();
      fail("Failover should have failed when old node wont fence");
    }
 catch (    ServiceFailedException sfe) {
      GenericTestUtils.assertExceptionContains("Unable to fence " + cluster.getService(0),sfe);
    }
  }
  finally {
    cluster.stop();
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=15000) public void testGracefulFailoverFailBecomingActive() throws Exception {
  try {
    cluster.start();
    cluster.waitForActiveLockHolder(0);
    cluster.setFailToBecomeActive(1,true);
    try {
      cluster.getService(1).getZKFCProxy(conf,5000).gracefulFailover();
      fail("Did not fail to graceful failover when target failed " + "to become active!");
    }
 catch (    ServiceFailedException sfe) {
      GenericTestUtils.assertExceptionContains("Couldn't make " + cluster.getService(1) + " active",sfe);
      GenericTestUtils.assertExceptionContains("injected failure",sfe);
    }
    assertEquals(0,cluster.getService(0).fenceCount);
    assertEquals(0,cluster.getService(1).fenceCount);
    cluster.waitForActiveLockHolder(0);
  }
  finally {
    cluster.stop();
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test that, if ACLs are specified in the configuration, that
 * it sets the ACLs when formatting the parent node.
 */
@Test(timeout=15000) public void testFormatSetsAcls() throws Exception {
  DummyHAService svc=cluster.getService(1);
  assertEquals(0,runFC(svc,"-formatZK"));
  ZooKeeper otherClient=createClient();
  try {
    Stat stat=new Stat();
    otherClient.getData(ZKFailoverController.ZK_PARENT_ZNODE_DEFAULT,false,stat);
    fail("Was able to read data without authenticating!");
  }
 catch (  KeeperException.NoAuthException nae) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.TestAbandonBlock </h4><pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testQuotaUpdatedWhenBlockAbandoned() throws IOException {
  fs.setQuota(new Path("/"),HdfsConstants.QUOTA_DONT_SET,3 * 1024 * 1024);
  String src=FILE_NAME_PREFIX + "test_quota1";
  FSDataOutputStream fout=fs.create(new Path(src),true,4096,(short)2,1024 * 1024);
  for (int i=0; i < 1024; i++) {
    fout.writeByte(123);
  }
  cluster.getDataNodes().get(0).shutdown();
  try {
    fout.close();
  }
 catch (  QuotaExceededException e) {
    fail("Unexpected quota exception when closing fout");
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.TestBlockReaderFactory </h4><pre class="type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test the case where we have a failure to complete a short circuit read
 * that occurs, and then later on, we have a success.
 * Any thread waiting on a cache load should receive the failure (if it
 * occurs);  however, the failure result should not be cached.  We want 
 * to be able to retry later and succeed.
 */
@Test(timeout=60000) public void testShortCircuitCacheTemporaryFailure() throws Exception {
  BlockReaderTestUtil.enableBlockReaderFactoryTracing();
  final AtomicBoolean replicaCreationShouldFail=new AtomicBoolean(true);
  final AtomicBoolean testFailed=new AtomicBoolean(false);
  DFSInputStream.tcpReadsDisabledForTesting=true;
  BlockReaderFactory.createShortCircuitReplicaInfoCallback=new ShortCircuitCache.ShortCircuitReplicaCreator(){
    @Override public ShortCircuitReplicaInfo createShortCircuitReplicaInfo(){
      if (replicaCreationShouldFail.get()) {
        Uninterruptibles.sleepUninterruptibly(2,TimeUnit.SECONDS);
        return new ShortCircuitReplicaInfo();
      }
      return null;
    }
  }
;
  TemporarySocketDirectory sockDir=new TemporarySocketDirectory();
  Configuration conf=createShortCircuitConf("testShortCircuitCacheTemporaryFailure",sockDir);
  final MiniDFSCluster cluster=new MiniDFSCluster.Builder(conf).numDataNodes(1).build();
  cluster.waitActive();
  final DistributedFileSystem dfs=cluster.getFileSystem();
  final String TEST_FILE="/test_file";
  final int TEST_FILE_LEN=4000;
  final int NUM_THREADS=2;
  final int SEED=0xFADED;
  final CountDownLatch gotFailureLatch=new CountDownLatch(NUM_THREADS);
  final CountDownLatch shouldRetryLatch=new CountDownLatch(1);
  DFSTestUtil.createFile(dfs,new Path(TEST_FILE),TEST_FILE_LEN,(short)1,SEED);
  Runnable readerRunnable=new Runnable(){
    @Override public void run(){
      try {
        List<LocatedBlock> locatedBlocks=cluster.getNameNode().getRpcServer().getBlockLocations(TEST_FILE,0,TEST_FILE_LEN).getLocatedBlocks();
        LocatedBlock lblock=locatedBlocks.get(0);
        BlockReader blockReader=null;
        try {
          blockReader=BlockReaderTestUtil.getBlockReader(cluster,lblock,0,TEST_FILE_LEN);
          Assert.fail("expected getBlockReader to fail the first time.");
        }
 catch (        Throwable t) {
          Assert.assertTrue("expected to see 'TCP reads were disabled " + "for testing' in exception " + t,t.getMessage().contains("TCP reads were disabled for testing"));
        }
 finally {
          if (blockReader != null)           blockReader.close();
        }
        gotFailureLatch.countDown();
        shouldRetryLatch.await();
        try {
          blockReader=BlockReaderTestUtil.getBlockReader(cluster,lblock,0,TEST_FILE_LEN);
        }
 catch (        Throwable t) {
          LOG.error("error trying to retrieve a block reader " + "the second time.",t);
          throw t;
        }
 finally {
          if (blockReader != null)           blockReader.close();
        }
      }
 catch (      Throwable t) {
        LOG.error("getBlockReader failure",t);
        testFailed.set(true);
      }
    }
  }
;
  Thread threads[]=new Thread[NUM_THREADS];
  for (int i=0; i < NUM_THREADS; i++) {
    threads[i]=new Thread(readerRunnable);
    threads[i].start();
  }
  gotFailureLatch.await();
  replicaCreationShouldFail.set(false);
  shouldRetryLatch.countDown();
  for (int i=0; i < NUM_THREADS; i++) {
    Uninterruptibles.joinUninterruptibly(threads[i]);
  }
  cluster.shutdown();
  sockDir.close();
  Assert.assertFalse(testFailed.get());
}

</code></pre>

<br>
<pre class="type-9 type-11 type-2 type-7 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test the case where we have multiple threads waiting on the
 * ShortCircuitCache delivering a certain ShortCircuitReplica.
 * In this case, there should only be one call to
 * createShortCircuitReplicaInfo.  This one replica should be shared
 * by all threads.
 */
@Test(timeout=60000) public void testMultipleWaitersOnShortCircuitCache() throws Exception {
  final CountDownLatch latch=new CountDownLatch(1);
  final AtomicBoolean creationIsBlocked=new AtomicBoolean(true);
  final AtomicBoolean testFailed=new AtomicBoolean(false);
  DFSInputStream.tcpReadsDisabledForTesting=true;
  BlockReaderFactory.createShortCircuitReplicaInfoCallback=new ShortCircuitCache.ShortCircuitReplicaCreator(){
    @Override public ShortCircuitReplicaInfo createShortCircuitReplicaInfo(){
      Uninterruptibles.awaitUninterruptibly(latch);
      if (!creationIsBlocked.compareAndSet(true,false)) {
        Assert.fail("there were multiple calls to " + "createShortCircuitReplicaInfo.  Only one was expected.");
      }
      return null;
    }
  }
;
  TemporarySocketDirectory sockDir=new TemporarySocketDirectory();
  Configuration conf=createShortCircuitConf("testMultipleWaitersOnShortCircuitCache",sockDir);
  MiniDFSCluster cluster=new MiniDFSCluster.Builder(conf).numDataNodes(1).build();
  cluster.waitActive();
  final DistributedFileSystem dfs=cluster.getFileSystem();
  final String TEST_FILE="/test_file";
  final int TEST_FILE_LEN=4000;
  final int SEED=0xFADED;
  final int NUM_THREADS=10;
  DFSTestUtil.createFile(dfs,new Path(TEST_FILE),TEST_FILE_LEN,(short)1,SEED);
  Runnable readerRunnable=new Runnable(){
    @Override public void run(){
      try {
        byte contents[]=DFSTestUtil.readFileBuffer(dfs,new Path(TEST_FILE));
        Assert.assertFalse(creationIsBlocked.get());
        byte expected[]=DFSTestUtil.calculateFileContentsFromSeed(SEED,TEST_FILE_LEN);
        Assert.assertTrue(Arrays.equals(contents,expected));
      }
 catch (      Throwable e) {
        LOG.error("readerRunnable error",e);
        testFailed.set(true);
      }
    }
  }
;
  Thread threads[]=new Thread[NUM_THREADS];
  for (int i=0; i < NUM_THREADS; i++) {
    threads[i]=new Thread(readerRunnable);
    threads[i].start();
  }
  Thread.sleep(500);
  latch.countDown();
  for (int i=0; i < NUM_THREADS; i++) {
    Uninterruptibles.joinUninterruptibly(threads[i]);
  }
  cluster.shutdown();
  sockDir.close();
  Assert.assertFalse(testFailed.get());
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.TestClientProtocolForPipelineRecovery </h4><pre class="type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testGetNewStamp() throws IOException {
  int numDataNodes=1;
  Configuration conf=new HdfsConfiguration();
  MiniDFSCluster cluster=new MiniDFSCluster.Builder(conf).numDataNodes(numDataNodes).build();
  try {
    cluster.waitActive();
    FileSystem fileSys=cluster.getFileSystem();
    NamenodeProtocols namenode=cluster.getNameNodeRpc();
    Path file=new Path("dataprotocol.dat");
    DFSTestUtil.createFile(fileSys,file,1L,(short)numDataNodes,0L);
    ExtendedBlock firstBlock=DFSTestUtil.getFirstBlock(fileSys,file);
    try {
      namenode.updateBlockForPipeline(firstBlock,"");
      Assert.fail("Can not get a new GS from a finalized block");
    }
 catch (    IOException e) {
      Assert.assertTrue(e.getMessage().contains("is not under Construction"));
    }
    try {
      long newBlockId=firstBlock.getBlockId() + 1;
      ExtendedBlock newBlock=new ExtendedBlock(firstBlock.getBlockPoolId(),newBlockId,0,firstBlock.getGenerationStamp());
      namenode.updateBlockForPipeline(newBlock,"");
      Assert.fail("Cannot get a new GS from a non-existent block");
    }
 catch (    IOException e) {
      Assert.assertTrue(e.getMessage().contains("does not exist"));
    }
    DFSOutputStream out=null;
    try {
      out=(DFSOutputStream)(fileSys.append(file).getWrappedStream());
      out.write(1);
      out.hflush();
      FSDataInputStream in=null;
      try {
        in=fileSys.open(file);
        firstBlock=DFSTestUtil.getAllBlocks(in).get(0).getBlock();
      }
  finally {
        IOUtils.closeStream(in);
      }
      DFSClient dfs=((DistributedFileSystem)fileSys).dfs;
      try {
        namenode.updateBlockForPipeline(firstBlock,"test" + dfs.clientName);
        Assert.fail("Cannot get a new GS for a non lease holder");
      }
 catch (      LeaseExpiredException e) {
        Assert.assertTrue(e.getMessage().startsWith("Lease mismatch"));
      }
      try {
        namenode.updateBlockForPipeline(firstBlock,null);
        Assert.fail("Cannot get a new GS for a null lease holder");
      }
 catch (      LeaseExpiredException e) {
        Assert.assertTrue(e.getMessage().startsWith("Lease mismatch"));
      }
      namenode.updateBlockForPipeline(firstBlock,dfs.clientName);
    }
  finally {
      IOUtils.closeStream(out);
    }
  }
  finally {
    cluster.shutdown();
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * Test whether corrupt replicas are detected correctly during pipeline
 * recoveries.
 */
@Test public void testPipelineRecoveryForLastBlock() throws IOException {
  DFSClientFaultInjector faultInjector=Mockito.mock(DFSClientFaultInjector.class);
  DFSClientFaultInjector oldInjector=DFSClientFaultInjector.instance;
  DFSClientFaultInjector.instance=faultInjector;
  Configuration conf=new HdfsConfiguration();
  conf.setInt(DFSConfigKeys.DFS_CLIENT_BLOCK_WRITE_LOCATEFOLLOWINGBLOCK_RETRIES_KEY,3);
  MiniDFSCluster cluster=null;
  try {
    int numDataNodes=3;
    cluster=new MiniDFSCluster.Builder(conf).numDataNodes(numDataNodes).build();
    cluster.waitActive();
    FileSystem fileSys=cluster.getFileSystem();
    Path file=new Path("dataprotocol1.dat");
    Mockito.when(faultInjector.failPacket()).thenReturn(true);
    DFSTestUtil.createFile(fileSys,file,68000000L,(short)numDataNodes,0L);
    FSDataInputStream in=fileSys.open(file);
    try {
      int c=in.read();
    }
 catch (    org.apache.hadoop.hdfs.BlockMissingException bme) {
      Assert.fail("Block is missing because the file was closed with" + " corrupt replicas.");
    }
  }
  finally {
    DFSClientFaultInjector.instance=oldInjector;
    if (cluster != null) {
      cluster.shutdown();
    }
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.TestClose </h4><pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testWriteAfterClose() throws IOException {
  Configuration conf=new Configuration();
  MiniDFSCluster cluster=new MiniDFSCluster.Builder(conf).build();
  try {
    final byte[] data="foo".getBytes();
    FileSystem fs=FileSystem.get(conf);
    OutputStream out=fs.create(new Path("/test"));
    out.write(data);
    out.close();
    try {
      out.write(data);
      fail("Should not have been able to write more data after file is closed.");
    }
 catch (    ClosedChannelException cce) {
    }
    out.close();
  }
  finally {
    if (cluster != null) {
      cluster.shutdown();
    }
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.TestCrcCorruption </h4><pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * Test case for data corruption during data transmission for
 * create/write. To recover from corruption while writing, at
 * least two replicas are needed.
 */
@Test(timeout=50000) public void testCorruptionDuringWrt() throws Exception {
  Configuration conf=new HdfsConfiguration();
  conf.setInt(DFSConfigKeys.DFS_CLIENT_RETRY_WINDOW_BASE,10);
  MiniDFSCluster cluster=null;
  try {
    cluster=new MiniDFSCluster.Builder(conf).numDataNodes(10).build();
    cluster.waitActive();
    FileSystem fs=cluster.getFileSystem();
    Path file=new Path("/test_corruption_file");
    FSDataOutputStream out=fs.create(file,true,8192,(short)3,(long)(128 * 1024 * 1024));
    byte[] data=new byte[65536];
    for (int i=0; i < 65536; i++) {
      data[i]=(byte)(i % 256);
    }
    for (int i=0; i < 5; i++) {
      out.write(data,0,65535);
    }
    out.hflush();
    Mockito.when(faultInjector.corruptPacket()).thenReturn(true,false);
    Mockito.when(faultInjector.uncorruptPacket()).thenReturn(true,false);
    for (int i=0; i < 5; i++) {
      out.write(data,0,65535);
    }
    out.close();
    FSDataInputStream in=fs.open(file);
    for (int c; (c=in.read()) != -1; )     ;
    in.close();
    out=fs.create(file,true,8192,(short)3,(long)(128 * 1024 * 1024));
    Mockito.when(faultInjector.corruptPacket()).thenReturn(true,false);
    Mockito.when(faultInjector.uncorruptPacket()).thenReturn(false);
    try {
      for (int i=0; i < 5; i++) {
        out.write(data,0,65535);
      }
      out.close();
      fail("Write did not fail");
    }
 catch (    IOException ioe) {
      DFSClient.LOG.info("Got expected exception",ioe);
    }
  }
  finally {
    if (cluster != null) {
      cluster.shutdown();
    }
    Mockito.when(faultInjector.corruptPacket()).thenReturn(false);
    Mockito.when(faultInjector.uncorruptPacket()).thenReturn(false);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.TestDFSClientExcludedNodes </h4><pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testExcludedNodesForgiveness() throws IOException {
  conf.setLong(DFSConfigKeys.DFS_CLIENT_WRITE_EXCLUDE_NODES_CACHE_EXPIRY_INTERVAL,2500);
  conf.setInt("io.bytes.per.checksum",512);
  cluster=new MiniDFSCluster.Builder(conf).numDataNodes(3).build();
  List<DataNodeProperties> props=cluster.dataNodes;
  FileSystem fs=cluster.getFileSystem();
  Path filePath=new Path("/testForgivingExcludedNodes");
  byte[] bytes=new byte[256];
  for (int index=0; index < bytes.length; index++) {
    bytes[index]='0';
  }
  FSDataOutputStream out=fs.create(filePath,true,4096,(short)3,512);
  out.write(bytes);
  out.write(bytes);
  out.hflush();
  DataNodeProperties two=cluster.stopDataNode(2);
  DataNodeProperties one=cluster.stopDataNode(1);
  out.write(bytes);
  out.write(bytes);
  out.hflush();
  Assert.assertEquals(true,cluster.restartDataNode(one,true));
  Assert.assertEquals(true,cluster.restartDataNode(two,true));
  cluster.waitActive();
  ThreadUtil.sleepAtLeastIgnoreInterrupts(5000);
  cluster.stopDataNode(0);
  try {
    out.write(bytes);
    out.hflush();
    out.close();
  }
 catch (  Exception e) {
    fail("Excluded DataNodes should be forgiven after a while and " + "not cause file writing exception of: '" + e.getMessage() + "'");
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test(timeout=60000) public void testExcludedNodes() throws IOException {
  cluster=new MiniDFSCluster.Builder(conf).numDataNodes(3).build();
  FileSystem fs=cluster.getFileSystem();
  Path filePath=new Path("/testExcludedNodes");
  cluster.stopDataNode(AppendTestUtil.nextInt(3));
  OutputStream out=fs.create(filePath,true,4096,(short)3,fs.getDefaultBlockSize(filePath));
  out.write(20);
  try {
    out.close();
  }
 catch (  Exception e) {
    fail("Single DN failure should not result in a block abort: \n" + e.getMessage());
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.TestDFSClientFailover </h4><pre class="type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Make sure that a helpful error message is shown if a proxy provider is
 * configured for a given URI, but no actual addresses are configured for that
 * URI.
 */
@Test public void testFailureWithMisconfiguredHaNNs() throws Exception {
  String logicalHost="misconfigured-ha-uri";
  Configuration conf=new Configuration();
  conf.set(DFS_CLIENT_FAILOVER_PROXY_PROVIDER_KEY_PREFIX + "." + logicalHost,ConfiguredFailoverProxyProvider.class.getName());
  URI uri=new URI("hdfs://" + logicalHost + "/test");
  try {
    FileSystem.get(uri,conf).exists(new Path("/test"));
    fail("Successfully got proxy provider for misconfigured FS");
  }
 catch (  IOException ioe) {
    LOG.info("got expected exception",ioe);
    assertTrue("expected exception did not contain helpful message",StringUtils.stringifyException(ioe).contains("Could not find any configured addresses for URI " + uri));
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * Regression test for HDFS-2683.
 */
@Test public void testLogicalUriShouldNotHavePorts(){
  Configuration config=new HdfsConfiguration(conf);
  String logicalName=HATestUtil.getLogicalHostname(cluster);
  HATestUtil.setFailoverConfigurations(cluster,config,logicalName);
  Path p=new Path("hdfs://" + logicalName + ":12345/");
  try {
    p.getFileSystem(config).exists(p);
    fail("Did not fail with fake FS");
  }
 catch (  IOException ioe) {
    GenericTestUtils.assertExceptionContains("does not use port information",ioe);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.TestDFSClientRetries </h4><pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * Test that timeout occurs when DN does not respond to RPC.
 * Start up a server and ask it to sleep for n seconds. Make an
 * RPC to the server and set rpcTimeout to less than n and ensure
 * that socketTimeoutException is obtained
 */
@Test public void testClientDNProtocolTimeout() throws IOException {
  final Server server=new TestServer(1,true);
  server.start();
  final InetSocketAddress addr=NetUtils.getConnectAddress(server);
  DatanodeID fakeDnId=DFSTestUtil.getLocalDatanodeID(addr.getPort());
  ExtendedBlock b=new ExtendedBlock("fake-pool",new Block(12345L));
  LocatedBlock fakeBlock=new LocatedBlock(b,new DatanodeInfo[0]);
  ClientDatanodeProtocol proxy=null;
  try {
    proxy=DFSUtil.createClientDatanodeProtocolProxy(fakeDnId,conf,500,false,fakeBlock);
    proxy.getReplicaVisibleLength(new ExtendedBlock("bpid",1));
    fail("Did not get expected exception: SocketTimeoutException");
  }
 catch (  SocketTimeoutException e) {
    LOG.info("Got the expected Exception: SocketTimeoutException");
  }
 finally {
    if (proxy != null) {
      RPC.stopProxy(proxy);
    }
    server.stop();
  }
}

</code></pre>

<br>
<pre class="type-9 type-13 type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions in iterations
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test that checksum failures are recovered from by the next read on the same
 * DFSInputStream. Corruption information is not persisted from read call to
 * read call, so the client should expect consecutive calls to behave the same
 * way. See HDFS-3067.
 */
@Test public void testRetryOnChecksumFailure() throws Exception {
  HdfsConfiguration conf=new HdfsConfiguration();
  MiniDFSCluster cluster=new MiniDFSCluster.Builder(conf).numDataNodes(1).build();
  try {
    final short REPL_FACTOR=1;
    final long FILE_LENGTH=512L;
    cluster.waitActive();
    FileSystem fs=cluster.getFileSystem();
    Path path=new Path("/corrupted");
    DFSTestUtil.createFile(fs,path,FILE_LENGTH,REPL_FACTOR,12345L);
    DFSTestUtil.waitReplication(fs,path,REPL_FACTOR);
    ExtendedBlock block=DFSTestUtil.getFirstBlock(fs,path);
    int blockFilesCorrupted=cluster.corruptBlockOnDataNodes(block);
    assertEquals("All replicas not corrupted",REPL_FACTOR,blockFilesCorrupted);
    InetSocketAddress nnAddr=new InetSocketAddress("localhost",cluster.getNameNodePort());
    DFSClient client=new DFSClient(nnAddr,conf);
    DFSInputStream dis=client.open(path.toString());
    byte[] arr=new byte[(int)FILE_LENGTH];
    for (int i=0; i < 2; ++i) {
      try {
        dis.read(arr,0,(int)FILE_LENGTH);
        fail("Expected ChecksumException not thrown");
      }
 catch (      Exception ex) {
        GenericTestUtils.assertExceptionContains("Checksum error",ex);
      }
    }
  }
  finally {
    cluster.shutdown();
  }
}

</code></pre>

<br>
<pre class="type-9 type-2 type-7 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * This tests that DFSInputStream failures are counted for a given read
 * operation, and not over the lifetime of the stream. It is a regression
 * test for HDFS-127.
 */
@Test public void testFailuresArePerOperation() throws Exception {
  long fileSize=4096;
  Path file=new Path("/testFile");
  conf.setInt(DFSConfigKeys.DFS_CLIENT_RETRY_WINDOW_BASE,10);
  conf.setInt(DFS_CLIENT_SOCKET_TIMEOUT_KEY,2 * 1000);
  MiniDFSCluster cluster=new MiniDFSCluster.Builder(conf).build();
  try {
    cluster.waitActive();
    FileSystem fs=cluster.getFileSystem();
    NamenodeProtocols preSpyNN=cluster.getNameNodeRpc();
    NamenodeProtocols spyNN=spy(preSpyNN);
    DFSClient client=new DFSClient(null,spyNN,conf,null);
    int maxBlockAcquires=client.getMaxBlockAcquireFailures();
    assertTrue(maxBlockAcquires > 0);
    DFSTestUtil.createFile(fs,file,fileSize,(short)1,12345L);
    doAnswer(new FailNTimesAnswer(preSpyNN,maxBlockAcquires + 1)).when(spyNN).getBlockLocations(anyString(),anyLong(),anyLong());
    try {
      IOUtils.copyBytes(client.open(file.toString()),new IOUtils.NullOutputStream(),conf,true);
      fail("Didn't get exception");
    }
 catch (    IOException ioe) {
      DFSClient.LOG.info("Got expected exception",ioe);
    }
    doAnswer(new FailNTimesAnswer(preSpyNN,maxBlockAcquires)).when(spyNN).getBlockLocations(anyString(),anyLong(),anyLong());
    IOUtils.copyBytes(client.open(file.toString()),new IOUtils.NullOutputStream(),conf,true);
    DFSClient.LOG.info("Starting test case for failure reset");
    doAnswer(new FailNTimesAnswer(preSpyNN,maxBlockAcquires)).when(spyNN).getBlockLocations(anyString(),anyLong(),anyLong());
    DFSInputStream is=client.open(file.toString());
    byte buf[]=new byte[10];
    IOUtils.readFully(is,buf,0,buf.length);
    DFSClient.LOG.info("First read successful after some failures.");
    doAnswer(new FailNTimesAnswer(preSpyNN,maxBlockAcquires)).when(spyNN).getBlockLocations(anyString(),anyLong(),anyLong());
    is.openInfo();
    is.seek(0);
    IOUtils.readFully(is,buf,0,buf.length);
  }
  finally {
    cluster.shutdown();
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.TestDFSMkdirs </h4><pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * Regression test for HDFS-3626. Creates a file using a non-canonical path
 * (i.e. with extra slashes between components) and makes sure that the NN
 * rejects it.
 */
@Test public void testMkdirRpcNonCanonicalPath() throws IOException {
  MiniDFSCluster cluster=new MiniDFSCluster.Builder(conf).numDataNodes(0).build();
  try {
    NamenodeProtocols nnrpc=cluster.getNameNodeRpc();
    for (    String pathStr : NON_CANONICAL_PATHS) {
      try {
        nnrpc.mkdirs(pathStr,new FsPermission((short)0755),true);
        fail("Did not fail when called with a non-canonicalized path: " + pathStr);
      }
 catch (      InvalidPathException ipe) {
      }
    }
  }
  finally {
    cluster.shutdown();
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.TestDFSPermission </h4><pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testAccessGroupMember() throws IOException, InterruptedException {
  FileSystem rootFs=FileSystem.get(conf);
  Path p2=new Path("/p2");
  rootFs.mkdirs(p2);
  rootFs.setOwner(p2,UserGroupInformation.getCurrentUser().getShortUserName(),GROUP1_NAME);
  rootFs.setPermission(p2,new FsPermission((short)0740));
  fs=USER1.doAs(new PrivilegedExceptionAction<FileSystem>(){
    @Override public FileSystem run() throws Exception {
      return FileSystem.get(conf);
    }
  }
);
  fs.access(p2,FsAction.READ);
  try {
    fs.access(p2,FsAction.EXECUTE);
    fail("The access call should have failed.");
  }
 catch (  AccessControlException e) {
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testAccessOwner() throws IOException, InterruptedException {
  FileSystem rootFs=FileSystem.get(conf);
  Path p1=new Path("/p1");
  rootFs.mkdirs(p1);
  rootFs.setOwner(p1,USER1_NAME,GROUP1_NAME);
  fs=USER1.doAs(new PrivilegedExceptionAction<FileSystem>(){
    @Override public FileSystem run() throws Exception {
      return FileSystem.get(conf);
    }
  }
);
  fs.setPermission(p1,new FsPermission((short)0444));
  fs.access(p1,FsAction.READ);
  try {
    fs.access(p1,FsAction.WRITE);
    fail("The access call should have failed.");
  }
 catch (  AccessControlException e) {
  }
  Path badPath=new Path("/bad/bad");
  try {
    fs.access(badPath,FsAction.READ);
    fail("The access call should have failed");
  }
 catch (  FileNotFoundException e) {
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testAccessOthers() throws IOException, InterruptedException {
  FileSystem rootFs=FileSystem.get(conf);
  Path p3=new Path("/p3");
  rootFs.mkdirs(p3);
  rootFs.setPermission(p3,new FsPermission((short)0774));
  fs=USER1.doAs(new PrivilegedExceptionAction<FileSystem>(){
    @Override public FileSystem run() throws Exception {
      return FileSystem.get(conf);
    }
  }
);
  fs.access(p3,FsAction.READ);
  try {
    fs.access(p3,FsAction.READ_WRITE);
    fail("The access call should have failed.");
  }
 catch (  AccessControlException e) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.TestDFSUpgrade </h4><pre class="type-2 type-14 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies that exceptions are thrown during the test case execution">ExceptionVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies that exceptions are thrown during the test case execution
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(expected=IOException.class) public void testUpgradeFromPreUpgradeLVFails() throws IOException {
  Storage.checkVersionUpgradable(Storage.LAST_PRE_UPGRADE_LAYOUT_VERSION + 1);
  fail("Expected IOException is not thrown");
}

</code></pre>

<br>
<pre class="type-13 type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * This test attempts to upgrade the NameNode and DataNode under
 * a number of valid and invalid conditions.
 */
@Test(timeout=60000) public void testUpgrade() throws Exception {
  File[] baseDirs;
  StorageInfo storageInfo=null;
  for (int numDirs=1; numDirs <= 2; numDirs++) {
    conf=new HdfsConfiguration();
    conf=UpgradeUtilities.initializeStorageStateConf(numDirs,conf);
    String[] nameNodeDirs=conf.getStrings(DFSConfigKeys.DFS_NAMENODE_NAME_DIR_KEY);
    String[] dataNodeDirs=conf.getStrings(DFSConfigKeys.DFS_DATANODE_DATA_DIR_KEY);
    log("Normal NameNode upgrade",numDirs);
    UpgradeUtilities.createNameNodeStorageDirs(nameNodeDirs,"current");
    cluster=createCluster();
    try {
      final DistributedFileSystem dfs=cluster.getFileSystem();
      dfs.setSafeMode(SafeModeAction.SAFEMODE_ENTER);
      dfs.rollingUpgrade(RollingUpgradeAction.PREPARE);
      fail();
    }
 catch (    RemoteException re) {
      assertEquals(InconsistentFSStateException.class.getName(),re.getClassName());
      LOG.info("The exception is expected.",re);
    }
    checkNameNode(nameNodeDirs,EXPECTED_TXID);
    if (numDirs > 1)     TestParallelImageWrite.checkImages(cluster.getNamesystem(),numDirs);
    cluster.shutdown();
    UpgradeUtilities.createEmptyDirs(nameNodeDirs);
    log("Normal DataNode upgrade",numDirs);
    UpgradeUtilities.createNameNodeStorageDirs(nameNodeDirs,"current");
    cluster=createCluster();
    UpgradeUtilities.createDataNodeStorageDirs(dataNodeDirs,"current");
    cluster.startDataNodes(conf,1,false,StartupOption.REGULAR,null);
    checkDataNode(dataNodeDirs,UpgradeUtilities.getCurrentBlockPoolID(null));
    cluster.shutdown();
    UpgradeUtilities.createEmptyDirs(nameNodeDirs);
    UpgradeUtilities.createEmptyDirs(dataNodeDirs);
    log("NameNode upgrade with existing previous dir",numDirs);
    UpgradeUtilities.createNameNodeStorageDirs(nameNodeDirs,"current");
    UpgradeUtilities.createNameNodeStorageDirs(nameNodeDirs,"previous");
    startNameNodeShouldFail(StartupOption.UPGRADE);
    UpgradeUtilities.createEmptyDirs(nameNodeDirs);
    log("DataNode upgrade with existing previous dir",numDirs);
    UpgradeUtilities.createNameNodeStorageDirs(nameNodeDirs,"current");
    cluster=createCluster();
    UpgradeUtilities.createDataNodeStorageDirs(dataNodeDirs,"current");
    UpgradeUtilities.createDataNodeStorageDirs(dataNodeDirs,"previous");
    cluster.startDataNodes(conf,1,false,StartupOption.REGULAR,null);
    checkDataNode(dataNodeDirs,UpgradeUtilities.getCurrentBlockPoolID(null));
    cluster.shutdown();
    UpgradeUtilities.createEmptyDirs(nameNodeDirs);
    UpgradeUtilities.createEmptyDirs(dataNodeDirs);
    log("DataNode upgrade with future stored layout version in current",numDirs);
    UpgradeUtilities.createNameNodeStorageDirs(nameNodeDirs,"current");
    cluster=createCluster();
    baseDirs=UpgradeUtilities.createDataNodeStorageDirs(dataNodeDirs,"current");
    storageInfo=new StorageInfo(Integer.MIN_VALUE,UpgradeUtilities.getCurrentNamespaceID(cluster),UpgradeUtilities.getCurrentClusterID(cluster),UpgradeUtilities.getCurrentFsscTime(cluster),NodeType.DATA_NODE);
    UpgradeUtilities.createDataNodeVersionFile(baseDirs,storageInfo,UpgradeUtilities.getCurrentBlockPoolID(cluster));
    startBlockPoolShouldFail(StartupOption.REGULAR,UpgradeUtilities.getCurrentBlockPoolID(null));
    cluster.shutdown();
    UpgradeUtilities.createEmptyDirs(nameNodeDirs);
    UpgradeUtilities.createEmptyDirs(dataNodeDirs);
    log("DataNode upgrade with newer fsscTime in current",numDirs);
    UpgradeUtilities.createNameNodeStorageDirs(nameNodeDirs,"current");
    cluster=createCluster();
    baseDirs=UpgradeUtilities.createDataNodeStorageDirs(dataNodeDirs,"current");
    storageInfo=new StorageInfo(HdfsConstants.DATANODE_LAYOUT_VERSION,UpgradeUtilities.getCurrentNamespaceID(cluster),UpgradeUtilities.getCurrentClusterID(cluster),Long.MAX_VALUE,NodeType.DATA_NODE);
    UpgradeUtilities.createDataNodeVersionFile(baseDirs,storageInfo,UpgradeUtilities.getCurrentBlockPoolID(cluster));
    startBlockPoolShouldFail(StartupOption.REGULAR,UpgradeUtilities.getCurrentBlockPoolID(null));
    cluster.shutdown();
    UpgradeUtilities.createEmptyDirs(nameNodeDirs);
    UpgradeUtilities.createEmptyDirs(dataNodeDirs);
    log("NameNode upgrade with no edits file",numDirs);
    UpgradeUtilities.createNameNodeStorageDirs(nameNodeDirs,"current");
    deleteStorageFilesWithPrefix(nameNodeDirs,"edits_");
    startNameNodeShouldFail(StartupOption.UPGRADE);
    UpgradeUtilities.createEmptyDirs(nameNodeDirs);
    log("NameNode upgrade with no image file",numDirs);
    UpgradeUtilities.createNameNodeStorageDirs(nameNodeDirs,"current");
    deleteStorageFilesWithPrefix(nameNodeDirs,"fsimage_");
    startNameNodeShouldFail(StartupOption.UPGRADE);
    UpgradeUtilities.createEmptyDirs(nameNodeDirs);
    log("NameNode upgrade with corrupt version file",numDirs);
    baseDirs=UpgradeUtilities.createNameNodeStorageDirs(nameNodeDirs,"current");
    for (    File f : baseDirs) {
      UpgradeUtilities.corruptFile(new File(f,"VERSION"),"layoutVersion".getBytes(Charsets.UTF_8),"xxxxxxxxxxxxx".getBytes(Charsets.UTF_8));
    }
    startNameNodeShouldFail(StartupOption.UPGRADE);
    UpgradeUtilities.createEmptyDirs(nameNodeDirs);
    log("NameNode upgrade with old layout version in current",numDirs);
    baseDirs=UpgradeUtilities.createNameNodeStorageDirs(nameNodeDirs,"current");
    storageInfo=new StorageInfo(Storage.LAST_UPGRADABLE_LAYOUT_VERSION + 1,UpgradeUtilities.getCurrentNamespaceID(null),UpgradeUtilities.getCurrentClusterID(null),UpgradeUtilities.getCurrentFsscTime(null),NodeType.NAME_NODE);
    UpgradeUtilities.createNameNodeVersionFile(conf,baseDirs,storageInfo,UpgradeUtilities.getCurrentBlockPoolID(cluster));
    startNameNodeShouldFail(StartupOption.UPGRADE);
    UpgradeUtilities.createEmptyDirs(nameNodeDirs);
    log("NameNode upgrade with future layout version in current",numDirs);
    baseDirs=UpgradeUtilities.createNameNodeStorageDirs(nameNodeDirs,"current");
    storageInfo=new StorageInfo(Integer.MIN_VALUE,UpgradeUtilities.getCurrentNamespaceID(null),UpgradeUtilities.getCurrentClusterID(null),UpgradeUtilities.getCurrentFsscTime(null),NodeType.NAME_NODE);
    UpgradeUtilities.createNameNodeVersionFile(conf,baseDirs,storageInfo,UpgradeUtilities.getCurrentBlockPoolID(cluster));
    startNameNodeShouldFail(StartupOption.UPGRADE);
    UpgradeUtilities.createEmptyDirs(nameNodeDirs);
  }
  int numDirs=4;
{
    conf=new HdfsConfiguration();
    conf.setInt(DFSConfigKeys.DFS_DATANODE_SCAN_PERIOD_HOURS_KEY,-1);
    conf=UpgradeUtilities.initializeStorageStateConf(numDirs,conf);
    String[] nameNodeDirs=conf.getStrings(DFSConfigKeys.DFS_NAMENODE_NAME_DIR_KEY);
    log("Normal NameNode upgrade",numDirs);
    UpgradeUtilities.createNameNodeStorageDirs(nameNodeDirs,"current");
    cluster=createCluster();
    try {
      final DistributedFileSystem dfs=cluster.getFileSystem();
      dfs.setSafeMode(SafeModeAction.SAFEMODE_ENTER);
      dfs.rollingUpgrade(RollingUpgradeAction.PREPARE);
      fail();
    }
 catch (    RemoteException re) {
      assertEquals(InconsistentFSStateException.class.getName(),re.getClassName());
      LOG.info("The exception is expected.",re);
    }
    checkNameNode(nameNodeDirs,EXPECTED_TXID);
    TestParallelImageWrite.checkImages(cluster.getNamesystem(),numDirs);
    cluster.shutdown();
    UpgradeUtilities.createEmptyDirs(nameNodeDirs);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.TestDFSUpgradeFromImage </h4><pre class="type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test that sets up a fake image from Hadoop 0.3.0 and tries to start a
 * NN, verifying that the correct error message is thrown.
 */
@Test public void testFailOnPreUpgradeImage() throws IOException {
  Configuration conf=new HdfsConfiguration();
  File namenodeStorage=new File(TEST_ROOT_DIR,"nnimage-0.3.0");
  conf.set(DFSConfigKeys.DFS_NAMENODE_NAME_DIR_KEY,namenodeStorage.toString());
  FileUtil.fullyDelete(namenodeStorage);
  assertTrue("Make " + namenodeStorage,namenodeStorage.mkdirs());
  File imageDir=new File(namenodeStorage,"image");
  assertTrue("Make " + imageDir,imageDir.mkdirs());
  File imageFile=new File(imageDir,"fsimage");
  byte[] imageBytes=StringUtils.hexStringToByte("fffffffee17c0d2700000000");
  FileOutputStream fos=new FileOutputStream(imageFile);
  try {
    fos.write(imageBytes);
  }
  finally {
    fos.close();
  }
  MiniDFSCluster cluster=null;
  try {
    cluster=new MiniDFSCluster.Builder(conf).numDataNodes(0).format(false).manageDataDfsDirs(false).manageNameDfsDirs(false).startupOption(StartupOption.REGULAR).build();
    fail("Was able to start NN from 0.3.0 image");
  }
 catch (  IOException ioe) {
    if (!ioe.toString().contains("Old layout version is 'too old'")) {
      throw ioe;
    }
  }
 finally {
    if (cluster != null) {
      cluster.shutdown();
    }
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test upgrade from 0.22 image with corrupt md5, make sure it
 * fails to upgrade
 */
@Test public void testUpgradeFromCorruptRel22Image() throws IOException {
  unpackStorage(HADOOP22_IMAGE,HADOOP_DFS_DIR_TXT);
  File baseDir=new File(MiniDFSCluster.getBaseDirectory());
  FSImageTestUtil.corruptVersionFile(new File(baseDir,"name1/current/VERSION"),"imageMD5Digest","22222222222222222222222222222222");
  FSImageTestUtil.corruptVersionFile(new File(baseDir,"name2/current/VERSION"),"imageMD5Digest","22222222222222222222222222222222");
  final LogVerificationAppender appender=new LogVerificationAppender();
  final Logger logger=Logger.getRootLogger();
  logger.addAppender(appender);
  try {
    upgradeAndVerify(new MiniDFSCluster.Builder(upgradeConf).numDataNodes(4));
    fail("Upgrade did not fail with bad MD5");
  }
 catch (  IOException ioe) {
    String msg=StringUtils.stringifyException(ioe);
    if (!msg.contains("Failed to load an FSImage file")) {
      throw ioe;
    }
    int md5failures=appender.countExceptionsWithMessage(" is corrupt with MD5 checksum of ");
    assertEquals("Upgrade did not fail with bad MD5",1,md5failures);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.TestDFSUtil </h4><pre class="type-9 type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * Tests for empty configuration, an exception is thrown from{@link DFSUtil#getNNServiceRpcAddresses(Configuration)}{@link DFSUtil#getBackupNodeAddresses(Configuration)}{@link DFSUtil#getSecondaryNameNodeAddresses(Configuration)}
 */
@Test public void testEmptyConf(){
  HdfsConfiguration conf=new HdfsConfiguration(false);
  try {
    Map<String,Map<String,InetSocketAddress>> map=DFSUtil.getNNServiceRpcAddresses(conf);
    fail("Expected IOException is not thrown, result was: " + DFSUtil.addressMapToString(map));
  }
 catch (  IOException expected) {
  }
  try {
    Map<String,Map<String,InetSocketAddress>> map=DFSUtil.getBackupNodeAddresses(conf);
    fail("Expected IOException is not thrown, result was: " + DFSUtil.addressMapToString(map));
  }
 catch (  IOException expected) {
  }
  try {
    Map<String,Map<String,InetSocketAddress>> map=DFSUtil.getSecondaryNameNodeAddresses(conf);
    fail("Expected IOException is not thrown, result was: " + DFSUtil.addressMapToString(map));
  }
 catch (  IOException expected) {
  }
}

</code></pre>

<br>
<pre class="type-2 type-14 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies that exceptions are thrown during the test case execution">ExceptionVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies that exceptions are thrown during the test case execution
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test {@link DFSUtil#getNamenodeNameServiceId(Configuration)} to ensure
 * exception is thrown when multiple rpc addresses match the local node's
 * address
 */
@Test(expected=HadoopIllegalArgumentException.class) public void testGetNameServiceIdException(){
  HdfsConfiguration conf=new HdfsConfiguration();
  conf.set(DFS_NAMESERVICES,"nn1,nn2");
  conf.set(DFSUtil.addKeySuffixes(DFS_NAMENODE_RPC_ADDRESS_KEY,"nn1"),"localhost:9000");
  conf.set(DFSUtil.addKeySuffixes(DFS_NAMENODE_RPC_ADDRESS_KEY,"nn2"),"localhost:9001");
  DFSUtil.getNamenodeNameServiceId(conf);
  fail("Expected exception is not thrown");
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.TestDatanodeConfig </h4><pre class="type-9 type-2 type-7 type-10 type-1 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test that a data-node does not start if configuration specifies
 * incorrect URI scheme in data directory.
 * Test that a data-node starts if data directory is specified as
 * URI = "file:///path" or as a non URI path.
 */
@Test public void testDataDirectories() throws IOException {
  File dataDir=new File(BASE_DIR,"data").getCanonicalFile();
  Configuration conf=cluster.getConfiguration(0);
  String dnDir=makeURI("shv",null,fileAsURI(dataDir).getPath());
  conf.set(DFSConfigKeys.DFS_DATANODE_DATA_DIR_KEY,dnDir);
  DataNode dn=null;
  try {
    dn=DataNode.createDataNode(new String[]{},conf);
    fail();
  }
 catch (  Exception e) {
  }
 finally {
    if (dn != null) {
      dn.shutdown();
    }
  }
  assertNull("Data-node startup should have failed.",dn);
  String dnDir1=fileAsURI(dataDir).toString() + "1";
  String dnDir2=makeURI("file","localhost",fileAsURI(dataDir).getPath() + "2");
  String dnDir3=dataDir.getAbsolutePath() + "3";
  conf.set(DFSConfigKeys.DFS_DATANODE_DATA_DIR_KEY,dnDir1 + "," + dnDir2+ ","+ dnDir3);
  try {
    cluster.startDataNodes(conf,1,false,StartupOption.REGULAR,null);
    assertTrue("Data-node should startup.",cluster.isDataNodeUp());
  }
  finally {
    if (cluster != null) {
      cluster.shutdownDataNodes();
    }
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.TestDatanodeRegistration </h4><pre class="type-11 type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Regression test for HDFS-894 ensures that, when datanodes
 * are restarted, the new IPC port is registered with the
 * namenode.
 */
@Test public void testChangeIpcPort() throws Exception {
  HdfsConfiguration conf=new HdfsConfiguration();
  MiniDFSCluster cluster=null;
  try {
    cluster=new MiniDFSCluster.Builder(conf).build();
    InetSocketAddress addr=new InetSocketAddress("localhost",cluster.getNameNodePort());
    DFSClient client=new DFSClient(addr,conf);
    cluster.restartDataNodes();
    DatanodeInfo[] report=client.datanodeReport(DatanodeReportType.ALL);
    long firstUpdateAfterRestart=report[0].getLastUpdate();
    boolean gotHeartbeat=false;
    for (int i=0; i < 10 && !gotHeartbeat; i++) {
      try {
        Thread.sleep(i * 1000);
      }
 catch (      InterruptedException ie) {
      }
      report=client.datanodeReport(DatanodeReportType.ALL);
      gotHeartbeat=(report[0].getLastUpdate() > firstUpdateAfterRestart);
    }
    if (!gotHeartbeat) {
      fail("Never got a heartbeat from restarted datanode.");
    }
    int realIpcPort=cluster.getDataNodes().get(0).getIpcPort();
    assertEquals(realIpcPort,report[0].getIpcPort());
  }
  finally {
    if (cluster != null) {
      cluster.shutdown();
    }
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testRegistrationWithDifferentSoftwareVersions() throws Exception {
  Configuration conf=new HdfsConfiguration();
  conf.set(DFSConfigKeys.DFS_DATANODE_MIN_SUPPORTED_NAMENODE_VERSION_KEY,"3.0.0");
  conf.set(DFSConfigKeys.DFS_NAMENODE_MIN_SUPPORTED_DATANODE_VERSION_KEY,"3.0.0");
  MiniDFSCluster cluster=null;
  try {
    cluster=new MiniDFSCluster.Builder(conf).numDataNodes(0).build();
    NamenodeProtocols rpcServer=cluster.getNameNodeRpc();
    long nnCTime=cluster.getNamesystem().getFSImage().getStorage().getCTime();
    StorageInfo mockStorageInfo=mock(StorageInfo.class);
    doReturn(nnCTime).when(mockStorageInfo).getCTime();
    DatanodeRegistration mockDnReg=mock(DatanodeRegistration.class);
    doReturn(HdfsConstants.DATANODE_LAYOUT_VERSION).when(mockDnReg).getVersion();
    doReturn("127.0.0.1").when(mockDnReg).getIpAddr();
    doReturn(123).when(mockDnReg).getXferPort();
    doReturn("fake-storage-id").when(mockDnReg).getDatanodeUuid();
    doReturn(mockStorageInfo).when(mockDnReg).getStorageInfo();
    doReturn("3.0.0").when(mockDnReg).getSoftwareVersion();
    rpcServer.registerDatanode(mockDnReg);
    doReturn("4.0.0").when(mockDnReg).getSoftwareVersion();
    rpcServer.registerDatanode(mockDnReg);
    doReturn("2.0.0").when(mockDnReg).getSoftwareVersion();
    try {
      rpcServer.registerDatanode(mockDnReg);
      fail("Should not have been able to register DN with too-low version.");
    }
 catch (    IncorrectVersionException ive) {
      GenericTestUtils.assertExceptionContains("The reported DataNode version is too low",ive);
      LOG.info("Got expected exception",ive);
    }
  }
  finally {
    if (cluster != null) {
      cluster.shutdown();
    }
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testRegistrationWithDifferentSoftwareVersionsDuringUpgrade() throws Exception {
  Configuration conf=new HdfsConfiguration();
  conf.set(DFSConfigKeys.DFS_DATANODE_MIN_SUPPORTED_NAMENODE_VERSION_KEY,"1.0.0");
  MiniDFSCluster cluster=null;
  try {
    cluster=new MiniDFSCluster.Builder(conf).numDataNodes(0).build();
    NamenodeProtocols rpcServer=cluster.getNameNodeRpc();
    long nnCTime=cluster.getNamesystem().getFSImage().getStorage().getCTime();
    StorageInfo mockStorageInfo=mock(StorageInfo.class);
    doReturn(nnCTime).when(mockStorageInfo).getCTime();
    DatanodeRegistration mockDnReg=mock(DatanodeRegistration.class);
    doReturn(HdfsConstants.DATANODE_LAYOUT_VERSION).when(mockDnReg).getVersion();
    doReturn("fake-storage-id").when(mockDnReg).getDatanodeUuid();
    doReturn(mockStorageInfo).when(mockDnReg).getStorageInfo();
    doReturn(VersionInfo.getVersion()).when(mockDnReg).getSoftwareVersion();
    doReturn("127.0.0.1").when(mockDnReg).getIpAddr();
    doReturn(123).when(mockDnReg).getXferPort();
    rpcServer.registerDatanode(mockDnReg);
    doReturn(nnCTime + 1).when(mockStorageInfo).getCTime();
    rpcServer.registerDatanode(mockDnReg);
    doReturn(VersionInfo.getVersion() + ".1").when(mockDnReg).getSoftwareVersion();
    try {
      rpcServer.registerDatanode(mockDnReg);
      fail("Should not have been able to register DN with different software" + " versions and CTimes");
    }
 catch (    IncorrectVersionException ive) {
      GenericTestUtils.assertExceptionContains("does not match CTime of NN",ive);
      LOG.info("Got expected exception",ive);
    }
  }
  finally {
    if (cluster != null) {
      cluster.shutdown();
    }
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.TestDistributedFileSystem </h4><pre class="type-13 type-2 type-7 type-10 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testFileChecksum() throws Exception {
  final long seed=RAN.nextLong();
  System.out.println("seed=" + seed);
  RAN.setSeed(seed);
  final Configuration conf=getTestConfiguration();
  conf.setBoolean(DFSConfigKeys.DFS_WEBHDFS_ENABLED_KEY,true);
  final MiniDFSCluster cluster=new MiniDFSCluster.Builder(conf).numDataNodes(2).build();
  final FileSystem hdfs=cluster.getFileSystem();
  final String nnAddr=conf.get(DFSConfigKeys.DFS_NAMENODE_HTTP_ADDRESS_KEY);
  final UserGroupInformation current=UserGroupInformation.getCurrentUser();
  final UserGroupInformation ugi=UserGroupInformation.createUserForTesting(current.getShortUserName() + "x",new String[]{"user"});
  try {
    hdfs.getFileChecksum(new Path("/test/TestNonExistingFile"));
    fail("Expecting FileNotFoundException");
  }
 catch (  FileNotFoundException e) {
    assertTrue("Not throwing the intended exception message",e.getMessage().contains("File does not exist: /test/TestNonExistingFile"));
  }
  try {
    Path path=new Path("/test/TestExistingDir/");
    hdfs.mkdirs(path);
    hdfs.getFileChecksum(path);
    fail("Expecting FileNotFoundException");
  }
 catch (  FileNotFoundException e) {
    assertTrue("Not throwing the intended exception message",e.getMessage().contains("Path is not a file: /test/TestExistingDir"));
  }
  final String webhdfsuri=WebHdfsFileSystem.SCHEME + "://" + nnAddr;
  System.out.println("webhdfsuri=" + webhdfsuri);
  final FileSystem webhdfs=ugi.doAs(new PrivilegedExceptionAction<FileSystem>(){
    @Override public FileSystem run() throws Exception {
      return new Path(webhdfsuri).getFileSystem(conf);
    }
  }
);
  final Path dir=new Path("/filechecksum");
  final int block_size=1024;
  final int buffer_size=conf.getInt(CommonConfigurationKeys.IO_FILE_BUFFER_SIZE_KEY,4096);
  conf.setInt(DFSConfigKeys.DFS_BYTES_PER_CHECKSUM_KEY,512);
  for (int n=0; n < 5; n++) {
    final byte[] data=new byte[RAN.nextInt(block_size / 2 - 1) + n * block_size + 1];
    RAN.nextBytes(data);
    System.out.println("data.length=" + data.length);
    final Path foo=new Path(dir,"foo" + n);
{
      final FSDataOutputStream out=hdfs.create(foo,false,buffer_size,(short)2,block_size);
      out.write(data);
      out.close();
    }
    final FileChecksum hdfsfoocs=hdfs.getFileChecksum(foo);
    System.out.println("hdfsfoocs=" + hdfsfoocs);
    final FileChecksum webhdfsfoocs=webhdfs.getFileChecksum(foo);
    System.out.println("webhdfsfoocs=" + webhdfsfoocs);
    final Path webhdfsqualified=new Path(webhdfsuri + dir,"foo" + n);
    final FileChecksum webhdfs_qfoocs=webhdfs.getFileChecksum(webhdfsqualified);
    System.out.println("webhdfs_qfoocs=" + webhdfs_qfoocs);
    final Path zeroByteFile=new Path(dir,"zeroByteFile" + n);
{
      final FSDataOutputStream out=hdfs.create(zeroByteFile,false,buffer_size,(short)2,block_size);
      out.close();
    }
{
      final FileChecksum zeroChecksum=hdfs.getFileChecksum(zeroByteFile);
      assertEquals(zeroChecksum.toString(),"MD5-of-0MD5-of-0CRC32:70bc8f4b72a86921468bf8e8441dce51");
    }
    final Path bar=new Path(dir,"bar" + n);
{
      final FSDataOutputStream out=hdfs.create(bar,false,buffer_size,(short)2,block_size);
      out.write(data);
      out.close();
    }
{
      final FileChecksum barcs=hdfs.getFileChecksum(bar);
      final int barhashcode=barcs.hashCode();
      assertEquals(hdfsfoocs.hashCode(),barhashcode);
      assertEquals(hdfsfoocs,barcs);
      assertEquals(webhdfsfoocs.hashCode(),barhashcode);
      assertEquals(webhdfsfoocs,barcs);
      assertEquals(webhdfs_qfoocs.hashCode(),barhashcode);
      assertEquals(webhdfs_qfoocs,barcs);
    }
    hdfs.setPermission(dir,new FsPermission((short)0));
{
      try {
        webhdfs.getFileChecksum(webhdfsqualified);
        fail();
      }
 catch (      IOException ioe) {
        FileSystem.LOG.info("GOOD: getting an exception",ioe);
      }
    }
    hdfs.setPermission(dir,new FsPermission((short)0777));
  }
  cluster.shutdown();
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.TestEncryptedTransfer </h4><pre class="type-9 type-11 type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testClientThatDoesNotSupportEncryption() throws IOException {
  MiniDFSCluster cluster=null;
  try {
    Configuration conf=new Configuration();
    conf.setInt(DFSConfigKeys.DFS_CLIENT_RETRY_WINDOW_BASE,10);
    cluster=new MiniDFSCluster.Builder(conf).build();
    FileSystem fs=getFileSystem(conf);
    writeTestDataToFile(fs);
    assertEquals(PLAIN_TEXT,DFSTestUtil.readFile(fs,TEST_PATH));
    fs.close();
    cluster.shutdown();
    setEncryptionConfigKeys(conf);
    cluster=new MiniDFSCluster.Builder(conf).manageDataDfsDirs(false).manageNameDfsDirs(false).format(false).startupOption(StartupOption.REGULAR).build();
    fs=getFileSystem(conf);
    DFSClient client=DFSClientAdapter.getDFSClient((DistributedFileSystem)fs);
    DFSClient spyClient=Mockito.spy(client);
    Mockito.doReturn(false).when(spyClient).shouldEncryptData();
    DFSClientAdapter.setDFSClient((DistributedFileSystem)fs,spyClient);
    LogCapturer logs=GenericTestUtils.LogCapturer.captureLogs(LogFactory.getLog(DataNode.class));
    try {
      assertEquals(PLAIN_TEXT,DFSTestUtil.readFile(fs,TEST_PATH));
      if (resolverClazz != null && !resolverClazz.endsWith("TestTrustedChannelResolver")) {
        fail("Should not have been able to read without encryption enabled.");
      }
    }
 catch (    IOException ioe) {
      GenericTestUtils.assertExceptionContains("Could not obtain block:",ioe);
    }
 finally {
      logs.stopCapturing();
    }
    fs.close();
    if (resolverClazz != null && !resolverClazz.endsWith("TestTrustedChannelResolver")) {
      GenericTestUtils.assertMatches(logs.getOutput(),"Failed to read expected encryption handshake from client at");
    }
  }
  finally {
    if (cluster != null) {
      cluster.shutdown();
    }
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.TestEncryptionZones </h4><pre class="type-9 type-2 type-7 type-1 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test getEncryptionZoneForPath as a non super user.
 */
@Test(timeout=60000) public void testGetEZAsNonSuperUser() throws Exception {
  final UserGroupInformation user=UserGroupInformation.createUserForTesting("user",new String[]{"mygroup"});
  final Path testRoot=new Path(fsHelper.getTestRootDir());
  final Path superPath=new Path(testRoot,"superuseronly");
  final Path superPathFile=new Path(superPath,"file1");
  final Path allPath=new Path(testRoot,"accessall");
  final Path allPathFile=new Path(allPath,"file1");
  final Path nonEZDir=new Path(testRoot,"nonEZDir");
  final Path nonEZFile=new Path(nonEZDir,"file1");
  final int len=8192;
  fsWrapper.mkdir(testRoot,new FsPermission((short)0777),true);
  fsWrapper.mkdir(superPath,new FsPermission((short)0700),false);
  fsWrapper.mkdir(allPath,new FsPermission((short)0777),false);
  fsWrapper.mkdir(nonEZDir,new FsPermission((short)0777),false);
  dfsAdmin.createEncryptionZone(superPath,TEST_KEY);
  dfsAdmin.createEncryptionZone(allPath,TEST_KEY);
  dfsAdmin.allowSnapshot(new Path("/"));
  final Path newSnap=fs.createSnapshot(new Path("/"));
  DFSTestUtil.createFile(fs,superPathFile,len,(short)1,0xFEED);
  DFSTestUtil.createFile(fs,allPathFile,len,(short)1,0xFEED);
  DFSTestUtil.createFile(fs,nonEZFile,len,(short)1,0xFEED);
  user.doAs(new PrivilegedExceptionAction(){
    @Override public Object run() throws Exception {
      final HdfsAdmin userAdmin=new HdfsAdmin(FileSystem.getDefaultUri(conf),conf);
      try {
        userAdmin.getEncryptionZoneForPath(null);
        fail("should have thrown NPE");
      }
 catch (      NullPointerException e) {
      }
      assertEquals("expected ez path",allPath.toString(),userAdmin.getEncryptionZoneForPath(allPath).getPath().toString());
      assertEquals("expected ez path",allPath.toString(),userAdmin.getEncryptionZoneForPath(allPathFile).getPath().toString());
      try {
        userAdmin.getEncryptionZoneForPath(superPathFile);
        fail("expected AccessControlException");
      }
 catch (      AccessControlException e) {
        assertExceptionContains("Permission denied:",e);
      }
      assertNull("expected null for non-ez path",userAdmin.getEncryptionZoneForPath(nonEZDir));
      assertNull("expected null for non-ez path",userAdmin.getEncryptionZoneForPath(nonEZFile));
      String snapshottedAllPath=newSnap.toString() + allPath.toString();
      assertEquals("expected ez path",allPath.toString(),userAdmin.getEncryptionZoneForPath(new Path(snapshottedAllPath)).getPath().toString());
      fs.delete(allPathFile,false);
      assertEquals("expected ez path",allPath.toString(),userAdmin.getEncryptionZoneForPath(new Path(snapshottedAllPath)).getPath().toString());
      fs.delete(allPath,true);
      assertEquals("expected ez path",allPath.toString(),userAdmin.getEncryptionZoneForPath(new Path(snapshottedAllPath)).getPath().toString());
      assertNull("expected null for deleted file path",userAdmin.getEncryptionZoneForPath(allPathFile));
      assertNull("expected null for deleted directory path",userAdmin.getEncryptionZoneForPath(allPath));
      return null;
    }
  }
);
}

</code></pre>

<br>
<pre class="type-9 type-13 type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions in iterations
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testCipherSuiteNegotiation() throws Exception {
  final HdfsAdmin dfsAdmin=new HdfsAdmin(FileSystem.getDefaultUri(conf),conf);
  final Path zone=new Path("/zone");
  fs.mkdirs(zone);
  dfsAdmin.createEncryptionZone(zone,TEST_KEY);
  DFSTestUtil.createFile(fs,new Path(zone,"success1"),0,(short)1,0xFEED);
  fs.getClient().cipherSuites=Lists.newArrayListWithCapacity(0);
  try {
    DFSTestUtil.createFile(fs,new Path(zone,"fail"),0,(short)1,0xFEED);
    fail("Created a file without specifying a CipherSuite!");
  }
 catch (  UnknownCipherSuiteException e) {
    assertExceptionContains("No cipher suites",e);
  }
  fs.getClient().cipherSuites=Lists.newArrayListWithCapacity(3);
  fs.getClient().cipherSuites.add(CipherSuite.UNKNOWN);
  fs.getClient().cipherSuites.add(CipherSuite.UNKNOWN);
  fs.getClient().cipherSuites.add(CipherSuite.UNKNOWN);
  try {
    DFSTestUtil.createFile(fs,new Path(zone,"fail"),0,(short)1,0xFEED);
    fail("Created a file without specifying a CipherSuite!");
  }
 catch (  UnknownCipherSuiteException e) {
    assertExceptionContains("No cipher suites",e);
  }
  fs.getClient().cipherSuites=Lists.newArrayListWithCapacity(3);
  fs.getClient().cipherSuites.add(CipherSuite.AES_CTR_NOPADDING);
  fs.getClient().cipherSuites.add(CipherSuite.UNKNOWN);
  fs.getClient().cipherSuites.add(CipherSuite.UNKNOWN);
  DFSTestUtil.createFile(fs,new Path(zone,"success2"),0,(short)1,0xFEED);
  fs.getClient().cipherSuites=Lists.newArrayListWithCapacity(3);
  fs.getClient().cipherSuites.add(CipherSuite.UNKNOWN);
  fs.getClient().cipherSuites.add(CipherSuite.UNKNOWN);
  fs.getClient().cipherSuites.add(CipherSuite.AES_CTR_NOPADDING);
  DFSTestUtil.createFile(fs,new Path(zone,"success3"),4096,(short)1,0xFEED);
  cluster.getNamesystem().getProvider().flush();
  KeyProvider provider=KeyProviderFactory.getProviders(conf).get(0);
  List<String> keys=provider.getKeys();
  assertEquals("Expected NN to have created one key per zone",1,keys.size());
  List<KeyProvider.KeyVersion> allVersions=Lists.newArrayList();
  for (  String key : keys) {
    List<KeyProvider.KeyVersion> versions=provider.getKeyVersions(key);
    assertEquals("Should only have one key version per key",1,versions.size());
    allVersions.addAll(versions);
  }
  for (int i=2; i <= 3; i++) {
    FileEncryptionInfo feInfo=getFileEncryptionInfo(new Path(zone.toString() + "/success" + i));
    assertEquals(feInfo.getCipherSuite(),CipherSuite.AES_CTR_NOPADDING);
  }
}

</code></pre>

<br>
<pre class="type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Tests the retry logic in startFile. We release the lock while generating
 * an EDEK, so tricky things can happen in the intervening time.
 */
@Test(timeout=120000) public void testStartFileRetry() throws Exception {
  final Path zone1=new Path("/zone1");
  final Path file=new Path(zone1,"file1");
  fsWrapper.mkdir(zone1,FsPermission.getDirDefault(),true);
  ExecutorService executor=Executors.newSingleThreadExecutor();
  executor.submit(new InjectFaultTask(){
    @Override public void doFault() throws Exception {
      dfsAdmin.createEncryptionZone(zone1,TEST_KEY);
    }
    @Override public void doCleanup() throws Exception {
      assertEquals("Expected a startFile retry",2,injector.generateCount);
      fsWrapper.delete(file,false);
    }
  }
).get();
  executor.submit(new InjectFaultTask(){
    @Override public void doFault() throws Exception {
      fsWrapper.delete(zone1,true);
    }
    @Override public void doCleanup() throws Exception {
      assertEquals("Expected no startFile retries",1,injector.generateCount);
      fsWrapper.delete(file,false);
    }
  }
).get();
  fsWrapper.mkdir(zone1,FsPermission.getDirDefault(),true);
  final String otherKey="otherKey";
  DFSTestUtil.createKey(otherKey,cluster,conf);
  dfsAdmin.createEncryptionZone(zone1,TEST_KEY);
  executor.submit(new InjectFaultTask(){
    @Override public void doFault() throws Exception {
      fsWrapper.delete(zone1,true);
      fsWrapper.mkdir(zone1,FsPermission.getDirDefault(),true);
      dfsAdmin.createEncryptionZone(zone1,otherKey);
    }
    @Override public void doCleanup() throws Exception {
      assertEquals("Expected a startFile retry",2,injector.generateCount);
      fsWrapper.delete(zone1,true);
    }
  }
).get();
  fsWrapper.mkdir(zone1,FsPermission.getDirDefault(),true);
  final String anotherKey="anotherKey";
  DFSTestUtil.createKey(anotherKey,cluster,conf);
  dfsAdmin.createEncryptionZone(zone1,anotherKey);
  String keyToUse=otherKey;
  MyInjector injector=new MyInjector();
  EncryptionFaultInjector.instance=injector;
  Future<?> future=executor.submit(new CreateFileTask(fsWrapper,file));
  for (int i=0; i < 10; i++) {
    injector.ready.await();
    fsWrapper.delete(zone1,true);
    fsWrapper.mkdir(zone1,FsPermission.getDirDefault(),true);
    dfsAdmin.createEncryptionZone(zone1,keyToUse);
    if (keyToUse == otherKey) {
      keyToUse=anotherKey;
    }
 else {
      keyToUse=otherKey;
    }
    injector.wait.countDown();
    injector=new MyInjector();
    EncryptionFaultInjector.instance=injector;
  }
  try {
    future.get();
    fail("Expected exception from too many retries");
  }
 catch (  ExecutionException e) {
    assertExceptionContains("Too many retries because of encryption zone operations",e.getCause());
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test(timeout=60000) public void testBasicOperations() throws Exception {
  int numZones=0;
  final Path zoneParent=new Path("/zones");
  final Path zone1=new Path(zoneParent,"zone1");
  try {
    dfsAdmin.createEncryptionZone(zone1,TEST_KEY);
    fail("expected /test doesn't exist");
  }
 catch (  IOException e) {
    assertExceptionContains("cannot find",e);
  }
  fsWrapper.mkdir(zone1,FsPermission.getDirDefault(),true);
  dfsAdmin.createEncryptionZone(zone1,TEST_KEY);
  assertNumZones(++numZones);
  assertZonePresent(null,zone1.toString());
  try {
    dfsAdmin.createEncryptionZone(zone1,TEST_KEY);
  }
 catch (  IOException e) {
    assertExceptionContains("already in an encryption zone",e);
  }
  final Path zone1Child=new Path(zone1,"child");
  fsWrapper.mkdir(zone1Child,FsPermission.getDirDefault(),false);
  try {
    dfsAdmin.createEncryptionZone(zone1Child,TEST_KEY);
    fail("EZ in an EZ");
  }
 catch (  IOException e) {
    assertExceptionContains("already in an encryption zone",e);
  }
  try {
    dfsAdmin.createEncryptionZone(zoneParent,TEST_KEY);
    fail("EZ over an EZ");
  }
 catch (  IOException e) {
    assertExceptionContains("encryption zone for a non-empty directory",e);
  }
  final Path notEmpty=new Path("/notEmpty");
  final Path notEmptyChild=new Path(notEmpty,"child");
  fsWrapper.mkdir(notEmptyChild,FsPermission.getDirDefault(),true);
  try {
    dfsAdmin.createEncryptionZone(notEmpty,TEST_KEY);
    fail("Created EZ on an non-empty directory with folder");
  }
 catch (  IOException e) {
    assertExceptionContains("create an encryption zone",e);
  }
  fsWrapper.delete(notEmptyChild,false);
  fsWrapper.createFile(notEmptyChild);
  try {
    dfsAdmin.createEncryptionZone(notEmpty,TEST_KEY);
    fail("Created EZ on an non-empty directory with file");
  }
 catch (  IOException e) {
    assertExceptionContains("create an encryption zone",e);
  }
  try {
    dfsAdmin.createEncryptionZone(notEmptyChild,TEST_KEY);
    fail("Created EZ on a file");
  }
 catch (  IOException e) {
    assertExceptionContains("create an encryption zone for a file.",e);
  }
  final Path zone2=new Path("/zone2");
  fsWrapper.mkdir(zone2,FsPermission.getDirDefault(),false);
  final String myKeyName="mykeyname";
  try {
    dfsAdmin.createEncryptionZone(zone2,myKeyName);
    fail("expected key doesn't exist");
  }
 catch (  IOException e) {
    assertExceptionContains("doesn't exist.",e);
  }
  try {
    dfsAdmin.createEncryptionZone(zone2,"");
    fail("created a zone with empty key name");
  }
 catch (  IOException e) {
    assertExceptionContains("Must specify a key name when creating",e);
  }
  try {
    dfsAdmin.createEncryptionZone(zone2,null);
    fail("created a zone with null key name");
  }
 catch (  IOException e) {
    assertExceptionContains("Must specify a key name when creating",e);
  }
  assertNumZones(1);
  DFSTestUtil.createKey(myKeyName,cluster,conf);
  dfsAdmin.createEncryptionZone(zone2,myKeyName);
  assertNumZones(++numZones);
  assertZonePresent(myKeyName,zone2.toString());
  final UserGroupInformation user=UserGroupInformation.createUserForTesting("user",new String[]{"mygroup"});
  final Path nonSuper=new Path("/nonSuper");
  fsWrapper.mkdir(nonSuper,FsPermission.getDirDefault(),false);
  user.doAs(new PrivilegedExceptionAction(){
    @Override public Object run() throws Exception {
      final HdfsAdmin userAdmin=new HdfsAdmin(FileSystem.getDefaultUri(conf),conf);
      try {
        userAdmin.createEncryptionZone(nonSuper,TEST_KEY);
        fail("createEncryptionZone is superuser-only operation");
      }
 catch (      AccessControlException e) {
        assertExceptionContains("Superuser privilege is required",e);
      }
      return null;
    }
  }
);
  Path deepZone=new Path("/d/e/e/p/zone");
  fsWrapper.mkdir(deepZone,FsPermission.getDirDefault(),true);
  dfsAdmin.createEncryptionZone(deepZone,TEST_KEY);
  assertNumZones(++numZones);
  assertZonePresent(null,deepZone.toString());
  for (int i=1; i < 6; i++) {
    final Path zonePath=new Path("/listZone" + i);
    fsWrapper.mkdir(zonePath,FsPermission.getDirDefault(),false);
    dfsAdmin.createEncryptionZone(zonePath,TEST_KEY);
    numZones++;
    assertNumZones(numZones);
    assertZonePresent(null,zonePath.toString());
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test(timeout=120000) public void testCreateEZWithNoProvider() throws Exception {
  final Configuration clusterConf=cluster.getConfiguration(0);
  clusterConf.set(KeyProviderFactory.KEY_PROVIDER_PATH,"");
  cluster.restartNameNode(true);
  cluster.waitActive();
  final Path zone1=new Path("/zone1");
  fsWrapper.mkdir(zone1,FsPermission.getDirDefault(),true);
  try {
    dfsAdmin.createEncryptionZone(zone1,TEST_KEY);
    fail("expected exception");
  }
 catch (  IOException e) {
    assertExceptionContains("since no key provider is available",e);
  }
  clusterConf.set(KeyProviderFactory.KEY_PROVIDER_PATH,JavaKeyStoreProvider.SCHEME_NAME + "://file" + testRootDir+ "/test.jks");
  assertNumZones(0);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.TestFileAppend </h4><pre class="type-11 type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * Old replica of the block should not be accepted as valid for append/read
 */
@Test public void testFailedAppendBlockRejection() throws Exception {
  Configuration conf=new HdfsConfiguration();
  conf.set("dfs.client.block.write.replace-datanode-on-failure.enable","false");
  MiniDFSCluster cluster=new MiniDFSCluster.Builder(conf).numDataNodes(3).build();
  DistributedFileSystem fs=null;
  try {
    fs=cluster.getFileSystem();
    Path path=new Path("/test");
    FSDataOutputStream out=fs.create(path);
    out.writeBytes("hello\n");
    out.close();
    DataNodeProperties dnProp=cluster.stopDataNode(0);
    String dnAddress=dnProp.datanode.getXferAddress().toString();
    if (dnAddress.startsWith("/")) {
      dnAddress=dnAddress.substring(1);
    }
    for (int i=0; i < 2; i++) {
      out=fs.append(path);
      out.writeBytes("helloagain\n");
      out.close();
    }
    out=fs.append(path);
    cluster.restartDataNode(dnProp,true);
    Thread.sleep(2000);
    BlockLocation[] locations=fs.getFileBlockLocations(path,0,Long.MAX_VALUE);
    String[] names=locations[0].getNames();
    for (    String node : names) {
      if (node.equals(dnAddress)) {
        fail("Failed append should not be present in latest block locations.");
      }
    }
    out.close();
  }
  finally {
    IOUtils.closeStream(fs);
    cluster.shutdown();
  }
}

</code></pre>

<br>
<pre class="type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test two consecutive appends on a file with a full block. 
 */
@Test public void testAppendTwice() throws Exception {
  Configuration conf=new HdfsConfiguration();
  MiniDFSCluster cluster=new MiniDFSCluster.Builder(conf).build();
  final FileSystem fs1=cluster.getFileSystem();
  final FileSystem fs2=AppendTestUtil.createHdfsWithDifferentUsername(conf);
  try {
    final Path p=new Path("/testAppendTwice/foo");
    final int len=1 << 16;
    final byte[] fileContents=AppendTestUtil.initBuffer(len);
{
      FSDataOutputStream out=fs2.create(p,true,4096,(short)1,len);
      out.write(fileContents,0,len);
      out.close();
    }
    fs2.append(p);
    fs1.append(p);
    Assert.fail();
  }
 catch (  RemoteException re) {
    AppendTestUtil.LOG.info("Got an exception:",re);
    Assert.assertEquals(AlreadyBeingCreatedException.class.getName(),re.getClassName());
  }
 finally {
    fs2.close();
    fs1.close();
    cluster.shutdown();
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.TestFileAppend2 </h4><pre class="type-2 type-7 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Creates one file, writes a few bytes to it and then closed it.
 * Reopens the same file for appending, write all blocks and then close.
 * Verify that all data exists in file.
 * @throws IOException an exception might be thrown
 */
@Test public void testSimpleAppend() throws IOException {
  final Configuration conf=new HdfsConfiguration();
  if (simulatedStorage) {
    SimulatedFSDataset.setFactory(conf);
  }
  conf.setInt(DFSConfigKeys.DFS_DATANODE_HANDLER_COUNT_KEY,50);
  fileContents=AppendTestUtil.initBuffer(AppendTestUtil.FILE_SIZE);
  MiniDFSCluster cluster=new MiniDFSCluster.Builder(conf).build();
  FileSystem fs=cluster.getFileSystem();
  try {
{
      Path file1=new Path("/simpleAppend.dat");
      FSDataOutputStream stm=AppendTestUtil.createFile(fs,file1,1);
      System.out.println("Created file simpleAppend.dat");
      int mid=186;
      System.out.println("Writing " + mid + " bytes to file "+ file1);
      stm.write(fileContents,0,mid);
      stm.close();
      System.out.println("Wrote and Closed first part of file.");
      int mid2=607;
      System.out.println("Writing " + mid + " bytes to file "+ file1);
      stm=fs.append(file1);
      stm.write(fileContents,mid,mid2 - mid);
      stm.close();
      System.out.println("Wrote and Closed second part of file.");
      stm=fs.append(file1);
      assertTrue(stm.getPos() > 0);
      System.out.println("Writing " + (AppendTestUtil.FILE_SIZE - mid2) + " bytes to file "+ file1);
      stm.write(fileContents,mid2,AppendTestUtil.FILE_SIZE - mid2);
      System.out.println("Written second part of file");
      stm.close();
      System.out.println("Wrote and Closed second part of file.");
      AppendTestUtil.checkFullFile(fs,file1,AppendTestUtil.FILE_SIZE,fileContents,"Read 2");
    }
{
      FSDataOutputStream out=null;
      try {
        out=fs.append(new Path("/non-existing.dat"));
        fail("Expected to have FileNotFoundException");
      }
 catch (      java.io.FileNotFoundException fnfe) {
        System.out.println("Good: got " + fnfe);
        fnfe.printStackTrace(System.out);
      }
 finally {
        IOUtils.closeStream(out);
      }
    }
{
      Path root=new Path("/");
      fs.setPermission(root,new FsPermission((short)0777));
      fs.close();
      final UserGroupInformation superuser=UserGroupInformation.getCurrentUser();
      String username="testappenduser";
      String group="testappendgroup";
      assertFalse(superuser.getShortUserName().equals(username));
      assertFalse(Arrays.asList(superuser.getGroupNames()).contains(group));
      UserGroupInformation appenduser=UserGroupInformation.createUserForTesting(username,new String[]{group});
      fs=DFSTestUtil.getFileSystemAs(appenduser,conf);
      Path dir=new Path(root,getClass().getSimpleName());
      Path foo=new Path(dir,"foo.dat");
      FSDataOutputStream out=null;
      int offset=0;
      try {
        out=fs.create(foo);
        int len=10 + AppendTestUtil.nextInt(100);
        out.write(fileContents,offset,len);
        offset+=len;
      }
  finally {
        IOUtils.closeStream(out);
      }
      fs.setPermission(dir,new FsPermission((short)0100));
      fs.setPermission(foo,new FsPermission((short)0200));
      out=null;
      try {
        out=fs.append(foo);
        int len=10 + AppendTestUtil.nextInt(100);
        out.write(fileContents,offset,len);
        offset+=len;
      }
  finally {
        IOUtils.closeStream(out);
      }
      fs.setPermission(foo,new FsPermission((short)0577));
      fs.setPermission(dir,new FsPermission((short)0777));
      out=null;
      try {
        out=fs.append(foo);
        fail("Expected to have AccessControlException");
      }
 catch (      AccessControlException ace) {
        System.out.println("Good: got " + ace);
        ace.printStackTrace(System.out);
      }
 finally {
        IOUtils.closeStream(out);
      }
    }
  }
 catch (  IOException e) {
    System.out.println("Exception :" + e);
    throw e;
  }
catch (  Throwable e) {
    System.out.println("Throwable :" + e);
    e.printStackTrace();
    throw new IOException("Throwable : " + e);
  }
 finally {
    fs.close();
    cluster.shutdown();
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.TestFileAppend3 </h4><pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * TC5: Only one simultaneous append.
 * @throws IOException an exception might be thrown
 */
@Test public void testTC5() throws Exception {
  final Path p=new Path("/TC5/foo");
  System.out.println("p=" + p);
{
    FSDataOutputStream out=fs.create(p,false,buffersize,REPLICATION,BLOCK_SIZE);
    AppendTestUtil.write(out,0,(int)(BLOCK_SIZE / 2));
    out.close();
  }
  FSDataOutputStream out=fs.append(p);
  try {
    AppendTestUtil.createHdfsWithDifferentUsername(conf).append(p);
    fail("This should fail.");
  }
 catch (  IOException ioe) {
    AppendTestUtil.LOG.info("GOOD: got an exception",ioe);
  }
  out.close();
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.TestFileAppend4 </h4><pre class="type-2 type-7 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test that an append with no locations fails with an exception
 * showing insufficient locations.
 */
@Test(timeout=60000) public void testAppendInsufficientLocations() throws Exception {
  Configuration conf=new Configuration();
  conf.setInt(DFSConfigKeys.DFS_NAMENODE_HEARTBEAT_RECHECK_INTERVAL_KEY,1000);
  conf.setInt(DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_KEY,1);
  conf.setInt(DFSConfigKeys.DFS_CLIENT_SOCKET_TIMEOUT_KEY,3000);
  cluster=new MiniDFSCluster.Builder(conf).numDataNodes(4).build();
  DistributedFileSystem fileSystem=null;
  try {
    fileSystem=cluster.getFileSystem();
    Path f=new Path("/testAppend");
    FSDataOutputStream create=fileSystem.create(f,(short)2);
    create.write("/testAppend".getBytes());
    create.close();
    DFSTestUtil.waitReplication(fileSystem,f,(short)2);
    LocatedBlocks lbs=fileSystem.dfs.getNamenode().getBlockLocations("/testAppend",0,Long.MAX_VALUE);
    List<DataNode> dnsOfCluster=cluster.getDataNodes();
    DatanodeInfo[] dnsWithLocations=lbs.getLastLocatedBlock().getLocations();
    for (    DataNode dn : dnsOfCluster) {
      for (      DatanodeInfo loc : dnsWithLocations) {
        if (dn.getDatanodeId().equals(loc)) {
          dn.shutdown();
          DFSTestUtil.waitForDatanodeDeath(dn);
        }
      }
    }
    DFSTestUtil.waitReplication(fileSystem,f,(short)0);
    try {
      fileSystem.append(f);
      fail("Append should fail because insufficient locations");
    }
 catch (    IOException e) {
      LOG.info("Expected exception: ",e);
    }
    FSDirectory dir=cluster.getNamesystem().getFSDirectory();
    final INodeFile inode=INodeFile.valueOf(dir.getINode("/testAppend"),"/testAppend");
    assertTrue("File should remain closed",!inode.isUnderConstruction());
  }
  finally {
    if (null != fileSystem) {
      fileSystem.close();
    }
    cluster.shutdown();
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.TestFileConcurrentReader </h4><pre class="type-2 type-1 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=30000) public void testImmediateReadOfNewFile() throws IOException {
  final int blockSize=64 * 1024;
  final int writeSize=10 * blockSize;
  Configuration conf=new Configuration();
  conf.setLong(DFSConfigKeys.DFS_BLOCK_SIZE_KEY,blockSize);
  init(conf);
  final int requiredSuccessfulOpens=100;
  final Path file=new Path("/file1");
  final AtomicBoolean openerDone=new AtomicBoolean(false);
  final AtomicReference<String> errorMessage=new AtomicReference<String>();
  final FSDataOutputStream out=fileSystem.create(file);
  final Thread writer=new Thread(new Runnable(){
    @Override public void run(){
      try {
        while (!openerDone.get()) {
          out.write(DFSTestUtil.generateSequentialBytes(0,writeSize));
          out.hflush();
        }
      }
 catch (      IOException e) {
        LOG.warn("error in writer",e);
      }
 finally {
        try {
          out.close();
        }
 catch (        IOException e) {
          LOG.error("unable to close file");
        }
      }
    }
  }
);
  Thread opener=new Thread(new Runnable(){
    @Override public void run(){
      try {
        for (int i=0; i < requiredSuccessfulOpens; i++) {
          fileSystem.open(file).close();
        }
        openerDone.set(true);
      }
 catch (      IOException e) {
        openerDone.set(true);
        errorMessage.set(String.format("got exception : %s",StringUtils.stringifyException(e)));
      }
catch (      Exception e) {
        openerDone.set(true);
        errorMessage.set(String.format("got exception : %s",StringUtils.stringifyException(e)));
        writer.interrupt();
        fail("here");
      }
    }
  }
);
  writer.start();
  opener.start();
  try {
    writer.join();
    opener.join();
  }
 catch (  InterruptedException e) {
    Thread.currentThread().interrupt();
  }
  assertNull(errorMessage.get(),errorMessage.get());
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.TestFileCreation </h4><pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * test addBlock(..) when replication<min and excludeNodes==null. 
 */
@Test public void testFileCreationError3() throws IOException {
  System.out.println("testFileCreationError3 start");
  Configuration conf=new HdfsConfiguration();
  MiniDFSCluster cluster=new MiniDFSCluster.Builder(conf).numDataNodes(0).build();
  DistributedFileSystem dfs=null;
  try {
    cluster.waitActive();
    dfs=cluster.getFileSystem();
    DFSClient client=dfs.dfs;
    final Path f=new Path("/foo.txt");
    createFile(dfs,f,3);
    try {
      cluster.getNameNodeRpc().addBlock(f.toString(),client.clientName,null,null,INodeId.GRANDFATHER_INODE_ID,null);
      fail();
    }
 catch (    IOException ioe) {
      FileSystem.LOG.info("GOOD!",ioe);
    }
    System.out.println("testFileCreationError3 successful");
  }
  finally {
    IOUtils.closeStream(dfs);
    cluster.shutdown();
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * Test complete(..) - verifies that the fileId in the request
 * matches that of the Inode.
 * This test checks that FileNotFoundException exception is thrown in case
 * the fileId does not match.
 */
@Test public void testFileIdMismatch() throws IOException {
  Configuration conf=new HdfsConfiguration();
  MiniDFSCluster cluster=new MiniDFSCluster.Builder(conf).numDataNodes(3).build();
  DistributedFileSystem dfs=null;
  try {
    cluster.waitActive();
    dfs=cluster.getFileSystem();
    DFSClient client=dfs.dfs;
    final Path f=new Path("/testFileIdMismatch.txt");
    createFile(dfs,f,3);
    long someOtherFileId=-1;
    try {
      cluster.getNameNodeRpc().complete(f.toString(),client.clientName,null,someOtherFileId);
      fail();
    }
 catch (    LeaseExpiredException e) {
      FileSystem.LOG.info("Caught Expected LeaseExpiredException: ",e);
    }
  }
  finally {
    IOUtils.closeStream(dfs);
    cluster.shutdown();
  }
}

</code></pre>

<br>
<pre class="type-2 type-15 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Sets implicit assumptions ">AssumptionSetter</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Sets implicit assumptions 
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Same test but the client should bind to a local interface 
 */
@Test public void testFileCreationSetLocalInterface() throws IOException {
  assumeTrue(System.getProperty("os.name").startsWith("Linux"));
  checkFileCreation("lo",false);
  try {
    checkFileCreation("bogus-interface",false);
    fail("Able to specify a bogus interface");
  }
 catch (  UnknownHostException e) {
    assertEquals("No such interface bogus-interface",e.getMessage());
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * Test that a file which is open for write is overwritten by another
 * client. Regression test for HDFS-3755.
 */
@Test public void testOverwriteOpenForWrite() throws Exception {
  Configuration conf=new HdfsConfiguration();
  SimulatedFSDataset.setFactory(conf);
  conf.setBoolean(DFSConfigKeys.DFS_PERMISSIONS_ENABLED_KEY,false);
  final MiniDFSCluster cluster=new MiniDFSCluster.Builder(conf).build();
  FileSystem fs=cluster.getFileSystem();
  UserGroupInformation otherUgi=UserGroupInformation.createUserForTesting("testuser",new String[]{"testgroup"});
  FileSystem fs2=otherUgi.doAs(new PrivilegedExceptionAction<FileSystem>(){
    @Override public FileSystem run() throws Exception {
      return FileSystem.get(cluster.getConfiguration(0));
    }
  }
);
  String metricsName=RPC_DETAILED_METRICS + cluster.getNameNodePort();
  try {
    Path p=new Path("/testfile");
    FSDataOutputStream stm1=fs.create(p);
    stm1.write(1);
    assertCounter("CreateNumOps",1L,getMetrics(metricsName));
    try {
      fs2.create(p,false);
      fail("Did not throw!");
    }
 catch (    IOException abce) {
      GenericTestUtils.assertExceptionContains("already being created by",abce);
    }
    assertCounter("AlreadyBeingCreatedExceptionNumOps",6L,getMetrics(metricsName));
    FSDataOutputStream stm2=fs2.create(p,true);
    stm2.write(2);
    stm2.close();
    try {
      stm1.close();
      fail("Should have exception closing stm1 since it was deleted");
    }
 catch (    IOException ioe) {
      GenericTestUtils.assertExceptionContains("No lease on /testfile",ioe);
      GenericTestUtils.assertExceptionContains("File does not exist.",ioe);
    }
  }
  finally {
    IOUtils.closeStream(fs);
    IOUtils.closeStream(fs2);
    cluster.shutdown();
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.TestFileLengthOnClusterRestart </h4><pre class="type-2 type-7 type-10 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Tests the fileLength when we sync the file and restart the cluster and
 * Datanodes not report to Namenode yet.
 */
@Test(timeout=60000) public void testFileLengthWithHSyncAndClusterRestartWithOutDNsRegister() throws Exception {
  final Configuration conf=new HdfsConfiguration();
  conf.setInt(DFSConfigKeys.DFS_BLOCK_SIZE_KEY,512);
  final MiniDFSCluster cluster=new MiniDFSCluster.Builder(conf).numDataNodes(2).build();
  HdfsDataInputStream in=null;
  try {
    Path path=new Path("/tmp/TestFileLengthOnClusterRestart","test");
    DistributedFileSystem dfs=cluster.getFileSystem();
    FSDataOutputStream out=dfs.create(path);
    int fileLength=1030;
    out.write(new byte[fileLength]);
    out.hsync();
    cluster.restartNameNode();
    cluster.waitActive();
    in=(HdfsDataInputStream)dfs.open(path,1024);
    Assert.assertEquals(fileLength,in.getVisibleLength());
    cluster.shutdownDataNodes();
    cluster.restartNameNode(false);
    verifyNNIsInSafeMode(dfs);
    try {
      in=(HdfsDataInputStream)dfs.open(path);
      Assert.fail("Expected IOException");
    }
 catch (    IOException e) {
      Assert.assertTrue(e.getLocalizedMessage().indexOf("Name node is in safe mode") >= 0);
    }
  }
  finally {
    if (null != in) {
      in.close();
    }
    cluster.shutdown();
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.TestFileStatus </h4><pre class="type-2 type-10 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test getting a FileStatus object using a non-existant path 
 */
@Test public void testGetFileStatusOnNonExistantFileDir() throws IOException {
  Path dir=new Path("/test/mkdirs");
  try {
    fs.listStatus(dir);
    fail("listStatus of non-existent path should fail");
  }
 catch (  FileNotFoundException fe) {
    assertEquals("File " + dir + " does not exist.",fe.getMessage());
  }
  try {
    fc.listStatus(dir);
    fail("listStatus of non-existent path should fail");
  }
 catch (  FileNotFoundException fe) {
    assertEquals("File " + dir + " does not exist.",fe.getMessage());
  }
  try {
    fs.getFileStatus(dir);
    fail("getFileStatus of non-existent path should fail");
  }
 catch (  FileNotFoundException fe) {
    assertTrue("Exception doesn't indicate non-existant path",fe.getMessage().startsWith("File does not exist"));
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-10 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test calling getFileInfo directly on the client 
 */
@Test public void testGetFileInfo() throws IOException {
  Path path=new Path("/");
  assertTrue("/ should be a directory",fs.getFileStatus(path).isDirectory());
  HdfsFileStatus fileInfo=dfsClient.getFileInfo("/noSuchFile");
  assertEquals("Non-existant file should result in null",null,fileInfo);
  Path path1=new Path("/name1");
  Path path2=new Path("/name1/name2");
  assertTrue(fs.mkdirs(path1));
  FSDataOutputStream out=fs.create(path2,false);
  out.close();
  fileInfo=dfsClient.getFileInfo(path1.toString());
  assertEquals(1,fileInfo.getChildrenNum());
  fileInfo=dfsClient.getFileInfo(path2.toString());
  assertEquals(0,fileInfo.getChildrenNum());
  try {
    dfsClient.getFileInfo("non-absolute");
    fail("getFileInfo for a non-absolute path did not throw IOException");
  }
 catch (  RemoteException re) {
    assertTrue("Wrong exception for invalid file name",re.toString().contains("Invalid file name"));
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.TestLease </h4><pre class="type-9 type-11 type-2 type-7 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testLeaseAbort() throws Exception {
  MiniDFSCluster cluster=new MiniDFSCluster.Builder(conf).numDataNodes(2).build();
  try {
    cluster.waitActive();
    NamenodeProtocols preSpyNN=cluster.getNameNodeRpc();
    NamenodeProtocols spyNN=spy(preSpyNN);
    DFSClient dfs=new DFSClient(null,spyNN,conf,null);
    byte[] buf=new byte[1024];
    FSDataOutputStream c_out=createFsOut(dfs,dirString + "c");
    c_out.write(buf,0,1024);
    c_out.close();
    DFSInputStream c_in=dfs.open(dirString + "c");
    FSDataOutputStream d_out=createFsOut(dfs,dirString + "d");
    doThrow(new RemoteException(InvalidToken.class.getName(),"Your token is worthless")).when(spyNN).renewLease(anyString());
    LeaseRenewer originalRenewer=dfs.getLeaseRenewer();
    dfs.lastLeaseRenewal=Time.now() - HdfsConstants.LEASE_SOFTLIMIT_PERIOD - 1000;
    try {
      dfs.renewLease();
    }
 catch (    IOException e) {
    }
    try {
      d_out.write(buf,0,1024);
      LOG.info("Write worked beyond the soft limit as expected.");
    }
 catch (    IOException e) {
      Assert.fail("Write failed.");
    }
    dfs.lastLeaseRenewal=Time.now() - HdfsConstants.LEASE_HARDLIMIT_PERIOD - 1000;
    dfs.renewLease();
    try {
      d_out.write(buf,0,1024);
      d_out.close();
      Assert.fail("Write did not fail even after the fatal lease renewal failure");
    }
 catch (    IOException e) {
      LOG.info("Write failed as expected. ",e);
    }
    Thread.sleep(1000);
    Assert.assertTrue(originalRenewer.isEmpty());
    doNothing().when(spyNN).renewLease(anyString());
    try {
      int num=c_in.read(buf,0,1);
      if (num != 1) {
        Assert.fail("Failed to read 1 byte");
      }
      c_in.close();
    }
 catch (    IOException e) {
      LOG.error("Read failed with ",e);
      Assert.fail("Read after lease renewal failure failed");
    }
    try {
      c_out=createFsOut(dfs,dirString + "c");
      c_out.write(buf,0,1024);
      c_out.close();
    }
 catch (    IOException e) {
      LOG.error("Write failed with ",e);
      Assert.fail("Write failed");
    }
  }
  finally {
    cluster.shutdown();
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.TestLeaseRecovery2 </h4><pre class="type-9 type-2 type-7 type-10 type-6 type-20 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values related to public fields.">PublicFieldVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Verifies values related to public fields.
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * This test makes the client does not renew its lease and also
 * set the hard lease expiration period to be short 1s. Thus triggering
 * lease expiration to happen while the client is still alive.
 * The test makes sure that the lease recovery completes and the client
 * fails if it continues to write to the file.
 * @throws Exception
 */
@Test public void testHardLeaseRecovery() throws Exception {
  String filestr="/hardLeaseRecovery";
  AppendTestUtil.LOG.info("filestr=" + filestr);
  Path filepath=new Path(filestr);
  FSDataOutputStream stm=dfs.create(filepath,true,BUF_SIZE,REPLICATION_NUM,BLOCK_SIZE);
  assertTrue(dfs.dfs.exists(filestr));
  int size=AppendTestUtil.nextInt(FILE_SIZE);
  AppendTestUtil.LOG.info("size=" + size);
  stm.write(buffer,0,size);
  AppendTestUtil.LOG.info("hflush");
  stm.hflush();
  AppendTestUtil.LOG.info("leasechecker.interruptAndJoin()");
  dfs.dfs.getLeaseRenewer().interruptAndJoin();
  cluster.setLeasePeriod(LONG_LEASE_PERIOD,SHORT_LEASE_PERIOD);
  LocatedBlocks locatedBlocks;
  do {
    Thread.sleep(SHORT_LEASE_PERIOD);
    locatedBlocks=dfs.dfs.getLocatedBlocks(filestr,0L,size);
  }
 while (locatedBlocks.isUnderConstruction());
  assertEquals(size,locatedBlocks.getFileLength());
  try {
    stm.write('b');
    stm.close();
    fail("Writer thread should have been killed");
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
  AppendTestUtil.LOG.info("File size is good. Now validating sizes from datanodes...");
  AppendTestUtil.checkFullFile(dfs,filepath,size,buffer,filestr);
}

</code></pre>

<br>
<pre class="type-9 type-13 type-2 type-7 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions in iterations
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * This test makes the client does not renew its lease and also
 * set the soft lease expiration period to be short 1s. Thus triggering
 * soft lease expiration to happen immediately by having another client
 * trying to create the same file.
 * The test makes sure that the lease recovery completes.
 * @throws Exception
 */
@Test public void testSoftLeaseRecovery() throws Exception {
  Map<String,String[]> u2g_map=new HashMap<String,String[]>(1);
  u2g_map.put(fakeUsername,new String[]{fakeGroup});
  DFSTestUtil.updateConfWithFakeGroupMapping(conf,u2g_map);
  cluster.setLeasePeriod(HdfsConstants.LEASE_SOFTLIMIT_PERIOD,HdfsConstants.LEASE_HARDLIMIT_PERIOD);
  String filestr="/foo" + AppendTestUtil.nextInt();
  AppendTestUtil.LOG.info("filestr=" + filestr);
  Path filepath=new Path(filestr);
  FSDataOutputStream stm=dfs.create(filepath,true,BUF_SIZE,REPLICATION_NUM,BLOCK_SIZE);
  assertTrue(dfs.dfs.exists(filestr));
  int size=AppendTestUtil.nextInt(FILE_SIZE);
  AppendTestUtil.LOG.info("size=" + size);
  stm.write(buffer,0,size);
  AppendTestUtil.LOG.info("hflush");
  stm.hflush();
  AppendTestUtil.LOG.info("leasechecker.interruptAndJoin()");
  dfs.dfs.getLeaseRenewer().interruptAndJoin();
  cluster.setLeasePeriod(SHORT_LEASE_PERIOD,LONG_LEASE_PERIOD);
{
    UserGroupInformation ugi=UserGroupInformation.createUserForTesting(fakeUsername,new String[]{fakeGroup});
    FileSystem dfs2=DFSTestUtil.getFileSystemAs(ugi,conf);
    boolean done=false;
    for (int i=0; i < 10 && !done; i++) {
      AppendTestUtil.LOG.info("i=" + i);
      try {
        dfs2.create(filepath,false,BUF_SIZE,REPLICATION_NUM,BLOCK_SIZE);
        fail("Creation of an existing file should never succeed.");
      }
 catch (      FileAlreadyExistsException ex) {
        done=true;
      }
catch (      AlreadyBeingCreatedException ex) {
        AppendTestUtil.LOG.info("GOOD! got " + ex.getMessage());
      }
catch (      IOException ioe) {
        AppendTestUtil.LOG.warn("UNEXPECTED IOException",ioe);
      }
      if (!done) {
        AppendTestUtil.LOG.info("sleep " + 5000 + "ms");
        try {
          Thread.sleep(5000);
        }
 catch (        InterruptedException e) {
        }
      }
    }
    assertTrue(done);
  }
  AppendTestUtil.LOG.info("Lease for file " + filepath + " is recovered. "+ "Validating its contents now...");
  long fileSize=dfs.getFileStatus(filepath).getLen();
  assertTrue("File should be " + size + " bytes, but is actually "+ " found to be "+ fileSize+ " bytes",fileSize == size);
  AppendTestUtil.LOG.info("File size is good. " + "Now validating data and sizes from datanodes...");
  AppendTestUtil.checkFullFile(dfs,filepath,size,buffer,filestr);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.TestLeaseRenewer </h4><pre class="type-11 type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testRenewal() throws Exception {
  final AtomicInteger leaseRenewalCount=new AtomicInteger();
  Mockito.doAnswer(new Answer<Boolean>(){
    @Override public Boolean answer(    InvocationOnMock invocation) throws Throwable {
      leaseRenewalCount.incrementAndGet();
      return true;
    }
  }
).when(MOCK_DFSCLIENT).renewLease();
  DFSOutputStream mockStream=Mockito.mock(DFSOutputStream.class);
  long fileId=123L;
  renewer.put(fileId,mockStream,MOCK_DFSCLIENT);
  long failTime=Time.now() + 5000;
  while (Time.now() < failTime && leaseRenewalCount.get() == 0) {
    Thread.sleep(50);
  }
  if (leaseRenewalCount.get() == 0) {
    Assert.fail("Did not renew lease at all!");
  }
  renewer.closeFile(fileId,MOCK_DFSCLIENT);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.TestQuota </h4><pre class="type-2 type-7 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test limit cases for setting space quotas.
 */
@Test public void testMaxSpaceQuotas() throws Exception {
  final Configuration conf=new HdfsConfiguration();
  final MiniDFSCluster cluster=new MiniDFSCluster.Builder(conf).numDataNodes(2).build();
  try {
    final FileSystem fs=cluster.getFileSystem();
    assertTrue("Not a HDFS: " + fs.getUri(),fs instanceof DistributedFileSystem);
    final DistributedFileSystem dfs=(DistributedFileSystem)fs;
    final Path testFolder=new Path("/testFolder");
    assertTrue(dfs.mkdirs(testFolder));
    dfs.setQuota(testFolder,Long.MAX_VALUE - 1,10);
    ContentSummary c=dfs.getContentSummary(testFolder);
    assertTrue("Quota not set properly",c.getQuota() == Long.MAX_VALUE - 1);
    dfs.setQuota(testFolder,10,Long.MAX_VALUE - 1);
    c=dfs.getContentSummary(testFolder);
    assertTrue("Quota not set properly",c.getSpaceQuota() == Long.MAX_VALUE - 1);
    dfs.setQuota(testFolder,Long.MAX_VALUE,10);
    c=dfs.getContentSummary(testFolder);
    assertTrue("Quota should not have changed",c.getQuota() == 10);
    dfs.setQuota(testFolder,10,Long.MAX_VALUE);
    c=dfs.getContentSummary(testFolder);
    assertTrue("Quota should not have changed",c.getSpaceQuota() == 10);
    try {
      dfs.setQuota(testFolder,Long.MAX_VALUE + 1,10);
      fail("Exception not thrown");
    }
 catch (    IllegalArgumentException e) {
    }
    try {
      dfs.setQuota(testFolder,10,Long.MAX_VALUE + 1);
      fail("Exception not thrown");
    }
 catch (    IllegalArgumentException e) {
    }
  }
  finally {
    cluster.shutdown();
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-10 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test quota related commands: 
 * setQuota, clrQuota, setSpaceQuota, clrSpaceQuota, and count 
 */
@Test public void testQuotaCommands() throws Exception {
  final Configuration conf=new HdfsConfiguration();
  final int DEFAULT_BLOCK_SIZE=512;
  conf.setLong(DFSConfigKeys.DFS_BLOCK_SIZE_KEY,DEFAULT_BLOCK_SIZE);
  conf.setInt(DFSConfigKeys.DFS_CONTENT_SUMMARY_LIMIT_KEY,2);
  final MiniDFSCluster cluster=new MiniDFSCluster.Builder(conf).numDataNodes(2).build();
  final FileSystem fs=cluster.getFileSystem();
  assertTrue("Not a HDFS: " + fs.getUri(),fs instanceof DistributedFileSystem);
  final DistributedFileSystem dfs=(DistributedFileSystem)fs;
  DFSAdmin admin=new DFSAdmin(conf);
  try {
    final int fileLen=1024;
    final short replication=5;
    final long spaceQuota=fileLen * replication * 15 / 8;
    final Path parent=new Path("/test");
    assertTrue(dfs.mkdirs(parent));
    String[] args=new String[]{"-setQuota","3",parent.toString()};
    runCommand(admin,args,false);
    runCommand(admin,false,"-setSpaceQuota","2t",parent.toString());
    assertEquals(2L << 40,dfs.getContentSummary(parent).getSpaceQuota());
    runCommand(admin,false,"-setSpaceQuota",Long.toString(spaceQuota),parent.toString());
    final Path childDir0=new Path(parent,"data0");
    assertTrue(dfs.mkdirs(childDir0));
    final Path childFile0=new Path(parent,"datafile0");
    DFSTestUtil.createFile(fs,childFile0,fileLen,replication,0);
    ContentSummary c=dfs.getContentSummary(parent);
    assertEquals(c.getFileCount() + c.getDirectoryCount(),3);
    assertEquals(c.getQuota(),3);
    assertEquals(c.getSpaceConsumed(),fileLen * replication);
    assertEquals(c.getSpaceQuota(),spaceQuota);
    c=dfs.getContentSummary(childDir0);
    assertEquals(c.getFileCount() + c.getDirectoryCount(),1);
    assertEquals(c.getQuota(),-1);
    c=dfs.getContentSummary(parent);
    assertEquals(c.getSpaceConsumed(),fileLen * replication);
    final Path childDir1=new Path(parent,"data1");
    boolean hasException=false;
    try {
      assertFalse(dfs.mkdirs(childDir1));
    }
 catch (    QuotaExceededException e) {
      hasException=true;
    }
    assertTrue(hasException);
    OutputStream fout;
    final Path childFile1=new Path(parent,"datafile1");
    hasException=false;
    try {
      fout=dfs.create(childFile1);
    }
 catch (    QuotaExceededException e) {
      hasException=true;
    }
    assertTrue(hasException);
    runCommand(admin,new String[]{"-clrQuota",parent.toString()},false);
    c=dfs.getContentSummary(parent);
    assertEquals(c.getQuota(),-1);
    assertEquals(c.getSpaceQuota(),spaceQuota);
    runCommand(admin,new String[]{"-clrQuota",childDir0.toString()},false);
    c=dfs.getContentSummary(childDir0);
    assertEquals(c.getQuota(),-1);
    fout=dfs.create(childFile1,replication);
    try {
      fout.write(new byte[fileLen]);
      fout.close();
      Assert.fail();
    }
 catch (    QuotaExceededException e) {
      IOUtils.closeStream(fout);
    }
    dfs.delete(childFile1,false);
    runCommand(admin,false,"-clrSpaceQuota",parent.toString());
    c=dfs.getContentSummary(parent);
    assertEquals(c.getQuota(),-1);
    assertEquals(c.getSpaceQuota(),-1);
    DFSTestUtil.createFile(dfs,childFile1,fileLen,replication,0);
    args=new String[]{"-setQuota","1",parent.toString()};
    runCommand(admin,args,false);
    runCommand(admin,false,"-setSpaceQuota",Integer.toString(fileLen),args[2]);
    args=new String[]{"-setQuota","1",childDir0.toString()};
    runCommand(admin,args,false);
    hasException=false;
    try {
      assertFalse(dfs.mkdirs(new Path(childDir0,"in")));
    }
 catch (    QuotaExceededException e) {
      hasException=true;
    }
    assertTrue(hasException);
    c=dfs.getContentSummary(childDir0);
    assertEquals(c.getDirectoryCount() + c.getFileCount(),1);
    assertEquals(c.getQuota(),1);
    Path nonExistentPath=new Path("/test1");
    assertFalse(dfs.exists(nonExistentPath));
    args=new String[]{"-setQuota","1",nonExistentPath.toString()};
    runCommand(admin,args,true);
    runCommand(admin,true,"-setSpaceQuota","1g",nonExistentPath.toString());
    assertTrue(dfs.isFile(childFile0));
    args[1]=childFile0.toString();
    runCommand(admin,args,true);
    runCommand(admin,true,"-setSpaceQuota","1t",args[1]);
    args[0]="-clrQuota";
    runCommand(admin,args,true);
    runCommand(admin,true,"-clrSpaceQuota",args[1]);
    args[1]=nonExistentPath.toString();
    runCommand(admin,args,true);
    runCommand(admin,true,"-clrSpaceQuota",args[1]);
    args=new String[]{"-setQuota","0",parent.toString()};
    runCommand(admin,args,true);
    runCommand(admin,true,"-setSpaceQuota","0",args[2]);
    args[1]="-1";
    runCommand(admin,args,true);
    runCommand(admin,true,"-setSpaceQuota",args[1],args[2]);
    args[1]=String.valueOf(Long.MAX_VALUE + 1L);
    runCommand(admin,args,true);
    runCommand(admin,true,"-setSpaceQuota",args[1],args[2]);
    args[1]="33aa1.5";
    runCommand(admin,args,true);
    runCommand(admin,true,"-setSpaceQuota",args[1],args[2]);
    runCommand(admin,true,"-setSpaceQuota",(Long.MAX_VALUE / 1024 / 1024 + 1024) + "m",args[2]);
    final String username="userxx";
    UserGroupInformation ugi=UserGroupInformation.createUserForTesting(username,new String[]{"groupyy"});
    final String[] args2=args.clone();
    ugi.doAs(new PrivilegedExceptionAction(){
      @Override public Object run() throws Exception {
        assertEquals("Not running as new user",username,UserGroupInformation.getCurrentUser().getShortUserName());
        DFSAdmin userAdmin=new DFSAdmin(conf);
        args2[1]="100";
        runCommand(userAdmin,args2,true);
        runCommand(userAdmin,true,"-setSpaceQuota","1g",args2[2]);
        String[] args3=new String[]{"-clrQuota",parent.toString()};
        runCommand(userAdmin,args3,true);
        runCommand(userAdmin,true,"-clrSpaceQuota",args3[1]);
        return null;
      }
    }
);
    runCommand(admin,true,"-clrQuota","/");
    runCommand(admin,false,"-setQuota","1000000","/");
    runCommand(admin,true,"-clrQuota","/");
    runCommand(admin,false,"-clrSpaceQuota","/");
    runCommand(admin,new String[]{"-clrQuota",parent.toString()},false);
    runCommand(admin,false,"-clrSpaceQuota",parent.toString());
    final Path childDir2=new Path(parent,"data2");
    assertTrue(dfs.mkdirs(childDir2));
    final Path childFile2=new Path(childDir2,"datafile2");
    final Path childFile3=new Path(childDir2,"datafile3");
    final long spaceQuota2=DEFAULT_BLOCK_SIZE * replication;
    final long fileLen2=DEFAULT_BLOCK_SIZE;
    runCommand(admin,false,"-setSpaceQuota",Long.toString(spaceQuota2),childDir2.toString());
    runCommand(admin,false,"-clrSpaceQuota",childDir2.toString());
    DFSTestUtil.createFile(fs,childFile2,fileLen2,replication,0);
    runCommand(admin,false,"-setSpaceQuota",Long.toString(spaceQuota2),childDir2.toString());
    hasException=false;
    try {
      DFSTestUtil.createFile(fs,childFile3,fileLen2,replication,0);
    }
 catch (    DSQuotaExceededException e) {
      hasException=true;
    }
    assertTrue(hasException);
    final Path childFile4=new Path("/","datafile2");
    final Path childFile5=new Path("/","datafile3");
    runCommand(admin,true,"-clrQuota","/");
    runCommand(admin,false,"-clrSpaceQuota","/");
    runCommand(admin,false,"-setSpaceQuota",Long.toString(spaceQuota2),"/");
    runCommand(admin,false,"-clrSpaceQuota","/");
    DFSTestUtil.createFile(fs,childFile4,fileLen2,replication,0);
    runCommand(admin,false,"-setSpaceQuota",Long.toString(spaceQuota2),"/");
    hasException=false;
    try {
      DFSTestUtil.createFile(fs,childFile5,fileLen2,replication,0);
    }
 catch (    DSQuotaExceededException e) {
      hasException=true;
    }
    assertTrue(hasException);
    assertEquals(4,cluster.getNamesystem().getFSDirectory().getYieldCount());
  }
  finally {
    cluster.shutdown();
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.TestReplaceDatanodeOnFailure </h4><pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testAppend() throws Exception {
  final Configuration conf=new HdfsConfiguration();
  final short REPLICATION=(short)3;
  Assert.assertEquals(ReplaceDatanodeOnFailure.DEFAULT,ReplaceDatanodeOnFailure.get(conf));
  final MiniDFSCluster cluster=new MiniDFSCluster.Builder(conf).numDataNodes(1).build();
  try {
    final DistributedFileSystem fs=cluster.getFileSystem();
    final Path f=new Path(DIR,"testAppend");
{
      LOG.info("create an empty file " + f);
      fs.create(f,REPLICATION).close();
      final FileStatus status=fs.getFileStatus(f);
      Assert.assertEquals(REPLICATION,status.getReplication());
      Assert.assertEquals(0L,status.getLen());
    }
    final byte[] bytes=new byte[1000];
{
      LOG.info("append " + bytes.length + " bytes to "+ f);
      final FSDataOutputStream out=fs.append(f);
      out.write(bytes);
      out.close();
      final FileStatus status=fs.getFileStatus(f);
      Assert.assertEquals(REPLICATION,status.getReplication());
      Assert.assertEquals(bytes.length,status.getLen());
    }
{
      LOG.info("append another " + bytes.length + " bytes to "+ f);
      try {
        final FSDataOutputStream out=fs.append(f);
        out.write(bytes);
        out.close();
        Assert.fail();
      }
 catch (      IOException ioe) {
        LOG.info("This exception is expected",ioe);
      }
    }
  }
  finally {
    if (cluster != null) {
      cluster.shutdown();
    }
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.TestReservedRawPaths </h4><pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test(timeout=120000) public void testAdminAccessOnly() throws Exception {
  final Path zone=new Path("zone");
  final Path slashZone=new Path("/",zone);
  fs.mkdirs(slashZone);
  dfsAdmin.createEncryptionZone(slashZone,TEST_KEY);
  final Path base=new Path("base");
  final Path reservedRaw=new Path("/.reserved/raw");
  final int len=8192;
  final UserGroupInformation user=UserGroupInformation.createUserForTesting("user",new String[]{"mygroup"});
  user.doAs(new PrivilegedExceptionAction(){
    @Override public Object run() throws Exception {
      final DistributedFileSystem fs=cluster.getFileSystem();
      try {
        final Path ezRawEncFile=new Path(new Path(reservedRaw,zone),base);
        DFSTestUtil.createFile(fs,ezRawEncFile,len,(short)1,0xFEED);
        fail("access to /.reserved/raw is superuser-only operation");
      }
 catch (      AccessControlException e) {
        assertExceptionContains("Superuser privilege is required",e);
      }
      return null;
    }
  }
);
  final Path ezRawEncFile=new Path(new Path(reservedRaw,zone),base);
  DFSTestUtil.createFile(fs,ezRawEncFile,len,(short)1,0xFEED);
  user.doAs(new PrivilegedExceptionAction(){
    @Override public Object run() throws Exception {
      final DistributedFileSystem fs=cluster.getFileSystem();
      try {
        fs.getFileStatus(ezRawEncFile);
        fail("access to /.reserved/raw is superuser-only operation");
      }
 catch (      AccessControlException e) {
        assertExceptionContains("Superuser privilege is required",e);
      }
      return null;
    }
  }
);
  user.doAs(new PrivilegedExceptionAction(){
    @Override public Object run() throws Exception {
      final DistributedFileSystem fs=cluster.getFileSystem();
      try {
        fs.listStatus(ezRawEncFile);
        fail("access to /.reserved/raw is superuser-only operation");
      }
 catch (      AccessControlException e) {
        assertExceptionContains("Superuser privilege is required",e);
      }
      return null;
    }
  }
);
  fs.setPermission(new Path("/"),new FsPermission((short)0777));
  user.doAs(new PrivilegedExceptionAction(){
    @Override public Object run() throws Exception {
      final DistributedFileSystem fs=cluster.getFileSystem();
      final Path d1=new Path(reservedRaw,"dir1");
      try {
        fs.mkdirs(d1);
        fail("access to /.reserved/raw is superuser-only operation");
      }
 catch (      AccessControlException e) {
        assertExceptionContains("Superuser privilege is required",e);
      }
      return null;
    }
  }
);
}

</code></pre>

<br>
<pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=120000) public void testListDotReserved() throws Exception {
  final Path baseFileRaw=new Path("/.reserved/raw/base");
  final int len=8192;
  DFSTestUtil.createFile(fs,baseFileRaw,len,(short)1,0xFEED);
  try {
    fs.listStatus(new Path("/.reserved"));
    fail("expected FNFE");
  }
 catch (  FileNotFoundException e) {
    assertExceptionContains("/.reserved does not exist",e);
  }
  try {
    fs.listStatus(new Path("/.reserved/.inodes"));
    fail("expected FNFE");
  }
 catch (  FileNotFoundException e) {
    assertExceptionContains("/.reserved/.inodes does not exist",e);
  }
  final FileStatus[] fileStatuses=fs.listStatus(new Path("/.reserved/raw"));
  assertEquals("expected 1 entry",fileStatuses.length,1);
  assertMatches(fileStatuses[0].getPath().toString(),"/.reserved/raw/base");
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.TestRollingUpgrade </h4><pre class="type-2 type-7 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=300000) public void testCheckpoint() throws IOException, InterruptedException {
  final Configuration conf=new Configuration();
  conf.setInt(DFSConfigKeys.DFS_HA_TAILEDITS_PERIOD_KEY,1);
  conf.setInt(DFSConfigKeys.DFS_NAMENODE_CHECKPOINT_PERIOD_KEY,1);
  MiniQJMHACluster cluster=null;
  final Path foo=new Path("/foo");
  try {
    cluster=new MiniQJMHACluster.Builder(conf).build();
    MiniDFSCluster dfsCluster=cluster.getDfsCluster();
    dfsCluster.waitActive();
    dfsCluster.transitionToActive(0);
    DistributedFileSystem dfs=dfsCluster.getFileSystem(0);
    RollingUpgradeInfo info=dfs.rollingUpgrade(RollingUpgradeAction.PREPARE);
    Assert.assertTrue(info.isStarted());
    queryForPreparation(dfs);
    dfs.mkdirs(foo);
    long txid=dfs.rollEdits();
    Assert.assertTrue(txid > 0);
    int retries=0;
    while (++retries < 5) {
      NNStorage storage=dfsCluster.getNamesystem(1).getFSImage().getStorage();
      if (storage.getFsImageName(txid - 1) != null) {
        return;
      }
      Thread.sleep(1000);
    }
    Assert.fail("new checkpoint does not exist");
  }
  finally {
    if (cluster != null) {
      cluster.shutdown();
    }
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.TestSafeMode </h4><pre class="type-2 type-7 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Run various fs operations while the NN is in safe mode,
 * assert that they are either allowed or fail as expected.
 */
@Test public void testOperationsWhileInSafeMode() throws IOException, InterruptedException {
  final Path file1=new Path("/file1");
  assertFalse(dfs.setSafeMode(SafeModeAction.SAFEMODE_GET));
  DFSTestUtil.createFile(fs,file1,1024,(short)1,0);
  assertTrue("Could not enter SM",dfs.setSafeMode(SafeModeAction.SAFEMODE_ENTER));
  runFsFun("Set quota while in SM",new FSRun(){
    @Override public void run(    FileSystem fs) throws IOException {
      ((DistributedFileSystem)fs).setQuota(file1,1,1);
    }
  }
);
  runFsFun("Set perm while in SM",new FSRun(){
    @Override public void run(    FileSystem fs) throws IOException {
      fs.setPermission(file1,FsPermission.getDefault());
    }
  }
);
  runFsFun("Set owner while in SM",new FSRun(){
    @Override public void run(    FileSystem fs) throws IOException {
      fs.setOwner(file1,"user","group");
    }
  }
);
  runFsFun("Set repl while in SM",new FSRun(){
    @Override public void run(    FileSystem fs) throws IOException {
      fs.setReplication(file1,(short)1);
    }
  }
);
  runFsFun("Append file while in SM",new FSRun(){
    @Override public void run(    FileSystem fs) throws IOException {
      DFSTestUtil.appendFile(fs,file1,"new bytes");
    }
  }
);
  runFsFun("Delete file while in SM",new FSRun(){
    @Override public void run(    FileSystem fs) throws IOException {
      fs.delete(file1,false);
    }
  }
);
  runFsFun("Rename file while in SM",new FSRun(){
    @Override public void run(    FileSystem fs) throws IOException {
      fs.rename(file1,new Path("file2"));
    }
  }
);
  runFsFun("Set time while in SM",new FSRun(){
    @Override public void run(    FileSystem fs) throws IOException {
      fs.setTimes(file1,0,0);
    }
  }
);
  runFsFun("modifyAclEntries while in SM",new FSRun(){
    @Override public void run(    FileSystem fs) throws IOException {
      fs.modifyAclEntries(file1,Lists.<AclEntry>newArrayList());
    }
  }
);
  runFsFun("removeAclEntries while in SM",new FSRun(){
    @Override public void run(    FileSystem fs) throws IOException {
      fs.removeAclEntries(file1,Lists.<AclEntry>newArrayList());
    }
  }
);
  runFsFun("removeDefaultAcl while in SM",new FSRun(){
    @Override public void run(    FileSystem fs) throws IOException {
      fs.removeDefaultAcl(file1);
    }
  }
);
  runFsFun("removeAcl while in SM",new FSRun(){
    @Override public void run(    FileSystem fs) throws IOException {
      fs.removeAcl(file1);
    }
  }
);
  runFsFun("setAcl while in SM",new FSRun(){
    @Override public void run(    FileSystem fs) throws IOException {
      fs.setAcl(file1,Lists.<AclEntry>newArrayList());
    }
  }
);
  runFsFun("setXAttr while in SM",new FSRun(){
    @Override public void run(    FileSystem fs) throws IOException {
      fs.setXAttr(file1,"user.a1",null);
    }
  }
);
  runFsFun("removeXAttr while in SM",new FSRun(){
    @Override public void run(    FileSystem fs) throws IOException {
      fs.removeXAttr(file1,"user.a1");
    }
  }
);
  try {
    DFSTestUtil.readFile(fs,file1);
  }
 catch (  IOException ioe) {
    fail("Set times failed while in SM");
  }
  try {
    fs.getAclStatus(file1);
  }
 catch (  IOException ioe) {
    fail("getAclStatus failed while in SM");
  }
  UserGroupInformation ugiX=UserGroupInformation.createRemoteUser("userX");
  FileSystem myfs=ugiX.doAs(new PrivilegedExceptionAction<FileSystem>(){
    @Override public FileSystem run() throws IOException {
      return FileSystem.get(conf);
    }
  }
);
  myfs.access(file1,FsAction.READ);
  try {
    myfs.access(file1,FsAction.WRITE);
    fail("The access call should have failed.");
  }
 catch (  AccessControlException e) {
  }
  assertFalse("Could not leave SM",dfs.setSafeMode(SafeModeAction.SAFEMODE_LEAVE));
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.TestSetTimes </h4><pre class="type-2 type-7 type-10 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Tests mod & access time in DFS.
 */
@Test public void testTimes() throws IOException {
  Configuration conf=new HdfsConfiguration();
  final int MAX_IDLE_TIME=2000;
  conf.setInt("ipc.client.connection.maxidletime",MAX_IDLE_TIME);
  conf.setInt(DFSConfigKeys.DFS_NAMENODE_HEARTBEAT_RECHECK_INTERVAL_KEY,1000);
  conf.setInt(DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_KEY,1);
  MiniDFSCluster cluster=new MiniDFSCluster.Builder(conf).numDataNodes(numDatanodes).build();
  cluster.waitActive();
  final int nnport=cluster.getNameNodePort();
  InetSocketAddress addr=new InetSocketAddress("localhost",cluster.getNameNodePort());
  DFSClient client=new DFSClient(addr,conf);
  DatanodeInfo[] info=client.datanodeReport(DatanodeReportType.LIVE);
  assertEquals("Number of Datanodes ",numDatanodes,info.length);
  FileSystem fileSys=cluster.getFileSystem();
  int replicas=1;
  assertTrue(fileSys instanceof DistributedFileSystem);
  try {
    System.out.println("Creating testdir1 and testdir1/test1.dat.");
    Path dir1=new Path("testdir1");
    Path file1=new Path(dir1,"test1.dat");
    FSDataOutputStream stm=writeFile(fileSys,file1,replicas);
    FileStatus stat=fileSys.getFileStatus(file1);
    long atimeBeforeClose=stat.getAccessTime();
    String adate=dateForm.format(new Date(atimeBeforeClose));
    System.out.println("atime on " + file1 + " before close is "+ adate+ " ("+ atimeBeforeClose+ ")");
    assertTrue(atimeBeforeClose != 0);
    stm.close();
    stat=fileSys.getFileStatus(file1);
    long atime1=stat.getAccessTime();
    long mtime1=stat.getModificationTime();
    adate=dateForm.format(new Date(atime1));
    String mdate=dateForm.format(new Date(mtime1));
    System.out.println("atime on " + file1 + " is "+ adate+ " ("+ atime1+ ")");
    System.out.println("mtime on " + file1 + " is "+ mdate+ " ("+ mtime1+ ")");
    assertTrue(atime1 != 0);
    stat=fileSys.getFileStatus(dir1);
    long mdir1=stat.getAccessTime();
    assertTrue(mdir1 == 0);
    long atime2=atime1 - (24L * 3600L * 1000L);
    fileSys.setTimes(file1,-1,atime2);
    stat=fileSys.getFileStatus(file1);
    long atime3=stat.getAccessTime();
    String adate3=dateForm.format(new Date(atime3));
    System.out.println("new atime on " + file1 + " is "+ adate3+ " ("+ atime3+ ")");
    assertTrue(atime2 == atime3);
    assertTrue(mtime1 == stat.getModificationTime());
    long mtime2=mtime1 - (3600L * 1000L);
    fileSys.setTimes(file1,mtime2,-1);
    stat=fileSys.getFileStatus(file1);
    long mtime3=stat.getModificationTime();
    String mdate3=dateForm.format(new Date(mtime3));
    System.out.println("new mtime on " + file1 + " is "+ mdate3+ " ("+ mtime3+ ")");
    assertTrue(atime2 == stat.getAccessTime());
    assertTrue(mtime2 == mtime3);
    long mtime4=Time.now() - (3600L * 1000L);
    long atime4=Time.now();
    fileSys.setTimes(dir1,mtime4,atime4);
    stat=fileSys.getFileStatus(dir1);
    assertTrue("Not matching the modification times",mtime4 == stat.getModificationTime());
    assertTrue("Not matching the access times",atime4 == stat.getAccessTime());
    Path nonExistingDir=new Path(dir1,"/nonExistingDir/");
    try {
      fileSys.setTimes(nonExistingDir,mtime4,atime4);
      fail("Expecting FileNotFoundException");
    }
 catch (    FileNotFoundException e) {
      assertTrue(e.getMessage().contains("File/Directory " + nonExistingDir.toString() + " does not exist."));
    }
    cluster.shutdown();
    try {
      Thread.sleep(2 * MAX_IDLE_TIME);
    }
 catch (    InterruptedException e) {
    }
    cluster=new MiniDFSCluster.Builder(conf).nameNodePort(nnport).format(false).build();
    cluster.waitActive();
    fileSys=cluster.getFileSystem();
    System.out.println("Verifying times after cluster restart");
    stat=fileSys.getFileStatus(file1);
    assertTrue(atime2 == stat.getAccessTime());
    assertTrue(mtime3 == stat.getModificationTime());
    cleanupFile(fileSys,file1);
    cleanupFile(fileSys,dir1);
  }
 catch (  IOException e) {
    info=client.datanodeReport(DatanodeReportType.ALL);
    printDatanodeReport(info);
    throw e;
  }
 finally {
    fileSys.close();
    cluster.shutdown();
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.qjournal.TestNNWithQJM </h4><pre class="type-2 type-7 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=30000) public void testNewNamenodeTakesOverWriter() throws Exception {
  File nn1Dir=new File(MiniDFSCluster.getBaseDirectory() + "/TestNNWithQJM/image-nn1");
  File nn2Dir=new File(MiniDFSCluster.getBaseDirectory() + "/TestNNWithQJM/image-nn2");
  conf.set(DFSConfigKeys.DFS_NAMENODE_NAME_DIR_KEY,nn1Dir.getAbsolutePath());
  conf.set(DFSConfigKeys.DFS_NAMENODE_EDITS_DIR_KEY,mjc.getQuorumJournalURI("myjournal").toString());
  MiniDFSCluster cluster=new MiniDFSCluster.Builder(conf).numDataNodes(0).manageNameDfsDirs(false).checkExitOnShutdown(false).build();
  cluster.shutdown();
  try {
    FileUtil.fullyDelete(nn2Dir);
    FileUtil.copy(nn1Dir,FileSystem.getLocal(conf).getRaw(),new Path(nn2Dir.getAbsolutePath()),false,conf);
    cluster=new MiniDFSCluster.Builder(conf).numDataNodes(0).format(false).manageNameDfsDirs(false).checkExitOnShutdown(false).build();
    cluster.getFileSystem().mkdirs(TEST_PATH);
    Configuration conf2=new Configuration();
    conf2.set(DFSConfigKeys.DFS_NAMENODE_NAME_DIR_KEY,nn2Dir.getAbsolutePath());
    conf2.set(DFSConfigKeys.DFS_NAMENODE_EDITS_DIR_KEY,mjc.getQuorumJournalURI("myjournal").toString());
    MiniDFSCluster cluster2=new MiniDFSCluster.Builder(conf2).numDataNodes(0).format(false).manageNameDfsDirs(false).build();
    try {
      assertTrue(cluster2.getFileSystem().exists(TEST_PATH));
    }
  finally {
      cluster2.shutdown();
    }
    try {
      cluster.getFileSystem().mkdirs(new Path("/x"));
      fail("Did not abort trying to write to a fenced NN");
    }
 catch (    RemoteException re) {
      GenericTestUtils.assertExceptionContains("Could not sync enough journals to persistent storage",re);
    }
  }
  finally {
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test(timeout=30000) public void testMismatchedNNIsRejected() throws Exception {
  conf.set(DFSConfigKeys.DFS_NAMENODE_NAME_DIR_KEY,MiniDFSCluster.getBaseDirectory() + "/TestNNWithQJM/image");
  String defaultEditsDir=conf.get(DFSConfigKeys.DFS_NAMENODE_EDITS_DIR_KEY);
  conf.set(DFSConfigKeys.DFS_NAMENODE_EDITS_DIR_KEY,mjc.getQuorumJournalURI("myjournal").toString());
  MiniDFSCluster cluster=new MiniDFSCluster.Builder(conf).numDataNodes(0).manageNameDfsDirs(false).build();
  cluster.shutdown();
  Configuration onDiskOnly=new Configuration(conf);
  onDiskOnly.set(DFSConfigKeys.DFS_NAMENODE_EDITS_DIR_KEY,defaultEditsDir);
  NameNode.format(onDiskOnly);
  try {
    cluster=new MiniDFSCluster.Builder(conf).numDataNodes(0).manageNameDfsDirs(false).format(false).build();
    fail("New NN with different namespace should have been rejected");
  }
 catch (  IOException ioe) {
    GenericTestUtils.assertExceptionContains("Unable to start log segment 1: too few journals",ioe);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.qjournal.client.TestIPCLoggerChannel </h4><pre class="type-2 type-7 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test that, if the remote node gets unsynchronized (eg some edits were
 * missed or the node rebooted), the client stops sending edits until
 * the next roll. Test for HDFS-3726.
 */
@Test public void testStopSendingEditsWhenOutOfSync() throws Exception {
  Mockito.doThrow(new IOException("injected error")).when(mockProxy).journal(Mockito.<RequestInfo>any(),Mockito.eq(1L),Mockito.eq(1L),Mockito.eq(1),Mockito.same(FAKE_DATA));
  try {
    ch.sendEdits(1L,1L,1,FAKE_DATA).get();
    fail("Injected JOOSE did not cause sendEdits() to throw");
  }
 catch (  ExecutionException ee) {
    GenericTestUtils.assertExceptionContains("injected",ee);
  }
  Mockito.verify(mockProxy).journal(Mockito.<RequestInfo>any(),Mockito.eq(1L),Mockito.eq(1L),Mockito.eq(1),Mockito.same(FAKE_DATA));
  assertTrue(ch.isOutOfSync());
  try {
    ch.sendEdits(1L,2L,1,FAKE_DATA).get();
    fail("sendEdits() should throw until next roll");
  }
 catch (  ExecutionException ee) {
    GenericTestUtils.assertExceptionContains("disabled until next roll",ee.getCause());
  }
  Mockito.verify(mockProxy,Mockito.never()).journal(Mockito.<RequestInfo>any(),Mockito.eq(1L),Mockito.eq(2L),Mockito.eq(1),Mockito.same(FAKE_DATA));
  Mockito.verify(mockProxy).heartbeat(Mockito.<RequestInfo>any());
  ch.startLogSegment(3L,NameNodeLayoutVersion.CURRENT_LAYOUT_VERSION).get();
  assertFalse(ch.isOutOfSync());
  ch.sendEdits(3L,3L,1,FAKE_DATA).get();
}

</code></pre>

<br>
<pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test that, once the queue eclipses the configure size limit,
 * calls to journal more data are rejected.
 */
@Test public void testQueueLimiting() throws Exception {
  DelayAnswer delayer=new DelayAnswer(LOG);
  Mockito.doAnswer(delayer).when(mockProxy).journal(Mockito.<RequestInfo>any(),Mockito.eq(1L),Mockito.eq(1L),Mockito.eq(1),Mockito.same(FAKE_DATA));
  int numToQueue=LIMIT_QUEUE_SIZE_BYTES / FAKE_DATA.length;
  for (int i=1; i <= numToQueue; i++) {
    ch.sendEdits(1L,(long)i,1,FAKE_DATA);
  }
  assertEquals(LIMIT_QUEUE_SIZE_BYTES,ch.getQueuedEditsSize());
  try {
    ch.sendEdits(1L,numToQueue + 1,1,FAKE_DATA).get(1,TimeUnit.SECONDS);
    fail("Did not fail to queue more calls after queue was full");
  }
 catch (  ExecutionException ee) {
    if (!(ee.getCause() instanceof LoggerTooFarBehindException)) {
      throw ee;
    }
  }
  delayer.proceed();
  GenericTestUtils.waitFor(new Supplier<Boolean>(){
    @Override public Boolean get(){
      return ch.getQueuedEditsSize() == 0;
    }
  }
,10,1000);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.qjournal.client.TestQuorumCall </h4><pre class="type-9 type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=10000) public void testQuorums() throws Exception {
  Map<String,SettableFuture<String>> futures=ImmutableMap.of("f1",SettableFuture.<String>create(),"f2",SettableFuture.<String>create(),"f3",SettableFuture.<String>create());
  QuorumCall<String,String> q=QuorumCall.create(futures);
  assertEquals(0,q.countResponses());
  futures.get("f1").set("first future");
  q.waitFor(1,0,0,100000,"test");
  q.waitFor(0,1,0,100000,"test");
  assertEquals(1,q.countResponses());
  futures.get("f2").setException(new Exception("error"));
  assertEquals(2,q.countResponses());
  futures.get("f3").set("second future");
  q.waitFor(3,0,100,100000,"test");
  q.waitFor(0,2,100,100000,"test");
  assertEquals(3,q.countResponses());
  assertEquals("f1=first future,f3=second future",Joiner.on(",").withKeyValueSeparator("=").join(new TreeMap<String,String>(q.getResults())));
  try {
    q.waitFor(0,4,100,10,"test");
    fail("Didn't time out waiting for more responses than came back");
  }
 catch (  TimeoutException te) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.qjournal.client.TestQuorumJournalManager </h4><pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * edit lengths [3,4,5]
 * first recovery:
 * - sees [3,4,x]
 * - picks length 4 for recoveryEndTxId
 * - calls acceptRecovery()
 * - crashes before finalizing
 * second recovery:
 * - sees [x, 4, 5]
 * - should pick recovery length 4, even though it saw
 * a larger txid, because a previous recovery accepted it
 */
@Test public void testRecoverAfterIncompleteRecovery() throws Exception {
  setupLoggers345();
  cluster.getJournalNode(2).stopAndJoin(0);
  qjm=createSpyingQJM();
  spies=qjm.getLoggerSetForTests().getLoggersForTests();
  for (  AsyncLogger spy : spies) {
    TestQuorumJournalManagerUnit.futureThrows(new IOException("injected")).when(spy).finalizeLogSegment(Mockito.eq(1L),Mockito.eq(4L));
  }
  try {
    qjm.recoverUnfinalizedSegments();
    fail("Should have failed recovery since no finalization occurred");
  }
 catch (  IOException ioe) {
    GenericTestUtils.assertExceptionContains("injected",ioe);
  }
  cluster.getJournalNode(0).stopAndJoin(0);
  cluster.restartJournalNode(2);
  qjm=createSpyingQJM();
  spies=qjm.getLoggerSetForTests().getLoggersForTests();
  qjm.recoverUnfinalizedSegments();
  checkRecovery(cluster,1,4);
}

</code></pre>

<br>
<pre class="type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Regression test for HDFS-3891: selectInputStreams should throw
 * an exception when a majority of journalnodes have crashed.
 */
@Test public void testSelectInputStreamsMajorityDown() throws Exception {
  cluster.shutdown();
  List<EditLogInputStream> streams=Lists.newArrayList();
  try {
    qjm.selectInputStreams(streams,0,false);
    fail("Did not throw IOE");
  }
 catch (  QuorumException ioe) {
    GenericTestUtils.assertExceptionContains("Got too many exceptions",ioe);
    assertTrue(streams.isEmpty());
  }
}

</code></pre>

<br>
<pre class="type-9 type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test the case where one of the loggers misses a finalizeLogSegment()
 * call, and then misses the next startLogSegment() call before coming
 * back to life.
 * Previously, this caused it to keep on writing to the old log segment,
 * such that one logger had eg edits_1-10 while the others had edits_1-5 and
 * edits_6-10. This caused recovery to fail in certain cases.
 */
@Test public void testMissFinalizeAndNextStart() throws Exception {
  futureThrows(new IOException("injected")).when(spies.get(0)).finalizeLogSegment(Mockito.eq(1L),Mockito.eq(3L));
  futureThrows(new IOException("injected")).when(spies.get(0)).startLogSegment(Mockito.eq(4L),Mockito.eq(NameNodeLayoutVersion.CURRENT_LAYOUT_VERSION));
  failLoggerAtTxn(spies.get(1),4L);
  writeSegment(cluster,qjm,1,3,true);
  EditLogOutputStream stm=qjm.startLogSegment(4,NameNodeLayoutVersion.CURRENT_LAYOUT_VERSION);
  try {
    writeTxns(stm,4,1);
    fail("Did not fail to write");
  }
 catch (  QuorumException qe) {
    GenericTestUtils.assertExceptionContains("Writer out of sync",qe);
  }
 finally {
    stm.abort();
    qjm.close();
  }
  cluster.getJournalNode(2).stopAndJoin(0);
  qjm=createSpyingQJM();
  long recovered=QJMTestUtil.recoverAndReturnLastTxn(qjm);
  assertEquals(3L,recovered);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.qjournal.client.TestQuorumJournalManagerUnit </h4><pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testQuorumOfLoggersFail() throws Exception {
  futureReturns(null).when(spyLoggers.get(0)).startLogSegment(Mockito.anyLong(),Mockito.eq(NameNodeLayoutVersion.CURRENT_LAYOUT_VERSION));
  futureThrows(new IOException("logger failed")).when(spyLoggers.get(1)).startLogSegment(Mockito.anyLong(),Mockito.eq(NameNodeLayoutVersion.CURRENT_LAYOUT_VERSION));
  futureThrows(new IOException("logger failed")).when(spyLoggers.get(2)).startLogSegment(Mockito.anyLong(),Mockito.eq(NameNodeLayoutVersion.CURRENT_LAYOUT_VERSION));
  try {
    qjm.startLogSegment(1,NameNodeLayoutVersion.CURRENT_LAYOUT_VERSION);
    fail("Did not throw when quorum failed");
  }
 catch (  QuorumException qe) {
    GenericTestUtils.assertExceptionContains("logger failed",qe);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.qjournal.server.TestJournal </h4><pre class="type-2 type-7 type-10 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=10000) public void testEpochHandling() throws Exception {
  assertEquals(0,journal.getLastPromisedEpoch());
  NewEpochResponseProto newEpoch=journal.newEpoch(FAKE_NSINFO,1);
  assertFalse(newEpoch.hasLastSegmentTxId());
  assertEquals(1,journal.getLastPromisedEpoch());
  journal.newEpoch(FAKE_NSINFO,3);
  assertFalse(newEpoch.hasLastSegmentTxId());
  assertEquals(3,journal.getLastPromisedEpoch());
  try {
    journal.newEpoch(FAKE_NSINFO,3);
    fail("Should have failed to promise same epoch twice");
  }
 catch (  IOException ioe) {
    GenericTestUtils.assertExceptionContains("Proposed epoch 3 <= last promise 3",ioe);
  }
  try {
    journal.startLogSegment(makeRI(1),12345L,NameNodeLayoutVersion.CURRENT_LAYOUT_VERSION);
    fail("Should have rejected call from prior epoch");
  }
 catch (  IOException ioe) {
    GenericTestUtils.assertExceptionContains("epoch 1 is less than the last promised epoch 3",ioe);
  }
  try {
    journal.journal(makeRI(1),12345L,100L,0,new byte[0]);
    fail("Should have rejected call from prior epoch");
  }
 catch (  IOException ioe) {
    GenericTestUtils.assertExceptionContains("epoch 1 is less than the last promised epoch 3",ioe);
  }
}

</code></pre>

<br>
<pre class="type-2 type-15 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Sets implicit assumptions ">AssumptionSetter</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Sets implicit assumptions 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=10000) public void testJournalLocking() throws Exception {
  Assume.assumeTrue(journal.getStorage().getStorageDir(0).isLockSupported());
  StorageDirectory sd=journal.getStorage().getStorageDir(0);
  File lockFile=new File(sd.getRoot(),Storage.STORAGE_FILE_LOCK);
  GenericTestUtils.assertExists(lockFile);
  journal.newEpoch(FAKE_NSINFO,1);
  try {
    new Journal(conf,TEST_LOG_DIR,JID,StartupOption.REGULAR,mockErrorReporter);
    fail("Did not fail to create another journal in same dir");
  }
 catch (  IOException ioe) {
    GenericTestUtils.assertExceptionContains("Cannot lock storage",ioe);
  }
  journal.close();
  Journal journal2=new Journal(conf,TEST_LOG_DIR,JID,StartupOption.REGULAR,mockErrorReporter);
  journal2.newEpoch(FAKE_NSINFO,2);
  journal2.close();
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test(timeout=10000) public void testNamespaceVerification() throws Exception {
  journal.newEpoch(FAKE_NSINFO,1);
  try {
    journal.newEpoch(FAKE_NSINFO_2,2);
    fail("Did not fail newEpoch() when namespaces mismatched");
  }
 catch (  IOException ioe) {
    GenericTestUtils.assertExceptionContains("Incompatible namespaceID",ioe);
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * Ensure that finalizing a segment which doesn't exist throws the
 * appropriate exception.
 */
@Test(timeout=10000) public void testFinalizeMissingSegment() throws Exception {
  journal.newEpoch(FAKE_NSINFO,1);
  try {
    journal.finalizeLogSegment(makeRI(1),1000,1001);
    fail("did not fail to finalize");
  }
 catch (  JournalOutOfSyncException e) {
    GenericTestUtils.assertExceptionContains("No log file to finalize at transaction ID 1000",e);
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * Test finalizing a segment after some batch of edits were missed.
 * This should fail, since we validate the log before finalization.
 */
@Test(timeout=10000) public void testFinalizeWhenEditsAreMissed() throws Exception {
  journal.newEpoch(FAKE_NSINFO,1);
  journal.startLogSegment(makeRI(1),1,NameNodeLayoutVersion.CURRENT_LAYOUT_VERSION);
  journal.journal(makeRI(2),1,1,3,QJMTestUtil.createTxnData(1,3));
  try {
    journal.finalizeLogSegment(makeRI(3),1,6);
    fail("did not fail to finalize");
  }
 catch (  JournalOutOfSyncException e) {
    GenericTestUtils.assertExceptionContains("but only written up to txid 3",e);
  }
  journal.close();
  journal=new Journal(conf,TEST_LOG_DIR,JID,StartupOption.REGULAR,mockErrorReporter);
  try {
    journal.finalizeLogSegment(makeRI(4),1,6);
    fail("did not fail to finalize");
  }
 catch (  JournalOutOfSyncException e) {
    GenericTestUtils.assertExceptionContains("disk only contains up to txid 3",e);
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * Test behavior of startLogSegment() when a segment with the
 * same transaction ID already exists.
 */
@Test(timeout=10000) public void testStartLogSegmentWhenAlreadyExists() throws Exception {
  journal.newEpoch(FAKE_NSINFO,1);
  journal.startLogSegment(makeRI(1),1,NameNodeLayoutVersion.CURRENT_LAYOUT_VERSION);
  journal.journal(makeRI(2),1,1,1,QJMTestUtil.createTxnData(1,1));
  journal.startLogSegment(makeRI(3),1,NameNodeLayoutVersion.CURRENT_LAYOUT_VERSION);
  journal.journal(makeRI(4),1,1,1,QJMTestUtil.createTxnData(1,1));
  journal.journal(makeRI(5),1,2,3,QJMTestUtil.createTxnData(2,3));
  try {
    journal.startLogSegment(makeRI(6),1,NameNodeLayoutVersion.CURRENT_LAYOUT_VERSION);
    fail("Did not fail to start log segment which would overwrite " + "an existing one");
  }
 catch (  IllegalStateException ise) {
    GenericTestUtils.assertExceptionContains("seems to contain valid transactions",ise);
  }
  journal.finalizeLogSegment(makeRI(7),1,4);
  try {
    journal.startLogSegment(makeRI(8),1,NameNodeLayoutVersion.CURRENT_LAYOUT_VERSION);
    fail("Did not fail to start log segment which would overwrite " + "an existing one");
  }
 catch (  IllegalStateException ise) {
    GenericTestUtils.assertExceptionContains("have a finalized segment",ise);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.qjournal.server.TestJournalNode </h4><pre class="type-2 type-7 type-10 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test that the JournalNode performs correctly as a Paxos
 * <em>Acceptor</em> process.
 */
@Test(timeout=100000) public void testAcceptRecoveryBehavior() throws Exception {
  try {
    ch.prepareRecovery(1L).get();
    fail("Did not throw IllegalState when trying to run paxos without an epoch");
  }
 catch (  ExecutionException ise) {
    GenericTestUtils.assertExceptionContains("bad epoch",ise);
  }
  ch.newEpoch(1).get();
  ch.setEpoch(1);
  PrepareRecoveryResponseProto prep=ch.prepareRecovery(1L).get();
  System.err.println("Prep: " + prep);
  assertFalse(prep.hasAcceptedInEpoch());
  assertFalse(prep.hasSegmentState());
  ch.startLogSegment(1L,NameNodeLayoutVersion.CURRENT_LAYOUT_VERSION).get();
  ch.sendEdits(1L,1L,1,QJMTestUtil.createTxnData(1,1)).get();
  prep=ch.prepareRecovery(1L).get();
  System.err.println("Prep: " + prep);
  assertFalse(prep.hasAcceptedInEpoch());
  assertTrue(prep.hasSegmentState());
  ch.acceptRecovery(prep.getSegmentState(),new URL("file:///dev/null")).get();
  ch.newEpoch(2);
  ch.setEpoch(2);
  prep=ch.prepareRecovery(1L).get();
  assertEquals(1L,prep.getAcceptedInEpoch());
  assertEquals(1L,prep.getSegmentState().getEndTxId());
  ch.setEpoch(1);
  try {
    ch.prepareRecovery(1L).get();
    fail("prepare from earlier epoch not rejected");
  }
 catch (  ExecutionException ioe) {
    GenericTestUtils.assertExceptionContains("epoch 1 is less than the last promised epoch 2",ioe);
  }
  try {
    ch.acceptRecovery(prep.getSegmentState(),new URL("file:///dev/null")).get();
    fail("accept from earlier epoch not rejected");
  }
 catch (  ExecutionException ioe) {
    GenericTestUtils.assertExceptionContains("epoch 1 is less than the last promised epoch 2",ioe);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.security.TestDelegationToken </h4><pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testDelegationTokenWithDoAs() throws Exception {
  final DistributedFileSystem dfs=cluster.getFileSystem();
  final Credentials creds=new Credentials();
  final Token<?> tokens[]=dfs.addDelegationTokens("JobTracker",creds);
  Assert.assertEquals(1,tokens.length);
  @SuppressWarnings("unchecked") final Token<DelegationTokenIdentifier> token=(Token<DelegationTokenIdentifier>)tokens[0];
  final UserGroupInformation longUgi=UserGroupInformation.createRemoteUser("JobTracker/foo.com@FOO.COM");
  final UserGroupInformation shortUgi=UserGroupInformation.createRemoteUser("JobTracker");
  longUgi.doAs(new PrivilegedExceptionAction(){
    @Override public Object run() throws IOException {
      try {
        token.renew(config);
      }
 catch (      Exception e) {
        Assert.fail("Could not renew delegation token for user " + longUgi);
      }
      return null;
    }
  }
);
  shortUgi.doAs(new PrivilegedExceptionAction(){
    @Override public Object run() throws Exception {
      token.renew(config);
      return null;
    }
  }
);
  longUgi.doAs(new PrivilegedExceptionAction(){
    @Override public Object run() throws IOException {
      try {
        token.cancel(config);
      }
 catch (      Exception e) {
        Assert.fail("Could not cancel delegation token for user " + longUgi);
      }
      return null;
    }
  }
);
}

</code></pre>

<br>
<pre class="type-2 type-7 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testDelegationTokenSecretManager() throws Exception {
  Token<DelegationTokenIdentifier> token=generateDelegationToken("SomeUser","JobTracker");
  try {
    dtSecretManager.renewToken(token,"FakeRenewer");
    Assert.fail("should have failed");
  }
 catch (  AccessControlException ace) {
  }
  dtSecretManager.renewToken(token,"JobTracker");
  DelegationTokenIdentifier identifier=new DelegationTokenIdentifier();
  byte[] tokenId=token.getIdentifier();
  identifier.readFields(new DataInputStream(new ByteArrayInputStream(tokenId)));
  Assert.assertTrue(null != dtSecretManager.retrievePassword(identifier));
  LOG.info("Sleep to expire the token");
  Thread.sleep(6000);
  try {
    dtSecretManager.retrievePassword(identifier);
    Assert.fail("Token should have expired");
  }
 catch (  InvalidToken e) {
  }
  dtSecretManager.renewToken(token,"JobTracker");
  LOG.info("Sleep beyond the max lifetime");
  Thread.sleep(5000);
  try {
    dtSecretManager.renewToken(token,"JobTracker");
    Assert.fail("should have been expired");
  }
 catch (  InvalidToken it) {
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testCancelDelegationToken() throws Exception {
  Token<DelegationTokenIdentifier> token=generateDelegationToken("SomeUser","JobTracker");
  try {
    dtSecretManager.cancelToken(token,"FakeCanceller");
    Assert.fail("should have failed");
  }
 catch (  AccessControlException ace) {
  }
  dtSecretManager.cancelToken(token,"JobTracker");
  try {
    dtSecretManager.renewToken(token,"JobTracker");
    Assert.fail("should have failed");
  }
 catch (  InvalidToken it) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.security.token.block.TestBlockToken </h4><pre class="type-9 type-13 type-11 type-2 type-7 type-15 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Sets implicit assumptions ">AssumptionSetter</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions in iterations
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Sets implicit assumptions 
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test that fast repeated invocations of createClientDatanodeProtocolProxy
 * will not end up using up thousands of sockets. This is a regression test
 * for HDFS-1965.
 */
@Test public void testBlockTokenRpcLeak() throws Exception {
  Configuration conf=new Configuration();
  conf.set(HADOOP_SECURITY_AUTHENTICATION,"kerberos");
  UserGroupInformation.setConfiguration(conf);
  Assume.assumeTrue(FD_DIR.exists());
  BlockTokenSecretManager sm=new BlockTokenSecretManager(blockKeyUpdateInterval,blockTokenLifetime,0,"fake-pool",null);
  Token<BlockTokenIdentifier> token=sm.generateToken(block3,EnumSet.allOf(BlockTokenSecretManager.AccessMode.class));
  final Server server=createMockDatanode(sm,token,conf);
  server.start();
  final InetSocketAddress addr=NetUtils.getConnectAddress(server);
  DatanodeID fakeDnId=DFSTestUtil.getLocalDatanodeID(addr.getPort());
  ExtendedBlock b=new ExtendedBlock("fake-pool",new Block(12345L));
  LocatedBlock fakeBlock=new LocatedBlock(b,new DatanodeInfo[0]);
  fakeBlock.setBlockToken(token);
  ClientDatanodeProtocol proxyToNoWhere=RPC.getProxy(ClientDatanodeProtocol.class,ClientDatanodeProtocol.versionID,new InetSocketAddress("1.1.1.1",1),UserGroupInformation.createRemoteUser("junk"),conf,NetUtils.getDefaultSocketFactory(conf));
  ClientDatanodeProtocol proxy=null;
  int fdsAtStart=countOpenFileDescriptors();
  try {
    long endTime=Time.now() + 3000;
    while (Time.now() < endTime) {
      proxy=DFSUtil.createClientDatanodeProtocolProxy(fakeDnId,conf,1000,false,fakeBlock);
      assertEquals(block3.getBlockId(),proxy.getReplicaVisibleLength(block3));
      if (proxy != null) {
        RPC.stopProxy(proxy);
      }
      LOG.info("Num open fds:" + countOpenFileDescriptors());
    }
    int fdsAtEnd=countOpenFileDescriptors();
    if (fdsAtEnd - fdsAtStart > 50) {
      fail("Leaked " + (fdsAtEnd - fdsAtStart) + " fds!");
    }
  }
  finally {
    server.stop();
  }
  RPC.stopProxy(proxyToNoWhere);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.server.balancer.TestBalancer </h4><pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * Test parse method in Balancer#Cli class with wrong number of params
 */
@Test(timeout=100000) public void testBalancerCliParseWithWrongParams(){
  String parameters[]=new String[]{"-threshold"};
  String reason="IllegalArgumentException is expected when value is not specified";
  try {
    Balancer.Cli.parse(parameters);
    fail(reason);
  }
 catch (  IllegalArgumentException e) {
  }
  parameters=new String[]{"-policy"};
  try {
    Balancer.Cli.parse(parameters);
    fail(reason);
  }
 catch (  IllegalArgumentException e) {
  }
  parameters=new String[]{"-threshold","1","-policy"};
  try {
    Balancer.Cli.parse(parameters);
    fail(reason);
  }
 catch (  IllegalArgumentException e) {
  }
  parameters=new String[]{"-threshold","1","-include"};
  try {
    Balancer.Cli.parse(parameters);
    fail(reason);
  }
 catch (  IllegalArgumentException e) {
  }
  parameters=new String[]{"-threshold","1","-exclude"};
  try {
    Balancer.Cli.parse(parameters);
    fail(reason);
  }
 catch (  IllegalArgumentException e) {
  }
  parameters=new String[]{"-include","-f"};
  try {
    Balancer.Cli.parse(parameters);
    fail(reason);
  }
 catch (  IllegalArgumentException e) {
  }
  parameters=new String[]{"-exclude","-f"};
  try {
    Balancer.Cli.parse(parameters);
    fail(reason);
  }
 catch (  IllegalArgumentException e) {
  }
  parameters=new String[]{"-include","testnode1","-exclude","testnode2"};
  try {
    Balancer.Cli.parse(parameters);
    fail("IllegalArgumentException is expected when both -exclude and -include are specified");
  }
 catch (  IllegalArgumentException e) {
  }
}

</code></pre>

<br>
<pre class="type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test parse method in Balancer#Cli class with threshold value out of
 * boundaries.
 */
@Test(timeout=100000) public void testBalancerCliParseWithThresholdOutOfBoundaries(){
  String parameters[]=new String[]{"-threshold","0"};
  String reason="IllegalArgumentException is expected when threshold value" + " is out of boundary.";
  try {
    Balancer.Cli.parse(parameters);
    fail(reason);
  }
 catch (  IllegalArgumentException e) {
    assertEquals("Number out of range: threshold = 0.0",e.getMessage());
  }
  parameters=new String[]{"-threshold","101"};
  try {
    Balancer.Cli.parse(parameters);
    fail(reason);
  }
 catch (  IllegalArgumentException e) {
    assertEquals("Number out of range: threshold = 101.0",e.getMessage());
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.server.blockmanagement.TestDatanodeManager </h4><pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test(timeout=100000) public void testRejectUnresolvedDatanodes() throws IOException {
  FSNamesystem fsn=Mockito.mock(FSNamesystem.class);
  Mockito.when(fsn.hasWriteLock()).thenReturn(true);
  Configuration conf=new Configuration();
  conf.setBoolean(DFSConfigKeys.DFS_REJECT_UNRESOLVED_DN_TOPOLOGY_MAPPING_KEY,true);
  conf.setClass(CommonConfigurationKeysPublic.NET_TOPOLOGY_NODE_SWITCH_MAPPING_IMPL_KEY,TestDatanodeManager.MyResolver.class,DNSToSwitchMapping.class);
  DatanodeManager dm=new DatanodeManager(Mockito.mock(BlockManager.class),fsn,conf);
  String storageID="someStorageID-123";
  DatanodeRegistration dr=Mockito.mock(DatanodeRegistration.class);
  Mockito.when(dr.getDatanodeUuid()).thenReturn(storageID);
  try {
    dm.registerDatanode(dr);
    Assert.fail("Expected an UnresolvedTopologyException");
  }
 catch (  UnresolvedTopologyException ute) {
    LOG.info("Expected - topology is not resolved and " + "registration is rejected.");
  }
catch (  Exception e) {
    Assert.fail("Expected an UnresolvedTopologyException");
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.server.common.TestJspHelper </h4><pre class="type-9 type-2 type-7 type-1 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testGetUgiFromToken() throws IOException {
  conf.set(DFSConfigKeys.FS_DEFAULT_NAME_KEY,"hdfs://localhost:4321/");
  ServletContext context=mock(ServletContext.class);
  String realUser="TheDoctor";
  String user="TheNurse";
  conf.set(DFSConfigKeys.HADOOP_SECURITY_AUTHENTICATION,"kerberos");
  UserGroupInformation.setConfiguration(conf);
  UserGroupInformation ugi;
  HttpServletRequest request;
  Text ownerText=new Text(user);
  DelegationTokenIdentifier dtId=new DelegationTokenIdentifier(ownerText,ownerText,new Text(realUser));
  Token<DelegationTokenIdentifier> token=new Token<DelegationTokenIdentifier>(dtId,new DummySecretManager(0,0,0,0));
  String tokenString=token.encodeToUrlString();
  request=getMockRequest(null,null,null);
  when(request.getParameter(JspHelper.DELEGATION_PARAMETER_NAME)).thenReturn(tokenString);
  ugi=JspHelper.getUGI(context,request,conf);
  Assert.assertNotNull(ugi.getRealUser());
  Assert.assertEquals(ugi.getRealUser().getShortUserName(),realUser);
  Assert.assertEquals(ugi.getShortUserName(),user);
  checkUgiFromToken(ugi);
  request=getMockRequest(realUser,null,null);
  when(request.getParameter(JspHelper.DELEGATION_PARAMETER_NAME)).thenReturn(tokenString);
  ugi=JspHelper.getUGI(context,request,conf);
  Assert.assertNotNull(ugi.getRealUser());
  Assert.assertEquals(ugi.getRealUser().getShortUserName(),realUser);
  Assert.assertEquals(ugi.getShortUserName(),user);
  checkUgiFromToken(ugi);
  request=getMockRequest("rogue",null,null);
  when(request.getParameter(JspHelper.DELEGATION_PARAMETER_NAME)).thenReturn(tokenString);
  ugi=JspHelper.getUGI(context,request,conf);
  Assert.assertNotNull(ugi.getRealUser());
  Assert.assertEquals(ugi.getRealUser().getShortUserName(),realUser);
  Assert.assertEquals(ugi.getShortUserName(),user);
  checkUgiFromToken(ugi);
  request=getMockRequest(null,user,null);
  when(request.getParameter(JspHelper.DELEGATION_PARAMETER_NAME)).thenReturn(tokenString);
  ugi=JspHelper.getUGI(context,request,conf);
  Assert.assertNotNull(ugi.getRealUser());
  Assert.assertEquals(ugi.getRealUser().getShortUserName(),realUser);
  Assert.assertEquals(ugi.getShortUserName(),user);
  checkUgiFromToken(ugi);
  request=getMockRequest(null,null,"rogue");
  when(request.getParameter(JspHelper.DELEGATION_PARAMETER_NAME)).thenReturn(tokenString);
  try {
    JspHelper.getUGI(context,request,conf);
    Assert.fail("bad request allowed");
  }
 catch (  IOException ioe) {
    Assert.assertEquals("Usernames not matched: name=rogue != expected=" + user,ioe.getMessage());
  }
  request=getMockRequest(null,user,"rogue");
  when(request.getParameter(JspHelper.DELEGATION_PARAMETER_NAME)).thenReturn(tokenString);
  try {
    JspHelper.getUGI(context,request,conf);
    Assert.fail("bad request allowed");
  }
 catch (  IOException ioe) {
    Assert.assertEquals("Usernames not matched: name=rogue != expected=" + user,ioe.getMessage());
  }
}

</code></pre>

<br>
<pre class="type-9 type-2 type-7 type-1 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testGetNonProxyUgi() throws IOException {
  conf.set(DFSConfigKeys.FS_DEFAULT_NAME_KEY,"hdfs://localhost:4321/");
  ServletContext context=mock(ServletContext.class);
  String realUser="TheDoctor";
  String user="TheNurse";
  conf.set(DFSConfigKeys.HADOOP_SECURITY_AUTHENTICATION,"kerberos");
  UserGroupInformation.setConfiguration(conf);
  UserGroupInformation ugi;
  HttpServletRequest request;
  request=getMockRequest(null,null,null);
  try {
    JspHelper.getUGI(context,request,conf);
    Assert.fail("bad request allowed");
  }
 catch (  IOException ioe) {
    Assert.assertEquals("Security enabled but user not authenticated by filter",ioe.getMessage());
  }
  request=getMockRequest(null,realUser,null);
  try {
    JspHelper.getUGI(context,request,conf);
    Assert.fail("bad request allowed");
  }
 catch (  IOException ioe) {
    Assert.assertEquals("Security enabled but user not authenticated by filter",ioe.getMessage());
  }
  request=getMockRequest(realUser,null,null);
  ugi=JspHelper.getUGI(context,request,conf);
  Assert.assertNull(ugi.getRealUser());
  Assert.assertEquals(ugi.getShortUserName(),realUser);
  checkUgiFromAuth(ugi);
  request=getMockRequest(realUser,realUser,null);
  ugi=JspHelper.getUGI(context,request,conf);
  Assert.assertNull(ugi.getRealUser());
  Assert.assertEquals(ugi.getShortUserName(),realUser);
  checkUgiFromAuth(ugi);
  request=getMockRequest(realUser,user,null);
  try {
    JspHelper.getUGI(context,request,conf);
    Assert.fail("bad request allowed");
  }
 catch (  IOException ioe) {
    Assert.assertEquals("Usernames not matched: name=" + user + " != expected="+ realUser,ioe.getMessage());
  }
}

</code></pre>

<br>
<pre class="type-9 type-2 type-7 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testReadWriteReplicaState(){
  try {
    DataOutputBuffer out=new DataOutputBuffer();
    DataInputBuffer in=new DataInputBuffer();
    for (    HdfsServerConstants.ReplicaState repState : HdfsServerConstants.ReplicaState.values()) {
      repState.write(out);
      in.reset(out.getData(),out.getLength());
      HdfsServerConstants.ReplicaState result=HdfsServerConstants.ReplicaState.read(in);
      assertTrue("testReadWrite error !!!",repState == result);
      out.reset();
      in.reset();
    }
  }
 catch (  Exception ex) {
    fail("testReadWrite ex error ReplicaState");
  }
}

</code></pre>

<br>
<pre class="type-9 type-2 type-7 type-1 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testGetProxyUgi() throws IOException {
  conf.set(DFSConfigKeys.FS_DEFAULT_NAME_KEY,"hdfs://localhost:4321/");
  ServletContext context=mock(ServletContext.class);
  String realUser="TheDoctor";
  String user="TheNurse";
  conf.set(DFSConfigKeys.HADOOP_SECURITY_AUTHENTICATION,"kerberos");
  conf.set(DefaultImpersonationProvider.getTestProvider().getProxySuperuserGroupConfKey(realUser),"*");
  conf.set(DefaultImpersonationProvider.getTestProvider().getProxySuperuserIpConfKey(realUser),"*");
  ProxyUsers.refreshSuperUserGroupsConfiguration(conf);
  UserGroupInformation.setConfiguration(conf);
  UserGroupInformation ugi;
  HttpServletRequest request;
  request=getMockRequest(null,null,user);
  try {
    JspHelper.getUGI(context,request,conf);
    Assert.fail("bad request allowed");
  }
 catch (  IOException ioe) {
    Assert.assertEquals("Security enabled but user not authenticated by filter",ioe.getMessage());
  }
  request=getMockRequest(null,realUser,user);
  try {
    JspHelper.getUGI(context,request,conf);
    Assert.fail("bad request allowed");
  }
 catch (  IOException ioe) {
    Assert.assertEquals("Security enabled but user not authenticated by filter",ioe.getMessage());
  }
  request=getMockRequest(realUser,null,user);
  ugi=JspHelper.getUGI(context,request,conf);
  Assert.assertNotNull(ugi.getRealUser());
  Assert.assertEquals(ugi.getRealUser().getShortUserName(),realUser);
  Assert.assertEquals(ugi.getShortUserName(),user);
  checkUgiFromAuth(ugi);
  request=getMockRequest(realUser,realUser,user);
  ugi=JspHelper.getUGI(context,request,conf);
  Assert.assertNotNull(ugi.getRealUser());
  Assert.assertEquals(ugi.getRealUser().getShortUserName(),realUser);
  Assert.assertEquals(ugi.getShortUserName(),user);
  checkUgiFromAuth(ugi);
  request=getMockRequest(realUser,user,user);
  try {
    JspHelper.getUGI(context,request,conf);
    Assert.fail("bad request allowed");
  }
 catch (  IOException ioe) {
    Assert.assertEquals("Usernames not matched: name=" + user + " != expected="+ realUser,ioe.getMessage());
  }
  try {
    request=getMockRequest(user,null,realUser);
    JspHelper.getUGI(context,request,conf);
    Assert.fail("bad proxy request allowed");
  }
 catch (  AuthorizationException ae) {
    Assert.assertEquals("User: " + user + " is not allowed to impersonate "+ realUser,ae.getMessage());
  }
  try {
    request=getMockRequest(user,user,realUser);
    JspHelper.getUGI(context,request,conf);
    Assert.fail("bad proxy request allowed");
  }
 catch (  AuthorizationException ae) {
    Assert.assertEquals("User: " + user + " is not allowed to impersonate "+ realUser,ae.getMessage());
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.server.datanode.TestBlockRecovery </h4><pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * BlockRecoveryFI_10. DN has no ReplicaUnderRecovery.
 * @throws IOException in case of an error
 */
@Test public void testNoReplicaUnderRecovery() throws IOException {
  if (LOG.isDebugEnabled()) {
    LOG.debug("Running " + GenericTestUtils.getMethodName());
  }
  dn.data.createRbw(StorageType.DEFAULT,block);
  try {
    dn.syncBlock(rBlock,initBlockRecords(dn));
    fail("Sync should fail");
  }
 catch (  IOException e) {
    e.getMessage().startsWith("Cannot recover ");
  }
  DatanodeProtocol namenode=dn.getActiveNamenodeForBP(POOL_ID);
  verify(namenode,never()).commitBlockSynchronization(any(ExtendedBlock.class),anyLong(),anyLong(),anyBoolean(),anyBoolean(),any(DatanodeID[].class),any(String[].class));
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * BlockRecoveryFI_11. a replica's recovery id does not match new GS.
 * @throws IOException in case of an error
 */
@Test public void testNotMatchedReplicaID() throws IOException {
  if (LOG.isDebugEnabled()) {
    LOG.debug("Running " + GenericTestUtils.getMethodName());
  }
  ReplicaInPipelineInterface replicaInfo=dn.data.createRbw(StorageType.DEFAULT,block);
  ReplicaOutputStreams streams=null;
  try {
    streams=replicaInfo.createStreams(true,DataChecksum.newDataChecksum(DataChecksum.Type.CRC32,512));
    streams.getChecksumOut().write('a');
    dn.data.initReplicaRecovery(new RecoveringBlock(block,null,RECOVERY_ID + 1));
    try {
      dn.syncBlock(rBlock,initBlockRecords(dn));
      fail("Sync should fail");
    }
 catch (    IOException e) {
      e.getMessage().startsWith("Cannot recover ");
    }
    DatanodeProtocol namenode=dn.getActiveNamenodeForBP(POOL_ID);
    verify(namenode,never()).commitBlockSynchronization(any(ExtendedBlock.class),anyLong(),anyLong(),anyBoolean(),anyBoolean(),any(DatanodeID[].class),any(String[].class));
  }
  finally {
    streams.close();
  }
}

</code></pre>

<br>
<pre class="type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * BlockRecovery_02.8.
 * Two replicas are in Finalized state
 * @throws IOException in case of an error
 */
@Test public void testFinalizedReplicas() throws IOException {
  if (LOG.isDebugEnabled()) {
    LOG.debug("Running " + GenericTestUtils.getMethodName());
  }
  ReplicaRecoveryInfo replica1=new ReplicaRecoveryInfo(BLOCK_ID,REPLICA_LEN1,GEN_STAMP - 1,ReplicaState.FINALIZED);
  ReplicaRecoveryInfo replica2=new ReplicaRecoveryInfo(BLOCK_ID,REPLICA_LEN1,GEN_STAMP - 2,ReplicaState.FINALIZED);
  InterDatanodeProtocol dn1=mock(InterDatanodeProtocol.class);
  InterDatanodeProtocol dn2=mock(InterDatanodeProtocol.class);
  testSyncReplicas(replica1,replica2,dn1,dn2,REPLICA_LEN1);
  verify(dn1).updateReplicaUnderRecovery(block,RECOVERY_ID,REPLICA_LEN1);
  verify(dn2).updateReplicaUnderRecovery(block,RECOVERY_ID,REPLICA_LEN1);
  replica1=new ReplicaRecoveryInfo(BLOCK_ID,REPLICA_LEN1,GEN_STAMP - 1,ReplicaState.FINALIZED);
  replica2=new ReplicaRecoveryInfo(BLOCK_ID,REPLICA_LEN2,GEN_STAMP - 2,ReplicaState.FINALIZED);
  try {
    testSyncReplicas(replica1,replica2,dn1,dn2,REPLICA_LEN1);
    Assert.fail("Two finalized replicas should not have different lengthes!");
  }
 catch (  IOException e) {
    Assert.assertTrue(e.getMessage().startsWith("Inconsistent size of finalized replicas. "));
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * BlockRecoveryFI_09. some/all DNs failed to update replicas.
 * @throws IOException in case of an error
 */
@Test public void testFailedReplicaUpdate() throws IOException {
  if (LOG.isDebugEnabled()) {
    LOG.debug("Running " + GenericTestUtils.getMethodName());
  }
  DataNode spyDN=spy(dn);
  doThrow(new IOException()).when(spyDN).updateReplicaUnderRecovery(block,RECOVERY_ID,block.getNumBytes());
  try {
    spyDN.syncBlock(rBlock,initBlockRecords(spyDN));
    fail("Sync should fail");
  }
 catch (  IOException e) {
    e.getMessage().startsWith("Cannot recover ");
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.server.datanode.TestDataDirs </h4><pre class="type-9 type-2 type-7 type-21 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies logic rules using matcher-style statements">ConditionMatcher</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies logic rules using matcher-style statements
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=30000) public void testDataDirParsing() throws Throwable {
  Configuration conf=new Configuration();
  List<StorageLocation> locations;
  File dir0=new File("/dir0");
  File dir1=new File("/dir1");
  File dir2=new File("/dir2");
  File dir3=new File("/dir3");
  String locations1="[disk]/dir0,[DISK]/dir1,[sSd]/dir2,[disK]/dir3";
  conf.set(DFS_DATANODE_DATA_DIR_KEY,locations1);
  locations=DataNode.getStorageLocations(conf);
  assertThat(locations.size(),is(4));
  assertThat(locations.get(0).getStorageType(),is(StorageType.DISK));
  assertThat(locations.get(0).getUri(),is(dir0.toURI()));
  assertThat(locations.get(1).getStorageType(),is(StorageType.DISK));
  assertThat(locations.get(1).getUri(),is(dir1.toURI()));
  assertThat(locations.get(2).getStorageType(),is(StorageType.SSD));
  assertThat(locations.get(2).getUri(),is(dir2.toURI()));
  assertThat(locations.get(3).getStorageType(),is(StorageType.DISK));
  assertThat(locations.get(3).getUri(),is(dir3.toURI()));
  String locations2="[BadMediaType]/dir0,[ssd]/dir1,[disk]/dir2";
  conf.set(DFS_DATANODE_DATA_DIR_KEY,locations2);
  try {
    locations=DataNode.getStorageLocations(conf);
    fail();
  }
 catch (  IllegalArgumentException iae) {
    DataNode.LOG.info("The exception is expected.",iae);
  }
  String locations3="/dir0,/dir1";
  conf.set(DFS_DATANODE_DATA_DIR_KEY,locations3);
  locations=DataNode.getStorageLocations(conf);
  assertThat(locations.size(),is(2));
  assertThat(locations.get(0).getStorageType(),is(StorageType.DISK));
  assertThat(locations.get(0).getUri(),is(dir0.toURI()));
  assertThat(locations.get(1).getStorageType(),is(StorageType.DISK));
  assertThat(locations.get(1).getUri(),is(dir1.toURI()));
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.server.datanode.TestDataNodeMultipleRegistrations </h4><pre class="type-2 type-7 type-10 type-1 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects are null
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testMiniDFSClusterWithMultipleNN() throws IOException {
  Configuration conf=new HdfsConfiguration();
  MiniDFSCluster cluster=new MiniDFSCluster.Builder(conf).nnTopology(MiniDFSNNTopology.simpleFederatedTopology(2)).build();
  try {
    cluster.waitActive();
    Assert.assertEquals("(1)Should be 2 namenodes",2,cluster.getNumNameNodes());
    cluster.addNameNode(conf,0);
    Assert.assertEquals("(1)Should be 3 namenodes",3,cluster.getNumNameNodes());
  }
 catch (  IOException ioe) {
    Assert.fail("Failed to add NN to cluster:" + StringUtils.stringifyException(ioe));
  }
 finally {
    cluster.shutdown();
  }
  conf=new HdfsConfiguration();
  cluster=new MiniDFSCluster.Builder(conf).nnTopology(MiniDFSNNTopology.simpleFederatedTopology(1)).build();
  try {
    Assert.assertNotNull(cluster);
    cluster.waitActive();
    Assert.assertEquals("(2)Should be 1 namenodes",1,cluster.getNumNameNodes());
    cluster.addNameNode(conf,0);
    Assert.assertEquals("(2)Should be 2 namenodes",2,cluster.getNumNameNodes());
  }
 catch (  IOException ioe) {
    Assert.fail("Failed to add NN to cluster:" + StringUtils.stringifyException(ioe));
  }
 finally {
    cluster.shutdown();
  }
  conf=new HdfsConfiguration();
  cluster=new MiniDFSCluster.Builder(conf).build();
  try {
    cluster.waitActive();
    Assert.assertNotNull(cluster);
    Assert.assertEquals("(2)Should be 1 namenodes",1,cluster.getNumNameNodes());
    cluster.addNameNode(conf,9929);
    Assert.fail("shouldn't be able to add another NN to non federated cluster");
  }
 catch (  IOException e) {
    Assert.assertTrue(e.getMessage().startsWith("cannot add namenode"));
    Assert.assertEquals("(3)Should be 1 namenodes",1,cluster.getNumNameNodes());
  }
 finally {
    cluster.shutdown();
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.server.datanode.TestDataStorage </h4><pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testRecoverTransitionReadFailure() throws IOException {
  final int numLocations=3;
  List<StorageLocation> locations=createStorageLocations(numLocations,true);
  try {
    storage.recoverTransitionRead(mockDN,nsInfo,locations,START_OPT);
    fail("An IOException should throw: all StorageLocations are NON_EXISTENT");
  }
 catch (  IOException e) {
    GenericTestUtils.assertExceptionContains("All specified directories are not accessible or do not exist.",e);
  }
  assertEquals(0,storage.getNumStorageDirs());
}

</code></pre>

<br>
<pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * This test enforces the behavior that if there is an exception from
 * doTransition() during DN starts up, the storage directories that have
 * already been processed are still visible, i.e., in
 * DataStorage.storageDirs().
 */
@Test public void testRecoverTransitionReadDoTransitionFailure() throws IOException {
  final int numLocations=3;
  List<StorageLocation> locations=createStorageLocations(numLocations);
  String bpid=nsInfo.getBlockPoolID();
  storage.recoverTransitionRead(mockDN,bpid,nsInfo,locations,START_OPT);
  storage.unlockAll();
  storage=new DataStorage();
  nsInfo.clusterID="cluster1";
  try {
    storage.recoverTransitionRead(mockDN,bpid,nsInfo,locations,START_OPT);
    fail("Expect to throw an exception from doTransition()");
  }
 catch (  IOException e) {
    GenericTestUtils.assertExceptionContains("Incompatible clusterIDs",e);
  }
  assertEquals(numLocations,storage.getNumStorageDirs());
}

</code></pre>

<br>
<pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testAddStorageDirectories() throws IOException, URISyntaxException {
  final int numLocations=3;
  final int numNamespace=3;
  List<StorageLocation> locations=createStorageLocations(numLocations);
  List<NamespaceInfo> namespaceInfos=createNamespaceInfos(numNamespace);
  for (  NamespaceInfo ni : namespaceInfos) {
    storage.addStorageLocations(mockDN,ni,locations,START_OPT);
    for (    StorageLocation sl : locations) {
      checkDir(sl.getFile());
      checkDir(sl.getFile(),ni.getBlockPoolID());
    }
  }
  assertEquals(numLocations,storage.getNumStorageDirs());
  locations=createStorageLocations(numLocations);
  try {
    storage.addStorageLocations(mockDN,namespaceInfos.get(0),locations,START_OPT);
    fail("Expected to throw IOException: adding active directories.");
  }
 catch (  IOException e) {
    GenericTestUtils.assertExceptionContains("All specified directories are not accessible or do not exist.",e);
  }
  assertEquals(numLocations,storage.getNumStorageDirs());
  locations=createStorageLocations(6);
  storage.addStorageLocations(mockDN,nsInfo,locations,START_OPT);
  assertEquals(6,storage.getNumStorageDirs());
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.server.datanode.TestDatanodeRegister </h4><pre class="type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testDifferentLayoutVersions() throws Exception {
  assertEquals(HdfsConstants.NAMENODE_LAYOUT_VERSION,actor.retrieveNamespaceInfo().getLayoutVersion());
  doReturn(HdfsConstants.NAMENODE_LAYOUT_VERSION * 1000).when(fakeNsInfo).getLayoutVersion();
  try {
    actor.retrieveNamespaceInfo();
  }
 catch (  IOException e) {
    fail("Should not fail to retrieve NS info from DN with different layout version");
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testSoftwareVersionDifferences() throws Exception {
  assertEquals(VersionInfo.getVersion(),actor.retrieveNamespaceInfo().getSoftwareVersion());
  doReturn("4.0.0").when(fakeNsInfo).getSoftwareVersion();
  doReturn("3.0.0").when(mockDnConf).getMinimumNameNodeVersion();
  assertEquals("4.0.0",actor.retrieveNamespaceInfo().getSoftwareVersion());
  doReturn("3.0.0").when(fakeNsInfo).getSoftwareVersion();
  doReturn("4.0.0").when(mockDnConf).getMinimumNameNodeVersion();
  try {
    actor.retrieveNamespaceInfo();
    fail("Should have thrown an exception for NN with too-low version");
  }
 catch (  IncorrectVersionException ive) {
    GenericTestUtils.assertExceptionContains("The reported NameNode version is too low",ive);
    LOG.info("Got expected exception",ive);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.server.datanode.TestDeleteBlockPool </h4><pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testDeleteBlockPool() throws Exception {
  Configuration conf=new Configuration();
  MiniDFSCluster cluster=null;
  try {
    conf.set(DFSConfigKeys.DFS_NAMESERVICES,"namesServerId1,namesServerId2");
    cluster=new MiniDFSCluster.Builder(conf).nnTopology(MiniDFSNNTopology.simpleFederatedTopology(conf.get(DFSConfigKeys.DFS_NAMESERVICES))).numDataNodes(2).build();
    cluster.waitActive();
    FileSystem fs1=cluster.getFileSystem(0);
    FileSystem fs2=cluster.getFileSystem(1);
    DFSTestUtil.createFile(fs1,new Path("/alpha"),1024,(short)2,54);
    DFSTestUtil.createFile(fs2,new Path("/beta"),1024,(short)2,54);
    DataNode dn1=cluster.getDataNodes().get(0);
    DataNode dn2=cluster.getDataNodes().get(1);
    String bpid1=cluster.getNamesystem(0).getBlockPoolId();
    String bpid2=cluster.getNamesystem(1).getBlockPoolId();
    File dn1StorageDir1=cluster.getInstanceStorageDir(0,0);
    File dn1StorageDir2=cluster.getInstanceStorageDir(0,1);
    File dn2StorageDir1=cluster.getInstanceStorageDir(1,0);
    File dn2StorageDir2=cluster.getInstanceStorageDir(1,1);
    try {
      dn1.deleteBlockPool(bpid1,true);
      fail("Must not delete a running block pool");
    }
 catch (    IOException expected) {
    }
    Configuration nn1Conf=cluster.getConfiguration(1);
    nn1Conf.set(DFSConfigKeys.DFS_NAMESERVICES,"namesServerId2");
    dn1.refreshNamenodes(nn1Conf);
    assertEquals(1,dn1.getAllBpOs().length);
    try {
      dn1.deleteBlockPool(bpid1,false);
      fail("Must not delete if any block files exist unless " + "force is true");
    }
 catch (    IOException expected) {
    }
    verifyBlockPoolDirectories(true,dn1StorageDir1,bpid1);
    verifyBlockPoolDirectories(true,dn1StorageDir2,bpid1);
    dn1.deleteBlockPool(bpid1,true);
    verifyBlockPoolDirectories(false,dn1StorageDir1,bpid1);
    verifyBlockPoolDirectories(false,dn1StorageDir2,bpid1);
    fs1.delete(new Path("/alpha"),true);
    File finalDir1=MiniDFSCluster.getFinalizedDir(dn2StorageDir1,bpid1);
    File finalDir2=MiniDFSCluster.getFinalizedDir(dn2StorageDir1,bpid2);
    while ((!DatanodeUtil.dirNoFilesRecursive(finalDir1)) || (!DatanodeUtil.dirNoFilesRecursive(finalDir2))) {
      try {
        Thread.sleep(3000);
      }
 catch (      Exception ignored) {
      }
    }
    cluster.shutdownNameNode(0);
    try {
      dn2.deleteBlockPool(bpid1,true);
      fail("Must not delete a running block pool");
    }
 catch (    IOException expected) {
    }
    dn2.refreshNamenodes(nn1Conf);
    assertEquals(1,dn2.getAllBpOs().length);
    verifyBlockPoolDirectories(true,dn2StorageDir1,bpid1);
    verifyBlockPoolDirectories(true,dn2StorageDir2,bpid1);
    dn2.deleteBlockPool(bpid1,false);
    verifyBlockPoolDirectories(false,dn2StorageDir1,bpid1);
    verifyBlockPoolDirectories(false,dn2StorageDir2,bpid1);
    verifyBlockPoolDirectories(true,dn1StorageDir1,bpid2);
    verifyBlockPoolDirectories(true,dn1StorageDir2,bpid2);
    verifyBlockPoolDirectories(true,dn2StorageDir1,bpid2);
    verifyBlockPoolDirectories(true,dn2StorageDir2,bpid2);
    Path gammaFile=new Path("/gamma");
    DFSTestUtil.createFile(fs2,gammaFile,1024,(short)1,55);
    fs2.setReplication(gammaFile,(short)2);
    DFSTestUtil.waitReplication(fs2,gammaFile,(short)2);
  }
  finally {
    if (cluster != null) {
      cluster.shutdown();
    }
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.server.datanode.TestFsDatasetCache </h4><pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=600000) public void testUncachingBlocksBeforeCachingFinishes() throws Exception {
  LOG.info("beginning testUncachingBlocksBeforeCachingFinishes");
  final int NUM_BLOCKS=5;
  DFSTestUtil.verifyExpectedCacheUsage(0,0,fsd);
  final Path testFile=new Path("/testCacheBlock");
  final long testFileLen=BLOCK_SIZE * NUM_BLOCKS;
  DFSTestUtil.createFile(fs,testFile,testFileLen,(short)1,0xABBAl);
  HdfsBlockLocation[] locs=(HdfsBlockLocation[])fs.getFileBlockLocations(testFile,0,testFileLen);
  assertEquals("Unexpected number of blocks",NUM_BLOCKS,locs.length);
  final long[] blockSizes=getBlockSizes(locs);
  final long cacheCapacity=fsd.getCacheCapacity();
  long cacheUsed=fsd.getCacheUsed();
  long current=0;
  assertEquals("Unexpected cache capacity",CACHE_CAPACITY,cacheCapacity);
  assertEquals("Unexpected amount of cache used",current,cacheUsed);
  NativeIO.POSIX.setCacheManipulator(new NoMlockCacheManipulator(){
    @Override public void mlock(    String identifier,    ByteBuffer mmap,    long length) throws IOException {
      LOG.info("An mlock operation is starting on " + identifier);
      try {
        Thread.sleep(3000);
      }
 catch (      InterruptedException e) {
        Assert.fail();
      }
    }
  }
);
  for (int i=0; i < NUM_BLOCKS; i++) {
    setHeartbeatResponse(cacheBlock(locs[i]));
    current=DFSTestUtil.verifyExpectedCacheUsage(current + blockSizes[i],i + 1,fsd);
  }
  setHeartbeatResponse(new DatanodeCommand[]{getResponse(locs,DatanodeProtocol.DNA_UNCACHE)});
  current=DFSTestUtil.verifyExpectedCacheUsage(0,0,fsd);
  LOG.info("finishing testUncachingBlocksBeforeCachingFinishes");
}

</code></pre>

<br>
<pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testReCacheAfterUncache() throws Exception {
  final int TOTAL_BLOCKS_PER_CACHE=Ints.checkedCast(CACHE_CAPACITY / BLOCK_SIZE);
  BlockReaderTestUtil.enableHdfsCachingTracing();
  Assert.assertEquals(0,CACHE_CAPACITY % BLOCK_SIZE);
  final Path SMALL_FILE=new Path("/smallFile");
  DFSTestUtil.createFile(fs,SMALL_FILE,BLOCK_SIZE,(short)1,0xcafe);
  final Path BIG_FILE=new Path("/bigFile");
  DFSTestUtil.createFile(fs,BIG_FILE,TOTAL_BLOCKS_PER_CACHE * BLOCK_SIZE,(short)1,0xbeef);
  final DistributedFileSystem dfs=cluster.getFileSystem();
  dfs.addCachePool(new CachePoolInfo("pool"));
  final long bigCacheDirectiveId=dfs.addCacheDirective(new CacheDirectiveInfo.Builder().setPool("pool").setPath(BIG_FILE).setReplication((short)1).build());
  GenericTestUtils.waitFor(new Supplier<Boolean>(){
    @Override public Boolean get(){
      MetricsRecordBuilder dnMetrics=getMetrics(dn.getMetrics().name());
      long blocksCached=MetricsAsserts.getLongCounter("BlocksCached",dnMetrics);
      if (blocksCached != TOTAL_BLOCKS_PER_CACHE) {
        LOG.info("waiting for " + TOTAL_BLOCKS_PER_CACHE + " to "+ "be cached.   Right now only "+ blocksCached+ " blocks are cached.");
        return false;
      }
      LOG.info(TOTAL_BLOCKS_PER_CACHE + " blocks are now cached.");
      return true;
    }
  }
,1000,30000);
  final long shortCacheDirectiveId=dfs.addCacheDirective(new CacheDirectiveInfo.Builder().setPool("pool").setPath(SMALL_FILE).setReplication((short)1).build());
  Thread.sleep(10000);
  MetricsRecordBuilder dnMetrics=getMetrics(dn.getMetrics().name());
  Assert.assertEquals(TOTAL_BLOCKS_PER_CACHE,MetricsAsserts.getLongCounter("BlocksCached",dnMetrics));
  dfs.removeCacheDirective(bigCacheDirectiveId);
  GenericTestUtils.waitFor(new Supplier<Boolean>(){
    @Override public Boolean get(){
      RemoteIterator<CacheDirectiveEntry> iter;
      try {
        iter=dfs.listCacheDirectives(new CacheDirectiveInfo.Builder().build());
        CacheDirectiveEntry entry;
        do {
          entry=iter.next();
        }
 while (entry.getInfo().getId() != shortCacheDirectiveId);
        if (entry.getStats().getFilesCached() != 1) {
          LOG.info("waiting for directive " + shortCacheDirectiveId + " to be cached.  stats = "+ entry.getStats());
          return false;
        }
        LOG.info("directive " + shortCacheDirectiveId + " has been cached.");
      }
 catch (      IOException e) {
        Assert.fail("unexpected exception" + e.toString());
      }
      return true;
    }
  }
,1000,30000);
  dfs.removeCacheDirective(shortCacheDirectiveId);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.server.datanode.TestHdfsServerConstants </h4><pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * Test that we can parse a StartupOption string without the optional
 * RollingUpgradeStartupOption.
 */
@Test public void testStartupOptionParsing(){
  verifyStartupOptionResult("FORMAT",StartupOption.FORMAT,null);
  verifyStartupOptionResult("REGULAR",StartupOption.REGULAR,null);
  verifyStartupOptionResult("CHECKPOINT",StartupOption.CHECKPOINT,null);
  verifyStartupOptionResult("UPGRADE",StartupOption.UPGRADE,null);
  verifyStartupOptionResult("ROLLBACK",StartupOption.ROLLBACK,null);
  verifyStartupOptionResult("FINALIZE",StartupOption.FINALIZE,null);
  verifyStartupOptionResult("ROLLINGUPGRADE",StartupOption.ROLLINGUPGRADE,null);
  verifyStartupOptionResult("IMPORT",StartupOption.IMPORT,null);
  verifyStartupOptionResult("INITIALIZESHAREDEDITS",StartupOption.INITIALIZESHAREDEDITS,null);
  try {
    verifyStartupOptionResult("UNKNOWN(UNKNOWNOPTION)",StartupOption.FORMAT,null);
    fail("Failed to get expected IllegalArgumentException");
  }
 catch (  IllegalArgumentException iae) {
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * Test that we can parse a StartupOption string with a
 * RollingUpgradeStartupOption.
 */
@Test public void testRollingUpgradeStartupOptionParsing(){
  verifyStartupOptionResult("ROLLINGUPGRADE(ROLLBACK)",StartupOption.ROLLINGUPGRADE,RollingUpgradeStartupOption.ROLLBACK);
  verifyStartupOptionResult("ROLLINGUPGRADE(DOWNGRADE)",StartupOption.ROLLINGUPGRADE,RollingUpgradeStartupOption.DOWNGRADE);
  try {
    verifyStartupOptionResult("ROLLINGUPGRADE(UNKNOWNOPTION)",StartupOption.ROLLINGUPGRADE,null);
    fail("Failed to get expected IllegalArgumentException");
  }
 catch (  IllegalArgumentException iae) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.server.datanode.fsdataset.impl.TestInterDatanodeProtocol </h4><pre class="type-9 type-2 type-7 type-10 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test  for{@link FsDatasetImpl#updateReplicaUnderRecovery(ExtendedBlock,long,long)} 
 */
@Test public void testUpdateReplicaUnderRecovery() throws IOException {
  MiniDFSCluster cluster=null;
  try {
    cluster=new MiniDFSCluster.Builder(conf).numDataNodes(3).build();
    cluster.waitActive();
    String bpid=cluster.getNamesystem().getBlockPoolId();
    DistributedFileSystem dfs=cluster.getFileSystem();
    String filestr="/foo";
    Path filepath=new Path(filestr);
    DFSTestUtil.createFile(dfs,filepath,1024L,(short)3,0L);
    final LocatedBlock locatedblock=getLastLocatedBlock(DFSClientAdapter.getDFSClient(dfs).getNamenode(),filestr);
    final DatanodeInfo[] datanodeinfo=locatedblock.getLocations();
    Assert.assertTrue(datanodeinfo.length > 0);
    final DataNode datanode=cluster.getDataNode(datanodeinfo[0].getIpcPort());
    Assert.assertTrue(datanode != null);
    final ExtendedBlock b=locatedblock.getBlock();
    final long recoveryid=b.getGenerationStamp() + 1;
    final long newlength=b.getNumBytes() - 1;
    final FsDatasetSpi<?> fsdataset=DataNodeTestUtils.getFSDataset(datanode);
    final ReplicaRecoveryInfo rri=fsdataset.initReplicaRecovery(new RecoveringBlock(b,null,recoveryid));
    final ReplicaInfo replica=FsDatasetTestUtil.fetchReplicaInfo(fsdataset,bpid,b.getBlockId());
    Assert.assertEquals(ReplicaState.RUR,replica.getState());
    FsDatasetImpl.checkReplicaFiles(replica);
{
      final ExtendedBlock tmp=new ExtendedBlock(b.getBlockPoolId(),rri.getBlockId(),rri.getNumBytes() - 1,rri.getGenerationStamp());
      try {
        fsdataset.updateReplicaUnderRecovery(tmp,recoveryid,newlength);
        Assert.fail();
      }
 catch (      IOException ioe) {
        System.out.println("GOOD: getting " + ioe);
      }
    }
    final String storageID=fsdataset.updateReplicaUnderRecovery(new ExtendedBlock(b.getBlockPoolId(),rri),recoveryid,newlength);
    assertTrue(storageID != null);
  }
  finally {
    if (cluster != null)     cluster.shutdown();
  }
}

</code></pre>

<br>
<pre class="type-9 type-2 type-7 type-1 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test {@link FsDatasetImpl#initReplicaRecovery(String,ReplicaMap,Block,long,long)}
 */
@Test public void testInitReplicaRecovery() throws IOException {
  final long firstblockid=10000L;
  final long gs=7777L;
  final long length=22L;
  final ReplicaMap map=new ReplicaMap(this);
  String bpid="BP-TEST";
  final Block[] blocks=new Block[5];
  for (int i=0; i < blocks.length; i++) {
    blocks[i]=new Block(firstblockid + i,length,gs);
    map.add(bpid,createReplicaInfo(blocks[i]));
  }
{
    final Block b=blocks[0];
    final ReplicaInfo originalInfo=map.get(bpid,b);
    final long recoveryid=gs + 1;
    final ReplicaRecoveryInfo recoveryInfo=FsDatasetImpl.initReplicaRecovery(bpid,map,blocks[0],recoveryid,DFSConfigKeys.DFS_DATANODE_XCEIVER_STOP_TIMEOUT_MILLIS_DEFAULT);
    assertEquals(originalInfo,recoveryInfo);
    final ReplicaUnderRecovery updatedInfo=(ReplicaUnderRecovery)map.get(bpid,b);
    Assert.assertEquals(originalInfo.getBlockId(),updatedInfo.getBlockId());
    Assert.assertEquals(recoveryid,updatedInfo.getRecoveryID());
    final long recoveryid2=gs + 2;
    final ReplicaRecoveryInfo recoveryInfo2=FsDatasetImpl.initReplicaRecovery(bpid,map,blocks[0],recoveryid2,DFSConfigKeys.DFS_DATANODE_XCEIVER_STOP_TIMEOUT_MILLIS_DEFAULT);
    assertEquals(originalInfo,recoveryInfo2);
    final ReplicaUnderRecovery updatedInfo2=(ReplicaUnderRecovery)map.get(bpid,b);
    Assert.assertEquals(originalInfo.getBlockId(),updatedInfo2.getBlockId());
    Assert.assertEquals(recoveryid2,updatedInfo2.getRecoveryID());
    try {
      FsDatasetImpl.initReplicaRecovery(bpid,map,b,recoveryid,DFSConfigKeys.DFS_DATANODE_XCEIVER_STOP_TIMEOUT_MILLIS_DEFAULT);
      Assert.fail();
    }
 catch (    RecoveryInProgressException ripe) {
      System.out.println("GOOD: getting " + ripe);
    }
  }
{
    final long recoveryid=gs + 1;
    final Block b=new Block(firstblockid - 1,length,gs);
    ReplicaRecoveryInfo r=FsDatasetImpl.initReplicaRecovery(bpid,map,b,recoveryid,DFSConfigKeys.DFS_DATANODE_XCEIVER_STOP_TIMEOUT_MILLIS_DEFAULT);
    Assert.assertNull("Data-node should not have this replica.",r);
  }
{
    final long recoveryid=gs - 1;
    final Block b=new Block(firstblockid + 1,length,gs);
    try {
      FsDatasetImpl.initReplicaRecovery(bpid,map,b,recoveryid,DFSConfigKeys.DFS_DATANODE_XCEIVER_STOP_TIMEOUT_MILLIS_DEFAULT);
      Assert.fail();
    }
 catch (    IOException ioe) {
      System.out.println("GOOD: getting " + ioe);
    }
  }
{
    final long recoveryid=gs + 1;
    final Block b=new Block(firstblockid,length,gs + 1);
    try {
      FsDatasetImpl.initReplicaRecovery(bpid,map,b,recoveryid,DFSConfigKeys.DFS_DATANODE_XCEIVER_STOP_TIMEOUT_MILLIS_DEFAULT);
      fail("InitReplicaRecovery should fail because replica's " + "gs is less than the block's gs");
    }
 catch (    IOException e) {
      e.getMessage().startsWith("replica.getGenerationStamp() < block.getGenerationStamp(), block=");
    }
  }
}

</code></pre>

<br>
<pre class="type-2 type-14 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies that exceptions are thrown during the test case execution">ExceptionVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies that exceptions are thrown during the test case execution
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test to verify that InterDatanode RPC timesout as expected when
 * the server DN does not respond.
 */
@Test(expected=SocketTimeoutException.class) public void testInterDNProtocolTimeout() throws Throwable {
  final Server server=new TestServer(1,true);
  server.start();
  final InetSocketAddress addr=NetUtils.getConnectAddress(server);
  DatanodeID fakeDnId=DFSTestUtil.getLocalDatanodeID(addr.getPort());
  DatanodeInfo dInfo=new DatanodeInfo(fakeDnId);
  InterDatanodeProtocol proxy=null;
  try {
    proxy=DataNode.createInterDataNodeProtocolProxy(dInfo,conf,500,false);
    proxy.initReplicaRecovery(new RecoveringBlock(new ExtendedBlock("bpid",1),null,100));
    fail("Expected SocketTimeoutException exception, but did not get.");
  }
  finally {
    if (proxy != null) {
      RPC.stopProxy(proxy);
    }
    server.stop();
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.server.datanode.fsdataset.impl.TestReplicaMap </h4><pre class="type-2 type-7 type-1 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testRemove(){
  try {
    map.remove(bpid,null);
    fail("Expected exception not thrown");
  }
 catch (  IllegalArgumentException expected) {
  }
  Block b=new Block(block);
  b.setGenerationStamp(0);
  assertNull(map.remove(bpid,b));
  b.setGenerationStamp(block.getGenerationStamp());
  b.setBlockId(0);
  assertNull(map.remove(bpid,b));
  assertNotNull(map.remove(bpid,block));
  assertNull(map.remove(bpid,0));
  map.add(bpid,new FinalizedReplica(block,null,null));
  assertNotNull(map.remove(bpid,block.getBlockId()));
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testAdd(){
  try {
    map.add(bpid,null);
    fail("Expected exception not thrown");
  }
 catch (  IllegalArgumentException expected) {
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-1 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test for ReplicasMap.get(Block) and ReplicasMap.get(long) tests
 */
@Test public void testGet(){
  try {
    map.get(bpid,null);
    fail("Expected exception not thrown");
  }
 catch (  IllegalArgumentException expected) {
  }
  assertNotNull(map.get(bpid,block));
  Block b=new Block(block);
  b.setGenerationStamp(0);
  assertNull(map.get(bpid,b));
  b.setGenerationStamp(block.getGenerationStamp());
  b.setBlockId(0);
  assertNull(map.get(bpid,b));
  assertNotNull(map.get(bpid,block.getBlockId()));
  assertNull(map.get(bpid,0));
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.server.namenode.FSAclBaseTest </h4><pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testAccess() throws IOException, InterruptedException {
  Path p1=new Path("/p1");
  fs.mkdirs(p1);
  fs.setOwner(p1,BRUCE.getShortUserName(),"groupX");
  fsAsBruce.setAcl(p1,Lists.newArrayList(aclEntry(ACCESS,USER,READ),aclEntry(ACCESS,USER,"bruce",READ),aclEntry(ACCESS,GROUP,NONE),aclEntry(ACCESS,OTHER,NONE)));
  fsAsBruce.access(p1,FsAction.READ);
  try {
    fsAsBruce.access(p1,FsAction.WRITE);
    fail("The access call should have failed.");
  }
 catch (  AccessControlException e) {
  }
  Path badPath=new Path("/bad/bad");
  try {
    fsAsBruce.access(badPath,FsAction.READ);
    fail("The access call should have failed");
  }
 catch (  FileNotFoundException e) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.server.namenode.FSXAttrBaseTest </h4><pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Tests for setting xattr
 * 1. Set xattr with XAttrSetFlag.CREATE|XAttrSetFlag.REPLACE flag.
 * 2. Set xattr with illegal name.
 * 3. Set xattr without XAttrSetFlag.
 * 4. Set xattr and total number exceeds max limit.
 * 5. Set xattr and name is too long.
 * 6. Set xattr and value is too long.
 */
@Test(timeout=120000) public void testSetXAttr() throws Exception {
  FileSystem.mkdirs(fs,path,FsPermission.createImmutable((short)0750));
  fs.setXAttr(path,name1,value1,EnumSet.of(XAttrSetFlag.CREATE,XAttrSetFlag.REPLACE));
  Map<String,byte[]> xattrs=fs.getXAttrs(path);
  Assert.assertEquals(xattrs.size(),1);
  Assert.assertArrayEquals(value1,xattrs.get(name1));
  fs.removeXAttr(path,name1);
  try {
    fs.setXAttr(path,null,value1,EnumSet.of(XAttrSetFlag.CREATE,XAttrSetFlag.REPLACE));
    Assert.fail("Setting xattr with null name should fail.");
  }
 catch (  NullPointerException e) {
    GenericTestUtils.assertExceptionContains("XAttr name cannot be null",e);
  }
catch (  RemoteException e) {
    GenericTestUtils.assertExceptionContains("XAttr name cannot be null",e);
  }
  try {
    fs.setXAttr(path,"user.",value1,EnumSet.of(XAttrSetFlag.CREATE,XAttrSetFlag.REPLACE));
    Assert.fail("Setting xattr with empty name should fail.");
  }
 catch (  RemoteException e) {
    assertEquals("Unexpected RemoteException: " + e,e.getClassName(),HadoopIllegalArgumentException.class.getCanonicalName());
    GenericTestUtils.assertExceptionContains("XAttr name cannot be empty",e);
  }
catch (  HadoopIllegalArgumentException e) {
    GenericTestUtils.assertExceptionContains("XAttr name cannot be empty",e);
  }
  try {
    fs.setXAttr(path,"a1",value1,EnumSet.of(XAttrSetFlag.CREATE,XAttrSetFlag.REPLACE));
    Assert.fail("Setting xattr with invalid name prefix or without " + "name prefix should fail.");
  }
 catch (  RemoteException e) {
    assertEquals("Unexpected RemoteException: " + e,e.getClassName(),HadoopIllegalArgumentException.class.getCanonicalName());
    GenericTestUtils.assertExceptionContains("XAttr name must be prefixed",e);
  }
catch (  HadoopIllegalArgumentException e) {
    GenericTestUtils.assertExceptionContains("XAttr name must be prefixed",e);
  }
  fs.setXAttr(path,name1,value1);
  xattrs=fs.getXAttrs(path);
  Assert.assertEquals(xattrs.size(),1);
  Assert.assertArrayEquals(value1,xattrs.get(name1));
  fs.removeXAttr(path,name1);
  fs.setXAttr(path,name1,value1,EnumSet.of(XAttrSetFlag.CREATE));
  fs.setXAttr(path,name1,newValue1,EnumSet.of(XAttrSetFlag.CREATE,XAttrSetFlag.REPLACE));
  xattrs=fs.getXAttrs(path);
  Assert.assertEquals(xattrs.size(),1);
  Assert.assertArrayEquals(newValue1,xattrs.get(name1));
  fs.removeXAttr(path,name1);
  fs.setXAttr(path,name1,value1);
  fs.setXAttr(path,name2,value2);
  fs.setXAttr(path,name3,null);
  try {
    fs.setXAttr(path,name4,null);
    Assert.fail("Setting xattr should fail if total number of xattrs " + "for inode exceeds max limit.");
  }
 catch (  IOException e) {
    GenericTestUtils.assertExceptionContains("Cannot add additional XAttr",e);
  }
  fs.removeXAttr(path,name1);
  fs.removeXAttr(path,name2);
  fs.removeXAttr(path,name3);
  String longName="user.0123456789abcdefX";
  try {
    fs.setXAttr(path,longName,null);
    Assert.fail("Setting xattr should fail if name is too long.");
  }
 catch (  IOException e) {
    GenericTestUtils.assertExceptionContains("XAttr is too big",e);
    GenericTestUtils.assertExceptionContains("total size is 17",e);
  }
  byte[] longValue=new byte[MAX_SIZE];
  try {
    fs.setXAttr(path,"user.a",longValue);
    Assert.fail("Setting xattr should fail if value is too long.");
  }
 catch (  IOException e) {
    GenericTestUtils.assertExceptionContains("XAttr is too big",e);
    GenericTestUtils.assertExceptionContains("total size is 17",e);
  }
  String name="user.111";
  byte[] value=new byte[MAX_SIZE - 3];
  fs.setXAttr(path,name,value);
}

</code></pre>

<br>
<pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Tests for replacing xattr
 * 1. Replace an xattr using XAttrSetFlag.REPLACE.
 * 2. Replace an xattr which doesn't exist and expect an exception.
 * 3. Create multiple xattrs and replace some.
 * 4. Restart NN and save checkpoint scenarios.
 */
@Test(timeout=120000) public void testReplaceXAttr() throws Exception {
  FileSystem.mkdirs(fs,path,FsPermission.createImmutable((short)0750));
  fs.setXAttr(path,name1,value1,EnumSet.of(XAttrSetFlag.CREATE));
  fs.setXAttr(path,name1,newValue1,EnumSet.of(XAttrSetFlag.REPLACE));
  Map<String,byte[]> xattrs=fs.getXAttrs(path);
  Assert.assertEquals(xattrs.size(),1);
  Assert.assertArrayEquals(newValue1,xattrs.get(name1));
  fs.removeXAttr(path,name1);
  try {
    fs.setXAttr(path,name1,value1,EnumSet.of(XAttrSetFlag.REPLACE));
    Assert.fail("Replacing xattr which does not exist should fail.");
  }
 catch (  IOException e) {
  }
  fs.setXAttr(path,name1,value1,EnumSet.of(XAttrSetFlag.CREATE));
  fs.setXAttr(path,name2,value2,EnumSet.of(XAttrSetFlag.CREATE));
  fs.setXAttr(path,name2,null,EnumSet.of(XAttrSetFlag.REPLACE));
  xattrs=fs.getXAttrs(path);
  Assert.assertEquals(xattrs.size(),2);
  Assert.assertArrayEquals(value1,xattrs.get(name1));
  Assert.assertArrayEquals(new byte[0],xattrs.get(name2));
  restart(false);
  initFileSystem();
  xattrs=fs.getXAttrs(path);
  Assert.assertEquals(xattrs.size(),2);
  Assert.assertArrayEquals(value1,xattrs.get(name1));
  Assert.assertArrayEquals(new byte[0],xattrs.get(name2));
  restart(true);
  initFileSystem();
  xattrs=fs.getXAttrs(path);
  Assert.assertEquals(xattrs.size(),2);
  Assert.assertArrayEquals(value1,xattrs.get(name1));
  Assert.assertArrayEquals(new byte[0],xattrs.get(name2));
  fs.removeXAttr(path,name1);
  fs.removeXAttr(path,name2);
}

</code></pre>

<br>
<pre class="type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * removexattr tests. Test that removexattr throws an exception if any of
 * the following are true:
 * an xattr that was requested doesn't exist
 * the caller specifies an unknown namespace
 * the caller doesn't have access to the namespace
 * the caller doesn't have permission to get the value of the xattr
 * the caller does not have "execute" (scan) access to the parent directory
 * the caller has only read access to the owning directory
 * the caller has only execute access to the owning directory and execute
 * access to the actual entity
 * the caller does not have execute access to the owning directory and write
 * access to the actual entity
 */
@Test(timeout=120000) public void testRemoveXAttrPermissions() throws Exception {
  FileSystem.mkdirs(fs,path,FsPermission.createImmutable((short)0750));
  fs.setXAttr(path,name1,value1,EnumSet.of(XAttrSetFlag.CREATE));
  fs.setXAttr(path,name2,value2,EnumSet.of(XAttrSetFlag.CREATE));
  fs.setXAttr(path,name3,null,EnumSet.of(XAttrSetFlag.CREATE));
  try {
    fs.removeXAttr(path,name2);
    fs.removeXAttr(path,name2);
    Assert.fail("expected IOException");
  }
 catch (  IOException e) {
    GenericTestUtils.assertExceptionContains("No matching attributes found",e);
  }
  final String expectedExceptionString="An XAttr name must be prefixed " + "with user/trusted/security/system/raw, followed by a '.'";
  try {
    fs.removeXAttr(path,"wackynamespace.foo");
    Assert.fail("expected IOException");
  }
 catch (  RemoteException e) {
    assertEquals("Unexpected RemoteException: " + e,e.getClassName(),HadoopIllegalArgumentException.class.getCanonicalName());
    GenericTestUtils.assertExceptionContains(expectedExceptionString,e);
  }
catch (  HadoopIllegalArgumentException e) {
    GenericTestUtils.assertExceptionContains(expectedExceptionString,e);
  }
  final UserGroupInformation user=UserGroupInformation.createUserForTesting("user",new String[]{"mygroup"});
  fs.setXAttr(path,"trusted.foo","1234".getBytes());
  try {
    user.doAs(new PrivilegedExceptionAction(){
      @Override public Object run() throws Exception {
        final FileSystem userFs=dfsCluster.getFileSystem();
        userFs.removeXAttr(path,"trusted.foo");
        return null;
      }
    }
);
    Assert.fail("expected IOException");
  }
 catch (  IOException e) {
    GenericTestUtils.assertExceptionContains("User doesn't have permission",e);
  }
 finally {
    fs.removeXAttr(path,"trusted.foo");
  }
  fs.setPermission(path,new FsPermission((short)0700));
  try {
    user.doAs(new PrivilegedExceptionAction(){
      @Override public Object run() throws Exception {
        final FileSystem userFs=dfsCluster.getFileSystem();
        userFs.removeXAttr(path,name1);
        return null;
      }
    }
);
    Assert.fail("expected IOException");
  }
 catch (  IOException e) {
    GenericTestUtils.assertExceptionContains("Permission denied",e);
  }
  final Path childDir=new Path(path,"child" + pathCount);
  FileSystem.mkdirs(fs,childDir,FsPermission.createImmutable((short)0700));
  fs.setXAttr(childDir,name1,"1234".getBytes());
  try {
    user.doAs(new PrivilegedExceptionAction(){
      @Override public Object run() throws Exception {
        final FileSystem userFs=dfsCluster.getFileSystem();
        userFs.removeXAttr(childDir,name1);
        return null;
      }
    }
);
    Assert.fail("expected IOException");
  }
 catch (  IOException e) {
    GenericTestUtils.assertExceptionContains("Permission denied",e);
  }
  fs.setPermission(path,new FsPermission((short)0704));
  try {
    user.doAs(new PrivilegedExceptionAction(){
      @Override public Object run() throws Exception {
        final FileSystem userFs=dfsCluster.getFileSystem();
        userFs.removeXAttr(childDir,name1);
        return null;
      }
    }
);
    Assert.fail("expected IOException");
  }
 catch (  IOException e) {
    GenericTestUtils.assertExceptionContains("Permission denied",e);
  }
  fs.setPermission(path,new FsPermission((short)0701));
  fs.setPermission(childDir,new FsPermission((short)0701));
  try {
    user.doAs(new PrivilegedExceptionAction(){
      @Override public Object run() throws Exception {
        final FileSystem userFs=dfsCluster.getFileSystem();
        userFs.removeXAttr(childDir,name1);
        return null;
      }
    }
);
    Assert.fail("expected IOException");
  }
 catch (  IOException e) {
    GenericTestUtils.assertExceptionContains("Permission denied",e);
  }
  fs.setPermission(path,new FsPermission((short)0701));
  fs.setPermission(childDir,new FsPermission((short)0706));
  user.doAs(new PrivilegedExceptionAction(){
    @Override public Object run() throws Exception {
      final FileSystem userFs=dfsCluster.getFileSystem();
      userFs.removeXAttr(childDir,name1);
      return null;
    }
  }
);
}

</code></pre>

<br>
<pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Tests for creating xattr
 * 1. Create an xattr using XAttrSetFlag.CREATE.
 * 2. Create an xattr which already exists and expect an exception.
 * 3. Create multiple xattrs.
 * 4. Restart NN and save checkpoint scenarios.
 */
@Test(timeout=120000) public void testCreateXAttr() throws Exception {
  FileSystem.mkdirs(fs,path,FsPermission.createImmutable((short)0750));
  fs.setXAttr(path,name1,value1,EnumSet.of(XAttrSetFlag.CREATE));
  Map<String,byte[]> xattrs=fs.getXAttrs(path);
  Assert.assertEquals(xattrs.size(),1);
  Assert.assertArrayEquals(value1,xattrs.get(name1));
  fs.removeXAttr(path,name1);
  xattrs=fs.getXAttrs(path);
  Assert.assertEquals(xattrs.size(),0);
  fs.setXAttr(path,name1,value1,EnumSet.of(XAttrSetFlag.CREATE));
  try {
    fs.setXAttr(path,name1,value1,EnumSet.of(XAttrSetFlag.CREATE));
    Assert.fail("Creating xattr which already exists should fail.");
  }
 catch (  IOException e) {
  }
  fs.removeXAttr(path,name1);
  fs.setXAttr(path,name1,value1,EnumSet.of(XAttrSetFlag.CREATE));
  fs.setXAttr(path,name2,null,EnumSet.of(XAttrSetFlag.CREATE));
  xattrs=fs.getXAttrs(path);
  Assert.assertEquals(xattrs.size(),2);
  Assert.assertArrayEquals(value1,xattrs.get(name1));
  Assert.assertArrayEquals(new byte[0],xattrs.get(name2));
  restart(false);
  initFileSystem();
  xattrs=fs.getXAttrs(path);
  Assert.assertEquals(xattrs.size(),2);
  Assert.assertArrayEquals(value1,xattrs.get(name1));
  Assert.assertArrayEquals(new byte[0],xattrs.get(name2));
  restart(true);
  initFileSystem();
  xattrs=fs.getXAttrs(path);
  Assert.assertEquals(xattrs.size(),2);
  Assert.assertArrayEquals(value1,xattrs.get(name1));
  Assert.assertArrayEquals(new byte[0],xattrs.get(name2));
  fs.removeXAttr(path,name1);
  fs.removeXAttr(path,name2);
}

</code></pre>

<br>
<pre class="type-2 type-7 type-10 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=120000) public void testRawXAttrs() throws Exception {
  final UserGroupInformation user=UserGroupInformation.createUserForTesting("user",new String[]{"mygroup"});
  FileSystem.mkdirs(fs,path,FsPermission.createImmutable((short)0750));
  fs.setXAttr(rawPath,raw1,value1,EnumSet.of(XAttrSetFlag.CREATE,XAttrSetFlag.REPLACE));
{
    final byte[] value=fs.getXAttr(rawPath,raw1);
    Assert.assertArrayEquals(value,value1);
  }
{
    final Map<String,byte[]> xattrs=fs.getXAttrs(rawPath);
    Assert.assertEquals(xattrs.size(),1);
    Assert.assertArrayEquals(value1,xattrs.get(raw1));
    fs.removeXAttr(rawPath,raw1);
  }
{
    fs.setXAttr(rawPath,raw1,value1,EnumSet.of(XAttrSetFlag.CREATE));
    fs.setXAttr(rawPath,raw1,newValue1,EnumSet.of(XAttrSetFlag.CREATE,XAttrSetFlag.REPLACE));
    final Map<String,byte[]> xattrs=fs.getXAttrs(rawPath);
    Assert.assertEquals(xattrs.size(),1);
    Assert.assertArrayEquals(newValue1,xattrs.get(raw1));
    fs.removeXAttr(rawPath,raw1);
  }
{
    fs.setXAttr(rawPath,raw1,value1,EnumSet.of(XAttrSetFlag.CREATE));
    fs.setXAttr(rawPath,raw2,value2,EnumSet.of(XAttrSetFlag.CREATE));
    final List<String> xattrNames=fs.listXAttrs(rawPath);
    assertTrue(xattrNames.contains(raw1));
    assertTrue(xattrNames.contains(raw2));
    assertTrue(xattrNames.size() == 2);
    fs.removeXAttr(rawPath,raw1);
    fs.removeXAttr(rawPath,raw2);
  }
{
    fs.setXAttr(rawPath,raw1,value1,EnumSet.of(XAttrSetFlag.CREATE));
    fs.setXAttr(rawPath,raw2,value2,EnumSet.of(XAttrSetFlag.CREATE));
    final List<String> xattrNames=fs.listXAttrs(path);
    assertTrue(xattrNames.size() == 0);
    fs.removeXAttr(rawPath,raw1);
    fs.removeXAttr(rawPath,raw2);
  }
{
    user.doAs(new PrivilegedExceptionAction(){
      @Override public Object run() throws Exception {
        final FileSystem userFs=dfsCluster.getFileSystem();
        try {
          userFs.setXAttr(path,raw1,value1);
          fail("setXAttr should have thrown");
        }
 catch (        AccessControlException e) {
        }
        try {
          userFs.setXAttr(rawPath,raw1,value1);
          fail("setXAttr should have thrown");
        }
 catch (        AccessControlException e) {
        }
        try {
          userFs.getXAttrs(rawPath);
          fail("getXAttrs should have thrown");
        }
 catch (        AccessControlException e) {
        }
        try {
          userFs.getXAttrs(path);
          fail("getXAttrs should have thrown");
        }
 catch (        AccessControlException e) {
        }
        try {
          userFs.getXAttr(rawPath,raw1);
          fail("getXAttr should have thrown");
        }
 catch (        AccessControlException e) {
        }
        try {
          userFs.getXAttr(path,raw1);
          fail("getXAttr should have thrown");
        }
 catch (        AccessControlException e) {
        }
        return null;
      }
    }
);
  }
{
    fs.setXAttr(rawPath,raw1,value1);
    user.doAs(new PrivilegedExceptionAction(){
      @Override public Object run() throws Exception {
        final FileSystem userFs=dfsCluster.getFileSystem();
        try {
          userFs.getXAttr(rawPath,raw1);
          fail("getXAttr should have thrown");
        }
 catch (        AccessControlException e) {
        }
        try {
          userFs.getXAttr(path,raw1);
          fail("getXAttr should have thrown");
        }
 catch (        AccessControlException e) {
        }
        final List<String> xattrNames=userFs.listXAttrs(path);
        assertTrue(xattrNames.size() == 0);
        try {
          userFs.listXAttrs(rawPath);
          fail("listXAttrs on raw path should have thrown");
        }
 catch (        AccessControlException e) {
        }
        return null;
      }
    }
);
    fs.removeXAttr(rawPath,raw1);
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * getxattr tests. Test that getxattr throws an exception if any of
 * the following are true:
 * an xattr that was requested doesn't exist
 * the caller specifies an unknown namespace
 * the caller doesn't have access to the namespace
 * the caller doesn't have permission to get the value of the xattr
 * the caller does not have search access to the parent directory
 * the caller has only read access to the owning directory
 * the caller has only search access to the owning directory and
 * execute/search access to the actual entity
 * the caller does not have search access to the owning directory and read
 * access to the actual entity
 */
@Test(timeout=120000) public void testGetXAttrs() throws Exception {
  FileSystem.mkdirs(fs,path,FsPermission.createImmutable((short)0750));
  fs.setXAttr(path,name1,value1,EnumSet.of(XAttrSetFlag.CREATE));
  fs.setXAttr(path,name2,value2,EnumSet.of(XAttrSetFlag.CREATE));
  try {
    final byte[] value=fs.getXAttr(path,name3);
    Assert.fail("expected IOException");
  }
 catch (  IOException e) {
    GenericTestUtils.assertExceptionContains("At least one of the attributes provided was not found.",e);
  }
{
    final List<String> names=Lists.newArrayList();
    names.add(name1);
    names.add(name2);
    names.add(name3);
    try {
      final Map<String,byte[]> xattrs=fs.getXAttrs(path,names);
      Assert.fail("expected IOException");
    }
 catch (    IOException e) {
      GenericTestUtils.assertExceptionContains("At least one of the attributes provided was not found.",e);
    }
  }
  fs.removeXAttr(path,name1);
  fs.removeXAttr(path,name2);
  try {
    final byte[] xattr=fs.getXAttr(path,"wackynamespace.foo");
    Assert.fail("expected IOException");
  }
 catch (  Exception e) {
    GenericTestUtils.assertExceptionContains("An XAttr name must be prefixed with " + "user/trusted/security/system/raw, " + "followed by a '.'",e);
  }
  final UserGroupInformation user=UserGroupInformation.createUserForTesting("user",new String[]{"mygroup"});
  fs.setXAttr(path,"trusted.foo","1234".getBytes());
  try {
    user.doAs(new PrivilegedExceptionAction(){
      @Override public Object run() throws Exception {
        final FileSystem userFs=dfsCluster.getFileSystem();
        final byte[] xattr=userFs.getXAttr(path,"trusted.foo");
        return null;
      }
    }
);
    Assert.fail("expected IOException");
  }
 catch (  IOException e) {
    GenericTestUtils.assertExceptionContains("User doesn't have permission",e);
  }
  fs.setXAttr(path,name1,"1234".getBytes());
  fs.setPermission(path,new FsPermission((short)0700));
  try {
    user.doAs(new PrivilegedExceptionAction(){
      @Override public Object run() throws Exception {
        final FileSystem userFs=dfsCluster.getFileSystem();
        final byte[] xattr=userFs.getXAttr(path,name1);
        return null;
      }
    }
);
    Assert.fail("expected IOException");
  }
 catch (  IOException e) {
    GenericTestUtils.assertExceptionContains("Permission denied",e);
  }
  final Path childDir=new Path(path,"child" + pathCount);
  FileSystem.mkdirs(fs,childDir,FsPermission.createImmutable((short)0700));
  fs.setXAttr(childDir,name1,"1234".getBytes());
  try {
    user.doAs(new PrivilegedExceptionAction(){
      @Override public Object run() throws Exception {
        final FileSystem userFs=dfsCluster.getFileSystem();
        final byte[] xattr=userFs.getXAttr(childDir,name1);
        return null;
      }
    }
);
    Assert.fail("expected IOException");
  }
 catch (  IOException e) {
    GenericTestUtils.assertExceptionContains("Permission denied",e);
  }
  fs.setPermission(path,new FsPermission((short)0704));
  try {
    user.doAs(new PrivilegedExceptionAction(){
      @Override public Object run() throws Exception {
        final FileSystem userFs=dfsCluster.getFileSystem();
        final byte[] xattr=userFs.getXAttr(childDir,name1);
        return null;
      }
    }
);
    Assert.fail("expected IOException");
  }
 catch (  IOException e) {
    GenericTestUtils.assertExceptionContains("Permission denied",e);
  }
  fs.setPermission(path,new FsPermission((short)0701));
  fs.setPermission(childDir,new FsPermission((short)0701));
  try {
    user.doAs(new PrivilegedExceptionAction(){
      @Override public Object run() throws Exception {
        final FileSystem userFs=dfsCluster.getFileSystem();
        final byte[] xattr=userFs.getXAttr(childDir,name1);
        return null;
      }
    }
);
    Assert.fail("expected IOException");
  }
 catch (  IOException e) {
    GenericTestUtils.assertExceptionContains("Permission denied",e);
  }
  fs.setPermission(path,new FsPermission((short)0701));
  fs.setPermission(childDir,new FsPermission((short)0704));
  user.doAs(new PrivilegedExceptionAction(){
    @Override public Object run() throws Exception {
      final FileSystem userFs=dfsCluster.getFileSystem();
      final byte[] xattr=userFs.getXAttr(childDir,name1);
      return null;
    }
  }
);
}

</code></pre>

<br>
<pre class="type-2 type-7 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test the listXAttrs api.
 * listXAttrs on a path that doesn't exist.
 * listXAttrs on a path with no XAttrs
 * Check basic functionality.
 * Check that read access to parent dir is not enough to get xattr names
 * Check that write access to the parent dir is not enough to get names
 * Check that execute/scan access to the parent dir is sufficient to get
 * xattr names.
 */
@Test(timeout=120000) public void testListXAttrs() throws Exception {
  final UserGroupInformation user=UserGroupInformation.createUserForTesting("user",new String[]{"mygroup"});
  try {
    fs.listXAttrs(path);
    fail("expected FileNotFoundException");
  }
 catch (  FileNotFoundException e) {
    GenericTestUtils.assertExceptionContains("cannot find",e);
  }
  FileSystem.mkdirs(fs,path,FsPermission.createImmutable((short)0750));
  final List<String> noXAttrs=fs.listXAttrs(path);
  assertTrue("XAttrs were found?",noXAttrs.size() == 0);
  fs.setXAttr(path,name1,value1,EnumSet.of(XAttrSetFlag.CREATE));
  fs.setXAttr(path,name2,value2,EnumSet.of(XAttrSetFlag.CREATE));
  final List<String> xattrNames=fs.listXAttrs(path);
  assertTrue(xattrNames.contains(name1));
  assertTrue(xattrNames.contains(name2));
  assertTrue(xattrNames.size() == 2);
  fs.setPermission(path,new FsPermission((short)0704));
  final Path childDir=new Path(path,"child" + pathCount);
  FileSystem.mkdirs(fs,childDir,FsPermission.createImmutable((short)0700));
  fs.setXAttr(childDir,name1,"1234".getBytes());
  try {
    user.doAs(new PrivilegedExceptionAction(){
      @Override public Object run() throws Exception {
        final FileSystem userFs=dfsCluster.getFileSystem();
        userFs.listXAttrs(childDir);
        return null;
      }
    }
);
    fail("expected IOException");
  }
 catch (  IOException e) {
    GenericTestUtils.assertExceptionContains("Permission denied",e);
  }
  fs.setPermission(path,new FsPermission((short)0702));
  try {
    user.doAs(new PrivilegedExceptionAction(){
      @Override public Object run() throws Exception {
        final FileSystem userFs=dfsCluster.getFileSystem();
        userFs.listXAttrs(childDir);
        return null;
      }
    }
);
    fail("expected IOException");
  }
 catch (  IOException e) {
    GenericTestUtils.assertExceptionContains("Permission denied",e);
  }
  fs.setPermission(path,new FsPermission((short)0701));
  user.doAs(new PrivilegedExceptionAction(){
    @Override public Object run() throws Exception {
      final FileSystem userFs=dfsCluster.getFileSystem();
      userFs.listXAttrs(childDir);
      return null;
    }
  }
);
  fs.setXAttr(childDir,"trusted.myxattr","1234".getBytes());
  user.doAs(new PrivilegedExceptionAction(){
    @Override public Object run() throws Exception {
      final FileSystem userFs=dfsCluster.getFileSystem();
      assertTrue(userFs.listXAttrs(childDir).size() == 1);
      return null;
    }
  }
);
  assertTrue(fs.listXAttrs(childDir).size() == 2);
}

</code></pre>

<br>
<pre class="type-9 type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=120000) public void testXAttrAcl() throws Exception {
  FileSystem.mkdirs(fs,path,FsPermission.createImmutable((short)0750));
  fs.setOwner(path,BRUCE.getUserName(),null);
  FileSystem fsAsBruce=createFileSystem(BRUCE);
  FileSystem fsAsDiana=createFileSystem(DIANA);
  fsAsBruce.setXAttr(path,name1,value1);
  Map<String,byte[]> xattrs;
  try {
    xattrs=fsAsDiana.getXAttrs(path);
    Assert.fail("Diana should not have read access to get xattrs");
  }
 catch (  AccessControlException e) {
  }
  fsAsBruce.modifyAclEntries(path,Lists.newArrayList(aclEntry(ACCESS,USER,DIANA.getUserName(),READ)));
  xattrs=fsAsDiana.getXAttrs(path);
  Assert.assertArrayEquals(value1,xattrs.get(name1));
  try {
    fsAsDiana.removeXAttr(path,name1);
    Assert.fail("Diana should not have write access to remove xattrs");
  }
 catch (  AccessControlException e) {
  }
  try {
    fsAsDiana.setXAttr(path,name2,value2);
    Assert.fail("Diana should not have write access to set xattrs");
  }
 catch (  AccessControlException e) {
  }
  fsAsBruce.modifyAclEntries(path,Lists.newArrayList(aclEntry(ACCESS,USER,DIANA.getUserName(),ALL)));
  fsAsDiana.setXAttr(path,name2,value2);
  Assert.assertArrayEquals(value2,fsAsDiana.getXAttrs(path).get(name2));
  fsAsDiana.removeXAttr(path,name1);
  fsAsDiana.removeXAttr(path,name2);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.server.namenode.TestAllowFormat </h4><pre class="type-2 type-7 type-10 type-1 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * start MiniDFScluster, try formatting with different settings
 * @throws IOException
 * @throws InterruptedException 
 */
@Test public void testAllowFormat() throws IOException {
  LOG.info("--starting mini cluster");
  NameNode nn;
  config.setBoolean(DFS_NAMENODE_SUPPORT_ALLOW_FORMAT_KEY,true);
  cluster=new MiniDFSCluster.Builder(config).manageDataDfsDirs(false).manageNameDfsDirs(false).build();
  cluster.waitActive();
  assertNotNull(cluster);
  nn=cluster.getNameNode();
  assertNotNull(nn);
  LOG.info("Mini cluster created OK");
  LOG.info("Verifying format will fail with allowformat false");
  config.setBoolean(DFS_NAMENODE_SUPPORT_ALLOW_FORMAT_KEY,false);
  try {
    cluster.shutdown();
    NameNode.format(config);
    fail("Format succeeded, when it should have failed");
  }
 catch (  IOException e) {
    assertTrue("Exception was not about formatting Namenode",e.getMessage().startsWith("The option " + DFS_NAMENODE_SUPPORT_ALLOW_FORMAT_KEY));
    LOG.info("Expected failure: " + StringUtils.stringifyException(e));
    LOG.info("Done verifying format will fail with allowformat false");
  }
  LOG.info("Verifying format will succeed with allowformat true");
  config.setBoolean(DFS_NAMENODE_SUPPORT_ALLOW_FORMAT_KEY,true);
  NameNode.format(config);
  LOG.info("Done verifying format will succeed with allowformat true");
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.server.namenode.TestAuditLogger </h4><pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * Tests that a broken audit logger causes requests to fail.
 */
@Test public void testBrokenLogger() throws IOException {
  Configuration conf=new HdfsConfiguration();
  conf.set(DFS_NAMENODE_AUDIT_LOGGERS_KEY,BrokenAuditLogger.class.getName());
  MiniDFSCluster cluster=new MiniDFSCluster.Builder(conf).build();
  try {
    cluster.waitClusterUp();
    FileSystem fs=cluster.getFileSystem();
    long time=System.currentTimeMillis();
    fs.setTimes(new Path("/"),time,time);
    fail("Expected exception due to broken audit logger.");
  }
 catch (  RemoteException re) {
  }
 finally {
    cluster.shutdown();
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.server.namenode.TestAuditLogs </h4><pre class="type-9 type-2 type-7 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
"></span><br>
/** 
 * test that denied access via webhdfs puts proper entry in audit log 
 */
@Test public void testAuditWebHdfsDenied() throws Exception {
  final Path file=new Path(fnames[0]);
  fs.setPermission(file,new FsPermission((short)0600));
  fs.setOwner(file,"root",null);
  setupAuditLogs();
  try {
    WebHdfsFileSystem webfs=WebHdfsTestUtil.getWebHdfsFileSystemAs(userGroupInfo,conf,WebHdfsFileSystem.SCHEME);
    InputStream istream=webfs.open(file);
    int val=istream.read();
    fail("open+read must not succeed, got " + val);
  }
 catch (  AccessControlException E) {
    System.out.println("got access denied, as expected.");
  }
  verifyAuditLogsRepeat(false,2);
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * test that denied operation puts proper entry in audit log 
 */
@Test public void testAuditDenied() throws Exception {
  final Path file=new Path(fnames[0]);
  FileSystem userfs=DFSTestUtil.getFileSystemAs(userGroupInfo,conf);
  fs.setPermission(file,new FsPermission((short)0600));
  fs.setOwner(file,"root",null);
  setupAuditLogs();
  try {
    userfs.open(file);
    fail("open must not succeed");
  }
 catch (  AccessControlException e) {
    System.out.println("got access denied, as expected.");
  }
  verifyAuditLogs(false);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.server.namenode.TestCacheDirectives </h4><pre class="type-2 type-7 type-10 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testCreateAndModifyPools() throws Exception {
  String poolName="pool1";
  String ownerName="abc";
  String groupName="123";
  FsPermission mode=new FsPermission((short)0755);
  long limit=150;
  dfs.addCachePool(new CachePoolInfo(poolName).setOwnerName(ownerName).setGroupName(groupName).setMode(mode).setLimit(limit));
  RemoteIterator<CachePoolEntry> iter=dfs.listCachePools();
  CachePoolInfo info=iter.next().getInfo();
  assertEquals(poolName,info.getPoolName());
  assertEquals(ownerName,info.getOwnerName());
  assertEquals(groupName,info.getGroupName());
  ownerName="def";
  groupName="456";
  mode=new FsPermission((short)0700);
  limit=151;
  dfs.modifyCachePool(new CachePoolInfo(poolName).setOwnerName(ownerName).setGroupName(groupName).setMode(mode).setLimit(limit));
  iter=dfs.listCachePools();
  info=iter.next().getInfo();
  assertEquals(poolName,info.getPoolName());
  assertEquals(ownerName,info.getOwnerName());
  assertEquals(groupName,info.getGroupName());
  assertEquals(mode,info.getMode());
  assertEquals(limit,(long)info.getLimit());
  dfs.removeCachePool(poolName);
  iter=dfs.listCachePools();
  assertFalse("expected no cache pools after deleting pool",iter.hasNext());
  proto.listCachePools(null);
  try {
    proto.removeCachePool("pool99");
    fail("expected to get an exception when " + "removing a non-existent pool.");
  }
 catch (  IOException ioe) {
    GenericTestUtils.assertExceptionContains("Cannot remove non-existent",ioe);
  }
  try {
    proto.removeCachePool(poolName);
    fail("expected to get an exception when " + "removing a non-existent pool.");
  }
 catch (  IOException ioe) {
    GenericTestUtils.assertExceptionContains("Cannot remove non-existent",ioe);
  }
  iter=dfs.listCachePools();
  assertFalse("expected no cache pools after deleting pool",iter.hasNext());
}

</code></pre>

<br>
<pre class="type-2 type-7 type-10 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=30000) public void testMaxRelativeExpiry() throws Exception {
  try {
    dfs.addCachePool(new CachePoolInfo("failpool").setMaxRelativeExpiryMs(-1l));
    fail("Added a pool with a negative max expiry.");
  }
 catch (  InvalidRequestException e) {
    GenericTestUtils.assertExceptionContains("negative",e);
  }
  try {
    dfs.addCachePool(new CachePoolInfo("failpool").setMaxRelativeExpiryMs(Long.MAX_VALUE - 1));
    fail("Added a pool with too big of a max expiry.");
  }
 catch (  InvalidRequestException e) {
    GenericTestUtils.assertExceptionContains("too big",e);
  }
  CachePoolInfo coolPool=new CachePoolInfo("coolPool");
  final long poolExpiration=1000 * 60 * 10l;
  dfs.addCachePool(coolPool.setMaxRelativeExpiryMs(poolExpiration));
  RemoteIterator<CachePoolEntry> poolIt=dfs.listCachePools();
  CachePoolInfo listPool=poolIt.next().getInfo();
  assertFalse("Should only be one pool",poolIt.hasNext());
  assertEquals("Expected max relative expiry to match set value",poolExpiration,listPool.getMaxRelativeExpiryMs().longValue());
  try {
    dfs.addCachePool(coolPool.setMaxRelativeExpiryMs(-1l));
    fail("Added a pool with a negative max expiry.");
  }
 catch (  InvalidRequestException e) {
    assertExceptionContains("negative",e);
  }
  try {
    dfs.modifyCachePool(coolPool.setMaxRelativeExpiryMs(CachePoolInfo.RELATIVE_EXPIRY_NEVER + 1));
    fail("Added a pool with too big of a max expiry.");
  }
 catch (  InvalidRequestException e) {
    assertExceptionContains("too big",e);
  }
  CacheDirectiveInfo defaultExpiry=new CacheDirectiveInfo.Builder().setPath(new Path("/blah")).setPool(coolPool.getPoolName()).build();
  dfs.addCacheDirective(defaultExpiry);
  RemoteIterator<CacheDirectiveEntry> dirIt=dfs.listCacheDirectives(defaultExpiry);
  CacheDirectiveInfo listInfo=dirIt.next().getInfo();
  assertFalse("Should only have one entry in listing",dirIt.hasNext());
  long listExpiration=listInfo.getExpiration().getAbsoluteMillis() - new Date().getTime();
  assertTrue("Directive expiry should be approximately the pool's max expiry",Math.abs(listExpiration - poolExpiration) < 10 * 1000);
  CacheDirectiveInfo.Builder builder=new CacheDirectiveInfo.Builder().setPath(new Path("/lolcat")).setPool(coolPool.getPoolName());
  try {
    dfs.addCacheDirective(builder.setExpiration(Expiration.newRelative(poolExpiration + 1)).build());
    fail("Added a directive that exceeds pool's max relative expiration");
  }
 catch (  InvalidRequestException e) {
    assertExceptionContains("exceeds the max relative expiration",e);
  }
  try {
    dfs.addCacheDirective(builder.setExpiration(Expiration.newAbsolute(new Date().getTime() + poolExpiration + (10 * 1000))).build());
    fail("Added a directive that exceeds pool's max relative expiration");
  }
 catch (  InvalidRequestException e) {
    assertExceptionContains("exceeds the max relative expiration",e);
  }
  try {
    dfs.modifyCacheDirective(new CacheDirectiveInfo.Builder(defaultExpiry).setId(listInfo.getId()).setExpiration(Expiration.newRelative(poolExpiration + 1)).build());
    fail("Modified a directive to exceed pool's max relative expiration");
  }
 catch (  InvalidRequestException e) {
    assertExceptionContains("exceeds the max relative expiration",e);
  }
  try {
    dfs.modifyCacheDirective(new CacheDirectiveInfo.Builder(defaultExpiry).setId(listInfo.getId()).setExpiration(Expiration.newAbsolute(new Date().getTime() + poolExpiration + (10 * 1000))).build());
    fail("Modified a directive to exceed pool's max relative expiration");
  }
 catch (  InvalidRequestException e) {
    assertExceptionContains("exceeds the max relative expiration",e);
  }
  try {
    dfs.addCacheDirective(builder.setExpiration(Expiration.newRelative(Long.MAX_VALUE)).build());
    fail("Added a directive with a gigantic max value");
  }
 catch (  IllegalArgumentException e) {
    assertExceptionContains("is too far in the future",e);
  }
  try {
    dfs.addCacheDirective(builder.setExpiration(Expiration.newAbsolute(Long.MAX_VALUE)).build());
    fail("Added a directive with a gigantic max value");
  }
 catch (  InvalidRequestException e) {
    assertExceptionContains("is too far in the future",e);
  }
  try {
    dfs.modifyCacheDirective(new CacheDirectiveInfo.Builder(defaultExpiry).setId(listInfo.getId()).setExpiration(Expiration.NEVER).build());
    fail("Modified a directive to exceed pool's max relative expiration");
  }
 catch (  InvalidRequestException e) {
    assertExceptionContains("exceeds the max relative expiration",e);
  }
  try {
    dfs.modifyCacheDirective(new CacheDirectiveInfo.Builder(defaultExpiry).setId(listInfo.getId()).setExpiration(Expiration.newAbsolute(Long.MAX_VALUE)).build());
    fail("Modified a directive to exceed pool's max relative expiration");
  }
 catch (  InvalidRequestException e) {
    assertExceptionContains("is too far in the future",e);
  }
  CachePoolInfo destPool=new CachePoolInfo("destPool");
  dfs.addCachePool(destPool.setMaxRelativeExpiryMs(poolExpiration / 2));
  try {
    dfs.modifyCacheDirective(new CacheDirectiveInfo.Builder(defaultExpiry).setId(listInfo.getId()).setPool(destPool.getPoolName()).build());
    fail("Modified a directive to a pool with a lower max expiration");
  }
 catch (  InvalidRequestException e) {
    assertExceptionContains("exceeds the max relative expiration",e);
  }
  dfs.modifyCacheDirective(new CacheDirectiveInfo.Builder(defaultExpiry).setId(listInfo.getId()).setPool(destPool.getPoolName()).setExpiration(Expiration.newRelative(poolExpiration / 2)).build());
  dirIt=dfs.listCacheDirectives(new CacheDirectiveInfo.Builder().setPool(destPool.getPoolName()).build());
  listInfo=dirIt.next().getInfo();
  listExpiration=listInfo.getExpiration().getAbsoluteMillis() - new Date().getTime();
  assertTrue("Unexpected relative expiry " + listExpiration + " expected approximately "+ poolExpiration / 2,Math.abs(poolExpiration / 2 - listExpiration) < 10 * 1000);
  dfs.modifyCachePool(destPool.setMaxRelativeExpiryMs(CachePoolInfo.RELATIVE_EXPIRY_NEVER));
  poolIt=dfs.listCachePools();
  listPool=poolIt.next().getInfo();
  while (!listPool.getPoolName().equals(destPool.getPoolName())) {
    listPool=poolIt.next().getInfo();
  }
  assertEquals("Expected max relative expiry to match set value",CachePoolInfo.RELATIVE_EXPIRY_NEVER,listPool.getMaxRelativeExpiryMs().longValue());
  dfs.modifyCacheDirective(new CacheDirectiveInfo.Builder().setId(listInfo.getId()).setExpiration(Expiration.newRelative(RELATIVE_EXPIRY_NEVER)).build());
  dfs.modifyCacheDirective(new CacheDirectiveInfo.Builder().setId(listInfo.getId()).setExpiration(Expiration.newRelative(RELATIVE_EXPIRY_NEVER - 1)).build());
}

</code></pre>

<br>
<pre class="type-2 type-7 type-10 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=120000) public void testLimit() throws Exception {
  try {
    dfs.addCachePool(new CachePoolInfo("poolofnegativity").setLimit(-99l));
    fail("Should not be able to set a negative limit");
  }
 catch (  InvalidRequestException e) {
    GenericTestUtils.assertExceptionContains("negative",e);
  }
  final String destiny="poolofdestiny";
  final Path path1=new Path("/destiny");
  DFSTestUtil.createFile(dfs,path1,2 * BLOCK_SIZE,(short)1,0x9494);
  final CachePoolInfo poolInfo=new CachePoolInfo(destiny).setLimit(2 * BLOCK_SIZE - 1);
  dfs.addCachePool(poolInfo);
  final CacheDirectiveInfo info1=new CacheDirectiveInfo.Builder().setPool(destiny).setPath(path1).build();
  try {
    dfs.addCacheDirective(info1);
    fail("Should not be able to cache when there is no more limit");
  }
 catch (  InvalidRequestException e) {
    GenericTestUtils.assertExceptionContains("remaining capacity",e);
  }
  poolInfo.setLimit(2 * BLOCK_SIZE);
  dfs.modifyCachePool(poolInfo);
  long id1=dfs.addCacheDirective(info1);
  waitForCachePoolStats(dfs,2 * BLOCK_SIZE,2 * BLOCK_SIZE,1,1,poolInfo,"testLimit:1");
  final Path path2=new Path("/failure");
  DFSTestUtil.createFile(dfs,path2,BLOCK_SIZE,(short)1,0x9495);
  try {
    dfs.addCacheDirective(new CacheDirectiveInfo.Builder().setPool(destiny).setPath(path2).build(),EnumSet.noneOf(CacheFlag.class));
    fail("Should not be able to add another cached file");
  }
 catch (  InvalidRequestException e) {
    GenericTestUtils.assertExceptionContains("remaining capacity",e);
  }
  poolInfo.setLimit(BLOCK_SIZE);
  dfs.modifyCachePool(poolInfo);
  waitForCachePoolStats(dfs,2 * BLOCK_SIZE,0,1,0,poolInfo,"testLimit:2");
  RemoteIterator<CachePoolEntry> it=dfs.listCachePools();
  assertTrue("Expected a cache pool",it.hasNext());
  CachePoolStats stats=it.next().getStats();
  assertEquals("Overlimit bytes should be difference of needed and limit",BLOCK_SIZE,stats.getBytesOverlimit());
  CachePoolInfo inadequate=new CachePoolInfo("poolofinadequacy").setLimit(BLOCK_SIZE);
  dfs.addCachePool(inadequate);
  try {
    dfs.modifyCacheDirective(new CacheDirectiveInfo.Builder(info1).setId(id1).setPool(inadequate.getPoolName()).build(),EnumSet.noneOf(CacheFlag.class));
  }
 catch (  InvalidRequestException e) {
    GenericTestUtils.assertExceptionContains("remaining capacity",e);
  }
  dfs.modifyCacheDirective(new CacheDirectiveInfo.Builder(info1).setId(id1).setPool(inadequate.getPoolName()).build(),EnumSet.of(CacheFlag.FORCE));
  dfs.addCacheDirective(new CacheDirectiveInfo.Builder().setPool(inadequate.getPoolName()).setPath(path1).build(),EnumSet.of(CacheFlag.FORCE));
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test(timeout=60000) public void testBasicPoolOperations() throws Exception {
  final String poolName="pool1";
  CachePoolInfo info=new CachePoolInfo(poolName).setOwnerName("bob").setGroupName("bobgroup").setMode(new FsPermission((short)0755)).setLimit(150l);
  dfs.addCachePool(info);
  try {
    dfs.addCachePool(info);
    fail("added the pool with the same name twice");
  }
 catch (  IOException ioe) {
    GenericTestUtils.assertExceptionContains("pool1 already exists",ioe);
  }
  try {
    dfs.addCachePool(new CachePoolInfo(""));
    fail("added empty pool");
  }
 catch (  IOException ioe) {
    GenericTestUtils.assertExceptionContains("invalid empty cache pool name",ioe);
  }
  try {
    dfs.addCachePool(null);
    fail("added null pool");
  }
 catch (  IOException ioe) {
    GenericTestUtils.assertExceptionContains("CachePoolInfo is null",ioe);
  }
  try {
    proto.addCachePool(new CachePoolInfo(""));
    fail("added empty pool");
  }
 catch (  IOException ioe) {
    GenericTestUtils.assertExceptionContains("invalid empty cache pool name",ioe);
  }
  try {
    proto.addCachePool(null);
    fail("added null pool");
  }
 catch (  IOException ioe) {
    GenericTestUtils.assertExceptionContains("CachePoolInfo is null",ioe);
  }
  info.setOwnerName("jane").setGroupName("janegroup").setMode(new FsPermission((short)0700)).setLimit(314l);
  dfs.modifyCachePool(info);
  try {
    dfs.modifyCachePool(new CachePoolInfo("fool"));
    fail("modified non-existent cache pool");
  }
 catch (  IOException ioe) {
    GenericTestUtils.assertExceptionContains("fool does not exist",ioe);
  }
  try {
    dfs.modifyCachePool(new CachePoolInfo(""));
    fail("modified empty pool");
  }
 catch (  IOException ioe) {
    GenericTestUtils.assertExceptionContains("invalid empty cache pool name",ioe);
  }
  try {
    dfs.modifyCachePool(null);
    fail("modified null pool");
  }
 catch (  IOException ioe) {
    GenericTestUtils.assertExceptionContains("CachePoolInfo is null",ioe);
  }
  try {
    proto.modifyCachePool(new CachePoolInfo(""));
    fail("modified empty pool");
  }
 catch (  IOException ioe) {
    GenericTestUtils.assertExceptionContains("invalid empty cache pool name",ioe);
  }
  try {
    proto.modifyCachePool(null);
    fail("modified null pool");
  }
 catch (  IOException ioe) {
    GenericTestUtils.assertExceptionContains("CachePoolInfo is null",ioe);
  }
  dfs.removeCachePool(poolName);
  try {
    dfs.removeCachePool("pool99");
    fail("expected to get an exception when " + "removing a non-existent pool.");
  }
 catch (  IOException ioe) {
    GenericTestUtils.assertExceptionContains("Cannot remove " + "non-existent cache pool",ioe);
  }
  try {
    dfs.removeCachePool(poolName);
    fail("expected to get an exception when " + "removing a non-existent pool.");
  }
 catch (  IOException ioe) {
    GenericTestUtils.assertExceptionContains("Cannot remove " + "non-existent cache pool",ioe);
  }
  try {
    dfs.removeCachePool("");
    fail("removed empty pool");
  }
 catch (  IOException ioe) {
    GenericTestUtils.assertExceptionContains("invalid empty cache pool name",ioe);
  }
  try {
    dfs.removeCachePool(null);
    fail("removed null pool");
  }
 catch (  IOException ioe) {
    GenericTestUtils.assertExceptionContains("invalid empty cache pool name",ioe);
  }
  try {
    proto.removeCachePool("");
    fail("removed empty pool");
  }
 catch (  IOException ioe) {
    GenericTestUtils.assertExceptionContains("invalid empty cache pool name",ioe);
  }
  try {
    proto.removeCachePool(null);
    fail("removed null pool");
  }
 catch (  IOException ioe) {
    GenericTestUtils.assertExceptionContains("invalid empty cache pool name",ioe);
  }
  info=new CachePoolInfo("pool2");
  dfs.addCachePool(info);
}

</code></pre>

<br>
<pre class="type-9 type-2 type-7 type-10 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testAddRemoveDirectives() throws Exception {
  proto.addCachePool(new CachePoolInfo("pool1").setMode(new FsPermission((short)0777)));
  proto.addCachePool(new CachePoolInfo("pool2").setMode(new FsPermission((short)0777)));
  proto.addCachePool(new CachePoolInfo("pool3").setMode(new FsPermission((short)0777)));
  proto.addCachePool(new CachePoolInfo("pool4").setMode(new FsPermission((short)0)));
  CacheDirectiveInfo alpha=new CacheDirectiveInfo.Builder().setPath(new Path("/alpha")).setPool("pool1").build();
  CacheDirectiveInfo beta=new CacheDirectiveInfo.Builder().setPath(new Path("/beta")).setPool("pool2").build();
  CacheDirectiveInfo delta=new CacheDirectiveInfo.Builder().setPath(new Path("/delta")).setPool("pool1").build();
  long alphaId=addAsUnprivileged(alpha);
  long alphaId2=addAsUnprivileged(alpha);
  assertFalse("Expected to get unique directives when re-adding an " + "existing CacheDirectiveInfo",alphaId == alphaId2);
  long betaId=addAsUnprivileged(beta);
  try {
    addAsUnprivileged(new CacheDirectiveInfo.Builder().setPath(new Path("/unicorn")).setPool("no_such_pool").build());
    fail("expected an error when adding to a non-existent pool.");
  }
 catch (  InvalidRequestException ioe) {
    GenericTestUtils.assertExceptionContains("Unknown pool",ioe);
  }
  try {
    addAsUnprivileged(new CacheDirectiveInfo.Builder().setPath(new Path("/blackhole")).setPool("pool4").build());
    fail("expected an error when adding to a pool with " + "mode 0 (no permissions for anyone).");
  }
 catch (  AccessControlException e) {
    GenericTestUtils.assertExceptionContains("Permission denied while accessing pool",e);
  }
  try {
    addAsUnprivileged(new CacheDirectiveInfo.Builder().setPath(new Path("/illegal:path/")).setPool("pool1").build());
    fail("expected an error when adding a malformed path " + "to the cache directives.");
  }
 catch (  IllegalArgumentException e) {
    GenericTestUtils.assertExceptionContains("is not a valid DFS filename",e);
  }
  try {
    addAsUnprivileged(new CacheDirectiveInfo.Builder().setPath(new Path("/emptypoolname")).setReplication((short)1).setPool("").build());
    fail("expected an error when adding a cache " + "directive with an empty pool name.");
  }
 catch (  InvalidRequestException e) {
    GenericTestUtils.assertExceptionContains("Invalid empty pool name",e);
  }
  long deltaId=addAsUnprivileged(delta);
  long relativeId=addAsUnprivileged(new CacheDirectiveInfo.Builder().setPath(new Path("relative")).setPool("pool1").build());
  RemoteIterator<CacheDirectiveEntry> iter;
  iter=dfs.listCacheDirectives(null);
  validateListAll(iter,alphaId,alphaId2,betaId,deltaId,relativeId);
  iter=dfs.listCacheDirectives(new CacheDirectiveInfo.Builder().setPool("pool3").build());
  assertFalse(iter.hasNext());
  iter=dfs.listCacheDirectives(new CacheDirectiveInfo.Builder().setPool("pool1").build());
  validateListAll(iter,alphaId,alphaId2,deltaId,relativeId);
  iter=dfs.listCacheDirectives(new CacheDirectiveInfo.Builder().setPool("pool2").build());
  validateListAll(iter,betaId);
  iter=dfs.listCacheDirectives(new CacheDirectiveInfo.Builder().setId(alphaId2).build());
  validateListAll(iter,alphaId2);
  iter=dfs.listCacheDirectives(new CacheDirectiveInfo.Builder().setId(relativeId).build());
  validateListAll(iter,relativeId);
  dfs.removeCacheDirective(betaId);
  iter=dfs.listCacheDirectives(new CacheDirectiveInfo.Builder().setPool("pool2").build());
  assertFalse(iter.hasNext());
  try {
    dfs.removeCacheDirective(betaId);
    fail("expected an error when removing a non-existent ID");
  }
 catch (  InvalidRequestException e) {
    GenericTestUtils.assertExceptionContains("No directive with ID",e);
  }
  try {
    proto.removeCacheDirective(-42l);
    fail("expected an error when removing a negative ID");
  }
 catch (  InvalidRequestException e) {
    GenericTestUtils.assertExceptionContains("Invalid negative ID",e);
  }
  try {
    proto.removeCacheDirective(43l);
    fail("expected an error when removing a non-existent ID");
  }
 catch (  InvalidRequestException e) {
    GenericTestUtils.assertExceptionContains("No directive with ID",e);
  }
  dfs.removeCacheDirective(alphaId);
  dfs.removeCacheDirective(alphaId2);
  dfs.removeCacheDirective(deltaId);
  dfs.modifyCacheDirective(new CacheDirectiveInfo.Builder().setId(relativeId).setReplication((short)555).build());
  iter=dfs.listCacheDirectives(null);
  assertTrue(iter.hasNext());
  CacheDirectiveInfo modified=iter.next().getInfo();
  assertEquals(relativeId,modified.getId().longValue());
  assertEquals((short)555,modified.getReplication().shortValue());
  dfs.removeCacheDirective(relativeId);
  iter=dfs.listCacheDirectives(null);
  assertFalse(iter.hasNext());
  CacheDirectiveInfo directive=new CacheDirectiveInfo.Builder().setPath(new Path(".")).setPool("pool1").build();
  long id=dfs.addCacheDirective(directive);
  dfs.modifyCacheDirective(new CacheDirectiveInfo.Builder(directive).setId(id).setReplication((short)2).build());
  dfs.removeCacheDirective(id);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.server.namenode.TestCheckPointForSecurityTokens </h4><pre class="type-9 type-2 type-7 type-10 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Tests save namespace.
 */
@Test public void testSaveNamespace() throws IOException {
  DistributedFileSystem fs=null;
  try {
    Configuration conf=new HdfsConfiguration();
    conf.setBoolean(DFSConfigKeys.DFS_NAMENODE_DELEGATION_TOKEN_ALWAYS_USE_KEY,true);
    cluster=new MiniDFSCluster.Builder(conf).numDataNodes(numDatanodes).build();
    cluster.waitActive();
    fs=cluster.getFileSystem();
    FSNamesystem namesystem=cluster.getNamesystem();
    String renewer=UserGroupInformation.getLoginUser().getUserName();
    Token<DelegationTokenIdentifier> token1=namesystem.getDelegationToken(new Text(renewer));
    Token<DelegationTokenIdentifier> token2=namesystem.getDelegationToken(new Text(renewer));
    DFSAdmin admin=new DFSAdmin(conf);
    String[] args=new String[]{"-saveNamespace"};
    NameNode nn=cluster.getNameNode();
    for (    StorageDirectory sd : nn.getFSImage().getStorage().dirIterable(null)) {
      EditLogFile log=FSImageTestUtil.findLatestEditsLog(sd);
      assertTrue(log.isInProgress());
      log.validateLog();
      long numTransactions=(log.getLastTxId() - log.getFirstTxId()) + 1;
      assertEquals("In-progress log " + log + " should have 5 transactions",5,numTransactions);
      ;
    }
    fs.setSafeMode(SafeModeAction.SAFEMODE_ENTER);
    try {
      admin.run(args);
    }
 catch (    Exception e) {
      throw new IOException(e.getMessage());
    }
    for (    StorageDirectory sd : nn.getFSImage().getStorage().dirIterable(null)) {
      EditLogFile log=FSImageTestUtil.findLatestEditsLog(sd);
      assertTrue(log.isInProgress());
      log.validateLog();
      long numTransactions=(log.getLastTxId() - log.getFirstTxId()) + 1;
      assertEquals("In-progress log " + log + " should only have START txn",1,numTransactions);
    }
    cluster.shutdown();
    cluster=null;
    cluster=new MiniDFSCluster.Builder(conf).numDataNodes(numDatanodes).format(false).build();
    cluster.waitActive();
    try {
      renewToken(token1);
      renewToken(token2);
    }
 catch (    IOException e) {
      fail("Could not renew or cancel the token");
    }
    namesystem=cluster.getNamesystem();
    Token<DelegationTokenIdentifier> token3=namesystem.getDelegationToken(new Text(renewer));
    Token<DelegationTokenIdentifier> token4=namesystem.getDelegationToken(new Text(renewer));
    cluster.shutdown();
    cluster=null;
    cluster=new MiniDFSCluster.Builder(conf).numDataNodes(numDatanodes).format(false).build();
    cluster.waitActive();
    namesystem=cluster.getNamesystem();
    Token<DelegationTokenIdentifier> token5=namesystem.getDelegationToken(new Text(renewer));
    try {
      renewToken(token1);
      renewToken(token2);
      renewToken(token3);
      renewToken(token4);
      renewToken(token5);
    }
 catch (    IOException e) {
      fail("Could not renew or cancel the token");
    }
    cluster.shutdown();
    cluster=null;
    cluster=new MiniDFSCluster.Builder(conf).numDataNodes(numDatanodes).format(false).build();
    cluster.waitActive();
    namesystem=cluster.getNamesystem();
    try {
      renewToken(token1);
      cancelToken(token1);
      renewToken(token2);
      cancelToken(token2);
      renewToken(token3);
      cancelToken(token3);
      renewToken(token4);
      cancelToken(token4);
      renewToken(token5);
      cancelToken(token5);
    }
 catch (    IOException e) {
      fail("Could not renew or cancel the token");
    }
  }
  finally {
    if (fs != null)     fs.close();
    if (cluster != null)     cluster.shutdown();
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.server.namenode.TestCheckpoint </h4><pre class="type-2 type-7 type-10 type-1 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects are null
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testCommandLineParsing() throws ParseException {
  SecondaryNameNode.CommandLineOpts opts=new SecondaryNameNode.CommandLineOpts();
  opts.parse();
  assertNull(opts.getCommand());
  opts.parse("-checkpoint");
  assertEquals(SecondaryNameNode.CommandLineOpts.Command.CHECKPOINT,opts.getCommand());
  assertFalse(opts.shouldForceCheckpoint());
  opts.parse("-checkpoint","force");
  assertEquals(SecondaryNameNode.CommandLineOpts.Command.CHECKPOINT,opts.getCommand());
  assertTrue(opts.shouldForceCheckpoint());
  opts.parse("-geteditsize");
  assertEquals(SecondaryNameNode.CommandLineOpts.Command.GETEDITSIZE,opts.getCommand());
  opts.parse("-format");
  assertTrue(opts.shouldFormat());
  try {
    opts.parse("-geteditsize","-checkpoint");
    fail("Should have failed bad parsing for two actions");
  }
 catch (  ParseException e) {
    LOG.warn("Encountered ",e);
  }
  try {
    opts.parse("-checkpoint","xx");
    fail("Should have failed for bad checkpoint arg");
  }
 catch (  ParseException e) {
    LOG.warn("Encountered ",e);
  }
}

</code></pre>

<br>
<pre class="type-9 type-2 type-7 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=30000) public void testReloadOnEditReplayFailure() throws IOException {
  Configuration conf=new HdfsConfiguration();
  FSDataOutputStream fos=null;
  SecondaryNameNode secondary=null;
  MiniDFSCluster cluster=null;
  FileSystem fs=null;
  try {
    cluster=new MiniDFSCluster.Builder(conf).numDataNodes(numDatanodes).build();
    cluster.waitActive();
    fs=cluster.getFileSystem();
    secondary=startSecondaryNameNode(conf);
    fos=fs.create(new Path("tmpfile0"));
    fos.write(new byte[]{0,1,2,3});
    secondary.doCheckpoint();
    fos.write(new byte[]{0,1,2,3});
    fos.hsync();
    Mockito.doThrow(new IOException("Injecting failure during merge")).when(faultInjector).duringMerge();
    try {
      secondary.doCheckpoint();
      fail("Fault injection failed.");
    }
 catch (    IOException ioe) {
    }
    Mockito.reset(faultInjector);
    fos.write(new byte[]{0,1,2,3});
    fos.hsync();
    assertTrue("Another checkpoint should have reloaded image",secondary.doCheckpoint());
  }
  finally {
    if (fs != null) {
      fs.close();
    }
    cleanup(secondary);
    secondary=null;
    cleanup(cluster);
    cluster=null;
    Mockito.reset(faultInjector);
  }
}

</code></pre>

<br>
<pre class="type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test the importCheckpoint startup option. Verifies:
 * 1. if the NN already contains an image, it will not be allowed
 * to import a checkpoint.
 * 2. if the NN does not contain an image, importing a checkpoint
 * succeeds and re-saves the image
 */
@Test public void testImportCheckpoint() throws Exception {
  Configuration conf=new HdfsConfiguration();
  Path testPath=new Path("/testfile");
  SecondaryNameNode snn=null;
  MiniDFSCluster cluster=null;
  Collection<URI> nameDirs=null;
  try {
    cluster=new MiniDFSCluster.Builder(conf).numDataNodes(0).build();
    nameDirs=cluster.getNameDirs(0);
    cluster.getFileSystem().mkdirs(testPath);
    snn=startSecondaryNameNode(conf);
    snn.doCheckpoint();
  }
  finally {
    cleanup(snn);
    cleanup(cluster);
    cluster=null;
  }
  LOG.info("Trying to import checkpoint when the NameNode already " + "contains an image. This should fail.");
  try {
    cluster=new MiniDFSCluster.Builder(conf).numDataNodes(0).format(false).startupOption(StartupOption.IMPORT).build();
    fail("NameNode did not fail to start when it already contained " + "an image");
  }
 catch (  IOException ioe) {
    GenericTestUtils.assertExceptionContains("NameNode already contains an image",ioe);
  }
 finally {
    cleanup(cluster);
    cluster=null;
  }
  LOG.info("Removing NN storage contents");
  for (  URI uri : nameDirs) {
    File dir=new File(uri.getPath());
    LOG.info("Cleaning " + dir);
    removeAndRecreateDir(dir);
  }
  LOG.info("Trying to import checkpoint");
  try {
    cluster=new MiniDFSCluster.Builder(conf).format(false).numDataNodes(0).startupOption(StartupOption.IMPORT).build();
    assertTrue("Path from checkpoint should exist after import",cluster.getFileSystem().exists(testPath));
    FSImageTestUtil.assertNNHasCheckpoints(cluster,Ints.asList(3));
  }
  finally {
    cleanup(cluster);
    cluster=null;
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test case where the NN is configured with a name-only and an edits-only
 * dir, with storage-restore turned on. In this case, if the name-only dir
 * disappears and comes back, a new checkpoint after it has been restored
 * should function correctly.
 * @throws Exception
 */
@Test public void testCheckpointWithSeparateDirsAfterNameFails() throws Exception {
  MiniDFSCluster cluster=null;
  SecondaryNameNode secondary=null;
  File currentDir=null;
  Configuration conf=new HdfsConfiguration();
  File base_dir=new File(MiniDFSCluster.getBaseDirectory());
  conf.setBoolean(DFSConfigKeys.DFS_NAMENODE_NAME_DIR_RESTORE_KEY,true);
  conf.set(DFSConfigKeys.DFS_NAMENODE_NAME_DIR_KEY,MiniDFSCluster.getBaseDirectory() + "/name-only");
  conf.set(DFSConfigKeys.DFS_NAMENODE_EDITS_DIR_KEY,MiniDFSCluster.getBaseDirectory() + "/edits-only");
  conf.set(DFSConfigKeys.DFS_NAMENODE_CHECKPOINT_DIR_KEY,fileAsURI(new File(base_dir,"namesecondary1")).toString());
  try {
    cluster=new MiniDFSCluster.Builder(conf).numDataNodes(0).format(true).manageNameDfsDirs(false).build();
    secondary=startSecondaryNameNode(conf);
    secondary.doCheckpoint();
    NamenodeProtocols nn=cluster.getNameNodeRpc();
    NNStorage storage=cluster.getNameNode().getFSImage().getStorage();
    StorageDirectory sd0=storage.getStorageDir(0);
    assertEquals(NameNodeDirType.IMAGE,sd0.getStorageDirType());
    currentDir=sd0.getCurrentDir();
    assertEquals(0,FileUtil.chmod(currentDir.getAbsolutePath(),"000"));
    try {
      secondary.doCheckpoint();
      fail("Did not fail to checkpoint when there are no valid storage dirs");
    }
 catch (    IOException ioe) {
      GenericTestUtils.assertExceptionContains("No targets in destination storage",ioe);
    }
    assertEquals(0,FileUtil.chmod(currentDir.getAbsolutePath(),"755"));
    nn.restoreFailedStorage("true");
    nn.rollEditLog();
    secondary.doCheckpoint();
    assertNNHasCheckpoints(cluster,ImmutableList.of(8));
    assertParallelFilesInvariant(cluster,ImmutableList.of(secondary));
  }
  finally {
    if (currentDir != null) {
      FileUtil.chmod(currentDir.getAbsolutePath(),"755");
    }
    cleanup(secondary);
    secondary=null;
    cleanup(cluster);
    cluster=null;
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * Test that a fault while downloading edits the first time after the 2NN
 * starts up does not prevent future checkpointing.
 */
@Test(timeout=30000) public void testEditFailureOnFirstCheckpoint() throws IOException {
  Configuration conf=new HdfsConfiguration();
  SecondaryNameNode secondary=null;
  MiniDFSCluster cluster=null;
  FileSystem fs=null;
  try {
    cluster=new MiniDFSCluster.Builder(conf).numDataNodes(numDatanodes).build();
    cluster.waitActive();
    fs=cluster.getFileSystem();
    fs.mkdirs(new Path("test-file-1"));
    FSNamesystem fsns=cluster.getNamesystem();
    fsns.enterSafeMode(false);
    fsns.saveNamespace();
    fsns.leaveSafeMode();
    secondary=startSecondaryNameNode(conf);
    Mockito.doThrow(new IOException("Injecting failure before edit rename")).when(faultInjector).beforeEditsRename();
    try {
      secondary.doCheckpoint();
      fail("Fault injection failed.");
    }
 catch (    IOException ioe) {
      GenericTestUtils.assertExceptionContains("Injecting failure before edit rename",ioe);
    }
    Mockito.reset(faultInjector);
    secondary.doCheckpoint();
  }
  finally {
    if (secondary != null) {
      secondary.shutdown();
    }
    if (fs != null) {
      fs.close();
    }
    if (cluster != null) {
      cluster.shutdown();
    }
    Mockito.reset(faultInjector);
  }
}

</code></pre>

<br>
<pre class="type-9 type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testNameDirError() throws IOException {
  LOG.info("Starting testNameDirError");
  Configuration conf=new HdfsConfiguration();
  MiniDFSCluster cluster=new MiniDFSCluster.Builder(conf).numDataNodes(0).build();
  Collection<URI> nameDirs=cluster.getNameDirs(0);
  cluster.shutdown();
  cluster=null;
  for (  URI nameDirUri : nameDirs) {
    File dir=new File(nameDirUri.getPath());
    try {
      FileUtil.setWritable(dir,false);
      cluster=new MiniDFSCluster.Builder(conf).numDataNodes(0).format(false).build();
      fail("NN should have failed to start with " + dir + " set unreadable");
    }
 catch (    IOException ioe) {
      GenericTestUtils.assertExceptionContains("storage directory does not exist or is not accessible",ioe);
    }
 finally {
      cleanup(cluster);
      cluster=null;
      FileUtil.setWritable(dir,true);
    }
  }
}

</code></pre>

<br>
<pre class="type-9 type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=30000) public void testTooManyEditReplayFailures() throws IOException {
  Configuration conf=new HdfsConfiguration();
  conf.set(DFSConfigKeys.DFS_NAMENODE_CHECKPOINT_MAX_RETRIES_KEY,"1");
  conf.set(DFSConfigKeys.DFS_NAMENODE_CHECKPOINT_CHECK_PERIOD_KEY,"1");
  FSDataOutputStream fos=null;
  SecondaryNameNode secondary=null;
  MiniDFSCluster cluster=null;
  FileSystem fs=null;
  try {
    cluster=new MiniDFSCluster.Builder(conf).numDataNodes(numDatanodes).checkExitOnShutdown(false).build();
    cluster.waitActive();
    fs=cluster.getFileSystem();
    fos=fs.create(new Path("tmpfile0"));
    fos.write(new byte[]{0,1,2,3});
    Mockito.doThrow(new IOException("Injecting failure during merge")).when(faultInjector).duringMerge();
    secondary=startSecondaryNameNode(conf);
    secondary.doWork();
    fail("2NN did not exit.");
  }
 catch (  ExitException ee) {
    ExitUtil.resetFirstExitException();
    assertEquals("Max retries",1,secondary.getMergeErrorCount() - 1);
  }
 finally {
    if (fs != null) {
      fs.close();
    }
    cleanup(secondary);
    secondary=null;
    cleanup(cluster);
    cluster=null;
    Mockito.reset(faultInjector);
  }
}

</code></pre>

<br>
<pre class="type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Tests the following sequence of events:
 * - secondary successfully makes a checkpoint
 * - it then fails while trying to upload it
 * - it then fails again for the same reason
 * - it then tries to checkpoint a third time
 */
@Test public void testCheckpointAfterTwoFailedUploads() throws IOException {
  MiniDFSCluster cluster=null;
  SecondaryNameNode secondary=null;
  Configuration conf=new HdfsConfiguration();
  try {
    cluster=new MiniDFSCluster.Builder(conf).numDataNodes(numDatanodes).format(true).build();
    secondary=startSecondaryNameNode(conf);
    Mockito.doThrow(new IOException("Injecting failure after rolling edit logs")).when(faultInjector).afterSecondaryCallsRollEditLog();
    try {
      secondary.doCheckpoint();
      fail("Should have failed upload");
    }
 catch (    IOException ioe) {
      LOG.info("Got expected failure",ioe);
      assertTrue(ioe.toString().contains("Injecting failure"));
    }
    try {
      secondary.doCheckpoint();
      fail("Should have failed upload");
    }
 catch (    IOException ioe) {
      LOG.info("Got expected failure",ioe);
      assertTrue(ioe.toString().contains("Injecting failure"));
    }
 finally {
      Mockito.reset(faultInjector);
    }
    secondary.doCheckpoint();
  }
  finally {
    cleanup(secondary);
    secondary=null;
    cleanup(cluster);
    cluster=null;
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * Test NN restart if a failure happens in between creating the fsimage
 * MD5 file and renaming the fsimage.
 */
@Test(timeout=30000) public void testFailureBeforeRename() throws IOException {
  Configuration conf=new HdfsConfiguration();
  FSDataOutputStream fos=null;
  SecondaryNameNode secondary=null;
  MiniDFSCluster cluster=null;
  FileSystem fs=null;
  try {
    cluster=new MiniDFSCluster.Builder(conf).numDataNodes(numDatanodes).build();
    cluster.waitActive();
    fs=cluster.getFileSystem();
    secondary=startSecondaryNameNode(conf);
    fos=fs.create(new Path("tmpfile0"));
    fos.write(new byte[]{0,1,2,3});
    secondary.doCheckpoint();
    fos.write(new byte[]{0,1,2,3});
    fos.hsync();
    Mockito.doThrow(new IOException("Injecting failure after MD5Rename")).when(faultInjector).afterMD5Rename();
    try {
      secondary.doCheckpoint();
      fail("Fault injection failed.");
    }
 catch (    IOException ioe) {
    }
    Mockito.reset(faultInjector);
    cluster.restartNameNode();
  }
  finally {
    if (fs != null) {
      fs.close();
    }
    cleanup(secondary);
    secondary=null;
    cleanup(cluster);
    cluster=null;
    Mockito.reset(faultInjector);
  }
}

</code></pre>

<br>
<pre class="type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test case where the name node is reformatted while the secondary namenode
 * is running. The secondary should shut itself down if if talks to a NN
 * with the wrong namespace.
 */
@Test public void testReformatNNBetweenCheckpoints() throws IOException {
  MiniDFSCluster cluster=null;
  SecondaryNameNode secondary=null;
  Configuration conf=new HdfsConfiguration();
  conf.setInt(CommonConfigurationKeysPublic.IPC_CLIENT_CONNECTION_MAXIDLETIME_KEY,1);
  try {
    cluster=new MiniDFSCluster.Builder(conf).numDataNodes(0).format(true).build();
    int origPort=cluster.getNameNodePort();
    int origHttpPort=cluster.getNameNode().getHttpAddress().getPort();
    Configuration snnConf=new Configuration(conf);
    File checkpointDir=new File(MiniDFSCluster.getBaseDirectory(),"namesecondary");
    snnConf.set(DFSConfigKeys.DFS_NAMENODE_CHECKPOINT_DIR_KEY,checkpointDir.getAbsolutePath());
    secondary=startSecondaryNameNode(snnConf);
    secondary.doCheckpoint();
    cluster.shutdown();
    cluster=null;
    try {
      Thread.sleep(100);
    }
 catch (    InterruptedException ie) {
    }
    cluster=new MiniDFSCluster.Builder(conf).numDataNodes(0).nameNodePort(origPort).nameNodeHttpPort(origHttpPort).format(true).build();
    try {
      secondary.doCheckpoint();
      fail("Should have failed checkpoint against a different namespace");
    }
 catch (    IOException ioe) {
      LOG.info("Got expected failure",ioe);
      assertTrue(ioe.toString().contains("Inconsistent checkpoint"));
    }
  }
  finally {
    cleanup(secondary);
    secondary=null;
    cleanup(cluster);
    cluster=null;
  }
}

</code></pre>

<br>
<pre class="type-9 type-2 type-7 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test that a fault while downloading edits does not prevent future
 * checkpointing
 */
@Test(timeout=30000) public void testEditFailureBeforeRename() throws IOException {
  Configuration conf=new HdfsConfiguration();
  SecondaryNameNode secondary=null;
  MiniDFSCluster cluster=null;
  FileSystem fs=null;
  try {
    cluster=new MiniDFSCluster.Builder(conf).numDataNodes(numDatanodes).build();
    cluster.waitActive();
    fs=cluster.getFileSystem();
    secondary=startSecondaryNameNode(conf);
    DFSTestUtil.createFile(fs,new Path("tmpfile0"),1024,(short)1,0l);
    secondary.doCheckpoint();
    Mockito.doThrow(new IOException("Injecting failure before edit rename")).when(faultInjector).beforeEditsRename();
    DFSTestUtil.createFile(fs,new Path("tmpfile1"),1024,(short)1,0l);
    try {
      secondary.doCheckpoint();
      fail("Fault injection failed.");
    }
 catch (    IOException ioe) {
      GenericTestUtils.assertExceptionContains("Injecting failure before edit rename",ioe);
    }
    Mockito.reset(faultInjector);
    for (    StorageDirectory sd : secondary.getFSImage().getStorage().dirIterable(NameNodeDirType.EDITS)) {
      File[] tmpEdits=sd.getCurrentDir().listFiles(tmpEditsFilter);
      assertTrue("Expected a single tmp edits file in directory " + sd.toString(),tmpEdits.length == 1);
      RandomAccessFile randFile=new RandomAccessFile(tmpEdits[0],"rw");
      randFile.setLength(0);
      randFile.close();
    }
    secondary.doCheckpoint();
  }
  finally {
    if (secondary != null) {
      secondary.shutdown();
    }
    if (fs != null) {
      fs.close();
    }
    if (cluster != null) {
      cluster.shutdown();
    }
    Mockito.reset(faultInjector);
  }
}

</code></pre>

<br>
<pre class="type-9 type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test that the primary NN will not serve any files to a 2NN who doesn't
 * share its namespace ID, and also will not accept any files from one.
 */
@Test public void testNamespaceVerifiedOnFileTransfer() throws IOException {
  MiniDFSCluster cluster=null;
  Configuration conf=new HdfsConfiguration();
  try {
    cluster=new MiniDFSCluster.Builder(conf).numDataNodes(0).format(true).build();
    NamenodeProtocols nn=cluster.getNameNodeRpc();
    URL fsName=DFSUtil.getInfoServer(cluster.getNameNode().getServiceRpcAddress(),conf,DFSUtil.getHttpClientScheme(conf)).toURL();
    nn.rollEditLog();
    RemoteEditLogManifest manifest=nn.getEditLogManifest(1);
    RemoteEditLog log=manifest.getLogs().get(0);
    NNStorage dstImage=Mockito.mock(NNStorage.class);
    Mockito.doReturn(Lists.newArrayList(new File("/wont-be-written"))).when(dstImage).getFiles(Mockito.<NameNodeDirType>anyObject(),Mockito.anyString());
    File mockImageFile=File.createTempFile("image","");
    FileOutputStream imageFile=new FileOutputStream(mockImageFile);
    imageFile.write("data".getBytes());
    imageFile.close();
    Mockito.doReturn(mockImageFile).when(dstImage).findImageFile(Mockito.any(NameNodeFile.class),Mockito.anyLong());
    Mockito.doReturn(new StorageInfo(1,1,"X",1,NodeType.NAME_NODE).toColonSeparatedString()).when(dstImage).toColonSeparatedString();
    try {
      TransferFsImage.downloadImageToStorage(fsName,0,dstImage,false);
      fail("Storage info was not verified");
    }
 catch (    IOException ioe) {
      String msg=StringUtils.stringifyException(ioe);
      assertTrue(msg,msg.contains("but the secondary expected"));
    }
    try {
      TransferFsImage.downloadEditsToStorage(fsName,log,dstImage);
      fail("Storage info was not verified");
    }
 catch (    IOException ioe) {
      String msg=StringUtils.stringifyException(ioe);
      assertTrue(msg,msg.contains("but the secondary expected"));
    }
    try {
      TransferFsImage.uploadImageFromStorage(fsName,conf,dstImage,NameNodeFile.IMAGE,0);
      fail("Storage info was not verified");
    }
 catch (    IOException ioe) {
      String msg=StringUtils.stringifyException(ioe);
      assertTrue(msg,msg.contains("but the secondary expected"));
    }
  }
  finally {
    cleanup(cluster);
    cluster=null;
  }
}

</code></pre>

<br>
<pre class="type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test that, an attempt to lock a storage that is already locked by a nodename,
 * logs error message that includes JVM name of the namenode that locked it.
 */
@Test public void testStorageAlreadyLockedErrorMessage() throws Exception {
  Configuration conf=new HdfsConfiguration();
  MiniDFSCluster cluster=null;
  StorageDirectory savedSd=null;
  try {
    cluster=new MiniDFSCluster.Builder(conf).numDataNodes(0).build();
    NNStorage storage=cluster.getNameNode().getFSImage().getStorage();
    for (    StorageDirectory sd : storage.dirIterable(null)) {
      assertLockFails(sd);
      savedSd=sd;
    }
    LogCapturer logs=GenericTestUtils.LogCapturer.captureLogs(LogFactory.getLog(Storage.class));
    try {
      savedSd.lock();
      fail("Namenode should not be able to lock a storage that is already locked");
    }
 catch (    IOException ioe) {
      String lockingJvmName=Path.WINDOWS ? "" : " " + ManagementFactory.getRuntimeMXBean().getName();
      String expectedLogMessage="It appears that another namenode" + lockingJvmName + " has already locked the storage directory";
      assertTrue("Log output does not contain expected log message: " + expectedLogMessage,logs.getOutput().contains(expectedLogMessage));
    }
  }
  finally {
    cleanup(cluster);
    cluster=null;
  }
}

</code></pre>

<br>
<pre class="type-9 type-2 type-7 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test that the secondary namenode correctly deletes temporary edits
 * on startup.
 */
@Test(timeout=60000) public void testDeleteTemporaryEditsOnStartup() throws IOException {
  Configuration conf=new HdfsConfiguration();
  SecondaryNameNode secondary=null;
  MiniDFSCluster cluster=null;
  FileSystem fs=null;
  try {
    cluster=new MiniDFSCluster.Builder(conf).numDataNodes(numDatanodes).build();
    cluster.waitActive();
    fs=cluster.getFileSystem();
    secondary=startSecondaryNameNode(conf);
    DFSTestUtil.createFile(fs,new Path("tmpfile0"),1024,(short)1,0l);
    secondary.doCheckpoint();
    Mockito.doThrow(new IOException("Injecting failure before edit rename")).when(faultInjector).beforeEditsRename();
    DFSTestUtil.createFile(fs,new Path("tmpfile1"),1024,(short)1,0l);
    try {
      secondary.doCheckpoint();
      fail("Fault injection failed.");
    }
 catch (    IOException ioe) {
      GenericTestUtils.assertExceptionContains("Injecting failure before edit rename",ioe);
    }
    Mockito.reset(faultInjector);
    for (    StorageDirectory sd : secondary.getFSImage().getStorage().dirIterable(NameNodeDirType.EDITS)) {
      File[] tmpEdits=sd.getCurrentDir().listFiles(tmpEditsFilter);
      assertTrue("Expected a single tmp edits file in directory " + sd.toString(),tmpEdits.length == 1);
    }
    secondary.shutdown();
    secondary=startSecondaryNameNode(conf);
    for (    StorageDirectory sd : secondary.getFSImage().getStorage().dirIterable(NameNodeDirType.EDITS)) {
      File[] tmpEdits=sd.getCurrentDir().listFiles(tmpEditsFilter);
      assertTrue("Did not expect a tmp edits file in directory " + sd.toString(),tmpEdits.length == 0);
    }
    secondary.doCheckpoint();
  }
  finally {
    if (secondary != null) {
      secondary.shutdown();
    }
    if (fs != null) {
      fs.close();
    }
    if (cluster != null) {
      cluster.shutdown();
    }
    Mockito.reset(faultInjector);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.server.namenode.TestClusterId </h4><pre class="type-9 type-11 type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test namenode format with -format -force -clusterid option when name
 * directory exists. Format should succeed.
 * @throws IOException
 */
@Test public void testFormatWithForceAndClusterId() throws IOException {
  if (!hdfsDir.mkdirs()) {
    fail("Failed to create dir " + hdfsDir.getPath());
  }
  String myId="testFormatWithForceAndClusterId";
  String[] argv={"-format","-force","-clusterid",myId};
  try {
    NameNode.createNameNode(argv,config);
    fail("createNameNode() did not call System.exit()");
  }
 catch (  ExitException e) {
    assertEquals("Format should have succeeded",0,e.status);
  }
  String cId=getClusterId(config);
  assertEquals("ClusterIds do not match",myId,cId);
}

</code></pre>

<br>
<pre class="type-9 type-11 type-2 type-10 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test namenode format with -format -force options when name directory
 * exists. Format should succeed.
 * @throws IOException
 */
@Test public void testFormatWithForce() throws IOException {
  if (!hdfsDir.mkdirs()) {
    fail("Failed to create dir " + hdfsDir.getPath());
  }
  String[] argv={"-format","-force"};
  try {
    NameNode.createNameNode(argv,config);
    fail("createNameNode() did not call System.exit()");
  }
 catch (  ExitException e) {
    assertEquals("Format should have succeeded",0,e.status);
  }
  String cid=getClusterId(config);
  assertTrue("Didn't get new ClusterId",(cid != null && !cid.equals("")));
}

</code></pre>

<br>
<pre class="type-9 type-11 type-2 type-10 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test namenode format with -force -nonInteractive -force option. Format
 * should succeed.
 * @throws IOException
 */
@Test public void testFormatWithNonInteractiveAndForce() throws IOException {
  if (!hdfsDir.mkdirs()) {
    fail("Failed to create dir " + hdfsDir.getPath());
  }
  String[] argv={"-format","-nonInteractive","-force"};
  try {
    NameNode.createNameNode(argv,config);
    fail("createNameNode() did not call System.exit()");
  }
 catch (  ExitException e) {
    assertEquals("Format should have succeeded",0,e.status);
  }
  String cid=getClusterId(config);
  assertTrue("Didn't get new ClusterId",(cid != null && !cid.equals("")));
}

</code></pre>

<br>
<pre class="type-11 type-2 type-10 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test namenode format with -format option when a non empty name directory
 * exists. Enter N when prompted and format should be aborted.
 * @throws IOException
 * @throws InterruptedException
 */
@Test public void testFormatWithoutForceEnterNo() throws IOException, InterruptedException {
  File data=new File(hdfsDir,"file");
  if (!data.mkdirs()) {
    fail("Failed to create dir " + data.getPath());
  }
  InputStream origIn=System.in;
  ByteArrayInputStream bins=new ByteArrayInputStream("N\n".getBytes());
  System.setIn(bins);
  String[] argv={"-format"};
  try {
    NameNode.createNameNode(argv,config);
    fail("createNameNode() did not call System.exit()");
  }
 catch (  ExitException e) {
    assertEquals("Format should not have succeeded",1,e.status);
  }
  System.setIn(origIn);
  File version=new File(hdfsDir,"current/VERSION");
  assertFalse("Check version should not exist",version.exists());
}

</code></pre>

<br>
<pre class="type-9 type-11 type-2 type-10 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test namenode format with -format option when an empty name directory
 * exists. Format should succeed.
 * @throws IOException
 */
@Test public void testFormatWithEmptyDir() throws IOException {
  if (!hdfsDir.mkdirs()) {
    fail("Failed to create dir " + hdfsDir.getPath());
  }
  String[] argv={"-format"};
  try {
    NameNode.createNameNode(argv,config);
    fail("createNameNode() did not call System.exit()");
  }
 catch (  ExitException e) {
    assertEquals("Format should have succeeded",0,e.status);
  }
  String cid=getClusterId(config);
  assertTrue("Didn't get new ClusterId",(cid != null && !cid.equals("")));
}

</code></pre>

<br>
<pre class="type-9 type-2 type-10 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test namenode format with -format -nonInteractive options when name
 * directory does not exist. Format should succeed.
 * @throws IOException
 */
@Test public void testFormatWithNonInteractiveNameDirDoesNotExit() throws IOException {
  String[] argv={"-format","-nonInteractive"};
  try {
    NameNode.createNameNode(argv,config);
    fail("createNameNode() did not call System.exit()");
  }
 catch (  ExitException e) {
    assertEquals("Format should have succeeded",0,e.status);
  }
  String cid=getClusterId(config);
  assertTrue("Didn't get new ClusterId",(cid != null && !cid.equals("")));
}

</code></pre>

<br>
<pre class="type-9 type-11 type-2 type-10 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test namenode format with -format option when a non empty name directory
 * exists. Enter Y when prompted and the format should succeed.
 * @throws IOException
 * @throws InterruptedException
 */
@Test public void testFormatWithoutForceEnterYes() throws IOException, InterruptedException {
  File data=new File(hdfsDir,"file");
  if (!data.mkdirs()) {
    fail("Failed to create dir " + data.getPath());
  }
  InputStream origIn=System.in;
  ByteArrayInputStream bins=new ByteArrayInputStream("Y\n".getBytes());
  System.setIn(bins);
  String[] argv={"-format"};
  try {
    NameNode.createNameNode(argv,config);
    fail("createNameNode() did not call System.exit()");
  }
 catch (  ExitException e) {
    assertEquals("Format should have succeeded",0,e.status);
  }
  System.setIn(origIn);
  String cid=getClusterId(config);
  assertTrue("Didn't get new ClusterId",(cid != null && !cid.equals("")));
}

</code></pre>

<br>
<pre class="type-9 type-2 type-10 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test namenode format with -format option. Format should succeed.
 * @throws IOException
 */
@Test public void testFormat() throws IOException {
  String[] argv={"-format"};
  try {
    NameNode.createNameNode(argv,config);
    fail("createNameNode() did not call System.exit()");
  }
 catch (  ExitException e) {
    assertEquals("Format should have succeeded",0,e.status);
  }
  String cid=getClusterId(config);
  assertTrue("Didn't get new ClusterId",(cid != null && !cid.equals("")));
}

</code></pre>

<br>
<pre class="type-11 type-2 type-10 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test namenode format with -format -nonInteractive options when a non empty
 * name directory exists. Format should not succeed.
 * @throws IOException
 */
@Test public void testFormatWithNonInteractive() throws IOException {
  File data=new File(hdfsDir,"file");
  if (!data.mkdirs()) {
    fail("Failed to create dir " + data.getPath());
  }
  String[] argv={"-format","-nonInteractive"};
  try {
    NameNode.createNameNode(argv,config);
    fail("createNameNode() did not call System.exit()");
  }
 catch (  ExitException e) {
    assertEquals("Format should have been aborted with exit code 1",1,e.status);
  }
  File version=new File(hdfsDir,"current/VERSION");
  assertFalse("Check version should not exist",version.exists());
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.server.namenode.TestCommitBlockSynchronization </h4><pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testCommitBlockSynchronization2() throws IOException {
  INodeFile file=mockFileUnderConstruction();
  Block block=new Block(blockId,length,genStamp);
  FSNamesystem namesystemSpy=makeNameSystemSpy(block,file);
  DatanodeID[] newTargets=new DatanodeID[0];
  ExtendedBlock lastBlock=new ExtendedBlock();
  namesystemSpy.commitBlockSynchronization(lastBlock,genStamp,length,false,false,newTargets,null);
  try {
    namesystemSpy.commitBlockSynchronization(lastBlock,genStamp - 1,length,false,false,newTargets,null);
    fail("Failed to get expected IOException on generation stamp/" + "recovery ID mismatch");
  }
 catch (  IOException ioe) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.server.namenode.TestDeadDatanode </h4><pre class="type-9 type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test to ensure namenode rejects request from dead datanode
 * - Start a cluster
 * - Shutdown the datanode and wait for it to be marked dead at the namenode
 * - Send datanode requests to Namenode and make sure it is rejected 
 * appropriately.
 */
@Test public void testDeadDatanode() throws Exception {
  Configuration conf=new HdfsConfiguration();
  conf.setInt(DFSConfigKeys.DFS_NAMENODE_HEARTBEAT_RECHECK_INTERVAL_KEY,500);
  conf.setLong(DFSConfigKeys.DFS_HEARTBEAT_INTERVAL_KEY,1L);
  cluster=new MiniDFSCluster.Builder(conf).build();
  cluster.waitActive();
  String poolId=cluster.getNamesystem().getBlockPoolId();
  DataNode dn=cluster.getDataNodes().get(0);
  DatanodeRegistration reg=DataNodeTestUtils.getDNRegistrationForBP(cluster.getDataNodes().get(0),poolId);
  waitForDatanodeState(reg.getDatanodeUuid(),true,20000);
  dn.shutdown();
  waitForDatanodeState(reg.getDatanodeUuid(),false,20000);
  DatanodeProtocol dnp=cluster.getNameNodeRpc();
  ReceivedDeletedBlockInfo[] blocks={new ReceivedDeletedBlockInfo(new Block(0),ReceivedDeletedBlockInfo.BlockStatus.RECEIVED_BLOCK,null)};
  StorageReceivedDeletedBlocks[] storageBlocks={new StorageReceivedDeletedBlocks(reg.getDatanodeUuid(),blocks)};
  try {
    dnp.blockReceivedAndDeleted(reg,poolId,storageBlocks);
    fail("Expected IOException is not thrown");
  }
 catch (  IOException ex) {
  }
  StorageBlockReport[] report={new StorageBlockReport(new DatanodeStorage(reg.getDatanodeUuid()),new long[]{0L,0L,0L})};
  try {
    dnp.blockReport(reg,poolId,report);
    fail("Expected IOException is not thrown");
  }
 catch (  IOException ex) {
  }
  StorageReport[] rep={new StorageReport(new DatanodeStorage(reg.getDatanodeUuid()),false,0,0,0,0)};
  DatanodeCommand[] cmd=dnp.sendHeartbeat(reg,rep,0L,0L,0,0,0).getCommands();
  assertEquals(1,cmd.length);
  assertEquals(cmd[0].getAction(),RegisterCommand.REGISTER.getAction());
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.server.namenode.TestEditLog </h4><pre class="type-9 type-2 type-10 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test loading an editlog with gaps. A single editlog directory
 * is set up. On of the edit log files is deleted. This should
 * fail when selecting the input streams as it will not be able 
 * to select enough streams to load up to 4*TXNS_PER_ROLL.
 * There should be 4*TXNS_PER_ROLL transactions as we rolled 3
 * times. 
 */
@Test public void testLoadingWithGaps() throws IOException {
  File f1=new File(TEST_DIR + "/gaptest0");
  List<URI> editUris=ImmutableList.of(f1.toURI());
  NNStorage storage=setupEdits(editUris,3);
  final long startGapTxId=1 * TXNS_PER_ROLL + 1;
  final long endGapTxId=2 * TXNS_PER_ROLL;
  File[] files=new File(f1,"current").listFiles(new FilenameFilter(){
    @Override public boolean accept(    File dir,    String name){
      if (name.startsWith(NNStorage.getFinalizedEditsFileName(startGapTxId,endGapTxId))) {
        return true;
      }
      return false;
    }
  }
);
  assertEquals(1,files.length);
  assertTrue(files[0].delete());
  FSEditLog editlog=getFSEditLog(storage);
  editlog.initJournalsForWrite();
  long startTxId=1;
  try {
    editlog.selectInputStreams(startTxId,4 * TXNS_PER_ROLL);
    fail("Should have thrown exception");
  }
 catch (  IOException ioe) {
    GenericTestUtils.assertExceptionContains("Gap in transactions. Expected to be able to read up until " + "at least txid 40 but unable to find any edit logs containing " + "txid 11",ioe);
  }
}

</code></pre>

<br>
<pre class="type-9 type-2 type-10 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test edit log failover.  If a single edit log is missing, other 
 * edits logs should be used instead.
 */
@Test public void testEditLogFailOverFromMissing() throws IOException {
  File f1=new File(TEST_DIR + "/failover0");
  File f2=new File(TEST_DIR + "/failover1");
  List<URI> editUris=ImmutableList.of(f1.toURI(),f2.toURI());
  NNStorage storage=setupEdits(editUris,3);
  final long startErrorTxId=1 * TXNS_PER_ROLL + 1;
  final long endErrorTxId=2 * TXNS_PER_ROLL;
  File[] files=new File(f1,"current").listFiles(new FilenameFilter(){
    @Override public boolean accept(    File dir,    String name){
      if (name.startsWith(NNStorage.getFinalizedEditsFileName(startErrorTxId,endErrorTxId))) {
        return true;
      }
      return false;
    }
  }
);
  assertEquals(1,files.length);
  assertTrue(files[0].delete());
  FSEditLog editlog=getFSEditLog(storage);
  editlog.initJournalsForWrite();
  long startTxId=1;
  Collection<EditLogInputStream> streams=null;
  try {
    streams=editlog.selectInputStreams(startTxId,4 * TXNS_PER_ROLL);
    readAllEdits(streams,startTxId);
  }
 catch (  IOException e) {
    LOG.error("edit log failover didn't work",e);
    fail("Edit log failover didn't work");
  }
 finally {
    IOUtils.cleanup(null,streams.toArray(new EditLogInputStream[0]));
  }
}

</code></pre>

<br>
<pre class="type-9 type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test edit log failover from a corrupt edit log
 */
@Test public void testEditLogFailOverFromCorrupt() throws IOException {
  File f1=new File(TEST_DIR + "/failover0");
  File f2=new File(TEST_DIR + "/failover1");
  List<URI> editUris=ImmutableList.of(f1.toURI(),f2.toURI());
  NNStorage storage=setupEdits(editUris,3);
  final long startErrorTxId=1 * TXNS_PER_ROLL + 1;
  final long endErrorTxId=2 * TXNS_PER_ROLL;
  File[] files=new File(f1,"current").listFiles(new FilenameFilter(){
    @Override public boolean accept(    File dir,    String name){
      if (name.startsWith(NNStorage.getFinalizedEditsFileName(startErrorTxId,endErrorTxId))) {
        return true;
      }
      return false;
    }
  }
);
  assertEquals(1,files.length);
  long fileLen=files[0].length();
  LOG.debug("Corrupting Log File: " + files[0] + " len: "+ fileLen);
  RandomAccessFile rwf=new RandomAccessFile(files[0],"rw");
  rwf.seek(fileLen - 4);
  int b=rwf.readInt();
  rwf.seek(fileLen - 4);
  rwf.writeInt(b + 1);
  rwf.close();
  FSEditLog editlog=getFSEditLog(storage);
  editlog.initJournalsForWrite();
  long startTxId=1;
  Collection<EditLogInputStream> streams=null;
  try {
    streams=editlog.selectInputStreams(startTxId,4 * TXNS_PER_ROLL);
    readAllEdits(streams,startTxId);
  }
 catch (  IOException e) {
    LOG.error("edit log failover didn't work",e);
    fail("Edit log failover didn't work");
  }
 finally {
    IOUtils.cleanup(null,streams.toArray(new EditLogInputStream[0]));
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testFailedOpen() throws Exception {
  File logDir=new File(TEST_DIR,"testFailedOpen");
  logDir.mkdirs();
  FSEditLog log=FSImageTestUtil.createStandaloneEditLog(logDir);
  try {
    FileUtil.setWritable(logDir,false);
    log.openForWrite();
    fail("Did no throw exception on only having a bad dir");
  }
 catch (  IOException ioe) {
    GenericTestUtils.assertExceptionContains("too few journals successfully started",ioe);
  }
 finally {
    FileUtil.setWritable(logDir,true);
    log.close();
  }
}

</code></pre>

<br>
<pre class="type-9 type-2 type-10 type-1 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies whether objects are null
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testEditChecksum() throws Exception {
  Configuration conf=new HdfsConfiguration();
  MiniDFSCluster cluster=null;
  FileSystem fileSys=null;
  cluster=new MiniDFSCluster.Builder(conf).numDataNodes(NUM_DATA_NODES).build();
  cluster.waitActive();
  fileSys=cluster.getFileSystem();
  final FSNamesystem namesystem=cluster.getNamesystem();
  FSImage fsimage=namesystem.getFSImage();
  final FSEditLog editLog=fsimage.getEditLog();
  fileSys.mkdirs(new Path("/tmp"));
  Iterator<StorageDirectory> iter=fsimage.getStorage().dirIterator(NameNodeDirType.EDITS);
  LinkedList<StorageDirectory> sds=new LinkedList<StorageDirectory>();
  while (iter.hasNext()) {
    sds.add(iter.next());
  }
  editLog.close();
  cluster.shutdown();
  for (  StorageDirectory sd : sds) {
    File editFile=NNStorage.getFinalizedEditsFile(sd,1,3);
    assertTrue(editFile.exists());
    long fileLen=editFile.length();
    LOG.debug("Corrupting Log File: " + editFile + " len: "+ fileLen);
    RandomAccessFile rwf=new RandomAccessFile(editFile,"rw");
    rwf.seek(fileLen - 4);
    int b=rwf.readInt();
    rwf.seek(fileLen - 4);
    rwf.writeInt(b + 1);
    rwf.close();
  }
  try {
    cluster=new MiniDFSCluster.Builder(conf).numDataNodes(NUM_DATA_NODES).format(false).build();
    fail("should not be able to start");
  }
 catch (  IOException e) {
    assertNotNull("Cause of exception should be ChecksumException",e.getCause());
    assertEquals("Cause of exception should be ChecksumException",ChecksumException.class,e.getCause().getClass());
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.server.namenode.TestEditLogJournalFailures </h4><pre class="type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testAllEditsDirFailOnWrite() throws IOException {
  assertTrue(doAnEdit());
  invalidateEditsDirAtIndex(0,true,true);
  invalidateEditsDirAtIndex(1,true,true);
  try {
    doAnEdit();
    fail("The previous edit could not be synced to any persistent storage, " + " should have halted the NN");
  }
 catch (  RemoteException re) {
    assertTrue(re.getClassName().contains("ExitException"));
    GenericTestUtils.assertExceptionContains("Could not sync enough journals to persistent storage due to " + "No journals available to flush. " + "Unsynced transactions: 1",re);
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testSingleRequiredFailedEditsDirOnSetReadyToFlush() throws IOException {
  String[] editsDirs=cluster.getConfiguration(0).getTrimmedStrings(DFSConfigKeys.DFS_NAMENODE_NAME_DIR_KEY);
  shutDownMiniCluster();
  Configuration conf=new HdfsConfiguration();
  conf.set(DFSConfigKeys.DFS_NAMENODE_EDITS_DIR_REQUIRED_KEY,editsDirs[0]);
  conf.setInt(DFSConfigKeys.DFS_NAMENODE_EDITS_DIR_MINIMUM_KEY,0);
  conf.setInt(DFSConfigKeys.DFS_NAMENODE_CHECKED_VOLUMES_MINIMUM_KEY,0);
  setUpMiniCluster(conf,true);
  assertTrue(doAnEdit());
  invalidateEditsDirAtIndex(0,false,false);
  JournalAndStream nonRequiredJas=getJournalAndStream(1);
  EditLogFileOutputStream nonRequiredSpy=spyOnStream(nonRequiredJas);
  assertTrue(nonRequiredJas.isActive());
  try {
    doAnEdit();
    fail("A single failure of a required journal should have halted the NN");
  }
 catch (  RemoteException re) {
    assertTrue(re.getClassName().contains("ExitException"));
    GenericTestUtils.assertExceptionContains("setReadyToFlush failed for required journal",re);
  }
  Mockito.verify(nonRequiredSpy,Mockito.never()).setReadyToFlush();
  assertFalse(nonRequiredJas.isActive());
}

</code></pre>

<br>
<pre class="type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testAllEditsDirsFailOnFlush() throws IOException {
  assertTrue(doAnEdit());
  invalidateEditsDirAtIndex(0,true,false);
  invalidateEditsDirAtIndex(1,true,false);
  try {
    doAnEdit();
    fail("The previous edit could not be synced to any persistent storage, " + "should have halted the NN");
  }
 catch (  RemoteException re) {
    assertTrue(re.getClassName().contains("ExitException"));
    GenericTestUtils.assertExceptionContains("Could not sync enough journals to persistent storage. " + "Unsynced transactions: 1",re);
  }
}

</code></pre>

<br>
<pre class="type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testMultipleRedundantFailedEditsDirOnSetReadyToFlush() throws IOException {
  shutDownMiniCluster();
  Configuration conf=new HdfsConfiguration();
  String[] nameDirs=new String[4];
  for (int i=0; i < nameDirs.length; i++) {
    File nameDir=new File(PathUtils.getTestDir(getClass()),"name-dir" + i);
    nameDir.mkdirs();
    nameDirs[i]=nameDir.getAbsolutePath();
  }
  conf.set(DFSConfigKeys.DFS_NAMENODE_NAME_DIR_KEY,StringUtils.join(nameDirs,","));
  conf.setInt(DFSConfigKeys.DFS_NAMENODE_EDITS_DIR_MINIMUM_KEY,2);
  setUpMiniCluster(conf,false);
  assertTrue(doAnEdit());
  invalidateEditsDirAtIndex(0,false,false);
  assertTrue(doAnEdit());
  invalidateEditsDirAtIndex(1,false,false);
  assertTrue(doAnEdit());
  invalidateEditsDirAtIndex(2,false,false);
  try {
    doAnEdit();
    fail("A failure of more than the minimum number of redundant journals " + "should have halted ");
  }
 catch (  RemoteException re) {
    assertTrue(re.getClassName().contains("ExitException"));
    GenericTestUtils.assertExceptionContains("Could not sync enough journals to persistent storage due to " + "setReadyToFlush failed for too many journals. " + "Unsynced transactions: 1",re);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.server.namenode.TestEditsDoubleBuffer </h4><pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void shouldFailToCloseWhenUnflushed() throws IOException {
  EditsDoubleBuffer buf=new EditsDoubleBuffer(1024);
  buf.writeRaw(new byte[1],0,1);
  try {
    buf.close();
    fail("Did not fail to close with unflushed data");
  }
 catch (  IOException ioe) {
    if (!ioe.toString().contains("still to be flushed")) {
      throw ioe;
    }
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.server.namenode.TestFSDirectory </h4><pre class="type-13 type-2 type-7 type-10 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=300000) public void testXAttrMultiAddRemoveErrors() throws Exception {
  List<XAttr> existingXAttrs=Lists.newArrayList();
  List<XAttr> toAdd=Lists.newArrayList();
  toAdd.add(generatedXAttrs.get(0));
  toAdd.add(generatedXAttrs.get(1));
  toAdd.add(generatedXAttrs.get(2));
  toAdd.add(generatedXAttrs.get(0));
  try {
    fsdir.setINodeXAttrs(existingXAttrs,toAdd,EnumSet.of(XAttrSetFlag.CREATE));
    fail("Specified the same xattr to be set twice");
  }
 catch (  IOException e) {
    GenericTestUtils.assertExceptionContains("Cannot specify the same " + "XAttr to be set",e);
  }
  toAdd.remove(generatedXAttrs.get(0));
  existingXAttrs.add(generatedXAttrs.get(0));
  try {
    fsdir.setINodeXAttrs(existingXAttrs,toAdd,EnumSet.of(XAttrSetFlag.CREATE));
    fail("Set XAttr that is already set without REPLACE flag");
  }
 catch (  IOException e) {
    GenericTestUtils.assertExceptionContains("already exists",e);
  }
  try {
    fsdir.setINodeXAttrs(existingXAttrs,toAdd,EnumSet.of(XAttrSetFlag.REPLACE));
    fail("Set XAttr that does not exist without the CREATE flag");
  }
 catch (  IOException e) {
    GenericTestUtils.assertExceptionContains("does not exist",e);
  }
  toAdd.remove(generatedXAttrs.get(0));
  List<XAttr> newXAttrs=fsdir.setINodeXAttrs(existingXAttrs,toAdd,EnumSet.of(XAttrSetFlag.CREATE));
  assertEquals("Unexpected toAdd size",2,toAdd.size());
  for (  XAttr x : toAdd) {
    assertTrue("Did not find added XAttr " + x,newXAttrs.contains(x));
  }
  existingXAttrs=newXAttrs;
  toAdd=Lists.newArrayList();
  for (int i=0; i < 3; i++) {
    XAttr xAttr=(new XAttr.Builder()).setNameSpace(XAttr.NameSpace.SYSTEM).setName("a" + i).setValue(new byte[]{(byte)(i * 2)}).build();
    toAdd.add(xAttr);
  }
  newXAttrs=fsdir.setINodeXAttrs(existingXAttrs,toAdd,EnumSet.of(XAttrSetFlag.REPLACE));
  assertEquals("Unexpected number of new XAttrs",3,newXAttrs.size());
  for (int i=0; i < 3; i++) {
    assertArrayEquals("Unexpected XAttr value",new byte[]{(byte)(i * 2)},newXAttrs.get(i).getValue());
  }
  existingXAttrs=newXAttrs;
  toAdd=Lists.newArrayList();
  for (int i=0; i < 4; i++) {
    toAdd.add(generatedXAttrs.get(i));
  }
  newXAttrs=fsdir.setINodeXAttrs(existingXAttrs,toAdd,EnumSet.of(XAttrSetFlag.CREATE,XAttrSetFlag.REPLACE));
  verifyXAttrsPresent(newXAttrs,4);
}

</code></pre>

<br>
<pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testINodeXAttrsLimit() throws Exception {
  List<XAttr> existingXAttrs=Lists.newArrayListWithCapacity(2);
  XAttr xAttr1=(new XAttr.Builder()).setNameSpace(XAttr.NameSpace.USER).setName("a1").setValue(new byte[]{0x31,0x32,0x33}).build();
  XAttr xAttr2=(new XAttr.Builder()).setNameSpace(XAttr.NameSpace.USER).setName("a2").setValue(new byte[]{0x31,0x31,0x31}).build();
  existingXAttrs.add(xAttr1);
  existingXAttrs.add(xAttr2);
  XAttr newSystemXAttr=(new XAttr.Builder()).setNameSpace(XAttr.NameSpace.SYSTEM).setName("a3").setValue(new byte[]{0x33,0x33,0x33}).build();
  XAttr newRawXAttr=(new XAttr.Builder()).setNameSpace(XAttr.NameSpace.RAW).setName("a3").setValue(new byte[]{0x33,0x33,0x33}).build();
  List<XAttr> newXAttrs=Lists.newArrayListWithCapacity(2);
  newXAttrs.add(newSystemXAttr);
  newXAttrs.add(newRawXAttr);
  List<XAttr> xAttrs=fsdir.setINodeXAttrs(existingXAttrs,newXAttrs,EnumSet.of(XAttrSetFlag.CREATE,XAttrSetFlag.REPLACE));
  assertEquals(xAttrs.size(),4);
  XAttr newXAttr1=(new XAttr.Builder()).setNameSpace(XAttr.NameSpace.TRUSTED).setName("a4").setValue(new byte[]{0x34,0x34,0x34}).build();
  newXAttrs.set(0,newXAttr1);
  try {
    fsdir.setINodeXAttrs(existingXAttrs,newXAttrs,EnumSet.of(XAttrSetFlag.CREATE,XAttrSetFlag.REPLACE));
    fail("Setting user visible xattr on inode should fail if " + "reaching limit.");
  }
 catch (  IOException e) {
    GenericTestUtils.assertExceptionContains("Cannot add additional XAttr " + "to inode, would exceed limit",e);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.server.namenode.TestFSEditLogLoader </h4><pre class="type-9 type-2 type-7 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testDisplayRecentEditLogOpCodes() throws IOException {
  Configuration conf=new HdfsConfiguration();
  MiniDFSCluster cluster=null;
  FileSystem fileSys=null;
  cluster=new MiniDFSCluster.Builder(conf).numDataNodes(NUM_DATA_NODES).enableManagedDfsDirsRedundancy(false).build();
  cluster.waitActive();
  fileSys=cluster.getFileSystem();
  final FSNamesystem namesystem=cluster.getNamesystem();
  FSImage fsimage=namesystem.getFSImage();
  for (int i=0; i < 20; i++) {
    fileSys.mkdirs(new Path("/tmp/tmp" + i));
  }
  StorageDirectory sd=fsimage.getStorage().dirIterator(NameNodeDirType.EDITS).next();
  cluster.shutdown();
  File editFile=FSImageTestUtil.findLatestEditsLog(sd).getFile();
  assertTrue("Should exist: " + editFile,editFile.exists());
  long fileLen=editFile.length();
  RandomAccessFile rwf=new RandomAccessFile(editFile,"rw");
  rwf.seek(fileLen - 40);
  for (int i=0; i < 20; i++) {
    rwf.write(FSEditLogOpCodes.OP_DELETE.getOpCode());
  }
  rwf.close();
  StringBuilder bld=new StringBuilder();
  bld.append("^Error replaying edit log at offset \\d+.  ");
  bld.append("Expected transaction ID was \\d+\n");
  bld.append("Recent opcode offsets: (\\d+\\s*){4}$");
  try {
    cluster=new MiniDFSCluster.Builder(conf).numDataNodes(NUM_DATA_NODES).enableManagedDfsDirsRedundancy(false).format(false).build();
    fail("should not be able to start");
  }
 catch (  IOException e) {
    assertTrue("error message contains opcodes message",e.getMessage().matches(bld.toString()));
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testStreamLimiter() throws IOException {
  final File LIMITER_TEST_FILE=new File(TEST_DIR,"limiter.test");
  FileOutputStream fos=new FileOutputStream(LIMITER_TEST_FILE);
  try {
    fos.write(0x12);
    fos.write(0x12);
    fos.write(0x12);
  }
  finally {
    fos.close();
  }
  FileInputStream fin=new FileInputStream(LIMITER_TEST_FILE);
  BufferedInputStream bin=new BufferedInputStream(fin);
  FSEditLogLoader.PositionTrackingInputStream tracker=new FSEditLogLoader.PositionTrackingInputStream(bin);
  try {
    tracker.setLimit(2);
    tracker.mark(100);
    tracker.read();
    tracker.read();
    try {
      tracker.read();
      fail("expected to get IOException after reading past the limit");
    }
 catch (    IOException e) {
    }
    tracker.reset();
    tracker.mark(100);
    byte arr[]=new byte[3];
    try {
      tracker.read(arr);
      fail("expected to get IOException after reading past the limit");
    }
 catch (    IOException e) {
    }
    tracker.reset();
    arr=new byte[2];
    tracker.read(arr);
  }
  finally {
    tracker.close();
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.server.namenode.TestFsck </h4><pre class="type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test fsck with FileNotFound 
 */
@Test public void testFsckFileNotFound() throws Exception {
  final short NUM_REPLICAS=1;
  Configuration conf=new Configuration();
  NameNode namenode=mock(NameNode.class);
  NetworkTopology nettop=mock(NetworkTopology.class);
  Map<String,String[]> pmap=new HashMap<String,String[]>();
  Writer result=new StringWriter();
  PrintWriter out=new PrintWriter(result,true);
  InetAddress remoteAddress=InetAddress.getLocalHost();
  FSNamesystem fsName=mock(FSNamesystem.class);
  BlockManager blockManager=mock(BlockManager.class);
  DatanodeManager dnManager=mock(DatanodeManager.class);
  when(namenode.getNamesystem()).thenReturn(fsName);
  when(fsName.getBlockLocations(anyString(),anyLong(),anyLong(),anyBoolean(),anyBoolean(),anyBoolean())).thenThrow(new FileNotFoundException());
  when(fsName.getBlockManager()).thenReturn(blockManager);
  when(blockManager.getDatanodeManager()).thenReturn(dnManager);
  NamenodeFsck fsck=new NamenodeFsck(conf,namenode,nettop,pmap,out,NUM_REPLICAS,(short)1,remoteAddress);
  String pathString="/tmp/testFile";
  long length=123L;
  boolean isDir=false;
  int blockReplication=1;
  long blockSize=128 * 1024L;
  long modTime=123123123L;
  long accessTime=123123120L;
  FsPermission perms=FsPermission.getDefault();
  String owner="foo";
  String group="bar";
  byte[] symlink=null;
  byte[] path=new byte[128];
  path=DFSUtil.string2Bytes(pathString);
  long fileId=312321L;
  int numChildren=1;
  HdfsFileStatus file=new HdfsFileStatus(length,isDir,blockReplication,blockSize,modTime,accessTime,perms,owner,group,symlink,path,fileId,numChildren,null);
  Result res=new Result(conf);
  try {
    fsck.check(pathString,file,res);
  }
 catch (  Exception e) {
    fail("Unexpected exception " + e.getMessage());
  }
  assertTrue(res.toString().contains("HEALTHY"));
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.server.namenode.TestGenericJournalConf </h4><pre class="type-11 type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * Test that a implementation of JournalManager without a 
 * (Configuration,URI) constructor throws an exception
 */
@Test public void testBadConstructor() throws Exception {
  MiniDFSCluster cluster=null;
  Configuration conf=new Configuration();
  conf.set(DFSConfigKeys.DFS_NAMENODE_EDITS_PLUGIN_PREFIX + ".dummy",BadConstructorJournalManager.class.getName());
  conf.set(DFSConfigKeys.DFS_NAMENODE_EDITS_DIR_KEY,"dummy://test");
  try {
    cluster=new MiniDFSCluster.Builder(conf).numDataNodes(0).build();
    cluster.waitActive();
    fail("Should have failed before this point");
  }
 catch (  IllegalArgumentException iae) {
    if (!iae.getMessage().contains("Unable to construct journal")) {
      fail("Should have failed with unable to construct exception");
    }
  }
 finally {
    if (cluster != null) {
      cluster.shutdown();
    }
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.server.namenode.TestHDFSConcat </h4><pre class="type-13 type-2 type-7 type-1 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Concatenates 10 files into one
 * Verifies the final size, deletion of the file, number of blocks
 * @throws IOException
 */
@Test public void testConcat() throws IOException, InterruptedException {
  final int numFiles=10;
  long fileLen=blockSize * 3;
  HdfsFileStatus fStatus;
  FSDataInputStream stm;
  String trg=new String("/trg");
  Path trgPath=new Path(trg);
  DFSTestUtil.createFile(dfs,trgPath,fileLen,REPL_FACTOR,1);
  fStatus=nn.getFileInfo(trg);
  long trgLen=fStatus.getLen();
  long trgBlocks=nn.getBlockLocations(trg,0,trgLen).locatedBlockCount();
  Path[] files=new Path[numFiles];
  byte[][] bytes=new byte[numFiles][(int)fileLen];
  LocatedBlocks[] lblocks=new LocatedBlocks[numFiles];
  long[] lens=new long[numFiles];
  int i=0;
  for (i=0; i < files.length; i++) {
    files[i]=new Path("/file" + i);
    Path path=files[i];
    System.out.println("Creating file " + path);
    DFSTestUtil.createFile(dfs,path,fileLen,REPL_FACTOR,1);
    fStatus=nn.getFileInfo(path.toUri().getPath());
    lens[i]=fStatus.getLen();
    assertEquals(trgLen,lens[i]);
    lblocks[i]=nn.getBlockLocations(path.toUri().getPath(),0,lens[i]);
    stm=dfs.open(path);
    stm.readFully(0,bytes[i]);
    stm.close();
  }
  final UserGroupInformation user1=UserGroupInformation.createUserForTesting("theDoctor",new String[]{"tardis"});
  DistributedFileSystem hdfs=(DistributedFileSystem)DFSTestUtil.getFileSystemAs(user1,conf);
  try {
    hdfs.concat(trgPath,files);
    fail("Permission exception expected");
  }
 catch (  IOException ie) {
    System.out.println("Got expected exception for permissions:" + ie.getLocalizedMessage());
  }
  ContentSummary cBefore=dfs.getContentSummary(trgPath.getParent());
  dfs.concat(trgPath,files);
  ContentSummary cAfter=dfs.getContentSummary(trgPath.getParent());
  assertEquals(cBefore.getFileCount(),cAfter.getFileCount() + files.length);
  long totalLen=trgLen;
  long totalBlocks=trgBlocks;
  for (i=0; i < files.length; i++) {
    totalLen+=lens[i];
    totalBlocks+=lblocks[i].locatedBlockCount();
  }
  System.out.println("total len=" + totalLen + "; totalBlocks="+ totalBlocks);
  fStatus=nn.getFileInfo(trg);
  trgLen=fStatus.getLen();
  stm=dfs.open(trgPath);
  byte[] byteFileConcat=new byte[(int)trgLen];
  stm.readFully(0,byteFileConcat);
  stm.close();
  trgBlocks=nn.getBlockLocations(trg,0,trgLen).locatedBlockCount();
  assertEquals(trgBlocks,totalBlocks);
  assertEquals(trgLen,totalLen);
  for (  Path p : files) {
    fStatus=nn.getFileInfo(p.toUri().getPath());
    assertNull("File " + p + " still exists",fStatus);
    DFSTestUtil.createFile(dfs,p,fileLen,REPL_FACTOR,1);
  }
  checkFileContent(byteFileConcat,bytes);
  Path smallFile=new Path("/sfile");
  int sFileLen=10;
  DFSTestUtil.createFile(dfs,smallFile,sFileLen,REPL_FACTOR,1);
  dfs.concat(trgPath,new Path[]{smallFile});
  fStatus=nn.getFileInfo(trg);
  trgLen=fStatus.getLen();
  trgBlocks=nn.getBlockLocations(trg,0,trgLen).locatedBlockCount();
  assertEquals(trgBlocks,totalBlocks + 1);
  assertEquals(trgLen,totalLen + sFileLen);
}

</code></pre>

<br>
<pre class="type-2 type-7 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * test illegal args cases
 */
@Test public void testIllegalArg() throws IOException {
  long fileLen=blockSize * 3;
  Path parentDir=new Path("/parentTrg");
  assertTrue(dfs.mkdirs(parentDir));
  Path trg=new Path(parentDir,"trg");
  DFSTestUtil.createFile(dfs,trg,fileLen,REPL_FACTOR,1);
{
    Path dir1=new Path("/dir1");
    assertTrue(dfs.mkdirs(dir1));
    Path src=new Path(dir1,"src");
    DFSTestUtil.createFile(dfs,src,fileLen,REPL_FACTOR,1);
    try {
      dfs.concat(trg,new Path[]{src});
      fail("didn't fail for src and trg in different directories");
    }
 catch (    Exception e) {
    }
  }
  try {
    dfs.concat(trg,new Path[]{new Path("test1/a")});
    fail("didn't fail with invalid arguments");
  }
 catch (  Exception e) {
  }
  try {
    dfs.concat(trg,new Path[]{});
    fail("didn't fail with invalid arguments");
  }
 catch (  Exception e) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.server.namenode.TestINodeFile </h4><pre class="type-9 type-2 type-7 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testFilesInGetListingOps() throws Exception {
  final Configuration conf=new Configuration();
  MiniDFSCluster cluster=null;
  try {
    cluster=new MiniDFSCluster.Builder(conf).numDataNodes(1).build();
    cluster.waitActive();
    final DistributedFileSystem hdfs=cluster.getFileSystem();
    final FSDirectory fsdir=cluster.getNamesystem().getFSDirectory();
    hdfs.mkdirs(new Path("/tmp"));
    DFSTestUtil.createFile(hdfs,new Path("/tmp/f1"),0,(short)1,0);
    DFSTestUtil.createFile(hdfs,new Path("/tmp/f2"),0,(short)1,0);
    DFSTestUtil.createFile(hdfs,new Path("/tmp/f3"),0,(short)1,0);
    DirectoryListing dl=cluster.getNameNodeRpc().getListing("/tmp",HdfsFileStatus.EMPTY_NAME,false);
    assertTrue(dl.getPartialListing().length == 3);
    String f2=new String("f2");
    dl=cluster.getNameNodeRpc().getListing("/tmp",f2.getBytes(),false);
    assertTrue(dl.getPartialListing().length == 1);
    INode f2INode=fsdir.getINode("/tmp/f2");
    String f2InodePath="/.reserved/.inodes/" + f2INode.getId();
    dl=cluster.getNameNodeRpc().getListing("/tmp",f2InodePath.getBytes(),false);
    assertTrue(dl.getPartialListing().length == 1);
    hdfs.delete(new Path("/tmp/f2"),false);
    try {
      dl=cluster.getNameNodeRpc().getListing("/tmp",f2InodePath.getBytes(),false);
      fail("Didn't get exception for the deleted startAfter token.");
    }
 catch (    IOException e) {
      assertTrue(e instanceof DirectoryListingStartAfterNotFoundException);
    }
  }
  finally {
    if (cluster != null) {
      cluster.shutdown();
    }
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=120000) public void testWriteToDeletedFile() throws IOException {
  Configuration conf=new Configuration();
  MiniDFSCluster cluster=new MiniDFSCluster.Builder(conf).numDataNodes(1).build();
  cluster.waitActive();
  FileSystem fs=cluster.getFileSystem();
  Path path=new Path("/test1");
  assertTrue(fs.mkdirs(path));
  int size=conf.getInt(DFSConfigKeys.DFS_BYTES_PER_CHECKSUM_KEY,512);
  byte[] data=new byte[size];
  Path filePath=new Path("/test1/file");
  FSDataOutputStream fos=fs.create(filePath);
  fs.delete(filePath,false);
  try {
    fos.write(data,0,data.length);
    fos.hflush();
    fail("Write should fail after delete");
  }
 catch (  Exception e) {
  }
 finally {
    cluster.shutdown();
  }
}

</code></pre>

<br>
<pre class="type-9 type-2 type-10 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Tests for {@link FSDirectory#resolvePath(String,byte[][],FSDirectory)}
 */
@Test public void testInodePath() throws IOException {
  String path="/a/b/c";
  INode inode=createTreeOfInodes(path);
  FSDirectory fsd=Mockito.mock(FSDirectory.class);
  Mockito.doReturn(inode).when(fsd).getInode(Mockito.anyLong());
  assertEquals("/test",FSDirectory.resolvePath("/test",null,fsd));
  byte[][] components=INode.getPathComponents(path);
  String resolvedPath=FSDirectory.resolvePath(path,components,fsd);
  assertEquals(path,resolvedPath);
  components=INode.getPathComponents("/.reserved/.inodes/1");
  resolvedPath=FSDirectory.resolvePath(path,components,fsd);
  assertEquals(path,resolvedPath);
  components=INode.getPathComponents("/.reserved/.inodes/1/");
  assertEquals(path,resolvedPath);
  components=INode.getPathComponents("/.reserved/.inodes/1/d/e/f");
  resolvedPath=FSDirectory.resolvePath(path,components,fsd);
  assertEquals("/a/b/c/d/e/f",resolvedPath);
  String testPath="/.reserved/.inodes";
  components=INode.getPathComponents(testPath);
  resolvedPath=FSDirectory.resolvePath(testPath,components,fsd);
  assertEquals(testPath,resolvedPath);
  testPath="/.reserved/.inodes/" + INodeId.ROOT_INODE_ID;
  components=INode.getPathComponents(testPath);
  resolvedPath=FSDirectory.resolvePath(testPath,components,fsd);
  assertEquals("/",resolvedPath);
  testPath="/.invalid/.inodes/1";
  components=INode.getPathComponents(testPath);
  resolvedPath=FSDirectory.resolvePath(testPath,components,fsd);
  assertEquals(testPath,resolvedPath);
  Mockito.doReturn(null).when(fsd).getInode(Mockito.anyLong());
  testPath="/.reserved/.inodes/1234";
  components=INode.getPathComponents(testPath);
  try {
    String realPath=FSDirectory.resolvePath(testPath,components,fsd);
    fail("Path should not be resolved:" + realPath);
  }
 catch (  IOException e) {
    assertTrue(e instanceof FileNotFoundException);
  }
}

</code></pre>

<br>
<pre class="type-9 type-2 type-7 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test for the static {@link INodeFile#valueOf(INode,String)}and {@link INodeFileUnderConstruction#valueOf(INode,String)} methods.
 * @throws IOException 
 */
@Test public void testValueOf() throws IOException {
  final String path="/testValueOf";
  final short replication=3;
{
    final INode from=null;
    try {
      INodeFile.valueOf(from,path);
      fail();
    }
 catch (    FileNotFoundException fnfe) {
      assertTrue(fnfe.getMessage().contains("File does not exist"));
    }
    try {
      INodeDirectory.valueOf(from,path);
      fail();
    }
 catch (    FileNotFoundException e) {
      assertTrue(e.getMessage().contains("Directory does not exist"));
    }
  }
{
    final INode from=createINodeFile(replication,preferredBlockSize);
    final INodeFile f=INodeFile.valueOf(from,path);
    assertTrue(f == from);
    try {
      INodeDirectory.valueOf(from,path);
      fail();
    }
 catch (    PathIsNotDirectoryException e) {
    }
  }
{
    final INode from=new INodeFile(INodeId.GRANDFATHER_INODE_ID,null,perm,0L,0L,null,replication,1024L);
    from.asFile().toUnderConstruction("client","machine");
    final INodeFile f=INodeFile.valueOf(from,path);
    assertTrue(f == from);
    try {
      INodeDirectory.valueOf(from,path);
      fail();
    }
 catch (    PathIsNotDirectoryException expected) {
    }
  }
{
    final INode from=new INodeDirectory(INodeId.GRANDFATHER_INODE_ID,null,perm,0L);
    try {
      INodeFile.valueOf(from,path);
      fail();
    }
 catch (    FileNotFoundException fnfe) {
      assertTrue(fnfe.getMessage().contains("Path is not a file"));
    }
    final INodeDirectory d=INodeDirectory.valueOf(from,path);
    assertTrue(d == from);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.server.namenode.TestMetaSave </h4><pre class="type-13 type-11 type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * Tests that metasave overwrites the output file (not append).
 */
@Test public void testMetaSaveOverwrite() throws Exception {
  namesystem.metaSave("metaSaveOverwrite.out.txt");
  namesystem.metaSave("metaSaveOverwrite.out.txt");
  FileInputStream fis=null;
  InputStreamReader isr=null;
  BufferedReader rdr=null;
  try {
    fis=new FileInputStream(getLogFile("metaSaveOverwrite.out.txt"));
    isr=new InputStreamReader(fis);
    rdr=new BufferedReader(isr);
    boolean foundLiveDatanodesLine=false;
    String line=rdr.readLine();
    while (line != null) {
      if (line.startsWith("Live Datanodes")) {
        if (foundLiveDatanodesLine) {
          fail("multiple Live Datanodes lines, output file not overwritten");
        }
        foundLiveDatanodesLine=true;
      }
      line=rdr.readLine();
    }
  }
  finally {
    IOUtils.cleanup(null,rdr,isr,fis);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.server.namenode.TestNameEditsConfigs </h4><pre class="type-2 type-7 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test various configuration options of dfs.namenode.name.dir and dfs.namenode.edits.dir
 * This test tries to simulate failure scenarios.
 * 1. Start cluster with shared name and edits dir
 * 2. Restart cluster by adding separate name and edits dirs
 * 3. Restart cluster by removing shared name and edits dir
 * 4. Restart cluster with old shared name and edits dir, but only latest 
 * name dir. This should fail since we don't have latest edits dir
 * 5. Restart cluster with old shared name and edits dir, but only latest
 * edits dir. This should succeed since the latest edits will have
 * segments leading all the way from the image in name_and_edits.
 */
@Test public void testNameEditsConfigsFailure() throws IOException {
  Path file1=new Path("TestNameEditsConfigs1");
  Path file2=new Path("TestNameEditsConfigs2");
  Path file3=new Path("TestNameEditsConfigs3");
  MiniDFSCluster cluster=null;
  Configuration conf=null;
  FileSystem fileSys=null;
  File nameOnlyDir=new File(base_dir,"name");
  File editsOnlyDir=new File(base_dir,"edits");
  File nameAndEditsDir=new File(base_dir,"name_and_edits");
  conf=new HdfsConfiguration();
  conf.set(DFSConfigKeys.DFS_NAMENODE_NAME_DIR_KEY,nameAndEditsDir.getPath());
  conf.set(DFSConfigKeys.DFS_NAMENODE_EDITS_DIR_KEY,nameAndEditsDir.getPath());
  replication=(short)conf.getInt(DFSConfigKeys.DFS_REPLICATION_KEY,3);
  try {
    cluster=new MiniDFSCluster.Builder(conf).numDataNodes(NUM_DATA_NODES).manageNameDfsDirs(false).build();
    cluster.waitActive();
    assertTrue(new File(nameAndEditsDir,"current/VERSION").exists());
    fileSys=cluster.getFileSystem();
    assertTrue(!fileSys.exists(file1));
    DFSTestUtil.createFile(fileSys,file1,FILE_SIZE,FILE_SIZE,BLOCK_SIZE,replication,SEED);
    checkFile(fileSys,file1,replication);
  }
  finally {
    fileSys.close();
    cluster.shutdown();
  }
  conf=new HdfsConfiguration();
  assertTrue(nameOnlyDir.mkdir());
  assertTrue(editsOnlyDir.mkdir());
  conf.set(DFSConfigKeys.DFS_NAMENODE_NAME_DIR_KEY,nameAndEditsDir.getPath() + "," + nameOnlyDir.getPath());
  conf.set(DFSConfigKeys.DFS_NAMENODE_EDITS_DIR_KEY,nameAndEditsDir.getPath() + "," + editsOnlyDir.getPath());
  replication=(short)conf.getInt(DFSConfigKeys.DFS_REPLICATION_KEY,3);
  try {
    cluster=new MiniDFSCluster.Builder(conf).numDataNodes(NUM_DATA_NODES).format(false).manageNameDfsDirs(false).build();
    cluster.waitActive();
    assertTrue(new File(nameAndEditsDir,"current/VERSION").exists());
    assertTrue(new File(nameOnlyDir,"current/VERSION").exists());
    assertTrue(new File(editsOnlyDir,"current/VERSION").exists());
    fileSys=cluster.getFileSystem();
    assertTrue(fileSys.exists(file1));
    checkFile(fileSys,file1,replication);
    cleanupFile(fileSys,file1);
    DFSTestUtil.createFile(fileSys,file2,FILE_SIZE,FILE_SIZE,BLOCK_SIZE,replication,SEED);
    checkFile(fileSys,file2,replication);
  }
  finally {
    fileSys.close();
    cluster.shutdown();
  }
  try {
    conf=new HdfsConfiguration();
    conf.set(DFSConfigKeys.DFS_NAMENODE_NAME_DIR_KEY,nameOnlyDir.getPath());
    conf.set(DFSConfigKeys.DFS_NAMENODE_EDITS_DIR_KEY,editsOnlyDir.getPath());
    replication=(short)conf.getInt(DFSConfigKeys.DFS_REPLICATION_KEY,3);
    cluster=new MiniDFSCluster.Builder(conf).numDataNodes(NUM_DATA_NODES).format(false).manageNameDfsDirs(false).build();
    cluster.waitActive();
    fileSys=cluster.getFileSystem();
    assertFalse(fileSys.exists(file1));
    assertTrue(fileSys.exists(file2));
    checkFile(fileSys,file2,replication);
    cleanupFile(fileSys,file2);
    DFSTestUtil.createFile(fileSys,file3,FILE_SIZE,FILE_SIZE,BLOCK_SIZE,replication,SEED);
    checkFile(fileSys,file3,replication);
  }
  finally {
    fileSys.close();
    cluster.shutdown();
  }
  conf=new HdfsConfiguration();
  conf.set(DFSConfigKeys.DFS_NAMENODE_NAME_DIR_KEY,nameOnlyDir.getPath() + "," + nameAndEditsDir.getPath());
  conf.set(DFSConfigKeys.DFS_NAMENODE_EDITS_DIR_KEY,nameAndEditsDir.getPath());
  replication=(short)conf.getInt(DFSConfigKeys.DFS_REPLICATION_KEY,3);
  try {
    cluster=new MiniDFSCluster.Builder(conf).numDataNodes(NUM_DATA_NODES).format(false).manageNameDfsDirs(false).build();
    fail("Successfully started cluster but should not have been able to.");
  }
 catch (  IOException e) {
    LOG.info("EXPECTED: cluster start failed due to missing " + "latest edits dir",e);
  }
 finally {
    if (cluster != null) {
      cluster.shutdown();
    }
    cluster=null;
  }
  conf=new HdfsConfiguration();
  conf.set(DFSConfigKeys.DFS_NAMENODE_NAME_DIR_KEY,nameAndEditsDir.getPath());
  conf.set(DFSConfigKeys.DFS_NAMENODE_EDITS_DIR_KEY,editsOnlyDir.getPath() + "," + nameAndEditsDir.getPath());
  replication=(short)conf.getInt(DFSConfigKeys.DFS_REPLICATION_KEY,3);
  try {
    cluster=new MiniDFSCluster.Builder(conf).numDataNodes(NUM_DATA_NODES).format(false).manageNameDfsDirs(false).build();
    fileSys=cluster.getFileSystem();
    assertFalse(fileSys.exists(file1));
    assertFalse(fileSys.exists(file2));
    assertTrue(fileSys.exists(file3));
    checkFile(fileSys,file3,replication);
    cleanupFile(fileSys,file3);
    DFSTestUtil.createFile(fileSys,file3,FILE_SIZE,FILE_SIZE,BLOCK_SIZE,replication,SEED);
    checkFile(fileSys,file3,replication);
  }
  finally {
    fileSys.close();
    cluster.shutdown();
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * Test edits.dir.required configuration options.
 * 1. Directory present in dfs.namenode.edits.dir.required but not in
 * dfs.namenode.edits.dir. Expected to fail.
 * 2. Directory present in both dfs.namenode.edits.dir.required and
 * dfs.namenode.edits.dir. Expected to succeed.
 * 3. Directory present only in dfs.namenode.edits.dir. Expected to
 * succeed.
 */
@Test public void testNameEditsRequiredConfigs() throws IOException {
  MiniDFSCluster cluster=null;
  File nameAndEditsDir=new File(base_dir,"name_and_edits");
  File nameAndEditsDir2=new File(base_dir,"name_and_edits2");
  File nameDir=new File(base_dir,"name");
  try {
    Configuration conf=new HdfsConfiguration();
    conf.set(DFSConfigKeys.DFS_NAMENODE_NAME_DIR_KEY,nameDir.getAbsolutePath());
    conf.set(DFSConfigKeys.DFS_NAMENODE_EDITS_DIR_REQUIRED_KEY,nameAndEditsDir2.toURI().toString());
    conf.set(DFSConfigKeys.DFS_NAMENODE_EDITS_DIR_KEY,nameAndEditsDir.toURI().toString());
    cluster=new MiniDFSCluster.Builder(conf).numDataNodes(NUM_DATA_NODES).manageNameDfsDirs(false).build();
    fail("Successfully started cluster but should not have been able to.");
  }
 catch (  IllegalArgumentException iae) {
    LOG.info("EXPECTED: cluster start failed due to bad configuration" + iae);
  }
 finally {
    if (cluster != null) {
      cluster.shutdown();
    }
    cluster=null;
  }
  try {
    Configuration conf=new HdfsConfiguration();
    conf.set(DFSConfigKeys.DFS_NAMENODE_NAME_DIR_KEY,nameDir.getAbsolutePath());
    conf.setStrings(DFSConfigKeys.DFS_NAMENODE_EDITS_DIR_KEY,nameAndEditsDir.toURI().toString(),nameAndEditsDir2.toURI().toString());
    conf.set(DFSConfigKeys.DFS_NAMENODE_EDITS_DIR_REQUIRED_KEY,nameAndEditsDir2.toURI().toString());
    cluster=new MiniDFSCluster.Builder(conf).numDataNodes(NUM_DATA_NODES).manageNameDfsDirs(false).build();
  }
  finally {
    if (cluster != null) {
      cluster.shutdown();
    }
  }
  try {
    Configuration conf=new HdfsConfiguration();
    conf.set(DFSConfigKeys.DFS_NAMENODE_NAME_DIR_KEY,nameDir.getAbsolutePath());
    conf.setStrings(DFSConfigKeys.DFS_NAMENODE_EDITS_DIR_KEY,nameAndEditsDir.toURI().toString(),nameAndEditsDir2.toURI().toString());
    cluster=new MiniDFSCluster.Builder(conf).numDataNodes(NUM_DATA_NODES).manageNameDfsDirs(false).build();
  }
  finally {
    if (cluster != null) {
      cluster.shutdown();
    }
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.server.namenode.TestNamenodeRetryCache </h4><pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test for crateSnapshot
 */
@Test public void testSnapshotMethods() throws Exception {
  String dir="/testNamenodeRetryCache/testCreateSnapshot/src";
  resetCall();
  namesystem.mkdirs(dir,perm,true);
  namesystem.allowSnapshot(dir);
  newCall();
  String name=namesystem.createSnapshot(dir,"snap1");
  Assert.assertEquals(name,namesystem.createSnapshot(dir,"snap1"));
  Assert.assertEquals(name,namesystem.createSnapshot(dir,"snap1"));
  Assert.assertEquals(name,namesystem.createSnapshot(dir,"snap1"));
  newCall();
  try {
    namesystem.createSnapshot(dir,"snap1");
    Assert.fail("testSnapshotMethods expected exception is not thrown");
  }
 catch (  IOException e) {
  }
  newCall();
  namesystem.renameSnapshot(dir,"snap1","snap2");
  namesystem.renameSnapshot(dir,"snap1","snap2");
  namesystem.renameSnapshot(dir,"snap1","snap2");
  newCall();
  try {
    namesystem.renameSnapshot(dir,"snap1","snap2");
    Assert.fail("testSnapshotMethods expected exception is not thrown");
  }
 catch (  IOException e) {
  }
  newCall();
  namesystem.deleteSnapshot(dir,"snap2");
  namesystem.deleteSnapshot(dir,"snap2");
  namesystem.deleteSnapshot(dir,"snap2");
  newCall();
  try {
    namesystem.deleteSnapshot(dir,"snap2");
    Assert.fail("testSnapshotMethods expected exception is not thrown");
  }
 catch (  IOException e) {
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * Tests for concat call
 */
@Test public void testConcat() throws Exception {
  resetCall();
  String file1="/testNamenodeRetryCache/testConcat/file1";
  String file2="/testNamenodeRetryCache/testConcat/file2";
  concatSetup(file1,file2);
  newCall();
  namesystem.concat(file1,new String[]{file2});
  namesystem.concat(file1,new String[]{file2});
  namesystem.concat(file1,new String[]{file2});
  newCall();
  try {
    namesystem.concat(file1,new String[]{file2});
    Assert.fail("testConcat - expected exception is not thrown");
  }
 catch (  IOException e) {
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test for create file
 */
@Test public void testCreate() throws Exception {
  String src="/testNamenodeRetryCache/testCreate/file";
  newCall();
  HdfsFileStatus status=namesystem.startFile(src,perm,"holder","clientmachine",EnumSet.of(CreateFlag.CREATE),true,(short)1,BlockSize,null);
  Assert.assertEquals(status,namesystem.startFile(src,perm,"holder","clientmachine",EnumSet.of(CreateFlag.CREATE),true,(short)1,BlockSize,null));
  Assert.assertEquals(status,namesystem.startFile(src,perm,"holder","clientmachine",EnumSet.of(CreateFlag.CREATE),true,(short)1,BlockSize,null));
  newCall();
  try {
    namesystem.startFile(src,perm,"holder","clientmachine",EnumSet.of(CreateFlag.CREATE),true,(short)1,BlockSize,null);
    Assert.fail("testCreate - expected exception is not thrown");
  }
 catch (  IOException e) {
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test for rename1
 */
@Test public void testAppend() throws Exception {
  String src="/testNamenodeRetryCache/testAppend/src";
  resetCall();
  DFSTestUtil.createFile(filesystem,new Path(src),128,(short)1,0L);
  newCall();
  LocatedBlock b=namesystem.appendFile(src,"holder","clientMachine");
  Assert.assertEquals(b,namesystem.appendFile(src,"holder","clientMachine"));
  Assert.assertEquals(b,namesystem.appendFile(src,"holder","clientMachine"));
  newCall();
  try {
    namesystem.appendFile(src,"holder","clientMachine");
    Assert.fail("testAppend - expected exception is not thrown");
  }
 catch (  Exception e) {
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * Test for rename2
 */
@Test public void testRename2() throws Exception {
  String src="/testNamenodeRetryCache/testRename2/src";
  String target="/testNamenodeRetryCache/testRename2/target";
  resetCall();
  namesystem.mkdirs(src,perm,true);
  newCall();
  namesystem.renameTo(src,target,Rename.NONE);
  namesystem.renameTo(src,target,Rename.NONE);
  namesystem.renameTo(src,target,Rename.NONE);
  newCall();
  try {
    namesystem.renameTo(src,target,Rename.NONE);
    Assert.fail("testRename 2 expected exception is not thrown");
  }
 catch (  IOException e) {
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * Make sure a retry call does not hang because of the exception thrown in the
 * first call.
 */
@Test(timeout=60000) public void testUpdatePipelineWithFailOver() throws Exception {
  cluster.shutdown();
  namesystem=null;
  filesystem=null;
  cluster=new MiniDFSCluster.Builder(conf).nnTopology(MiniDFSNNTopology.simpleHATopology()).numDataNodes(1).build();
  FSNamesystem ns0=cluster.getNamesystem(0);
  ExtendedBlock oldBlock=new ExtendedBlock();
  ExtendedBlock newBlock=new ExtendedBlock();
  DatanodeID[] newNodes=new DatanodeID[2];
  String[] newStorages=new String[2];
  newCall();
  try {
    ns0.updatePipeline("testClient",oldBlock,newBlock,newNodes,newStorages);
    fail("Expect StandbyException from the updatePipeline call");
  }
 catch (  StandbyException e) {
    GenericTestUtils.assertExceptionContains(HAServiceState.STANDBY.toString(),e);
  }
  cluster.transitionToActive(0);
  try {
    ns0.updatePipeline("testClient",oldBlock,newBlock,newNodes,newStorages);
  }
 catch (  IOException e) {
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * Test for createSymlink
 */
@Test public void testCreateSymlink() throws Exception {
  String target="/testNamenodeRetryCache/testCreateSymlink/target";
  newCall();
  namesystem.createSymlink(target,"/a/b",perm,true);
  namesystem.createSymlink(target,"/a/b",perm,true);
  namesystem.createSymlink(target,"/a/b",perm,true);
  newCall();
  try {
    namesystem.createSymlink(target,"/a/b",perm,true);
    Assert.fail("testCreateSymlink - expected exception is not thrown");
  }
 catch (  IOException e) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.server.namenode.TestSaveNamespace </h4><pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test(timeout=20000) public void testCancelSaveNamespace() throws Exception {
  Configuration conf=getConf();
  NameNode.initMetrics(conf,NamenodeRole.NAMENODE);
  DFSTestUtil.formatNameNode(conf);
  FSNamesystem fsn=FSNamesystem.loadFromDisk(conf);
  final FSImage image=fsn.getFSImage();
  NNStorage storage=image.getStorage();
  storage.close();
  storage.setStorageDirectories(FSNamesystem.getNamespaceDirs(conf),FSNamesystem.getNamespaceEditsDirs(conf));
  FSNamesystem spyFsn=spy(fsn);
  final FSNamesystem finalFsn=spyFsn;
  DelayAnswer delayer=new GenericTestUtils.DelayAnswer(LOG);
  doAnswer(delayer).when(spyFsn).getGenerationStampV2();
  ExecutorService pool=Executors.newFixedThreadPool(2);
  try {
    doAnEdit(fsn,1);
    final Canceler canceler=new Canceler();
    fsn.setSafeMode(SafeModeAction.SAFEMODE_ENTER);
    try {
      Future<Void> saverFuture=pool.submit(new Callable<Void>(){
        @Override public Void call() throws Exception {
          image.saveNamespace(finalFsn,NameNodeFile.IMAGE,canceler);
          return null;
        }
      }
);
      delayer.waitForCall();
      Future<Void> cancelFuture=pool.submit(new Callable<Void>(){
        @Override public Void call() throws Exception {
          canceler.cancel("cancelled");
          return null;
        }
      }
);
      Thread.sleep(500);
      delayer.proceed();
      cancelFuture.get();
      saverFuture.get();
      fail("saveNamespace did not fail even though cancelled!");
    }
 catch (    Throwable t) {
      GenericTestUtils.assertExceptionContains("SaveNamespaceCancelledException",t);
    }
    LOG.info("Successfully cancelled a saveNamespace");
    FSImageTestUtil.logStorageContents(LOG,storage);
    for (    StorageDirectory sd : storage.dirIterable(null)) {
      File curDir=sd.getCurrentDir();
      GenericTestUtils.assertGlobEquals(curDir,"fsimage_.*",NNStorage.getImageFileName(0),NNStorage.getImageFileName(0) + MD5FileUtils.MD5_SUFFIX);
    }
  }
  finally {
    if (fsn != null) {
      fsn.close();
    }
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.server.namenode.TestSecondaryNameNodeUpgrade </h4><pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testChangeNsIDFails() throws IOException {
  try {
    doIt(ImmutableMap.of("namespaceID","2"));
    Assert.fail("Should throw InconsistentFSStateException");
  }
 catch (  IOException e) {
    GenericTestUtils.assertExceptionContains("Inconsistent checkpoint fields",e);
    System.out.println("Correctly failed with inconsistent namespaceID: " + e);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.server.namenode.TestSecureNameNode </h4><pre class="type-9 type-2 type-7 type-1 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testName() throws IOException, InterruptedException {
  MiniDFSCluster cluster=null;
  try {
    String keyTabDir=System.getProperty("kdc.resource.dir") + "/keytabs";
    String nn1KeytabPath=keyTabDir + "/nn1.keytab";
    String user1KeyTabPath=keyTabDir + "/user1.keytab";
    Configuration conf=new HdfsConfiguration();
    conf.set(CommonConfigurationKeys.HADOOP_SECURITY_AUTHENTICATION,"kerberos");
    conf.set(DFSConfigKeys.DFS_NAMENODE_KERBEROS_PRINCIPAL_KEY,"nn1/localhost@EXAMPLE.COM");
    conf.set(DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY,nn1KeytabPath);
    cluster=new MiniDFSCluster.Builder(conf).numDataNodes(NUM_OF_DATANODES).build();
    final MiniDFSCluster clusterRef=cluster;
    cluster.waitActive();
    FileSystem fsForCurrentUser=cluster.getFileSystem();
    fsForCurrentUser.mkdirs(new Path("/tmp"));
    fsForCurrentUser.setPermission(new Path("/tmp"),new FsPermission((short)511));
    UserGroupInformation ugi=UserGroupInformation.loginUserFromKeytabAndReturnUGI("user1@EXAMPLE.COM",user1KeyTabPath);
    FileSystem fs=ugi.doAs(new PrivilegedExceptionAction<FileSystem>(){
      @Override public FileSystem run() throws Exception {
        return clusterRef.getFileSystem();
      }
    }
);
    try {
      Path p=new Path("/users");
      fs.mkdirs(p);
      fail("user1 must not be allowed to write in /");
    }
 catch (    IOException expected) {
    }
    Path p=new Path("/tmp/alpha");
    fs.mkdirs(p);
    assertNotNull(fs.listStatus(p));
    assertEquals(AuthenticationMethod.KERBEROS,ugi.getAuthenticationMethod());
  }
  finally {
    if (cluster != null) {
      cluster.shutdown();
    }
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.server.namenode.TestSecureNameNodeWithExternalKdc </h4><pre class="type-9 type-2 type-7 type-1 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testSecureNameNode() throws IOException, InterruptedException {
  MiniDFSCluster cluster=null;
  try {
    String nnPrincipal=System.getProperty("dfs.namenode.kerberos.principal");
    String nnSpnegoPrincipal=System.getProperty("dfs.namenode.kerberos.internal.spnego.principal");
    String nnKeyTab=System.getProperty("dfs.namenode.keytab.file");
    assertNotNull("NameNode principal was not specified",nnPrincipal);
    assertNotNull("NameNode SPNEGO principal was not specified",nnSpnegoPrincipal);
    assertNotNull("NameNode keytab was not specified",nnKeyTab);
    Configuration conf=new HdfsConfiguration();
    conf.set(CommonConfigurationKeys.HADOOP_SECURITY_AUTHENTICATION,"kerberos");
    conf.set(DFSConfigKeys.DFS_NAMENODE_KERBEROS_PRINCIPAL_KEY,nnPrincipal);
    conf.set(DFSConfigKeys.DFS_NAMENODE_KERBEROS_INTERNAL_SPNEGO_PRINCIPAL_KEY,nnSpnegoPrincipal);
    conf.set(DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY,nnKeyTab);
    cluster=new MiniDFSCluster.Builder(conf).numDataNodes(NUM_OF_DATANODES).build();
    final MiniDFSCluster clusterRef=cluster;
    cluster.waitActive();
    FileSystem fsForCurrentUser=cluster.getFileSystem();
    fsForCurrentUser.mkdirs(new Path("/tmp"));
    fsForCurrentUser.setPermission(new Path("/tmp"),new FsPermission((short)511));
    String userPrincipal=System.getProperty("user.principal");
    String userKeyTab=System.getProperty("user.keytab");
    assertNotNull("User principal was not specified",userPrincipal);
    assertNotNull("User keytab was not specified",userKeyTab);
    UserGroupInformation ugi=UserGroupInformation.loginUserFromKeytabAndReturnUGI(userPrincipal,userKeyTab);
    FileSystem fs=ugi.doAs(new PrivilegedExceptionAction<FileSystem>(){
      @Override public FileSystem run() throws Exception {
        return clusterRef.getFileSystem();
      }
    }
);
    try {
      Path p=new Path("/users");
      fs.mkdirs(p);
      fail("User must not be allowed to write in /");
    }
 catch (    IOException expected) {
    }
    Path p=new Path("/tmp/alpha");
    fs.mkdirs(p);
    assertNotNull(fs.listStatus(p));
    assertEquals(AuthenticationMethod.KERBEROS,ugi.getAuthenticationMethod());
  }
  finally {
    if (cluster != null) {
      cluster.shutdown();
    }
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.server.namenode.TestSnapshotPathINodes </h4><pre class="type-9 type-13 type-2 type-7 type-10 type-6 type-20 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values related to public fields.">PublicFieldVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions in iterations
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Verifies values related to public fields.
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test {@link INodeDirectory#getExistingPathINodes(byte[][],int,boolean)} 
 * for snapshot file.
 */
@Test(timeout=15000) public void testSnapshotPathINodes() throws Exception {
  hdfs.allowSnapshot(sub1);
  hdfs.createSnapshot(sub1,"s1");
  String snapshotPath=sub1.toString() + "/.snapshot/s1/file1";
  String[] names=INode.getPathNames(snapshotPath);
  byte[][] components=INode.getPathComponents(names);
  INodesInPath nodesInPath=INodesInPath.resolve(fsdir.rootDir,components);
  INode[] inodes=nodesInPath.getINodes();
  assertEquals(inodes.length,components.length - 1);
  final Snapshot snapshot=getSnapshot(nodesInPath,"s1");
  assertSnapshot(nodesInPath,true,snapshot,3);
  INode snapshotFileNode=inodes[inodes.length - 1];
  assertINodeFile(snapshotFileNode,file1);
  assertTrue(snapshotFileNode.getParent().isWithSnapshot());
  nodesInPath=INodesInPath.resolve(fsdir.rootDir,components,1,false);
  inodes=nodesInPath.getINodes();
  assertEquals(inodes.length,1);
  assertSnapshot(nodesInPath,true,snapshot,-1);
  assertINodeFile(nodesInPath.getLastINode(),file1);
  nodesInPath=INodesInPath.resolve(fsdir.rootDir,components,2,false);
  inodes=nodesInPath.getINodes();
  assertEquals(inodes.length,2);
  assertSnapshot(nodesInPath,true,snapshot,0);
  assertINodeFile(nodesInPath.getLastINode(),file1);
  String dotSnapshotPath=sub1.toString() + "/.snapshot";
  names=INode.getPathNames(dotSnapshotPath);
  components=INode.getPathComponents(names);
  nodesInPath=INodesInPath.resolve(fsdir.rootDir,components);
  inodes=nodesInPath.getINodes();
  assertEquals(inodes.length,components.length - 1);
  assertSnapshot(nodesInPath,true,snapshot,-1);
  final INode last=nodesInPath.getLastINode();
  assertEquals(last.getFullPathName(),sub1.toString());
  assertFalse(last instanceof INodeFile);
  String[] invalidPathComponent={"invalidDir","foo",".snapshot","bar"};
  Path invalidPath=new Path(invalidPathComponent[0]);
  for (int i=1; i < invalidPathComponent.length; i++) {
    invalidPath=new Path(invalidPath,invalidPathComponent[i]);
    try {
      hdfs.getFileStatus(invalidPath);
      Assert.fail();
    }
 catch (    FileNotFoundException fnfe) {
      System.out.println("The exception is expected: " + fnfe);
    }
  }
  hdfs.deleteSnapshot(sub1,"s1");
  hdfs.disallowSnapshot(sub1);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.server.namenode.TestStartup </h4><pre class="type-2 type-7 type-1 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * secnn-7
 * secondary node copies fsimage and edits into correct separate directories.
 * @throws IOException
 */
@Test public void testSNNStartup() throws IOException {
  LOG.info("--starting SecondNN startup test");
  config.set(DFSConfigKeys.DFS_NAMENODE_NAME_DIR_KEY,fileAsURI(new File(hdfsDir,"name")).toString());
  config.set(DFSConfigKeys.DFS_NAMENODE_EDITS_DIR_KEY,fileAsURI(new File(hdfsDir,"name")).toString());
  config.set(DFSConfigKeys.DFS_NAMENODE_CHECKPOINT_EDITS_DIR_KEY,fileAsURI(new File(hdfsDir,"chkpt_edits")).toString());
  config.set(DFSConfigKeys.DFS_NAMENODE_CHECKPOINT_DIR_KEY,fileAsURI(new File(hdfsDir,"chkpt")).toString());
  LOG.info("--starting NN ");
  MiniDFSCluster cluster=null;
  SecondaryNameNode sn=null;
  NameNode nn=null;
  try {
    cluster=new MiniDFSCluster.Builder(config).manageDataDfsDirs(false).manageNameDfsDirs(false).build();
    cluster.waitActive();
    nn=cluster.getNameNode();
    assertNotNull(nn);
    LOG.info("--starting SecondNN");
    sn=new SecondaryNameNode(config);
    assertNotNull(sn);
    LOG.info("--doing checkpoint");
    sn.doCheckpoint();
    LOG.info("--done checkpoint");
    FSImage image=nn.getFSImage();
    StorageDirectory sd=image.getStorage().getStorageDir(0);
    assertEquals(sd.getStorageDirType(),NameNodeDirType.IMAGE_AND_EDITS);
    image.getStorage();
    File imf=NNStorage.getStorageFile(sd,NameNodeFile.IMAGE,0);
    image.getStorage();
    File edf=NNStorage.getStorageFile(sd,NameNodeFile.EDITS,0);
    LOG.info("--image file " + imf.getAbsolutePath() + "; len = "+ imf.length());
    LOG.info("--edits file " + edf.getAbsolutePath() + "; len = "+ edf.length());
    FSImage chkpImage=sn.getFSImage();
    verifyDifferentDirs(chkpImage,imf.length(),edf.length());
  }
 catch (  IOException e) {
    fail(StringUtils.stringifyException(e));
    System.err.println("checkpoint failed");
    throw e;
  }
 finally {
    if (sn != null)     sn.shutdown();
    if (cluster != null)     cluster.shutdown();
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=120000) public void testXattrConfiguration() throws Exception {
  Configuration conf=new HdfsConfiguration();
  MiniDFSCluster cluster=null;
  try {
    conf.setInt(DFSConfigKeys.DFS_NAMENODE_MAX_XATTR_SIZE_KEY,-1);
    cluster=new MiniDFSCluster.Builder(conf).numDataNodes(0).format(true).build();
    fail("Expected exception with negative xattr size");
  }
 catch (  IllegalArgumentException e) {
    GenericTestUtils.assertExceptionContains("Cannot set a negative value for the maximum size of an xattr",e);
  }
 finally {
    conf.setInt(DFSConfigKeys.DFS_NAMENODE_MAX_XATTR_SIZE_KEY,DFSConfigKeys.DFS_NAMENODE_MAX_XATTR_SIZE_DEFAULT);
    if (cluster != null) {
      cluster.shutdown();
    }
  }
  try {
    conf.setInt(DFSConfigKeys.DFS_NAMENODE_MAX_XATTRS_PER_INODE_KEY,-1);
    cluster=new MiniDFSCluster.Builder(conf).numDataNodes(0).format(true).build();
    fail("Expected exception with negative # xattrs per inode");
  }
 catch (  IllegalArgumentException e) {
    GenericTestUtils.assertExceptionContains("Cannot set a negative limit on the number of xattrs per inode",e);
  }
 finally {
    conf.setInt(DFSConfigKeys.DFS_NAMENODE_MAX_XATTRS_PER_INODE_KEY,DFSConfigKeys.DFS_NAMENODE_MAX_XATTRS_PER_INODE_DEFAULT);
    if (cluster != null) {
      cluster.shutdown();
    }
  }
  try {
    final LogVerificationAppender appender=new LogVerificationAppender();
    final Logger logger=Logger.getRootLogger();
    logger.addAppender(appender);
    int count=appender.countLinesWithMessage("Maximum size of an xattr: 0 (unlimited)");
    assertEquals("Expected no messages about unlimited xattr size",0,count);
    conf.setInt(DFSConfigKeys.DFS_NAMENODE_MAX_XATTR_SIZE_KEY,0);
    cluster=new MiniDFSCluster.Builder(conf).numDataNodes(0).format(true).build();
    count=appender.countLinesWithMessage("Maximum size of an xattr: 0 (unlimited)");
    assertEquals("Expected unlimited xattr size",2,count);
  }
  finally {
    conf.setInt(DFSConfigKeys.DFS_NAMENODE_MAX_XATTR_SIZE_KEY,DFSConfigKeys.DFS_NAMENODE_MAX_XATTR_SIZE_DEFAULT);
    if (cluster != null) {
      cluster.shutdown();
    }
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-10 type-1 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects are null
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * This test tests hosts include list contains host names.  After namenode
 * restarts, the still alive datanodes should not have any trouble in getting
 * registrant again.
 */
@Test public void testNNRestart() throws IOException, InterruptedException {
  MiniDFSCluster cluster=null;
  FileSystem localFileSys;
  Path hostsFile;
  Path excludeFile;
  int HEARTBEAT_INTERVAL=1;
  localFileSys=FileSystem.getLocal(config);
  Path workingDir=localFileSys.getWorkingDirectory();
  Path dir=new Path(workingDir,"build/test/data/work-dir/restartnn");
  hostsFile=new Path(dir,"hosts");
  excludeFile=new Path(dir,"exclude");
  config.set(DFSConfigKeys.DFS_HOSTS_EXCLUDE,excludeFile.toUri().getPath());
  writeConfigFile(localFileSys,excludeFile,null);
  config.set(DFSConfigKeys.DFS_HOSTS,hostsFile.toUri().getPath());
  ArrayList<String> list=new ArrayList<String>();
  byte b[]={127,0,0,1};
  InetAddress inetAddress=InetAddress.getByAddress(b);
  list.add(inetAddress.getHostName());
  writeConfigFile(localFileSys,hostsFile,list);
  int numDatanodes=1;
  try {
    cluster=new MiniDFSCluster.Builder(config).numDataNodes(numDatanodes).setupHostsFile(true).build();
    cluster.waitActive();
    cluster.restartNameNode();
    NamenodeProtocols nn=cluster.getNameNodeRpc();
    assertNotNull(nn);
    assertTrue(cluster.isDataNodeUp());
    DatanodeInfo[] info=nn.getDatanodeReport(DatanodeReportType.LIVE);
    for (int i=0; i < 5 && info.length != numDatanodes; i++) {
      Thread.sleep(HEARTBEAT_INTERVAL * 1000);
      info=nn.getDatanodeReport(DatanodeReportType.LIVE);
    }
    assertEquals("Number of live nodes should be " + numDatanodes,numDatanodes,info.length);
  }
 catch (  IOException e) {
    fail(StringUtils.stringifyException(e));
    throw e;
  }
 finally {
    cleanupFile(localFileSys,excludeFile.getParent());
    if (cluster != null) {
      cluster.shutdown();
    }
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.server.namenode.TestTransferFsImage </h4><pre class="type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Regression test for HDFS-1997. Test that, if an exception
 * occurs on the client side, it is properly reported as such,
 * and reported to the associated NNStorage object.
 */
@Test public void testClientSideException() throws IOException {
  Configuration conf=new HdfsConfiguration();
  MiniDFSCluster cluster=new MiniDFSCluster.Builder(conf).numDataNodes(0).build();
  NNStorage mockStorage=Mockito.mock(NNStorage.class);
  List<File> localPath=Collections.singletonList(new File("/xxxxx-does-not-exist/blah"));
  try {
    URL fsName=DFSUtil.getInfoServer(cluster.getNameNode().getServiceRpcAddress(),conf,DFSUtil.getHttpClientScheme(conf)).toURL();
    String id="getimage=1&txid=0";
    TransferFsImage.getFileClient(fsName,id,localPath,mockStorage,false);
    fail("Didn't get an exception!");
  }
 catch (  IOException ioe) {
    Mockito.verify(mockStorage).reportErrorOnFile(localPath.get(0));
    assertTrue("Unexpected exception: " + StringUtils.stringifyException(ioe),ioe.getMessage().contains("Unable to download to any storage"));
  }
 finally {
    cluster.shutdown();
  }
}

</code></pre>

<br>
<pre class="type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test to verify the timeout of Image upload
 */
@Test(timeout=10000) public void testImageUploadTimeout() throws Exception {
  Configuration conf=new HdfsConfiguration();
  NNStorage mockStorage=Mockito.mock(NNStorage.class);
  HttpServer2 testServer=HttpServerFunctionalTest.createServer("hdfs");
  try {
    testServer.addServlet("ImageTransfer",ImageServlet.PATH_SPEC,TestImageTransferServlet.class);
    testServer.start();
    URL serverURL=HttpServerFunctionalTest.getServerURL(testServer);
    TransferFsImage.timeout=2000;
    File tmpDir=new File(new FileSystemTestHelper().getTestRootDir());
    tmpDir.mkdirs();
    File mockImageFile=File.createTempFile("image","",tmpDir);
    FileOutputStream imageFile=new FileOutputStream(mockImageFile);
    imageFile.write("data".getBytes());
    imageFile.close();
    Mockito.when(mockStorage.findImageFile(Mockito.any(NameNodeFile.class),Mockito.anyLong())).thenReturn(mockImageFile);
    Mockito.when(mockStorage.toColonSeparatedString()).thenReturn("storage:info:string");
    try {
      TransferFsImage.uploadImageFromStorage(serverURL,conf,mockStorage,NameNodeFile.IMAGE,1L);
      fail("TransferImage Should fail with timeout");
    }
 catch (    SocketTimeoutException e) {
      assertEquals("Upload should timeout","Read timed out",e.getMessage());
    }
  }
  finally {
    testServer.stop();
  }
}

</code></pre>

<br>
<pre class="type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test to verify the read timeout
 */
@Test(timeout=5000) public void testGetImageTimeout() throws Exception {
  HttpServer2 testServer=HttpServerFunctionalTest.createServer("hdfs");
  try {
    testServer.addServlet("ImageTransfer",ImageServlet.PATH_SPEC,TestImageTransferServlet.class);
    testServer.start();
    URL serverURL=HttpServerFunctionalTest.getServerURL(testServer);
    TransferFsImage.timeout=2000;
    try {
      TransferFsImage.getFileClient(serverURL,"txid=1",null,null,false);
      fail("TransferImage Should fail with timeout");
    }
 catch (    SocketTimeoutException e) {
      assertEquals("Read should timeout","Read timed out",e.getMessage());
    }
  }
  finally {
    if (testServer != null) {
      testServer.stop();
    }
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.server.namenode.ha.TestBootstrapStandby </h4><pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test for the base success case. The primary NN
 * hasn't made any checkpoints, and we copy the fsimage_0
 * file over and start up.
 */
@Test public void testSuccessfulBaseCase() throws Exception {
  removeStandbyNameDirs();
  try {
    cluster.restartNameNode(1);
    fail("Did not throw");
  }
 catch (  IOException ioe) {
    GenericTestUtils.assertExceptionContains("storage directory does not exist or is not accessible",ioe);
  }
  int rc=BootstrapStandby.run(new String[]{"-nonInteractive"},cluster.getConfiguration(1));
  assertEquals(0,rc);
  FSImageTestUtil.assertNNHasCheckpoints(cluster,1,ImmutableList.of(0));
  FSImageTestUtil.assertNNFilesMatch(cluster);
  cluster.restartNameNode(1);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.server.namenode.ha.TestDFSUpgradeWithHA </h4><pre class="type-9 type-2 type-7 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Make sure that starting a second NN with the -upgrade flag fails if the
 * other NN has already done that.
 */
@Test public void testCannotUpgradeSecondNameNode() throws IOException, URISyntaxException {
  MiniDFSCluster cluster=null;
  FileSystem fs=null;
  try {
    cluster=new MiniDFSCluster.Builder(conf).nnTopology(MiniDFSNNTopology.simpleHATopology()).numDataNodes(0).build();
    File sharedDir=new File(cluster.getSharedEditsDir(0,1));
    checkClusterPreviousDirExistence(cluster,false);
    assertCTimesEqual(cluster);
    checkPreviousDirExistence(sharedDir,false);
    cluster.transitionToActive(0);
    fs=HATestUtil.configureFailoverFs(cluster,conf);
    assertTrue(fs.mkdirs(new Path("/foo1")));
    cluster.shutdownNameNode(1);
    cluster.getNameNodeInfos()[0].setStartOpt(StartupOption.UPGRADE);
    cluster.restartNameNode(0,false);
    checkNnPreviousDirExistence(cluster,0,true);
    checkNnPreviousDirExistence(cluster,1,false);
    checkPreviousDirExistence(sharedDir,true);
    assertTrue(fs.mkdirs(new Path("/foo2")));
    cluster.getNameNodeInfos()[0].setStartOpt(StartupOption.REGULAR);
    cluster.restartNameNode(0,false);
    cluster.transitionToActive(0);
    assertTrue(fs.mkdirs(new Path("/foo3")));
    cluster.getNameNodeInfos()[1].setStartOpt(StartupOption.UPGRADE);
    try {
      cluster.restartNameNode(1,false);
      fail("Should not have been able to start second NN with -upgrade");
    }
 catch (    IOException ioe) {
      GenericTestUtils.assertExceptionContains("It looks like the shared log is already being upgraded",ioe);
    }
  }
  finally {
    if (fs != null) {
      fs.close();
    }
    if (cluster != null) {
      cluster.shutdown();
    }
  }
}

</code></pre>

<br>
<pre class="type-9 type-2 type-7 type-10 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Ensure that an admin cannot finalize an HA upgrade without at least one NN
 * being active.
 */
@Test public void testCannotFinalizeIfNoActive() throws IOException, URISyntaxException {
  MiniDFSCluster cluster=null;
  FileSystem fs=null;
  try {
    cluster=new MiniDFSCluster.Builder(conf).nnTopology(MiniDFSNNTopology.simpleHATopology()).numDataNodes(0).build();
    File sharedDir=new File(cluster.getSharedEditsDir(0,1));
    checkClusterPreviousDirExistence(cluster,false);
    assertCTimesEqual(cluster);
    checkPreviousDirExistence(sharedDir,false);
    cluster.transitionToActive(0);
    fs=HATestUtil.configureFailoverFs(cluster,conf);
    assertTrue(fs.mkdirs(new Path("/foo1")));
    cluster.shutdownNameNode(1);
    cluster.getNameNodeInfos()[0].setStartOpt(StartupOption.UPGRADE);
    cluster.restartNameNode(0,false);
    checkNnPreviousDirExistence(cluster,0,true);
    checkNnPreviousDirExistence(cluster,1,false);
    checkPreviousDirExistence(sharedDir,true);
    assertTrue(fs.mkdirs(new Path("/foo2")));
    cluster.getNameNodeInfos()[0].setStartOpt(StartupOption.REGULAR);
    cluster.restartNameNode(0,false);
    cluster.transitionToActive(0);
    assertTrue(fs.mkdirs(new Path("/foo3")));
    int rc=BootstrapStandby.run(new String[]{"-force"},cluster.getConfiguration(1));
    assertEquals(0,rc);
    cluster.restartNameNode(1);
    cluster.transitionToStandby(0);
    cluster.transitionToActive(1);
    assertTrue(fs.mkdirs(new Path("/foo4")));
    assertCTimesEqual(cluster);
    cluster.transitionToStandby(1);
    try {
      runFinalizeCommand(cluster);
      fail("Should not have been able to finalize upgrade with no NN active");
    }
 catch (    IOException ioe) {
      GenericTestUtils.assertExceptionContains("Cannot finalize with no NameNode active",ioe);
    }
  }
  finally {
    if (fs != null) {
      fs.close();
    }
    if (cluster != null) {
      cluster.shutdown();
    }
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.server.namenode.ha.TestDelegationTokensWithHA </h4><pre class="type-9 type-2 type-7 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test if StandbyException can be thrown from StandbyNN, when it's requested for 
 * password. (HDFS-6475). With StandbyException, the client can failover to try
 * activeNN.
 */
@Test public void testDelegationTokenStandbyNNAppearFirst() throws Exception {
  cluster.transitionToStandby(0);
  cluster.transitionToActive(1);
  final DelegationTokenSecretManager stSecretManager=NameNodeAdapter.getDtSecretManager(nn1.getNamesystem());
  final Token<DelegationTokenIdentifier> token=getDelegationToken(fs,"JobTracker");
  final DelegationTokenIdentifier identifier=new DelegationTokenIdentifier();
  byte[] tokenId=token.getIdentifier();
  identifier.readFields(new DataInputStream(new ByteArrayInputStream(tokenId)));
  assertTrue(null != stSecretManager.retrievePassword(identifier));
  final UserGroupInformation ugi=UserGroupInformation.createRemoteUser("JobTracker");
  ugi.addToken(token);
  ugi.doAs(new PrivilegedExceptionAction(){
    @Override public Object run(){
      try {
        try {
          byte[] tmppw=dtSecretManager.retrievePassword(identifier);
          fail("InvalidToken with cause StandbyException is expected" + " since nn0 is standby");
          return tmppw;
        }
 catch (        IOException e) {
          throw new SecurityException("Failed to obtain user group information: " + e,e);
        }
      }
 catch (      Exception oe) {
        HttpServletResponse response=mock(HttpServletResponse.class);
        ExceptionHandler eh=new ExceptionHandler();
        eh.initResponse(response);
        Response resp=eh.toResponse(oe);
        Map<?,?> m=(Map<?,?>)JSON.parse(resp.getEntity().toString());
        RemoteException re=JsonUtil.toRemoteException(m);
        Exception unwrapped=((RemoteException)re).unwrapRemoteException(StandbyException.class);
        assertTrue(unwrapped instanceof StandbyException);
        return null;
      }
    }
  }
);
}

</code></pre>

<br>
<pre class="type-2 type-7 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test if correct exception (StandbyException or RetriableException) can be
 * thrown during the NN failover. 
 */
@Test public void testDelegationTokenDuringNNFailover() throws Exception {
  EditLogTailer editLogTailer=nn1.getNamesystem().getEditLogTailer();
  editLogTailer.stop();
  Configuration conf=(Configuration)Whitebox.getInternalState(editLogTailer,"conf");
  nn1.getNamesystem().setEditLogTailerForTests(new EditLogTailerForTest(nn1.getNamesystem(),conf));
  final Token<DelegationTokenIdentifier> token=getDelegationToken(fs,"JobTracker");
  DelegationTokenIdentifier identifier=new DelegationTokenIdentifier();
  byte[] tokenId=token.getIdentifier();
  identifier.readFields(new DataInputStream(new ByteArrayInputStream(tokenId)));
  LOG.info("A valid token should have non-null password, " + "and should be renewed successfully");
  assertTrue(null != dtSecretManager.retrievePassword(identifier));
  dtSecretManager.renewToken(token,"JobTracker");
  cluster.transitionToStandby(0);
  try {
    cluster.getNameNodeRpc(0).renewDelegationToken(token);
    fail("StandbyException is expected since nn0 is in standby state");
  }
 catch (  StandbyException e) {
    GenericTestUtils.assertExceptionContains(HAServiceState.STANDBY.toString(),e);
  }
  new Thread(){
    @Override public void run(){
      try {
        cluster.transitionToActive(1);
      }
 catch (      Exception e) {
        LOG.error("Transition nn1 to active failed",e);
      }
    }
  }
.start();
  Thread.sleep(1000);
  try {
    nn1.getNamesystem().verifyToken(token.decodeIdentifier(),token.getPassword());
    fail("RetriableException/StandbyException is expected since nn1 is in transition");
  }
 catch (  IOException e) {
    assertTrue(e instanceof StandbyException || e instanceof RetriableException);
    LOG.info("Got expected exception",e);
  }
  catchup=true;
synchronized (this) {
    this.notifyAll();
  }
  Configuration clientConf=dfs.getConf();
  doRenewOrCancel(token,clientConf,TokenTestAction.RENEW);
  doRenewOrCancel(token,clientConf,TokenTestAction.CANCEL);
}

</code></pre>

<br>
<pre class="type-2 type-7 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testDelegationTokenDFSApi() throws Exception {
  final Token<DelegationTokenIdentifier> token=getDelegationToken(fs,"JobTracker");
  DelegationTokenIdentifier identifier=new DelegationTokenIdentifier();
  byte[] tokenId=token.getIdentifier();
  identifier.readFields(new DataInputStream(new ByteArrayInputStream(tokenId)));
  LOG.info("A valid token should have non-null password, " + "and should be renewed successfully");
  assertTrue(null != dtSecretManager.retrievePassword(identifier));
  dtSecretManager.renewToken(token,"JobTracker");
  Configuration clientConf=dfs.getConf();
  doRenewOrCancel(token,clientConf,TokenTestAction.RENEW);
  Configuration emptyConf=new Configuration();
  try {
    doRenewOrCancel(token,emptyConf,TokenTestAction.RENEW);
    fail("Did not throw trying to renew with an empty conf!");
  }
 catch (  IOException ioe) {
    GenericTestUtils.assertExceptionContains("Unable to map logical nameservice URI",ioe);
  }
  cluster.transitionToStandby(0);
  cluster.transitionToActive(1);
  doRenewOrCancel(token,clientConf,TokenTestAction.RENEW);
  doRenewOrCancel(token,clientConf,TokenTestAction.CANCEL);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.server.namenode.ha.TestFailoverWithBlockTokensEnabled </h4><pre class="type-9 type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void ensureInvalidBlockTokensAreRejected() throws IOException, URISyntaxException {
  cluster.transitionToActive(0);
  FileSystem fs=HATestUtil.configureFailoverFs(cluster,conf);
  DFSTestUtil.writeFile(fs,TEST_PATH,TEST_DATA);
  assertEquals(TEST_DATA,DFSTestUtil.readFile(fs,TEST_PATH));
  DFSClient dfsClient=DFSClientAdapter.getDFSClient((DistributedFileSystem)fs);
  DFSClient spyDfsClient=Mockito.spy(dfsClient);
  Mockito.doAnswer(new Answer<LocatedBlocks>(){
    @Override public LocatedBlocks answer(    InvocationOnMock arg0) throws Throwable {
      LocatedBlocks locatedBlocks=(LocatedBlocks)arg0.callRealMethod();
      for (      LocatedBlock lb : locatedBlocks.getLocatedBlocks()) {
        Token<BlockTokenIdentifier> token=lb.getBlockToken();
        BlockTokenIdentifier id=lb.getBlockToken().decodeIdentifier();
        id.setExpiryDate(Time.now() + 10);
        Token<BlockTokenIdentifier> newToken=new Token<BlockTokenIdentifier>(id.getBytes(),token.getPassword(),token.getKind(),token.getService());
        lb.setBlockToken(newToken);
      }
      return locatedBlocks;
    }
  }
).when(spyDfsClient).getLocatedBlocks(Mockito.anyString(),Mockito.anyLong(),Mockito.anyLong());
  DFSClientAdapter.setDFSClient((DistributedFileSystem)fs,spyDfsClient);
  try {
    assertEquals(TEST_DATA,DFSTestUtil.readFile(fs,TEST_PATH));
    fail("Shouldn't have been able to read a file with invalid block tokens");
  }
 catch (  IOException ioe) {
    GenericTestUtils.assertExceptionContains("Could not obtain block",ioe);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.server.namenode.ha.TestFailureOfSharedDir </h4><pre class="type-9 type-2 type-7 type-10 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test that marking the shared edits dir as being "required" causes the NN to
 * fail if that dir can't be accessed.
 */
@Test public void testFailureOfSharedDir() throws Exception {
  Configuration conf=new Configuration();
  conf.setLong(DFS_NAMENODE_RESOURCE_CHECK_INTERVAL_KEY,2000);
  MiniDFSCluster cluster=null;
  File sharedEditsDir=null;
  try {
    cluster=new MiniDFSCluster.Builder(conf).nnTopology(MiniDFSNNTopology.simpleHATopology()).numDataNodes(0).checkExitOnShutdown(false).build();
    cluster.waitActive();
    cluster.transitionToActive(0);
    FileSystem fs=HATestUtil.configureFailoverFs(cluster,conf);
    assertTrue(fs.mkdirs(new Path("/test1")));
    URI sharedEditsUri=cluster.getSharedEditsDir(0,1);
    sharedEditsDir=new File(sharedEditsUri);
    assertEquals(0,FileUtil.chmod(sharedEditsDir.getAbsolutePath(),"-w",true));
    Thread.sleep(conf.getLong(DFS_NAMENODE_RESOURCE_CHECK_INTERVAL_KEY,DFS_NAMENODE_RESOURCE_CHECK_INTERVAL_DEFAULT) * 2);
    NameNode nn1=cluster.getNameNode(1);
    assertTrue(nn1.isStandbyState());
    assertFalse("StandBy NameNode should not go to SafeMode on resource unavailability",nn1.isInSafeMode());
    NameNode nn0=cluster.getNameNode(0);
    try {
      nn0.getRpcServer().rollEditLog();
      fail("Succeeded in rolling edit log despite shared dir being deleted");
    }
 catch (    ExitException ee) {
      GenericTestUtils.assertExceptionContains("finalize log segment 1, 3 failed for required journal",ee);
    }
    for (    URI editsUri : cluster.getNameEditsDirs(0)) {
      if (editsUri.equals(sharedEditsUri)) {
        continue;
      }
      File editsDir=new File(editsUri.getPath());
      File curDir=new File(editsDir,"current");
      GenericTestUtils.assertGlobEquals(curDir,"edits_.*",NNStorage.getInProgressEditsFileName(1));
    }
  }
  finally {
    if (sharedEditsDir != null) {
      FileUtil.chmod(sharedEditsDir.getAbsolutePath(),"+w",true);
    }
    if (cluster != null) {
      cluster.shutdown();
    }
  }
}

</code></pre>

<br>
<pre class="type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Multiple shared edits directories is an invalid configuration.
 */
@Test public void testMultipleSharedDirsFails() throws Exception {
  Configuration conf=new Configuration();
  URI sharedA=new URI("file:///shared-A");
  URI sharedB=new URI("file:///shared-B");
  URI localA=new URI("file:///local-A");
  conf.set(DFSConfigKeys.DFS_NAMENODE_SHARED_EDITS_DIR_KEY,Joiner.on(",").join(sharedA,sharedB));
  conf.set(DFSConfigKeys.DFS_NAMENODE_EDITS_DIR_KEY,localA.toString());
  try {
    FSNamesystem.getNamespaceEditsDirs(conf);
    fail("Allowed multiple shared edits directories");
  }
 catch (  IOException ioe) {
    assertEquals("Multiple shared edits directories are not yet supported",ioe.getMessage());
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.server.namenode.ha.TestFailureToReadEdits </h4><pre class="type-2 type-7 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Ensure that the standby fails to become active if it cannot read all
 * available edits in the shared edits dir when it is transitioning to active
 * state.
 */
@Test public void testFailureToReadEditsOnTransitionToActive() throws Exception {
  assertTrue(fs.mkdirs(new Path(TEST_DIR1)));
  HATestUtil.waitForStandbyToCatchUp(nn0,nn1);
  HATestUtil.waitForCheckpoint(cluster,0,ImmutableList.of(0,3));
  causeFailureOnEditLogRead();
  assertTrue(fs.mkdirs(new Path(TEST_DIR2)));
  assertTrue(fs.mkdirs(new Path(TEST_DIR3)));
  try {
    HATestUtil.waitForStandbyToCatchUp(nn0,nn1);
    fail("Standby fully caught up, but should not have been able to");
  }
 catch (  HATestUtil.CouldNotCatchUpException e) {
  }
  cluster.shutdownNameNode(0);
  try {
    cluster.transitionToActive(1);
    fail("Standby transitioned to active, but should not have been able to");
  }
 catch (  ExitException ee) {
    GenericTestUtils.assertExceptionContains("Error replaying edit log",ee);
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-10 type-1 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test that the standby NN won't double-replay earlier edits if it encounters
 * a failure to read a later edit.
 */
@Test public void testFailuretoReadEdits() throws Exception {
  assertTrue(fs.mkdirs(new Path(TEST_DIR1)));
  HATestUtil.waitForStandbyToCatchUp(nn0,nn1);
  fs.setOwner(new Path(TEST_DIR1),"foo","bar");
  assertTrue(fs.delete(new Path(TEST_DIR1),true));
  assertTrue(fs.mkdirs(new Path(TEST_DIR2)));
  assertTrue(fs.mkdirs(new Path(TEST_DIR3)));
  LimitedEditLogAnswer answer=causeFailureOnEditLogRead();
  try {
    HATestUtil.waitForStandbyToCatchUp(nn0,nn1);
    fail("Standby fully caught up, but should not have been able to");
  }
 catch (  HATestUtil.CouldNotCatchUpException e) {
  }
  assertNull(NameNodeAdapter.getFileInfo(nn1,TEST_DIR1,false));
  assertTrue(NameNodeAdapter.getFileInfo(nn1,TEST_DIR2,false).isDir());
  assertNull(NameNodeAdapter.getFileInfo(nn1,TEST_DIR3,false));
  answer.setThrowExceptionOnRead(false);
  HATestUtil.waitForStandbyToCatchUp(nn0,nn1);
  assertNull(NameNodeAdapter.getFileInfo(nn1,TEST_DIR1,false));
  assertTrue(NameNodeAdapter.getFileInfo(nn1,TEST_DIR2,false).isDir());
  assertTrue(NameNodeAdapter.getFileInfo(nn1,TEST_DIR3,false).isDir());
}

</code></pre>

<br>
<pre class="type-9 type-2 type-7 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test the following case:
 * 1. SBN is reading a finalized edits file when NFS disappears halfway
 * through (or some intermittent error happens)
 * 2. SBN performs a checkpoint and uploads it to the NN
 * 3. NN receives a checkpoint that doesn't correspond to the end of any log
 * segment
 * 4. Both NN and SBN should be able to restart at this point.
 * This is a regression test for HDFS-2766.
 */
@Test public void testCheckpointStartingMidEditsFile() throws Exception {
  assertTrue(fs.mkdirs(new Path(TEST_DIR1)));
  HATestUtil.waitForStandbyToCatchUp(nn0,nn1);
  HATestUtil.waitForCheckpoint(cluster,1,ImmutableList.of(0,3));
  HATestUtil.waitForCheckpoint(cluster,0,ImmutableList.of(0,3));
  causeFailureOnEditLogRead();
  assertTrue(fs.mkdirs(new Path(TEST_DIR2)));
  assertTrue(fs.mkdirs(new Path(TEST_DIR3)));
  try {
    HATestUtil.waitForStandbyToCatchUp(nn0,nn1);
    fail("Standby fully caught up, but should not have been able to");
  }
 catch (  HATestUtil.CouldNotCatchUpException e) {
  }
  HATestUtil.waitForCheckpoint(cluster,1,ImmutableList.of(0,3,5));
  HATestUtil.waitForCheckpoint(cluster,0,ImmutableList.of(0,3,5));
  cluster.restartNameNode(0);
  HATestUtil.waitForCheckpoint(cluster,0,ImmutableList.of(0,3,5));
  FileSystem fs0=null;
  try {
    fs0=FileSystem.get(NameNode.getUri(nn0.getNameNodeAddress()),conf);
    assertTrue(fs0.exists(new Path(TEST_DIR1)));
    assertTrue(fs0.exists(new Path(TEST_DIR2)));
    assertTrue(fs0.exists(new Path(TEST_DIR3)));
  }
  finally {
    if (fs0 != null)     fs0.close();
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.server.namenode.ha.TestHAConfiguration </h4><pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testCheckpointerValidityChecks() throws Exception {
  try {
    Configuration conf=new Configuration();
    new StandbyCheckpointer(conf,fsn);
    fail("Bad config did not throw an error");
  }
 catch (  IllegalArgumentException iae) {
    GenericTestUtils.assertExceptionContains("Invalid URI for NameNode address",iae);
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * Test that the 2NN does not start if given a config with HA NNs.
 */
@Test public void testSecondaryNameNodeDoesNotStart() throws IOException {
  Configuration conf=getHAConf("ns1","1.2.3.1","1.2.3.2");
  try {
    new SecondaryNameNode(conf);
    fail("Created a 2NN with an HA config");
  }
 catch (  IOException ioe) {
    GenericTestUtils.assertExceptionContains("Cannot use SecondaryNameNode in an HA cluster",ioe);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.server.namenode.ha.TestHASafeMode </h4><pre class="type-11 type-2 type-7 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * DFS#isInSafeMode should check the ActiveNNs safemode in HA enabled cluster. HDFS-3507
 * @throws Exception
 */
@Test public void testIsInSafemode() throws Exception {
  NameNode nn2=cluster.getNameNode(1);
  assertTrue("nn2 should be in standby state",nn2.isStandbyState());
  InetSocketAddress nameNodeAddress=nn2.getNameNodeAddress();
  Configuration conf=new Configuration();
  DistributedFileSystem dfs=new DistributedFileSystem();
  try {
    dfs.initialize(URI.create("hdfs://" + nameNodeAddress.getHostName() + ":"+ nameNodeAddress.getPort()),conf);
    dfs.isInSafeMode();
    fail("StandBy should throw exception for isInSafeMode");
  }
 catch (  IOException e) {
    if (e instanceof RemoteException) {
      IOException sbExcpetion=((RemoteException)e).unwrapRemoteException();
      assertTrue("StandBy nn should not support isInSafeMode",sbExcpetion instanceof StandbyException);
    }
 else {
      throw e;
    }
  }
 finally {
    if (null != dfs) {
      dfs.close();
    }
  }
  cluster.transitionToStandby(0);
  cluster.transitionToActive(1);
  cluster.getNameNodeRpc(1).setSafeMode(SafeModeAction.SAFEMODE_ENTER,false);
  DistributedFileSystem dfsWithFailOver=(DistributedFileSystem)fs;
  assertTrue("ANN should be in SafeMode",dfsWithFailOver.isInSafeMode());
  cluster.getNameNodeRpc(1).setSafeMode(SafeModeAction.SAFEMODE_LEAVE,false);
  assertFalse("ANN should be out of SafeMode",dfsWithFailOver.isInSafeMode());
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.server.namenode.ha.TestHAStateTransitions </h4><pre class="type-2 type-7 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test which takes a single node and flip flops between
 * active and standby mode, making sure it doesn't
 * double-play any edits.
 */
@Test public void testTransitionActiveToStandby() throws Exception {
  Configuration conf=new Configuration();
  MiniDFSCluster cluster=new MiniDFSCluster.Builder(conf).nnTopology(MiniDFSNNTopology.simpleHATopology()).numDataNodes(1).build();
  try {
    cluster.waitActive();
    cluster.transitionToActive(0);
    FileSystem fs=cluster.getFileSystem(0);
    fs.mkdirs(TEST_DIR);
    cluster.transitionToStandby(0);
    try {
      fs.mkdirs(new Path("/x"));
      fail("Didn't throw trying to mutate FS in standby state");
    }
 catch (    Throwable t) {
      GenericTestUtils.assertExceptionContains("Operation category WRITE is not supported",t);
    }
    cluster.transitionToActive(0);
    DFSTestUtil.createFile(fs,new Path(TEST_DIR,"foo"),10,(short)1,1L);
    fs.delete(TEST_DIR,true);
    cluster.transitionToStandby(0);
    cluster.transitionToActive(0);
    assertFalse(fs.exists(TEST_DIR));
  }
  finally {
    cluster.shutdown();
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.server.namenode.ha.TestNNHealthCheck </h4><pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testNNHealthCheck() throws IOException {
  MiniDFSCluster cluster=null;
  try {
    Configuration conf=new Configuration();
    cluster=new MiniDFSCluster.Builder(conf).numDataNodes(0).nnTopology(MiniDFSNNTopology.simpleHATopology()).build();
    NameNodeResourceChecker mockResourceChecker=Mockito.mock(NameNodeResourceChecker.class);
    Mockito.doReturn(true).when(mockResourceChecker).hasAvailableDiskSpace();
    cluster.getNameNode(0).getNamesystem().setNNResourceChecker(mockResourceChecker);
    NamenodeProtocols rpc=cluster.getNameNodeRpc(0);
    rpc.monitorHealth();
    Mockito.doReturn(false).when(mockResourceChecker).hasAvailableDiskSpace();
    try {
      rpc.monitorHealth();
      fail("Should not have succeeded in calling monitorHealth");
    }
 catch (    HealthCheckFailedException hcfe) {
      GenericTestUtils.assertExceptionContains("The NameNode has no resources available",hcfe);
    }
  }
  finally {
    if (cluster != null) {
      cluster.shutdown();
    }
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.server.namenode.ha.TestPipelinesFailover </h4><pre class="type-9 type-11 type-2 type-7 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test the scenario where the NN fails over after issuing a block
 * synchronization request, but before it is committed. The
 * DN running the recovery should then fail to commit the synchronization
 * and a later retry will succeed.
 */
@Test(timeout=30000) public void testFailoverRightBeforeCommitSynchronization() throws Exception {
  final Configuration conf=new Configuration();
  conf.setBoolean(DFSConfigKeys.DFS_PERMISSIONS_ENABLED_KEY,false);
  conf.setInt(DFSConfigKeys.DFS_BLOCK_SIZE_KEY,BLOCK_SIZE);
  FSDataOutputStream stm=null;
  final MiniDFSCluster cluster=new MiniDFSCluster.Builder(conf).nnTopology(MiniDFSNNTopology.simpleHATopology()).numDataNodes(3).build();
  try {
    cluster.waitActive();
    cluster.transitionToActive(0);
    Thread.sleep(500);
    LOG.info("Starting with NN 0 active");
    FileSystem fs=HATestUtil.configureFailoverFs(cluster,conf);
    stm=fs.create(TEST_PATH);
    AppendTestUtil.write(stm,0,BLOCK_SIZE / 2);
    stm.hflush();
    NameNode nn0=cluster.getNameNode(0);
    ExtendedBlock blk=DFSTestUtil.getFirstBlock(fs,TEST_PATH);
    DatanodeDescriptor expectedPrimary=DFSTestUtil.getExpectedPrimaryNode(nn0,blk);
    LOG.info("Expecting block recovery to be triggered on DN " + expectedPrimary);
    DataNode primaryDN=cluster.getDataNode(expectedPrimary.getIpcPort());
    DatanodeProtocolClientSideTranslatorPB nnSpy=DataNodeTestUtils.spyOnBposToNN(primaryDN,nn0);
    DelayAnswer delayer=new DelayAnswer(LOG);
    Mockito.doAnswer(delayer).when(nnSpy).commitBlockSynchronization(Mockito.eq(blk),Mockito.anyInt(),Mockito.anyLong(),Mockito.eq(true),Mockito.eq(false),(DatanodeID[])Mockito.anyObject(),(String[])Mockito.anyObject());
    DistributedFileSystem fsOtherUser=createFsAsOtherUser(cluster,conf);
    assertFalse(fsOtherUser.recoverLease(TEST_PATH));
    LOG.info("Waiting for commitBlockSynchronization call from primary");
    delayer.waitForCall();
    LOG.info("Failing over to NN 1");
    cluster.transitionToStandby(0);
    cluster.transitionToActive(1);
    delayer.proceed();
    delayer.waitForResult();
    Throwable t=delayer.getThrown();
    if (t == null) {
      fail("commitBlockSynchronization call did not fail on standby");
    }
    GenericTestUtils.assertExceptionContains("Operation category WRITE is not supported",t);
    loopRecoverLease(fsOtherUser,TEST_PATH);
    AppendTestUtil.check(fs,TEST_PATH,BLOCK_SIZE / 2);
  }
  finally {
    IOUtils.closeStream(stm);
    cluster.shutdown();
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.server.namenode.ha.TestStandbyCheckpoints </h4><pre class="type-2 type-7 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Make sure that clients will receive StandbyExceptions even when a
 * checkpoint is in progress on the SBN, and therefore the StandbyCheckpointer
 * thread will have FSNS lock. Regression test for HDFS-4591.
 */
@Test(timeout=300000) public void testStandbyExceptionThrownDuringCheckpoint() throws Exception {
  FSImage spyImage1=NameNodeAdapter.spyOnFsImage(nn1);
  DelayAnswer answerer=new DelayAnswer(LOG);
  Mockito.doAnswer(answerer).when(spyImage1).saveNamespace(Mockito.any(FSNamesystem.class),Mockito.eq(NameNodeFile.IMAGE),Mockito.any(Canceler.class));
  doEdits(0,1000);
  nn0.getRpcServer().rollEditLog();
  answerer.waitForCall();
  assertTrue("SBN is not performing checkpoint but it should be.",answerer.getFireCount() == 1 && answerer.getResultCount() == 0);
  ThreadUtil.sleepAtLeastIgnoreInterrupts(1000);
  try {
    nn1.getRpcServer().getFileInfo("/");
    fail("Should have thrown StandbyException, but instead succeeded.");
  }
 catch (  StandbyException se) {
    GenericTestUtils.assertExceptionContains("is not supported",se);
  }
  assertTrue("SBN should have still been checkpointing.",answerer.getFireCount() == 1 && answerer.getResultCount() == 0);
  answerer.proceed();
  answerer.waitForResult();
  assertTrue("SBN should have finished checkpointing.",answerer.getFireCount() == 1 && answerer.getResultCount() == 1);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.server.namenode.ha.TestStateTransitionFailure </h4><pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * Ensure that a failure to fully transition to the active state causes a
 * shutdown of the NameNode.
 */
@Test public void testFailureToTransitionCausesShutdown() throws IOException {
  MiniDFSCluster cluster=null;
  try {
    Configuration conf=new Configuration();
    conf.setLong(CommonConfigurationKeys.FS_TRASH_INTERVAL_KEY,-1);
    cluster=new MiniDFSCluster.Builder(conf).nnTopology(MiniDFSNNTopology.simpleHATopology()).numDataNodes(0).checkExitOnShutdown(false).build();
    cluster.waitActive();
    try {
      cluster.transitionToActive(0);
      fail("Transitioned to active but should not have been able to.");
    }
 catch (    ExitException ee) {
      assertExceptionContains("Cannot start trash emptier with negative interval",ee);
    }
  }
  finally {
    if (cluster != null) {
      cluster.shutdown();
    }
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.server.namenode.snapshot.TestDisallowModifyROSnapshot </h4><pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test(timeout=60000) public void testRename() throws Exception {
  try {
    fs.rename(objInSnapshot,new Path("/invalid/path"));
    fail("Didn't throw SnapshotAccessControlException");
  }
 catch (  SnapshotAccessControlException e) {
  }
  try {
    fs.rename(sub2,objInSnapshot);
    fail("Didn't throw SnapshotAccessControlException");
  }
 catch (  SnapshotAccessControlException e) {
  }
  try {
    fs.rename(sub2,objInSnapshot,(Options.Rename)null);
    fail("Didn't throw SnapshotAccessControlException");
  }
 catch (  SnapshotAccessControlException e) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.server.namenode.snapshot.TestNestedSnapshots </h4><pre class="type-9 type-13 type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions in iterations
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test the snapshot limit of a single snapshottable directory.
 * @throws Exception
 */
@Test(timeout=300000) public void testSnapshotLimit() throws Exception {
  final int step=1000;
  final String dirStr="/testSnapshotLimit/dir";
  final Path dir=new Path(dirStr);
  hdfs.mkdirs(dir,new FsPermission((short)0777));
  hdfs.allowSnapshot(dir);
  int s=0;
  for (; s < SNAPSHOT_LIMIT; s++) {
    final String snapshotName="s" + s;
    hdfs.createSnapshot(dir,snapshotName);
    if (s % step == 0) {
      final Path file=new Path(dirStr,"f" + s);
      DFSTestUtil.createFile(hdfs,file,BLOCKSIZE,REPLICATION,SEED);
    }
  }
  try {
    hdfs.createSnapshot(dir,"s" + s);
    Assert.fail("Expected to fail to create snapshot, but didn't.");
  }
 catch (  IOException ioe) {
    SnapshotTestHelper.LOG.info("The exception is expected.",ioe);
  }
  for (int f=0; f < SNAPSHOT_LIMIT; f+=step) {
    final String file="f" + f;
    s=RANDOM.nextInt(step);
    for (; s < SNAPSHOT_LIMIT; s+=RANDOM.nextInt(step)) {
      final Path p=SnapshotTestHelper.getSnapshotPath(dir,"s" + s,file);
      Assert.assertEquals(s > f,hdfs.exists(p));
    }
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * Create a snapshot for /test/foo and create another snapshot for
 * /test/foo/bar.  Files created before the snapshots should appear in both
 * snapshots and the files created after the snapshots should not appear in
 * any of the snapshots.  
 */
@Test(timeout=300000) public void testNestedSnapshots() throws Exception {
  cluster.getNamesystem().getSnapshotManager().setAllowNestedSnapshots(true);
  final Path foo=new Path("/testNestedSnapshots/foo");
  final Path bar=new Path(foo,"bar");
  final Path file1=new Path(bar,"file1");
  DFSTestUtil.createFile(hdfs,file1,BLOCKSIZE,REPLICATION,SEED);
  print("create file " + file1);
  final String s1name="foo-s1";
  final Path s1path=SnapshotTestHelper.getSnapshotRoot(foo,s1name);
  hdfs.allowSnapshot(foo);
  print("allow snapshot " + foo);
  hdfs.createSnapshot(foo,s1name);
  print("create snapshot " + s1name);
  final String s2name="bar-s2";
  final Path s2path=SnapshotTestHelper.getSnapshotRoot(bar,s2name);
  hdfs.allowSnapshot(bar);
  print("allow snapshot " + bar);
  hdfs.createSnapshot(bar,s2name);
  print("create snapshot " + s2name);
  final Path file2=new Path(bar,"file2");
  DFSTestUtil.createFile(hdfs,file2,BLOCKSIZE,REPLICATION,SEED);
  print("create file " + file2);
  assertFile(s1path,s2path,file1,true,true,true);
  assertFile(s1path,s2path,file2,true,false,false);
  final String rootStr="/";
  final Path rootPath=new Path(rootStr);
  hdfs.allowSnapshot(rootPath);
  print("allow snapshot " + rootStr);
  final Path rootSnapshot=hdfs.createSnapshot(rootPath);
  print("create snapshot " + rootSnapshot);
  hdfs.deleteSnapshot(rootPath,rootSnapshot.getName());
  print("delete snapshot " + rootSnapshot);
  hdfs.disallowSnapshot(rootPath);
  print("disallow snapshot " + rootStr);
  hdfs.deleteSnapshot(foo,s1name);
  hdfs.disallowSnapshot(foo);
  cluster.getNamesystem().getSnapshotManager().setAllowNestedSnapshots(false);
  try {
    hdfs.allowSnapshot(rootPath);
    Assert.fail();
  }
 catch (  SnapshotException se) {
    assertNestedSnapshotException(se,"subdirectory");
  }
  try {
    hdfs.allowSnapshot(foo);
    Assert.fail();
  }
 catch (  SnapshotException se) {
    assertNestedSnapshotException(se,"subdirectory");
  }
  final Path sub1Bar=new Path(bar,"sub1");
  final Path sub2Bar=new Path(sub1Bar,"sub2");
  hdfs.mkdirs(sub2Bar);
  try {
    hdfs.allowSnapshot(sub1Bar);
    Assert.fail();
  }
 catch (  SnapshotException se) {
    assertNestedSnapshotException(se,"ancestor");
  }
  try {
    hdfs.allowSnapshot(sub2Bar);
    Assert.fail();
  }
 catch (  SnapshotException se) {
    assertNestedSnapshotException(se,"ancestor");
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-10 type-19 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether two objects/variables are the same">IdentityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether two objects/variables are the same
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=300000) public void testSnapshotWithQuota() throws Exception {
  final String dirStr="/testSnapshotWithQuota/dir";
  final Path dir=new Path(dirStr);
  hdfs.mkdirs(dir,new FsPermission((short)0777));
  hdfs.allowSnapshot(dir);
  final int NS_QUOTA=6;
  hdfs.setQuota(dir,NS_QUOTA,HdfsConstants.QUOTA_DONT_SET);
  final Path foo=new Path(dir,"foo");
  final Path f1=new Path(foo,"f1");
  DFSTestUtil.createFile(hdfs,f1,BLOCKSIZE,REPLICATION,SEED);
{
    final Path snapshotPath=hdfs.createSnapshot(dir);
    final String snapshotName=snapshotPath.getName();
    Assert.assertTrue("snapshotName=" + snapshotName,Pattern.matches("s\\d\\d\\d\\d\\d\\d\\d\\d-\\d\\d\\d\\d\\d\\d\\.\\d\\d\\d",snapshotName));
    final Path parent=snapshotPath.getParent();
    Assert.assertEquals(HdfsConstants.DOT_SNAPSHOT_DIR,parent.getName());
    Assert.assertEquals(dir,parent.getParent());
  }
  final Path f2=new Path(foo,"f2");
  DFSTestUtil.createFile(hdfs,f2,BLOCKSIZE,REPLICATION,SEED);
  try {
    final Path f3=new Path(foo,"f3");
    DFSTestUtil.createFile(hdfs,f3,BLOCKSIZE,REPLICATION,SEED);
    Assert.fail();
  }
 catch (  NSQuotaExceededException e) {
    SnapshotTestHelper.LOG.info("The exception is expected.",e);
  }
  try {
    hdfs.createSnapshot(dir);
    Assert.fail();
  }
 catch (  NSQuotaExceededException e) {
    SnapshotTestHelper.LOG.info("The exception is expected.",e);
  }
  try {
    hdfs.setPermission(f1,new FsPermission((short)0));
    Assert.fail();
  }
 catch (  RemoteException e) {
    Assert.assertSame(NSQuotaExceededException.class,e.unwrapRemoteException().getClass());
    SnapshotTestHelper.LOG.info("The exception is expected.",e);
  }
  hdfs.setPermission(f2,new FsPermission((short)0));
  hdfs.setQuota(dir,NS_QUOTA + 2,HdfsConstants.QUOTA_DONT_SET);
  hdfs.createSnapshot(dir,"s1");
  hdfs.setPermission(foo,new FsPermission((short)0444));
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.server.namenode.snapshot.TestRenameWithSnapshots </h4><pre class="type-9 type-2 type-7 type-10 type-19 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether two objects/variables are the same">IdentityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether two objects/variables are the same
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=300000) public void testRenameFromSDir2NonSDir() throws Exception {
  final String dirStr="/testRenameWithSnapshot";
  final String abcStr=dirStr + "/abc";
  final Path abc=new Path(abcStr);
  hdfs.mkdirs(abc,new FsPermission((short)0777));
  hdfs.allowSnapshot(abc);
  final Path foo=new Path(abc,"foo");
  DFSTestUtil.createFile(hdfs,foo,BLOCKSIZE,REPL,SEED);
  hdfs.createSnapshot(abc,"s0");
  try {
    hdfs.rename(abc,new Path(dirStr,"tmp"));
    fail("Expect exception since " + abc + " is snapshottable and already has snapshots");
  }
 catch (  IOException e) {
    GenericTestUtils.assertExceptionContains(abcStr + " is snapshottable and already has snapshots",e);
  }
  final String xyzStr=dirStr + "/xyz";
  final Path xyz=new Path(xyzStr);
  hdfs.mkdirs(xyz,new FsPermission((short)0777));
  final Path bar=new Path(xyz,"bar");
  hdfs.rename(foo,bar);
  final INode fooRef=fsdir.getINode(SnapshotTestHelper.getSnapshotPath(abc,"s0","foo").toString());
  Assert.assertTrue(fooRef.isReference());
  Assert.assertTrue(fooRef.asReference() instanceof INodeReference.WithName);
  final INodeReference.WithCount withCount=(INodeReference.WithCount)fooRef.asReference().getReferredINode();
  Assert.assertEquals(2,withCount.getReferenceCount());
  final INode barRef=fsdir.getINode(bar.toString());
  Assert.assertTrue(barRef.isReference());
  Assert.assertSame(withCount,barRef.asReference().getReferredINode());
  hdfs.delete(bar,false);
  Assert.assertEquals(1,withCount.getReferenceCount());
}

</code></pre>

<br>
<pre class="type-2 type-7 type-10 type-19 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether two objects/variables are the same">IdentityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether two objects/variables are the same
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test undo where dst node being overwritten is a reference node
 */
@Test public void testRenameUndo_4() throws Exception {
  final Path sdir1=new Path("/dir1");
  final Path sdir2=new Path("/dir2");
  final Path sdir3=new Path("/dir3");
  hdfs.mkdirs(sdir1);
  hdfs.mkdirs(sdir2);
  hdfs.mkdirs(sdir3);
  final Path foo=new Path(sdir1,"foo");
  final Path bar=new Path(foo,"bar");
  DFSTestUtil.createFile(hdfs,bar,BLOCKSIZE,REPL,SEED);
  final Path foo2=new Path(sdir2,"foo2");
  hdfs.mkdirs(foo2);
  SnapshotTestHelper.createSnapshot(hdfs,sdir1,"s1");
  SnapshotTestHelper.createSnapshot(hdfs,sdir2,"s2");
  final Path foo3=new Path(sdir3,"foo3");
  hdfs.rename(foo2,foo3);
  INode foo3Node=fsdir.getINode4Write(foo3.toString());
  assertTrue(foo3Node.isReference());
  INodeDirectory dir3=fsdir.getINode4Write(sdir3.toString()).asDirectory();
  INodeDirectory mockDir3=spy(dir3);
  doReturn(false).when(mockDir3).addChild((INode)Mockito.isNull(),anyBoolean(),Mockito.anyInt());
  Mockito.when(mockDir3.addChild((INode)Mockito.isNotNull(),anyBoolean(),Mockito.anyInt())).thenReturn(false).thenCallRealMethod();
  INodeDirectory root=fsdir.getINode4Write("/").asDirectory();
  root.replaceChild(dir3,mockDir3,fsdir.getINodeMap());
  foo3Node.setParent(mockDir3);
  try {
    hdfs.rename(foo,foo3,Rename.OVERWRITE);
    fail("the rename from " + foo + " to "+ foo3+ " should fail");
  }
 catch (  IOException e) {
    GenericTestUtils.assertExceptionContains("rename from " + foo + " to "+ foo3+ " failed.",e);
  }
  final INode foo3Node_undo=fsdir.getINode4Write(foo3.toString());
  assertSame(foo3Node,foo3Node_undo);
  INodeReference.WithCount foo3_wc=(WithCount)foo3Node.asReference().getReferredINode();
  assertEquals(2,foo3_wc.getReferenceCount());
  assertSame(foo3Node,foo3_wc.getParentReference());
}

</code></pre>

<br>
<pre class="type-9 type-2 type-7 type-10 type-19 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether two objects/variables are the same">IdentityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether two objects/variables are the same
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test the rename undo when removing dst node fails
 */
@Test public void testRenameUndo_6() throws Exception {
  final Path test=new Path("/test");
  final Path dir1=new Path(test,"dir1");
  final Path dir2=new Path(test,"dir2");
  final Path sub_dir2=new Path(dir2,"subdir");
  final Path subsub_dir2=new Path(sub_dir2,"subdir");
  hdfs.mkdirs(dir1);
  hdfs.mkdirs(subsub_dir2);
  final Path foo=new Path(dir1,"foo");
  hdfs.mkdirs(foo);
  SnapshotTestHelper.createSnapshot(hdfs,dir1,"s1");
  SnapshotTestHelper.createSnapshot(hdfs,dir2,"s2");
  hdfs.setQuota(dir2,4,Long.MAX_VALUE - 1);
  try {
    hdfs.rename(foo,subsub_dir2,Rename.OVERWRITE);
    fail("Expect QuotaExceedException");
  }
 catch (  QuotaExceededException e) {
    String msg="Failed to record modification for snapshot: " + "The NameSpace quota (directories and files)" + " is exceeded: quota=4 file count=5";
    GenericTestUtils.assertExceptionContains(msg,e);
  }
  assertTrue(hdfs.exists(foo));
  INodeDirectory dir1Node=fsdir.getINode4Write(dir1.toString()).asDirectory();
  List<INode> childrenList=ReadOnlyList.Util.asList(dir1Node.getChildrenList(Snapshot.CURRENT_STATE_ID));
  assertEquals(1,childrenList.size());
  INode fooNode=childrenList.get(0);
  assertTrue(fooNode.asDirectory().isWithSnapshot());
  assertSame(dir1Node,fooNode.getParent());
  List<DirectoryDiff> diffList=dir1Node.getDiffs().asList();
  assertEquals(1,diffList.size());
  DirectoryDiff diff=diffList.get(0);
  assertTrue(diff.getChildrenDiff().getList(ListType.CREATED).isEmpty());
  assertTrue(diff.getChildrenDiff().getList(ListType.DELETED).isEmpty());
  INodeDirectory dir2Node=fsdir.getINode4Write(dir2.toString()).asDirectory();
  assertTrue(dir2Node.isSnapshottable());
  Quota.Counts counts=dir2Node.computeQuotaUsage();
  assertEquals(4,counts.get(Quota.NAMESPACE));
  assertEquals(0,counts.get(Quota.DISKSPACE));
  childrenList=ReadOnlyList.Util.asList(dir2Node.asDirectory().getChildrenList(Snapshot.CURRENT_STATE_ID));
  assertEquals(1,childrenList.size());
  INode subdir2Node=childrenList.get(0);
  assertTrue(subdir2Node.asDirectory().isWithSnapshot());
  assertSame(dir2Node,subdir2Node.getParent());
  assertSame(subdir2Node,fsdir.getINode4Write(sub_dir2.toString()));
  INode subsubdir2Node=fsdir.getINode4Write(subsub_dir2.toString());
  assertTrue(subsubdir2Node.getClass() == INodeDirectory.class);
  assertSame(subdir2Node,subsubdir2Node.getParent());
  diffList=(dir2Node).getDiffs().asList();
  assertEquals(1,diffList.size());
  diff=diffList.get(0);
  assertTrue(diff.getChildrenDiff().getList(ListType.CREATED).isEmpty());
  assertTrue(diff.getChildrenDiff().getList(ListType.DELETED).isEmpty());
  diffList=subdir2Node.asDirectory().getDiffs().asList();
  assertEquals(0,diffList.size());
}

</code></pre>

<br>
<pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test rename where the src/dst directories are both snapshottable 
 * directories without snapshots. In such case we need to update the 
 * snapshottable dir list in SnapshotManager.
 */
@Test(timeout=60000) public void testRenameAndUpdateSnapshottableDirs() throws Exception {
  final Path sdir1=new Path("/dir1");
  final Path sdir2=new Path("/dir2");
  final Path foo=new Path(sdir1,"foo");
  final Path bar=new Path(sdir2,"bar");
  hdfs.mkdirs(foo);
  hdfs.mkdirs(bar);
  hdfs.allowSnapshot(foo);
  SnapshotTestHelper.createSnapshot(hdfs,bar,snap1);
  assertEquals(2,fsn.getSnapshottableDirListing().length);
  INodeDirectory fooNode=fsdir.getINode4Write(foo.toString()).asDirectory();
  long fooId=fooNode.getId();
  try {
    hdfs.rename(foo,bar,Rename.OVERWRITE);
    fail("Expect exception since " + bar + " is snapshottable and already has snapshots");
  }
 catch (  IOException e) {
    GenericTestUtils.assertExceptionContains(bar.toString() + " is snapshottable and already has snapshots",e);
  }
  hdfs.deleteSnapshot(bar,snap1);
  hdfs.rename(foo,bar,Rename.OVERWRITE);
  SnapshottableDirectoryStatus[] dirs=fsn.getSnapshottableDirListing();
  assertEquals(1,dirs.length);
  assertEquals(bar,dirs[0].getFullPath());
  assertEquals(fooId,dirs[0].getDirStatus().getFileId());
}

</code></pre>

<br>
<pre class="type-9 type-2 type-7 type-10 type-19 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether two objects/variables are the same">IdentityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether two objects/variables are the same
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test rename to an invalid name (xxx/.snapshot)
 */
@Test public void testRenameUndo_7() throws Exception {
  final Path root=new Path("/");
  final Path foo=new Path(root,"foo");
  final Path bar=new Path(foo,"bar");
  DFSTestUtil.createFile(hdfs,bar,BLOCKSIZE,REPL,SEED);
  SnapshotTestHelper.createSnapshot(hdfs,root,snap1);
  final Path invalid=new Path(foo,HdfsConstants.DOT_SNAPSHOT_DIR);
  try {
    hdfs.rename(bar,invalid);
    fail("expect exception since invalid name is used for rename");
  }
 catch (  Exception e) {
    GenericTestUtils.assertExceptionContains("\"" + HdfsConstants.DOT_SNAPSHOT_DIR + "\" is a reserved name",e);
  }
  INodeDirectory rootNode=fsdir.getINode4Write(root.toString()).asDirectory();
  INodeDirectory fooNode=fsdir.getINode4Write(foo.toString()).asDirectory();
  ReadOnlyList<INode> children=fooNode.getChildrenList(Snapshot.CURRENT_STATE_ID);
  assertEquals(1,children.size());
  List<DirectoryDiff> diffList=fooNode.getDiffs().asList();
  assertEquals(1,diffList.size());
  DirectoryDiff diff=diffList.get(0);
  Snapshot s1=rootNode.getSnapshot(DFSUtil.string2Bytes(snap1));
  assertEquals(s1.getId(),diff.getSnapshotId());
  assertTrue(diff.getChildrenDiff().getList(ListType.DELETED).isEmpty());
  assertTrue(diff.getChildrenDiff().getList(ListType.CREATED).isEmpty());
  INodeFile barNode=fsdir.getINode4Write(bar.toString()).asFile();
  assertSame(barNode,children.get(0));
  assertSame(fooNode,barNode.getParent());
  List<FileDiff> barDiffList=barNode.getDiffs().asList();
  assertEquals(1,barDiffList.size());
  FileDiff barDiff=barDiffList.get(0);
  assertEquals(s1.getId(),barDiff.getSnapshotId());
  hdfs.setSafeMode(SafeModeAction.SAFEMODE_ENTER);
  hdfs.saveNamespace();
  hdfs.setSafeMode(SafeModeAction.SAFEMODE_LEAVE);
  cluster.shutdown();
  cluster=new MiniDFSCluster.Builder(conf).format(false).numDataNodes(REPL).build();
  cluster.waitActive();
  restartClusterAndCheckImage(true);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.server.namenode.snapshot.TestSnapshot </h4><pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * Creating snapshots for a directory that is not snapshottable must fail.
 */
@Test(timeout=60000) public void testSnapshottableDirectory() throws Exception {
  Path dir=new Path("/TestSnapshot/sub");
  Path file0=new Path(dir,"file0");
  Path file1=new Path(dir,"file1");
  DFSTestUtil.createFile(hdfs,file0,BLOCKSIZE,REPLICATION,seed);
  DFSTestUtil.createFile(hdfs,file1,BLOCKSIZE,REPLICATION,seed);
  try {
    hdfs.createSnapshot(dir,"s1");
    fail("Exception expected: " + dir + " is not snapshottable");
  }
 catch (  IOException e) {
    GenericTestUtils.assertExceptionContains("Directory is not a snapshottable directory: " + dir,e);
  }
  try {
    hdfs.deleteSnapshot(dir,"s1");
    fail("Exception expected: " + dir + " is not a snapshottale dir");
  }
 catch (  Exception e) {
    GenericTestUtils.assertExceptionContains("Directory is not a snapshottable directory: " + dir,e);
  }
  try {
    hdfs.renameSnapshot(dir,"s1","s2");
    fail("Exception expected: " + dir + " is not a snapshottale dir");
  }
 catch (  Exception e) {
    GenericTestUtils.assertExceptionContains("Directory is not a snapshottable directory: " + dir,e);
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * Test creating a snapshot with illegal name
 */
@Test public void testCreateSnapshotWithIllegalName() throws Exception {
  final Path dir=new Path("/dir");
  hdfs.mkdirs(dir);
  final String name1=HdfsConstants.DOT_SNAPSHOT_DIR;
  try {
    hdfs.createSnapshot(dir,name1);
    fail("Exception expected when an illegal name is given");
  }
 catch (  RemoteException e) {
    String errorMsg="Invalid path name Invalid snapshot name: " + name1;
    GenericTestUtils.assertExceptionContains(errorMsg,e);
  }
  final String[] badNames=new String[]{"foo" + Path.SEPARATOR,Path.SEPARATOR + "foo",Path.SEPARATOR,"foo" + Path.SEPARATOR + "bar"};
  for (  String badName : badNames) {
    try {
      hdfs.createSnapshot(dir,badName);
      fail("Exception expected when an illegal name is given");
    }
 catch (    RemoteException e) {
      String errorMsg="Invalid path name Invalid snapshot name: " + badName;
      GenericTestUtils.assertExceptionContains(errorMsg,e);
    }
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.server.namenode.snapshot.TestSnapshotBlocksMap </h4><pre class="type-9 type-2 type-7 type-10 type-19 type-1 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether two objects/variables are the same">IdentityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether two objects/variables are the same
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test deleting a file with snapshots. Need to check the blocksMap to make
 * sure the corresponding record is updated correctly.
 */
@Test(timeout=60000) public void testDeletionWithSnapshots() throws Exception {
  Path file0=new Path(sub1,"file0");
  Path file1=new Path(sub1,"file1");
  Path sub2=new Path(sub1,"sub2");
  Path file2=new Path(sub2,"file2");
  Path file3=new Path(sub1,"file3");
  Path file4=new Path(sub1,"file4");
  Path file5=new Path(sub1,"file5");
  DFSTestUtil.createFile(hdfs,file0,4 * BLOCKSIZE,REPLICATION,seed);
  DFSTestUtil.createFile(hdfs,file1,2 * BLOCKSIZE,REPLICATION,seed);
  DFSTestUtil.createFile(hdfs,file2,3 * BLOCKSIZE,REPLICATION,seed);
{
    final INodeFile f2=assertBlockCollection(file2.toString(),3,fsdir,blockmanager);
    BlockInfo[] blocks=f2.getBlocks();
    hdfs.delete(sub2,true);
    for (    BlockInfo b : blocks) {
      assertNull(blockmanager.getBlockCollection(b));
    }
  }
  final String[] snapshots={"s0","s1","s2"};
  DFSTestUtil.createFile(hdfs,file3,5 * BLOCKSIZE,REPLICATION,seed);
  SnapshotTestHelper.createSnapshot(hdfs,sub1,snapshots[0]);
  DFSTestUtil.createFile(hdfs,file4,1 * BLOCKSIZE,REPLICATION,seed);
  SnapshotTestHelper.createSnapshot(hdfs,sub1,snapshots[1]);
  DFSTestUtil.createFile(hdfs,file5,7 * BLOCKSIZE,REPLICATION,seed);
  SnapshotTestHelper.createSnapshot(hdfs,sub1,snapshots[2]);
{
    INodeFile f1=assertBlockCollection(file1.toString(),2,fsdir,blockmanager);
    Assert.assertSame(INodeFile.class,f1.getClass());
    hdfs.setReplication(file1,(short)2);
    f1=assertBlockCollection(file1.toString(),2,fsdir,blockmanager);
    assertTrue(f1.isWithSnapshot());
    assertFalse(f1.isUnderConstruction());
  }
  final INodeFile f0=assertBlockCollection(file0.toString(),4,fsdir,blockmanager);
  BlockInfo[] blocks0=f0.getBlocks();
  Path snapshotFile0=SnapshotTestHelper.getSnapshotPath(sub1,"s0",file0.getName());
  assertBlockCollection(snapshotFile0.toString(),4,fsdir,blockmanager);
  hdfs.delete(file0,true);
  for (  BlockInfo b : blocks0) {
    assertNotNull(blockmanager.getBlockCollection(b));
  }
  assertBlockCollection(snapshotFile0.toString(),4,fsdir,blockmanager);
  String s1f0=SnapshotTestHelper.getSnapshotPath(sub1,"s1",file0.getName()).toString();
  assertBlockCollection(s1f0,4,fsdir,blockmanager);
  hdfs.deleteSnapshot(sub1,"s1");
  for (  BlockInfo b : blocks0) {
    assertNotNull(blockmanager.getBlockCollection(b));
  }
  assertBlockCollection(snapshotFile0.toString(),4,fsdir,blockmanager);
  try {
    INodeFile.valueOf(fsdir.getINode(s1f0),s1f0);
    fail("Expect FileNotFoundException when identifying the INode in a deleted Snapshot");
  }
 catch (  IOException e) {
    assertExceptionContains("File does not exist: " + s1f0,e);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.server.namenode.snapshot.TestSnapshotDeletion </h4><pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testDeleteSnapshotWithPermissionsDisabled() throws Exception {
  cluster.shutdown();
  Configuration newConf=new Configuration(conf);
  newConf.setBoolean(DFSConfigKeys.DFS_PERMISSIONS_ENABLED_KEY,false);
  cluster=new MiniDFSCluster.Builder(newConf).numDataNodes(0).build();
  cluster.waitActive();
  hdfs=cluster.getFileSystem();
  final Path path=new Path("/dir");
  hdfs.mkdirs(path);
  hdfs.allowSnapshot(path);
  hdfs.mkdirs(new Path(path,"/test"));
  hdfs.createSnapshot(path,"s1");
  UserGroupInformation anotherUser=UserGroupInformation.createRemoteUser("anotheruser");
  anotherUser.doAs(new PrivilegedAction(){
    @Override public Object run(){
      DistributedFileSystem anotherUserFS=null;
      try {
        anotherUserFS=cluster.getFileSystem();
        anotherUserFS.deleteSnapshot(path,"s1");
      }
 catch (      IOException e) {
        fail("Failed to delete snapshot : " + e.getLocalizedMessage());
      }
 finally {
        IOUtils.closeStream(anotherUserFS);
      }
      return null;
    }
  }
);
}

</code></pre>

<br>
<pre class="type-9 type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test deleting the earliest (first) snapshot. In this simplest scenario, the 
 * snapshots are taken on the same directory, and we do not need to combine
 * snapshot diffs.
 */
@Test(timeout=300000) public void testDeleteEarliestSnapshot1() throws Exception {
  Path file0=new Path(sub,"file0");
  Path file1=new Path(sub,"file1");
  DFSTestUtil.createFile(hdfs,file0,BLOCKSIZE,REPLICATION,seed);
  DFSTestUtil.createFile(hdfs,file1,BLOCKSIZE,REPLICATION,seed);
  String snapshotName="s1";
  try {
    hdfs.deleteSnapshot(sub,snapshotName);
    fail("SnapshotException expected: " + sub.toString() + " is not snapshottable yet");
  }
 catch (  Exception e) {
    GenericTestUtils.assertExceptionContains("Directory is not a snapshottable directory: " + sub,e);
  }
  hdfs.allowSnapshot(sub);
  try {
    hdfs.deleteSnapshot(sub,snapshotName);
    fail("SnapshotException expected: snapshot " + snapshotName + " does not exist for "+ sub.toString());
  }
 catch (  Exception e) {
    GenericTestUtils.assertExceptionContains("Cannot delete snapshot " + snapshotName + " from path "+ sub.toString()+ ": the snapshot does not exist.",e);
  }
  SnapshotTestHelper.createSnapshot(hdfs,sub,snapshotName);
  checkQuotaUsageComputation(sub,4,BLOCKSIZE * REPLICATION * 2);
  hdfs.deleteSnapshot(sub,snapshotName);
  checkQuotaUsageComputation(sub,3,BLOCKSIZE * REPLICATION * 2);
  hdfs.createSnapshot(sub,snapshotName);
  checkQuotaUsageComputation(sub,4,BLOCKSIZE * REPLICATION * 2);
  Path newFile=new Path(sub,"newFile");
  DFSTestUtil.createFile(hdfs,newFile,BLOCKSIZE,REPLICATION,seed);
  String snapshotName2="s2";
  hdfs.createSnapshot(sub,snapshotName2);
  checkQuotaUsageComputation(sub,6,BLOCKSIZE * REPLICATION * 3);
  Path ss=SnapshotTestHelper.getSnapshotPath(sub,snapshotName2,"newFile");
  FileStatus statusBeforeDeletion=hdfs.getFileStatus(ss);
  hdfs.deleteSnapshot(sub,snapshotName);
  checkQuotaUsageComputation(sub,5,BLOCKSIZE * REPLICATION * 3);
  FileStatus statusAfterDeletion=hdfs.getFileStatus(ss);
  System.out.println("Before deletion: " + statusBeforeDeletion.toString() + "\n"+ "After deletion: "+ statusAfterDeletion.toString());
  assertEquals(statusBeforeDeletion.toString(),statusAfterDeletion.toString());
}

</code></pre>

<br>
<pre class="type-2 type-7 type-1 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test deleting the earliest (first) snapshot. In this more complicated 
 * scenario, the snapshots are taken across directories.
 * <pre>
 * The test covers the following scenarios:
 * 1. delete the first diff in the diff list of a directory
 * 2. delete the first diff in the diff list of a file
 * </pre>
 * Also, the recursive cleanTree process should cover both INodeFile and 
 * INodeDirectory.
 */
@Test(timeout=300000) public void testDeleteEarliestSnapshot2() throws Exception {
  Path noChangeDir=new Path(sub,"noChangeDir");
  Path noChangeFile=new Path(noChangeDir,"noChangeFile");
  Path metaChangeFile=new Path(noChangeDir,"metaChangeFile");
  Path metaChangeDir=new Path(noChangeDir,"metaChangeDir");
  Path toDeleteFile=new Path(metaChangeDir,"toDeleteFile");
  DFSTestUtil.createFile(hdfs,noChangeFile,BLOCKSIZE,REPLICATION,seed);
  DFSTestUtil.createFile(hdfs,metaChangeFile,BLOCKSIZE,REPLICATION,seed);
  DFSTestUtil.createFile(hdfs,toDeleteFile,BLOCKSIZE,REPLICATION,seed);
  final INodeFile toDeleteFileNode=TestSnapshotBlocksMap.assertBlockCollection(toDeleteFile.toString(),1,fsdir,blockmanager);
  BlockInfo[] blocks=toDeleteFileNode.getBlocks();
  SnapshotTestHelper.createSnapshot(hdfs,dir,"s0");
  checkQuotaUsageComputation(dir,8,3 * BLOCKSIZE * REPLICATION);
  hdfs.delete(toDeleteFile,true);
  checkQuotaUsageComputation(dir,10,3 * BLOCKSIZE * REPLICATION);
  hdfs.setReplication(metaChangeFile,REPLICATION_1);
  hdfs.setOwner(metaChangeDir,"unknown","unknown");
  checkQuotaUsageComputation(dir,11,3 * BLOCKSIZE * REPLICATION);
  hdfs.createSnapshot(dir,"s1");
  checkQuotaUsageComputation(dir,12,3 * BLOCKSIZE * REPLICATION);
  hdfs.deleteSnapshot(dir,"s0");
  checkQuotaUsageComputation(dir,7,2 * BLOCKSIZE * REPLICATION - BLOCKSIZE);
  for (  BlockInfo b : blocks) {
    assertNull(blockmanager.getBlockCollection(b));
  }
  final INodeDirectory dirNode=fsdir.getINode(dir.toString()).asDirectory();
  Snapshot snapshot0=dirNode.getSnapshot(DFSUtil.string2Bytes("s0"));
  assertNull(snapshot0);
  Snapshot snapshot1=dirNode.getSnapshot(DFSUtil.string2Bytes("s1"));
  DirectoryDiffList diffList=dirNode.getDiffs();
  assertEquals(1,diffList.asList().size());
  assertEquals(snapshot1.getId(),diffList.getLast().getSnapshotId());
  diffList=fsdir.getINode(metaChangeDir.toString()).asDirectory().getDiffs();
  assertEquals(0,diffList.asList().size());
  final INodeDirectory noChangeDirNode=(INodeDirectory)fsdir.getINode(noChangeDir.toString());
  assertEquals(INodeDirectory.class,noChangeDirNode.getClass());
  final INodeFile noChangeFileNode=(INodeFile)fsdir.getINode(noChangeFile.toString());
  assertEquals(INodeFile.class,noChangeFileNode.getClass());
  TestSnapshotBlocksMap.assertBlockCollection(noChangeFile.toString(),1,fsdir,blockmanager);
  FileStatus status=hdfs.getFileStatus(metaChangeDir);
  assertEquals("unknown",status.getOwner());
  assertEquals("unknown",status.getGroup());
  status=hdfs.getFileStatus(metaChangeFile);
  assertEquals(REPLICATION_1,status.getReplication());
  TestSnapshotBlocksMap.assertBlockCollection(metaChangeFile.toString(),1,fsdir,blockmanager);
  try {
    status=hdfs.getFileStatus(toDeleteFile);
    fail("should throw FileNotFoundException");
  }
 catch (  FileNotFoundException e) {
    GenericTestUtils.assertExceptionContains("File does not exist: " + toDeleteFile.toString(),e);
  }
  final Path toDeleteFileInSnapshot=SnapshotTestHelper.getSnapshotPath(dir,"s0",toDeleteFile.toString().substring(dir.toString().length()));
  try {
    status=hdfs.getFileStatus(toDeleteFileInSnapshot);
    fail("should throw FileNotFoundException");
  }
 catch (  FileNotFoundException e) {
    GenericTestUtils.assertExceptionContains("File does not exist: " + toDeleteFileInSnapshot.toString(),e);
  }
}

</code></pre>

<br>
<pre class="type-9 type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * A test covering the case where the snapshot diff to be deleted is renamed 
 * to its previous snapshot. 
 */
@Test(timeout=300000) public void testRenameSnapshotDiff() throws Exception {
  cluster.getNamesystem().getSnapshotManager().setAllowNestedSnapshots(true);
  final Path subFile0=new Path(sub,"file0");
  final Path subsubFile0=new Path(subsub,"file0");
  DFSTestUtil.createFile(hdfs,subFile0,BLOCKSIZE,REPLICATION,seed);
  DFSTestUtil.createFile(hdfs,subsubFile0,BLOCKSIZE,REPLICATION,seed);
  hdfs.setOwner(subsub,"owner","group");
  SnapshotTestHelper.createSnapshot(hdfs,sub,"s0");
  checkQuotaUsageComputation(sub,5,BLOCKSIZE * 6);
  final Path subFile1=new Path(sub,"file1");
  final Path subsubFile1=new Path(subsub,"file1");
  DFSTestUtil.createFile(hdfs,subFile1,BLOCKSIZE,REPLICATION_1,seed);
  DFSTestUtil.createFile(hdfs,subsubFile1,BLOCKSIZE,REPLICATION,seed);
  checkQuotaUsageComputation(sub,8,BLOCKSIZE * 11);
  SnapshotTestHelper.createSnapshot(hdfs,sub,"s1");
  checkQuotaUsageComputation(sub,9,BLOCKSIZE * 11);
  SnapshotTestHelper.createSnapshot(hdfs,dir,"s2");
  checkQuotaUsageComputation(dir,11,BLOCKSIZE * 11);
  checkQuotaUsageComputation(sub,9,BLOCKSIZE * 11);
  hdfs.setOwner(subsub,"unknown","unknown");
  hdfs.setReplication(subsubFile1,REPLICATION_1);
  checkQuotaUsageComputation(dir,13,BLOCKSIZE * 11);
  checkQuotaUsageComputation(sub,11,BLOCKSIZE * 11);
  hdfs.delete(subFile1,true);
  checkQuotaUsageComputation(new Path("/"),16,BLOCKSIZE * 11);
  checkQuotaUsageComputation(dir,15,BLOCKSIZE * 11);
  checkQuotaUsageComputation(sub,13,BLOCKSIZE * 11);
  Path subsubSnapshotCopy=SnapshotTestHelper.getSnapshotPath(dir,"s2",sub.getName() + Path.SEPARATOR + subsub.getName());
  Path subsubFile1SCopy=SnapshotTestHelper.getSnapshotPath(dir,"s2",sub.getName() + Path.SEPARATOR + subsub.getName()+ Path.SEPARATOR+ subsubFile1.getName());
  Path subFile1SCopy=SnapshotTestHelper.getSnapshotPath(dir,"s2",sub.getName() + Path.SEPARATOR + subFile1.getName());
  FileStatus subsubStatus=hdfs.getFileStatus(subsubSnapshotCopy);
  assertEquals("owner",subsubStatus.getOwner());
  assertEquals("group",subsubStatus.getGroup());
  FileStatus subsubFile1Status=hdfs.getFileStatus(subsubFile1SCopy);
  assertEquals(REPLICATION,subsubFile1Status.getReplication());
  FileStatus subFile1Status=hdfs.getFileStatus(subFile1SCopy);
  assertEquals(REPLICATION_1,subFile1Status.getReplication());
  hdfs.deleteSnapshot(dir,"s2");
  checkQuotaUsageComputation(new Path("/"),14,BLOCKSIZE * 11);
  checkQuotaUsageComputation(dir,13,BLOCKSIZE * 11);
  checkQuotaUsageComputation(sub,12,BLOCKSIZE * 11);
  try {
    hdfs.getFileStatus(subsubSnapshotCopy);
    fail("should throw FileNotFoundException");
  }
 catch (  FileNotFoundException e) {
    GenericTestUtils.assertExceptionContains("File does not exist: " + subsubSnapshotCopy.toString(),e);
  }
  try {
    hdfs.getFileStatus(subsubFile1SCopy);
    fail("should throw FileNotFoundException");
  }
 catch (  FileNotFoundException e) {
    GenericTestUtils.assertExceptionContains("File does not exist: " + subsubFile1SCopy.toString(),e);
  }
  try {
    hdfs.getFileStatus(subFile1SCopy);
    fail("should throw FileNotFoundException");
  }
 catch (  FileNotFoundException e) {
    GenericTestUtils.assertExceptionContains("File does not exist: " + subFile1SCopy.toString(),e);
  }
  subsubSnapshotCopy=SnapshotTestHelper.getSnapshotPath(sub,"s1",subsub.getName());
  subsubFile1SCopy=SnapshotTestHelper.getSnapshotPath(sub,"s1",subsub.getName() + Path.SEPARATOR + subsubFile1.getName());
  subFile1SCopy=SnapshotTestHelper.getSnapshotPath(sub,"s1",subFile1.getName());
  subsubStatus=hdfs.getFileStatus(subsubSnapshotCopy);
  assertEquals("owner",subsubStatus.getOwner());
  assertEquals("group",subsubStatus.getGroup());
  subsubFile1Status=hdfs.getFileStatus(subsubFile1SCopy);
  assertEquals(REPLICATION,subsubFile1Status.getReplication());
  subFile1Status=hdfs.getFileStatus(subFile1SCopy);
  assertEquals(REPLICATION_1,subFile1Status.getReplication());
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.server.namenode.snapshot.TestSnapshotDiffReport </h4><pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test the computation and representation of diff between snapshots 
 */
@Test(timeout=60000) public void testDiffReport() throws Exception {
  cluster.getNamesystem().getSnapshotManager().setAllowNestedSnapshots(true);
  Path subsub1=new Path(sub1,"subsub1");
  Path subsubsub1=new Path(subsub1,"subsubsub1");
  hdfs.mkdirs(subsubsub1);
  modifyAndCreateSnapshot(sub1,new Path[]{sub1,subsubsub1});
  modifyAndCreateSnapshot(subsubsub1,new Path[]{sub1,subsubsub1});
  try {
    hdfs.getSnapshotDiffReport(subsub1,"s1","s2");
    fail("Expect exception when getting snapshot diff report: " + subsub1 + " is not a snapshottable directory.");
  }
 catch (  IOException e) {
    GenericTestUtils.assertExceptionContains("Directory is not a snapshottable directory: " + subsub1,e);
  }
  final String invalidName="invalid";
  try {
    hdfs.getSnapshotDiffReport(sub1,invalidName,invalidName);
    fail("Expect exception when providing invalid snapshot name for diff report");
  }
 catch (  IOException e) {
    GenericTestUtils.assertExceptionContains("Cannot find the snapshot of directory " + sub1 + " with name "+ invalidName,e);
  }
  SnapshotDiffReport report=hdfs.getSnapshotDiffReport(sub1,"s0","s0");
  System.out.println(report);
  assertEquals(0,report.getDiffList().size());
  report=hdfs.getSnapshotDiffReport(sub1,"","");
  System.out.println(report);
  assertEquals(0,report.getDiffList().size());
  report=hdfs.getSnapshotDiffReport(subsubsub1,"s0","s2");
  System.out.println(report);
  assertEquals(0,report.getDiffList().size());
  report=hdfs.getSnapshotDiffReport(hdfs.makeQualified(subsubsub1),"s0","s2");
  System.out.println(report);
  assertEquals(0,report.getDiffList().size());
  verifyDiffReport(sub1,"s0","s2",new DiffReportEntry(DiffType.MODIFY,DFSUtil.string2Bytes("")),new DiffReportEntry(DiffType.CREATE,DFSUtil.string2Bytes("file15")),new DiffReportEntry(DiffType.DELETE,DFSUtil.string2Bytes("file12")),new DiffReportEntry(DiffType.DELETE,DFSUtil.string2Bytes("file11")),new DiffReportEntry(DiffType.CREATE,DFSUtil.string2Bytes("file11")),new DiffReportEntry(DiffType.MODIFY,DFSUtil.string2Bytes("file13")),new DiffReportEntry(DiffType.DELETE,DFSUtil.string2Bytes("link13")),new DiffReportEntry(DiffType.CREATE,DFSUtil.string2Bytes("link13")));
  verifyDiffReport(sub1,"s0","s5",new DiffReportEntry(DiffType.MODIFY,DFSUtil.string2Bytes("")),new DiffReportEntry(DiffType.CREATE,DFSUtil.string2Bytes("file15")),new DiffReportEntry(DiffType.DELETE,DFSUtil.string2Bytes("file12")),new DiffReportEntry(DiffType.MODIFY,DFSUtil.string2Bytes("file10")),new DiffReportEntry(DiffType.DELETE,DFSUtil.string2Bytes("file11")),new DiffReportEntry(DiffType.CREATE,DFSUtil.string2Bytes("file11")),new DiffReportEntry(DiffType.MODIFY,DFSUtil.string2Bytes("file13")),new DiffReportEntry(DiffType.DELETE,DFSUtil.string2Bytes("link13")),new DiffReportEntry(DiffType.CREATE,DFSUtil.string2Bytes("link13")),new DiffReportEntry(DiffType.MODIFY,DFSUtil.string2Bytes("subsub1/subsubsub1")),new DiffReportEntry(DiffType.CREATE,DFSUtil.string2Bytes("subsub1/subsubsub1/file10")),new DiffReportEntry(DiffType.CREATE,DFSUtil.string2Bytes("subsub1/subsubsub1/file11")),new DiffReportEntry(DiffType.CREATE,DFSUtil.string2Bytes("subsub1/subsubsub1/file13")),new DiffReportEntry(DiffType.CREATE,DFSUtil.string2Bytes("subsub1/subsubsub1/link13")),new DiffReportEntry(DiffType.CREATE,DFSUtil.string2Bytes("subsub1/subsubsub1/file15")));
  verifyDiffReport(sub1,"s2","s5",new DiffReportEntry(DiffType.MODIFY,DFSUtil.string2Bytes("file10")),new DiffReportEntry(DiffType.MODIFY,DFSUtil.string2Bytes("subsub1/subsubsub1")),new DiffReportEntry(DiffType.CREATE,DFSUtil.string2Bytes("subsub1/subsubsub1/file10")),new DiffReportEntry(DiffType.CREATE,DFSUtil.string2Bytes("subsub1/subsubsub1/file11")),new DiffReportEntry(DiffType.CREATE,DFSUtil.string2Bytes("subsub1/subsubsub1/file13")),new DiffReportEntry(DiffType.CREATE,DFSUtil.string2Bytes("subsub1/subsubsub1/link13")),new DiffReportEntry(DiffType.CREATE,DFSUtil.string2Bytes("subsub1/subsubsub1/file15")));
  verifyDiffReport(sub1,"s3","",new DiffReportEntry(DiffType.MODIFY,DFSUtil.string2Bytes("subsub1/subsubsub1")),new DiffReportEntry(DiffType.CREATE,DFSUtil.string2Bytes("subsub1/subsubsub1/file15")),new DiffReportEntry(DiffType.DELETE,DFSUtil.string2Bytes("subsub1/subsubsub1/file12")),new DiffReportEntry(DiffType.MODIFY,DFSUtil.string2Bytes("subsub1/subsubsub1/file10")),new DiffReportEntry(DiffType.DELETE,DFSUtil.string2Bytes("subsub1/subsubsub1/file11")),new DiffReportEntry(DiffType.CREATE,DFSUtil.string2Bytes("subsub1/subsubsub1/file11")),new DiffReportEntry(DiffType.MODIFY,DFSUtil.string2Bytes("subsub1/subsubsub1/file13")),new DiffReportEntry(DiffType.CREATE,DFSUtil.string2Bytes("subsub1/subsubsub1/link13")),new DiffReportEntry(DiffType.DELETE,DFSUtil.string2Bytes("subsub1/subsubsub1/link13")));
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.server.namenode.snapshot.TestSnapshotListing </h4><pre class="type-13 type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test listing snapshots under a snapshottable directory
 */
@Test(timeout=15000) public void testListSnapshots() throws Exception {
  final Path snapshotsPath=new Path(dir,".snapshot");
  FileStatus[] stats=null;
  stats=hdfs.listStatus(new Path("/.snapshot"));
  assertEquals(0,stats.length);
  try {
    stats=hdfs.listStatus(snapshotsPath);
    fail("expect SnapshotException");
  }
 catch (  IOException e) {
    GenericTestUtils.assertExceptionContains("Directory is not a snapshottable directory: " + dir.toString(),e);
  }
  hdfs.allowSnapshot(dir);
  stats=hdfs.listStatus(snapshotsPath);
  assertEquals(0,stats.length);
  final int snapshotNum=5;
  for (int sNum=0; sNum < snapshotNum; sNum++) {
    hdfs.createSnapshot(dir,"s_" + sNum);
    stats=hdfs.listStatus(snapshotsPath);
    assertEquals(sNum + 1,stats.length);
    for (int i=0; i <= sNum; i++) {
      assertEquals("s_" + i,stats[i].getPath().getName());
    }
  }
  for (int sNum=snapshotNum - 1; sNum > 0; sNum--) {
    hdfs.deleteSnapshot(dir,"s_" + sNum);
    stats=hdfs.listStatus(snapshotsPath);
    assertEquals(sNum,stats.length);
    for (int i=0; i < sNum; i++) {
      assertEquals("s_" + i,stats[i].getPath().getName());
    }
  }
  hdfs.deleteSnapshot(dir,"s_0");
  stats=hdfs.listStatus(snapshotsPath);
  assertEquals(0,stats.length);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.server.namenode.snapshot.TestSnapshotManager </h4><pre class="type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test that the global limit on snapshots is honored.
 */
@Test(timeout=10000) public void testSnapshotLimits() throws Exception {
  INodeDirectory ids=mock(INodeDirectory.class);
  FSDirectory fsdir=mock(FSDirectory.class);
  SnapshotManager sm=spy(new SnapshotManager(fsdir));
  doReturn(ids).when(sm).getSnapshottableRoot(anyString());
  doReturn(testMaxSnapshotLimit).when(sm).getMaxSnapshotID();
  for (Integer i=0; i < testMaxSnapshotLimit; ++i) {
    sm.createSnapshot("dummy",i.toString());
  }
  try {
    sm.createSnapshot("dummy","shouldFailSnapshot");
    Assert.fail("Expected SnapshotException not thrown");
  }
 catch (  SnapshotException se) {
    Assert.assertTrue(se.getMessage().toLowerCase().contains("rollover"));
  }
  sm.deleteSnapshot("","",mock(INode.BlocksMapUpdateInfo.class),new ArrayList<INode>());
  try {
    sm.createSnapshot("dummy","shouldFailSnapshot2");
    Assert.fail("Expected SnapshotException not thrown");
  }
 catch (  SnapshotException se) {
    Assert.assertTrue(se.getMessage().toLowerCase().contains("rollover"));
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.server.namenode.snapshot.TestSnapshotRename </h4><pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * Test renaming a snapshot with illegal name
 */
@Test public void testRenameWithIllegalName() throws Exception {
  DFSTestUtil.createFile(hdfs,file1,BLOCKSIZE,REPLICATION,seed);
  SnapshotTestHelper.createSnapshot(hdfs,sub1,"s1");
  final String name1=HdfsConstants.DOT_SNAPSHOT_DIR;
  try {
    hdfs.renameSnapshot(sub1,"s1",name1);
    fail("Exception expected when an illegal name is given for rename");
  }
 catch (  RemoteException e) {
    String errorMsg="\"" + HdfsConstants.DOT_SNAPSHOT_DIR + "\" is a reserved name.";
    GenericTestUtils.assertExceptionContains(errorMsg,e);
  }
  String errorMsg="Snapshot name cannot contain \"" + Path.SEPARATOR + "\"";
  final String[] badNames=new String[]{"foo" + Path.SEPARATOR,Path.SEPARATOR + "foo",Path.SEPARATOR,"foo" + Path.SEPARATOR + "bar"};
  for (  String badName : badNames) {
    try {
      hdfs.renameSnapshot(sub1,"s1",badName);
      fail("Exception expected when an illegal name is given");
    }
 catch (    RemoteException e) {
      GenericTestUtils.assertExceptionContains(errorMsg,e);
    }
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.server.namenode.startupprogress.TestStartupProgress </h4><pre class="type-2 type-7 type-1 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=10000) public void testInitialState(){
  StartupProgressView view=startupProgress.createView();
  assertNotNull(view);
  assertEquals(0L,view.getElapsedTime());
  assertEquals(0.0f,view.getPercentComplete(),0.001f);
  List<Phase> phases=new ArrayList<Phase>();
  for (  Phase phase : view.getPhases()) {
    phases.add(phase);
    assertEquals(0L,view.getElapsedTime(phase));
    assertNull(view.getFile(phase));
    assertEquals(0.0f,view.getPercentComplete(phase),0.001f);
    assertEquals(Long.MIN_VALUE,view.getSize(phase));
    assertEquals(PENDING,view.getStatus(phase));
    assertEquals(0L,view.getTotal(phase));
    for (    Step step : view.getSteps(phase)) {
      fail(String.format("unexpected step %s in phase %s at initial state",step,phase));
    }
  }
  assertArrayEquals(EnumSet.allOf(Phase.class).toArray(),phases.toArray());
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.shortcircuit.TestShortCircuitCache </h4><pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test(timeout=60000) public void testTimeBasedStaleness() throws Exception {
  final ShortCircuitCache cache=new ShortCircuitCache(2,10000000,1,10000000,1,10,0);
  final TestFileDescriptorPair pairs[]=new TestFileDescriptorPair[]{new TestFileDescriptorPair(),new TestFileDescriptorPair()};
  ShortCircuitReplicaInfo replicaInfos[]=new ShortCircuitReplicaInfo[]{null,null};
  final long HOUR_IN_MS=60 * 60 * 1000;
  for (int i=0; i < pairs.length; i++) {
    final Integer iVal=new Integer(i);
    final ExtendedBlockId key=new ExtendedBlockId(i,"test_bp1");
    replicaInfos[i]=cache.fetchOrCreate(key,new ShortCircuitReplicaCreator(){
      @Override public ShortCircuitReplicaInfo createShortCircuitReplicaInfo(){
        try {
          return new ShortCircuitReplicaInfo(new ShortCircuitReplica(key,pairs[iVal].getFileInputStreams()[0],pairs[iVal].getFileInputStreams()[1],cache,Time.monotonicNow() + (iVal * HOUR_IN_MS),null));
        }
 catch (        IOException e) {
          throw new RuntimeException(e);
        }
      }
    }
);
    Preconditions.checkNotNull(replicaInfos[i].getReplica());
    Preconditions.checkState(replicaInfos[i].getInvalidTokenException() == null);
    pairs[i].compareWith(replicaInfos[i].getReplica().getDataStream(),replicaInfos[i].getReplica().getMetaStream());
  }
  GenericTestUtils.waitFor(new Supplier<Boolean>(){
    @Override public Boolean get(){
      ShortCircuitReplicaInfo info=cache.fetchOrCreate(new ExtendedBlockId(0,"test_bp1"),new ShortCircuitReplicaCreator(){
        @Override public ShortCircuitReplicaInfo createShortCircuitReplicaInfo(){
          return null;
        }
      }
);
      if (info.getReplica() != null) {
        info.getReplica().unref();
        return false;
      }
      return true;
    }
  }
,500,60000);
  ShortCircuitReplicaInfo info=cache.fetchOrCreate(new ExtendedBlockId(1,"test_bp1"),new ShortCircuitReplicaCreator(){
    @Override public ShortCircuitReplicaInfo createShortCircuitReplicaInfo(){
      Assert.fail("second replica went stale, despite 1 " + "hour staleness time.");
      return null;
    }
  }
);
  info.getReplica().unref();
  for (int i=1; i < pairs.length; i++) {
    replicaInfos[i].getReplica().unref();
  }
  cache.close();
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test(timeout=60000) public void testAddAndRetrieve() throws Exception {
  final ShortCircuitCache cache=new ShortCircuitCache(10,10000000,10,10000000,1,10000,0);
  final TestFileDescriptorPair pair=new TestFileDescriptorPair();
  ShortCircuitReplicaInfo replicaInfo1=cache.fetchOrCreate(new ExtendedBlockId(123,"test_bp1"),new SimpleReplicaCreator(123,cache,pair));
  Preconditions.checkNotNull(replicaInfo1.getReplica());
  Preconditions.checkState(replicaInfo1.getInvalidTokenException() == null);
  pair.compareWith(replicaInfo1.getReplica().getDataStream(),replicaInfo1.getReplica().getMetaStream());
  ShortCircuitReplicaInfo replicaInfo2=cache.fetchOrCreate(new ExtendedBlockId(123,"test_bp1"),new ShortCircuitReplicaCreator(){
    @Override public ShortCircuitReplicaInfo createShortCircuitReplicaInfo(){
      Assert.fail("expected to use existing entry.");
      return null;
    }
  }
);
  Preconditions.checkNotNull(replicaInfo2.getReplica());
  Preconditions.checkState(replicaInfo2.getInvalidTokenException() == null);
  Preconditions.checkState(replicaInfo1 == replicaInfo2);
  pair.compareWith(replicaInfo2.getReplica().getDataStream(),replicaInfo2.getReplica().getMetaStream());
  replicaInfo1.getReplica().unref();
  replicaInfo2.getReplica().unref();
  ShortCircuitReplicaInfo replicaInfo3=cache.fetchOrCreate(new ExtendedBlockId(123,"test_bp1"),new ShortCircuitReplicaCreator(){
    @Override public ShortCircuitReplicaInfo createShortCircuitReplicaInfo(){
      Assert.fail("expected to use existing entry.");
      return null;
    }
  }
);
  Preconditions.checkNotNull(replicaInfo3.getReplica());
  Preconditions.checkState(replicaInfo3.getInvalidTokenException() == null);
  replicaInfo3.getReplica().unref();
  pair.close();
  cache.close();
}

</code></pre>

<br>
<pre class="type-2 type-7 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testEviction() throws Exception {
  final ShortCircuitCache cache=new ShortCircuitCache(2,10000000,1,10000000,1,10000,0);
  final TestFileDescriptorPair pairs[]=new TestFileDescriptorPair[]{new TestFileDescriptorPair(),new TestFileDescriptorPair(),new TestFileDescriptorPair()};
  ShortCircuitReplicaInfo replicaInfos[]=new ShortCircuitReplicaInfo[]{null,null,null};
  for (int i=0; i < pairs.length; i++) {
    replicaInfos[i]=cache.fetchOrCreate(new ExtendedBlockId(i,"test_bp1"),new SimpleReplicaCreator(i,cache,pairs[i]));
    Preconditions.checkNotNull(replicaInfos[i].getReplica());
    Preconditions.checkState(replicaInfos[i].getInvalidTokenException() == null);
    pairs[i].compareWith(replicaInfos[i].getReplica().getDataStream(),replicaInfos[i].getReplica().getMetaStream());
  }
  for (int i=0; i < pairs.length; i++) {
    replicaInfos[i].getReplica().unref();
  }
  for (int i=1; i < pairs.length; i++) {
    final Integer iVal=new Integer(i);
    replicaInfos[i]=cache.fetchOrCreate(new ExtendedBlockId(i,"test_bp1"),new ShortCircuitReplicaCreator(){
      @Override public ShortCircuitReplicaInfo createShortCircuitReplicaInfo(){
        Assert.fail("expected to use existing entry for " + iVal);
        return null;
      }
    }
);
    Preconditions.checkNotNull(replicaInfos[i].getReplica());
    Preconditions.checkState(replicaInfos[i].getInvalidTokenException() == null);
    pairs[i].compareWith(replicaInfos[i].getReplica().getDataStream(),replicaInfos[i].getReplica().getMetaStream());
  }
  final MutableBoolean calledCreate=new MutableBoolean(false);
  replicaInfos[0]=cache.fetchOrCreate(new ExtendedBlockId(0,"test_bp1"),new ShortCircuitReplicaCreator(){
    @Override public ShortCircuitReplicaInfo createShortCircuitReplicaInfo(){
      calledCreate.setValue(true);
      return null;
    }
  }
);
  Preconditions.checkState(replicaInfos[0].getReplica() == null);
  Assert.assertTrue(calledCreate.isTrue());
  for (int i=1; i < pairs.length; i++) {
    replicaInfos[i].getReplica().unref();
  }
  for (int i=0; i < pairs.length; i++) {
    pairs[i].close();
  }
  cache.close();
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.shortcircuit.TestShortCircuitLocalRead </h4><pre class="type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=10000) public void testDeprecatedGetBlockLocalPathInfoRpc() throws IOException {
  final Configuration conf=new Configuration();
  MiniDFSCluster cluster=new MiniDFSCluster.Builder(conf).numDataNodes(1).format(true).build();
  cluster.waitActive();
  FileSystem fs=cluster.getFileSystem();
  try {
    DFSTestUtil.createFile(fs,new Path("/tmp/x"),16,(short)1,23);
    LocatedBlocks lb=cluster.getNameNode().getRpcServer().getBlockLocations("/tmp/x",0,16);
    ExtendedBlock blk=new ExtendedBlock(lb.get(0).getBlock());
    Token<BlockTokenIdentifier> token=lb.get(0).getBlockToken();
    final DatanodeInfo dnInfo=lb.get(0).getLocations()[0];
    ClientDatanodeProtocol proxy=DFSUtil.createClientDatanodeProtocolProxy(dnInfo,conf,60000,false);
    try {
      proxy.getBlockLocalPathInfo(blk,token);
      Assert.fail("The call should have failed as this user " + " is not allowed to call getBlockLocalPathInfo");
    }
 catch (    IOException ex) {
      Assert.assertTrue(ex.getMessage().contains("not allowed to call getBlockLocalPathInfo"));
    }
  }
  finally {
    fs.close();
    cluster.shutdown();
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test(timeout=120000) public void testHandleTruncatedBlockFile() throws IOException {
  MiniDFSCluster cluster=null;
  HdfsConfiguration conf=new HdfsConfiguration();
  conf.setBoolean(DFSConfigKeys.DFS_CLIENT_READ_SHORTCIRCUIT_KEY,true);
  conf.setBoolean(DFSConfigKeys.DFS_CLIENT_READ_SHORTCIRCUIT_SKIP_CHECKSUM_KEY,false);
  conf.set(DFSConfigKeys.DFS_DOMAIN_SOCKET_PATH_KEY,"/tmp/testHandleTruncatedBlockFile._PORT");
  conf.set(DFSConfigKeys.DFS_CHECKSUM_TYPE_KEY,"CRC32C");
  final Path TEST_PATH=new Path("/a");
  final Path TEST_PATH2=new Path("/b");
  final long RANDOM_SEED=4567L;
  final long RANDOM_SEED2=4568L;
  FSDataInputStream fsIn=null;
  final int TEST_LENGTH=3456;
  try {
    cluster=new MiniDFSCluster.Builder(conf).numDataNodes(1).build();
    cluster.waitActive();
    FileSystem fs=cluster.getFileSystem();
    DFSTestUtil.createFile(fs,TEST_PATH,TEST_LENGTH,(short)1,RANDOM_SEED);
    DFSTestUtil.createFile(fs,TEST_PATH2,TEST_LENGTH,(short)1,RANDOM_SEED2);
    fsIn=cluster.getFileSystem().open(TEST_PATH2);
    byte original[]=new byte[TEST_LENGTH];
    IOUtils.readFully(fsIn,original,0,TEST_LENGTH);
    fsIn.close();
    fsIn=null;
    try {
      DFSTestUtil.waitReplication(fs,TEST_PATH,(short)1);
    }
 catch (    InterruptedException e) {
      Assert.fail("unexpected InterruptedException during " + "waitReplication: " + e);
    }
catch (    TimeoutException e) {
      Assert.fail("unexpected TimeoutException during " + "waitReplication: " + e);
    }
    ExtendedBlock block=DFSTestUtil.getFirstBlock(fs,TEST_PATH);
    File dataFile=MiniDFSCluster.getBlockFile(0,block);
    cluster.shutdown();
    cluster=null;
    RandomAccessFile raf=null;
    try {
      raf=new RandomAccessFile(dataFile,"rw");
      raf.setLength(0);
    }
  finally {
      if (raf != null)       raf.close();
    }
    cluster=new MiniDFSCluster.Builder(conf).numDataNodes(1).format(false).build();
    cluster.waitActive();
    fs=cluster.getFileSystem();
    fsIn=fs.open(TEST_PATH);
    try {
      byte buf[]=new byte[100];
      fsIn.seek(2000);
      fsIn.readFully(buf,0,buf.length);
      Assert.fail("shouldn't be able to read from corrupt 0-length " + "block file.");
    }
 catch (    IOException e) {
      DFSClient.LOG.error("caught exception ",e);
    }
    fsIn.close();
    fsIn=null;
    fsIn=fs.open(TEST_PATH2);
    byte buf[]=new byte[original.length];
    fsIn.readFully(buf,0,buf.length);
    TestBlockReaderLocal.assertArrayRegionsEqual(original,0,buf,0,original.length);
    fsIn.close();
    fsIn=null;
  }
  finally {
    if (fsIn != null)     fsIn.close();
    if (cluster != null)     cluster.shutdown();
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.util.TestAtomicFileOutputStream </h4><pre class="type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test case where the flush() fails at close time - make sure
 * that we clean up after ourselves and don't touch any
 * existing file at the destination
 */
@Test public void testFailToFlush() throws IOException {
  FileOutputStream fos=new FileOutputStream(DST_FILE);
  fos.write(TEST_STRING_2.getBytes());
  fos.close();
  OutputStream failingStream=createFailingStream();
  failingStream.write(TEST_STRING.getBytes());
  try {
    failingStream.close();
    fail("Close didn't throw exception");
  }
 catch (  IOException ioe) {
  }
  assertEquals(TEST_STRING_2,DFSTestUtil.readFile(DST_FILE));
  assertEquals("Temporary file should have been cleaned up",DST_FILE.getName(),Joiner.on(",").join(TEST_DIR.list()));
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.util.TestExactSizeInputStream </h4><pre class="type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testReadArrayNotEnough() throws IOException {
  ExactSizeInputStream s=new ExactSizeInputStream(byteStream("he"),5);
  byte[] buf=new byte[10];
  assertEquals(2,s.read(buf,0,5));
  try {
    s.read(buf,2,3);
    fail("Read buf when should be out of data");
  }
 catch (  EOFException e) {
  }
}

</code></pre>

<br>
<pre class="type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testSkipNotEnough() throws IOException {
  ExactSizeInputStream s=new ExactSizeInputStream(byteStream("he"),5);
  assertEquals(2,s.skip(3));
  try {
    s.skip(1);
    fail("Skip when should be out of data");
  }
 catch (  EOFException e) {
  }
}

</code></pre>

<br>
<pre class="type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testMark() throws IOException {
  ExactSizeInputStream s=new ExactSizeInputStream(byteStream("he"),5);
  assertFalse(s.markSupported());
  try {
    s.mark(1);
    fail("Mark should not succeed");
  }
 catch (  UnsupportedOperationException uoe) {
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testReadNotEnough() throws IOException {
  ExactSizeInputStream s=new ExactSizeInputStream(byteStream("he"),5);
  assertEquals(2,s.available());
  assertEquals((int)'h',s.read());
  assertEquals((int)'e',s.read());
  try {
    s.read();
    fail("Read when should be out of data");
  }
 catch (  EOFException e) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.util.TestMD5FileUtils </h4><pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * Test when .md5 file exists but incorrect checksum
 */
@Test public void testVerifyMD5FileBadDigest() throws Exception {
  MD5FileUtils.saveMD5File(TEST_FILE,MD5Hash.digest(new byte[0]));
  try {
    MD5FileUtils.verifySavedMD5(TEST_FILE,TEST_MD5);
    fail("Did not throw");
  }
 catch (  IOException ioe) {
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * Test when .md5 file exists but has a bad format
 */
@Test public void testVerifyMD5FileBadFormat() throws Exception {
  FileWriter writer=new FileWriter(MD5FileUtils.getDigestFileForFile(TEST_FILE));
  try {
    writer.write("this is not an md5 file");
  }
  finally {
    writer.close();
  }
  try {
    MD5FileUtils.verifySavedMD5(TEST_FILE,TEST_MD5);
    fail("Did not throw");
  }
 catch (  IOException ioe) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.util.TestXMLUtils </h4><pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testInvalidSequence() throws Exception {
  try {
    XMLUtils.unmangleXmlString("\\000g;foo");
    Assert.fail("expected an unmangling error");
  }
 catch (  UnmanglingError e) {
  }
  try {
    XMLUtils.unmangleXmlString("\\0");
    Assert.fail("expected an unmangling error");
  }
 catch (  UnmanglingError e) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.web.TestByteRangeInputStream </h4><pre class="type-2 type-7 type-10 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testByteRange() throws IOException {
  ByteRangeInputStream.URLOpener oMock=getMockURLOpener(new URL("http://test"));
  ByteRangeInputStream.URLOpener rMock=getMockURLOpener(null);
  ByteRangeInputStream bris=new ByteRangeInputStreamImpl(oMock,rMock);
  bris.seek(0);
  assertEquals("getPos wrong",0,bris.getPos());
  bris.read();
  assertEquals("Initial call made incorrectly (offset check)",0,bris.startPos);
  assertEquals("getPos should return 1 after reading one byte",1,bris.getPos());
  verify(oMock,times(1)).connect(0,false);
  bris.read();
  assertEquals("getPos should return 2 after reading two bytes",2,bris.getPos());
  verify(oMock,times(1)).connect(0,false);
  rMock.setURL(new URL("http://resolvedurl/"));
  bris.seek(100);
  bris.read();
  assertEquals("Seek to 100 bytes made incorrectly (offset Check)",100,bris.startPos);
  assertEquals("getPos should return 101 after reading one byte",101,bris.getPos());
  verify(rMock,times(1)).connect(100,true);
  bris.seek(101);
  bris.read();
  verify(rMock,times(1)).connect(100,true);
  verify(rMock,times(0)).connect(101,true);
  bris.seek(2500);
  bris.read();
  assertEquals("Seek to 2500 bytes made incorrectly (offset Check)",2500,bris.startPos);
  doReturn(getMockConnection(null)).when(rMock).connect(anyLong(),anyBoolean());
  bris.seek(500);
  try {
    bris.read();
    fail("Exception should be thrown when content-length is not given");
  }
 catch (  IOException e) {
    assertTrue("Incorrect response message: " + e.getMessage(),e.getMessage().startsWith(HttpHeaders.CONTENT_LENGTH + " is missing: "));
  }
  bris.close();
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.web.TestFSMainOperationsWebHdfs </h4><pre class="type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Override @Test public void testMkdirsFailsForSubdirectoryOfExistingFile() throws Exception {
  Path testDir=getTestRootPath(fSys,"test/hadoop");
  Assert.assertFalse(exists(fSys,testDir));
  fSys.mkdirs(testDir);
  Assert.assertTrue(exists(fSys,testDir));
  createFile(getTestRootPath(fSys,"test/hadoop/file"));
  Path testSubDir=getTestRootPath(fSys,"test/hadoop/file/subdir");
  try {
    fSys.mkdirs(testSubDir);
    Assert.fail("Should throw IOException.");
  }
 catch (  IOException e) {
  }
  try {
    Assert.assertFalse(exists(fSys,testSubDir));
  }
 catch (  AccessControlException e) {
  }
  Path testDeepSubDir=getTestRootPath(fSys,"test/hadoop/file/deep/sub/dir");
  try {
    fSys.mkdirs(testDeepSubDir);
    Assert.fail("Should throw IOException.");
  }
 catch (  IOException e) {
  }
  try {
    Assert.assertFalse(exists(fSys,testDeepSubDir));
  }
 catch (  AccessControlException e) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.web.TestWebHDFS </h4><pre class="type-9 type-2 type-7 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test snapshot creation through WebHdfs
 */
@Test public void testWebHdfsCreateSnapshot() throws Exception {
  MiniDFSCluster cluster=null;
  final Configuration conf=WebHdfsTestUtil.createConf();
  try {
    cluster=new MiniDFSCluster.Builder(conf).numDataNodes(0).build();
    cluster.waitActive();
    final DistributedFileSystem dfs=cluster.getFileSystem();
    final FileSystem webHdfs=WebHdfsTestUtil.getWebHdfsFileSystem(conf,WebHdfsFileSystem.SCHEME);
    final Path foo=new Path("/foo");
    dfs.mkdirs(foo);
    try {
      webHdfs.createSnapshot(foo);
      fail("Cannot create snapshot on a non-snapshottable directory");
    }
 catch (    Exception e) {
      GenericTestUtils.assertExceptionContains("Directory is not a snapshottable directory",e);
    }
    dfs.allowSnapshot(foo);
    webHdfs.createSnapshot(foo,"s1");
    final Path spath=webHdfs.createSnapshot(foo,null);
    Assert.assertTrue(webHdfs.exists(spath));
    final Path s1path=SnapshotTestHelper.getSnapshotRoot(foo,"s1");
    Assert.assertTrue(webHdfs.exists(s1path));
  }
  finally {
    if (cluster != null) {
      cluster.shutdown();
    }
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * Make sure a RetriableException is thrown when rpcServer is null in
 * NamenodeWebHdfsMethods.
 */
@Test public void testRaceWhileNNStartup() throws Exception {
  MiniDFSCluster cluster=null;
  final Configuration conf=WebHdfsTestUtil.createConf();
  try {
    cluster=new MiniDFSCluster.Builder(conf).numDataNodes(0).build();
    cluster.waitActive();
    final NameNode namenode=cluster.getNameNode();
    final NamenodeProtocols rpcServer=namenode.getRpcServer();
    Whitebox.setInternalState(namenode,"rpcServer",null);
    final Path foo=new Path("/foo");
    final FileSystem webHdfs=WebHdfsTestUtil.getWebHdfsFileSystem(conf,WebHdfsFileSystem.SCHEME);
    try {
      webHdfs.mkdirs(foo);
      fail("Expected RetriableException");
    }
 catch (    RetriableException e) {
      GenericTestUtils.assertExceptionContains("Namenode is in startup mode",e);
    }
    Whitebox.setInternalState(namenode,"rpcServer",rpcServer);
  }
  finally {
    if (cluster != null) {
      cluster.shutdown();
    }
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * Test for catching "no datanode" IOException, when to create a file
 * but datanode is not running for some reason.
 */
@Test(timeout=300000) public void testCreateWithNoDN() throws Exception {
  MiniDFSCluster cluster=null;
  final Configuration conf=WebHdfsTestUtil.createConf();
  try {
    cluster=new MiniDFSCluster.Builder(conf).numDataNodes(0).build();
    conf.setInt(DFSConfigKeys.DFS_REPLICATION_KEY,1);
    cluster.waitActive();
    FileSystem fs=WebHdfsTestUtil.getWebHdfsFileSystem(conf,WebHdfsFileSystem.SCHEME);
    fs.create(new Path("/testnodatanode"));
    Assert.fail("No exception was thrown");
  }
 catch (  IOException ex) {
    GenericTestUtils.assertExceptionContains("Failed to find datanode",ex);
  }
 finally {
    if (cluster != null) {
      cluster.shutdown();
    }
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.web.TestWebHdfsContentLength </h4><pre class="type-9 type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testGetOpWithRedirect(){
  Future<String> future1=contentLengthFuture(redirectResponse);
  Future<String> future2=contentLengthFuture(errResponse);
  try {
    fs.open(p).read();
    Assert.fail();
  }
 catch (  IOException ioe) {
  }
  Assert.assertEquals(null,getContentLength(future1));
  Assert.assertEquals(null,getContentLength(future2));
}

</code></pre>

<br>
<pre class="type-9 type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testPutOpWithRedirect(){
  Future<String> future1=contentLengthFuture(redirectResponse);
  Future<String> future2=contentLengthFuture(errResponse);
  try {
    FSDataOutputStream os=fs.create(p);
    os.write(new byte[]{0});
    os.close();
    Assert.fail();
  }
 catch (  IOException ioe) {
  }
  Assert.assertEquals("0",getContentLength(future1));
  Assert.assertEquals("chunked",getContentLength(future2));
}

</code></pre>

<br>
<pre class="type-9 type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testDelete(){
  Future<String> future=contentLengthFuture(errResponse);
  try {
    fs.delete(p,false);
    Assert.fail();
  }
 catch (  IOException ioe) {
  }
  Assert.assertEquals(null,getContentLength(future));
}

</code></pre>

<br>
<pre class="type-9 type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testPutOp(){
  Future<String> future=contentLengthFuture(errResponse);
  try {
    fs.mkdirs(p);
    Assert.fail();
  }
 catch (  IOException ioe) {
  }
  Assert.assertEquals("0",getContentLength(future));
}

</code></pre>

<br>
<pre class="type-9 type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testPostOp(){
  Future<String> future=contentLengthFuture(errResponse);
  try {
    fs.concat(p,new Path[]{p});
    Assert.fail();
  }
 catch (  IOException ioe) {
  }
  Assert.assertEquals("0",getContentLength(future));
}

</code></pre>

<br>
<pre class="type-9 type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testPostOpWithRedirect(){
  Future<String> future1=contentLengthFuture(redirectResponse);
  Future<String> future2=contentLengthFuture(errResponse);
  try {
    FSDataOutputStream os=fs.append(p);
    os.write(new byte[]{0});
    os.close();
    Assert.fail();
  }
 catch (  IOException ioe) {
  }
  Assert.assertEquals("0",getContentLength(future1));
  Assert.assertEquals("chunked",getContentLength(future2));
}

</code></pre>

<br>
<pre class="type-9 type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testGetOp() throws Exception {
  Future<String> future=contentLengthFuture(errResponse);
  try {
    fs.getFileStatus(p);
    Assert.fail();
  }
 catch (  IOException ioe) {
  }
  Assert.assertEquals(null,getContentLength(future));
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.web.TestWebHdfsFileSystemContract </h4><pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testAccess() throws IOException, InterruptedException {
  Path p1=new Path("/pathX");
  try {
    UserGroupInformation ugi=UserGroupInformation.createUserForTesting("alpha",new String[]{"beta"});
    WebHdfsFileSystem fs=WebHdfsTestUtil.getWebHdfsFileSystemAs(ugi,conf,WebHdfsFileSystem.SCHEME);
    fs.mkdirs(p1);
    fs.setPermission(p1,new FsPermission((short)0444));
    fs.access(p1,FsAction.READ);
    try {
      fs.access(p1,FsAction.WRITE);
      fail("The access call should have failed.");
    }
 catch (    AccessControlException e) {
    }
    Path badPath=new Path("/bad");
    try {
      fs.access(badPath,FsAction.READ);
      fail("The access call should have failed");
    }
 catch (    FileNotFoundException e) {
    }
  }
  finally {
    fs.delete(p1,true);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.web.TestWebHdfsTimeouts </h4><pre class="type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Expect connect timeout, because the connection backlog is consumed.
 */
@Test(timeout=TEST_TIMEOUT) public void testConnectTimeout() throws Exception {
  consumeConnectionBacklog();
  try {
    fs.listFiles(new Path("/"),false);
    fail("expected timeout");
  }
 catch (  SocketTimeoutException e) {
    assertEquals("connect timed out",e.getMessage());
  }
}

</code></pre>

<br>
<pre class="type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * On the second step of two-step write, expect read timeout accessing the
 * redirect location, because the bogus server never sends a reply.
 */
@Test(timeout=TEST_TIMEOUT) public void testTwoStepWriteReadTimeout() throws Exception {
  startSingleTemporaryRedirectResponseThread(false);
  OutputStream os=null;
  try {
    os=fs.create(new Path("/file"));
    os.close();
    os=null;
    fail("expected timeout");
  }
 catch (  SocketTimeoutException e) {
    assertEquals("Read timed out",e.getMessage());
  }
 finally {
    IOUtils.cleanup(LOG,os);
  }
}

</code></pre>

<br>
<pre class="type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Expect read timeout, because the bogus server never sends a reply.
 */
@Test(timeout=TEST_TIMEOUT) public void testReadTimeout() throws Exception {
  try {
    fs.listFiles(new Path("/"),false);
    fail("expected timeout");
  }
 catch (  SocketTimeoutException e) {
    assertEquals("Read timed out",e.getMessage());
  }
}

</code></pre>

<br>
<pre class="type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * After a redirect, expect read timeout accessing the redirect location,
 * because the bogus server never sends a reply.
 */
@Test(timeout=TEST_TIMEOUT) public void testRedirectReadTimeout() throws Exception {
  startSingleTemporaryRedirectResponseThread(false);
  try {
    fs.getFileChecksum(new Path("/file"));
    fail("expected timeout");
  }
 catch (  SocketTimeoutException e) {
    assertEquals("Read timed out",e.getMessage());
  }
}

</code></pre>

<br>
<pre class="type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * After a redirect, expect connect timeout accessing the redirect location,
 * because the connection backlog is consumed.
 */
@Test(timeout=TEST_TIMEOUT) public void testRedirectConnectTimeout() throws Exception {
  startSingleTemporaryRedirectResponseThread(true);
  try {
    fs.getFileChecksum(new Path("/file"));
    fail("expected timeout");
  }
 catch (  SocketTimeoutException e) {
    assertEquals("connect timed out",e.getMessage());
  }
}

</code></pre>

<br>
<pre class="type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * On the second step of two-step write, expect connect timeout accessing the
 * redirect location, because the connection backlog is consumed.
 */
@Test(timeout=TEST_TIMEOUT) public void testTwoStepWriteConnectTimeout() throws Exception {
  startSingleTemporaryRedirectResponseThread(true);
  OutputStream os=null;
  try {
    os=fs.create(new Path("/file"));
    fail("expected timeout");
  }
 catch (  SocketTimeoutException e) {
    assertEquals("connect timed out",e.getMessage());
  }
 finally {
    IOUtils.cleanup(LOG,os);
  }
}

</code></pre>

<br>
<pre class="type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Expect read timeout on a URL that requires auth, because the bogus server
 * never sends a reply.
 */
@Test(timeout=TEST_TIMEOUT) public void testAuthUrlReadTimeout() throws Exception {
  try {
    fs.getDelegationToken("renewer");
    fail("expected timeout");
  }
 catch (  SocketTimeoutException e) {
    assertEquals("Read timed out",e.getMessage());
  }
}

</code></pre>

<br>
<pre class="type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Expect connect timeout on a URL that requires auth, because the connection
 * backlog is consumed.
 */
@Test(timeout=TEST_TIMEOUT) public void testAuthUrlConnectTimeout() throws Exception {
  consumeConnectionBacklog();
  try {
    fs.getDelegationToken("renewer");
    fail("expected timeout");
  }
 catch (  SocketTimeoutException e) {
    assertEquals("connect timed out",e.getMessage());
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.web.TestWebHdfsWithAuthenticationFilter </h4><pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testWebHdfsAuthFilter() throws IOException {
  authorized=false;
  try {
    fs.getFileStatus(new Path("/"));
    Assert.fail("The filter fails to block the request");
  }
 catch (  IOException e) {
  }
  authorized=true;
  fs.getFileStatus(new Path("/"));
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hdfs.web.resources.TestParam </h4><pre class="type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testAclPermissionParam(){
  final AclPermissionParam p=new AclPermissionParam("user::rwx,group::r--,other::rwx,user:user1:rwx");
  List<AclEntry> setAclList=AclEntry.parseAclSpec("user::rwx,group::r--,other::rwx,user:user1:rwx",true);
  Assert.assertEquals(setAclList.toString(),p.getAclPermission(true).toString());
  new AclPermissionParam("user::rw-,group::rwx,other::rw-,user:user1:rwx");
  try {
    new AclPermissionParam("user::rw--,group::rwx-,other::rw-");
    Assert.fail();
  }
 catch (  IllegalArgumentException e) {
    LOG.info("EXPECTED: " + e);
  }
  new AclPermissionParam("user::rw-,group::rwx,other::rw-,user:user1:rwx,group:group1:rwx,other::rwx,mask::rwx,default:user:user1:rwx");
  try {
    new AclPermissionParam("user:r-,group:rwx,other:rw-");
    Assert.fail();
  }
 catch (  IllegalArgumentException e) {
    LOG.info("EXPECTED: " + e);
  }
  try {
    new AclPermissionParam("default:::r-,default:group::rwx,other::rw-");
    Assert.fail();
  }
 catch (  IllegalArgumentException e) {
    LOG.info("EXPECTED: " + e);
  }
  try {
    new AclPermissionParam("user:r-,group::rwx,other:rw-,mask:rw-,temp::rwx");
    Assert.fail();
  }
 catch (  IllegalArgumentException e) {
    LOG.info("EXPECTED: " + e);
  }
}

</code></pre>

<br>
<pre class="type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testModificationTimeParam(){
  final ModificationTimeParam p=new ModificationTimeParam(ModificationTimeParam.DEFAULT);
  Assert.assertEquals(-1L,p.getValue().longValue());
  new ModificationTimeParam(-1L);
  try {
    new ModificationTimeParam(-2L);
    Assert.fail();
  }
 catch (  IllegalArgumentException e) {
    LOG.info("EXPECTED: " + e);
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testReplicationParam(){
  final ReplicationParam p=new ReplicationParam(ReplicationParam.DEFAULT);
  Assert.assertEquals(null,p.getValue());
  Assert.assertEquals((short)conf.getInt(DFSConfigKeys.DFS_REPLICATION_KEY,DFSConfigKeys.DFS_REPLICATION_DEFAULT),p.getValue(conf));
  new ReplicationParam((short)1);
  try {
    new ReplicationParam((short)0);
    Assert.fail();
  }
 catch (  IllegalArgumentException e) {
    LOG.info("EXPECTED: " + e);
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testBufferSizeParam(){
  final BufferSizeParam p=new BufferSizeParam(BufferSizeParam.DEFAULT);
  Assert.assertEquals(null,p.getValue());
  Assert.assertEquals(conf.getInt(CommonConfigurationKeysPublic.IO_FILE_BUFFER_SIZE_KEY,CommonConfigurationKeysPublic.IO_FILE_BUFFER_SIZE_DEFAULT),p.getValue(conf));
  new BufferSizeParam(1);
  try {
    new BufferSizeParam(0);
    Assert.fail();
  }
 catch (  IllegalArgumentException e) {
    LOG.info("EXPECTED: " + e);
  }
}

</code></pre>

<br>
<pre class="type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testRecursiveParam(){
  final RecursiveParam p=new RecursiveParam(RecursiveParam.DEFAULT);
  Assert.assertEquals(false,p.getValue());
  new RecursiveParam("falSe");
  try {
    new RecursiveParam("abc");
    Assert.fail();
  }
 catch (  IllegalArgumentException e) {
    LOG.info("EXPECTED: " + e);
  }
}

</code></pre>

<br>
<pre class="type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testOverwriteParam(){
  final OverwriteParam p=new OverwriteParam(OverwriteParam.DEFAULT);
  Assert.assertEquals(false,p.getValue());
  new OverwriteParam("trUe");
  try {
    new OverwriteParam("abc");
    Assert.fail();
  }
 catch (  IllegalArgumentException e) {
    LOG.info("EXPECTED: " + e);
  }
}

</code></pre>

<br>
<pre class="type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testDestinationParam(){
  final DestinationParam p=new DestinationParam(DestinationParam.DEFAULT);
  Assert.assertEquals(null,p.getValue());
  new DestinationParam("/abc");
  try {
    new DestinationParam("abc");
    Assert.fail();
  }
 catch (  IllegalArgumentException e) {
    LOG.info("EXPECTED: " + e);
  }
}

</code></pre>

<br>
<pre class="type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testPermissionParam(){
  final PermissionParam p=new PermissionParam(PermissionParam.DEFAULT);
  Assert.assertEquals(new FsPermission((short)0755),p.getFsPermission());
  new PermissionParam("0");
  try {
    new PermissionParam("-1");
    Assert.fail();
  }
 catch (  IllegalArgumentException e) {
    LOG.info("EXPECTED: " + e);
  }
  new PermissionParam("1777");
  try {
    new PermissionParam("2000");
    Assert.fail();
  }
 catch (  IllegalArgumentException e) {
    LOG.info("EXPECTED: " + e);
  }
  try {
    new PermissionParam("8");
    Assert.fail();
  }
 catch (  IllegalArgumentException e) {
    LOG.info("EXPECTED: " + e);
  }
  try {
    new PermissionParam("abc");
    Assert.fail();
  }
 catch (  IllegalArgumentException e) {
    LOG.info("EXPECTED: " + e);
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testBlockSizeParam(){
  final BlockSizeParam p=new BlockSizeParam(BlockSizeParam.DEFAULT);
  Assert.assertEquals(null,p.getValue());
  Assert.assertEquals(conf.getLongBytes(DFSConfigKeys.DFS_BLOCK_SIZE_KEY,DFSConfigKeys.DFS_BLOCK_SIZE_DEFAULT),p.getValue(conf));
  new BlockSizeParam(1L);
  try {
    new BlockSizeParam(0L);
    Assert.fail();
  }
 catch (  IllegalArgumentException e) {
    LOG.info("EXPECTED: " + e);
  }
}

</code></pre>

<br>
<pre class="type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testAccessTimeParam(){
  final AccessTimeParam p=new AccessTimeParam(AccessTimeParam.DEFAULT);
  Assert.assertEquals(-1L,p.getValue().longValue());
  new AccessTimeParam(-1L);
  try {
    new AccessTimeParam(-2L);
    Assert.fail();
  }
 catch (  IllegalArgumentException e) {
    LOG.info("EXPECTED: " + e);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.http.TestHttpServerWebapps </h4><pre class="type-2 type-7 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
"></span><br>
/** 
 * Test that an invalid webapp triggers an exception
 * @throws Throwable if something went wrong
 */
@Test public void testMissingServerResource() throws Throwable {
  try {
    HttpServer2 server=createServer("NoSuchWebapp");
    String serverDescription=server.toString();
    stop(server);
    fail("Expected an exception, got " + serverDescription);
  }
 catch (  FileNotFoundException expected) {
    log.debug("Expected exception " + expected,expected);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.http.TestServletFilter </h4><pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * Similar to the above test case, except that it uses a different API to add the
 * filter. Regression test for HADOOP-8786.
 */
@Test public void testContextSpecificServletFilterWhenInitThrowsException() throws Exception {
  Configuration conf=new Configuration();
  HttpServer2 http=createTestServer(conf);
  HttpServer2.defineFilter(http.webAppContext,"ErrorFilter",ErrorFilter.class.getName(),null,null);
  try {
    http.start();
    fail("expecting exception");
  }
 catch (  IOException e) {
    GenericTestUtils.assertExceptionContains("Unable to initialize WebAppContext",e);
  }
}

</code></pre>

<br>
<pre class="type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testServletFilterWhenInitThrowsException() throws Exception {
  Configuration conf=new Configuration();
  conf.set(HttpServer2.FILTER_INITIALIZER_PROPERTY,ErrorFilter.Initializer.class.getName());
  HttpServer2 http=createTestServer(conf);
  try {
    http.start();
    fail("expecting exception");
  }
 catch (  IOException e) {
    assertTrue(e.getMessage().contains("Problem in starting http server. Server handlers failed"));
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.io.TestArrayPrimitiveWritable </h4><pre class="type-9 type-2 type-7 type-10 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testOldFormat() throws IOException {
  ObjectWritable.writeObject(out,i,i.getClass(),null);
  in.reset(out.getData(),out.getLength());
  @SuppressWarnings("deprecation") String className=UTF8.readString(in);
  assertEquals("The int[] written by ObjectWritable as a non-compact array " + "was not labelled as an array of int",i.getClass().getName(),className);
  int length=in.readInt();
  assertEquals("The int[] written by ObjectWritable as a non-compact array " + "was not expected length",i.length,length);
  int[] readValue=new int[length];
  try {
    for (int i=0; i < length; i++) {
      readValue[i]=(int)((Integer)ObjectWritable.readObject(in,null));
    }
  }
 catch (  Exception e) {
    fail("The int[] written by ObjectWritable as a non-compact array " + "was corrupted.  Failed to correctly read int[] of length " + length + ". Got exception:\n"+ StringUtils.stringifyException(e));
  }
  assertTrue("The int[] written by ObjectWritable as a non-compact array " + "was corrupted.",Arrays.equals(i,readValue));
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.io.TestIOUtils </h4><pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testCopyBytesShouldCloseInputSteamWhenInputStreamCloseThrowsRunTimeException() throws Exception {
  InputStream inputStream=Mockito.mock(InputStream.class);
  OutputStream outputStream=Mockito.mock(OutputStream.class);
  Mockito.doReturn(-1).when(inputStream).read(new byte[1]);
  Mockito.doThrow(new RuntimeException()).when(inputStream).close();
  try {
    IOUtils.copyBytes(inputStream,outputStream,1,true);
    fail("Didn't throw exception");
  }
 catch (  RuntimeException e) {
  }
  Mockito.verify(inputStream,Mockito.atLeastOnce()).close();
}

</code></pre>

<br>
<pre class="type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testSkipFully() throws IOException {
  byte inArray[]=new byte[]{0,1,2,3,4};
  ByteArrayInputStream in=new ByteArrayInputStream(inArray);
  try {
    in.mark(inArray.length);
    IOUtils.skipFully(in,2);
    IOUtils.skipFully(in,2);
    try {
      IOUtils.skipFully(in,2);
      fail("expected to get a PrematureEOFException");
    }
 catch (    EOFException e) {
      assertEquals("Premature EOF from inputStream " + "after skipping 1 byte(s).",e.getMessage());
    }
    in.reset();
    try {
      IOUtils.skipFully(in,20);
      fail("expected to get a PrematureEOFException");
    }
 catch (    EOFException e) {
      assertEquals("Premature EOF from inputStream " + "after skipping 5 byte(s).",e.getMessage());
    }
    in.reset();
    IOUtils.skipFully(in,5);
    try {
      IOUtils.skipFully(in,10);
      fail("expected to get a PrematureEOFException");
    }
 catch (    EOFException e) {
      assertEquals("Premature EOF from inputStream " + "after skipping 0 byte(s).",e.getMessage());
    }
  }
  finally {
    in.close();
  }
}

</code></pre>

<br>
<pre class="type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testWrappedReadForCompressedData() throws IOException {
  byte[] buf=new byte[2];
  InputStream mockStream=Mockito.mock(InputStream.class);
  Mockito.when(mockStream.read(buf,0,1)).thenReturn(1);
  Mockito.when(mockStream.read(buf,0,2)).thenThrow(new java.lang.InternalError());
  try {
    assertEquals("Check expected value",1,IOUtils.wrappedReadForCompressedData(mockStream,buf,0,1));
  }
 catch (  IOException ioe) {
    fail("Unexpected error while reading");
  }
  try {
    IOUtils.wrappedReadForCompressedData(mockStream,buf,0,2);
  }
 catch (  IOException ioe) {
    GenericTestUtils.assertExceptionContains("Error while reading compressed data",ioe);
  }
}

</code></pre>

<br>
<pre class="type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testCopyBytesWithCountShouldThrowOutTheStreamClosureExceptions() throws Exception {
  InputStream inputStream=Mockito.mock(InputStream.class);
  OutputStream outputStream=Mockito.mock(OutputStream.class);
  Mockito.doReturn(-1).when(inputStream).read(new byte[4096],0,1);
  Mockito.doThrow(new IOException("Exception in closing the stream")).when(outputStream).close();
  try {
    IOUtils.copyBytes(inputStream,outputStream,(long)1,true);
    fail("Should throw out the exception");
  }
 catch (  IOException e) {
    assertEquals("Not throwing the expected exception.","Exception in closing the stream",e.getMessage());
  }
  Mockito.verify(inputStream,Mockito.atLeastOnce()).close();
  Mockito.verify(outputStream,Mockito.atLeastOnce()).close();
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testCopyBytesShouldCloseInputSteamWhenOutputStreamCloseThrowsRunTimeException() throws Exception {
  InputStream inputStream=Mockito.mock(InputStream.class);
  OutputStream outputStream=Mockito.mock(OutputStream.class);
  Mockito.doReturn(-1).when(inputStream).read(new byte[1]);
  Mockito.doThrow(new RuntimeException()).when(outputStream).close();
  try {
    IOUtils.copyBytes(inputStream,outputStream,1,true);
    fail("Didn't throw exception");
  }
 catch (  RuntimeException e) {
  }
  Mockito.verify(outputStream,Mockito.atLeastOnce()).close();
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.io.TestMapFile </h4><pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * test {@code MapFile.Writer} constructor with IOException
 */
@Test public void testPathExplosionWriterCreation(){
  Path path=new Path(TEST_DIR,"testPathExplosionWriterCreation.mapfile");
  String TEST_ERROR_MESSAGE="Mkdirs failed to create directory " + path.getName();
  MapFile.Writer writer=null;
  try {
    FileSystem fsSpy=spy(FileSystem.get(conf));
    Path pathSpy=spy(path);
    when(fsSpy.mkdirs(path)).thenThrow(new IOException(TEST_ERROR_MESSAGE));
    when(pathSpy.getFileSystem(conf)).thenReturn(fsSpy);
    writer=new MapFile.Writer(conf,pathSpy,MapFile.Writer.keyClass(IntWritable.class),MapFile.Writer.valueClass(IntWritable.class));
    fail("fail in testPathExplosionWriterCreation !!!");
  }
 catch (  IOException ex) {
    assertEquals("testPathExplosionWriterCreation ex message error !!!",ex.getMessage(),TEST_ERROR_MESSAGE);
  }
catch (  Exception e) {
    fail("fail in testPathExplosionWriterCreation. Other ex !!!");
  }
 finally {
    IOUtils.cleanup(null,writer);
  }
}

</code></pre>

<br>
<pre class="type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * test throwing {@code IOException} in {@code MapFile.Writer} constructor    
 */
@Test public void testWriteWithFailDirCreation(){
  String ERROR_MESSAGE="Mkdirs failed to create directory";
  Path dirName=new Path(TEST_DIR,"fail.mapfile");
  MapFile.Writer writer=null;
  try {
    FileSystem fs=FileSystem.getLocal(conf);
    FileSystem spyFs=spy(fs);
    Path pathSpy=spy(dirName);
    when(pathSpy.getFileSystem(conf)).thenReturn(spyFs);
    when(spyFs.mkdirs(dirName)).thenReturn(false);
    writer=new MapFile.Writer(conf,pathSpy,MapFile.Writer.keyClass(IntWritable.class),MapFile.Writer.valueClass(Text.class));
    fail("testWriteWithFailDirCreation error !!!");
  }
 catch (  IOException ex) {
    assertTrue("testWriteWithFailDirCreation ex error !!!",ex.getMessage().startsWith(ERROR_MESSAGE));
  }
 finally {
    IOUtils.cleanup(null,writer);
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * test {@code MapFile.Writer.append() } with wrong key class
 */
@Test public void testReaderWithWrongValueClass(){
  final String TEST_METHOD_KEY="testReaderWithWrongValueClass.mapfile";
  MapFile.Writer writer=null;
  try {
    writer=createWriter(TEST_METHOD_KEY,IntWritable.class,Text.class);
    writer.append(new IntWritable(0),new IntWritable(0));
    fail("no excepted exception in testReaderWithWrongKeyClass !!!");
  }
 catch (  IOException ex) {
  }
 finally {
    IOUtils.cleanup(null,writer);
  }
}

</code></pre>

<br>
<pre class="type-11 type-8 type-2 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Allocates resources before the execution of the test cases">TestInitializer</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions inside branch conditions
- Allocates resources before the execution of the test cases
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Before public void setup() throws Exception {
  LocalFileSystem fs=FileSystem.getLocal(conf);
  if (fs.exists(TEST_DIR) && !fs.delete(TEST_DIR,true)) {
    Assert.fail("Can't clean up test root dir");
  }
  fs.mkdirs(TEST_DIR);
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testMainMethodMapFile(){
  String path=new Path(TEST_DIR,"mainMethodMapFile.mapfile").toString();
  String inFile="mainMethodMapFile.mapfile";
  String outFile="mainMethodMapFile.mapfile";
  String[] args={path,outFile};
  MapFile.Writer writer=null;
  try {
    writer=createWriter(inFile,IntWritable.class,Text.class);
    writer.append(new IntWritable(1),new Text("test_text1"));
    writer.append(new IntWritable(2),new Text("test_text2"));
    writer.close();
    MapFile.main(args);
  }
 catch (  Exception ex) {
    fail("testMainMethodMapFile error !!!");
  }
 finally {
    IOUtils.cleanup(null,writer);
  }
}

</code></pre>

<br>
<pre class="type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * test {@code MapFile.Reader.finalKey()} method
 */
@Test public void testOnFinalKey(){
  final String TEST_METHOD_KEY="testOnFinalKey.mapfile";
  int SIZE=10;
  MapFile.Writer writer=null;
  MapFile.Reader reader=null;
  try {
    writer=createWriter(TEST_METHOD_KEY,IntWritable.class,IntWritable.class);
    for (int i=0; i < SIZE; i++)     writer.append(new IntWritable(i),new IntWritable(i));
    writer.close();
    reader=createReader(TEST_METHOD_KEY,IntWritable.class);
    IntWritable expectedKey=new IntWritable(0);
    reader.finalKey(expectedKey);
    assertEquals("testOnFinalKey not same !!!",expectedKey,new IntWritable(9));
  }
 catch (  IOException ex) {
    fail("testOnFinalKey error !!!");
  }
 finally {
    IOUtils.cleanup(null,writer,reader);
  }
}

</code></pre>

<br>
<pre class="type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * test {@code MapFile.rename()} 
 * method with throwing {@code IOException}  
 */
@Test public void testRenameWithException(){
  final String ERROR_MESSAGE="Can't rename file";
  final String NEW_FILE_NAME="test-new.mapfile";
  final String OLD_FILE_NAME="test-old.mapfile";
  MapFile.Writer writer=null;
  try {
    FileSystem fs=FileSystem.getLocal(conf);
    FileSystem spyFs=spy(fs);
    writer=createWriter(OLD_FILE_NAME,IntWritable.class,IntWritable.class);
    writer.close();
    Path oldDir=new Path(TEST_DIR,OLD_FILE_NAME);
    Path newDir=new Path(TEST_DIR,NEW_FILE_NAME);
    when(spyFs.rename(oldDir,newDir)).thenThrow(new IOException(ERROR_MESSAGE));
    MapFile.rename(spyFs,oldDir.toString(),newDir.toString());
    fail("testRenameWithException no exception error !!!");
  }
 catch (  IOException ex) {
    assertEquals("testRenameWithException invalid IOExceptionMessage !!!",ex.getMessage(),ERROR_MESSAGE);
  }
 finally {
    IOUtils.cleanup(null,writer);
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * test  {@code MapFile.Writer.rename()} method 
 */
@Test public void testRename(){
  final String NEW_FILE_NAME="test-new.mapfile";
  final String OLD_FILE_NAME="test-old.mapfile";
  MapFile.Writer writer=null;
  try {
    FileSystem fs=FileSystem.getLocal(conf);
    writer=createWriter(OLD_FILE_NAME,IntWritable.class,IntWritable.class);
    writer.close();
    MapFile.rename(fs,new Path(TEST_DIR,OLD_FILE_NAME).toString(),new Path(TEST_DIR,NEW_FILE_NAME).toString());
    MapFile.delete(fs,new Path(TEST_DIR,NEW_FILE_NAME).toString());
  }
 catch (  IOException ex) {
    fail("testRename error " + ex);
  }
 finally {
    IOUtils.cleanup(null,writer);
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * test {@code MapFile.Reader.getClosest() } with wrong class key
 */
@Test public void testReaderGetClosest() throws Exception {
  final String TEST_METHOD_KEY="testReaderWithWrongKeyClass.mapfile";
  MapFile.Writer writer=null;
  MapFile.Reader reader=null;
  try {
    writer=createWriter(TEST_METHOD_KEY,IntWritable.class,Text.class);
    for (int i=0; i < 10; i++)     writer.append(new IntWritable(i),new Text("value" + i));
    writer.close();
    reader=createReader(TEST_METHOD_KEY,Text.class);
    reader.getClosest(new Text("2"),new Text(""));
    fail("no excepted exception in testReaderWithWrongKeyClass !!!");
  }
 catch (  IOException ex) {
  }
 finally {
    IOUtils.cleanup(null,writer,reader);
  }
}

</code></pre>

<br>
<pre class="type-2 type-1 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * test {@code MapFile.Writer} constructor with key, value
 * and validate it with {@code keyClass(), valueClass()} methods 
 */
@Test public void testKeyValueClasses(){
  Class<? extends WritableComparable<?>> keyClass=IntWritable.class;
  Class<?> valueClass=Text.class;
  try {
    createWriter("testKeyValueClasses.mapfile",IntWritable.class,Text.class).close();
    assertNotNull("writer key class null error !!!",MapFile.Writer.keyClass(keyClass));
    assertNotNull("writer value class null error !!!",MapFile.Writer.valueClass(valueClass));
  }
 catch (  IOException ex) {
    fail(ex.getMessage());
  }
}

</code></pre>

<br>
<pre class="type-9 type-2 type-7 type-1 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * test all available constructor for {@code MapFile.Writer}
 */
@Test @SuppressWarnings("deprecation") public void testDeprecatedConstructors(){
  String path=new Path(TEST_DIR,"writes.mapfile").toString();
  MapFile.Writer writer=null;
  MapFile.Reader reader=null;
  try {
    FileSystem fs=FileSystem.getLocal(conf);
    writer=new MapFile.Writer(conf,fs,path,IntWritable.class,Text.class,CompressionType.RECORD);
    assertNotNull(writer);
    writer.close();
    writer=new MapFile.Writer(conf,fs,path,IntWritable.class,Text.class,CompressionType.RECORD,defaultProgressable);
    assertNotNull(writer);
    writer.close();
    writer=new MapFile.Writer(conf,fs,path,IntWritable.class,Text.class,CompressionType.RECORD,defaultCodec,defaultProgressable);
    assertNotNull(writer);
    writer.close();
    writer=new MapFile.Writer(conf,fs,path,WritableComparator.get(Text.class),Text.class);
    assertNotNull(writer);
    writer.close();
    writer=new MapFile.Writer(conf,fs,path,WritableComparator.get(Text.class),Text.class,SequenceFile.CompressionType.RECORD);
    assertNotNull(writer);
    writer.close();
    writer=new MapFile.Writer(conf,fs,path,WritableComparator.get(Text.class),Text.class,CompressionType.RECORD,defaultProgressable);
    assertNotNull(writer);
    writer.close();
    reader=new MapFile.Reader(fs,path,WritableComparator.get(IntWritable.class),conf);
    assertNotNull(reader);
    assertNotNull("reader key is null !!!",reader.getKeyClass());
    assertNotNull("reader value in null",reader.getValueClass());
  }
 catch (  IOException e) {
    fail(e.getMessage());
  }
 finally {
    IOUtils.cleanup(null,writer,reader);
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * test {@code MapFile.Writer} constructor 
 * with IllegalArgumentException  
 */
@Test public void testKeyLessWriterCreation(){
  MapFile.Writer writer=null;
  try {
    writer=new MapFile.Writer(conf,TEST_DIR);
    fail("fail in testKeyLessWriterCreation !!!");
  }
 catch (  IllegalArgumentException ex) {
  }
catch (  Exception e) {
    fail("fail in testKeyLessWriterCreation. Other ex !!!");
  }
 finally {
    IOUtils.cleanup(null,writer);
  }
}

</code></pre>

<br>
<pre class="type-9 type-13 type-2 type-7 type-10 type-1 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions in iterations
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * test {@code MapFile.Reader.next(key, value)} for iteration.
 */
@Test public void testReaderKeyIteration(){
  final String TEST_METHOD_KEY="testReaderKeyIteration.mapfile";
  int SIZE=10;
  int ITERATIONS=5;
  MapFile.Writer writer=null;
  MapFile.Reader reader=null;
  try {
    writer=createWriter(TEST_METHOD_KEY,IntWritable.class,Text.class);
    int start=0;
    for (int i=0; i < SIZE; i++)     writer.append(new IntWritable(i),new Text("Value:" + i));
    writer.close();
    reader=createReader(TEST_METHOD_KEY,IntWritable.class);
    Writable startValue=new Text("Value:" + start);
    int i=0;
    while (i++ < ITERATIONS) {
      IntWritable key=new IntWritable(start);
      Writable value=startValue;
      while (reader.next(key,value)) {
        assertNotNull(key);
        assertNotNull(value);
      }
      reader.reset();
    }
    assertTrue("reader seek error !!!",reader.seek(new IntWritable(SIZE / 2)));
    assertFalse("reader seek error !!!",reader.seek(new IntWritable(SIZE * 2)));
  }
 catch (  IOException ex) {
    fail("reader seek error !!!");
  }
 finally {
    IOUtils.cleanup(null,writer,reader);
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * test {@code MapFile.Writer.append} method with desc order  
 */
@Test public void testDescOrderWithThrowExceptionWriterAppend(){
  MapFile.Writer writer=null;
  try {
    writer=createWriter(".mapfile",IntWritable.class,Text.class);
    writer.append(new IntWritable(2),new Text("value: " + 1));
    writer.append(new IntWritable(2),new Text("value: " + 2));
    writer.append(new IntWritable(2),new Text("value: " + 4));
    writer.append(new IntWritable(1),new Text("value: " + 3));
    fail("testDescOrderWithThrowExceptionWriterAppend not expected exception error !!!");
  }
 catch (  IOException ex) {
  }
catch (  Exception e) {
    fail("testDescOrderWithThrowExceptionWriterAppend other ex throw !!!");
  }
 finally {
    IOUtils.cleanup(null,writer);
  }
}

</code></pre>

<br>
<pre class="type-9 type-11 type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * test {@code MapFile.Writer.testFix} method
 */
@Test public void testFix(){
  final String INDEX_LESS_MAP_FILE="testFix.mapfile";
  int PAIR_SIZE=20;
  MapFile.Writer writer=null;
  try {
    FileSystem fs=FileSystem.getLocal(conf);
    Path dir=new Path(TEST_DIR,INDEX_LESS_MAP_FILE);
    writer=createWriter(INDEX_LESS_MAP_FILE,IntWritable.class,Text.class);
    for (int i=0; i < PAIR_SIZE; i++)     writer.append(new IntWritable(0),new Text("value"));
    writer.close();
    File indexFile=new File(".","." + INDEX_LESS_MAP_FILE + "/index");
    boolean isDeleted=false;
    if (indexFile.exists())     isDeleted=indexFile.delete();
    if (isDeleted)     assertTrue("testFix error !!!",MapFile.fix(fs,dir,IntWritable.class,Text.class,true,conf) == PAIR_SIZE);
  }
 catch (  Exception ex) {
    fail("testFix error !!!");
  }
 finally {
    IOUtils.cleanup(null,writer);
  }
}

</code></pre>

<br>
<pre class="type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testRenameWithFalse(){
  final String ERROR_MESSAGE="Could not rename";
  final String NEW_FILE_NAME="test-new.mapfile";
  final String OLD_FILE_NAME="test-old.mapfile";
  MapFile.Writer writer=null;
  try {
    FileSystem fs=FileSystem.getLocal(conf);
    FileSystem spyFs=spy(fs);
    writer=createWriter(OLD_FILE_NAME,IntWritable.class,IntWritable.class);
    writer.close();
    Path oldDir=new Path(TEST_DIR,OLD_FILE_NAME);
    Path newDir=new Path(TEST_DIR,NEW_FILE_NAME);
    when(spyFs.rename(oldDir,newDir)).thenReturn(false);
    MapFile.rename(spyFs,oldDir.toString(),newDir.toString());
    fail("testRenameWithException no exception error !!!");
  }
 catch (  IOException ex) {
    assertTrue("testRenameWithFalse invalid IOExceptionMessage error !!!",ex.getMessage().startsWith(ERROR_MESSAGE));
  }
 finally {
    IOUtils.cleanup(null,writer);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.io.TestSecureIOUtils </h4><pre class="type-2 type-15 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Sets implicit assumptions ">AssumptionSetter</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Sets implicit assumptions 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=10000) public void testReadIncorrectlyRestrictedWithSecurity() throws IOException {
  assumeTrue(NativeIO.isAvailable());
  System.out.println("Running test with native libs...");
  String invalidUser="InvalidUser";
  try {
    SecureIOUtils.forceSecureOpenForRead(testFilePathIs,invalidUser,realGroup).close();
    fail("Didn't throw expection for wrong user ownership!");
  }
 catch (  IOException ioe) {
  }
  try {
    SecureIOUtils.forceSecureOpenFSDataInputStream(testFilePathFadis,invalidUser,realGroup).close();
    fail("Didn't throw expection for wrong user ownership!");
  }
 catch (  IOException ioe) {
  }
  try {
    SecureIOUtils.forceSecureOpenForRandomRead(testFilePathRaf,"r",invalidUser,realGroup).close();
    fail("Didn't throw expection for wrong user ownership!");
  }
 catch (  IOException ioe) {
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test(timeout=10000) public void testCreateForWrite() throws IOException {
  try {
    SecureIOUtils.createForWrite(testFilePathIs,0777);
    fail("Was able to create file at " + testFilePathIs);
  }
 catch (  SecureIOUtils.AlreadyExistsException aee) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.io.compress.TestCodec </h4><pre class="type-11 type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testLz4Codec() throws IOException {
  if (NativeCodeLoader.isNativeCodeLoaded()) {
    if (Lz4Codec.isNativeCodeLoaded()) {
      conf.setBoolean(CommonConfigurationKeys.IO_COMPRESSION_CODEC_LZ4_USELZ4HC_KEY,false);
      codecTest(conf,seed,0,"org.apache.hadoop.io.compress.Lz4Codec");
      codecTest(conf,seed,count,"org.apache.hadoop.io.compress.Lz4Codec");
      conf.setBoolean(CommonConfigurationKeys.IO_COMPRESSION_CODEC_LZ4_USELZ4HC_KEY,true);
      codecTest(conf,seed,0,"org.apache.hadoop.io.compress.Lz4Codec");
      codecTest(conf,seed,count,"org.apache.hadoop.io.compress.Lz4Codec");
    }
 else {
      Assert.fail("Native hadoop library available but lz4 not");
    }
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.io.compress.TestCompressorDecompressor </h4><pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testCompressorDecompressor(){
  int SIZE=44 * 1024;
  byte[] rawData=generate(SIZE);
  try {
    CompressDecompressTester.of(rawData).withCompressDecompressPair(new SnappyCompressor(),new SnappyDecompressor()).withCompressDecompressPair(new Lz4Compressor(),new Lz4Decompressor()).withCompressDecompressPair(new BuiltInZlibDeflater(),new BuiltInZlibInflater()).withTestCases(ImmutableSet.of(CompressionTestStrategy.COMPRESS_DECOMPRESS_SINGLE_BLOCK,CompressionTestStrategy.COMPRESS_DECOMPRESS_BLOCK,CompressionTestStrategy.COMPRESS_DECOMPRESS_ERRORS,CompressionTestStrategy.COMPRESS_DECOMPRESS_WITH_EMPTY_STREAM)).test();
  }
 catch (  Exception ex) {
    fail("testCompressorDecompressor error !!!" + ex);
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testCompressorDecompressorWithExeedBufferLimit(){
  int BYTE_SIZE=100 * 1024;
  byte[] rawData=generate(BYTE_SIZE);
  try {
    CompressDecompressTester.of(rawData).withCompressDecompressPair(new SnappyCompressor(BYTE_SIZE + BYTE_SIZE / 2),new SnappyDecompressor(BYTE_SIZE + BYTE_SIZE / 2)).withCompressDecompressPair(new Lz4Compressor(BYTE_SIZE),new Lz4Decompressor(BYTE_SIZE)).withTestCases(ImmutableSet.of(CompressionTestStrategy.COMPRESS_DECOMPRESS_SINGLE_BLOCK,CompressionTestStrategy.COMPRESS_DECOMPRESS_BLOCK,CompressionTestStrategy.COMPRESS_DECOMPRESS_ERRORS,CompressionTestStrategy.COMPRESS_DECOMPRESS_WITH_EMPTY_STREAM)).test();
  }
 catch (  Exception ex) {
    fail("testCompressorDecompressorWithExeedBufferLimit error !!!" + ex);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.io.compress.lz4.TestLz4CompressorDecompressor </h4><pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testDecompressorCompressNullPointerException(){
  try {
    Lz4Decompressor decompressor=new Lz4Decompressor();
    byte[] bytes=generate(1024 * 6);
    decompressor.setInput(bytes,0,bytes.length);
    decompressor.decompress(null,0,0);
    fail("testDecompressorCompressNullPointerException error !!!");
  }
 catch (  NullPointerException ex) {
  }
catch (  Exception e) {
    fail("testDecompressorCompressNullPointerException ex error !!!");
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testDecompressorCompressAIOBException(){
  try {
    Lz4Decompressor decompressor=new Lz4Decompressor();
    byte[] bytes=generate(1024 * 6);
    decompressor.setInput(bytes,0,bytes.length);
    decompressor.decompress(new byte[]{},0,-1);
    fail("testDecompressorCompressAIOBException error !!!");
  }
 catch (  ArrayIndexOutOfBoundsException ex) {
  }
catch (  Exception e) {
    fail("testDecompressorCompressAIOBException ex error !!!");
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testDecompressorSetInputNullPointerException(){
  try {
    Lz4Decompressor decompressor=new Lz4Decompressor();
    decompressor.setInput(null,0,10);
    fail("testDecompressorSetInputNullPointerException error !!!");
  }
 catch (  NullPointerException ex) {
  }
catch (  Exception e) {
    fail("testDecompressorSetInputNullPointerException ex error !!!");
  }
}

</code></pre>

<br>
<pre class="type-9 type-2 type-7 type-10 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testCompressDecompress(){
  int BYTE_SIZE=1024 * 54;
  byte[] bytes=generate(BYTE_SIZE);
  Lz4Compressor compressor=new Lz4Compressor();
  try {
    compressor.setInput(bytes,0,bytes.length);
    assertTrue("Lz4CompressDecompress getBytesRead error !!!",compressor.getBytesRead() > 0);
    assertTrue("Lz4CompressDecompress getBytesWritten before compress error !!!",compressor.getBytesWritten() == 0);
    byte[] compressed=new byte[BYTE_SIZE];
    int cSize=compressor.compress(compressed,0,compressed.length);
    assertTrue("Lz4CompressDecompress getBytesWritten after compress error !!!",compressor.getBytesWritten() > 0);
    Lz4Decompressor decompressor=new Lz4Decompressor();
    decompressor.setInput(compressed,0,cSize);
    byte[] decompressed=new byte[BYTE_SIZE];
    decompressor.decompress(decompressed,0,decompressed.length);
    assertTrue("testLz4CompressDecompress finished error !!!",decompressor.finished());
    assertArrayEquals(bytes,decompressed);
    compressor.reset();
    decompressor.reset();
    assertTrue("decompressor getRemaining error !!!",decompressor.getRemaining() == 0);
  }
 catch (  Exception e) {
    fail("testLz4CompressDecompress ex error!!!");
  }
}

</code></pre>

<br>
<pre class="type-9 type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testCompressorDecopressorLogicWithCompressionStreams(){
  DataOutputStream deflateOut=null;
  DataInputStream inflateIn=null;
  int BYTE_SIZE=1024 * 100;
  byte[] bytes=generate(BYTE_SIZE);
  int bufferSize=262144;
  int compressionOverhead=(bufferSize / 6) + 32;
  try {
    DataOutputBuffer compressedDataBuffer=new DataOutputBuffer();
    CompressionOutputStream deflateFilter=new BlockCompressorStream(compressedDataBuffer,new Lz4Compressor(bufferSize),bufferSize,compressionOverhead);
    deflateOut=new DataOutputStream(new BufferedOutputStream(deflateFilter));
    deflateOut.write(bytes,0,bytes.length);
    deflateOut.flush();
    deflateFilter.finish();
    DataInputBuffer deCompressedDataBuffer=new DataInputBuffer();
    deCompressedDataBuffer.reset(compressedDataBuffer.getData(),0,compressedDataBuffer.getLength());
    CompressionInputStream inflateFilter=new BlockDecompressorStream(deCompressedDataBuffer,new Lz4Decompressor(bufferSize),bufferSize);
    inflateIn=new DataInputStream(new BufferedInputStream(inflateFilter));
    byte[] result=new byte[BYTE_SIZE];
    inflateIn.read(result);
    assertArrayEquals("original array not equals compress/decompressed array",result,bytes);
  }
 catch (  IOException e) {
    fail("testLz4CompressorDecopressorLogicWithCompressionStreams ex error !!!");
  }
 finally {
    try {
      if (deflateOut != null)       deflateOut.close();
      if (inflateIn != null)       inflateIn.close();
    }
 catch (    Exception e) {
    }
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testCompressorCompressAIOBException(){
  try {
    Lz4Compressor compressor=new Lz4Compressor();
    byte[] bytes=generate(1024 * 6);
    compressor.setInput(bytes,0,bytes.length);
    compressor.compress(new byte[]{},0,-1);
    fail("testCompressorCompressAIOBException error !!!");
  }
 catch (  ArrayIndexOutOfBoundsException ex) {
  }
catch (  Exception e) {
    fail("testCompressorCompressAIOBException ex error !!!");
  }
}

</code></pre>

<br>
<pre class="type-9 type-2 type-7 type-10 type-20 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values related to public fields.">PublicFieldVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies values related to public fields.
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testSetInputWithBytesSizeMoreThenDefaultLz4CompressorByfferSize(){
  int BYTES_SIZE=1024 * 64 + 1;
  try {
    Lz4Compressor compressor=new Lz4Compressor();
    byte[] bytes=generate(BYTES_SIZE);
    assertTrue("needsInput error !!!",compressor.needsInput());
    compressor.setInput(bytes,0,bytes.length);
    byte[] emptyBytes=new byte[BYTES_SIZE];
    int csize=compressor.compress(emptyBytes,0,bytes.length);
    assertTrue("testSetInputWithBytesSizeMoreThenDefaultLz4CompressorByfferSize error !!!",csize != 0);
  }
 catch (  Exception ex) {
    fail("testSetInputWithBytesSizeMoreThenDefaultLz4CompressorByfferSize ex error !!!");
  }
}

</code></pre>

<br>
<pre class="type-9 type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testCompressorDecompressorEmptyStreamLogic(){
  ByteArrayInputStream bytesIn=null;
  ByteArrayOutputStream bytesOut=null;
  byte[] buf=null;
  BlockDecompressorStream blockDecompressorStream=null;
  try {
    bytesOut=new ByteArrayOutputStream();
    BlockCompressorStream blockCompressorStream=new BlockCompressorStream(bytesOut,new Lz4Compressor(),1024,0);
    blockCompressorStream.close();
    buf=bytesOut.toByteArray();
    assertEquals("empty stream compressed output size != 4",4,buf.length);
    bytesIn=new ByteArrayInputStream(buf);
    blockDecompressorStream=new BlockDecompressorStream(bytesIn,new Lz4Decompressor(),1024);
    assertEquals("return value is not -1",-1,blockDecompressorStream.read());
  }
 catch (  Exception e) {
    fail("testCompressorDecompressorEmptyStreamLogic ex error !!!" + e.getMessage());
  }
 finally {
    if (blockDecompressorStream != null)     try {
      bytesIn.close();
      bytesOut.close();
      blockDecompressorStream.close();
    }
 catch (    IOException e) {
    }
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testCompressorSetInputAIOBException(){
  try {
    Lz4Compressor compressor=new Lz4Compressor();
    compressor.setInput(new byte[]{},-5,10);
    fail("testCompressorSetInputAIOBException error !!!");
  }
 catch (  ArrayIndexOutOfBoundsException ex) {
  }
catch (  Exception ex) {
    fail("testCompressorSetInputAIOBException ex error !!!");
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testCompressorCompressNullPointerException(){
  try {
    Lz4Compressor compressor=new Lz4Compressor();
    byte[] bytes=generate(1024 * 6);
    compressor.setInput(bytes,0,bytes.length);
    compressor.compress(null,0,0);
    fail("testCompressorCompressNullPointerException error !!!");
  }
 catch (  NullPointerException ex) {
  }
catch (  Exception e) {
    fail("testCompressorCompressNullPointerException ex error !!!");
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testDecompressorSetInputAIOUBException(){
  try {
    Lz4Decompressor decompressor=new Lz4Decompressor();
    decompressor.setInput(new byte[]{},-5,10);
    fail("testDecompressorSetInputAIOBException error !!!");
  }
 catch (  ArrayIndexOutOfBoundsException ex) {
  }
catch (  Exception e) {
    fail("testDecompressorSetInputAIOBException ex error !!!");
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testCompressorSetInputNullPointerException(){
  try {
    Lz4Compressor compressor=new Lz4Compressor();
    compressor.setInput(null,0,10);
    fail("testCompressorSetInputNullPointerException error !!!");
  }
 catch (  NullPointerException ex) {
  }
catch (  Exception e) {
    fail("testCompressorSetInputNullPointerException ex error !!!");
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.io.compress.snappy.TestSnappyCompressorDecompressor </h4><pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testSnappyCompressorSetInputAIOBException(){
  try {
    SnappyCompressor compressor=new SnappyCompressor();
    compressor.setInput(new byte[]{},-5,10);
    fail("testSnappyCompressorSetInputAIOBException error !!!");
  }
 catch (  ArrayIndexOutOfBoundsException ex) {
  }
catch (  Exception ex) {
    fail("testSnappyCompressorSetInputAIOBException ex error !!!");
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testSnappyCompressorCompressAIOBException(){
  try {
    SnappyCompressor compressor=new SnappyCompressor();
    byte[] bytes=BytesGenerator.get(1024 * 6);
    compressor.setInput(bytes,0,bytes.length);
    compressor.compress(new byte[]{},0,-1);
    fail("testSnappyCompressorCompressAIOBException error !!!");
  }
 catch (  ArrayIndexOutOfBoundsException ex) {
  }
catch (  Exception e) {
    fail("testSnappyCompressorCompressAIOBException ex error !!!");
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-10 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testSnappyCompressDecompress(){
  int BYTE_SIZE=1024 * 54;
  byte[] bytes=BytesGenerator.get(BYTE_SIZE);
  SnappyCompressor compressor=new SnappyCompressor();
  try {
    compressor.setInput(bytes,0,bytes.length);
    assertTrue("SnappyCompressDecompress getBytesRead error !!!",compressor.getBytesRead() > 0);
    assertTrue("SnappyCompressDecompress getBytesWritten before compress error !!!",compressor.getBytesWritten() == 0);
    byte[] compressed=new byte[BYTE_SIZE];
    int cSize=compressor.compress(compressed,0,compressed.length);
    assertTrue("SnappyCompressDecompress getBytesWritten after compress error !!!",compressor.getBytesWritten() > 0);
    SnappyDecompressor decompressor=new SnappyDecompressor(BYTE_SIZE);
    decompressor.setInput(compressed,0,cSize);
    byte[] decompressed=new byte[BYTE_SIZE];
    decompressor.decompress(decompressed,0,decompressed.length);
    assertTrue("testSnappyCompressDecompress finished error !!!",decompressor.finished());
    Assert.assertArrayEquals(bytes,decompressed);
    compressor.reset();
    decompressor.reset();
    assertTrue("decompressor getRemaining error !!!",decompressor.getRemaining() == 0);
  }
 catch (  Exception e) {
    fail("testSnappyCompressDecompress ex error!!!");
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testSnappyDecompressorCompressNullPointerException(){
  try {
    SnappyDecompressor decompressor=new SnappyDecompressor();
    byte[] bytes=BytesGenerator.get(1024 * 6);
    decompressor.setInput(bytes,0,bytes.length);
    decompressor.decompress(null,0,0);
    fail("testSnappyDecompressorCompressNullPointerException error !!!");
  }
 catch (  NullPointerException ex) {
  }
catch (  Exception e) {
    fail("testSnappyDecompressorCompressNullPointerException ex error !!!");
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testSnappyCompressorCompressNullPointerException(){
  try {
    SnappyCompressor compressor=new SnappyCompressor();
    byte[] bytes=BytesGenerator.get(1024 * 6);
    compressor.setInput(bytes,0,bytes.length);
    compressor.compress(null,0,0);
    fail("testSnappyCompressorCompressNullPointerException error !!!");
  }
 catch (  NullPointerException ex) {
  }
catch (  Exception e) {
    fail("testSnappyCompressorCompressNullPointerException ex error !!!");
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testSnappyCompressorDecopressorLogicWithCompressionStreams(){
  int BYTE_SIZE=1024 * 100;
  byte[] bytes=BytesGenerator.get(BYTE_SIZE);
  int bufferSize=262144;
  int compressionOverhead=(bufferSize / 6) + 32;
  DataOutputStream deflateOut=null;
  DataInputStream inflateIn=null;
  try {
    DataOutputBuffer compressedDataBuffer=new DataOutputBuffer();
    CompressionOutputStream deflateFilter=new BlockCompressorStream(compressedDataBuffer,new SnappyCompressor(bufferSize),bufferSize,compressionOverhead);
    deflateOut=new DataOutputStream(new BufferedOutputStream(deflateFilter));
    deflateOut.write(bytes,0,bytes.length);
    deflateOut.flush();
    deflateFilter.finish();
    DataInputBuffer deCompressedDataBuffer=new DataInputBuffer();
    deCompressedDataBuffer.reset(compressedDataBuffer.getData(),0,compressedDataBuffer.getLength());
    CompressionInputStream inflateFilter=new BlockDecompressorStream(deCompressedDataBuffer,new SnappyDecompressor(bufferSize),bufferSize);
    inflateIn=new DataInputStream(new BufferedInputStream(inflateFilter));
    byte[] result=new byte[BYTE_SIZE];
    inflateIn.read(result);
    Assert.assertArrayEquals("original array not equals compress/decompressed array",result,bytes);
  }
 catch (  IOException e) {
    fail("testSnappyCompressorDecopressorLogicWithCompressionStreams ex error !!!");
  }
 finally {
    try {
      if (deflateOut != null)       deflateOut.close();
      if (inflateIn != null)       inflateIn.close();
    }
 catch (    Exception e) {
    }
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testSnappyCompressorSetInputNullPointerException(){
  try {
    SnappyCompressor compressor=new SnappyCompressor();
    compressor.setInput(null,0,10);
    fail("testSnappyCompressorSetInputNullPointerException error !!!");
  }
 catch (  NullPointerException ex) {
  }
catch (  Exception ex) {
    fail("testSnappyCompressorSetInputNullPointerException ex error !!!");
  }
}

</code></pre>

<br>
<pre class="type-2 type-15 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Sets implicit assumptions ">AssumptionSetter</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Sets implicit assumptions 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testSnappyDirectBlockCompression(){
  int[] size={4 * 1024,64 * 1024,128 * 1024,1024 * 1024};
  assumeTrue(SnappyCodec.isNativeCodeLoaded());
  try {
    for (int i=0; i < size.length; i++) {
      compressDecompressLoop(size[i]);
    }
  }
 catch (  IOException ex) {
    fail("testSnappyDirectBlockCompression ex !!!" + ex);
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testSnappyDecompressorSetInputNullPointerException(){
  try {
    SnappyDecompressor decompressor=new SnappyDecompressor();
    decompressor.setInput(null,0,10);
    fail("testSnappyDecompressorSetInputNullPointerException error !!!");
  }
 catch (  NullPointerException ex) {
  }
catch (  Exception e) {
    fail("testSnappyDecompressorSetInputNullPointerException ex error !!!");
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testSnappyDecompressorSetInputAIOUBException(){
  try {
    SnappyDecompressor decompressor=new SnappyDecompressor();
    decompressor.setInput(new byte[]{},-5,10);
    fail("testSnappyDecompressorSetInputAIOUBException error !!!");
  }
 catch (  ArrayIndexOutOfBoundsException ex) {
  }
catch (  Exception e) {
    fail("testSnappyDecompressorSetInputAIOUBException ex error !!!");
  }
}

</code></pre>

<br>
<pre class="type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testSnappyBlockCompression(){
  int BYTE_SIZE=1024 * 50;
  int BLOCK_SIZE=512;
  ByteArrayOutputStream out=new ByteArrayOutputStream();
  byte[] block=new byte[BLOCK_SIZE];
  byte[] bytes=BytesGenerator.get(BYTE_SIZE);
  try {
    SnappyCompressor compressor=new SnappyCompressor();
    int off=0;
    int len=BYTE_SIZE;
    int maxSize=BLOCK_SIZE - 18;
    if (BYTE_SIZE > maxSize) {
      do {
        int bufLen=Math.min(len,maxSize);
        compressor.setInput(bytes,off,bufLen);
        compressor.finish();
        while (!compressor.finished()) {
          compressor.compress(block,0,block.length);
          out.write(block);
        }
        compressor.reset();
        off+=bufLen;
        len-=bufLen;
      }
 while (len > 0);
    }
    assertTrue("testSnappyBlockCompression error !!!",out.toByteArray().length > 0);
  }
 catch (  Exception ex) {
    fail("testSnappyBlockCompression ex error !!!");
  }
}

</code></pre>

<br>
<pre class="type-9 type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testCompressorDecompressorEmptyStreamLogic(){
  ByteArrayInputStream bytesIn=null;
  ByteArrayOutputStream bytesOut=null;
  byte[] buf=null;
  BlockDecompressorStream blockDecompressorStream=null;
  try {
    bytesOut=new ByteArrayOutputStream();
    BlockCompressorStream blockCompressorStream=new BlockCompressorStream(bytesOut,new SnappyCompressor(),1024,0);
    blockCompressorStream.close();
    buf=bytesOut.toByteArray();
    assertEquals("empty stream compressed output size != 4",4,buf.length);
    bytesIn=new ByteArrayInputStream(buf);
    blockDecompressorStream=new BlockDecompressorStream(bytesIn,new SnappyDecompressor(),1024);
    assertEquals("return value is not -1",-1,blockDecompressorStream.read());
  }
 catch (  Exception e) {
    fail("testCompressorDecompressorEmptyStreamLogic ex error !!!" + e.getMessage());
  }
 finally {
    if (blockDecompressorStream != null)     try {
      bytesIn.close();
      bytesOut.close();
      blockDecompressorStream.close();
    }
 catch (    IOException e) {
    }
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testSnappyDecompressorCompressAIOBException(){
  try {
    SnappyDecompressor decompressor=new SnappyDecompressor();
    byte[] bytes=BytesGenerator.get(1024 * 6);
    decompressor.setInput(bytes,0,bytes.length);
    decompressor.decompress(new byte[]{},0,-1);
    fail("testSnappyDecompressorCompressAIOBException error !!!");
  }
 catch (  ArrayIndexOutOfBoundsException ex) {
  }
catch (  Exception e) {
    fail("testSnappyDecompressorCompressAIOBException ex error !!!");
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.io.compress.zlib.TestZlibCompressorDecompressor </h4><pre class="type-2 type-7 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testBuiltInGzipDecompressorExceptions(){
  BuiltInGzipDecompressor decompresser=new BuiltInGzipDecompressor();
  try {
    decompresser.setInput(null,0,1);
  }
 catch (  NullPointerException ex) {
  }
catch (  Exception ex) {
    fail("testBuiltInGzipDecompressorExceptions npe error " + ex);
  }
  try {
    decompresser.setInput(new byte[]{0},0,-1);
  }
 catch (  ArrayIndexOutOfBoundsException ex) {
  }
catch (  Exception ex) {
    fail("testBuiltInGzipDecompressorExceptions aioob error" + ex);
  }
  assertTrue("decompresser.getBytesRead error",decompresser.getBytesRead() == 0);
  assertTrue("decompresser.getRemaining error",decompresser.getRemaining() == 0);
  decompresser.reset();
  decompresser.end();
  InputStream decompStream=null;
  try {
    int buffSize=1 * 1024;
    byte buffer[]=new byte[buffSize];
    Decompressor decompressor=new BuiltInGzipDecompressor();
    DataInputBuffer gzbuf=new DataInputBuffer();
    decompStream=new DecompressorStream(gzbuf,decompressor);
    gzbuf.reset(new byte[]{0,0,1,1,1,1,11,1,1,1,1},11);
    decompStream.read(buffer);
  }
 catch (  IOException ioex) {
  }
catch (  Exception ex) {
    fail("invalid 0 and 1 byte in gzip stream" + ex);
  }
  try {
    int buffSize=1 * 1024;
    byte buffer[]=new byte[buffSize];
    Decompressor decompressor=new BuiltInGzipDecompressor();
    DataInputBuffer gzbuf=new DataInputBuffer();
    decompStream=new DecompressorStream(gzbuf,decompressor);
    gzbuf.reset(new byte[]{31,-117,7,1,1,1,1,11,1,1,1,1},11);
    decompStream.read(buffer);
  }
 catch (  IOException ioex) {
  }
catch (  Exception ex) {
    fail("invalid 2 byte in gzip stream" + ex);
  }
  try {
    int buffSize=1 * 1024;
    byte buffer[]=new byte[buffSize];
    Decompressor decompressor=new BuiltInGzipDecompressor();
    DataInputBuffer gzbuf=new DataInputBuffer();
    decompStream=new DecompressorStream(gzbuf,decompressor);
    gzbuf.reset(new byte[]{31,-117,8,-32,1,1,1,11,1,1,1,1},11);
    decompStream.read(buffer);
  }
 catch (  IOException ioex) {
  }
catch (  Exception ex) {
    fail("invalid 3 byte in gzip stream" + ex);
  }
  try {
    int buffSize=1 * 1024;
    byte buffer[]=new byte[buffSize];
    Decompressor decompressor=new BuiltInGzipDecompressor();
    DataInputBuffer gzbuf=new DataInputBuffer();
    decompStream=new DecompressorStream(gzbuf,decompressor);
    gzbuf.reset(new byte[]{31,-117,8,4,1,1,1,11,1,1,1,1},11);
    decompStream.read(buffer);
  }
 catch (  IOException ioex) {
  }
catch (  Exception ex) {
    fail("invalid 3 byte make hasExtraField" + ex);
  }
}

</code></pre>

<br>
<pre class="type-9 type-2 type-7 type-10 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testZlibCompressDecompress(){
  byte[] rawData=null;
  int rawDataSize=0;
  rawDataSize=1024 * 64;
  rawData=generate(rawDataSize);
  try {
    ZlibCompressor compressor=new ZlibCompressor();
    ZlibDecompressor decompressor=new ZlibDecompressor();
    assertFalse("testZlibCompressDecompress finished error",compressor.finished());
    compressor.setInput(rawData,0,rawData.length);
    assertTrue("testZlibCompressDecompress getBytesRead before error",compressor.getBytesRead() == 0);
    compressor.finish();
    byte[] compressedResult=new byte[rawDataSize];
    int cSize=compressor.compress(compressedResult,0,rawDataSize);
    assertTrue("testZlibCompressDecompress getBytesRead ather error",compressor.getBytesRead() == rawDataSize);
    assertTrue("testZlibCompressDecompress compressed size no less then original size",cSize < rawDataSize);
    decompressor.setInput(compressedResult,0,cSize);
    byte[] decompressedBytes=new byte[rawDataSize];
    decompressor.decompress(decompressedBytes,0,decompressedBytes.length);
    assertArrayEquals("testZlibCompressDecompress arrays not equals ",rawData,decompressedBytes);
    compressor.reset();
    decompressor.reset();
  }
 catch (  IOException ex) {
    fail("testZlibCompressDecompress ex !!!" + ex);
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testCompressorDecompressorWithExeedBufferLimit(){
  int BYTE_SIZE=100 * 1024;
  byte[] rawData=generate(BYTE_SIZE);
  try {
    CompressDecompressTester.of(rawData).withCompressDecompressPair(new ZlibCompressor(org.apache.hadoop.io.compress.zlib.ZlibCompressor.CompressionLevel.BEST_COMPRESSION,CompressionStrategy.DEFAULT_STRATEGY,org.apache.hadoop.io.compress.zlib.ZlibCompressor.CompressionHeader.DEFAULT_HEADER,BYTE_SIZE),new ZlibDecompressor(org.apache.hadoop.io.compress.zlib.ZlibDecompressor.CompressionHeader.DEFAULT_HEADER,BYTE_SIZE)).withTestCases(ImmutableSet.of(CompressionTestStrategy.COMPRESS_DECOMPRESS_SINGLE_BLOCK,CompressionTestStrategy.COMPRESS_DECOMPRESS_BLOCK,CompressionTestStrategy.COMPRESS_DECOMPRESS_ERRORS,CompressionTestStrategy.COMPRESS_DECOMPRESS_WITH_EMPTY_STREAM)).test();
  }
 catch (  Exception ex) {
    fail("testCompressorDecompressorWithExeedBufferLimit error !!!" + ex);
  }
}

</code></pre>

<br>
<pre class="type-11 type-2 type-7 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testZlibCompressorDecompressorWithConfiguration(){
  Configuration conf=new Configuration();
  conf.setBoolean(CommonConfigurationKeys.IO_NATIVE_LIB_AVAILABLE_KEY,true);
  if (ZlibFactory.isNativeZlibLoaded(conf)) {
    byte[] rawData;
    int tryNumber=5;
    int BYTE_SIZE=10 * 1024;
    Compressor zlibCompressor=ZlibFactory.getZlibCompressor(conf);
    Decompressor zlibDecompressor=ZlibFactory.getZlibDecompressor(conf);
    rawData=generate(BYTE_SIZE);
    try {
      for (int i=0; i < tryNumber; i++)       compressDecompressZlib(rawData,(ZlibCompressor)zlibCompressor,(ZlibDecompressor)zlibDecompressor);
      zlibCompressor.reinit(conf);
    }
 catch (    Exception ex) {
      fail("testZlibCompressorDecompressorWithConfiguration ex error " + ex);
    }
  }
 else {
    assertTrue("ZlibFactory is using native libs against request",ZlibFactory.isNativeZlibLoaded(conf));
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testZlibCompressorDecompressor(){
  try {
    int SIZE=44 * 1024;
    byte[] rawData=generate(SIZE);
    CompressDecompressTester.of(rawData).withCompressDecompressPair(new ZlibCompressor(),new ZlibDecompressor()).withTestCases(ImmutableSet.of(CompressionTestStrategy.COMPRESS_DECOMPRESS_SINGLE_BLOCK,CompressionTestStrategy.COMPRESS_DECOMPRESS_BLOCK,CompressionTestStrategy.COMPRESS_DECOMPRESS_ERRORS,CompressionTestStrategy.COMPRESS_DECOMPRESS_WITH_EMPTY_STREAM)).test();
  }
 catch (  Exception ex) {
    fail("testCompressorDecompressor error !!!" + ex);
  }
}

</code></pre>

<br>
<pre class="type-2 type-15 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Sets implicit assumptions ">AssumptionSetter</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Sets implicit assumptions 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testZlibDirectCompressDecompress(){
  int[] size={1,4,16,4 * 1024,64 * 1024,128 * 1024,1024 * 1024};
  assumeTrue(NativeCodeLoader.isNativeCodeLoaded());
  try {
    for (int i=0; i < size.length; i++) {
      compressDecompressLoop(size[i]);
    }
  }
 catch (  IOException ex) {
    fail("testZlibDirectCompressDecompress ex !!!" + ex);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.io.file.tfile.TestTFileByteArrays </h4><pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testFailureNegativeOffset() throws IOException {
  if (skip)   return;
  try {
    writer.append("keyX".getBytes(),-1,4,"valueX".getBytes(),0,6);
    Assert.fail("Error on handling negative offset.");
  }
 catch (  Exception e) {
  }
  closeOutput();
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testFailureOutOfOrderKeys() throws IOException {
  if (skip)   return;
  try {
    writer.append("keyM".getBytes(),"valueM".getBytes());
    writer.append("keyA".getBytes(),"valueA".getBytes());
    Assert.fail("Error on handling out of order keys.");
  }
 catch (  Exception e) {
  }
  closeOutput();
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testFailureFileWriteNotAt0Position() throws IOException {
  if (skip)   return;
  closeOutput();
  out=fs.create(path);
  out.write(123);
  try {
    writer=new Writer(out,BLOCK_SIZE,compression,comparator,conf);
    Assert.fail("Failed to catch file write not at position 0.");
  }
 catch (  Exception e) {
  }
  closeOutput();
}

</code></pre>

<br>
<pre class="type-2 type-7 type-1 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testFailureGetNonExistentMetaBlock() throws IOException {
  if (skip)   return;
  writer.append("keyX".getBytes(),"valueX".getBytes());
  DataOutputStream outMeta=writer.prepareMetaBlock("testX",Compression.Algorithm.GZ.getName());
  outMeta.write(123);
  outMeta.write("foo".getBytes());
  outMeta.close();
  closeOutput();
  Reader reader=new Reader(fs.open(path),fs.getFileStatus(path).getLen(),conf);
  DataInputStream mb=reader.getMetaBlock("testX");
  Assert.assertNotNull(mb);
  mb.close();
  try {
    DataInputStream mbBad=reader.getMetaBlock("testY");
    Assert.fail("Error on handling non-existent metablocks.");
  }
 catch (  Exception e) {
  }
  reader.close();
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testFailureNegativeLength_2() throws IOException {
  if (skip)   return;
  closeOutput();
  Reader reader=new Reader(fs.open(path),fs.getFileStatus(path).getLen(),conf);
  Scanner scanner=reader.createScanner();
  try {
    scanner.lowerBound("keyX".getBytes(),0,-1);
    Assert.fail("Error on handling negative length.");
  }
 catch (  Exception e) {
  }
 finally {
    scanner.close();
    reader.close();
  }
  closeOutput();
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testFailureNegativeLength() throws IOException {
  if (skip)   return;
  try {
    writer.append("keyX".getBytes(),0,-1,"valueX".getBytes(),0,6);
    Assert.fail("Error on handling negative length.");
  }
 catch (  Exception e) {
  }
  closeOutput();
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testFailureNegativeLength_3() throws IOException {
  if (skip)   return;
  writeRecords(3);
  Reader reader=new Reader(fs.open(path),fs.getFileStatus(path).getLen(),conf);
  Scanner scanner=reader.createScanner();
  try {
    try {
      scanner.seekTo("keyY".getBytes(),-1,4);
      Assert.fail("Failed to handle negative offset.");
    }
 catch (    Exception e) {
    }
    try {
      scanner.seekTo("keyY".getBytes(),0,-2);
      Assert.fail("Failed to handle negative key length.");
    }
 catch (    Exception e) {
    }
  }
  finally {
    reader.close();
    scanner.close();
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testFailureWriteRecordAfterMetaBlock() throws IOException {
  if (skip)   return;
  writer.append("keyX".getBytes(),"valueX".getBytes());
  DataOutputStream outMeta=writer.prepareMetaBlock("testX",Compression.Algorithm.GZ.getName());
  outMeta.write(123);
  outMeta.write("dummy".getBytes());
  outMeta.close();
  try {
    writer.append("keyY".getBytes(),"valueY".getBytes());
    Assert.fail("Cannot add key/value after start adding meta blocks.");
  }
 catch (  Exception e) {
  }
  closeOutput();
}

</code></pre>

<br>
<pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testFailureReadValueManyTimes() throws IOException {
  if (skip)   return;
  writeRecords(5);
  Reader reader=new Reader(fs.open(path),fs.getFileStatus(path).getLen(),conf);
  Scanner scanner=reader.createScanner();
  byte[] vbuf=new byte[BUF_SIZE];
  int vlen=scanner.entry().getValueLength();
  scanner.entry().getValue(vbuf);
  Assert.assertEquals(new String(vbuf,0,vlen),VALUE + 0);
  try {
    scanner.entry().getValue(vbuf);
    Assert.fail("Cannot get the value mlutiple times.");
  }
 catch (  Exception e) {
  }
  scanner.close();
  reader.close();
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testFailureWriterNotClosed() throws IOException {
  if (skip)   return;
  Reader reader=null;
  try {
    reader=new Reader(fs.open(path),fs.getFileStatus(path).getLen(),conf);
    Assert.fail("Cannot read before closing the writer.");
  }
 catch (  IOException e) {
  }
 finally {
    if (reader != null) {
      reader.close();
    }
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testFailureOpenEmptyFile() throws IOException {
  if (skip)   return;
  closeOutput();
  path=new Path(fs.getWorkingDirectory(),outputFile);
  out=fs.create(path);
  out.close();
  try {
    new Reader(fs.open(path),fs.getFileStatus(path).getLen(),conf);
    Assert.fail("Error on handling empty files.");
  }
 catch (  EOFException e) {
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testFailureNegativeOffset_2() throws IOException {
  if (skip)   return;
  closeOutput();
  Reader reader=new Reader(fs.open(path),fs.getFileStatus(path).getLen(),conf);
  Scanner scanner=reader.createScanner();
  try {
    scanner.lowerBound("keyX".getBytes(),-1,4);
    Assert.fail("Error on handling negative offset.");
  }
 catch (  Exception e) {
  }
 finally {
    reader.close();
    scanner.close();
  }
  closeOutput();
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testFailureBadCompressionCodec() throws IOException {
  if (skip)   return;
  closeOutput();
  out=fs.create(path);
  try {
    writer=new Writer(out,BLOCK_SIZE,"BAD",comparator,conf);
    Assert.fail("Error on handling invalid compression codecs.");
  }
 catch (  Exception e) {
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testFailureOpenRandomFile() throws IOException {
  if (skip)   return;
  closeOutput();
  path=new Path(fs.getWorkingDirectory(),outputFile);
  out=fs.create(path);
  Random rand=new Random();
  byte[] buf=new byte[K];
  for (int nx=0; nx < K + 2; nx++) {
    rand.nextBytes(buf);
    out.write(buf);
  }
  out.close();
  try {
    new Reader(fs.open(path),fs.getFileStatus(path).getLen(),conf);
    Assert.fail("Error on handling random files.");
  }
 catch (  IOException e) {
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testFailureWriteMetaBlocksWithSameName() throws IOException {
  if (skip)   return;
  writer.append("keyX".getBytes(),"valueX".getBytes());
  DataOutputStream outMeta=writer.prepareMetaBlock("testX",Compression.Algorithm.GZ.getName());
  outMeta.write(123);
  outMeta.write("foo".getBytes());
  outMeta.close();
  try {
    writer.prepareMetaBlock("testX",Compression.Algorithm.GZ.getName());
    Assert.fail("Cannot create metablocks with the same name.");
  }
 catch (  Exception e) {
  }
  closeOutput();
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.io.nativeio.TestNativeIO </h4><pre class="type-2 type-10 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test basic chmod operation
 */
@Test(timeout=30000) public void testChmod() throws Exception {
  if (Path.WINDOWS) {
    return;
  }
  try {
    NativeIO.POSIX.chmod("/this/file/doesnt/exist",777);
    fail("Chmod of non-existent file didn't fail");
  }
 catch (  NativeIOException nioe) {
    assertEquals(Errno.ENOENT,nioe.getErrno());
  }
  File toChmod=new File(TEST_DIR,"testChmod");
  assertTrue("Create test subject",toChmod.exists() || toChmod.mkdir());
  NativeIO.POSIX.chmod(toChmod.getAbsolutePath(),0777);
  assertPermissions(toChmod,0777);
  NativeIO.POSIX.chmod(toChmod.getAbsolutePath(),0000);
  assertPermissions(toChmod,0000);
  NativeIO.POSIX.chmod(toChmod.getAbsolutePath(),0644);
  assertPermissions(toChmod,0644);
}

</code></pre>

<br>
<pre class="type-2 type-10 type-1 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies whether objects are null
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=30000) public void testOpenWithCreate() throws Exception {
  if (Path.WINDOWS) {
    return;
  }
  LOG.info("Test creating a file with O_CREAT");
  FileDescriptor fd=NativeIO.POSIX.open(new File(TEST_DIR,"testWorkingOpen").getAbsolutePath(),NativeIO.POSIX.O_WRONLY | NativeIO.POSIX.O_CREAT,0700);
  assertNotNull(true);
  assertTrue(fd.valid());
  FileOutputStream fos=new FileOutputStream(fd);
  fos.write("foo".getBytes());
  fos.close();
  assertFalse(fd.valid());
  LOG.info("Test exclusive create");
  try {
    fd=NativeIO.POSIX.open(new File(TEST_DIR,"testWorkingOpen").getAbsolutePath(),NativeIO.POSIX.O_WRONLY | NativeIO.POSIX.O_CREAT | NativeIO.POSIX.O_EXCL,0700);
    fail("Was able to create existing file with O_EXCL");
  }
 catch (  NativeIOException nioe) {
    LOG.info("Got expected exception for failed exclusive create",nioe);
    assertEquals(Errno.EEXIST,nioe.getErrno());
  }
}

</code></pre>

<br>
<pre class="type-9 type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=30000) public void testSetFilePointer() throws Exception {
  if (!Path.WINDOWS) {
    return;
  }
  LOG.info("Set a file pointer on Windows");
  try {
    File testfile=new File(TEST_DIR,"testSetFilePointer");
    assertTrue("Create test subject",testfile.exists() || testfile.createNewFile());
    FileWriter writer=new FileWriter(testfile);
    try {
      for (int i=0; i < 200; i++)       if (i < 100)       writer.write('a');
 else       writer.write('b');
      writer.flush();
    }
 catch (    Exception writerException) {
      fail("Got unexpected exception: " + writerException.getMessage());
    }
 finally {
      writer.close();
    }
    FileDescriptor fd=NativeIO.Windows.createFile(testfile.getCanonicalPath(),NativeIO.Windows.GENERIC_READ,NativeIO.Windows.FILE_SHARE_READ | NativeIO.Windows.FILE_SHARE_WRITE | NativeIO.Windows.FILE_SHARE_DELETE,NativeIO.Windows.OPEN_EXISTING);
    NativeIO.Windows.setFilePointer(fd,120,NativeIO.Windows.FILE_BEGIN);
    FileReader reader=new FileReader(fd);
    try {
      int c=reader.read();
      assertTrue("Unexpected character: " + c,c == 'b');
    }
 catch (    Exception readerException) {
      fail("Got unexpected exception: " + readerException.getMessage());
    }
 finally {
      reader.close();
    }
  }
 catch (  Exception e) {
    fail("Got unexpected exception: " + e.getMessage());
  }
}

</code></pre>

<br>
<pre class="type-11 type-2 type-7 type-10 type-15 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Sets implicit assumptions ">AssumptionSetter</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Sets implicit assumptions 
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=30000) public void testRenameTo() throws Exception {
  final File TEST_DIR=new File(new File(System.getProperty("test.build.data","build/test/data")),"renameTest");
  assumeTrue(TEST_DIR.mkdirs());
  File nonExistentFile=new File(TEST_DIR,"nonexistent");
  File targetFile=new File(TEST_DIR,"target");
  try {
    NativeIO.renameTo(nonExistentFile,targetFile);
    Assert.fail();
  }
 catch (  NativeIOException e) {
    if (Path.WINDOWS) {
      Assert.assertEquals(String.format("The system cannot find the file specified.%n"),e.getMessage());
    }
 else {
      Assert.assertEquals(Errno.ENOENT,e.getErrno());
    }
  }
  File sourceFile=new File(TEST_DIR,"source");
  Assert.assertTrue(sourceFile.createNewFile());
  NativeIO.renameTo(sourceFile,sourceFile);
  NativeIO.renameTo(sourceFile,targetFile);
  sourceFile=new File(TEST_DIR,"source");
  Assert.assertTrue(sourceFile.createNewFile());
  File badTarget=new File(targetFile,"subdir");
  try {
    NativeIO.renameTo(sourceFile,badTarget);
    Assert.fail();
  }
 catch (  NativeIOException e) {
    if (Path.WINDOWS) {
      Assert.assertEquals(String.format("The parameter is incorrect.%n"),e.getMessage());
    }
 else {
      Assert.assertEquals(Errno.ENOTDIR,e.getErrno());
    }
  }
  FileUtils.deleteQuietly(TEST_DIR);
}

</code></pre>

<br>
<pre class="type-2 type-15 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Sets implicit assumptions ">AssumptionSetter</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Sets implicit assumptions 
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=30000) public void testSyncFileRange() throws Exception {
  FileOutputStream fos=new FileOutputStream(new File(TEST_DIR,"testSyncFileRange"));
  try {
    fos.write("foo".getBytes());
    NativeIO.POSIX.sync_file_range(fos.getFD(),0,1024,NativeIO.POSIX.SYNC_FILE_RANGE_WRITE);
  }
 catch (  UnsupportedOperationException uoe) {
    assumeTrue(false);
  }
 finally {
    fos.close();
  }
  try {
    NativeIO.POSIX.sync_file_range(fos.getFD(),0,1024,NativeIO.POSIX.SYNC_FILE_RANGE_WRITE);
    fail("Did not throw on bad file");
  }
 catch (  NativeIOException nioe) {
    assertEquals(Errno.EBADF,nioe.getErrno());
  }
}

</code></pre>

<br>
<pre class="type-2 type-15 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Sets implicit assumptions ">AssumptionSetter</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Sets implicit assumptions 
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=30000) public void testPosixFadvise() throws Exception {
  if (Path.WINDOWS) {
    return;
  }
  FileInputStream fis=new FileInputStream("/dev/zero");
  try {
    NativeIO.POSIX.posix_fadvise(fis.getFD(),0,0,NativeIO.POSIX.POSIX_FADV_SEQUENTIAL);
  }
 catch (  UnsupportedOperationException uoe) {
    assumeTrue(false);
  }
catch (  NativeIOException nioe) {
  }
 finally {
    fis.close();
  }
  try {
    NativeIO.POSIX.posix_fadvise(fis.getFD(),0,1024,NativeIO.POSIX.POSIX_FADV_SEQUENTIAL);
    fail("Did not throw on bad file");
  }
 catch (  NativeIOException nioe) {
    assertEquals(Errno.EBADF,nioe.getErrno());
  }
  try {
    NativeIO.POSIX.posix_fadvise(null,0,1024,NativeIO.POSIX.POSIX_FADV_SEQUENTIAL);
    fail("Did not throw on null file");
  }
 catch (  NullPointerException npe) {
  }
}

</code></pre>

<br>
<pre class="type-9 type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=30000) public void testCreateFile() throws Exception {
  if (!Path.WINDOWS) {
    return;
  }
  LOG.info("Open a file on Windows with SHARE_DELETE shared mode");
  try {
    File testfile=new File(TEST_DIR,"testCreateFile");
    assertTrue("Create test subject",testfile.exists() || testfile.createNewFile());
    FileDescriptor fd=NativeIO.Windows.createFile(testfile.getCanonicalPath(),NativeIO.Windows.GENERIC_READ,NativeIO.Windows.FILE_SHARE_READ | NativeIO.Windows.FILE_SHARE_WRITE | NativeIO.Windows.FILE_SHARE_DELETE,NativeIO.Windows.OPEN_EXISTING);
    FileInputStream fin=new FileInputStream(fd);
    try {
      fin.read();
      File newfile=new File(TEST_DIR,"testRenamedFile");
      boolean renamed=testfile.renameTo(newfile);
      assertTrue("Rename failed.",renamed);
      fin.read();
    }
 catch (    Exception e) {
      fail("Got unexpected exception: " + e.getMessage());
    }
 finally {
      fin.close();
    }
  }
 catch (  Exception e) {
    fail("Got unexpected exception: " + e.getMessage());
  }
}

</code></pre>

<br>
<pre class="type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=30000) public void testOpenMissingWithoutCreate() throws Exception {
  if (Path.WINDOWS) {
    return;
  }
  LOG.info("Open a missing file without O_CREAT and it should fail");
  try {
    FileDescriptor fd=NativeIO.POSIX.open(new File(TEST_DIR,"doesntexist").getAbsolutePath(),NativeIO.POSIX.O_WRONLY,0700);
    fail("Able to open a new file without O_CREAT");
  }
 catch (  NativeIOException nioe) {
    LOG.info("Got expected exception",nioe);
    assertEquals(Errno.ENOENT,nioe.getErrno());
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.io.nativeio.TestSharedFileDescriptorFactory </h4><pre class="type-9 type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testDirectoryFallbacks() throws Exception {
  File nonExistentPath=new File(TEST_BASE,"nonexistent");
  File permissionDeniedPath=new File("/");
  File goodPath=new File(TEST_BASE,"testDirectoryFallbacks");
  goodPath.mkdirs();
  try {
    SharedFileDescriptorFactory.create("shm_",new String[]{nonExistentPath.getAbsolutePath(),permissionDeniedPath.getAbsolutePath()});
    Assert.fail();
  }
 catch (  IOException e) {
  }
  SharedFileDescriptorFactory factory=SharedFileDescriptorFactory.create("shm_",new String[]{nonExistentPath.getAbsolutePath(),permissionDeniedPath.getAbsolutePath(),goodPath.getAbsolutePath()});
  Assert.assertEquals(goodPath.getAbsolutePath(),factory.getPath());
  FileUtil.fullyDelete(goodPath);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.io.retry.TestFailoverProxy </h4><pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testFailoverOnStandbyException() throws UnreliableException, IOException, StandbyException {
  UnreliableInterface unreliable=(UnreliableInterface)RetryProxy.create(UnreliableInterface.class,newFlipFlopProxyProvider(),RetryPolicies.failoverOnNetworkException(1));
  assertEquals("impl1",unreliable.succeedsOnceThenFailsReturningString());
  try {
    unreliable.succeedsOnceThenFailsReturningString();
    fail("should not have succeeded twice");
  }
 catch (  UnreliableException e) {
    assertEquals("impl1",e.getMessage());
  }
  unreliable=(UnreliableInterface)RetryProxy.create(UnreliableInterface.class,newFlipFlopProxyProvider(TypeOfExceptionToFailWith.STANDBY_EXCEPTION,TypeOfExceptionToFailWith.UNRELIABLE_EXCEPTION),RetryPolicies.failoverOnNetworkException(1));
  assertEquals("impl1",unreliable.succeedsOnceThenFailsReturningString());
  assertEquals("impl2",unreliable.succeedsOnceThenFailsReturningString());
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * Test that if a non-idempotent void function is called, and there is an exception,
 * the exception is properly propagated
 */
@Test public void testExceptionPropagatedForNonIdempotentVoid() throws Exception {
  UnreliableInterface unreliable=(UnreliableInterface)RetryProxy.create(UnreliableInterface.class,newFlipFlopProxyProvider(TypeOfExceptionToFailWith.IO_EXCEPTION,TypeOfExceptionToFailWith.UNRELIABLE_EXCEPTION),RetryPolicies.failoverOnNetworkException(1));
  try {
    unreliable.nonIdempotentVoidFailsIfIdentifierDoesntMatch("impl2");
    fail("did not throw an exception");
  }
 catch (  Exception e) {
  }
}

</code></pre>

<br>
<pre class="type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Ensure that normal IO exceptions don't result in a failover.
 */
@Test public void testExpectedIOException(){
  UnreliableInterface unreliable=(UnreliableInterface)RetryProxy.create(UnreliableInterface.class,newFlipFlopProxyProvider(TypeOfExceptionToFailWith.REMOTE_EXCEPTION,TypeOfExceptionToFailWith.UNRELIABLE_EXCEPTION),RetryPolicies.failoverOnNetworkException(RetryPolicies.TRY_ONCE_THEN_FAIL,10,1000,10000));
  try {
    unreliable.failsIfIdentifierDoesntMatch("no-such-identifier");
    fail("Should have thrown *some* exception");
  }
 catch (  Exception e) {
    assertTrue("Expected IOE but got " + e.getClass(),e instanceof IOException);
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testSuccedsOnceThenFailOver() throws UnreliableException, IOException, StandbyException {
  UnreliableInterface unreliable=(UnreliableInterface)RetryProxy.create(UnreliableInterface.class,newFlipFlopProxyProvider(),new FailOverOnceOnAnyExceptionPolicy());
  assertEquals("impl1",unreliable.succeedsOnceThenFailsReturningString());
  assertEquals("impl2",unreliable.succeedsOnceThenFailsReturningString());
  try {
    unreliable.succeedsOnceThenFailsReturningString();
    fail("should not have succeeded more than twice");
  }
 catch (  UnreliableException e) {
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testFailoverOnNetworkExceptionIdempotentOperation() throws UnreliableException, IOException, StandbyException {
  UnreliableInterface unreliable=(UnreliableInterface)RetryProxy.create(UnreliableInterface.class,newFlipFlopProxyProvider(TypeOfExceptionToFailWith.IO_EXCEPTION,TypeOfExceptionToFailWith.UNRELIABLE_EXCEPTION),RetryPolicies.failoverOnNetworkException(1));
  assertEquals("impl1",unreliable.succeedsOnceThenFailsReturningString());
  try {
    unreliable.succeedsOnceThenFailsReturningString();
    fail("should not have succeeded twice");
  }
 catch (  IOException e) {
    assertEquals("impl1",e.getMessage());
  }
  assertEquals("impl1",unreliable.succeedsOnceThenFailsReturningStringIdempotent());
  assertEquals("impl2",unreliable.succeedsOnceThenFailsReturningStringIdempotent());
}

</code></pre>

<br>
<pre class="type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testNeverFailOver() throws UnreliableException, IOException, StandbyException {
  UnreliableInterface unreliable=(UnreliableInterface)RetryProxy.create(UnreliableInterface.class,newFlipFlopProxyProvider(),RetryPolicies.TRY_ONCE_THEN_FAIL);
  unreliable.succeedsOnceThenFailsReturningString();
  try {
    unreliable.succeedsOnceThenFailsReturningString();
    fail("should not have succeeded twice");
  }
 catch (  UnreliableException e) {
    assertEquals("impl1",e.getMessage());
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.io.retry.TestRetryProxy </h4><pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testExponentialRetry() throws UnreliableException {
  UnreliableInterface unreliable=(UnreliableInterface)RetryProxy.create(UnreliableInterface.class,unreliableImpl,exponentialBackoffRetry(5,1L,TimeUnit.NANOSECONDS));
  unreliable.alwaysSucceeds();
  unreliable.failsOnceThenSucceeds();
  try {
    unreliable.failsTenTimesThenSucceeds();
    fail("Should fail");
  }
 catch (  UnreliableException e) {
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testRetryUpToMaximumCountWithProportionalSleep() throws UnreliableException {
  UnreliableInterface unreliable=(UnreliableInterface)RetryProxy.create(UnreliableInterface.class,unreliableImpl,retryUpToMaximumCountWithProportionalSleep(8,1,TimeUnit.NANOSECONDS));
  unreliable.alwaysSucceeds();
  unreliable.failsOnceThenSucceeds();
  try {
    unreliable.failsTenTimesThenSucceeds();
    fail("Should fail");
  }
 catch (  UnreliableException e) {
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testRetryByException() throws UnreliableException {
  Map<Class<? extends Exception>,RetryPolicy> exceptionToPolicyMap=Collections.<Class<? extends Exception>,RetryPolicy>singletonMap(FatalException.class,TRY_ONCE_THEN_FAIL);
  UnreliableInterface unreliable=(UnreliableInterface)RetryProxy.create(UnreliableInterface.class,unreliableImpl,retryByException(RETRY_FOREVER,exceptionToPolicyMap));
  unreliable.failsOnceThenSucceeds();
  try {
    unreliable.alwaysFailsWithFatalException();
    fail("Should fail");
  }
 catch (  FatalException e) {
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testRetryUpToMaximumTimeWithFixedSleep() throws UnreliableException {
  UnreliableInterface unreliable=(UnreliableInterface)RetryProxy.create(UnreliableInterface.class,unreliableImpl,retryUpToMaximumTimeWithFixedSleep(80,10,TimeUnit.NANOSECONDS));
  unreliable.alwaysSucceeds();
  unreliable.failsOnceThenSucceeds();
  try {
    unreliable.failsTenTimesThenSucceeds();
    fail("Should fail");
  }
 catch (  UnreliableException e) {
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testRetryUpToMaximumCountWithFixedSleep() throws UnreliableException {
  UnreliableInterface unreliable=(UnreliableInterface)RetryProxy.create(UnreliableInterface.class,unreliableImpl,retryUpToMaximumCountWithFixedSleep(8,1,TimeUnit.NANOSECONDS));
  unreliable.alwaysSucceeds();
  unreliable.failsOnceThenSucceeds();
  try {
    unreliable.failsTenTimesThenSucceeds();
    fail("Should fail");
  }
 catch (  UnreliableException e) {
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testRetryByRemoteException(){
  Map<Class<? extends Exception>,RetryPolicy> exceptionToPolicyMap=Collections.<Class<? extends Exception>,RetryPolicy>singletonMap(FatalException.class,TRY_ONCE_THEN_FAIL);
  UnreliableInterface unreliable=(UnreliableInterface)RetryProxy.create(UnreliableInterface.class,unreliableImpl,retryByRemoteException(RETRY_FOREVER,exceptionToPolicyMap));
  try {
    unreliable.alwaysFailsWithRemoteFatalException();
    fail("Should fail");
  }
 catch (  RemoteException e) {
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testTryOnceThenFail() throws UnreliableException {
  UnreliableInterface unreliable=(UnreliableInterface)RetryProxy.create(UnreliableInterface.class,unreliableImpl,TRY_ONCE_THEN_FAIL);
  unreliable.alwaysSucceeds();
  try {
    unreliable.failsOnceThenSucceeds();
    fail("Should fail");
  }
 catch (  UnreliableException e) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.ipc.TestIPC </h4><pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test(timeout=60000) public void testIpcConnectTimeout() throws IOException {
  Server server=new TestServer(1,true);
  InetSocketAddress addr=NetUtils.getConnectAddress(server);
  Client.setConnectTimeout(conf,100);
  Client client=new Client(LongWritable.class,conf);
  try {
    client.call(new LongWritable(RANDOM.nextLong()),addr,null,null,MIN_SLEEP_TIME * 2,conf);
    fail("Expected an exception to have been thrown");
  }
 catch (  SocketTimeoutException e) {
    LOG.info("Get a SocketTimeoutException ",e);
  }
}

</code></pre>

<br>
<pre class="type-9 type-2 type-10 type-1 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testStandAloneClient() throws IOException {
  Client client=new Client(LongWritable.class,conf);
  InetSocketAddress address=new InetSocketAddress("127.0.0.1",10);
  try {
    client.call(new LongWritable(RANDOM.nextLong()),address,null,null,0,conf);
    fail("Expected an exception to have been thrown");
  }
 catch (  IOException e) {
    String message=e.getMessage();
    String addressText=address.getHostName() + ":" + address.getPort();
    assertTrue("Did not find " + addressText + " in "+ message,message.contains(addressText));
    Throwable cause=e.getCause();
    assertNotNull("No nested exception in " + e,cause);
    String causeText=cause.getMessage();
    assertTrue("Did not find " + causeText + " in "+ message,message.contains(causeText));
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test(timeout=60000) public void testIpcTimeout() throws IOException {
  Server server=new TestServer(1,true);
  InetSocketAddress addr=NetUtils.getConnectAddress(server);
  server.start();
  Client client=new Client(LongWritable.class,conf);
  try {
    client.call(new LongWritable(RANDOM.nextLong()),addr,null,null,MIN_SLEEP_TIME / 2,conf);
    fail("Expected an exception to have been thrown");
  }
 catch (  SocketTimeoutException e) {
    LOG.info("Get a SocketTimeoutException ",e);
  }
  client.call(new LongWritable(RANDOM.nextLong()),addr,null,null,3 * PING_INTERVAL + MIN_SLEEP_TIME,conf);
}

</code></pre>

<br>
<pre class="type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test that, if the socket factory throws an IOE, it properly propagates
 * to the client.
 */
@Test(timeout=60000) public void testSocketFactoryException() throws IOException {
  SocketFactory mockFactory=mock(SocketFactory.class);
  doThrow(new IOException("Injected fault")).when(mockFactory).createSocket();
  Client client=new Client(LongWritable.class,conf,mockFactory);
  InetSocketAddress address=new InetSocketAddress("127.0.0.1",10);
  try {
    client.call(new LongWritable(RANDOM.nextLong()),address,null,null,0,conf);
    fail("Expected an exception to have been thrown");
  }
 catch (  IOException e) {
    assertTrue(e.getMessage().contains("Injected fault"));
  }
}

</code></pre>

<br>
<pre class="type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test that, if a RuntimeException is thrown after creating a socket
 * but before successfully connecting to the IPC server, that the
 * failure is handled properly. This is a regression test for
 * HADOOP-7428.
 */
@Test(timeout=60000) public void testRTEDuringConnectionSetup() throws IOException {
  SocketFactory spyFactory=spy(NetUtils.getDefaultSocketFactory(conf));
  Mockito.doAnswer(new Answer<Socket>(){
    @Override public Socket answer(    InvocationOnMock invocation) throws Throwable {
      Socket s=spy((Socket)invocation.callRealMethod());
      doThrow(new RuntimeException("Injected fault")).when(s).setSoTimeout(anyInt());
      return s;
    }
  }
).when(spyFactory).createSocket();
  Server server=new TestServer(1,true);
  server.start();
  try {
    InetSocketAddress address=NetUtils.getConnectAddress(server);
    Client client=new Client(LongWritable.class,conf,spyFactory);
    try {
      client.call(new LongWritable(RANDOM.nextLong()),address,null,null,0,conf);
      fail("Expected an exception to have been thrown");
    }
 catch (    Exception e) {
      LOG.info("caught expected exception",e);
      assertTrue(StringUtils.stringifyException(e).contains("Injected fault"));
    }
    Mockito.reset(spyFactory);
    client.call(new LongWritable(RANDOM.nextLong()),address,null,null,0,conf);
  }
  finally {
    server.stop();
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.ipc.TestProtoBufRpc </h4><pre class="type-9 type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=6000) public void testExtraLongRpc() throws Exception {
  TestRpcService2 client=getClient2();
  final String shortString=StringUtils.repeat("X",4);
  EchoRequestProto echoRequest=EchoRequestProto.newBuilder().setMessage(shortString).build();
  EchoResponseProto echoResponse=client.echo2(null,echoRequest);
  Assert.assertEquals(shortString,echoResponse.getMessage());
  final String longString=StringUtils.repeat("X",4096);
  echoRequest=EchoRequestProto.newBuilder().setMessage(longString).build();
  try {
    echoResponse=client.echo2(null,echoRequest);
    Assert.fail("expected extra-long RPC to fail");
  }
 catch (  ServiceException se) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.ipc.TestRPC </h4><pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testStandaloneClient() throws IOException {
  try {
    TestProtocol proxy=RPC.waitForProxy(TestProtocol.class,TestProtocol.versionID,new InetSocketAddress(ADDRESS,20),conf,15000L);
    proxy.echo("");
    fail("We should not have reached here");
  }
 catch (  ConnectException ioe) {
  }
}

</code></pre>

<br>
<pre class="type-11 type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testRPCBuilder() throws IOException {
  try {
    new RPC.Builder(null).setProtocol(TestProtocol.class).setInstance(new TestImpl()).setBindAddress(ADDRESS).setPort(0).setNumHandlers(5).setVerbose(true).build();
    fail("Didn't throw HadoopIllegalArgumentException");
  }
 catch (  Exception e) {
    if (!(e instanceof HadoopIllegalArgumentException)) {
      fail("Expecting HadoopIllegalArgumentException but caught " + e);
    }
  }
  try {
    new RPC.Builder(conf).setInstance(new TestImpl()).setBindAddress(ADDRESS).setPort(0).setNumHandlers(5).setVerbose(true).build();
    fail("Didn't throw HadoopIllegalArgumentException");
  }
 catch (  Exception e) {
    if (!(e instanceof HadoopIllegalArgumentException)) {
      fail("Expecting HadoopIllegalArgumentException but caught " + e);
    }
  }
  try {
    new RPC.Builder(conf).setProtocol(TestProtocol.class).setBindAddress(ADDRESS).setPort(0).setNumHandlers(5).setVerbose(true).build();
    fail("Didn't throw HadoopIllegalArgumentException");
  }
 catch (  Exception e) {
    if (!(e instanceof HadoopIllegalArgumentException)) {
      fail("Expecting HadoopIllegalArgumentException but caught " + e);
    }
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test(timeout=90000) public void testRPCInterruptedSimple() throws IOException {
  final Configuration conf=new Configuration();
  Server server=new RPC.Builder(conf).setProtocol(TestProtocol.class).setInstance(new TestImpl()).setBindAddress(ADDRESS).setPort(0).setNumHandlers(5).setVerbose(true).setSecretManager(null).build();
  server.start();
  try {
    InetSocketAddress addr=NetUtils.getConnectAddress(server);
    final TestProtocol proxy=RPC.getProxy(TestProtocol.class,TestProtocol.versionID,addr,conf);
    proxy.ping();
    Thread.currentThread().interrupt();
    try {
      proxy.ping();
      fail("Interruption did not cause IPC to fail");
    }
 catch (    IOException ioe) {
      if (!ioe.toString().contains("InterruptedException")) {
        throw ioe;
      }
      Thread.interrupted();
    }
  }
  finally {
    server.stop();
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.ipc.TestRPCCompatibility </h4><pre class="type-2 type-7 type-10 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testVersionMismatch() throws IOException {
  server=new RPC.Builder(conf).setProtocol(TestProtocol2.class).setInstance(new TestImpl2()).setBindAddress(ADDRESS).setPort(0).setNumHandlers(2).setVerbose(false).build();
  server.start();
  addr=NetUtils.getConnectAddress(server);
  TestProtocol4 proxy=RPC.getProxy(TestProtocol4.class,TestProtocol4.versionID,addr,conf);
  try {
    proxy.echo(21);
    fail("The call must throw VersionMismatch exception");
  }
 catch (  RemoteException ex) {
    Assert.assertEquals(RPC.VersionMismatch.class.getName(),ex.getClassName());
    Assert.assertTrue(ex.getErrorCode().equals(RpcErrorCodeProto.ERROR_RPC_VERSION_MISMATCH));
  }
catch (  IOException ex) {
    fail("Expected version mismatch but got " + ex);
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testVersion1ClientVersion0Server() throws Exception {
  server=new RPC.Builder(conf).setProtocol(TestProtocol0.class).setInstance(new TestImpl0()).setBindAddress(ADDRESS).setPort(0).setNumHandlers(2).setVerbose(false).build();
  server.start();
  addr=NetUtils.getConnectAddress(server);
  proxy=RPC.getProtocolProxy(TestProtocol1.class,TestProtocol1.versionID,addr,conf);
  TestProtocol1 proxy1=(TestProtocol1)proxy.getProxy();
  proxy1.ping();
  try {
    proxy1.echo("hello");
    fail("Echo should fail");
  }
 catch (  IOException e) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.lib.server.TestServer </h4><pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test @TestDir public void services() throws Exception {
  String dir=TestDirHelper.getTestDir().getAbsolutePath();
  Configuration conf;
  Server server;
  ORDER.clear();
  conf=new Configuration(false);
  server=new Server("server",dir,dir,dir,dir,conf);
  server.init();
  assertEquals(ORDER.size(),0);
  ORDER.clear();
  String services=StringUtils.join(",",Arrays.asList(MyService1.class.getName(),MyService3.class.getName()));
  conf=new Configuration(false);
  conf.set("server.services",services);
  server=new Server("server",dir,dir,dir,dir,conf);
  server.init();
  assertEquals(server.get(MyService1.class).getInterface(),MyService1.class);
  assertEquals(server.get(MyService3.class).getInterface(),MyService3.class);
  assertEquals(ORDER.size(),4);
  assertEquals(ORDER.get(0),"s1.init");
  assertEquals(ORDER.get(1),"s3.init");
  assertEquals(ORDER.get(2),"s1.postInit");
  assertEquals(ORDER.get(3),"s3.postInit");
  server.destroy();
  assertEquals(ORDER.size(),6);
  assertEquals(ORDER.get(4),"s3.destroy");
  assertEquals(ORDER.get(5),"s1.destroy");
  ORDER.clear();
  services=StringUtils.join(",",Arrays.asList(MyService1.class.getName(),MyService2.class.getName(),MyService3.class.getName()));
  conf=new Configuration(false);
  conf.set("server.services",services);
  server=new Server("server",dir,dir,dir,dir,conf);
  try {
    server.init();
    fail();
  }
 catch (  ServerException ex) {
    assertEquals(MyService2.class,ex.getError().getClass());
  }
catch (  Exception ex) {
    fail();
  }
  assertEquals(ORDER.size(),3);
  assertEquals(ORDER.get(0),"s1.init");
  assertEquals(ORDER.get(1),"s2.init");
  assertEquals(ORDER.get(2),"s1.destroy");
  ORDER.clear();
  services=StringUtils.join(",",Arrays.asList(MyService1.class.getName(),MyService5.class.getName()));
  conf=new Configuration(false);
  conf.set("server.services",services);
  server=new Server("server",dir,dir,dir,dir,conf);
  server.init();
  assertEquals(ORDER.size(),4);
  assertEquals(ORDER.get(0),"s1.init");
  assertEquals(ORDER.get(1),"s5.init");
  assertEquals(ORDER.get(2),"s1.postInit");
  assertEquals(ORDER.get(3),"s5.postInit");
  server.destroy();
  assertEquals(ORDER.size(),6);
  assertEquals(ORDER.get(4),"s5.destroy");
  assertEquals(ORDER.get(5),"s1.destroy");
  ORDER.clear();
  services=StringUtils.join(",",Arrays.asList(MyService1.class.getName(),MyService3.class.getName()));
  String servicesExt=StringUtils.join(",",Arrays.asList(MyService1a.class.getName()));
  conf=new Configuration(false);
  conf.set("server.services",services);
  conf.set("server.services.ext",servicesExt);
  server=new Server("server",dir,dir,dir,dir,conf);
  server.init();
  assertEquals(server.get(MyService1.class).getClass(),MyService1a.class);
  assertEquals(ORDER.size(),4);
  assertEquals(ORDER.get(0),"s1a.init");
  assertEquals(ORDER.get(1),"s3.init");
  assertEquals(ORDER.get(2),"s1a.postInit");
  assertEquals(ORDER.get(3),"s3.postInit");
  server.destroy();
  assertEquals(ORDER.size(),6);
  assertEquals(ORDER.get(4),"s3.destroy");
  assertEquals(ORDER.get(5),"s1a.destroy");
  ORDER.clear();
  services=StringUtils.join(",",Arrays.asList(MyService1.class.getName(),MyService3.class.getName()));
  conf=new Configuration(false);
  conf.set("server.services",services);
  server=new Server("server",dir,dir,dir,dir,conf);
  server.init();
  server.setService(MyService1a.class);
  assertEquals(ORDER.size(),6);
  assertEquals(ORDER.get(4),"s1.destroy");
  assertEquals(ORDER.get(5),"s1a.init");
  assertEquals(server.get(MyService1.class).getClass(),MyService1a.class);
  server.destroy();
  assertEquals(ORDER.size(),8);
  assertEquals(ORDER.get(6),"s3.destroy");
  assertEquals(ORDER.get(7),"s1a.destroy");
  ORDER.clear();
  services=StringUtils.join(",",Arrays.asList(MyService1.class.getName(),MyService3.class.getName()));
  conf=new Configuration(false);
  conf.set("server.services",services);
  server=new Server("server",dir,dir,dir,dir,conf);
  server.init();
  server.setService(MyService5.class);
  assertEquals(ORDER.size(),5);
  assertEquals(ORDER.get(4),"s5.init");
  assertEquals(server.get(MyService5.class).getClass(),MyService5.class);
  server.destroy();
  assertEquals(ORDER.size(),8);
  assertEquals(ORDER.get(5),"s5.destroy");
  assertEquals(ORDER.get(6),"s3.destroy");
  assertEquals(ORDER.get(7),"s1.destroy");
  ORDER.clear();
  services=StringUtils.join(",",Arrays.asList(MyService1.class.getName(),MyService3.class.getName()));
  conf=new Configuration(false);
  conf.set("server.services",services);
  server=new Server("server",dir,dir,dir,dir,conf);
  server.init();
  try {
    server.setService(MyService7.class);
    fail();
  }
 catch (  ServerException ex) {
    assertEquals(ServerException.ERROR.S09,ex.getError());
  }
catch (  Exception ex) {
    fail();
  }
  assertEquals(ORDER.size(),6);
  assertEquals(ORDER.get(4),"s3.destroy");
  assertEquals(ORDER.get(5),"s1.destroy");
  ORDER.clear();
  services=StringUtils.join(",",Arrays.asList(MyService1.class.getName(),MyService6.class.getName()));
  conf=new Configuration(false);
  conf.set("server.services",services);
  server=new Server("server",dir,dir,dir,dir,conf);
  server.init();
  assertEquals(server.get(MyService1.class).getInterface(),MyService1.class);
  assertEquals(server.get(MyService6.class).getInterface(),MyService6.class);
  server.destroy();
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.lib.service.hadoop.TestFileSystemAccessService </h4><pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test @TestDir @TestHdfs public void fileSystemExecutor() throws Exception {
  String dir=TestDirHelper.getTestDir().getAbsolutePath();
  String services=StringUtils.join(",",Arrays.asList(InstrumentationService.class.getName(),SchedulerService.class.getName(),FileSystemAccessService.class.getName()));
  Configuration hadoopConf=new Configuration(false);
  hadoopConf.set(CommonConfigurationKeysPublic.FS_DEFAULT_NAME_KEY,TestHdfsHelper.getHdfsConf().get(CommonConfigurationKeysPublic.FS_DEFAULT_NAME_KEY));
  createHadoopConf(hadoopConf);
  Configuration conf=new Configuration(false);
  conf.set("server.services",services);
  conf.set("server.hadoop.filesystem.cache.purge.timeout","0");
  Server server=new Server("server",dir,dir,dir,dir,conf);
  server.init();
  FileSystemAccess hadoop=server.get(FileSystemAccess.class);
  final FileSystem fsa[]=new FileSystem[1];
  hadoop.execute("u",hadoop.getFileSystemConfiguration(),new FileSystemAccess.FileSystemExecutor<Void>(){
    @Override public Void execute(    FileSystem fs) throws IOException {
      fs.mkdirs(new Path("/tmp/foo"));
      fsa[0]=fs;
      return null;
    }
  }
);
  try {
    fsa[0].mkdirs(new Path("/tmp/foo"));
    Assert.fail();
  }
 catch (  IOException ex) {
  }
catch (  Exception ex) {
    Assert.fail();
  }
  server.destroy();
}

</code></pre>

<br>
<pre class="type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test @TestDir @TestHdfs public void fileSystemExecutorException() throws Exception {
  String dir=TestDirHelper.getTestDir().getAbsolutePath();
  String services=StringUtils.join(",",Arrays.asList(InstrumentationService.class.getName(),SchedulerService.class.getName(),FileSystemAccessService.class.getName()));
  Configuration hadoopConf=new Configuration(false);
  hadoopConf.set(CommonConfigurationKeysPublic.FS_DEFAULT_NAME_KEY,TestHdfsHelper.getHdfsConf().get(CommonConfigurationKeysPublic.FS_DEFAULT_NAME_KEY));
  createHadoopConf(hadoopConf);
  Configuration conf=new Configuration(false);
  conf.set("server.services",services);
  conf.set("server.hadoop.filesystem.cache.purge.timeout","0");
  Server server=new Server("server",dir,dir,dir,dir,conf);
  server.init();
  FileSystemAccess hadoop=server.get(FileSystemAccess.class);
  final FileSystem fsa[]=new FileSystem[1];
  try {
    hadoop.execute("u",hadoop.getFileSystemConfiguration(),new FileSystemAccess.FileSystemExecutor<Void>(){
      @Override public Void execute(      FileSystem fs) throws IOException {
        fsa[0]=fs;
        throw new IOException();
      }
    }
);
    Assert.fail();
  }
 catch (  FileSystemAccessException ex) {
    Assert.assertEquals(ex.getError(),FileSystemAccessException.ERROR.H03);
  }
catch (  Exception ex) {
    Assert.fail();
  }
  try {
    fsa[0].mkdirs(new Path("/tmp/foo"));
    Assert.fail();
  }
 catch (  IOException ex) {
  }
catch (  Exception ex) {
    Assert.fail();
  }
  server.destroy();
}

</code></pre>

<br>
<pre class="type-2 type-7 type-1 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test @TestDir @TestHdfs public void createFileSystem() throws Exception {
  String dir=TestDirHelper.getTestDir().getAbsolutePath();
  String services=StringUtils.join(",",Arrays.asList(InstrumentationService.class.getName(),SchedulerService.class.getName(),FileSystemAccessService.class.getName()));
  Configuration hadoopConf=new Configuration(false);
  hadoopConf.set(CommonConfigurationKeysPublic.FS_DEFAULT_NAME_KEY,TestHdfsHelper.getHdfsConf().get(CommonConfigurationKeysPublic.FS_DEFAULT_NAME_KEY));
  createHadoopConf(hadoopConf);
  Configuration conf=new Configuration(false);
  conf.set("server.services",services);
  conf.set("server.hadoop.filesystem.cache.purge.timeout","0");
  Server server=new Server("server",dir,dir,dir,dir,conf);
  server.init();
  FileSystemAccess hadoop=server.get(FileSystemAccess.class);
  FileSystem fs=hadoop.createFileSystem("u",hadoop.getFileSystemConfiguration());
  Assert.assertNotNull(fs);
  fs.mkdirs(new Path("/tmp/foo"));
  hadoop.releaseFileSystem(fs);
  try {
    fs.mkdirs(new Path("/tmp/foo"));
    Assert.fail();
  }
 catch (  IOException ex) {
  }
catch (  Exception ex) {
    Assert.fail();
  }
  server.destroy();
}

</code></pre>

<br>
<pre class="type-2 type-7 type-1 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test @TestDir @TestHdfs public void fileSystemCache() throws Exception {
  String dir=TestDirHelper.getTestDir().getAbsolutePath();
  String services=StringUtils.join(",",Arrays.asList(InstrumentationService.class.getName(),SchedulerService.class.getName(),FileSystemAccessService.class.getName()));
  Configuration hadoopConf=new Configuration(false);
  hadoopConf.set(CommonConfigurationKeysPublic.FS_DEFAULT_NAME_KEY,TestHdfsHelper.getHdfsConf().get(CommonConfigurationKeysPublic.FS_DEFAULT_NAME_KEY));
  createHadoopConf(hadoopConf);
  Configuration conf=new Configuration(false);
  conf.set("server.services",services);
  conf.set("server.hadoop.filesystem.cache.purge.frequency","1");
  conf.set("server.hadoop.filesystem.cache.purge.timeout","1");
  Server server=new Server("server",dir,dir,dir,dir,conf);
  try {
    server.init();
    FileSystemAccess hadoop=server.get(FileSystemAccess.class);
    FileSystem fs1=hadoop.createFileSystem("u",hadoop.getFileSystemConfiguration());
    Assert.assertNotNull(fs1);
    fs1.mkdirs(new Path("/tmp/foo1"));
    hadoop.releaseFileSystem(fs1);
    fs1.mkdirs(new Path("/tmp/foo2"));
    FileSystem fs2=hadoop.createFileSystem("u",hadoop.getFileSystemConfiguration());
    Assert.assertEquals(fs1,fs2);
    Thread.sleep(4 * 1000);
    fs1.mkdirs(new Path("/tmp/foo2"));
    Thread.sleep(4 * 1000);
    fs2.mkdirs(new Path("/tmp/foo"));
    hadoop.releaseFileSystem(fs2);
    Thread.sleep(4 * 1000);
    try {
      fs2.mkdirs(new Path("/tmp/foo"));
      Assert.fail();
    }
 catch (    IOException ex) {
    }
catch (    Exception ex) {
      Assert.fail();
    }
  }
  finally {
    server.destroy();
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.lib.service.instrumentation.TestInstrumentationService </h4><pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void cron(){
  InstrumentationService.Cron cron=new InstrumentationService.Cron();
  assertEquals(cron.start,0);
  assertEquals(cron.lapStart,0);
  assertEquals(cron.own,0);
  assertEquals(cron.total,0);
  long begin=Time.now();
  assertEquals(cron.start(),cron);
  assertEquals(cron.start(),cron);
  assertEquals(cron.start,begin,20);
  assertEquals(cron.start,cron.lapStart);
  sleep(100);
  assertEquals(cron.stop(),cron);
  long end=Time.now();
  long delta=end - begin;
  assertEquals(cron.own,delta,20);
  assertEquals(cron.total,0);
  assertEquals(cron.lapStart,0);
  sleep(100);
  long reStart=Time.now();
  cron.start();
  assertEquals(cron.start,begin,20);
  assertEquals(cron.lapStart,reStart,20);
  sleep(100);
  cron.stop();
  long reEnd=Time.now();
  delta+=reEnd - reStart;
  assertEquals(cron.own,delta,20);
  assertEquals(cron.total,0);
  assertEquals(cron.lapStart,0);
  cron.end();
  assertEquals(cron.total,reEnd - begin,20);
  try {
    cron.start();
    fail();
  }
 catch (  IllegalStateException ex) {
  }
catch (  Exception ex) {
    fail();
  }
  try {
    cron.stop();
    fail();
  }
 catch (  IllegalStateException ex) {
  }
catch (  Exception ex) {
    fail();
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.mapred.TestClientServiceDelegate </h4><pre class="type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testRemoteExceptionFromHistoryServer() throws Exception {
  MRClientProtocol historyServerProxy=mock(MRClientProtocol.class);
  when(historyServerProxy.getJobReport(getJobReportRequest())).thenThrow(new IOException("Job ID doesnot Exist"));
  ResourceMgrDelegate rm=mock(ResourceMgrDelegate.class);
  when(rm.getApplicationReport(TypeConverter.toYarn(oldJobId).getAppId())).thenReturn(null);
  ClientServiceDelegate clientServiceDelegate=getClientServiceDelegate(historyServerProxy,rm);
  try {
    clientServiceDelegate.getJobStatus(oldJobId);
    Assert.fail("Invoke should throw exception after retries.");
  }
 catch (  IOException e) {
    Assert.assertTrue(e.getMessage().contains("Job ID doesnot Exist"));
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.mapred.TestCombineTextInputFormat </h4><pre class="type-9 type-11 type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test using the gzip codec for reading
 */
@Test(timeout=10000) public void testGzip() throws IOException {
  JobConf job=new JobConf(defaultConf);
  CompressionCodec gzip=new GzipCodec();
  ReflectionUtils.setConf(gzip,job);
  localFs.delete(workDir,true);
  writeFile(localFs,new Path(workDir,"part1.txt.gz"),gzip,"the quick\nbrown\nfox jumped\nover\n the lazy\n dog\n");
  writeFile(localFs,new Path(workDir,"part2.txt.gz"),gzip,"this is a test\nof gzip\n");
  FileInputFormat.setInputPaths(job,workDir);
  CombineTextInputFormat format=new CombineTextInputFormat();
  InputSplit[] splits=format.getSplits(job,100);
  assertEquals("compressed splits == 1",1,splits.length);
  List<Text> results=readSplit(format,splits[0],job);
  assertEquals("splits[0] length",8,results.size());
  final String[] firstList={"the quick","brown","fox jumped","over"," the lazy"," dog"};
  final String[] secondList={"this is a test","of gzip"};
  String first=results.get(0).toString();
  if (first.equals(firstList[0])) {
    testResults(results,firstList,secondList);
  }
 else   if (first.equals(secondList[0])) {
    testResults(results,secondList,firstList);
  }
 else {
    fail("unexpected first token!");
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.mapred.TestFileInputFormat </h4><pre class="type-2 type-7 type-10 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testListStatusErrorOnNonExistantDir() throws IOException {
  Configuration conf=new Configuration();
  conf.setInt(FileInputFormat.LIST_STATUS_NUM_THREADS,numThreads);
  org.apache.hadoop.mapreduce.lib.input.TestFileInputFormat.configureTestErrorOnNonExistantDir(conf,localFs);
  JobConf jobConf=new JobConf(conf);
  TextInputFormat fif=new TextInputFormat();
  fif.configure(jobConf);
  try {
    fif.listStatus(jobConf);
    Assert.fail("Expecting an IOException for a missing Input path");
  }
 catch (  IOException e) {
    Path expectedExceptionPath=new Path(TEST_ROOT_DIR,"input2");
    expectedExceptionPath=localFs.makeQualified(expectedExceptionPath);
    Assert.assertTrue(e instanceof InvalidInputException);
    Assert.assertEquals("Input path does not exist: " + expectedExceptionPath.toString(),e.getMessage());
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.mapred.TestMaster </h4><pre class="type-9 type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testGetMasterAddress(){
  YarnConfiguration conf=new YarnConfiguration();
  String masterHostname=Master.getMasterAddress(conf).getHostName();
  InetSocketAddress rmAddr=NetUtils.createSocketAddr(YarnConfiguration.DEFAULT_RM_ADDRESS);
  assertEquals(masterHostname,rmAddr.getHostName());
  conf.set(MRConfig.FRAMEWORK_NAME,MRConfig.CLASSIC_FRAMEWORK_NAME);
  conf.set(MRConfig.MASTER_ADDRESS,"local:invalid");
  try {
    Master.getMasterAddress(conf);
    fail("Should not reach here as there is a bad master address");
  }
 catch (  Exception e) {
  }
  conf.set(MRConfig.MASTER_ADDRESS,"bar.com:8042");
  masterHostname=Master.getMasterAddress(conf).getHostName();
  assertEquals(masterHostname,"bar.com");
  conf.set(MRConfig.FRAMEWORK_NAME,MRConfig.YARN_FRAMEWORK_NAME);
  conf.set(YarnConfiguration.RM_ADDRESS,"foo1.com:8192");
  masterHostname=Master.getMasterAddress(conf).getHostName();
  assertEquals(masterHostname,"foo1.com");
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.mapred.TestMiniMRChildTask </h4><pre class="type-9 type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * To test OS dependent setting of default execution path for a MapRed task.
 * Mainly that we can use MRJobConfig.DEFAULT_MAPRED_ADMIN_USER_ENV to set -
 * for WINDOWS: %HADOOP_COMMON_HOME%\bin is expected to be included in PATH - for
 * Linux: $HADOOP_COMMON_HOME/lib/native is expected to be included in
 * LD_LIBRARY_PATH
 */
@Test public void testMapRedExecutionEnv(){
  try {
    Map<String,String> environment=new HashMap<String,String>();
    String setupHadoopHomeCommand=Shell.WINDOWS ? "HADOOP_COMMON_HOME=C:\\fake\\PATH\\to\\hadoop\\common\\home" : "HADOOP_COMMON_HOME=/fake/path/to/hadoop/common/home";
    MRApps.setEnvFromInputString(environment,setupHadoopHomeCommand,conf);
    MRApps.setEnvFromInputString(environment,conf.get(MRJobConfig.MAPRED_ADMIN_USER_ENV,MRJobConfig.DEFAULT_MAPRED_ADMIN_USER_ENV),conf);
    String executionPaths=environment.get(Shell.WINDOWS ? "PATH" : "LD_LIBRARY_PATH");
    String toFind=Shell.WINDOWS ? "C:\\fake\\PATH\\to\\hadoop\\common\\home\\bin" : "/fake/path/to/hadoop/common/home/lib/native";
    assertTrue("execution path does not include the hadoop lib location " + toFind,executionPaths.contains(toFind));
  }
 catch (  Exception e) {
    e.printStackTrace();
    fail("Exception in testing execution environment for MapReduce task");
    tearDown();
  }
  try {
    JobConf conf=new JobConf(mr.getConfig());
    Path inDir=new Path("input");
    Path outDir=new Path("output");
    String input="The input";
    configure(conf,inDir,outDir,input,ExecutionEnvCheckMapClass.class,IdentityReducer.class);
    launchTest(conf,inDir,outDir,input);
  }
 catch (  Exception e) {
    e.printStackTrace();
    fail("Exception in testing propagation of env setting to child task");
    tearDown();
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * Tests task's temp directory.
 * In this test, we give different values to mapreduce.task.tmp.dir
 * both relative and absolute. And check whether the temp directory 
 * is created. We also check whether java.io.tmpdir value is same as 
 * the directory specified. We create a temp file and check if is is 
 * created in the directory specified.
 */
@Test public void testTaskTempDir(){
  try {
    JobConf conf=new JobConf(mr.getConfig());
    Path inDir=new Path("testing/wc/input");
    Path outDir=new Path("testing/wc/output");
    String input="The input";
    configure(conf,inDir,outDir,input,MapClass.class,IdentityReducer.class);
    launchTest(conf,inDir,outDir,input);
  }
 catch (  Exception e) {
    e.printStackTrace();
    fail("Exception in testing temp dir");
    tearDown();
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * Test to test if the user set *old* env variables reflect in the child
 * processes. Mainly
 * - x=y (x can be a already existing env variable or a new variable)
 * - x=$x:y (replace $x with the current value of x)
 */
@Test public void testTaskOldEnv(){
  try {
    JobConf conf=new JobConf(mr.getConfig());
    Path inDir=new Path("testing/wc/input1");
    Path outDir=new Path("testing/wc/output1");
    FileSystem outFs=outDir.getFileSystem(conf);
    runTestTaskEnv(conf,inDir,outDir,true);
    outFs.delete(outDir,true);
  }
 catch (  Exception e) {
    e.printStackTrace();
    fail("Exception in testing child env");
    tearDown();
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * Test to test if the user set env variables reflect in the child
 * processes. Mainly
 * - x=y (x can be a already existing env variable or a new variable)
 * - x=$x:y (replace $x with the current value of x)
 */
@Test public void testTaskEnv(){
  try {
    JobConf conf=new JobConf(mr.getConfig());
    Path inDir=new Path("testing/wc/input1");
    Path outDir=new Path("testing/wc/output1");
    FileSystem outFs=outDir.getFileSystem(conf);
    runTestTaskEnv(conf,inDir,outDir,false);
    outFs.delete(outDir,true);
  }
 catch (  Exception e) {
    e.printStackTrace();
    fail("Exception in testing child env");
    tearDown();
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.mapred.TestOldCombinerGrouping </h4><pre class="type-9 type-11 type-2 type-7 type-10 type-1 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects are null
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testCombiner() throws Exception {
  if (!new File(TEST_ROOT_DIR).mkdirs()) {
    throw new RuntimeException("Could not create test dir: " + TEST_ROOT_DIR);
  }
  File in=new File(TEST_ROOT_DIR,"input");
  if (!in.mkdirs()) {
    throw new RuntimeException("Could not create test dir: " + in);
  }
  File out=new File(TEST_ROOT_DIR,"output");
  PrintWriter pw=new PrintWriter(new FileWriter(new File(in,"data.txt")));
  pw.println("A|a,1");
  pw.println("A|b,2");
  pw.println("B|a,3");
  pw.println("B|b,4");
  pw.println("B|c,5");
  pw.close();
  JobConf job=new JobConf();
  job.set("mapreduce.framework.name","local");
  TextInputFormat.setInputPaths(job,new Path(in.getPath()));
  TextOutputFormat.setOutputPath(job,new Path(out.getPath()));
  job.setMapperClass(Map.class);
  job.setReducerClass(Reduce.class);
  job.setInputFormat(TextInputFormat.class);
  job.setMapOutputKeyClass(Text.class);
  job.setMapOutputValueClass(LongWritable.class);
  job.setOutputFormat(TextOutputFormat.class);
  job.setOutputValueGroupingComparator(GroupComparator.class);
  job.setCombinerClass(Combiner.class);
  job.setCombinerKeyGroupingComparator(GroupComparator.class);
  job.setInt("min.num.spills.for.combine",0);
  JobClient client=new JobClient(job);
  RunningJob runningJob=client.submitJob(job);
  runningJob.waitForCompletion();
  if (runningJob.isSuccessful()) {
    Counters counters=runningJob.getCounters();
    long combinerInputRecords=counters.getGroup("org.apache.hadoop.mapreduce.TaskCounter").getCounter("COMBINE_INPUT_RECORDS");
    long combinerOutputRecords=counters.getGroup("org.apache.hadoop.mapreduce.TaskCounter").getCounter("COMBINE_OUTPUT_RECORDS");
    Assert.assertTrue(combinerInputRecords > 0);
    Assert.assertTrue(combinerInputRecords > combinerOutputRecords);
    BufferedReader br=new BufferedReader(new FileReader(new File(out,"part-00000")));
    Set<String> output=new HashSet<String>();
    String line=br.readLine();
    Assert.assertNotNull(line);
    output.add(line.substring(0,1) + line.substring(4,5));
    line=br.readLine();
    Assert.assertNotNull(line);
    output.add(line.substring(0,1) + line.substring(4,5));
    line=br.readLine();
    Assert.assertNull(line);
    br.close();
    Set<String> expected=new HashSet<String>();
    expected.add("A2");
    expected.add("B5");
    Assert.assertEquals(expected,output);
  }
 else {
    Assert.fail("Job failed");
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.mapred.TestShuffleHandler </h4><pre class="type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Validate the limit on number of shuffle connections.
 * @throws Exception exception
 */
@Test(timeout=10000) public void testMaxConnections() throws Exception {
  Configuration conf=new Configuration();
  conf.setInt(ShuffleHandler.SHUFFLE_PORT_CONFIG_KEY,0);
  conf.setInt(ShuffleHandler.MAX_SHUFFLE_CONNECTIONS,3);
  ShuffleHandler shuffleHandler=new ShuffleHandler(){
    @Override protected Shuffle getShuffle(    Configuration conf){
      return new Shuffle(conf){
        @Override protected MapOutputInfo getMapOutputInfo(        String base,        String mapId,        int reduce,        String user) throws IOException {
          return null;
        }
        @Override protected void populateHeaders(        List<String> mapIds,        String jobId,        String user,        int reduce,        HttpRequest request,        HttpResponse response,        boolean keepAliveParam,        Map<String,MapOutputInfo> infoMap) throws IOException {
        }
        @Override protected void verifyRequest(        String appid,        ChannelHandlerContext ctx,        HttpRequest request,        HttpResponse response,        URL requestUri) throws IOException {
        }
        @Override protected ChannelFuture sendMapOutput(        ChannelHandlerContext ctx,        Channel ch,        String user,        String mapId,        int reduce,        MapOutputInfo info) throws IOException {
          ShuffleHeader header=new ShuffleHeader("dummy_header",5678,5678,1);
          DataOutputBuffer dob=new DataOutputBuffer();
          header.write(dob);
          ch.write(wrappedBuffer(dob.getData(),0,dob.getLength()));
          dob=new DataOutputBuffer();
          for (int i=0; i < 100000; ++i) {
            header.write(dob);
          }
          return ch.write(wrappedBuffer(dob.getData(),0,dob.getLength()));
        }
      }
;
    }
  }
;
  shuffleHandler.init(conf);
  shuffleHandler.start();
  int connAttempts=3;
  HttpURLConnection conns[]=new HttpURLConnection[connAttempts];
  for (int i=0; i < connAttempts; i++) {
    String URLstring="http://127.0.0.1:" + shuffleHandler.getConfig().get(ShuffleHandler.SHUFFLE_PORT_CONFIG_KEY) + "/mapOutput?job=job_12345_1&reduce=1&map=attempt_12345_1_m_"+ i+ "_0";
    URL url=new URL(URLstring);
    conns[i]=(HttpURLConnection)url.openConnection();
    conns[i].setRequestProperty(ShuffleHeader.HTTP_HEADER_NAME,ShuffleHeader.DEFAULT_HTTP_HEADER_NAME);
    conns[i].setRequestProperty(ShuffleHeader.HTTP_HEADER_VERSION,ShuffleHeader.DEFAULT_HTTP_HEADER_VERSION);
  }
  for (int i=0; i < connAttempts; i++) {
    conns[i].connect();
  }
  conns[0].getInputStream();
  int rc=conns[0].getResponseCode();
  Assert.assertEquals(HttpURLConnection.HTTP_OK,rc);
  conns[1].getInputStream();
  rc=conns[1].getResponseCode();
  Assert.assertEquals(HttpURLConnection.HTTP_OK,rc);
  try {
    conns[2].getInputStream();
    rc=conns[2].getResponseCode();
    Assert.fail("Expected a SocketException");
  }
 catch (  SocketException se) {
    LOG.info("Expected - connection should not be open");
  }
catch (  Exception e) {
    Assert.fail("Expected a SocketException");
  }
  shuffleHandler.stop();
}

</code></pre>

<br>
<pre class="type-9 type-2 type-7 type-10 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testRecoveryFromOtherVersions() throws IOException {
  final String user="someuser";
  final ApplicationId appId=ApplicationId.newInstance(12345,1);
  final File tmpDir=new File(System.getProperty("test.build.data",System.getProperty("java.io.tmpdir")),TestShuffleHandler.class.getName());
  Configuration conf=new Configuration();
  conf.setInt(ShuffleHandler.SHUFFLE_PORT_CONFIG_KEY,0);
  conf.setInt(ShuffleHandler.MAX_SHUFFLE_CONNECTIONS,3);
  ShuffleHandler shuffle=new ShuffleHandler();
  shuffle.setRecoveryPath(new Path(tmpDir.toString()));
  tmpDir.mkdirs();
  try {
    shuffle.init(conf);
    shuffle.start();
    DataOutputBuffer outputBuffer=new DataOutputBuffer();
    outputBuffer.reset();
    Token<JobTokenIdentifier> jt=new Token<JobTokenIdentifier>("identifier".getBytes(),"password".getBytes(),new Text(user),new Text("shuffleService"));
    jt.write(outputBuffer);
    shuffle.initializeApplication(new ApplicationInitializationContext(user,appId,ByteBuffer.wrap(outputBuffer.getData(),0,outputBuffer.getLength())));
    int rc=getShuffleResponseCode(shuffle,jt);
    Assert.assertEquals(HttpURLConnection.HTTP_OK,rc);
    shuffle.close();
    shuffle=new ShuffleHandler();
    shuffle.setRecoveryPath(new Path(tmpDir.toString()));
    shuffle.init(conf);
    shuffle.start();
    rc=getShuffleResponseCode(shuffle,jt);
    Assert.assertEquals(HttpURLConnection.HTTP_OK,rc);
    Version version=Version.newInstance(1,0);
    Assert.assertEquals(version,shuffle.getCurrentVersion());
    Version version11=Version.newInstance(1,1);
    shuffle.storeVersion(version11);
    Assert.assertEquals(version11,shuffle.loadVersion());
    shuffle.close();
    shuffle=new ShuffleHandler();
    shuffle.setRecoveryPath(new Path(tmpDir.toString()));
    shuffle.init(conf);
    shuffle.start();
    Assert.assertEquals(version,shuffle.loadVersion());
    rc=getShuffleResponseCode(shuffle,jt);
    Assert.assertEquals(HttpURLConnection.HTTP_OK,rc);
    Version version21=Version.newInstance(2,1);
    shuffle.storeVersion(version21);
    Assert.assertEquals(version21,shuffle.loadVersion());
    shuffle.close();
    shuffle=new ShuffleHandler();
    shuffle.setRecoveryPath(new Path(tmpDir.toString()));
    shuffle.init(conf);
    try {
      shuffle.start();
      Assert.fail("Incompatible version, should expect fail here.");
    }
 catch (    ServiceStateException e) {
      Assert.assertTrue("Exception message mismatch",e.getMessage().contains("Incompatible version for state DB schema:"));
    }
  }
  finally {
    if (shuffle != null) {
      shuffle.close();
    }
    FileUtil.fullyDelete(tmpDir);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.mapred.TestTaskAttemptListenerImpl </h4><pre class="type-2 type-7 type-10 type-1 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects are null
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=5000) public void testGetTask() throws IOException {
  AppContext appCtx=mock(AppContext.class);
  JobTokenSecretManager secret=mock(JobTokenSecretManager.class);
  RMHeartbeatHandler rmHeartbeatHandler=mock(RMHeartbeatHandler.class);
  TaskHeartbeatHandler hbHandler=mock(TaskHeartbeatHandler.class);
  Dispatcher dispatcher=mock(Dispatcher.class);
  EventHandler ea=mock(EventHandler.class);
  when(dispatcher.getEventHandler()).thenReturn(ea);
  when(appCtx.getEventHandler()).thenReturn(ea);
  CheckpointAMPreemptionPolicy policy=new CheckpointAMPreemptionPolicy();
  policy.init(appCtx);
  MockTaskAttemptListenerImpl listener=new MockTaskAttemptListenerImpl(appCtx,secret,rmHeartbeatHandler,hbHandler,policy);
  Configuration conf=new Configuration();
  listener.init(conf);
  listener.start();
  JVMId id=new JVMId("foo",1,true,1);
  WrappedJvmID wid=new WrappedJvmID(id.getJobId(),id.isMap,id.getId());
  JvmContext context=new JvmContext();
  context.jvmId=id;
  JvmTask result=listener.getTask(context);
  assertNotNull(result);
  assertTrue(result.shouldDie);
  TaskAttemptId attemptID=mock(TaskAttemptId.class);
  Task task=mock(Task.class);
  listener.registerPendingTask(task,wid);
  result=listener.getTask(context);
  assertNull(result);
  listener.unregister(attemptID,wid);
  listener.registerPendingTask(task,wid);
  listener.registerLaunchedTask(attemptID,wid);
  verify(hbHandler).register(attemptID);
  result=listener.getTask(context);
  assertNotNull(result);
  assertFalse(result.shouldDie);
  result=listener.getTask(context);
  assertNotNull(result);
  assertTrue(result.shouldDie);
  listener.unregister(attemptID,wid);
  result=listener.getTask(context);
  assertNotNull(result);
  assertTrue(result.shouldDie);
  listener.stop();
  JVMId jvmid=JVMId.forName("jvm_001_002_m_004");
  assertNotNull(jvmid);
  try {
    JVMId.forName("jvm_001_002_m_004_006");
    fail();
  }
 catch (  IllegalArgumentException e) {
    assertEquals(e.getMessage(),"TaskId string : jvm_001_002_m_004_006 is not properly formed");
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.mapred.TestTextOutputFormat </h4><pre class="type-9 type-11 type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testFormat() throws Exception {
  JobConf job=new JobConf();
  job.set(JobContext.TASK_ATTEMPT_ID,attempt);
  FileOutputFormat.setOutputPath(job,workDir.getParent().getParent());
  FileOutputFormat.setWorkOutputPath(job,workDir);
  FileSystem fs=workDir.getFileSystem(job);
  if (!fs.mkdirs(workDir)) {
    fail("Failed to create output directory");
  }
  String file="test_format.txt";
  Reporter reporter=Reporter.NULL;
  TextOutputFormat<Object,Object> theOutputFormat=new TextOutputFormat<Object,Object>();
  RecordWriter<Object,Object> theRecordWriter=theOutputFormat.getRecordWriter(localFs,job,file,reporter);
  Text key1=new Text("key1");
  Text key2=new Text("key2");
  Text val1=new Text("val1");
  Text val2=new Text("val2");
  NullWritable nullWritable=NullWritable.get();
  try {
    theRecordWriter.write(key1,val1);
    theRecordWriter.write(null,nullWritable);
    theRecordWriter.write(null,val1);
    theRecordWriter.write(nullWritable,val2);
    theRecordWriter.write(key2,nullWritable);
    theRecordWriter.write(key1,null);
    theRecordWriter.write(null,null);
    theRecordWriter.write(key2,val2);
  }
  finally {
    theRecordWriter.close(reporter);
  }
  File expectedFile=new File(new Path(workDir,file).toString());
  StringBuffer expectedOutput=new StringBuffer();
  expectedOutput.append(key1).append('\t').append(val1).append("\n");
  expectedOutput.append(val1).append("\n");
  expectedOutput.append(val2).append("\n");
  expectedOutput.append(key2).append("\n");
  expectedOutput.append(key1).append("\n");
  expectedOutput.append(key2).append('\t').append(val2).append("\n");
  String output=UtilsForTests.slurp(expectedFile);
  assertEquals(expectedOutput.toString(),output);
}

</code></pre>

<br>
<pre class="type-11 type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * test compressed file
 * @throws IOException
 */
@Test public void testCompress() throws IOException {
  JobConf job=new JobConf();
  job.set(JobContext.TASK_ATTEMPT_ID,attempt);
  job.set(org.apache.hadoop.mapreduce.lib.output.FileOutputFormat.COMPRESS,"true");
  FileOutputFormat.setOutputPath(job,workDir.getParent().getParent());
  FileOutputFormat.setWorkOutputPath(job,workDir);
  FileSystem fs=workDir.getFileSystem(job);
  if (!fs.mkdirs(workDir)) {
    fail("Failed to create output directory");
  }
  String file="test_compress.txt";
  Reporter reporter=Reporter.NULL;
  TextOutputFormat<Object,Object> theOutputFormat=new TextOutputFormat<Object,Object>();
  RecordWriter<Object,Object> theRecordWriter=theOutputFormat.getRecordWriter(localFs,job,file,reporter);
  Text key1=new Text("key1");
  Text key2=new Text("key2");
  Text val1=new Text("val1");
  Text val2=new Text("val2");
  NullWritable nullWritable=NullWritable.get();
  try {
    theRecordWriter.write(key1,val1);
    theRecordWriter.write(null,nullWritable);
    theRecordWriter.write(null,val1);
    theRecordWriter.write(nullWritable,val2);
    theRecordWriter.write(key2,nullWritable);
    theRecordWriter.write(key1,null);
    theRecordWriter.write(null,null);
    theRecordWriter.write(key2,val2);
  }
  finally {
    theRecordWriter.close(reporter);
  }
  StringBuffer expectedOutput=new StringBuffer();
  expectedOutput.append(key1).append("\t").append(val1).append("\n");
  expectedOutput.append(val1).append("\n");
  expectedOutput.append(val2).append("\n");
  expectedOutput.append(key2).append("\n");
  expectedOutput.append(key1).append("\n");
  expectedOutput.append(key2).append("\t").append(val2).append("\n");
  DefaultCodec codec=new DefaultCodec();
  codec.setConf(job);
  Path expectedFile=new Path(workDir,file + codec.getDefaultExtension());
  final FileInputStream istream=new FileInputStream(expectedFile.toString());
  CompressionInputStream cistream=codec.createInputStream(istream);
  LineReader reader=new LineReader(cistream);
  String output="";
  Text out=new Text();
  while (reader.readLine(out) > 0) {
    output+=out;
    output+="\n";
  }
  reader.close();
  assertEquals(expectedOutput.toString(),output);
}

</code></pre>

<br>
<pre class="type-9 type-11 type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testFormatWithCustomSeparator() throws Exception {
  JobConf job=new JobConf();
  String separator="\u0001";
  job.set("mapreduce.output.textoutputformat.separator",separator);
  job.set(JobContext.TASK_ATTEMPT_ID,attempt);
  FileOutputFormat.setOutputPath(job,workDir.getParent().getParent());
  FileOutputFormat.setWorkOutputPath(job,workDir);
  FileSystem fs=workDir.getFileSystem(job);
  if (!fs.mkdirs(workDir)) {
    fail("Failed to create output directory");
  }
  String file="test_custom.txt";
  Reporter reporter=Reporter.NULL;
  TextOutputFormat<Object,Object> theOutputFormat=new TextOutputFormat<Object,Object>();
  RecordWriter<Object,Object> theRecordWriter=theOutputFormat.getRecordWriter(localFs,job,file,reporter);
  Text key1=new Text("key1");
  Text key2=new Text("key2");
  Text val1=new Text("val1");
  Text val2=new Text("val2");
  NullWritable nullWritable=NullWritable.get();
  try {
    theRecordWriter.write(key1,val1);
    theRecordWriter.write(null,nullWritable);
    theRecordWriter.write(null,val1);
    theRecordWriter.write(nullWritable,val2);
    theRecordWriter.write(key2,nullWritable);
    theRecordWriter.write(key1,null);
    theRecordWriter.write(null,null);
    theRecordWriter.write(key2,val2);
  }
  finally {
    theRecordWriter.close(reporter);
  }
  File expectedFile=new File(new Path(workDir,file).toString());
  StringBuffer expectedOutput=new StringBuffer();
  expectedOutput.append(key1).append(separator).append(val1).append("\n");
  expectedOutput.append(val1).append("\n");
  expectedOutput.append(val2).append("\n");
  expectedOutput.append(key2).append("\n");
  expectedOutput.append(key1).append("\n");
  expectedOutput.append(key2).append(separator).append(val2).append("\n");
  String output=UtilsForTests.slurp(expectedFile);
  assertEquals(expectedOutput.toString(),output);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.mapred.gridmix.TestFilePool </h4><pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testUnsuitable() throws Exception {
  try {
    final Configuration conf=new Configuration();
    conf.setLong(FilePool.GRIDMIX_MIN_FILE,14 * 1024);
    final FilePool pool=new FilePool(conf,base);
    pool.refresh();
  }
 catch (  IOException e) {
    return;
  }
  fail();
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.mapred.pipes.TestPipeApplication </h4><pre class="type-11 type-2 type-7 type-10 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * test org.apache.hadoop.mapred.pipes.Submitter
 * @throws Exception
 */
@Test public void testSubmitter() throws Exception {
  JobConf conf=new JobConf();
  File[] psw=cleanTokenPasswordFile();
  System.setProperty("test.build.data","target/tmp/build/TEST_SUBMITTER_MAPPER/data");
  conf.set("hadoop.log.dir","target/tmp");
  Submitter.setIsJavaMapper(conf,false);
  Submitter.setIsJavaReducer(conf,false);
  Submitter.setKeepCommandFile(conf,false);
  Submitter.setIsJavaRecordReader(conf,false);
  Submitter.setIsJavaRecordWriter(conf,false);
  PipesPartitioner<IntWritable,Text> partitioner=new PipesPartitioner<IntWritable,Text>();
  partitioner.configure(conf);
  Submitter.setJavaPartitioner(conf,partitioner.getClass());
  assertEquals(PipesPartitioner.class,(Submitter.getJavaPartitioner(conf)));
  SecurityManager securityManager=System.getSecurityManager();
  PrintStream oldps=System.out;
  ByteArrayOutputStream out=new ByteArrayOutputStream();
  ExitUtil.disableSystemExit();
  try {
    System.setOut(new PrintStream(out));
    Submitter.main(new String[0]);
    fail();
  }
 catch (  ExitUtil.ExitException e) {
    assertTrue(out.toString().contains(""));
    assertTrue(out.toString().contains("bin/hadoop pipes"));
    assertTrue(out.toString().contains("[-input <path>] // Input directory"));
    assertTrue(out.toString().contains("[-output <path>] // Output directory"));
    assertTrue(out.toString().contains("[-jar <jar file> // jar filename"));
    assertTrue(out.toString().contains("[-inputformat <class>] // InputFormat class"));
    assertTrue(out.toString().contains("[-map <class>] // Java Map class"));
    assertTrue(out.toString().contains("[-partitioner <class>] // Java Partitioner"));
    assertTrue(out.toString().contains("[-reduce <class>] // Java Reduce class"));
    assertTrue(out.toString().contains("[-writer <class>] // Java RecordWriter"));
    assertTrue(out.toString().contains("[-program <executable>] // executable URI"));
    assertTrue(out.toString().contains("[-reduces <num>] // number of reduces"));
    assertTrue(out.toString().contains("[-lazyOutput <true/false>] // createOutputLazily"));
    assertTrue(out.toString().contains("-conf <configuration file>     specify an application configuration file"));
    assertTrue(out.toString().contains("-D <property=value>            use value for given property"));
    assertTrue(out.toString().contains("-fs <local|namenode:port>      specify a namenode"));
    assertTrue(out.toString().contains("-jt <local|jobtracker:port>    specify a job tracker"));
    assertTrue(out.toString().contains("-files <comma separated list of files>    specify comma separated files to be copied to the map reduce cluster"));
    assertTrue(out.toString().contains("-libjars <comma separated list of jars>    specify comma separated jar files to include in the classpath."));
    assertTrue(out.toString().contains("-archives <comma separated list of archives>    specify comma separated archives to be unarchived on the compute machines."));
  }
 finally {
    System.setOut(oldps);
    System.setSecurityManager(securityManager);
    if (psw != null) {
      for (      File file : psw) {
        file.deleteOnExit();
      }
    }
  }
  try {
    File fCommand=getFileCommand(null);
    String[] args=new String[22];
    File input=new File(workSpace + File.separator + "input");
    if (!input.exists()) {
      Assert.assertTrue(input.createNewFile());
    }
    File outPut=new File(workSpace + File.separator + "output");
    FileUtil.fullyDelete(outPut);
    args[0]="-input";
    args[1]=input.getAbsolutePath();
    args[2]="-output";
    args[3]=outPut.getAbsolutePath();
    args[4]="-inputformat";
    args[5]="org.apache.hadoop.mapred.TextInputFormat";
    args[6]="-map";
    args[7]="org.apache.hadoop.mapred.lib.IdentityMapper";
    args[8]="-partitioner";
    args[9]="org.apache.hadoop.mapred.pipes.PipesPartitioner";
    args[10]="-reduce";
    args[11]="org.apache.hadoop.mapred.lib.IdentityReducer";
    args[12]="-writer";
    args[13]="org.apache.hadoop.mapred.TextOutputFormat";
    args[14]="-program";
    args[15]=fCommand.getAbsolutePath();
    args[16]="-reduces";
    args[17]="2";
    args[18]="-lazyOutput";
    args[19]="lazyOutput";
    args[20]="-jobconf";
    args[21]="mapreduce.pipes.isjavarecordwriter=false,mapreduce.pipes.isjavarecordreader=false";
    Submitter.main(args);
    fail();
  }
 catch (  ExitUtil.ExitException e) {
    assertEquals(e.status,0);
  }
 finally {
    System.setOut(oldps);
    System.setSecurityManager(securityManager);
  }
}

</code></pre>

<br>
<pre class="type-9 type-2 type-7 type-10 type-1 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects are null
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * test org.apache.hadoop.mapred.pipes.Application
 * test a internal functions: MessageType.REGISTER_COUNTER,  INCREMENT_COUNTER, STATUS, PROGRESS...
 * @throws Throwable
 */
@Test public void testApplication() throws Throwable {
  JobConf conf=new JobConf();
  RecordReader<FloatWritable,NullWritable> rReader=new Reader();
  File fCommand=getFileCommand("org.apache.hadoop.mapred.pipes.PipeApplicationStub");
  TestTaskReporter reporter=new TestTaskReporter();
  File[] psw=cleanTokenPasswordFile();
  try {
    conf.set(MRJobConfig.TASK_ATTEMPT_ID,taskName);
    conf.set(MRJobConfig.CACHE_LOCALFILES,fCommand.getAbsolutePath());
    Token<AMRMTokenIdentifier> token=new Token<AMRMTokenIdentifier>("user".getBytes(),"password".getBytes(),new Text("kind"),new Text("service"));
    TokenCache.setJobToken(token,conf.getCredentials());
    FakeCollector output=new FakeCollector(new Counters.Counter(),new Progress());
    FileSystem fs=new RawLocalFileSystem();
    fs.setConf(conf);
    Writer<IntWritable,Text> wr=new Writer<IntWritable,Text>(conf,fs.create(new Path(workSpace.getAbsolutePath() + File.separator + "outfile")),IntWritable.class,Text.class,null,null,true);
    output.setWriter(wr);
    conf.set(Submitter.PRESERVE_COMMANDFILE,"true");
    initStdOut(conf);
    Application<WritableComparable<IntWritable>,Writable,IntWritable,Text> application=new Application<WritableComparable<IntWritable>,Writable,IntWritable,Text>(conf,rReader,output,reporter,IntWritable.class,Text.class);
    application.getDownlink().flush();
    application.getDownlink().mapItem(new IntWritable(3),new Text("txt"));
    application.getDownlink().flush();
    application.waitForFinish();
    wr.close();
    String stdOut=readStdOut(conf);
    assertTrue(stdOut.contains("key:3"));
    assertTrue(stdOut.contains("value:txt"));
    assertEquals(1.0,reporter.getProgress(),0.01);
    assertNotNull(reporter.getCounter("group","name"));
    assertEquals(reporter.getStatus(),"PROGRESS");
    stdOut=readFile(new File(workSpace.getAbsolutePath() + File.separator + "outfile"));
    assertEquals(0.55f,rReader.getProgress(),0.001);
    application.getDownlink().close();
    Entry<IntWritable,Text> entry=output.getCollect().entrySet().iterator().next();
    assertEquals(123,entry.getKey().get());
    assertEquals("value",entry.getValue().toString());
    try {
      application.abort(new Throwable());
      fail();
    }
 catch (    IOException e) {
      assertEquals("pipe child exception",e.getMessage());
    }
  }
  finally {
    if (psw != null) {
      for (      File file : psw) {
        file.deleteOnExit();
      }
    }
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.mapreduce.TestClientProtocolProviderImpls </h4><pre class="type-2 type-7 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testClusterWithLocalClientProvider() throws Exception {
  Configuration conf=new Configuration();
  try {
    conf.set(MRConfig.FRAMEWORK_NAME,"incorrect");
    new Cluster(conf);
    fail("Cluster should not be initialized with incorrect framework name");
  }
 catch (  IOException e) {
  }
  conf.set(MRConfig.FRAMEWORK_NAME,"local");
  Cluster cluster=new Cluster(conf);
  assertTrue(cluster.getClient() instanceof LocalJobRunner);
  cluster.close();
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testClusterException(){
  Configuration conf=new Configuration();
  conf.set(MRConfig.FRAMEWORK_NAME,MRConfig.CLASSIC_FRAMEWORK_NAME);
  conf.set(JTConfig.JT_IPC_ADDRESS,"local");
  boolean errorThrown=false;
  try {
    Cluster cluster=new Cluster(conf);
    cluster.close();
    fail("Not expected - cluster init should have failed");
  }
 catch (  IOException e) {
    errorThrown=true;
    assert (e.getMessage().contains("Cannot initialize Cluster. Please check"));
  }
  assert (errorThrown);
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testClusterWithJTClientProvider() throws Exception {
  Configuration conf=new Configuration();
  try {
    conf.set(MRConfig.FRAMEWORK_NAME,"incorrect");
    new Cluster(conf);
    fail("Cluster should not be initialized with incorrect framework name");
  }
 catch (  IOException e) {
  }
  try {
    conf.set(MRConfig.FRAMEWORK_NAME,"classic");
    conf.set(JTConfig.JT_IPC_ADDRESS,"local");
    new Cluster(conf);
    fail("Cluster with classic Framework name shouldnot use local JT address");
  }
 catch (  IOException e) {
  }
  try {
    conf=new Configuration();
    conf.set(MRConfig.FRAMEWORK_NAME,"classic");
    conf.set(JTConfig.JT_IPC_ADDRESS,"127.0.0.1:0");
    Cluster cluster=new Cluster(conf);
    cluster.close();
  }
 catch (  IOException e) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.mapreduce.TestNewCombinerGrouping </h4><pre class="type-9 type-11 type-2 type-7 type-10 type-1 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects are null
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testCombiner() throws Exception {
  if (!new File(TEST_ROOT_DIR).mkdirs()) {
    throw new RuntimeException("Could not create test dir: " + TEST_ROOT_DIR);
  }
  File in=new File(TEST_ROOT_DIR,"input");
  if (!in.mkdirs()) {
    throw new RuntimeException("Could not create test dir: " + in);
  }
  File out=new File(TEST_ROOT_DIR,"output");
  PrintWriter pw=new PrintWriter(new FileWriter(new File(in,"data.txt")));
  pw.println("A|a,1");
  pw.println("A|b,2");
  pw.println("B|a,3");
  pw.println("B|b,4");
  pw.println("B|c,5");
  pw.close();
  JobConf conf=new JobConf();
  conf.set("mapreduce.framework.name","local");
  Job job=new Job(conf);
  TextInputFormat.setInputPaths(job,new Path(in.getPath()));
  TextOutputFormat.setOutputPath(job,new Path(out.getPath()));
  job.setMapperClass(Map.class);
  job.setReducerClass(Reduce.class);
  job.setInputFormatClass(TextInputFormat.class);
  job.setMapOutputKeyClass(Text.class);
  job.setMapOutputValueClass(LongWritable.class);
  job.setOutputFormatClass(TextOutputFormat.class);
  job.setGroupingComparatorClass(GroupComparator.class);
  job.setCombinerKeyGroupingComparatorClass(GroupComparator.class);
  job.setCombinerClass(Combiner.class);
  job.getConfiguration().setInt("min.num.spills.for.combine",0);
  job.submit();
  job.waitForCompletion(false);
  if (job.isSuccessful()) {
    Counters counters=job.getCounters();
    long combinerInputRecords=counters.findCounter("org.apache.hadoop.mapreduce.TaskCounter","COMBINE_INPUT_RECORDS").getValue();
    long combinerOutputRecords=counters.findCounter("org.apache.hadoop.mapreduce.TaskCounter","COMBINE_OUTPUT_RECORDS").getValue();
    Assert.assertTrue(combinerInputRecords > 0);
    Assert.assertTrue(combinerInputRecords > combinerOutputRecords);
    BufferedReader br=new BufferedReader(new FileReader(new File(out,"part-r-00000")));
    Set<String> output=new HashSet<String>();
    String line=br.readLine();
    Assert.assertNotNull(line);
    output.add(line.substring(0,1) + line.substring(4,5));
    line=br.readLine();
    Assert.assertNotNull(line);
    output.add(line.substring(0,1) + line.substring(4,5));
    line=br.readLine();
    Assert.assertNull(line);
    br.close();
    Set<String> expected=new HashSet<String>();
    expected.add("A2");
    expected.add("B5");
    Assert.assertEquals(expected,output);
  }
 else {
    Assert.fail("Job failed");
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.mapreduce.TestTypeConverter </h4><pre class="type-9 type-2 type-7 type-1 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testFromYarnApplicationReport(){
  ApplicationId mockAppId=mock(ApplicationId.class);
  when(mockAppId.getClusterTimestamp()).thenReturn(12345L);
  when(mockAppId.getId()).thenReturn(6789);
  ApplicationReport mockReport=mock(ApplicationReport.class);
  when(mockReport.getTrackingUrl()).thenReturn("dummy-tracking-url");
  when(mockReport.getApplicationId()).thenReturn(mockAppId);
  when(mockReport.getYarnApplicationState()).thenReturn(YarnApplicationState.KILLED);
  when(mockReport.getUser()).thenReturn("dummy-user");
  when(mockReport.getQueue()).thenReturn("dummy-queue");
  String jobFile="dummy-path/job.xml";
  try {
    JobStatus status=TypeConverter.fromYarn(mockReport,jobFile);
  }
 catch (  NullPointerException npe) {
    Assert.fail("Type converstion from YARN fails for jobs without " + "ApplicationUsageReport");
  }
  ApplicationResourceUsageReport appUsageRpt=Records.newRecord(ApplicationResourceUsageReport.class);
  Resource r=Records.newRecord(Resource.class);
  r.setMemory(2048);
  appUsageRpt.setNeededResources(r);
  appUsageRpt.setNumReservedContainers(1);
  appUsageRpt.setNumUsedContainers(3);
  appUsageRpt.setReservedResources(r);
  appUsageRpt.setUsedResources(r);
  when(mockReport.getApplicationResourceUsageReport()).thenReturn(appUsageRpt);
  JobStatus status=TypeConverter.fromYarn(mockReport,jobFile);
  Assert.assertNotNull("fromYarn returned null status",status);
  Assert.assertEquals("jobFile set incorrectly","dummy-path/job.xml",status.getJobFile());
  Assert.assertEquals("queue set incorrectly","dummy-queue",status.getQueue());
  Assert.assertEquals("trackingUrl set incorrectly","dummy-tracking-url",status.getTrackingUrl());
  Assert.assertEquals("user set incorrectly","dummy-user",status.getUsername());
  Assert.assertEquals("schedulingInfo set incorrectly","dummy-tracking-url",status.getSchedulingInfo());
  Assert.assertEquals("jobId set incorrectly",6789,status.getJobID().getId());
  Assert.assertEquals("state set incorrectly",JobStatus.State.KILLED,status.getState());
  Assert.assertEquals("needed mem info set incorrectly",2048,status.getNeededMem());
  Assert.assertEquals("num rsvd slots info set incorrectly",1,status.getNumReservedSlots());
  Assert.assertEquals("num used slots info set incorrectly",3,status.getNumUsedSlots());
  Assert.assertEquals("rsvd mem info set incorrectly",2048,status.getReservedMem());
  Assert.assertEquals("used mem info set incorrectly",2048,status.getUsedMem());
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.mapreduce.lib.input.TestCombineTextInputFormat </h4><pre class="type-9 type-11 type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test using the gzip codec for reading
 */
@Test(timeout=10000) public void testGzip() throws IOException, InterruptedException {
  Configuration conf=new Configuration(defaultConf);
  CompressionCodec gzip=new GzipCodec();
  ReflectionUtils.setConf(gzip,conf);
  localFs.delete(workDir,true);
  writeFile(localFs,new Path(workDir,"part1.txt.gz"),gzip,"the quick\nbrown\nfox jumped\nover\n the lazy\n dog\n");
  writeFile(localFs,new Path(workDir,"part2.txt.gz"),gzip,"this is a test\nof gzip\n");
  Job job=Job.getInstance(conf);
  FileInputFormat.setInputPaths(job,workDir);
  CombineTextInputFormat format=new CombineTextInputFormat();
  List<InputSplit> splits=format.getSplits(job);
  assertEquals("compressed splits == 1",1,splits.size());
  List<Text> results=readSplit(format,splits.get(0),job);
  assertEquals("splits[0] length",8,results.size());
  final String[] firstList={"the quick","brown","fox jumped","over"," the lazy"," dog"};
  final String[] secondList={"this is a test","of gzip"};
  String first=results.get(0).toString();
  if (first.equals(firstList[0])) {
    testResults(results,firstList,secondList);
  }
 else   if (first.equals(secondList[0])) {
    testResults(results,secondList,firstList);
  }
 else {
    fail("unexpected first token!");
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.mapreduce.lib.input.TestFileInputFormat </h4><pre class="type-2 type-7 type-10 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testListStatusErrorOnNonExistantDir() throws IOException {
  Configuration conf=new Configuration();
  conf.setInt(FileInputFormat.LIST_STATUS_NUM_THREADS,numThreads);
  configureTestErrorOnNonExistantDir(conf,localFs);
  Job job=Job.getInstance(conf);
  FileInputFormat<?,?> fif=new TextInputFormat();
  try {
    fif.listStatus(job);
    Assert.fail("Expecting an IOException for a missing Input path");
  }
 catch (  IOException e) {
    Path expectedExceptionPath=new Path(TEST_ROOT_DIR,"input2");
    expectedExceptionPath=localFs.makeQualified(expectedExceptionPath);
    Assert.assertTrue(e instanceof InvalidInputException);
    Assert.assertEquals("Input path does not exist: " + expectedExceptionPath.toString(),e.getMessage());
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.mapreduce.security.TestBinaryTokenFile </h4><pre class="type-9 type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * run a distributed job and verify that TokenCache is available
 * @throws IOException
 */
@Test public void testBinaryTokenFile() throws IOException {
  Configuration conf=mrCluster.getConfig();
  final String nnUri=dfsCluster.getURI(0).toString();
  conf.set(MRJobConfig.JOB_NAMENODES,nnUri + "," + nnUri);
  final String[] args={"-m","1","-r","1","-mt","1","-rt","1"};
  int res=-1;
  try {
    res=ToolRunner.run(conf,new MySleepJob(),args);
  }
 catch (  Exception e) {
    System.out.println("Job failed with " + e.getLocalizedMessage());
    e.printStackTrace(System.out);
    fail("Job failed");
  }
  assertEquals("dist job res is not 0:",0,res);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.mapreduce.security.TestJHSSecurity </h4><pre class="type-2 type-10 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testDelegationToken() throws IOException, InterruptedException {
  Logger rootLogger=LogManager.getRootLogger();
  rootLogger.setLevel(Level.DEBUG);
  final YarnConfiguration conf=new YarnConfiguration(new JobConf());
  conf.set(JHAdminConfig.MR_HISTORY_PRINCIPAL,"RandomOrc/localhost@apache.org");
  conf.set(CommonConfigurationKeysPublic.HADOOP_SECURITY_AUTHENTICATION,"kerberos");
  UserGroupInformation.setConfiguration(conf);
  final long initialInterval=10000l;
  final long maxLifetime=20000l;
  final long renewInterval=10000l;
  JobHistoryServer jobHistoryServer=null;
  MRClientProtocol clientUsingDT=null;
  long tokenFetchTime;
  try {
    jobHistoryServer=new JobHistoryServer(){
      protected void doSecureLogin(      Configuration conf) throws IOException {
      }
      @Override protected JHSDelegationTokenSecretManager createJHSSecretManager(      Configuration conf,      HistoryServerStateStoreService store){
        return new JHSDelegationTokenSecretManager(initialInterval,maxLifetime,renewInterval,3600000,store);
      }
      @Override protected HistoryClientService createHistoryClientService(){
        return new HistoryClientService(historyContext,this.jhsDTSecretManager){
          @Override protected void initializeWebApp(          Configuration conf){
          }
        }
;
      }
    }
;
    jobHistoryServer.init(conf);
    jobHistoryServer.start();
    final MRClientProtocol hsService=jobHistoryServer.getClientService().getClientHandler();
    UserGroupInformation loggedInUser=UserGroupInformation.createRemoteUser("testrenewer@APACHE.ORG");
    Assert.assertEquals("testrenewer",loggedInUser.getShortUserName());
    loggedInUser.setAuthenticationMethod(AuthenticationMethod.KERBEROS);
    Token token=getDelegationToken(loggedInUser,hsService,loggedInUser.getShortUserName());
    tokenFetchTime=System.currentTimeMillis();
    LOG.info("Got delegation token at: " + tokenFetchTime);
    clientUsingDT=getMRClientProtocol(token,jobHistoryServer.getClientService().getBindAddress(),"TheDarkLord",conf);
    GetJobReportRequest jobReportRequest=Records.newRecord(GetJobReportRequest.class);
    jobReportRequest.setJobId(MRBuilderUtils.newJobId(123456,1,1));
    try {
      clientUsingDT.getJobReport(jobReportRequest);
    }
 catch (    IOException e) {
      Assert.assertEquals("Unknown job job_123456_0001",e.getMessage());
    }
    while (System.currentTimeMillis() < tokenFetchTime + initialInterval / 2) {
      Thread.sleep(500l);
    }
    long nextExpTime=renewDelegationToken(loggedInUser,hsService,token);
    long renewalTime=System.currentTimeMillis();
    LOG.info("Renewed token at: " + renewalTime + ", NextExpiryTime: "+ nextExpTime);
    while (System.currentTimeMillis() > tokenFetchTime + initialInterval && System.currentTimeMillis() < nextExpTime) {
      Thread.sleep(500l);
    }
    Thread.sleep(50l);
    try {
      clientUsingDT.getJobReport(jobReportRequest);
    }
 catch (    IOException e) {
      Assert.assertEquals("Unknown job job_123456_0001",e.getMessage());
    }
    while (System.currentTimeMillis() < renewalTime + renewInterval) {
      Thread.sleep(500l);
    }
    Thread.sleep(50l);
    LOG.info("At time: " + System.currentTimeMillis() + ", token should be invalid");
    try {
      clientUsingDT.getJobReport(jobReportRequest);
      fail("Should not have succeeded with an expired token");
    }
 catch (    IOException e) {
      assertTrue(e.getCause().getMessage().contains("is expired"));
    }
    if (clientUsingDT != null) {
      clientUsingDT=null;
    }
    token=getDelegationToken(loggedInUser,hsService,loggedInUser.getShortUserName());
    tokenFetchTime=System.currentTimeMillis();
    LOG.info("Got delegation token at: " + tokenFetchTime);
    clientUsingDT=getMRClientProtocol(token,jobHistoryServer.getClientService().getBindAddress(),"loginuser2",conf);
    try {
      clientUsingDT.getJobReport(jobReportRequest);
    }
 catch (    IOException e) {
      fail("Unexpected exception" + e);
    }
    cancelDelegationToken(loggedInUser,hsService,token);
    Token tokenWithDifferentRenewer=getDelegationToken(loggedInUser,hsService,"yarn");
    cancelDelegationToken(loggedInUser,hsService,tokenWithDifferentRenewer);
    if (clientUsingDT != null) {
      clientUsingDT=null;
    }
    clientUsingDT=getMRClientProtocol(token,jobHistoryServer.getClientService().getBindAddress(),"loginuser2",conf);
    LOG.info("Cancelled delegation token at: " + System.currentTimeMillis());
    try {
      clientUsingDT.getJobReport(jobReportRequest);
      fail("Should not have succeeded with a cancelled delegation token");
    }
 catch (    IOException e) {
    }
  }
  finally {
    jobHistoryServer.stop();
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.mapreduce.security.TestMRCredentials </h4><pre class="type-9 type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * run a distributed job and verify that TokenCache is available
 * @throws IOException
 */
@Test public void test() throws IOException {
  Configuration jobConf=new JobConf(mrCluster.getConfig());
  NameNode nn=dfsCluster.getNameNode();
  URI nnUri=NameNode.getUri(nn.getNameNodeAddress());
  jobConf.set(JobContext.JOB_NAMENODES,nnUri + "," + nnUri.toString());
  jobConf.set("mapreduce.job.credentials.json","keys.json");
  String[] args={"-m","1","-r","1","-mt","1","-rt","1"};
  int res=-1;
  try {
    res=ToolRunner.run(jobConf,new CredentialsTestJob(),args);
  }
 catch (  Exception e) {
    System.out.println("Job failed with" + e.getLocalizedMessage());
    e.printStackTrace(System.out);
    fail("Job failed");
  }
  assertEquals("dist job res is not 0",res,0);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.mapreduce.security.token.delegation.TestDelegationToken </h4><pre class="type-2 type-7 type-10 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@SuppressWarnings("deprecation") @Test public void testDelegationToken() throws Exception {
  final JobClient client;
  client=user1.doAs(new PrivilegedExceptionAction<JobClient>(){
    @Override public JobClient run() throws Exception {
      return new JobClient(cluster.createJobConf());
    }
  }
);
  final JobClient bobClient;
  bobClient=user2.doAs(new PrivilegedExceptionAction<JobClient>(){
    @Override public JobClient run() throws Exception {
      return new JobClient(cluster.createJobConf());
    }
  }
);
  final Token<DelegationTokenIdentifier> token=client.getDelegationToken(new Text(user1.getUserName()));
  DataInputBuffer inBuf=new DataInputBuffer();
  byte[] bytes=token.getIdentifier();
  inBuf.reset(bytes,bytes.length);
  DelegationTokenIdentifier ident=new DelegationTokenIdentifier();
  ident.readFields(inBuf);
  assertEquals("alice",ident.getUser().getUserName());
  long createTime=ident.getIssueDate();
  long maxTime=ident.getMaxDate();
  long currentTime=System.currentTimeMillis();
  System.out.println("create time: " + createTime);
  System.out.println("current time: " + currentTime);
  System.out.println("max time: " + maxTime);
  assertTrue("createTime < current",createTime < currentTime);
  assertTrue("current < maxTime",currentTime < maxTime);
  user1.doAs(new PrivilegedExceptionAction<Void>(){
    @Override public Void run() throws Exception {
      client.renewDelegationToken(token);
      client.renewDelegationToken(token);
      return null;
    }
  }
);
  user2.doAs(new PrivilegedExceptionAction<Void>(){
    @Override public Void run() throws Exception {
      try {
        bobClient.renewDelegationToken(token);
        Assert.fail("bob renew");
      }
 catch (      AccessControlException ace) {
      }
      return null;
    }
  }
);
  user2.doAs(new PrivilegedExceptionAction<Void>(){
    @Override public Void run() throws Exception {
      try {
        bobClient.cancelDelegationToken(token);
        Assert.fail("bob cancel");
      }
 catch (      AccessControlException ace) {
      }
      return null;
    }
  }
);
  user1.doAs(new PrivilegedExceptionAction<Void>(){
    @Override public Void run() throws Exception {
      client.cancelDelegationToken(token);
      try {
        client.cancelDelegationToken(token);
        Assert.fail("second alice cancel");
      }
 catch (      InvalidToken it) {
      }
      return null;
    }
  }
);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.mapreduce.v2.TestRecordFactory </h4><pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testPbRecordFactory(){
  RecordFactory pbRecordFactory=RecordFactoryPBImpl.get();
  try {
    CounterGroup response=pbRecordFactory.newRecordInstance(CounterGroup.class);
    Assert.assertEquals(CounterGroupPBImpl.class,response.getClass());
  }
 catch (  YarnRuntimeException e) {
    e.printStackTrace();
    Assert.fail("Failed to crete record");
  }
  try {
    GetCountersRequest response=pbRecordFactory.newRecordInstance(GetCountersRequest.class);
    Assert.assertEquals(GetCountersRequestPBImpl.class,response.getClass());
  }
 catch (  YarnRuntimeException e) {
    e.printStackTrace();
    Assert.fail("Failed to crete record");
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.mapreduce.v2.app.TestMRClientService </h4><pre class="type-2 type-7 type-10 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testViewAclOnlyCannotModify() throws Exception {
  final MRAppWithClientService app=new MRAppWithClientService(1,0,false);
  final Configuration conf=new Configuration();
  conf.setBoolean(MRConfig.MR_ACLS_ENABLED,true);
  conf.set(MRJobConfig.JOB_ACL_VIEW_JOB,"viewonlyuser");
  Job job=app.submit(conf);
  app.waitForState(job,JobState.RUNNING);
  Assert.assertEquals("Num tasks not correct",1,job.getTasks().size());
  Iterator<Task> it=job.getTasks().values().iterator();
  Task task=it.next();
  app.waitForState(task,TaskState.RUNNING);
  TaskAttempt attempt=task.getAttempts().values().iterator().next();
  app.waitForState(attempt,TaskAttemptState.RUNNING);
  UserGroupInformation viewOnlyUser=UserGroupInformation.createUserForTesting("viewonlyuser",new String[]{});
  Assert.assertTrue("viewonlyuser cannot view job",job.checkAccess(viewOnlyUser,JobACL.VIEW_JOB));
  Assert.assertFalse("viewonlyuser can modify job",job.checkAccess(viewOnlyUser,JobACL.MODIFY_JOB));
  MRClientProtocol client=viewOnlyUser.doAs(new PrivilegedExceptionAction<MRClientProtocol>(){
    @Override public MRClientProtocol run() throws Exception {
      YarnRPC rpc=YarnRPC.create(conf);
      return (MRClientProtocol)rpc.getProxy(MRClientProtocol.class,app.clientService.getBindAddress(),conf);
    }
  }
);
  KillJobRequest killJobRequest=recordFactory.newRecordInstance(KillJobRequest.class);
  killJobRequest.setJobId(app.getJobId());
  try {
    client.killJob(killJobRequest);
    fail("viewonlyuser killed job");
  }
 catch (  AccessControlException e) {
  }
  KillTaskRequest killTaskRequest=recordFactory.newRecordInstance(KillTaskRequest.class);
  killTaskRequest.setTaskId(task.getID());
  try {
    client.killTask(killTaskRequest);
    fail("viewonlyuser killed task");
  }
 catch (  AccessControlException e) {
  }
  KillTaskAttemptRequest killTaskAttemptRequest=recordFactory.newRecordInstance(KillTaskAttemptRequest.class);
  killTaskAttemptRequest.setTaskAttemptId(attempt.getID());
  try {
    client.killTaskAttempt(killTaskAttemptRequest);
    fail("viewonlyuser killed task attempt");
  }
 catch (  AccessControlException e) {
  }
  FailTaskAttemptRequest failTaskAttemptRequest=recordFactory.newRecordInstance(FailTaskAttemptRequest.class);
  failTaskAttemptRequest.setTaskAttemptId(attempt.getID());
  try {
    client.failTaskAttempt(failTaskAttemptRequest);
    fail("viewonlyuser killed task attempt");
  }
 catch (  AccessControlException e) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.mapreduce.v2.app.job.impl.TestJobImpl </h4><pre class="type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testJobNoTasks(){
  Configuration conf=new Configuration();
  conf.setInt(MRJobConfig.NUM_REDUCES,0);
  conf.set(MRJobConfig.MR_AM_STAGING_DIR,stagingDir);
  conf.set(MRJobConfig.WORKFLOW_ID,"testId");
  conf.set(MRJobConfig.WORKFLOW_NAME,"testName");
  conf.set(MRJobConfig.WORKFLOW_NODE_NAME,"testNodeName");
  conf.set(MRJobConfig.WORKFLOW_ADJACENCY_PREFIX_STRING + "key1","value1");
  conf.set(MRJobConfig.WORKFLOW_ADJACENCY_PREFIX_STRING + "key2","value2");
  conf.set(MRJobConfig.WORKFLOW_TAGS,"tag1,tag2");
  AsyncDispatcher dispatcher=new AsyncDispatcher();
  dispatcher.init(conf);
  dispatcher.start();
  OutputCommitter committer=mock(OutputCommitter.class);
  CommitterEventHandler commitHandler=createCommitterEventHandler(dispatcher,committer);
  commitHandler.init(conf);
  commitHandler.start();
  JobSubmittedEventHandler jseHandler=new JobSubmittedEventHandler("testId","testName","testNodeName","\"key2\"=\"value2\" \"key1\"=\"value1\" ","tag1,tag2");
  dispatcher.register(EventType.class,jseHandler);
  JobImpl job=createStubbedJob(conf,dispatcher,0,null);
  job.handle(new JobEvent(job.getID(),JobEventType.JOB_INIT));
  assertJobState(job,JobStateInternal.INITED);
  job.handle(new JobStartEvent(job.getID()));
  assertJobState(job,JobStateInternal.SUCCEEDED);
  dispatcher.stop();
  commitHandler.stop();
  try {
    Assert.assertTrue(jseHandler.getAssertValue());
  }
 catch (  InterruptedException e) {
    Assert.fail("Workflow related attributes are not tested properly");
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.mapreduce.v2.app.job.impl.TestTaskAttempt </h4><pre class="type-11 type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testHostResolveAttempt() throws Exception {
  TaskAttemptImpl.RequestContainerTransition rct=new TaskAttemptImpl.RequestContainerTransition(false);
  EventHandler eventHandler=mock(EventHandler.class);
  String[] hosts=new String[3];
  hosts[0]="192.168.1.1";
  hosts[1]="host2";
  hosts[2]="host3";
  TaskSplitMetaInfo splitInfo=new TaskSplitMetaInfo(hosts,0,128 * 1024 * 1024l);
  TaskAttemptImpl mockTaskAttempt=createMapTaskAttemptImplForTest(eventHandler,splitInfo);
  TaskAttemptImpl spyTa=spy(mockTaskAttempt);
  when(spyTa.resolveHost(hosts[0])).thenReturn("host1");
  spyTa.dataLocalHosts=spyTa.resolveHosts(splitInfo.getLocations());
  TaskAttemptEvent mockTAEvent=mock(TaskAttemptEvent.class);
  rct.transition(spyTa,mockTAEvent);
  verify(spyTa).resolveHost(hosts[0]);
  ArgumentCaptor<Event> arg=ArgumentCaptor.forClass(Event.class);
  verify(eventHandler,times(2)).handle(arg.capture());
  if (!(arg.getAllValues().get(1) instanceof ContainerRequestEvent)) {
    Assert.fail("Second Event not of type ContainerRequestEvent");
  }
  Map<String,Boolean> expected=new HashMap<String,Boolean>();
  expected.put("host1",true);
  expected.put("host2",true);
  expected.put("host3",true);
  ContainerRequestEvent cre=(ContainerRequestEvent)arg.getAllValues().get(1);
  String[] requestedHosts=cre.getHosts();
  for (  String h : requestedHosts) {
    expected.remove(h);
  }
  assertEquals(0,expected.size());
}

</code></pre>

<br>
<pre class="type-11 type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testSingleRackRequest() throws Exception {
  TaskAttemptImpl.RequestContainerTransition rct=new TaskAttemptImpl.RequestContainerTransition(false);
  EventHandler eventHandler=mock(EventHandler.class);
  String[] hosts=new String[3];
  hosts[0]="host1";
  hosts[1]="host2";
  hosts[2]="host3";
  TaskSplitMetaInfo splitInfo=new TaskSplitMetaInfo(hosts,0,128 * 1024 * 1024l);
  TaskAttemptImpl mockTaskAttempt=createMapTaskAttemptImplForTest(eventHandler,splitInfo);
  TaskAttemptEvent mockTAEvent=mock(TaskAttemptEvent.class);
  rct.transition(mockTaskAttempt,mockTAEvent);
  ArgumentCaptor<Event> arg=ArgumentCaptor.forClass(Event.class);
  verify(eventHandler,times(2)).handle(arg.capture());
  if (!(arg.getAllValues().get(1) instanceof ContainerRequestEvent)) {
    Assert.fail("Second Event not of type ContainerRequestEvent");
  }
  ContainerRequestEvent cre=(ContainerRequestEvent)arg.getAllValues().get(1);
  String[] requestedRacks=cre.getRacks();
  assertEquals(1,requestedRacks.length);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.mapreduce.v2.app.local.TestLocalContainerAllocator </h4><pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testRMConnectionRetry() throws Exception {
  Configuration conf=new Configuration();
  LocalContainerAllocator lca=new StubbedLocalContainerAllocator();
  lca.init(conf);
  lca.start();
  try {
    lca.heartbeat();
    Assert.fail("heartbeat was supposed to throw");
  }
 catch (  YarnException e) {
  }
 finally {
    lca.stop();
  }
  conf.setLong(MRJobConfig.MR_AM_TO_RM_WAIT_INTERVAL_MS,0);
  lca=new StubbedLocalContainerAllocator();
  lca.init(conf);
  lca.start();
  try {
    lca.heartbeat();
    Assert.fail("heartbeat was supposed to throw");
  }
 catch (  YarnRuntimeException e) {
  }
 finally {
    lca.stop();
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.mapreduce.v2.app.webapp.TestAMWebApp </h4><pre class="type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testMRWebAppSSLDisabled() throws Exception {
  MRApp app=new MRApp(2,2,true,this.getClass().getName(),true){
    @Override protected ClientService createClientService(    AppContext context){
      return new MRClientService(context);
    }
  }
;
  Configuration conf=new Configuration();
  conf.set(YarnConfiguration.YARN_HTTP_POLICY_KEY,Policy.HTTPS_ONLY.name());
  Job job=app.submit(conf);
  String hostPort=NetUtils.getHostPortString(((MRClientService)app.getClientService()).getWebApp().getListenerAddress());
  URL httpUrl=new URL("http://" + hostPort);
  HttpURLConnection conn=(HttpURLConnection)httpUrl.openConnection();
  InputStream in=conn.getInputStream();
  ByteArrayOutputStream out=new ByteArrayOutputStream();
  IOUtils.copyBytes(in,out,1024);
  Assert.assertTrue(out.toString().contains("MapReduce Application"));
  URL httpsUrl=new URL("https://" + hostPort);
  try {
    HttpURLConnection httpsConn=(HttpURLConnection)httpsUrl.openConnection();
    httpsConn.getInputStream();
    Assert.fail("https:// is not accessible, expected to fail");
  }
 catch (  Exception e) {
    Assert.assertTrue(e instanceof SSLException);
  }
  app.waitForState(job,JobState.SUCCEEDED);
  app.verifyCompleted();
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.mapreduce.v2.app.webapp.TestAMWebServices </h4><pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testInvalidAccept() throws JSONException, Exception {
  WebResource r=resource();
  String responseStr="";
  try {
    responseStr=r.path("ws").path("v1").path("mapreduce").accept(MediaType.TEXT_PLAIN).get(String.class);
    fail("should have thrown exception on invalid uri");
  }
 catch (  UniformInterfaceException ue) {
    ClientResponse response=ue.getResponse();
    assertEquals(Status.INTERNAL_SERVER_ERROR,response.getClientResponseStatus());
    WebServicesTestUtils.checkStringMatch("error string exists and shouldn't","",responseStr);
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testInvalidUri2() throws JSONException, Exception {
  WebResource r=resource();
  String responseStr="";
  try {
    responseStr=r.path("ws").path("v1").path("invalid").accept(MediaType.APPLICATION_JSON).get(String.class);
    fail("should have thrown exception on invalid uri");
  }
 catch (  UniformInterfaceException ue) {
    ClientResponse response=ue.getResponse();
    assertEquals(Status.NOT_FOUND,response.getClientResponseStatus());
    WebServicesTestUtils.checkStringMatch("error string exists and shouldn't","",responseStr);
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testInvalidUri() throws JSONException, Exception {
  WebResource r=resource();
  String responseStr="";
  try {
    responseStr=r.path("ws").path("v1").path("mapreduce").path("bogus").accept(MediaType.APPLICATION_JSON).get(String.class);
    fail("should have thrown exception on invalid uri");
  }
 catch (  UniformInterfaceException ue) {
    ClientResponse response=ue.getResponse();
    assertEquals(Status.NOT_FOUND,response.getClientResponseStatus());
    WebServicesTestUtils.checkStringMatch("error string exists and shouldn't","",responseStr);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.mapreduce.v2.app.webapp.TestAMWebServicesJobs </h4><pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testJobIdInvalidXML() throws JSONException, Exception {
  WebResource r=resource();
  try {
    r.path("ws").path("v1").path("mapreduce").path("jobs").path("job_foo").accept(MediaType.APPLICATION_XML).get(JSONObject.class);
    fail("should have thrown exception on invalid uri");
  }
 catch (  UniformInterfaceException ue) {
    ClientResponse response=ue.getResponse();
    assertEquals(Status.NOT_FOUND,response.getClientResponseStatus());
    assertEquals(MediaType.APPLICATION_XML_TYPE,response.getType());
    String msg=response.getEntity(String.class);
    System.out.println(msg);
    DocumentBuilderFactory dbf=DocumentBuilderFactory.newInstance();
    DocumentBuilder db=dbf.newDocumentBuilder();
    InputSource is=new InputSource();
    is.setCharacterStream(new StringReader(msg));
    Document dom=db.parse(is);
    NodeList nodes=dom.getElementsByTagName("RemoteException");
    Element element=(Element)nodes.item(0);
    String message=WebServicesTestUtils.getXmlString(element,"message");
    String type=WebServicesTestUtils.getXmlString(element,"exception");
    String classname=WebServicesTestUtils.getXmlString(element,"javaClassName");
    verifyJobIdInvalid(message,type,classname);
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testJobIdInvalid() throws JSONException, Exception {
  WebResource r=resource();
  try {
    r.path("ws").path("v1").path("mapreduce").path("jobs").path("job_foo").accept(MediaType.APPLICATION_JSON).get(JSONObject.class);
    fail("should have thrown exception on invalid uri");
  }
 catch (  UniformInterfaceException ue) {
    ClientResponse response=ue.getResponse();
    assertEquals(Status.NOT_FOUND,response.getClientResponseStatus());
    assertEquals(MediaType.APPLICATION_JSON_TYPE,response.getType());
    JSONObject msg=response.getEntity(JSONObject.class);
    JSONObject exception=msg.getJSONObject("RemoteException");
    assertEquals("incorrect number of elements",3,exception.length());
    String message=exception.getString("message");
    String type=exception.getString("exception");
    String classname=exception.getString("javaClassName");
    verifyJobIdInvalid(message,type,classname);
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testJobIdInvalidDefault() throws JSONException, Exception {
  WebResource r=resource();
  try {
    r.path("ws").path("v1").path("mapreduce").path("jobs").path("job_foo").get(JSONObject.class);
    fail("should have thrown exception on invalid uri");
  }
 catch (  UniformInterfaceException ue) {
    ClientResponse response=ue.getResponse();
    assertEquals(Status.NOT_FOUND,response.getClientResponseStatus());
    assertEquals(MediaType.APPLICATION_JSON_TYPE,response.getType());
    JSONObject msg=response.getEntity(JSONObject.class);
    JSONObject exception=msg.getJSONObject("RemoteException");
    assertEquals("incorrect number of elements",3,exception.length());
    String message=exception.getString("message");
    String type=exception.getString("exception");
    String classname=exception.getString("javaClassName");
    verifyJobIdInvalid(message,type,classname);
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testJobIdNonExist() throws JSONException, Exception {
  WebResource r=resource();
  try {
    r.path("ws").path("v1").path("mapreduce").path("jobs").path("job_0_1234").get(JSONObject.class);
    fail("should have thrown exception on invalid uri");
  }
 catch (  UniformInterfaceException ue) {
    ClientResponse response=ue.getResponse();
    assertEquals(Status.NOT_FOUND,response.getClientResponseStatus());
    assertEquals(MediaType.APPLICATION_JSON_TYPE,response.getType());
    JSONObject msg=response.getEntity(JSONObject.class);
    JSONObject exception=msg.getJSONObject("RemoteException");
    assertEquals("incorrect number of elements",3,exception.length());
    String message=exception.getString("message");
    String type=exception.getString("exception");
    String classname=exception.getString("javaClassName");
    WebServicesTestUtils.checkStringMatch("exception message","java.lang.Exception: job, job_0_1234, is not found",message);
    WebServicesTestUtils.checkStringMatch("exception type","NotFoundException",type);
    WebServicesTestUtils.checkStringMatch("exception classname","org.apache.hadoop.yarn.webapp.NotFoundException",classname);
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testJobIdInvalidBogus() throws JSONException, Exception {
  WebResource r=resource();
  try {
    r.path("ws").path("v1").path("mapreduce").path("jobs").path("bogusfoo").get(JSONObject.class);
    fail("should have thrown exception on invalid uri");
  }
 catch (  UniformInterfaceException ue) {
    ClientResponse response=ue.getResponse();
    assertEquals(Status.NOT_FOUND,response.getClientResponseStatus());
    assertEquals(MediaType.APPLICATION_JSON_TYPE,response.getType());
    JSONObject msg=response.getEntity(JSONObject.class);
    JSONObject exception=msg.getJSONObject("RemoteException");
    assertEquals("incorrect number of elements",3,exception.length());
    String message=exception.getString("message");
    String type=exception.getString("exception");
    String classname=exception.getString("javaClassName");
    WebServicesTestUtils.checkStringMatch("exception message","java.lang.Exception: JobId string : bogusfoo is not properly formed",message);
    WebServicesTestUtils.checkStringMatch("exception type","NotFoundException",type);
    WebServicesTestUtils.checkStringMatch("exception classname","org.apache.hadoop.yarn.webapp.NotFoundException",classname);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.mapreduce.v2.app.webapp.TestAMWebServicesTasks </h4><pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testTaskIdInvalid() throws JSONException, Exception {
  WebResource r=resource();
  Map<JobId,Job> jobsMap=appContext.getAllJobs();
  for (  JobId id : jobsMap.keySet()) {
    String jobId=MRApps.toString(id);
    String tid="task_0_0000_d_000000";
    try {
      r.path("ws").path("v1").path("mapreduce").path("jobs").path(jobId).path("tasks").path(tid).get(JSONObject.class);
      fail("should have thrown exception on invalid uri");
    }
 catch (    UniformInterfaceException ue) {
      ClientResponse response=ue.getResponse();
      assertEquals(Status.NOT_FOUND,response.getClientResponseStatus());
      assertEquals(MediaType.APPLICATION_JSON_TYPE,response.getType());
      JSONObject msg=response.getEntity(JSONObject.class);
      JSONObject exception=msg.getJSONObject("RemoteException");
      assertEquals("incorrect number of elements",3,exception.length());
      String message=exception.getString("message");
      String type=exception.getString("exception");
      String classname=exception.getString("javaClassName");
      WebServicesTestUtils.checkStringMatch("exception message","java.lang.Exception: Bad TaskType identifier. TaskId string : " + "task_0_0000_d_000000 is not properly formed.",message);
      WebServicesTestUtils.checkStringMatch("exception type","NotFoundException",type);
      WebServicesTestUtils.checkStringMatch("exception classname","org.apache.hadoop.yarn.webapp.NotFoundException",classname);
    }
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testTaskIdBogus() throws JSONException, Exception {
  WebResource r=resource();
  Map<JobId,Job> jobsMap=appContext.getAllJobs();
  for (  JobId id : jobsMap.keySet()) {
    String jobId=MRApps.toString(id);
    String tid="bogustaskid";
    try {
      r.path("ws").path("v1").path("mapreduce").path("jobs").path(jobId).path("tasks").path(tid).get(JSONObject.class);
      fail("should have thrown exception on invalid uri");
    }
 catch (    UniformInterfaceException ue) {
      ClientResponse response=ue.getResponse();
      assertEquals(Status.NOT_FOUND,response.getClientResponseStatus());
      assertEquals(MediaType.APPLICATION_JSON_TYPE,response.getType());
      JSONObject msg=response.getEntity(JSONObject.class);
      JSONObject exception=msg.getJSONObject("RemoteException");
      assertEquals("incorrect number of elements",3,exception.length());
      String message=exception.getString("message");
      String type=exception.getString("exception");
      String classname=exception.getString("javaClassName");
      WebServicesTestUtils.checkStringMatch("exception message","java.lang.Exception: TaskId string : " + "bogustaskid is not properly formed",message);
      WebServicesTestUtils.checkStringMatch("exception type","NotFoundException",type);
      WebServicesTestUtils.checkStringMatch("exception classname","org.apache.hadoop.yarn.webapp.NotFoundException",classname);
    }
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testTasksQueryInvalid() throws JSONException, Exception {
  WebResource r=resource();
  Map<JobId,Job> jobsMap=appContext.getAllJobs();
  for (  JobId id : jobsMap.keySet()) {
    String jobId=MRApps.toString(id);
    String tasktype="reduce";
    try {
      r.path("ws").path("v1").path("mapreduce").path("jobs").path(jobId).path("tasks").queryParam("type",tasktype).accept(MediaType.APPLICATION_JSON).get(JSONObject.class);
      fail("should have thrown exception on invalid uri");
    }
 catch (    UniformInterfaceException ue) {
      ClientResponse response=ue.getResponse();
      assertEquals(Status.BAD_REQUEST,response.getClientResponseStatus());
      assertEquals(MediaType.APPLICATION_JSON_TYPE,response.getType());
      JSONObject msg=response.getEntity(JSONObject.class);
      JSONObject exception=msg.getJSONObject("RemoteException");
      assertEquals("incorrect number of elements",3,exception.length());
      String message=exception.getString("message");
      String type=exception.getString("exception");
      String classname=exception.getString("javaClassName");
      WebServicesTestUtils.checkStringMatch("exception message","java.lang.Exception: tasktype must be either m or r",message);
      WebServicesTestUtils.checkStringMatch("exception type","BadRequestException",type);
      WebServicesTestUtils.checkStringMatch("exception classname","org.apache.hadoop.yarn.webapp.BadRequestException",classname);
    }
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testTaskIdNonExist() throws JSONException, Exception {
  WebResource r=resource();
  Map<JobId,Job> jobsMap=appContext.getAllJobs();
  for (  JobId id : jobsMap.keySet()) {
    String jobId=MRApps.toString(id);
    String tid="task_0_0000_m_000000";
    try {
      r.path("ws").path("v1").path("mapreduce").path("jobs").path(jobId).path("tasks").path(tid).get(JSONObject.class);
      fail("should have thrown exception on invalid uri");
    }
 catch (    UniformInterfaceException ue) {
      ClientResponse response=ue.getResponse();
      assertEquals(Status.NOT_FOUND,response.getClientResponseStatus());
      assertEquals(MediaType.APPLICATION_JSON_TYPE,response.getType());
      JSONObject msg=response.getEntity(JSONObject.class);
      JSONObject exception=msg.getJSONObject("RemoteException");
      assertEquals("incorrect number of elements",3,exception.length());
      String message=exception.getString("message");
      String type=exception.getString("exception");
      String classname=exception.getString("javaClassName");
      WebServicesTestUtils.checkStringMatch("exception message","java.lang.Exception: task not found with id task_0_0000_m_000000",message);
      WebServicesTestUtils.checkStringMatch("exception type","NotFoundException",type);
      WebServicesTestUtils.checkStringMatch("exception classname","org.apache.hadoop.yarn.webapp.NotFoundException",classname);
    }
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testTaskIdInvalid3() throws JSONException, Exception {
  WebResource r=resource();
  Map<JobId,Job> jobsMap=appContext.getAllJobs();
  for (  JobId id : jobsMap.keySet()) {
    String jobId=MRApps.toString(id);
    String tid="task_0_0000_m";
    try {
      r.path("ws").path("v1").path("mapreduce").path("jobs").path(jobId).path("tasks").path(tid).get(JSONObject.class);
      fail("should have thrown exception on invalid uri");
    }
 catch (    UniformInterfaceException ue) {
      ClientResponse response=ue.getResponse();
      assertEquals(Status.NOT_FOUND,response.getClientResponseStatus());
      assertEquals(MediaType.APPLICATION_JSON_TYPE,response.getType());
      JSONObject msg=response.getEntity(JSONObject.class);
      JSONObject exception=msg.getJSONObject("RemoteException");
      assertEquals("incorrect number of elements",3,exception.length());
      String message=exception.getString("message");
      String type=exception.getString("exception");
      String classname=exception.getString("javaClassName");
      WebServicesTestUtils.checkStringMatch("exception message","java.lang.Exception: TaskId string : " + "task_0_0000_m is not properly formed",message);
      WebServicesTestUtils.checkStringMatch("exception type","NotFoundException",type);
      WebServicesTestUtils.checkStringMatch("exception classname","org.apache.hadoop.yarn.webapp.NotFoundException",classname);
    }
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testTaskIdInvalid2() throws JSONException, Exception {
  WebResource r=resource();
  Map<JobId,Job> jobsMap=appContext.getAllJobs();
  for (  JobId id : jobsMap.keySet()) {
    String jobId=MRApps.toString(id);
    String tid="task_0_m_000000";
    try {
      r.path("ws").path("v1").path("mapreduce").path("jobs").path(jobId).path("tasks").path(tid).get(JSONObject.class);
      fail("should have thrown exception on invalid uri");
    }
 catch (    UniformInterfaceException ue) {
      ClientResponse response=ue.getResponse();
      assertEquals(Status.NOT_FOUND,response.getClientResponseStatus());
      assertEquals(MediaType.APPLICATION_JSON_TYPE,response.getType());
      JSONObject msg=response.getEntity(JSONObject.class);
      JSONObject exception=msg.getJSONObject("RemoteException");
      assertEquals("incorrect number of elements",3,exception.length());
      String message=exception.getString("message");
      String type=exception.getString("exception");
      String classname=exception.getString("javaClassName");
      WebServicesTestUtils.checkStringMatch("exception message","java.lang.Exception: TaskId string : " + "task_0_m_000000 is not properly formed",message);
      WebServicesTestUtils.checkStringMatch("exception type","NotFoundException",type);
      WebServicesTestUtils.checkStringMatch("exception classname","org.apache.hadoop.yarn.webapp.NotFoundException",classname);
    }
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.mapreduce.v2.hs.TestHistoryFileManager </h4><pre class="type-2 type-7 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testCreateDirsWithFileSystemBecomingAvailBeforeTimeout() throws Exception {
  dfsCluster.getFileSystem().setSafeMode(HdfsConstants.SafeModeAction.SAFEMODE_ENTER);
  Assert.assertTrue(dfsCluster.getFileSystem().isInSafeMode());
  new Thread(){
    @Override public void run(){
      try {
        Thread.sleep(500);
        dfsCluster.getFileSystem().setSafeMode(HdfsConstants.SafeModeAction.SAFEMODE_LEAVE);
        Assert.assertTrue(dfsCluster.getFileSystem().isInSafeMode());
      }
 catch (      Exception ex) {
        Assert.fail(ex.toString());
      }
    }
  }
.start();
  testCreateHistoryDirs(dfsCluster.getConfiguration(0),new SystemClock());
}

</code></pre>

<br>
<pre class="type-2 type-7 type-10 type-14 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies that exceptions are thrown during the test case execution">ExceptionVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies that exceptions are thrown during the test case execution
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(expected=YarnRuntimeException.class) public void testCreateDirsWithFileSystemNotBecomingAvailBeforeTimeout() throws Exception {
  dfsCluster.getFileSystem().setSafeMode(HdfsConstants.SafeModeAction.SAFEMODE_ENTER);
  Assert.assertTrue(dfsCluster.getFileSystem().isInSafeMode());
  final ControlledClock clock=new ControlledClock(new SystemClock());
  clock.setTime(1);
  new Thread(){
    @Override public void run(){
      try {
        Thread.sleep(500);
        clock.setTime(3000);
      }
 catch (      Exception ex) {
        Assert.fail(ex.toString());
      }
    }
  }
.start();
  testCreateHistoryDirs(dfsCluster.getConfiguration(0),clock);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.mapreduce.v2.hs.TestHistoryServerFileSystemStateStoreService </h4><pre class="type-2 type-7 type-10 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testUpdatedTokenRecovery() throws IOException {
  IOException intentionalErr=new IOException("intentional error");
  FileSystem fs=FileSystem.getLocal(conf);
  final FileSystem spyfs=spy(fs);
  ArgumentMatcher<Path> updateTmpMatcher=new ArgumentMatcher<Path>(){
    @Override public boolean matches(    Object argument){
      if (argument instanceof Path) {
        return ((Path)argument).getName().startsWith("update");
      }
      return false;
    }
  }
;
  doThrow(intentionalErr).when(spyfs).rename(argThat(updateTmpMatcher),isA(Path.class));
  conf.set(JHAdminConfig.MR_HS_FS_STATE_STORE_URI,testDir.getAbsoluteFile().toURI().toString());
  HistoryServerStateStoreService store=new HistoryServerFileSystemStateStoreService(){
    @Override FileSystem createFileSystem() throws IOException {
      return spyfs;
    }
  }
;
  store.init(conf);
  store.start();
  final MRDelegationTokenIdentifier token1=new MRDelegationTokenIdentifier(new Text("tokenOwner1"),new Text("tokenRenewer1"),new Text("tokenUser1"));
  token1.setSequenceNumber(1);
  final Long tokenDate1=1L;
  store.storeToken(token1,tokenDate1);
  final Long newTokenDate1=975318642L;
  try {
    store.updateToken(token1,newTokenDate1);
    fail("intentional error not thrown");
  }
 catch (  IOException e) {
    assertEquals(intentionalErr,e);
  }
  store.close();
  store=createAndStartStore();
  HistoryServerState state=store.loadState();
  assertEquals("incorrect loaded token count",1,state.tokenState.size());
  assertTrue("missing token 1",state.tokenState.containsKey(token1));
  assertEquals("incorrect token 1 date",newTokenDate1,state.tokenState.get(token1));
  store.close();
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.mapreduce.v2.hs.TestJobHistoryServer </h4><pre class="type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testLaunch() throws Exception {
  ExitUtil.disableSystemExit();
  try {
    historyServer=JobHistoryServer.launchJobHistoryServer(new String[0]);
  }
 catch (  ExitUtil.ExitException e) {
    assertEquals(0,e.status);
    ExitUtil.resetFirstExitException();
    fail();
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.mapreduce.v2.hs.TestJobListCache </h4><pre class="type-13 type-11 type-2 type-7 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=1000) public void testEviction() throws InterruptedException {
  int maxSize=2;
  JobListCache cache=new JobListCache(maxSize,1000);
  JobId jobId1=MRBuilderUtils.newJobId(1,1,1);
  HistoryFileInfo fileInfo1=Mockito.mock(HistoryFileInfo.class);
  Mockito.when(fileInfo1.getJobId()).thenReturn(jobId1);
  JobId jobId2=MRBuilderUtils.newJobId(2,2,2);
  HistoryFileInfo fileInfo2=Mockito.mock(HistoryFileInfo.class);
  Mockito.when(fileInfo2.getJobId()).thenReturn(jobId2);
  JobId jobId3=MRBuilderUtils.newJobId(3,3,3);
  HistoryFileInfo fileInfo3=Mockito.mock(HistoryFileInfo.class);
  Mockito.when(fileInfo3.getJobId()).thenReturn(jobId3);
  cache.addIfAbsent(fileInfo1);
  cache.addIfAbsent(fileInfo2);
  cache.addIfAbsent(fileInfo3);
  Collection<HistoryFileInfo> values;
  for (int i=0; i < 9; i++) {
    values=cache.values();
    if (values.size() > maxSize) {
      Thread.sleep(100);
    }
 else {
      assertFalse("fileInfo1 should have been evicted",values.contains(fileInfo1));
      return;
    }
  }
  fail("JobListCache didn't delete the extra entry");
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.mapreduce.v2.hs.webapp.TestHsWebServices </h4><pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testInvalidAccept() throws JSONException, Exception {
  WebResource r=resource();
  String responseStr="";
  try {
    responseStr=r.path("ws").path("v1").path("history").accept(MediaType.TEXT_PLAIN).get(String.class);
    fail("should have thrown exception on invalid uri");
  }
 catch (  UniformInterfaceException ue) {
    ClientResponse response=ue.getResponse();
    assertEquals(Status.INTERNAL_SERVER_ERROR,response.getClientResponseStatus());
    WebServicesTestUtils.checkStringMatch("error string exists and shouldn't","",responseStr);
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testInvalidUri2() throws JSONException, Exception {
  WebResource r=resource();
  String responseStr="";
  try {
    responseStr=r.path("ws").path("v1").path("invalid").accept(MediaType.APPLICATION_JSON).get(String.class);
    fail("should have thrown exception on invalid uri");
  }
 catch (  UniformInterfaceException ue) {
    ClientResponse response=ue.getResponse();
    assertEquals(Status.NOT_FOUND,response.getClientResponseStatus());
    WebServicesTestUtils.checkStringMatch("error string exists and shouldn't","",responseStr);
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testInvalidUri() throws JSONException, Exception {
  WebResource r=resource();
  String responseStr="";
  try {
    responseStr=r.path("ws").path("v1").path("history").path("bogus").accept(MediaType.APPLICATION_JSON).get(String.class);
    fail("should have thrown exception on invalid uri");
  }
 catch (  UniformInterfaceException ue) {
    ClientResponse response=ue.getResponse();
    assertEquals(Status.NOT_FOUND,response.getClientResponseStatus());
    WebServicesTestUtils.checkStringMatch("error string exists and shouldn't","",responseStr);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.mapreduce.v2.hs.webapp.TestHsWebServicesAcls </h4><pre class="type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testGetJobTaskAttemptIdAcls(){
  HttpServletRequest hsr=mock(HttpServletRequest.class);
  when(hsr.getRemoteUser()).thenReturn(ENEMY_USER);
  try {
    hsWebServices.getJobTaskAttemptId(hsr,this.jobIdStr,this.taskIdStr,this.taskAttemptIdStr);
    fail("enemy can access job");
  }
 catch (  WebApplicationException e) {
    assertEquals(Status.UNAUTHORIZED,Status.fromStatusCode(e.getResponse().getStatus()));
  }
  when(hsr.getRemoteUser()).thenReturn(FRIENDLY_USER);
  hsWebServices.getJobTaskAttemptId(hsr,this.jobIdStr,this.taskIdStr,this.taskAttemptIdStr);
}

</code></pre>

<br>
<pre class="type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testGetJobAcls(){
  HttpServletRequest hsr=mock(HttpServletRequest.class);
  when(hsr.getRemoteUser()).thenReturn(ENEMY_USER);
  try {
    hsWebServices.getJob(hsr,jobIdStr);
    fail("enemy can access job");
  }
 catch (  WebApplicationException e) {
    assertEquals(Status.UNAUTHORIZED,Status.fromStatusCode(e.getResponse().getStatus()));
  }
  when(hsr.getRemoteUser()).thenReturn(FRIENDLY_USER);
  hsWebServices.getJob(hsr,jobIdStr);
}

</code></pre>

<br>
<pre class="type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testGetJobTaskAttemptsAcls(){
  HttpServletRequest hsr=mock(HttpServletRequest.class);
  when(hsr.getRemoteUser()).thenReturn(ENEMY_USER);
  try {
    hsWebServices.getJobTaskAttempts(hsr,this.jobIdStr,this.taskIdStr);
    fail("enemy can access job");
  }
 catch (  WebApplicationException e) {
    assertEquals(Status.UNAUTHORIZED,Status.fromStatusCode(e.getResponse().getStatus()));
  }
  when(hsr.getRemoteUser()).thenReturn(FRIENDLY_USER);
  hsWebServices.getJobTaskAttempts(hsr,this.jobIdStr,this.taskIdStr);
}

</code></pre>

<br>
<pre class="type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testGetJobTasksAcls(){
  HttpServletRequest hsr=mock(HttpServletRequest.class);
  when(hsr.getRemoteUser()).thenReturn(ENEMY_USER);
  try {
    hsWebServices.getJobTasks(hsr,jobIdStr,"m");
    fail("enemy can access job");
  }
 catch (  WebApplicationException e) {
    assertEquals(Status.UNAUTHORIZED,Status.fromStatusCode(e.getResponse().getStatus()));
  }
  when(hsr.getRemoteUser()).thenReturn(FRIENDLY_USER);
  hsWebServices.getJobTasks(hsr,jobIdStr,"m");
}

</code></pre>

<br>
<pre class="type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testGetSingleTaskCountersAcls(){
  HttpServletRequest hsr=mock(HttpServletRequest.class);
  when(hsr.getRemoteUser()).thenReturn(ENEMY_USER);
  try {
    hsWebServices.getSingleTaskCounters(hsr,this.jobIdStr,this.taskIdStr);
    fail("enemy can access job");
  }
 catch (  WebApplicationException e) {
    assertEquals(Status.UNAUTHORIZED,Status.fromStatusCode(e.getResponse().getStatus()));
  }
  when(hsr.getRemoteUser()).thenReturn(FRIENDLY_USER);
  hsWebServices.getSingleTaskCounters(hsr,this.jobIdStr,this.taskIdStr);
}

</code></pre>

<br>
<pre class="type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testGetJobTaskAttemptIdCountersAcls(){
  HttpServletRequest hsr=mock(HttpServletRequest.class);
  when(hsr.getRemoteUser()).thenReturn(ENEMY_USER);
  try {
    hsWebServices.getJobTaskAttemptIdCounters(hsr,this.jobIdStr,this.taskIdStr,this.taskAttemptIdStr);
    fail("enemy can access job");
  }
 catch (  WebApplicationException e) {
    assertEquals(Status.UNAUTHORIZED,Status.fromStatusCode(e.getResponse().getStatus()));
  }
  when(hsr.getRemoteUser()).thenReturn(FRIENDLY_USER);
  hsWebServices.getJobTaskAttemptIdCounters(hsr,this.jobIdStr,this.taskIdStr,this.taskAttemptIdStr);
}

</code></pre>

<br>
<pre class="type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testGetJobTaskAcls(){
  HttpServletRequest hsr=mock(HttpServletRequest.class);
  when(hsr.getRemoteUser()).thenReturn(ENEMY_USER);
  try {
    hsWebServices.getJobTask(hsr,jobIdStr,this.taskIdStr);
    fail("enemy can access job");
  }
 catch (  WebApplicationException e) {
    assertEquals(Status.UNAUTHORIZED,Status.fromStatusCode(e.getResponse().getStatus()));
  }
  when(hsr.getRemoteUser()).thenReturn(FRIENDLY_USER);
  hsWebServices.getJobTask(hsr,this.jobIdStr,this.taskIdStr);
}

</code></pre>

<br>
<pre class="type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testGetJobCountersAcls(){
  HttpServletRequest hsr=mock(HttpServletRequest.class);
  when(hsr.getRemoteUser()).thenReturn(ENEMY_USER);
  try {
    hsWebServices.getJobCounters(hsr,jobIdStr);
    fail("enemy can access job");
  }
 catch (  WebApplicationException e) {
    assertEquals(Status.UNAUTHORIZED,Status.fromStatusCode(e.getResponse().getStatus()));
  }
  when(hsr.getRemoteUser()).thenReturn(FRIENDLY_USER);
  hsWebServices.getJobCounters(hsr,jobIdStr);
}

</code></pre>

<br>
<pre class="type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testGetJobConfAcls(){
  HttpServletRequest hsr=mock(HttpServletRequest.class);
  when(hsr.getRemoteUser()).thenReturn(ENEMY_USER);
  try {
    hsWebServices.getJobConf(hsr,jobIdStr);
    fail("enemy can access job");
  }
 catch (  WebApplicationException e) {
    assertEquals(Status.UNAUTHORIZED,Status.fromStatusCode(e.getResponse().getStatus()));
  }
  when(hsr.getRemoteUser()).thenReturn(FRIENDLY_USER);
  hsWebServices.getJobConf(hsr,jobIdStr);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.mapreduce.v2.hs.webapp.TestHsWebServicesJobs </h4><pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testJobIdInvalidDefault() throws JSONException, Exception {
  WebResource r=resource();
  try {
    r.path("ws").path("v1").path("history").path("mapreduce").path("jobs").path("job_foo").get(JSONObject.class);
    fail("should have thrown exception on invalid uri");
  }
 catch (  UniformInterfaceException ue) {
    ClientResponse response=ue.getResponse();
    assertEquals(Status.NOT_FOUND,response.getClientResponseStatus());
    assertEquals(MediaType.APPLICATION_JSON_TYPE,response.getType());
    JSONObject msg=response.getEntity(JSONObject.class);
    JSONObject exception=msg.getJSONObject("RemoteException");
    assertEquals("incorrect number of elements",3,exception.length());
    String message=exception.getString("message");
    String type=exception.getString("exception");
    String classname=exception.getString("javaClassName");
    verifyJobIdInvalid(message,type,classname);
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testJobIdInvalidXML() throws JSONException, Exception {
  WebResource r=resource();
  try {
    r.path("ws").path("v1").path("history").path("mapreduce").path("jobs").path("job_foo").accept(MediaType.APPLICATION_XML).get(JSONObject.class);
    fail("should have thrown exception on invalid uri");
  }
 catch (  UniformInterfaceException ue) {
    ClientResponse response=ue.getResponse();
    assertEquals(Status.NOT_FOUND,response.getClientResponseStatus());
    assertEquals(MediaType.APPLICATION_XML_TYPE,response.getType());
    String msg=response.getEntity(String.class);
    System.out.println(msg);
    DocumentBuilderFactory dbf=DocumentBuilderFactory.newInstance();
    DocumentBuilder db=dbf.newDocumentBuilder();
    InputSource is=new InputSource();
    is.setCharacterStream(new StringReader(msg));
    Document dom=db.parse(is);
    NodeList nodes=dom.getElementsByTagName("RemoteException");
    Element element=(Element)nodes.item(0);
    String message=WebServicesTestUtils.getXmlString(element,"message");
    String type=WebServicesTestUtils.getXmlString(element,"exception");
    String classname=WebServicesTestUtils.getXmlString(element,"javaClassName");
    verifyJobIdInvalid(message,type,classname);
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testJobIdNonExist() throws JSONException, Exception {
  WebResource r=resource();
  try {
    r.path("ws").path("v1").path("history").path("mapreduce").path("jobs").path("job_0_1234").get(JSONObject.class);
    fail("should have thrown exception on invalid uri");
  }
 catch (  UniformInterfaceException ue) {
    ClientResponse response=ue.getResponse();
    assertEquals(Status.NOT_FOUND,response.getClientResponseStatus());
    assertEquals(MediaType.APPLICATION_JSON_TYPE,response.getType());
    JSONObject msg=response.getEntity(JSONObject.class);
    JSONObject exception=msg.getJSONObject("RemoteException");
    assertEquals("incorrect number of elements",3,exception.length());
    String message=exception.getString("message");
    String type=exception.getString("exception");
    String classname=exception.getString("javaClassName");
    WebServicesTestUtils.checkStringMatch("exception message","java.lang.Exception: job, job_0_1234, is not found",message);
    WebServicesTestUtils.checkStringMatch("exception type","NotFoundException",type);
    WebServicesTestUtils.checkStringMatch("exception classname","org.apache.hadoop.yarn.webapp.NotFoundException",classname);
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testJobIdInvalidBogus() throws JSONException, Exception {
  WebResource r=resource();
  try {
    r.path("ws").path("v1").path("history").path("mapreduce").path("jobs").path("bogusfoo").get(JSONObject.class);
    fail("should have thrown exception on invalid uri");
  }
 catch (  UniformInterfaceException ue) {
    ClientResponse response=ue.getResponse();
    assertEquals(Status.NOT_FOUND,response.getClientResponseStatus());
    assertEquals(MediaType.APPLICATION_JSON_TYPE,response.getType());
    JSONObject msg=response.getEntity(JSONObject.class);
    JSONObject exception=msg.getJSONObject("RemoteException");
    assertEquals("incorrect number of elements",3,exception.length());
    String message=exception.getString("message");
    String type=exception.getString("exception");
    String classname=exception.getString("javaClassName");
    WebServicesTestUtils.checkStringMatch("exception message","java.lang.Exception: JobId string : " + "bogusfoo is not properly formed",message);
    WebServicesTestUtils.checkStringMatch("exception type","NotFoundException",type);
    WebServicesTestUtils.checkStringMatch("exception classname","org.apache.hadoop.yarn.webapp.NotFoundException",classname);
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testJobIdInvalid() throws JSONException, Exception {
  WebResource r=resource();
  try {
    r.path("ws").path("v1").path("history").path("mapreduce").path("jobs").path("job_foo").accept(MediaType.APPLICATION_JSON).get(JSONObject.class);
    fail("should have thrown exception on invalid uri");
  }
 catch (  UniformInterfaceException ue) {
    ClientResponse response=ue.getResponse();
    assertEquals(Status.NOT_FOUND,response.getClientResponseStatus());
    assertEquals(MediaType.APPLICATION_JSON_TYPE,response.getType());
    JSONObject msg=response.getEntity(JSONObject.class);
    JSONObject exception=msg.getJSONObject("RemoteException");
    assertEquals("incorrect number of elements",3,exception.length());
    String message=exception.getString("message");
    String type=exception.getString("exception");
    String classname=exception.getString("javaClassName");
    verifyJobIdInvalid(message,type,classname);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.mapreduce.v2.hs.webapp.TestHsWebServicesTasks </h4><pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testTaskIdInvalid() throws JSONException, Exception {
  WebResource r=resource();
  Map<JobId,Job> jobsMap=appContext.getAllJobs();
  for (  JobId id : jobsMap.keySet()) {
    String jobId=MRApps.toString(id);
    String tid="task_0_0000_d_000000";
    try {
      r.path("ws").path("v1").path("history").path("mapreduce").path("jobs").path(jobId).path("tasks").path(tid).get(JSONObject.class);
      fail("should have thrown exception on invalid uri");
    }
 catch (    UniformInterfaceException ue) {
      ClientResponse response=ue.getResponse();
      assertEquals(Status.NOT_FOUND,response.getClientResponseStatus());
      assertEquals(MediaType.APPLICATION_JSON_TYPE,response.getType());
      JSONObject msg=response.getEntity(JSONObject.class);
      JSONObject exception=msg.getJSONObject("RemoteException");
      assertEquals("incorrect number of elements",3,exception.length());
      String message=exception.getString("message");
      String type=exception.getString("exception");
      String classname=exception.getString("javaClassName");
      WebServicesTestUtils.checkStringMatch("exception message","java.lang.Exception: Bad TaskType identifier. TaskId string : " + "task_0_0000_d_000000 is not properly formed.",message);
      WebServicesTestUtils.checkStringMatch("exception type","NotFoundException",type);
      WebServicesTestUtils.checkStringMatch("exception classname","org.apache.hadoop.yarn.webapp.NotFoundException",classname);
    }
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testTaskIdNonExist() throws JSONException, Exception {
  WebResource r=resource();
  Map<JobId,Job> jobsMap=appContext.getAllJobs();
  for (  JobId id : jobsMap.keySet()) {
    String jobId=MRApps.toString(id);
    String tid="task_0_0000_m_000000";
    try {
      r.path("ws").path("v1").path("history").path("mapreduce").path("jobs").path(jobId).path("tasks").path(tid).get(JSONObject.class);
      fail("should have thrown exception on invalid uri");
    }
 catch (    UniformInterfaceException ue) {
      ClientResponse response=ue.getResponse();
      assertEquals(Status.NOT_FOUND,response.getClientResponseStatus());
      assertEquals(MediaType.APPLICATION_JSON_TYPE,response.getType());
      JSONObject msg=response.getEntity(JSONObject.class);
      JSONObject exception=msg.getJSONObject("RemoteException");
      assertEquals("incorrect number of elements",3,exception.length());
      String message=exception.getString("message");
      String type=exception.getString("exception");
      String classname=exception.getString("javaClassName");
      WebServicesTestUtils.checkStringMatch("exception message","java.lang.Exception: task not found with id task_0_0000_m_000000",message);
      WebServicesTestUtils.checkStringMatch("exception type","NotFoundException",type);
      WebServicesTestUtils.checkStringMatch("exception classname","org.apache.hadoop.yarn.webapp.NotFoundException",classname);
    }
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testTaskIdInvalid3() throws JSONException, Exception {
  WebResource r=resource();
  Map<JobId,Job> jobsMap=appContext.getAllJobs();
  for (  JobId id : jobsMap.keySet()) {
    String jobId=MRApps.toString(id);
    String tid="task_0_0000_m";
    try {
      r.path("ws").path("v1").path("history").path("mapreduce").path("jobs").path(jobId).path("tasks").path(tid).get(JSONObject.class);
      fail("should have thrown exception on invalid uri");
    }
 catch (    UniformInterfaceException ue) {
      ClientResponse response=ue.getResponse();
      assertEquals(Status.NOT_FOUND,response.getClientResponseStatus());
      assertEquals(MediaType.APPLICATION_JSON_TYPE,response.getType());
      JSONObject msg=response.getEntity(JSONObject.class);
      JSONObject exception=msg.getJSONObject("RemoteException");
      assertEquals("incorrect number of elements",3,exception.length());
      String message=exception.getString("message");
      String type=exception.getString("exception");
      String classname=exception.getString("javaClassName");
      WebServicesTestUtils.checkStringMatch("exception message","java.lang.Exception: TaskId string : " + "task_0_0000_m is not properly formed",message);
      WebServicesTestUtils.checkStringMatch("exception type","NotFoundException",type);
      WebServicesTestUtils.checkStringMatch("exception classname","org.apache.hadoop.yarn.webapp.NotFoundException",classname);
    }
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testTaskIdInvalid2() throws JSONException, Exception {
  WebResource r=resource();
  Map<JobId,Job> jobsMap=appContext.getAllJobs();
  for (  JobId id : jobsMap.keySet()) {
    String jobId=MRApps.toString(id);
    String tid="task_0000_m_000000";
    try {
      r.path("ws").path("v1").path("history").path("mapreduce").path("jobs").path(jobId).path("tasks").path(tid).get(JSONObject.class);
      fail("should have thrown exception on invalid uri");
    }
 catch (    UniformInterfaceException ue) {
      ClientResponse response=ue.getResponse();
      assertEquals(Status.NOT_FOUND,response.getClientResponseStatus());
      assertEquals(MediaType.APPLICATION_JSON_TYPE,response.getType());
      JSONObject msg=response.getEntity(JSONObject.class);
      JSONObject exception=msg.getJSONObject("RemoteException");
      assertEquals("incorrect number of elements",3,exception.length());
      String message=exception.getString("message");
      String type=exception.getString("exception");
      String classname=exception.getString("javaClassName");
      WebServicesTestUtils.checkStringMatch("exception message","java.lang.Exception: TaskId string : " + "task_0000_m_000000 is not properly formed",message);
      WebServicesTestUtils.checkStringMatch("exception type","NotFoundException",type);
      WebServicesTestUtils.checkStringMatch("exception classname","org.apache.hadoop.yarn.webapp.NotFoundException",classname);
    }
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testTaskIdBogus() throws JSONException, Exception {
  WebResource r=resource();
  Map<JobId,Job> jobsMap=appContext.getAllJobs();
  for (  JobId id : jobsMap.keySet()) {
    String jobId=MRApps.toString(id);
    String tid="bogustaskid";
    try {
      r.path("ws").path("v1").path("history").path("mapreduce").path("jobs").path(jobId).path("tasks").path(tid).get(JSONObject.class);
      fail("should have thrown exception on invalid uri");
    }
 catch (    UniformInterfaceException ue) {
      ClientResponse response=ue.getResponse();
      assertEquals(Status.NOT_FOUND,response.getClientResponseStatus());
      assertEquals(MediaType.APPLICATION_JSON_TYPE,response.getType());
      JSONObject msg=response.getEntity(JSONObject.class);
      JSONObject exception=msg.getJSONObject("RemoteException");
      assertEquals("incorrect number of elements",3,exception.length());
      String message=exception.getString("message");
      String type=exception.getString("exception");
      String classname=exception.getString("javaClassName");
      WebServicesTestUtils.checkStringMatch("exception message","java.lang.Exception: TaskId string : " + "bogustaskid is not properly formed",message);
      WebServicesTestUtils.checkStringMatch("exception type","NotFoundException",type);
      WebServicesTestUtils.checkStringMatch("exception classname","org.apache.hadoop.yarn.webapp.NotFoundException",classname);
    }
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testTasksQueryInvalid() throws JSONException, Exception {
  WebResource r=resource();
  Map<JobId,Job> jobsMap=appContext.getAllJobs();
  for (  JobId id : jobsMap.keySet()) {
    String jobId=MRApps.toString(id);
    String tasktype="reduce";
    try {
      r.path("ws").path("v1").path("history").path("mapreduce").path("jobs").path(jobId).path("tasks").queryParam("type",tasktype).accept(MediaType.APPLICATION_JSON).get(JSONObject.class);
      fail("should have thrown exception on invalid uri");
    }
 catch (    UniformInterfaceException ue) {
      ClientResponse response=ue.getResponse();
      assertEquals(Status.BAD_REQUEST,response.getClientResponseStatus());
      assertEquals(MediaType.APPLICATION_JSON_TYPE,response.getType());
      JSONObject msg=response.getEntity(JSONObject.class);
      JSONObject exception=msg.getJSONObject("RemoteException");
      assertEquals("incorrect number of elements",3,exception.length());
      String message=exception.getString("message");
      String type=exception.getString("exception");
      String classname=exception.getString("javaClassName");
      WebServicesTestUtils.checkStringMatch("exception message","java.lang.Exception: tasktype must be either m or r",message);
      WebServicesTestUtils.checkStringMatch("exception type","BadRequestException",type);
      WebServicesTestUtils.checkStringMatch("exception classname","org.apache.hadoop.yarn.webapp.BadRequestException",classname);
    }
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.mapreduce.v2.util.TestMRApps </h4><pre class="type-9 type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=120000) public void testSetClasspathWithUserPrecendence(){
  Configuration conf=new Configuration();
  conf.setBoolean(MRConfig.MAPREDUCE_APP_SUBMISSION_CROSS_PLATFORM,true);
  conf.setBoolean(MRJobConfig.MAPREDUCE_JOB_USER_CLASSPATH_FIRST,true);
  Map<String,String> env=new HashMap<String,String>();
  try {
    MRApps.setClasspath(env,conf);
  }
 catch (  Exception e) {
    fail("Got exception while setting classpath");
  }
  String env_str=env.get("CLASSPATH");
  String expectedClasspath=StringUtils.join(ApplicationConstants.CLASS_PATH_SEPARATOR,Arrays.asList(ApplicationConstants.Environment.PWD.$$(),"job.jar/job.jar","job.jar/classes/","job.jar/lib/*",ApplicationConstants.Environment.PWD.$$() + "/*"));
  assertTrue("MAPREDUCE_JOB_USER_CLASSPATH_FIRST set, but not taking effect!",env_str.startsWith(expectedClasspath));
}

</code></pre>

<br>
<pre class="type-9 type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=120000) public void testSetClasspathWithNoUserPrecendence(){
  Configuration conf=new Configuration();
  conf.setBoolean(MRConfig.MAPREDUCE_APP_SUBMISSION_CROSS_PLATFORM,true);
  conf.setBoolean(MRJobConfig.MAPREDUCE_JOB_USER_CLASSPATH_FIRST,false);
  Map<String,String> env=new HashMap<String,String>();
  try {
    MRApps.setClasspath(env,conf);
  }
 catch (  Exception e) {
    fail("Got exception while setting classpath");
  }
  String env_str=env.get("CLASSPATH");
  String expectedClasspath=StringUtils.join(ApplicationConstants.CLASS_PATH_SEPARATOR,Arrays.asList("job.jar/job.jar","job.jar/classes/","job.jar/lib/*",ApplicationConstants.Environment.PWD.$$() + "/*"));
  assertTrue("MAPREDUCE_JOB_USER_CLASSPATH_FIRST false, and job.jar is not in" + " the classpath!",env_str.contains(expectedClasspath));
  assertFalse("MAPREDUCE_JOB_USER_CLASSPATH_FIRST false, but taking effect!",env_str.startsWith(expectedClasspath));
}

</code></pre>

<br>
<pre class="type-9 type-2 type-10 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=3000000) public void testSetClasspathWithFramework() throws IOException {
  final String FRAMEWORK_NAME="some-framework-name";
  final String FRAMEWORK_PATH="some-framework-path#" + FRAMEWORK_NAME;
  Configuration conf=new Configuration();
  conf.setBoolean(MRConfig.MAPREDUCE_APP_SUBMISSION_CROSS_PLATFORM,true);
  conf.set(MRJobConfig.MAPREDUCE_APPLICATION_FRAMEWORK_PATH,FRAMEWORK_PATH);
  Map<String,String> env=new HashMap<String,String>();
  try {
    MRApps.setClasspath(env,conf);
    fail("Failed to catch framework path set without classpath change");
  }
 catch (  IllegalArgumentException e) {
    assertTrue("Unexpected IllegalArgumentException",e.getMessage().contains("Could not locate MapReduce framework name '" + FRAMEWORK_NAME + "'"));
  }
  env.clear();
  final String FRAMEWORK_CLASSPATH=FRAMEWORK_NAME + "/*.jar";
  conf.set(MRJobConfig.MAPREDUCE_APPLICATION_CLASSPATH,FRAMEWORK_CLASSPATH);
  MRApps.setClasspath(env,conf);
  final String stdClasspath=StringUtils.join(ApplicationConstants.CLASS_PATH_SEPARATOR,Arrays.asList("job.jar/job.jar","job.jar/classes/","job.jar/lib/*",ApplicationConstants.Environment.PWD.$$() + "/*"));
  String expectedClasspath=StringUtils.join(ApplicationConstants.CLASS_PATH_SEPARATOR,Arrays.asList(ApplicationConstants.Environment.PWD.$$(),FRAMEWORK_CLASSPATH,stdClasspath));
  assertEquals("Incorrect classpath with framework and no user precedence",expectedClasspath,env.get("CLASSPATH"));
  env.clear();
  conf.setBoolean(MRJobConfig.MAPREDUCE_JOB_USER_CLASSPATH_FIRST,true);
  MRApps.setClasspath(env,conf);
  expectedClasspath=StringUtils.join(ApplicationConstants.CLASS_PATH_SEPARATOR,Arrays.asList(ApplicationConstants.Environment.PWD.$$(),stdClasspath,FRAMEWORK_CLASSPATH));
  assertEquals("Incorrect classpath with framework and user precedence",expectedClasspath,env.get("CLASSPATH"));
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.net.TestDNS </h4><pre class="type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Get the IP addresses of an unknown interface
 */
@Test public void testIPsOfUnknownInterface() throws Exception {
  try {
    DNS.getIPs("name-of-an-unknown-interface");
    fail("Got an IP for a bogus interface");
  }
 catch (  UnknownHostException e) {
    assertEquals("No such interface name-of-an-unknown-interface",e.getMessage());
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * Test null interface name
 */
@Test public void testNullInterface() throws Exception {
  try {
    String host=DNS.getDefaultHost(null);
    fail("Expected a NullPointerException, got " + host);
  }
 catch (  NullPointerException npe) {
  }
  try {
    String ip=DNS.getDefaultIP(null);
    fail("Expected a NullPointerException, got " + ip);
  }
 catch (  NullPointerException npe) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.net.TestNetUtils </h4><pre class="type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testCreateSocketAddress() throws Throwable {
  InetSocketAddress addr=NetUtils.createSocketAddr("127.0.0.1:12345",1000,"myconfig");
  assertEquals("127.0.0.1",addr.getAddress().getHostAddress());
  assertEquals(12345,addr.getPort());
  addr=NetUtils.createSocketAddr("127.0.0.1",1000,"myconfig");
  assertEquals("127.0.0.1",addr.getAddress().getHostAddress());
  assertEquals(1000,addr.getPort());
  try {
    addr=NetUtils.createSocketAddr("127.0.0.1:blahblah",1000,"myconfig");
    fail("Should have failed to parse bad port");
  }
 catch (  IllegalArgumentException iae) {
    assertInException(iae,"myconfig");
  }
}

</code></pre>

<br>
<pre class="type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test that we can't accidentally connect back to the connecting socket due
 * to a quirk in the TCP spec.
 * This is a regression test for HADOOP-6722.
 */
@Test public void testAvoidLoopbackTcpSockets() throws Exception {
  Configuration conf=new Configuration();
  Socket socket=NetUtils.getDefaultSocketFactory(conf).createSocket();
  socket.bind(new InetSocketAddress("127.0.0.1",0));
  System.err.println("local address: " + socket.getLocalAddress());
  System.err.println("local port: " + socket.getLocalPort());
  try {
    NetUtils.connect(socket,new InetSocketAddress(socket.getLocalAddress(),socket.getLocalPort()),20000);
    socket.close();
    fail("Should not have connected");
  }
 catch (  ConnectException ce) {
    System.err.println("Got exception: " + ce);
    assertTrue(ce.getMessage().contains("resulted in a loopback"));
  }
catch (  SocketException se) {
    assertTrue(se.getMessage().contains("Invalid argument"));
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testVerifyHostnamesNoException(){
  String[] names={"valid.host.com","1.com"};
  try {
    NetUtils.verifyHostnames(names);
  }
 catch (  UnknownHostException e) {
    fail("NetUtils.verifyHostnames threw unexpected UnknownHostException");
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.net.TestNetworkTopology </h4><pre class="type-2 type-7 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testCreateInvalidTopology() throws Exception {
  NetworkTopology invalCluster=new NetworkTopology();
  DatanodeDescriptor invalDataNodes[]=new DatanodeDescriptor[]{DFSTestUtil.getDatanodeDescriptor("1.1.1.1","/d1/r1"),DFSTestUtil.getDatanodeDescriptor("2.2.2.2","/d1/r1"),DFSTestUtil.getDatanodeDescriptor("3.3.3.3","/d1")};
  invalCluster.add(invalDataNodes[0]);
  invalCluster.add(invalDataNodes[1]);
  try {
    invalCluster.add(invalDataNodes[2]);
    fail("expected InvalidTopologyException");
  }
 catch (  NetworkTopology.InvalidTopologyException e) {
    assertTrue(e.getMessage().startsWith("Failed to add "));
    assertTrue(e.getMessage().contains("You cannot have a rack and a non-rack node at the same " + "level of the network topology."));
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.net.TestNetworkTopologyWithNodeGroup </h4><pre class="type-11 type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * This test checks that adding a node with invalid topology will be failed 
 * with an exception to show topology is invalid.
 */
@Test public void testAddNodeWithInvalidTopology(){
  try {
    cluster.add(rackOnlyNode);
    fail("Exception should be thrown, so we should not have reached here.");
  }
 catch (  Exception e) {
    if (!(e instanceof IllegalArgumentException)) {
      fail("Expecting IllegalArgumentException, but caught:" + e);
    }
    assertTrue(e.getMessage().contains("illegal network location"));
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.net.TestSocketIOWithTimeout </h4><pre class="type-9 type-11 type-2 type-10 type-6 type-20 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values related to public fields.">PublicFieldVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Verifies values related to public fields.
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testSocketIOWithTimeout() throws Exception {
  Pipe pipe=Pipe.open();
  Pipe.SourceChannel source=pipe.source();
  Pipe.SinkChannel sink=pipe.sink();
  try {
    final InputStream in=new SocketInputStream(source,TIMEOUT);
    OutputStream out=new SocketOutputStream(sink,TIMEOUT);
    byte[] writeBytes=TEST_STRING.getBytes();
    byte[] readBytes=new byte[writeBytes.length];
    byte byteWithHighBit=(byte)0x80;
    out.write(writeBytes);
    out.write(byteWithHighBit);
    doIO(null,out,TIMEOUT);
    in.read(readBytes);
    assertTrue(Arrays.equals(writeBytes,readBytes));
    assertEquals(byteWithHighBit & 0xff,in.read());
    doIO(in,null,TIMEOUT);
    ((SocketInputStream)in).setTimeout(TIMEOUT * 2);
    doIO(in,null,TIMEOUT * 2);
    ((SocketInputStream)in).setTimeout(0);
    TestingThread thread=new TestingThread(ctx){
      @Override public void doWork() throws Exception {
        try {
          in.read();
          fail("Did not fail with interrupt");
        }
 catch (        InterruptedIOException ste) {
          LOG.info("Got expection while reading as expected : " + ste.getMessage());
        }
      }
    }
;
    ctx.addThread(thread);
    ctx.startThreads();
    Thread.sleep(1000);
    thread.interrupt();
    ctx.stop();
    assertTrue(source.isOpen());
    assertTrue(sink.isOpen());
    if (!Shell.WINDOWS && !Shell.PPC_64) {
      try {
        out.write(1);
        fail("Did not throw");
      }
 catch (      IOException ioe) {
        GenericTestUtils.assertExceptionContains("stream is closed",ioe);
      }
    }
    out.close();
    assertFalse(sink.isOpen());
    assertEquals(-1,in.read());
    in.close();
    assertFalse(source.isOpen());
  }
  finally {
    if (source != null) {
      source.close();
    }
    if (sink != null) {
      sink.close();
    }
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.net.unix.TestDomainSocket </h4><pre class="type-9 type-2 type-7 type-10 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test setting some server options.
 * @throws IOException
 */
@Test(timeout=180000) public void testServerOptions() throws Exception {
  final String TEST_PATH=new File(sockDir.getDir(),"test_sock_server_options").getAbsolutePath();
  DomainSocket serv=DomainSocket.bindAndListen(TEST_PATH);
  try {
    int bufSize=serv.getAttribute(DomainSocket.RECEIVE_BUFFER_SIZE);
    int newBufSize=bufSize / 2;
    serv.setAttribute(DomainSocket.RECEIVE_BUFFER_SIZE,newBufSize);
    int nextBufSize=serv.getAttribute(DomainSocket.RECEIVE_BUFFER_SIZE);
    Assert.assertEquals(newBufSize,nextBufSize);
    int newTimeout=1000;
    serv.setAttribute(DomainSocket.RECEIVE_TIMEOUT,newTimeout);
    int nextTimeout=serv.getAttribute(DomainSocket.RECEIVE_TIMEOUT);
    Assert.assertEquals(newTimeout,nextTimeout);
    try {
      serv.accept();
      Assert.fail("expected the accept() to time out and fail");
    }
 catch (    SocketTimeoutException e) {
      GenericTestUtils.assertExceptionContains("accept(2) error: ",e);
    }
  }
  finally {
    serv.close();
    Assert.assertFalse(serv.isOpen());
  }
}

</code></pre>

<br>
<pre class="type-9 type-13 type-11 type-2 type-7 type-10 type-1 type-20 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values related to public fields.">PublicFieldVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions in iterations
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects are null
- Verifies values related to public fields.
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test file descriptor passing.
 * @throws IOException
 */
@Test(timeout=180000) public void testFdPassing() throws Exception {
  final String TEST_PATH=new File(sockDir.getDir(),"test_sock").getAbsolutePath();
  final byte clientMsg1[]=new byte[]{0x11,0x22,0x33,0x44,0x55,0x66};
  final byte serverMsg1[]=new byte[]{0x31,0x30,0x32,0x34,0x31,0x33,0x44,0x1,0x1,0x1,0x1,0x1};
  final ArrayBlockingQueue<Throwable> threadResults=new ArrayBlockingQueue<Throwable>(2);
  final DomainSocket serv=DomainSocket.bindAndListen(TEST_PATH);
  final PassedFile passedFiles[]=new PassedFile[]{new PassedFile(1),new PassedFile(2)};
  final FileDescriptor passedFds[]=new FileDescriptor[passedFiles.length];
  for (int i=0; i < passedFiles.length; i++) {
    passedFds[i]=passedFiles[i].getInputStream().getFD();
  }
  Thread serverThread=new Thread(){
    public void run(){
      DomainSocket conn=null;
      try {
        conn=serv.accept();
        byte in1[]=new byte[clientMsg1.length];
        InputStream connInputStream=conn.getInputStream();
        IOUtils.readFully(connInputStream,in1,0,in1.length);
        Assert.assertTrue(Arrays.equals(clientMsg1,in1));
        DomainSocket domainConn=(DomainSocket)conn;
        domainConn.sendFileDescriptors(passedFds,serverMsg1,0,serverMsg1.length);
        conn.close();
      }
 catch (      Throwable e) {
        threadResults.add(e);
        Assert.fail(e.getMessage());
      }
      threadResults.add(new Success());
    }
  }
;
  serverThread.start();
  Thread clientThread=new Thread(){
    public void run(){
      try {
        DomainSocket client=DomainSocket.connect(TEST_PATH);
        OutputStream clientOutputStream=client.getOutputStream();
        InputStream clientInputStream=client.getInputStream();
        clientOutputStream.write(clientMsg1);
        DomainSocket domainConn=(DomainSocket)client;
        byte in1[]=new byte[serverMsg1.length];
        FileInputStream recvFis[]=new FileInputStream[passedFds.length];
        int r=domainConn.recvFileInputStreams(recvFis,in1,0,in1.length - 1);
        Assert.assertTrue(r > 0);
        IOUtils.readFully(clientInputStream,in1,r,in1.length - r);
        Assert.assertTrue(Arrays.equals(serverMsg1,in1));
        for (int i=0; i < passedFds.length; i++) {
          Assert.assertNotNull(recvFis[i]);
          passedFiles[i].checkInputStream(recvFis[i]);
        }
        for (        FileInputStream fis : recvFis) {
          fis.close();
        }
        client.close();
      }
 catch (      Throwable e) {
        threadResults.add(e);
      }
      threadResults.add(new Success());
    }
  }
;
  clientThread.start();
  for (int i=0; i < 2; i++) {
    Throwable t=threadResults.take();
    if (!(t instanceof Success)) {
      Assert.fail(t.getMessage() + ExceptionUtils.getStackTrace(t));
    }
  }
  serverThread.join(120000);
  clientThread.join(120000);
  serv.close();
  for (  PassedFile pf : passedFiles) {
    pf.cleanup();
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.security.TestDoAsEffectiveUser </h4><pre class="type-9 type-2 type-7 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
"></span><br>
@Test public void testRealUserIPNotSpecified() throws IOException {
  final Configuration conf=new Configuration();
  conf.setStrings(DefaultImpersonationProvider.getTestProvider().getProxySuperuserGroupConfKey(REAL_USER_SHORT_NAME),"group1");
  Server server=new RPC.Builder(conf).setProtocol(TestProtocol.class).setInstance(new TestImpl()).setBindAddress(ADDRESS).setPort(0).setNumHandlers(2).setVerbose(false).build();
  refreshConf(conf);
  try {
    server.start();
    final InetSocketAddress addr=NetUtils.getConnectAddress(server);
    UserGroupInformation realUserUgi=UserGroupInformation.createRemoteUser(REAL_USER_NAME);
    UserGroupInformation proxyUserUgi=UserGroupInformation.createProxyUserForTesting(PROXY_USER_NAME,realUserUgi,GROUP_NAMES);
    String retVal=proxyUserUgi.doAs(new PrivilegedExceptionAction<String>(){
      @Override public String run() throws IOException {
        proxy=RPC.getProxy(TestProtocol.class,TestProtocol.versionID,addr,conf);
        String ret=proxy.aMethod();
        return ret;
      }
    }
);
    Assert.fail("The RPC must have failed " + retVal);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
 finally {
    server.stop();
    if (proxy != null) {
      RPC.stopProxy(proxy);
    }
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test(timeout=4000) public void testRealUserAuthorizationSuccess() throws IOException {
  final Configuration conf=new Configuration();
  configureSuperUserIPAddresses(conf,REAL_USER_SHORT_NAME);
  conf.setStrings(DefaultImpersonationProvider.getTestProvider().getProxySuperuserGroupConfKey(REAL_USER_SHORT_NAME),"group1");
  Server server=new RPC.Builder(conf).setProtocol(TestProtocol.class).setInstance(new TestImpl()).setBindAddress(ADDRESS).setPort(0).setNumHandlers(2).setVerbose(false).build();
  refreshConf(conf);
  try {
    server.start();
    UserGroupInformation realUserUgi=UserGroupInformation.createRemoteUser(REAL_USER_NAME);
    checkRemoteUgi(server,realUserUgi,conf);
    UserGroupInformation proxyUserUgi=UserGroupInformation.createProxyUserForTesting(PROXY_USER_NAME,realUserUgi,GROUP_NAMES);
    checkRemoteUgi(server,proxyUserUgi,conf);
  }
 catch (  Exception e) {
    e.printStackTrace();
    Assert.fail();
  }
 finally {
    server.stop();
    if (proxy != null) {
      RPC.stopProxy(proxy);
    }
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test(timeout=4000) public void testRealUserSetup() throws IOException {
  final Configuration conf=new Configuration();
  conf.setStrings(DefaultImpersonationProvider.getTestProvider().getProxySuperuserGroupConfKey(REAL_USER_SHORT_NAME),"group1");
  configureSuperUserIPAddresses(conf,REAL_USER_SHORT_NAME);
  Server server=new RPC.Builder(conf).setProtocol(TestProtocol.class).setInstance(new TestImpl()).setBindAddress(ADDRESS).setPort(0).setNumHandlers(5).setVerbose(true).build();
  refreshConf(conf);
  try {
    server.start();
    UserGroupInformation realUserUgi=UserGroupInformation.createRemoteUser(REAL_USER_NAME);
    checkRemoteUgi(server,realUserUgi,conf);
    UserGroupInformation proxyUserUgi=UserGroupInformation.createProxyUserForTesting(PROXY_USER_NAME,realUserUgi,GROUP_NAMES);
    checkRemoteUgi(server,proxyUserUgi,conf);
  }
 catch (  Exception e) {
    e.printStackTrace();
    Assert.fail();
  }
 finally {
    server.stop();
    if (proxy != null) {
      RPC.stopProxy(proxy);
    }
  }
}

</code></pre>

<br>
<pre class="type-9 type-2 type-7 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
"></span><br>
@Test public void testRealUserIPAuthorizationFailure() throws IOException {
  final Configuration conf=new Configuration();
  conf.setStrings(DefaultImpersonationProvider.getTestProvider().getProxySuperuserIpConfKey(REAL_USER_SHORT_NAME),"20.20.20.20");
  conf.setStrings(DefaultImpersonationProvider.getTestProvider().getProxySuperuserGroupConfKey(REAL_USER_SHORT_NAME),"group1");
  Server server=new RPC.Builder(conf).setProtocol(TestProtocol.class).setInstance(new TestImpl()).setBindAddress(ADDRESS).setPort(0).setNumHandlers(2).setVerbose(false).build();
  refreshConf(conf);
  try {
    server.start();
    final InetSocketAddress addr=NetUtils.getConnectAddress(server);
    UserGroupInformation realUserUgi=UserGroupInformation.createRemoteUser(REAL_USER_NAME);
    UserGroupInformation proxyUserUgi=UserGroupInformation.createProxyUserForTesting(PROXY_USER_NAME,realUserUgi,GROUP_NAMES);
    String retVal=proxyUserUgi.doAs(new PrivilegedExceptionAction<String>(){
      @Override public String run() throws IOException {
        proxy=RPC.getProxy(TestProtocol.class,TestProtocol.versionID,addr,conf);
        String ret=proxy.aMethod();
        return ret;
      }
    }
);
    Assert.fail("The RPC must have failed " + retVal);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
 finally {
    server.stop();
    if (proxy != null) {
      RPC.stopProxy(proxy);
    }
  }
}

</code></pre>

<br>
<pre class="type-9 type-2 type-7 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
"></span><br>
@Test public void testRealUserGroupAuthorizationFailure() throws IOException {
  final Configuration conf=new Configuration();
  configureSuperUserIPAddresses(conf,REAL_USER_SHORT_NAME);
  conf.setStrings(DefaultImpersonationProvider.getTestProvider().getProxySuperuserGroupConfKey(REAL_USER_SHORT_NAME),"group3");
  Server server=new RPC.Builder(conf).setProtocol(TestProtocol.class).setInstance(new TestImpl()).setBindAddress(ADDRESS).setPort(0).setNumHandlers(2).setVerbose(false).build();
  refreshConf(conf);
  try {
    server.start();
    final InetSocketAddress addr=NetUtils.getConnectAddress(server);
    UserGroupInformation realUserUgi=UserGroupInformation.createRemoteUser(REAL_USER_NAME);
    UserGroupInformation proxyUserUgi=UserGroupInformation.createProxyUserForTesting(PROXY_USER_NAME,realUserUgi,GROUP_NAMES);
    String retVal=proxyUserUgi.doAs(new PrivilegedExceptionAction<String>(){
      @Override public String run() throws IOException {
        proxy=RPC.getProxy(TestProtocol.class,TestProtocol.versionID,addr,conf);
        String ret=proxy.aMethod();
        return ret;
      }
    }
);
    Assert.fail("The RPC must have failed " + retVal);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
 finally {
    server.stop();
    if (proxy != null) {
      RPC.stopProxy(proxy);
    }
  }
}

</code></pre>

<br>
<pre class="type-9 type-2 type-7 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
"></span><br>
@Test public void testRealUserGroupNotSpecified() throws IOException {
  final Configuration conf=new Configuration();
  configureSuperUserIPAddresses(conf,REAL_USER_SHORT_NAME);
  Server server=new RPC.Builder(conf).setProtocol(TestProtocol.class).setInstance(new TestImpl()).setBindAddress(ADDRESS).setPort(0).setNumHandlers(2).setVerbose(false).build();
  try {
    server.start();
    final InetSocketAddress addr=NetUtils.getConnectAddress(server);
    UserGroupInformation realUserUgi=UserGroupInformation.createRemoteUser(REAL_USER_NAME);
    UserGroupInformation proxyUserUgi=UserGroupInformation.createProxyUserForTesting(PROXY_USER_NAME,realUserUgi,GROUP_NAMES);
    String retVal=proxyUserUgi.doAs(new PrivilegedExceptionAction<String>(){
      @Override public String run() throws IOException {
        proxy=(TestProtocol)RPC.getProxy(TestProtocol.class,TestProtocol.versionID,addr,conf);
        String ret=proxy.aMethod();
        return ret;
      }
    }
);
    Assert.fail("The RPC must have failed " + retVal);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
 finally {
    server.stop();
    if (proxy != null) {
      RPC.stopProxy(proxy);
    }
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.security.TestGroupsCaching </h4><pre class="type-11 type-2 type-7 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testGroupsCaching() throws Exception {
  conf.setLong(CommonConfigurationKeys.HADOOP_SECURITY_GROUPS_NEGATIVE_CACHE_SECS,0);
  Groups groups=new Groups(conf);
  groups.cacheGroupsAdd(Arrays.asList(myGroups));
  groups.refresh();
  FakeGroupMapping.clearBlackList();
  FakeGroupMapping.addToBlackList("user1");
  assertTrue(groups.getGroups("me").size() == 2);
  FakeGroupMapping.addToBlackList("me");
  assertTrue(groups.getGroups("me").size() == 2);
  try {
    LOG.error("We are not supposed to get here." + groups.getGroups("user1").toString());
    fail();
  }
 catch (  IOException ioe) {
    if (!ioe.getMessage().startsWith("No groups found")) {
      LOG.error("Got unexpected exception: " + ioe.getMessage());
      fail();
    }
  }
  FakeGroupMapping.clearBlackList();
  assertTrue(groups.getGroups("user1").size() == 2);
}

</code></pre>

<br>
<pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testNegativeGroupCaching() throws Exception {
  final String user="negcache";
  final String failMessage="Did not throw IOException: ";
  conf.setLong(CommonConfigurationKeys.HADOOP_SECURITY_GROUPS_NEGATIVE_CACHE_SECS,2);
  FakeTimer timer=new FakeTimer();
  Groups groups=new Groups(conf,timer);
  groups.cacheGroupsAdd(Arrays.asList(myGroups));
  groups.refresh();
  FakeGroupMapping.addToBlackList(user);
  try {
    groups.getGroups(user);
    fail(failMessage + "Failed to obtain groups from FakeGroupMapping.");
  }
 catch (  IOException e) {
    GenericTestUtils.assertExceptionContains("No groups found for user",e);
  }
  try {
    groups.getGroups(user);
    fail(failMessage + "The user is in the negative cache.");
  }
 catch (  IOException e) {
    GenericTestUtils.assertExceptionContains("No groups found for user",e);
  }
  FakeGroupMapping.clearBlackList();
  try {
    groups.getGroups(user);
    fail(failMessage + "The user is still in the negative cache, even " + "FakeGroupMapping has resumed.");
  }
 catch (  IOException e) {
    GenericTestUtils.assertExceptionContains("No groups found for user",e);
  }
  timer.advance(4 * 1000);
  assertEquals(Arrays.asList(myGroups),groups.getGroups(user));
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.security.TestPermissionSymlinks </h4><pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testAccess() throws Exception {
  fs.setPermission(target,new FsPermission((short)0002));
  fs.setAcl(target,Arrays.asList(aclEntry(ACCESS,USER,ALL),aclEntry(ACCESS,GROUP,NONE),aclEntry(ACCESS,USER,user.getShortUserName(),WRITE),aclEntry(ACCESS,OTHER,WRITE)));
  FileContext myfc=user.doAs(new PrivilegedExceptionAction<FileContext>(){
    @Override public FileContext run() throws IOException {
      return FileContext.getFileContext(conf);
    }
  }
);
  myfc.access(link,FsAction.WRITE);
  try {
    myfc.access(link,FsAction.ALL);
    fail("The access call should have failed.");
  }
 catch (  AccessControlException e) {
  }
  Path badPath=new Path(link,"bad");
  try {
    myfc.access(badPath,FsAction.READ);
    fail("The access call should have failed");
  }
 catch (  FileNotFoundException e) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.security.TestRefreshUserMappings </h4><pre class="type-2 type-7 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
"></span><br>
@Test public void testRefreshSuperUserGroupsConfiguration() throws Exception {
  final String SUPER_USER="super_user";
  final String[] GROUP_NAMES1=new String[]{"gr1","gr2"};
  final String[] GROUP_NAMES2=new String[]{"gr3","gr4"};
  String userKeyGroups=DefaultImpersonationProvider.getTestProvider().getProxySuperuserGroupConfKey(SUPER_USER);
  String userKeyHosts=DefaultImpersonationProvider.getTestProvider().getProxySuperuserIpConfKey(SUPER_USER);
  config.set(userKeyGroups,"gr3,gr4,gr5");
  config.set(userKeyHosts,"127.0.0.1");
  ProxyUsers.refreshSuperUserGroupsConfiguration(config);
  UserGroupInformation ugi1=mock(UserGroupInformation.class);
  UserGroupInformation ugi2=mock(UserGroupInformation.class);
  UserGroupInformation suUgi=mock(UserGroupInformation.class);
  when(ugi1.getRealUser()).thenReturn(suUgi);
  when(ugi2.getRealUser()).thenReturn(suUgi);
  when(suUgi.getShortUserName()).thenReturn(SUPER_USER);
  when(suUgi.getUserName()).thenReturn(SUPER_USER + "L");
  when(ugi1.getShortUserName()).thenReturn("user1");
  when(ugi2.getShortUserName()).thenReturn("user2");
  when(ugi1.getUserName()).thenReturn("userL1");
  when(ugi2.getUserName()).thenReturn("userL2");
  when(ugi1.getGroupNames()).thenReturn(GROUP_NAMES1);
  when(ugi2.getGroupNames()).thenReturn(GROUP_NAMES2);
  try {
    ProxyUsers.authorize(ugi1,"127.0.0.1");
    fail("first auth for " + ugi1.getShortUserName() + " should've failed ");
  }
 catch (  AuthorizationException e) {
    System.err.println("auth for " + ugi1.getUserName() + " failed");
  }
  try {
    ProxyUsers.authorize(ugi2,"127.0.0.1");
    System.err.println("auth for " + ugi2.getUserName() + " succeeded");
  }
 catch (  AuthorizationException e) {
    fail("first auth for " + ugi2.getShortUserName() + " should've succeeded: "+ e.getLocalizedMessage());
  }
  String rsrc="testGroupMappingRefresh_rsrc.xml";
  addNewConfigResource(rsrc,userKeyGroups,"gr2",userKeyHosts,"127.0.0.1");
  DFSAdmin admin=new DFSAdmin(config);
  String[] args=new String[]{"-refreshSuperUserGroupsConfiguration"};
  admin.run(args);
  try {
    ProxyUsers.authorize(ugi2,"127.0.0.1");
    fail("second auth for " + ugi2.getShortUserName() + " should've failed ");
  }
 catch (  AuthorizationException e) {
    System.err.println("auth for " + ugi2.getUserName() + " failed");
  }
  try {
    ProxyUsers.authorize(ugi1,"127.0.0.1");
    System.err.println("auth for " + ugi1.getUserName() + " succeeded");
  }
 catch (  AuthorizationException e) {
    fail("second auth for " + ugi1.getShortUserName() + " should've succeeded: "+ e.getLocalizedMessage());
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.security.TestUGIWithExternalKdc </h4><pre class="type-9 type-2 type-1 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects are null
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testLogin() throws IOException {
  String userPrincipal=System.getProperty("user.principal");
  String userKeyTab=System.getProperty("user.keytab");
  Assert.assertNotNull("User principal was not specified",userPrincipal);
  Assert.assertNotNull("User keytab was not specified",userKeyTab);
  Configuration conf=new Configuration();
  conf.set(CommonConfigurationKeys.HADOOP_SECURITY_AUTHENTICATION,"kerberos");
  UserGroupInformation.setConfiguration(conf);
  UserGroupInformation ugi=UserGroupInformation.loginUserFromKeytabAndReturnUGI(userPrincipal,userKeyTab);
  Assert.assertEquals(AuthenticationMethod.KERBEROS,ugi.getAuthenticationMethod());
  try {
    UserGroupInformation.loginUserFromKeytabAndReturnUGI("bogus@EXAMPLE.COM",userKeyTab);
    Assert.fail("Login should have failed");
  }
 catch (  Exception ex) {
    ex.printStackTrace();
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.security.TestUGIWithSecurityOn </h4><pre class="type-9 type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testLogin() throws IOException {
  String nn1keyTabFilepath=System.getProperty("kdc.resource.dir") + "/keytabs/nn1.keytab";
  String user1keyTabFilepath=System.getProperty("kdc.resource.dir") + "/keytabs/user1.keytab";
  Configuration conf=new Configuration();
  SecurityUtil.setAuthenticationMethod(AuthenticationMethod.KERBEROS,conf);
  UserGroupInformation.setConfiguration(conf);
  UserGroupInformation ugiNn=UserGroupInformation.loginUserFromKeytabAndReturnUGI("nn1/localhost@EXAMPLE.COM",nn1keyTabFilepath);
  UserGroupInformation ugiDn=UserGroupInformation.loginUserFromKeytabAndReturnUGI("user1@EXAMPLE.COM",user1keyTabFilepath);
  Assert.assertEquals(AuthenticationMethod.KERBEROS,ugiNn.getAuthenticationMethod());
  Assert.assertEquals(AuthenticationMethod.KERBEROS,ugiDn.getAuthenticationMethod());
  try {
    UserGroupInformation.loginUserFromKeytabAndReturnUGI("bogus@EXAMPLE.COM",nn1keyTabFilepath);
    Assert.fail("Login should have failed");
  }
 catch (  Exception ex) {
    ex.printStackTrace();
  }
}

</code></pre>

<br>
<pre class="type-11 type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testGetUGIFromKerberosSubject() throws IOException {
  String user1keyTabFilepath=System.getProperty("kdc.resource.dir") + "/keytabs/user1.keytab";
  UserGroupInformation ugi=UserGroupInformation.loginUserFromKeytabAndReturnUGI("user1@EXAMPLE.COM",user1keyTabFilepath);
  Set<KerberosPrincipal> principals=ugi.getSubject().getPrincipals(KerberosPrincipal.class);
  if (principals.isEmpty()) {
    Assert.fail("There should be a kerberos principal in the subject.");
  }
 else {
    UserGroupInformation ugi2=UserGroupInformation.getUGIFromSubject(ugi.getSubject());
    if (ugi2 != null) {
      ugi2.doAs(new PrivilegedAction(){
        @Override public Object run(){
          try {
            UserGroupInformation ugi3=UserGroupInformation.getCurrentUser();
            String doAsUserName=ugi3.getUserName();
            assertEquals(doAsUserName,"user1@EXAMPLE.COM");
            System.out.println("DO AS USERNAME: " + doAsUserName);
          }
 catch (          IOException e) {
            e.printStackTrace();
          }
          return null;
        }
      }
);
    }
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.security.TestUserGroupInformation </h4><pre class="type-2 type-7 type-10 type-19 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether two objects/variables are the same">IdentityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether two objects/variables are the same
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@SuppressWarnings("unchecked") @Test(timeout=30000) public <T extends TokenIdentifier>void testUGITokens() throws Exception {
  UserGroupInformation ugi=UserGroupInformation.createUserForTesting("TheDoctor",new String[]{"TheTARDIS"});
  Token<T> t1=mock(Token.class);
  when(t1.getService()).thenReturn(new Text("t1"));
  Token<T> t2=mock(Token.class);
  when(t2.getService()).thenReturn(new Text("t2"));
  Credentials creds=new Credentials();
  byte[] secretKey=new byte[]{};
  Text secretName=new Text("shhh");
  creds.addSecretKey(secretName,secretKey);
  ugi.addToken(t1);
  ugi.addToken(t2);
  ugi.addCredentials(creds);
  Collection<Token<? extends TokenIdentifier>> z=ugi.getTokens();
  assertTrue(z.contains(t1));
  assertTrue(z.contains(t2));
  assertEquals(2,z.size());
  Credentials ugiCreds=ugi.getCredentials();
  assertSame(secretKey,ugiCreds.getSecretKey(secretName));
  assertEquals(1,ugiCreds.numberOfSecretKeys());
  try {
    z.remove(t1);
    fail("Shouldn't be able to modify token collection from UGI");
  }
 catch (  UnsupportedOperationException uoe) {
  }
  Collection<Token<? extends TokenIdentifier>> otherSet=ugi.doAs(new PrivilegedExceptionAction<Collection<Token<?>>>(){
    @Override public Collection<Token<?>> run() throws IOException {
      return UserGroupInformation.getCurrentUser().getTokens();
    }
  }
);
  assertTrue(otherSet.contains(t1));
  assertTrue(otherSet.contains(t2));
}

</code></pre>

<br>
<pre class="type-13 type-2 type-7 type-1 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * This test checks a race condition between getting and adding tokens for
 * the current user.  Calling UserGroupInformation.getCurrentUser() returns
 * a new object each time, so simply making these methods synchronized was not
 * enough to prevent race conditions and causing a
 * ConcurrentModificationException.  These methods are synchronized on the
 * Subject, which is the same object between UserGroupInformation instances.
 * This test tries to cause a CME, by exposing the race condition.  Previously
 * this test would fail every time; now it does not.
 */
@Test public void testTokenRaceCondition() throws Exception {
  UserGroupInformation userGroupInfo=UserGroupInformation.createUserForTesting(USER_NAME,GROUP_NAMES);
  userGroupInfo.doAs(new PrivilegedExceptionAction<Void>(){
    @Override public Void run() throws Exception {
      assertNotEquals(UserGroupInformation.getLoginUser(),UserGroupInformation.getCurrentUser());
      GetTokenThread thread=new GetTokenThread();
      try {
        thread.start();
        for (int i=0; i < 100; i++) {
          @SuppressWarnings("unchecked") Token<? extends TokenIdentifier> t=mock(Token.class);
          when(t.getService()).thenReturn(new Text("t" + i));
          UserGroupInformation.getCurrentUser().addToken(t);
          assertNull("ConcurrentModificationException encountered",thread.cme);
        }
      }
 catch (      ConcurrentModificationException cme) {
        cme.printStackTrace();
        fail("ConcurrentModificationException encountered");
      }
 finally {
        thread.runThread=false;
        thread.join(5 * 1000);
      }
      return null;
    }
  }
);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.security.authentication.client.TestAuthenticatedURL </h4><pre class="type-2 type-7 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testExtractTokenFail() throws Exception {
  HttpURLConnection conn=Mockito.mock(HttpURLConnection.class);
  Mockito.when(conn.getResponseCode()).thenReturn(HttpURLConnection.HTTP_UNAUTHORIZED);
  String tokenStr="foo";
  Map<String,List<String>> headers=new HashMap<String,List<String>>();
  List<String> cookies=new ArrayList<String>();
  cookies.add(AuthenticatedURL.AUTH_COOKIE + "=" + tokenStr);
  headers.put("Set-Cookie",cookies);
  Mockito.when(conn.getHeaderFields()).thenReturn(headers);
  AuthenticatedURL.Token token=new AuthenticatedURL.Token();
  token.set("bar");
  try {
    AuthenticatedURL.extractToken(conn,token);
    Assert.fail();
  }
 catch (  AuthenticationException ex) {
    Assert.assertFalse(token.isSet());
  }
catch (  Exception ex) {
    Assert.fail();
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.security.authentication.server.TestAuthenticationFilter </h4><pre class="type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testInitEmpty() throws Exception {
  AuthenticationFilter filter=new AuthenticationFilter();
  try {
    FilterConfig config=Mockito.mock(FilterConfig.class);
    Mockito.when(config.getInitParameterNames()).thenReturn(new Vector<String>().elements());
    filter.init(config);
    Assert.fail();
  }
 catch (  ServletException ex) {
    Assert.assertEquals("Authentication type must be specified: simple|kerberos|<class>",ex.getMessage());
  }
catch (  Exception ex) {
    Assert.fail();
  }
 finally {
    filter.destroy();
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testDoFilterNotAuthenticated() throws Exception {
  AuthenticationFilter filter=new AuthenticationFilter();
  try {
    FilterConfig config=Mockito.mock(FilterConfig.class);
    Mockito.when(config.getInitParameter("management.operation.return")).thenReturn("true");
    Mockito.when(config.getInitParameter(AuthenticationFilter.AUTH_TYPE)).thenReturn(DummyAuthenticationHandler.class.getName());
    Mockito.when(config.getInitParameterNames()).thenReturn(new Vector<String>(Arrays.asList(AuthenticationFilter.AUTH_TYPE,"management.operation.return")).elements());
    ServletContext context=Mockito.mock(ServletContext.class);
    Mockito.when(context.getAttribute(AuthenticationFilter.SIGNATURE_PROVIDER_ATTRIBUTE)).thenReturn(null);
    Mockito.when(config.getServletContext()).thenReturn(context);
    filter.init(config);
    HttpServletRequest request=Mockito.mock(HttpServletRequest.class);
    Mockito.when(request.getRequestURL()).thenReturn(new StringBuffer("http://foo:8080/bar"));
    HttpServletResponse response=Mockito.mock(HttpServletResponse.class);
    FilterChain chain=Mockito.mock(FilterChain.class);
    Mockito.doAnswer(new Answer(){
      @Override public Object answer(      InvocationOnMock invocation) throws Throwable {
        Assert.fail();
        return null;
      }
    }
).when(chain).doFilter(Mockito.<ServletRequest>anyObject(),Mockito.<ServletResponse>anyObject());
    filter.doFilter(request,response,chain);
    Mockito.verify(response).sendError(HttpServletResponse.SC_UNAUTHORIZED,"Authentication required");
    Mockito.verify(response).setHeader("WWW-Authenticate","dummyauth");
  }
  finally {
    filter.destroy();
  }
}

</code></pre>

<br>
<pre class="type-9 type-2 type-1 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects are null
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testDoFilterAuthenticationFailure() throws Exception {
  AuthenticationFilter filter=new AuthenticationFilter();
  try {
    FilterConfig config=Mockito.mock(FilterConfig.class);
    Mockito.when(config.getInitParameter("management.operation.return")).thenReturn("true");
    Mockito.when(config.getInitParameter(AuthenticationFilter.AUTH_TYPE)).thenReturn(DummyAuthenticationHandler.class.getName());
    Mockito.when(config.getInitParameterNames()).thenReturn(new Vector<String>(Arrays.asList(AuthenticationFilter.AUTH_TYPE,"management.operation.return")).elements());
    ServletContext context=Mockito.mock(ServletContext.class);
    Mockito.when(context.getAttribute(AuthenticationFilter.SIGNATURE_PROVIDER_ATTRIBUTE)).thenReturn(null);
    Mockito.when(config.getServletContext()).thenReturn(context);
    filter.init(config);
    HttpServletRequest request=Mockito.mock(HttpServletRequest.class);
    Mockito.when(request.getRequestURL()).thenReturn(new StringBuffer("http://foo:8080/bar"));
    Mockito.when(request.getCookies()).thenReturn(new Cookie[]{});
    Mockito.when(request.getHeader("WWW-Authenticate")).thenReturn("dummyauth");
    HttpServletResponse response=Mockito.mock(HttpServletResponse.class);
    FilterChain chain=Mockito.mock(FilterChain.class);
    final HashMap<String,String> cookieMap=new HashMap<String,String>();
    Mockito.doAnswer(new Answer(){
      @Override public Object answer(      InvocationOnMock invocation) throws Throwable {
        Object[] args=invocation.getArguments();
        parseCookieMap((String)args[1],cookieMap);
        return null;
      }
    }
).when(response).addHeader(Mockito.eq("Set-Cookie"),Mockito.anyString());
    Mockito.doAnswer(new Answer(){
      @Override public Object answer(      InvocationOnMock invocation) throws Throwable {
        Assert.fail("shouldn't get here");
        return null;
      }
    }
).when(chain).doFilter(Mockito.<ServletRequest>anyObject(),Mockito.<ServletResponse>anyObject());
    filter.doFilter(request,response,chain);
    Mockito.verify(response).sendError(HttpServletResponse.SC_FORBIDDEN,"AUTH FAILED");
    Mockito.verify(response,Mockito.never()).setHeader(Mockito.eq("WWW-Authenticate"),Mockito.anyString());
    String value=cookieMap.get(AuthenticatedURL.AUTH_COOKIE);
    Assert.assertNotNull("cookie missing",value);
    Assert.assertEquals("",value);
  }
  finally {
    filter.destroy();
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.security.authentication.server.TestAuthenticationToken </h4><pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testConstructor() throws Exception {
  try {
    new AuthenticationToken(null,"p","t");
    Assert.fail();
  }
 catch (  IllegalArgumentException ex) {
  }
catch (  Throwable ex) {
    Assert.fail();
  }
  try {
    new AuthenticationToken("","p","t");
    Assert.fail();
  }
 catch (  IllegalArgumentException ex) {
  }
catch (  Throwable ex) {
    Assert.fail();
  }
  try {
    new AuthenticationToken("u",null,"t");
    Assert.fail();
  }
 catch (  IllegalArgumentException ex) {
  }
catch (  Throwable ex) {
    Assert.fail();
  }
  try {
    new AuthenticationToken("u","","t");
    Assert.fail();
  }
 catch (  IllegalArgumentException ex) {
  }
catch (  Throwable ex) {
    Assert.fail();
  }
  try {
    new AuthenticationToken("u","p",null);
    Assert.fail();
  }
 catch (  IllegalArgumentException ex) {
  }
catch (  Throwable ex) {
    Assert.fail();
  }
  try {
    new AuthenticationToken("u","p","");
    Assert.fail();
  }
 catch (  IllegalArgumentException ex) {
  }
catch (  Throwable ex) {
    Assert.fail();
  }
  new AuthenticationToken("u","p","t");
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testParseInvalid() throws Exception {
  long expires=System.currentTimeMillis() + 50;
  AuthenticationToken token=new AuthenticationToken("u","p","t");
  token.setExpires(expires);
  String str=token.toString();
  str=str.substring(0,str.indexOf("e="));
  try {
    AuthenticationToken.parse(str);
    Assert.fail();
  }
 catch (  AuthenticationException ex) {
  }
catch (  Exception ex) {
    Assert.fail();
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.security.authentication.server.TestKerberosAuthenticationHandler </h4><pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test(timeout=60000) public void testRequestWithIncompleteAuthorization() throws Exception {
  HttpServletRequest request=Mockito.mock(HttpServletRequest.class);
  HttpServletResponse response=Mockito.mock(HttpServletResponse.class);
  Mockito.when(request.getHeader(KerberosAuthenticator.AUTHORIZATION)).thenReturn(KerberosAuthenticator.NEGOTIATE);
  try {
    handler.authenticate(request,response);
    Assert.fail();
  }
 catch (  AuthenticationException ex) {
  }
catch (  Exception ex) {
    Assert.fail();
  }
}

</code></pre>

<br>
<pre class="type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testNameRules() throws Exception {
  KerberosName kn=new KerberosName(KerberosTestUtils.getServerPrincipal());
  Assert.assertEquals(KerberosTestUtils.getRealm(),kn.getRealm());
  handler.destroy();
  KerberosName.setRules("RULE:[1:$1@$0](.*@FOO)s/@.*//\nDEFAULT");
  handler=getNewAuthenticationHandler();
  Properties props=getDefaultProperties();
  props.setProperty(KerberosAuthenticationHandler.NAME_RULES,"RULE:[1:$1@$0](.*@BAR)s/@.*//\nDEFAULT");
  try {
    handler.init(props);
  }
 catch (  Exception ex) {
  }
  kn=new KerberosName("bar@BAR");
  Assert.assertEquals("bar",kn.getShortName());
  kn=new KerberosName("bar@FOO");
  try {
    kn.getShortName();
    Assert.fail();
  }
 catch (  Exception ex) {
  }
}

</code></pre>

<br>
<pre class="type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testDynamicPrincipalDiscoveryMissingPrincipals() throws Exception {
  String[] keytabUsers=new String[]{"hdfs/localhost"};
  String keytab=KerberosTestUtils.getKeytabFile();
  getKdc().createPrincipal(new File(keytab),keytabUsers);
  handler.destroy();
  Properties props=new Properties();
  props.setProperty(KerberosAuthenticationHandler.KEYTAB,keytab);
  props.setProperty(KerberosAuthenticationHandler.PRINCIPAL,"*");
  handler=getNewAuthenticationHandler();
  try {
    handler.init(props);
    Assert.fail("init should have failed");
  }
 catch (  ServletException ex) {
    Assert.assertEquals("Principals do not exist in the keytab",ex.getCause().getMessage());
  }
catch (  Throwable t) {
    Assert.fail("wrong exception: " + t);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.security.authentication.server.TestPseudoAuthenticationHandler </h4><pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testAnonymousOff() throws Exception {
  PseudoAuthenticationHandler handler=new PseudoAuthenticationHandler();
  try {
    Properties props=new Properties();
    props.setProperty(PseudoAuthenticationHandler.ANONYMOUS_ALLOWED,"false");
    handler.init(props);
    HttpServletRequest request=Mockito.mock(HttpServletRequest.class);
    HttpServletResponse response=Mockito.mock(HttpServletResponse.class);
    handler.authenticate(request,response);
    Assert.fail();
  }
 catch (  AuthenticationException ex) {
  }
catch (  Exception ex) {
    Assert.fail();
  }
 finally {
    handler.destroy();
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.security.authentication.util.TestKerberosUtil </h4><pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testGetPrincipalNamesMissingKeytab(){
  try {
    KerberosUtil.getPrincipalNames(testKeytab);
    Assert.fail("Exception should have been thrown");
  }
 catch (  IOException e) {
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testGetPrincipalNamesMissingPattern() throws IOException {
  createKeyTab(testKeytab,new String[]{"test/testhost@testRealm"});
  try {
    KerberosUtil.getPrincipalNames(testKeytab,null);
    Assert.fail("Exception should have been thrown");
  }
 catch (  Exception e) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.security.authentication.util.TestSigner </h4><pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testInvalidSignedText() throws Exception {
  Signer signer=new Signer(new StringSignerSecretProvider("secret"));
  try {
    signer.verifyAndExtract("test");
    Assert.fail();
  }
 catch (  SignerException ex) {
  }
catch (  Throwable ex) {
    Assert.fail();
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testNullAndEmptyString() throws Exception {
  Signer signer=new Signer(new StringSignerSecretProvider("secret"));
  try {
    signer.sign(null);
    Assert.fail();
  }
 catch (  IllegalArgumentException ex) {
  }
catch (  Throwable ex) {
    Assert.fail();
  }
  try {
    signer.sign("");
    Assert.fail();
  }
 catch (  IllegalArgumentException ex) {
  }
catch (  Throwable ex) {
    Assert.fail();
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testTampering() throws Exception {
  Signer signer=new Signer(new StringSignerSecretProvider("secret"));
  String t="test";
  String s=signer.sign(t);
  s+="x";
  try {
    signer.verifyAndExtract(s);
    Assert.fail();
  }
 catch (  SignerException ex) {
  }
catch (  Throwable ex) {
    Assert.fail();
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testMultipleSecrets() throws Exception {
  TestSignerSecretProvider secretProvider=new TestSignerSecretProvider();
  Signer signer=new Signer(secretProvider);
  secretProvider.setCurrentSecret("secretB");
  String t1="test";
  String s1=signer.sign(t1);
  String e1=signer.verifyAndExtract(s1);
  Assert.assertEquals(t1,e1);
  secretProvider.setPreviousSecret("secretA");
  String t2="test";
  String s2=signer.sign(t2);
  String e2=signer.verifyAndExtract(s2);
  Assert.assertEquals(t2,e2);
  Assert.assertEquals(s1,s2);
  secretProvider.setCurrentSecret("secretC");
  secretProvider.setPreviousSecret("secretB");
  String t3="test";
  String s3=signer.sign(t3);
  String e3=signer.verifyAndExtract(s3);
  Assert.assertEquals(t3,e3);
  Assert.assertNotEquals(s1,s3);
  String e1b=signer.verifyAndExtract(s1);
  Assert.assertEquals(t1,e1b);
  secretProvider.setCurrentSecret("secretD");
  secretProvider.setPreviousSecret("secretC");
  try {
    signer.verifyAndExtract(s1);
    Assert.fail();
  }
 catch (  SignerException ex) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.security.authorize.TestServiceAuthorization </h4><pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testDefaultBlockedAcl() throws UnknownHostException {
  UserGroupInformation drwho=UserGroupInformation.createUserForTesting("drwho@EXAMPLE.COM",new String[]{"group1","group2"});
  ServiceAuthorizationManager serviceAuthorizationManager=new ServiceAuthorizationManager();
  Configuration conf=new Configuration();
  serviceAuthorizationManager.refresh(conf,new TestPolicyProvider());
  try {
    serviceAuthorizationManager.authorize(drwho,TestProtocol1.class,conf,InetAddress.getByName(ADDRESS));
  }
 catch (  AuthorizationException e) {
    fail();
  }
  conf.set(CommonConfigurationKeys.HADOOP_SECURITY_SERVICE_AUTHORIZATION_DEFAULT_BLOCKED_ACL,"user2 group2");
  conf.set(ACL_CONFIG + ServiceAuthorizationManager.BLOCKED,"user2");
  serviceAuthorizationManager.refresh(conf,new TestPolicyProvider());
  try {
    serviceAuthorizationManager.authorize(drwho,TestProtocol.class,conf,InetAddress.getByName(ADDRESS));
  }
 catch (  AuthorizationException e) {
    fail();
  }
  try {
    serviceAuthorizationManager.authorize(drwho,TestProtocol1.class,conf,InetAddress.getByName(ADDRESS));
    fail();
  }
 catch (  AuthorizationException e) {
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testBlockedAcl() throws UnknownHostException {
  UserGroupInformation drwho=UserGroupInformation.createUserForTesting("drwho@EXAMPLE.COM",new String[]{"group1","group2"});
  ServiceAuthorizationManager serviceAuthorizationManager=new ServiceAuthorizationManager();
  Configuration conf=new Configuration();
  conf.set(ACL_CONFIG,"user1 group1");
  serviceAuthorizationManager.refresh(conf,new TestPolicyProvider());
  try {
    serviceAuthorizationManager.authorize(drwho,TestProtocol.class,conf,InetAddress.getByName(ADDRESS));
  }
 catch (  AuthorizationException e) {
    fail();
  }
  conf.set(ACL_CONFIG + ServiceAuthorizationManager.BLOCKED,"drwho2 group3");
  serviceAuthorizationManager.refresh(conf,new TestPolicyProvider());
  try {
    serviceAuthorizationManager.authorize(drwho,TestProtocol.class,conf,InetAddress.getByName(ADDRESS));
  }
 catch (  AuthorizationException e) {
    fail();
  }
  conf.set(ACL_CONFIG + ServiceAuthorizationManager.BLOCKED,"drwho group3");
  serviceAuthorizationManager.refresh(conf,new TestPolicyProvider());
  try {
    serviceAuthorizationManager.authorize(drwho,TestProtocol.class,conf,InetAddress.getByName(ADDRESS));
    fail();
  }
 catch (  AuthorizationException e) {
  }
  conf.set(ACL_CONFIG + ServiceAuthorizationManager.BLOCKED,"drwho2 group3");
  serviceAuthorizationManager.refresh(conf,new TestPolicyProvider());
  try {
    serviceAuthorizationManager.authorize(drwho,TestProtocol.class,conf,InetAddress.getByName(ADDRESS));
  }
 catch (  AuthorizationException e) {
    fail();
  }
  conf.set(ACL_CONFIG + ServiceAuthorizationManager.BLOCKED,"drwho2 group2");
  serviceAuthorizationManager.refresh(conf,new TestPolicyProvider());
  try {
    serviceAuthorizationManager.authorize(drwho,TestProtocol.class,conf,InetAddress.getByName(ADDRESS));
    fail();
  }
 catch (  AuthorizationException e) {
  }
  conf.set(ACL_CONFIG + ServiceAuthorizationManager.BLOCKED,"");
  serviceAuthorizationManager.refresh(conf,new TestPolicyProvider());
  try {
    serviceAuthorizationManager.authorize(drwho,TestProtocol.class,conf,InetAddress.getByName(ADDRESS));
  }
 catch (  AuthorizationException e) {
    fail();
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.security.token.delegation.TestDelegationToken </h4><pre class="type-9 type-2 type-7 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testDelegationTokenSecretManager() throws Exception {
  final TestDelegationTokenSecretManager dtSecretManager=new TestDelegationTokenSecretManager(24 * 60 * 60* 1000,3 * 1000,1 * 1000,3600000);
  try {
    dtSecretManager.startThreads();
    final Token<TestDelegationTokenIdentifier> token=generateDelegationToken(dtSecretManager,"SomeUser","JobTracker");
    Assert.assertTrue(dtSecretManager.isStoreNewTokenCalled);
    shouldThrow(new PrivilegedExceptionAction(){
      @Override public Object run() throws Exception {
        dtSecretManager.renewToken(token,"FakeRenewer");
        return null;
      }
    }
,AccessControlException.class);
    long time=dtSecretManager.renewToken(token,"JobTracker");
    Assert.assertTrue(dtSecretManager.isUpdateStoredTokenCalled);
    assertTrue("renew time is in future",time > Time.now());
    TestDelegationTokenIdentifier identifier=new TestDelegationTokenIdentifier();
    byte[] tokenId=token.getIdentifier();
    identifier.readFields(new DataInputStream(new ByteArrayInputStream(tokenId)));
    Assert.assertTrue(null != dtSecretManager.retrievePassword(identifier));
    LOG.info("Sleep to expire the token");
    Thread.sleep(2000);
    try {
      dtSecretManager.retrievePassword(identifier);
      Assert.fail("Token should have expired");
    }
 catch (    InvalidToken e) {
    }
    dtSecretManager.renewToken(token,"JobTracker");
    LOG.info("Sleep beyond the max lifetime");
    Thread.sleep(2000);
    shouldThrow(new PrivilegedExceptionAction(){
      @Override public Object run() throws Exception {
        dtSecretManager.renewToken(token,"JobTracker");
        return null;
      }
    }
,InvalidToken.class);
  }
  finally {
    dtSecretManager.stopThreads();
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testDelegationTokenNullRenewer() throws Exception {
  TestDelegationTokenSecretManager dtSecretManager=new TestDelegationTokenSecretManager(24 * 60 * 60* 1000,10 * 1000,1 * 1000,3600000);
  dtSecretManager.startThreads();
  TestDelegationTokenIdentifier dtId=new TestDelegationTokenIdentifier(new Text("theuser"),null,null);
  Token<TestDelegationTokenIdentifier> token=new Token<TestDelegationTokenIdentifier>(dtId,dtSecretManager);
  Assert.assertTrue(token != null);
  try {
    dtSecretManager.renewToken(token,"");
    Assert.fail("Renewal must not succeed");
  }
 catch (  IOException e) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.security.token.delegation.web.TestDelegationTokenManager </h4><pre class="type-2 type-7 type-10 type-1 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testDTManager() throws Exception {
  DelegationTokenManager tm=new DelegationTokenManager(new Text("foo"),DAY_IN_SECS,DAY_IN_SECS,DAY_IN_SECS,DAY_IN_SECS);
  tm.init();
  Token<DelegationTokenIdentifier> token=tm.createToken(UserGroupInformation.getCurrentUser(),"foo");
  Assert.assertNotNull(token);
  tm.verifyToken(token);
  Assert.assertTrue(tm.renewToken(token,"foo") > System.currentTimeMillis());
  tm.cancelToken(token,"foo");
  try {
    tm.verifyToken(token);
    Assert.fail();
  }
 catch (  IOException ex) {
  }
catch (  Exception ex) {
    Assert.fail();
  }
  tm.destroy();
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.security.token.delegation.web.TestWebDelegationToken </h4><pre class="type-2 type-7 type-10 type-1 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects are null
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testDelegationTokenAuthenticatorCalls() throws Exception {
  final Server jetty=createJettyServer();
  Context context=new Context();
  context.setContextPath("/foo");
  jetty.setHandler(context);
  context.addFilter(new FilterHolder(AFilter.class),"/*",0);
  context.addServlet(new ServletHolder(PingServlet.class),"/bar");
  try {
    jetty.start();
    URL nonAuthURL=new URL(getJettyURL() + "/foo/bar");
    URL authURL=new URL(getJettyURL() + "/foo/bar?authenticated=foo");
    URL authURL2=new URL(getJettyURL() + "/foo/bar?authenticated=bar");
    DelegationTokenAuthenticatedURL.Token token=new DelegationTokenAuthenticatedURL.Token();
    DelegationTokenAuthenticatedURL aUrl=new DelegationTokenAuthenticatedURL();
    try {
      aUrl.getDelegationToken(nonAuthURL,token,FOO_USER);
      Assert.fail();
    }
 catch (    Exception ex) {
      Assert.assertTrue(ex.getMessage().contains("401"));
    }
    aUrl.getDelegationToken(authURL,token,FOO_USER);
    Assert.assertNotNull(token.getDelegationToken());
    Assert.assertEquals(new Text("token-kind"),token.getDelegationToken().getKind());
    aUrl.renewDelegationToken(authURL,token);
    try {
      aUrl.renewDelegationToken(nonAuthURL,token);
      Assert.fail();
    }
 catch (    Exception ex) {
      Assert.assertTrue(ex.getMessage().contains("401"));
    }
    aUrl.getDelegationToken(authURL,token,FOO_USER);
    try {
      aUrl.renewDelegationToken(authURL2,token);
      Assert.fail();
    }
 catch (    Exception ex) {
      Assert.assertTrue(ex.getMessage().contains("403"));
    }
    aUrl.getDelegationToken(authURL,token,FOO_USER);
    aUrl.cancelDelegationToken(authURL,token);
    aUrl.getDelegationToken(authURL,token,FOO_USER);
    aUrl.cancelDelegationToken(nonAuthURL,token);
    aUrl.getDelegationToken(authURL,token,FOO_USER);
    try {
      aUrl.renewDelegationToken(nonAuthURL,token);
    }
 catch (    Exception ex) {
      Assert.assertTrue(ex.getMessage().contains("401"));
    }
  }
  finally {
    jetty.stop();
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-10 type-1 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testKerberosDelegationTokenAuthenticator() throws Exception {
  org.apache.hadoop.conf.Configuration conf=new org.apache.hadoop.conf.Configuration();
  conf.set("hadoop.security.authentication","kerberos");
  UserGroupInformation.setConfiguration(conf);
  File testDir=new File("target/" + UUID.randomUUID().toString());
  Assert.assertTrue(testDir.mkdirs());
  MiniKdc kdc=new MiniKdc(MiniKdc.createConf(),testDir);
  final Server jetty=createJettyServer();
  Context context=new Context();
  context.setContextPath("/foo");
  jetty.setHandler(context);
  context.addFilter(new FilterHolder(KDTAFilter.class),"/*",0);
  context.addServlet(new ServletHolder(UserServlet.class),"/bar");
  try {
    kdc.start();
    File keytabFile=new File(testDir,"test.keytab");
    kdc.createPrincipal(keytabFile,"client","HTTP/localhost");
    KDTAFilter.keytabFile=keytabFile.getAbsolutePath();
    jetty.start();
    final DelegationTokenAuthenticatedURL.Token token=new DelegationTokenAuthenticatedURL.Token();
    final DelegationTokenAuthenticatedURL aUrl=new DelegationTokenAuthenticatedURL();
    final URL url=new URL(getJettyURL() + "/foo/bar");
    try {
      aUrl.getDelegationToken(url,token,FOO_USER);
      Assert.fail();
    }
 catch (    AuthenticationException ex) {
      Assert.assertTrue(ex.getMessage().contains("GSSException"));
    }
    doAsKerberosUser("client",keytabFile.getAbsolutePath(),new Callable<Void>(){
      @Override public Void call() throws Exception {
        aUrl.getDelegationToken(url,token,"client");
        Assert.assertNotNull(token.getDelegationToken());
        aUrl.renewDelegationToken(url,token);
        Assert.assertNotNull(token.getDelegationToken());
        aUrl.getDelegationToken(url,token,FOO_USER);
        Assert.assertNotNull(token.getDelegationToken());
        try {
          aUrl.renewDelegationToken(url,token);
          Assert.fail();
        }
 catch (        Exception ex) {
          Assert.assertTrue(ex.getMessage().contains("403"));
        }
        aUrl.getDelegationToken(url,token,FOO_USER);
        aUrl.cancelDelegationToken(url,token);
        Assert.assertNull(token.getDelegationToken());
        return null;
      }
    }
);
  }
  finally {
    jetty.stop();
    kdc.stop();
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.service.TestCompositeService </h4><pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=1000) public void testAddUninitedSiblingInInit() throws Throwable {
  CompositeService parent=new CompositeService("parent");
  BreakableService sibling=new BreakableService();
  parent.addService(new AddSiblingService(parent,sibling,STATE.INITED));
  parent.init(new Configuration());
  try {
    parent.start();
    fail("Expected an exception, got " + parent);
  }
 catch (  ServiceStateException e) {
  }
  parent.stop();
  assertEquals("Incorrect number of services",2,parent.getServices().size());
}

</code></pre>

<br>
<pre class="type-2 type-7 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
"></span><br>
@Test(timeout=1000) public void testAddStoppedChildBeforeInit() throws Throwable {
  CompositeService parent=new CompositeService("parent");
  BreakableService child=new BreakableService();
  child.init(new Configuration());
  child.start();
  child.stop();
  AddSiblingService.addChildToService(parent,child);
  try {
    parent.init(new Configuration());
    fail("Expected an exception, got " + parent);
  }
 catch (  ServiceStateException e) {
  }
  parent.stop();
}

</code></pre>

<br>
<pre class="type-13 type-11 type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testServiceStartup(){
  ServiceManager serviceManager=new ServiceManager("ServiceManager");
  for (int i=0; i < NUM_OF_SERVICES; i++) {
    CompositeServiceImpl service=new CompositeServiceImpl(i);
    if (i == FAILED_SERVICE_SEQ_NUMBER) {
      service.setThrowExceptionOnStart(true);
    }
    serviceManager.addTestService(service);
  }
  CompositeServiceImpl[] services=serviceManager.getServices().toArray(new CompositeServiceImpl[0]);
  Configuration conf=new Configuration();
  serviceManager.init(conf);
  try {
    serviceManager.start();
    fail("Exception should have been thrown due to startup failure of last service");
  }
 catch (  ServiceTestRuntimeException e) {
    for (int i=0; i < NUM_OF_SERVICES - 1; i++) {
      if (i >= FAILED_SERVICE_SEQ_NUMBER && STOP_ONLY_STARTED_SERVICES) {
        assertEquals("Service state should have been ",STATE.INITED,services[NUM_OF_SERVICES - 1].getServiceState());
      }
 else {
        assertEquals("Service state should have been ",STATE.STOPPED,services[i].getServiceState());
      }
    }
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
"></span><br>
@Test(timeout=1000) public void testAddStartedChildBeforeInit() throws Throwable {
  CompositeService parent=new CompositeService("parent");
  BreakableService child=new BreakableService();
  child.init(new Configuration());
  child.start();
  AddSiblingService.addChildToService(parent,child);
  try {
    parent.init(new Configuration());
    fail("Expected an exception, got " + parent);
  }
 catch (  ServiceStateException e) {
  }
  parent.stop();
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.service.TestServiceLifecycle </h4><pre class="type-2 type-7 type-1 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Show that if the service failed during an init
 * operation, stop was called.
 */
@Test public void testStopFailingInitAndStop() throws Throwable {
  BreakableService svc=new BreakableService(true,false,true);
  svc.registerServiceListener(new LoggingStateChangeListener());
  try {
    svc.init(new Configuration());
    fail("Expected a failure, got " + svc);
  }
 catch (  BreakableService.BrokenLifecycleEvent e) {
    assertEquals(Service.STATE.INITED,e.state);
  }
  assertServiceStateStopped(svc);
  assertEquals(Service.STATE.INITED,svc.getFailureState());
  Throwable failureCause=svc.getFailureCause();
  assertNotNull("Null failure cause in " + svc,failureCause);
  BreakableService.BrokenLifecycleEvent cause=(BreakableService.BrokenLifecycleEvent)failureCause;
  assertNotNull("null state in " + cause + " raised by "+ svc,cause.state);
  assertEquals(Service.STATE.INITED,cause.state);
}

</code></pre>

<br>
<pre class="type-2 type-7 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
"></span><br>
/** 
 * Show that if the service failed during an init
 * operation, it stays in the created state, even after stopping it
 * @throws Throwable if necessary
 */
@Test public void testStopFailedInit() throws Throwable {
  BreakableService svc=new BreakableService(true,false,false);
  assertServiceStateCreated(svc);
  try {
    svc.init(new Configuration());
    fail("Expected a failure, got " + svc);
  }
 catch (  BreakableService.BrokenLifecycleEvent e) {
  }
  assertServiceStateStopped(svc);
  assertStateCount(svc,Service.STATE.INITED,1);
  assertStateCount(svc,Service.STATE.STOPPED,1);
  svc.stop();
  assertStateCount(svc,Service.STATE.STOPPED,1);
}

</code></pre>

<br>
<pre class="type-2 type-7 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
"></span><br>
/** 
 * verify that when a service fails during its stop operation,
 * its state does not change.
 * @throws Throwable if necessary
 */
@Test public void testFailingStop() throws Throwable {
  BreakableService svc=new BreakableService(false,false,true);
  svc.init(new Configuration());
  svc.start();
  try {
    svc.stop();
    fail("Expected a failure, got " + svc);
  }
 catch (  BreakableService.BrokenLifecycleEvent e) {
  }
  assertStateCount(svc,Service.STATE.STOPPED,1);
}

</code></pre>

<br>
<pre class="type-2 type-7 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
"></span><br>
/** 
 * Show that if the service failed during an init
 * operation, it stays in the created state, even after stopping it
 * @throws Throwable if necessary
 */
@Test public void testStopFailedStart() throws Throwable {
  BreakableService svc=new BreakableService(false,true,false);
  svc.init(new Configuration());
  assertServiceStateInited(svc);
  try {
    svc.start();
    fail("Expected a failure, got " + svc);
  }
 catch (  BreakableService.BrokenLifecycleEvent e) {
  }
  assertServiceStateStopped(svc);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.test.TestMultithreadedTestUtil </h4><pre class="type-2 type-10 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testThreadThrowsCheckedException() throws Exception {
  TestContext ctx=new TestContext();
  ctx.addThread(new TestingThread(ctx){
    @Override public void doWork() throws Exception {
      throw new IOException("my ioe");
    }
  }
);
  ctx.startThreads();
  long st=Time.now();
  try {
    ctx.waitFor(30000);
    fail("waitFor did not throw");
  }
 catch (  RuntimeException rte) {
    assertEquals("my ioe",rte.getCause().getMessage());
  }
  long et=Time.now();
  assertTrue("Test took " + (et - st) + "ms",et - st < 5000);
}

</code></pre>

<br>
<pre class="type-2 type-10 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testThreadFails() throws Exception {
  TestContext ctx=new TestContext();
  ctx.addThread(new TestingThread(ctx){
    @Override public void doWork() throws Exception {
      fail(FAIL_MSG);
    }
  }
);
  ctx.startThreads();
  long st=Time.now();
  try {
    ctx.waitFor(30000);
    fail("waitFor did not throw");
  }
 catch (  RuntimeException rte) {
    assertEquals(FAIL_MSG,rte.getCause().getMessage());
  }
  long et=Time.now();
  assertTrue("Test took " + (et - st) + "ms",et - st < 5000);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.tools.TestCopyListing </h4><pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=10000) public void testBuildListing(){
  FileSystem fs=null;
  try {
    fs=FileSystem.get(getConf());
    List<Path> srcPaths=new ArrayList<Path>();
    Path p1=new Path("/tmp/in/1");
    Path p2=new Path("/tmp/in/2");
    Path p3=new Path("/tmp/in2/2");
    Path target=new Path("/tmp/out/1");
    srcPaths.add(p1.getParent());
    srcPaths.add(p3.getParent());
    TestDistCpUtils.createFile(fs,"/tmp/in/1");
    TestDistCpUtils.createFile(fs,"/tmp/in/2");
    TestDistCpUtils.createFile(fs,"/tmp/in2/2");
    fs.mkdirs(target);
    OutputStream out=fs.create(p1);
    out.write("ABC".getBytes());
    out.close();
    out=fs.create(p2);
    out.write("DEF".getBytes());
    out.close();
    out=fs.create(p3);
    out.write("GHIJ".getBytes());
    out.close();
    Path listingFile=new Path("/tmp/file");
    DistCpOptions options=new DistCpOptions(srcPaths,target);
    options.setSyncFolder(true);
    CopyListing listing=new SimpleCopyListing(getConf(),CREDENTIALS);
    try {
      listing.buildListing(listingFile,options);
      Assert.fail("Duplicates not detected");
    }
 catch (    DuplicateFileException ignore) {
    }
    Assert.assertEquals(listing.getBytesToCopy(),10);
    Assert.assertEquals(listing.getNumberOfPaths(),3);
    TestDistCpUtils.delete(fs,"/tmp");
    try {
      listing.buildListing(listingFile,options);
      Assert.fail("Invalid input not detected");
    }
 catch (    InvalidInputException ignore) {
    }
    TestDistCpUtils.delete(fs,"/tmp");
  }
 catch (  IOException e) {
    LOG.error("Exception encountered ",e);
    Assert.fail("Test build listing failed");
  }
 finally {
    TestDistCpUtils.delete(fs,"/tmp");
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test(timeout=10000) public void testMultipleSrcToFile(){
  FileSystem fs=null;
  try {
    fs=FileSystem.get(getConf());
    List<Path> srcPaths=new ArrayList<Path>();
    srcPaths.add(new Path("/tmp/in/1"));
    srcPaths.add(new Path("/tmp/in/2"));
    Path target=new Path("/tmp/out/1");
    TestDistCpUtils.createFile(fs,"/tmp/in/1");
    TestDistCpUtils.createFile(fs,"/tmp/in/2");
    fs.mkdirs(target);
    DistCpOptions options=new DistCpOptions(srcPaths,target);
    validatePaths(options);
    TestDistCpUtils.delete(fs,"/tmp");
    target=new Path("/tmp/out/1");
    fs.create(target).close();
    options=new DistCpOptions(srcPaths,target);
    try {
      validatePaths(options);
      Assert.fail("Invalid inputs accepted");
    }
 catch (    InvalidInputException ignore) {
    }
    TestDistCpUtils.delete(fs,"/tmp");
    srcPaths.clear();
    srcPaths.add(new Path("/tmp/in/1"));
    fs.mkdirs(new Path("/tmp/in/1"));
    target=new Path("/tmp/out/1");
    fs.create(target).close();
    options=new DistCpOptions(srcPaths,target);
    try {
      validatePaths(options);
      Assert.fail("Invalid inputs accepted");
    }
 catch (    InvalidInputException ignore) {
    }
    TestDistCpUtils.delete(fs,"/tmp");
  }
 catch (  IOException e) {
    LOG.error("Exception encountered ",e);
    Assert.fail("Test input validation failed");
  }
 finally {
    TestDistCpUtils.delete(fs,"/tmp");
  }
}

</code></pre>

<br>
<pre class="type-9 type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=10000) public void testBuildListingForSingleFile(){
  FileSystem fs=null;
  String testRootString="/singleFileListing";
  Path testRoot=new Path(testRootString);
  SequenceFile.Reader reader=null;
  try {
    fs=FileSystem.get(getConf());
    if (fs.exists(testRoot))     TestDistCpUtils.delete(fs,testRootString);
    Path sourceFile=new Path(testRoot,"/source/foo/bar/source.txt");
    Path decoyFile=new Path(testRoot,"/target/moo/source.txt");
    Path targetFile=new Path(testRoot,"/target/moo/target.txt");
    TestDistCpUtils.createFile(fs,sourceFile.toString());
    TestDistCpUtils.createFile(fs,decoyFile.toString());
    TestDistCpUtils.createFile(fs,targetFile.toString());
    List<Path> srcPaths=new ArrayList<Path>();
    srcPaths.add(sourceFile);
    DistCpOptions options=new DistCpOptions(srcPaths,targetFile);
    CopyListing listing=new SimpleCopyListing(getConf(),CREDENTIALS);
    final Path listFile=new Path(testRoot,"/tmp/fileList.seq");
    listing.buildListing(listFile,options);
    reader=new SequenceFile.Reader(getConf(),SequenceFile.Reader.file(listFile));
    CopyListingFileStatus fileStatus=new CopyListingFileStatus();
    Text relativePath=new Text();
    Assert.assertTrue(reader.next(relativePath,fileStatus));
    Assert.assertTrue(relativePath.toString().equals(""));
  }
 catch (  Exception e) {
    Assert.fail("Unexpected exception encountered.");
    LOG.error("Unexpected exception: ",e);
  }
 finally {
    TestDistCpUtils.delete(fs,testRootString);
    IOUtils.closeStream(reader);
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test(timeout=10000) public void testDuplicates(){
  FileSystem fs=null;
  try {
    fs=FileSystem.get(getConf());
    List<Path> srcPaths=new ArrayList<Path>();
    srcPaths.add(new Path("/tmp/in/*/*"));
    TestDistCpUtils.createFile(fs,"/tmp/in/src1/1.txt");
    TestDistCpUtils.createFile(fs,"/tmp/in/src2/1.txt");
    Path target=new Path("/tmp/out");
    Path listingFile=new Path("/tmp/list");
    DistCpOptions options=new DistCpOptions(srcPaths,target);
    CopyListing listing=CopyListing.getCopyListing(getConf(),CREDENTIALS,options);
    try {
      listing.buildListing(listingFile,options);
      Assert.fail("Duplicates not detected");
    }
 catch (    DuplicateFileException ignore) {
    }
  }
 catch (  IOException e) {
    LOG.error("Exception encountered in test",e);
    Assert.fail("Test failed " + e.getMessage());
  }
 finally {
    TestDistCpUtils.delete(fs,"/tmp");
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.tools.TestDistCpViewFs </h4><pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testGlobTargetMissingMultiLevel(){
  try {
    Path listFile=new Path("target/tmp1/listing").makeQualified(fs.getUri(),fs.getWorkingDirectory());
    addEntries(listFile,"*/*");
    createFiles("multifile/file3","multifile/file4","multifile/file5");
    createFiles("singledir1/dir3/file7","singledir1/dir3/file8","singledir1/dir3/file9");
    runTest(listFile,target,false,false);
    checkResult(target,4,"file3","file4","file5","dir3/file7","dir3/file8","dir3/file9");
  }
 catch (  IOException e) {
    LOG.error("Exception encountered while running distcp",e);
    Assert.fail("distcp failure");
  }
 finally {
    TestDistCpUtils.delete(fs,root);
    TestDistCpUtils.delete(fs,"target/tmp1");
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testUpdateGlobTargetMissingMultiLevel(){
  try {
    Path listFile=new Path("target/tmp1/listing").makeQualified(fs.getUri(),fs.getWorkingDirectory());
    addEntries(listFile,"*/*");
    createFiles("multifile/file3","multifile/file4","multifile/file5");
    createFiles("singledir1/dir3/file7","singledir1/dir3/file8","singledir1/dir3/file9");
    runTest(listFile,target,false,true);
    checkResult(target,6,"file3","file4","file5","file7","file8","file9");
  }
 catch (  IOException e) {
    LOG.error("Exception encountered while running distcp",e);
    Assert.fail("distcp failure");
  }
 finally {
    TestDistCpUtils.delete(fs,root);
    TestDistCpUtils.delete(fs,"target/tmp1");
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testUpdateMultiDirTargetPresent(){
  try {
    addEntries(listFile,"Umultifile","Usingledir");
    createFiles("Umultifile/Ufile3","Umultifile/Ufile4","Umultifile/Ufile5");
    mkdirs(target.toString(),root + "/Usingledir/Udir1");
    runTest(listFile,target,true,true);
    checkResult(target,4,"Ufile3","Ufile4","Ufile5","Udir1");
  }
 catch (  IOException e) {
    LOG.error("Exception encountered while testing distcp",e);
    Assert.fail("distcp failure");
  }
 finally {
    TestDistCpUtils.delete(fs,root);
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testUpdateGlobTargetMissingSingleLevel(){
  try {
    Path listFile=new Path("target/tmp1/listing").makeQualified(fs.getUri(),fs.getWorkingDirectory());
    addEntries(listFile,"*");
    createFiles("multifile/file3","multifile/file4","multifile/file5");
    createFiles("singledir/dir2/file6");
    runTest(listFile,target,false,true);
    checkResult(target,4,"file3","file4","file5","dir2/file6");
  }
 catch (  IOException e) {
    LOG.error("Exception encountered while running distcp",e);
    Assert.fail("distcp failure");
  }
 finally {
    TestDistCpUtils.delete(fs,root);
    TestDistCpUtils.delete(fs,"target/tmp1");
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testGlobTargetMissingSingleLevel(){
  try {
    Path listFile=new Path("target/tmp1/listing").makeQualified(fs.getUri(),fs.getWorkingDirectory());
    addEntries(listFile,"*");
    createFiles("multifile/file3","multifile/file4","multifile/file5");
    createFiles("singledir/dir2/file6");
    runTest(listFile,target,false,false);
    checkResult(target,2,"multifile/file3","multifile/file4","multifile/file5","singledir/dir2/file6");
  }
 catch (  IOException e) {
    LOG.error("Exception encountered while testing distcp",e);
    Assert.fail("distcp failure");
  }
 finally {
    TestDistCpUtils.delete(fs,root);
    TestDistCpUtils.delete(fs,"target/tmp1");
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testMultiDirTargetPresent(){
  try {
    addEntries(listFile,"multifile","singledir");
    createFiles("multifile/file3","multifile/file4","multifile/file5");
    mkdirs(target.toString(),root + "/singledir/dir1");
    runTest(listFile,target,true,false);
    checkResult(target,2,"multifile/file3","multifile/file4","multifile/file5","singledir/dir1");
  }
 catch (  IOException e) {
    LOG.error("Exception encountered while testing distcp",e);
    Assert.fail("distcp failure");
  }
 finally {
    TestDistCpUtils.delete(fs,root);
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testUpdateSingleDirTargetPresent(){
  try {
    addEntries(listFile,"Usingledir");
    mkdirs(root + "/Usingledir/Udir1");
    mkdirs(target.toString());
    runTest(listFile,target,true,true);
    checkResult(target,1,"Udir1");
  }
 catch (  IOException e) {
    LOG.error("Exception encountered while testing distcp",e);
    Assert.fail("distcp failure");
  }
 finally {
    TestDistCpUtils.delete(fs,root);
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testMultiDirTargetMissing(){
  try {
    addEntries(listFile,"multifile","singledir");
    createFiles("multifile/file3","multifile/file4","multifile/file5");
    mkdirs(root + "/singledir/dir1");
    runTest(listFile,target,false,false);
    checkResult(target,2,"multifile/file3","multifile/file4","multifile/file5","singledir/dir1");
  }
 catch (  IOException e) {
    LOG.error("Exception encountered while testing distcp",e);
    Assert.fail("distcp failure");
  }
 finally {
    TestDistCpUtils.delete(fs,root);
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testSingleDirTargetPresent(){
  try {
    addEntries(listFile,"singledir");
    mkdirs(root + "/singledir/dir1");
    mkdirs(target.toString());
    runTest(listFile,target,true,false);
    checkResult(target,1,"singledir/dir1");
  }
 catch (  IOException e) {
    LOG.error("Exception encountered while testing distcp",e);
    Assert.fail("distcp failure");
  }
 finally {
    TestDistCpUtils.delete(fs,root);
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testUpdateMultiDirTargetMissing(){
  try {
    addEntries(listFile,"multifile","singledir");
    createFiles("multifile/file3","multifile/file4","multifile/file5");
    mkdirs(root + "/singledir/dir1");
    runTest(listFile,target,false,true);
    checkResult(target,4,"file3","file4","file5","dir1");
  }
 catch (  IOException e) {
    LOG.error("Exception encountered while testing distcp",e);
    Assert.fail("distcp failure");
  }
 finally {
    TestDistCpUtils.delete(fs,root);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.tools.TestExternalCall </h4><pre class="type-9 type-2 type-7 type-10 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * test main method of DistCp. Method should to call System.exit().
 */
@Test public void testCleanupTestViaToolRunner() throws IOException, InterruptedException {
  Configuration conf=getConf();
  Path stagingDir=JobSubmissionFiles.getStagingDir(new Cluster(conf),conf);
  stagingDir.getFileSystem(conf).mkdirs(stagingDir);
  Path soure=createFile("tmp.txt");
  Path target=createFile("target.txt");
  try {
    String[] arg={target.toString(),soure.toString()};
    DistCp.main(arg);
    Assert.fail();
  }
 catch (  ExitException t) {
    Assert.assertTrue(fs.exists(target));
    Assert.assertEquals(t.status,0);
    Assert.assertEquals(stagingDir.getFileSystem(conf).listStatus(stagingDir).length,0);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.tools.TestFileBasedCopyListing </h4><pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testUpdateSingleDirTargetPresent(){
  try {
    Path listFile=new Path("/tmp/listing");
    Path target=new Path("/tmp/target");
    addEntries(listFile,"/tmp/Usingledir");
    mkdirs("/tmp/Usingledir/Udir1");
    mkdirs(target.toString());
    runTest(listFile,target,true,true);
    checkResult(listFile,1);
  }
 catch (  IOException e) {
    LOG.error("Exception encountered while testing build listing",e);
    Assert.fail("build listing failure");
  }
 finally {
    TestDistCpUtils.delete(fs,"/tmp");
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testUpdateGlobTargetDirMultiLevel(){
  try {
    Path listFile=new Path("/tmp1/listing");
    Path target=new Path("/tmp/target");
    addEntries(listFile,"/tmp/*/*");
    createFiles("/tmp/Umultifile/Ufile3","/tmp/Umultifile/Ufile4","/tmp/Umultifile/Ufile5");
    createFiles("/tmp/Usingledir1/Udir3/Ufile7","/tmp/Usingledir1/Udir3/Ufile8","/tmp/Usingledir1/Udir3/Ufile9");
    mkdirs(target.toString());
    runTest(listFile,target,true);
    checkResult(listFile,6);
  }
 catch (  IOException e) {
    LOG.error("Exception encountered while testing build listing",e);
    Assert.fail("build listing failure");
  }
 finally {
    TestDistCpUtils.delete(fs,"/tmp");
    TestDistCpUtils.delete(fs,"/tmp1");
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testSingleDirTargetPresent(){
  try {
    Path listFile=new Path("/tmp/listing");
    Path target=new Path("/tmp/target");
    addEntries(listFile,"/tmp/singledir");
    mkdirs("/tmp/singledir/dir1");
    mkdirs(target.toString());
    runTest(listFile,target,true);
    checkResult(listFile,1);
  }
 catch (  IOException e) {
    LOG.error("Exception encountered while testing build listing",e);
    Assert.fail("build listing failure");
  }
 finally {
    TestDistCpUtils.delete(fs,"/tmp");
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testMultiDirTargetPresent(){
  try {
    Path listFile=new Path("/tmp/listing");
    Path target=new Path("/tmp/target");
    addEntries(listFile,"/tmp/multifile","/tmp/singledir");
    createFiles("/tmp/multifile/file3","/tmp/multifile/file4","/tmp/multifile/file5");
    mkdirs(target.toString(),"/tmp/singledir/dir1");
    runTest(listFile,target,true);
    checkResult(listFile,4);
  }
 catch (  IOException e) {
    LOG.error("Exception encountered while testing build listing",e);
    Assert.fail("build listing failure");
  }
 finally {
    TestDistCpUtils.delete(fs,"/tmp");
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testUpdateMultiDirTargetPresent(){
  try {
    Path listFile=new Path("/tmp/listing");
    Path target=new Path("/tmp/target");
    addEntries(listFile,"/tmp/Umultifile","/tmp/Usingledir");
    createFiles("/tmp/Umultifile/Ufile3","/tmp/Umultifile/Ufile4","/tmp/Umultifile/Ufile5");
    mkdirs(target.toString(),"/tmp/Usingledir/Udir1");
    runTest(listFile,target,true);
    checkResult(listFile,4);
  }
 catch (  IOException e) {
    LOG.error("Exception encountered while testing build listing",e);
    Assert.fail("build listing failure");
  }
 finally {
    TestDistCpUtils.delete(fs,"/tmp");
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testGlobTargetDirMultiLevel(){
  try {
    Path listFile=new Path("/tmp1/listing");
    Path target=new Path("/tmp/target");
    addEntries(listFile,"/tmp/*/*");
    createFiles("/tmp/multifile/file3","/tmp/multifile/file4","/tmp/multifile/file5");
    createFiles("/tmp/singledir1/dir3/file7","/tmp/singledir1/dir3/file8","/tmp/singledir1/dir3/file9");
    mkdirs(target.toString());
    runTest(listFile,target,true);
    checkResult(listFile,6);
  }
 catch (  IOException e) {
    LOG.error("Exception encountered while testing build listing",e);
    Assert.fail("build listing failure");
  }
 finally {
    TestDistCpUtils.delete(fs,"/tmp");
    TestDistCpUtils.delete(fs,"/tmp1");
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.tools.TestIntegration </h4><pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test(timeout=100000) public void testUpdateMultiDirTargetMissing(){
  try {
    addEntries(listFile,"multifile","singledir");
    createFiles("multifile/file3","multifile/file4","multifile/file5");
    mkdirs(root + "/singledir/dir1");
    runTest(listFile,target,false,true);
    checkResult(target,4,"file3","file4","file5","dir1");
  }
 catch (  IOException e) {
    LOG.error("Exception encountered while testing distcp",e);
    Assert.fail("distcp failure");
  }
 finally {
    TestDistCpUtils.delete(fs,root);
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test(timeout=100000) public void testUpdateMultiDirTargetPresent(){
  try {
    addEntries(listFile,"Umultifile","Usingledir");
    createFiles("Umultifile/Ufile3","Umultifile/Ufile4","Umultifile/Ufile5");
    mkdirs(target.toString(),root + "/Usingledir/Udir1");
    runTest(listFile,target,true,true);
    checkResult(target,4,"Ufile3","Ufile4","Ufile5","Udir1");
  }
 catch (  IOException e) {
    LOG.error("Exception encountered while testing distcp",e);
    Assert.fail("distcp failure");
  }
 finally {
    TestDistCpUtils.delete(fs,root);
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test(timeout=100000) public void testUpdateSingleDirTargetPresent(){
  try {
    addEntries(listFile,"Usingledir");
    mkdirs(root + "/Usingledir/Udir1");
    mkdirs(target.toString());
    runTest(listFile,target,true,true);
    checkResult(target,1,"Udir1");
  }
 catch (  IOException e) {
    LOG.error("Exception encountered while testing distcp",e);
    Assert.fail("distcp failure");
  }
 finally {
    TestDistCpUtils.delete(fs,root);
  }
}

</code></pre>

<br>
<pre class="type-2 type-6 type-20 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values related to public fields.">PublicFieldVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Verifies values related to public fields.
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=100000) public void testOverwrite(){
  byte[] contents1="contents1".getBytes();
  byte[] contents2="contents2".getBytes();
  Assert.assertEquals(contents1.length,contents2.length);
  try {
    addEntries(listFile,"srcdir");
    createWithContents("srcdir/file1",contents1);
    createWithContents("dstdir/file1",contents2);
    Path target=new Path(root + "/dstdir");
    runTest(listFile,target,false,false,false,true);
    checkResult(target,1,"file1");
    FSDataInputStream is=fs.open(new Path(root + "/dstdir/file1"));
    byte[] dstContents=new byte[contents1.length];
    is.readFully(dstContents);
    is.close();
    Assert.assertArrayEquals(contents1,dstContents);
  }
 catch (  IOException e) {
    LOG.error("Exception encountered while running distcp",e);
    Assert.fail("distcp failure");
  }
 finally {
    TestDistCpUtils.delete(fs,root);
    TestDistCpUtils.delete(fs,"target/tmp1");
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test(timeout=100000) public void testUpdateGlobTargetMissingSingleLevel(){
  try {
    Path listFile=new Path("target/tmp1/listing").makeQualified(fs.getUri(),fs.getWorkingDirectory());
    addEntries(listFile,"*");
    createFiles("multifile/file3","multifile/file4","multifile/file5");
    createFiles("singledir/dir2/file6");
    runTest(listFile,target,false,true);
    checkResult(target,4,"file3","file4","file5","dir2/file6");
  }
 catch (  IOException e) {
    LOG.error("Exception encountered while running distcp",e);
    Assert.fail("distcp failure");
  }
 finally {
    TestDistCpUtils.delete(fs,root);
    TestDistCpUtils.delete(fs,"target/tmp1");
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test(timeout=100000) public void testCustomCopyListing(){
  try {
    addEntries(listFile,"multifile1/file3","multifile1/file4","multifile1/file5");
    createFiles("multifile1/file3","multifile1/file4","multifile1/file5");
    mkdirs(target.toString());
    Configuration conf=getConf();
    try {
      conf.setClass(DistCpConstants.CONF_LABEL_COPY_LISTING_CLASS,CustomCopyListing.class,CopyListing.class);
      DistCpOptions options=new DistCpOptions(Arrays.asList(new Path(root + "/" + "multifile1")),target);
      options.setSyncFolder(true);
      options.setDeleteMissing(false);
      options.setOverwrite(false);
      try {
        new DistCp(conf,options).execute();
      }
 catch (      Exception e) {
        LOG.error("Exception encountered ",e);
        throw new IOException(e);
      }
    }
  finally {
      conf.unset(DistCpConstants.CONF_LABEL_COPY_LISTING_CLASS);
    }
    checkResult(target,2,"file4","file5");
  }
 catch (  IOException e) {
    LOG.error("Exception encountered while testing distcp",e);
    Assert.fail("distcp failure");
  }
 finally {
    TestDistCpUtils.delete(fs,root);
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test(timeout=100000) public void testMultiDirTargetMissing(){
  try {
    addEntries(listFile,"multifile","singledir");
    createFiles("multifile/file3","multifile/file4","multifile/file5");
    mkdirs(root + "/singledir/dir1");
    runTest(listFile,target,false,false);
    checkResult(target,2,"multifile/file3","multifile/file4","multifile/file5","singledir/dir1");
  }
 catch (  IOException e) {
    LOG.error("Exception encountered while testing distcp",e);
    Assert.fail("distcp failure");
  }
 finally {
    TestDistCpUtils.delete(fs,root);
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test(timeout=100000) public void testUpdateGlobTargetMissingMultiLevel(){
  try {
    Path listFile=new Path("target/tmp1/listing").makeQualified(fs.getUri(),fs.getWorkingDirectory());
    addEntries(listFile,"*/*");
    createFiles("multifile/file3","multifile/file4","multifile/file5");
    createFiles("singledir1/dir3/file7","singledir1/dir3/file8","singledir1/dir3/file9");
    runTest(listFile,target,false,true);
    checkResult(target,6,"file3","file4","file5","file7","file8","file9");
  }
 catch (  IOException e) {
    LOG.error("Exception encountered while running distcp",e);
    Assert.fail("distcp failure");
  }
 finally {
    TestDistCpUtils.delete(fs,root);
    TestDistCpUtils.delete(fs,"target/tmp1");
  }
}

</code></pre>

<br>
<pre class="type-9 type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=100000) public void testCleanup(){
  try {
    Path sourcePath=new Path("noscheme:///file");
    List<Path> sources=new ArrayList<Path>();
    sources.add(sourcePath);
    DistCpOptions options=new DistCpOptions(sources,target);
    Configuration conf=getConf();
    Path stagingDir=JobSubmissionFiles.getStagingDir(new Cluster(conf),conf);
    stagingDir.getFileSystem(conf).mkdirs(stagingDir);
    try {
      new DistCp(conf,options).execute();
    }
 catch (    Throwable t) {
      Assert.assertEquals(stagingDir.getFileSystem(conf).listStatus(stagingDir).length,0);
    }
  }
 catch (  Exception e) {
    LOG.error("Exception encountered ",e);
    Assert.fail("testCleanup failed " + e.getMessage());
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test(timeout=100000) public void testGlobTargetMissingMultiLevel(){
  try {
    Path listFile=new Path("target/tmp1/listing").makeQualified(fs.getUri(),fs.getWorkingDirectory());
    addEntries(listFile,"*/*");
    createFiles("multifile/file3","multifile/file4","multifile/file5");
    createFiles("singledir1/dir3/file7","singledir1/dir3/file8","singledir1/dir3/file9");
    runTest(listFile,target,false,false);
    checkResult(target,4,"file3","file4","file5","dir3/file7","dir3/file8","dir3/file9");
  }
 catch (  IOException e) {
    LOG.error("Exception encountered while running distcp",e);
    Assert.fail("distcp failure");
  }
 finally {
    TestDistCpUtils.delete(fs,root);
    TestDistCpUtils.delete(fs,"target/tmp1");
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test(timeout=100000) public void testMultiDirTargetPresent(){
  try {
    addEntries(listFile,"multifile","singledir");
    createFiles("multifile/file3","multifile/file4","multifile/file5");
    mkdirs(target.toString(),root + "/singledir/dir1");
    runTest(listFile,target,true,false);
    checkResult(target,2,"multifile/file3","multifile/file4","multifile/file5","singledir/dir1");
  }
 catch (  IOException e) {
    LOG.error("Exception encountered while testing distcp",e);
    Assert.fail("distcp failure");
  }
 finally {
    TestDistCpUtils.delete(fs,root);
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test(timeout=100000) public void testDeleteMissingInDestination(){
  try {
    addEntries(listFile,"srcdir");
    createFiles("srcdir/file1","dstdir/file1","dstdir/file2");
    Path target=new Path(root + "/dstdir");
    runTest(listFile,target,false,true,true,false);
    checkResult(target,1,"file1");
  }
 catch (  IOException e) {
    LOG.error("Exception encountered while running distcp",e);
    Assert.fail("distcp failure");
  }
 finally {
    TestDistCpUtils.delete(fs,root);
    TestDistCpUtils.delete(fs,"target/tmp1");
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test(timeout=100000) public void testGlobTargetMissingSingleLevel(){
  try {
    Path listFile=new Path("target/tmp1/listing").makeQualified(fs.getUri(),fs.getWorkingDirectory());
    addEntries(listFile,"*");
    createFiles("multifile/file3","multifile/file4","multifile/file5");
    createFiles("singledir/dir2/file6");
    runTest(listFile,target,false,false);
    checkResult(target,2,"multifile/file3","multifile/file4","multifile/file5","singledir/dir2/file6");
  }
 catch (  IOException e) {
    LOG.error("Exception encountered while testing distcp",e);
    Assert.fail("distcp failure");
  }
 finally {
    TestDistCpUtils.delete(fs,root);
    TestDistCpUtils.delete(fs,"target/tmp1");
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test(timeout=100000) public void testSingleDirTargetPresent(){
  try {
    addEntries(listFile,"singledir");
    mkdirs(root + "/singledir/dir1");
    mkdirs(target.toString());
    runTest(listFile,target,true,false);
    checkResult(target,1,"singledir/dir1");
  }
 catch (  IOException e) {
    LOG.error("Exception encountered while testing distcp",e);
    Assert.fail("distcp failure");
  }
 finally {
    TestDistCpUtils.delete(fs,root);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.tools.TestOptionsParser </h4><pre class="type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testParseAtomicCommit(){
  DistCpOptions options=OptionsParser.parse(new String[]{"hdfs://localhost:8020/source/first","hdfs://localhost:8020/target/"});
  Assert.assertFalse(options.shouldAtomicCommit());
  options=OptionsParser.parse(new String[]{"-atomic","hdfs://localhost:8020/source/first","hdfs://localhost:8020/target/"});
  Assert.assertTrue(options.shouldAtomicCommit());
  try {
    OptionsParser.parse(new String[]{"-atomic","-update","hdfs://localhost:8020/source/first","hdfs://localhost:8020/target/"});
    Assert.fail("Atomic and sync folders were allowed");
  }
 catch (  IllegalArgumentException ignore) {
  }
}

</code></pre>

<br>
<pre class="type-2 type-1 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects are null
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testParseWorkPath(){
  DistCpOptions options=OptionsParser.parse(new String[]{"hdfs://localhost:8020/source/first","hdfs://localhost:8020/target/"});
  Assert.assertNull(options.getAtomicWorkPath());
  options=OptionsParser.parse(new String[]{"-atomic","hdfs://localhost:8020/source/first","hdfs://localhost:8020/target/"});
  Assert.assertNull(options.getAtomicWorkPath());
  options=OptionsParser.parse(new String[]{"-atomic","-tmp","hdfs://localhost:8020/work","hdfs://localhost:8020/source/first","hdfs://localhost:8020/target/"});
  Assert.assertEquals(options.getAtomicWorkPath(),new Path("hdfs://localhost:8020/work"));
  try {
    OptionsParser.parse(new String[]{"-tmp","hdfs://localhost:8020/work","hdfs://localhost:8020/source/first","hdfs://localhost:8020/target/"});
    Assert.fail("work path was allowed without -atomic switch");
  }
 catch (  IllegalArgumentException ignore) {
  }
}

</code></pre>

<br>
<pre class="type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testParseMaps(){
  DistCpOptions options=OptionsParser.parse(new String[]{"hdfs://localhost:8020/source/first","hdfs://localhost:8020/target/"});
  Assert.assertEquals(options.getMaxMaps(),DistCpConstants.DEFAULT_MAPS);
  options=OptionsParser.parse(new String[]{"-m","1","hdfs://localhost:8020/source/first","hdfs://localhost:8020/target/"});
  Assert.assertEquals(options.getMaxMaps(),1);
  options=OptionsParser.parse(new String[]{"-m","0","hdfs://localhost:8020/source/first","hdfs://localhost:8020/target/"});
  Assert.assertEquals(options.getMaxMaps(),1);
  try {
    OptionsParser.parse(new String[]{"-m","hello","hdfs://localhost:8020/source/first","hdfs://localhost:8020/target/"});
    Assert.fail("Non numberic map parsed");
  }
 catch (  IllegalArgumentException ignore) {
  }
  try {
    OptionsParser.parse(new String[]{"-mapredXslConf","hdfs://localhost:8020/source/first","hdfs://localhost:8020/target/"});
    Assert.fail("Non numberic map parsed");
  }
 catch (  IllegalArgumentException ignore) {
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testInvalidArgs(){
  try {
    OptionsParser.parse(new String[]{"-m","-f","hdfs://localhost:8020/source"});
    Assert.fail("Missing map value");
  }
 catch (  IllegalArgumentException ignore) {
  }
}

</code></pre>

<br>
<pre class="type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testParseOverwrite(){
  DistCpOptions options=OptionsParser.parse(new String[]{"hdfs://localhost:8020/source/first","hdfs://localhost:8020/target/"});
  Assert.assertFalse(options.shouldOverwrite());
  options=OptionsParser.parse(new String[]{"-overwrite","hdfs://localhost:8020/source/first","hdfs://localhost:8020/target/"});
  Assert.assertTrue(options.shouldOverwrite());
  try {
    OptionsParser.parse(new String[]{"-update","-overwrite","hdfs://localhost:8020/source/first","hdfs://localhost:8020/target/"});
    Assert.fail("Update and overwrite aren't allowed together");
  }
 catch (  IllegalArgumentException ignore) {
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testParseDeleteMissing(){
  DistCpOptions options=OptionsParser.parse(new String[]{"hdfs://localhost:8020/source/first","hdfs://localhost:8020/target/"});
  Assert.assertFalse(options.shouldDeleteMissing());
  options=OptionsParser.parse(new String[]{"-update","-delete","hdfs://localhost:8020/source/first","hdfs://localhost:8020/target/"});
  Assert.assertTrue(options.shouldSyncFolder());
  Assert.assertTrue(options.shouldDeleteMissing());
  options=OptionsParser.parse(new String[]{"-overwrite","-delete","hdfs://localhost:8020/source/first","hdfs://localhost:8020/target/"});
  Assert.assertTrue(options.shouldOverwrite());
  Assert.assertTrue(options.shouldDeleteMissing());
  try {
    OptionsParser.parse(new String[]{"-atomic","-delete","hdfs://localhost:8020/source/first","hdfs://localhost:8020/target/"});
    Assert.fail("Atomic and delete folders were allowed");
  }
 catch (  IllegalArgumentException ignore) {
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testMissingTarget(){
  try {
    OptionsParser.parse(new String[]{"-f","hdfs://localhost:8020/source"});
    Assert.fail("Missing target allowed");
  }
 catch (  IllegalArgumentException ignore) {
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testSourceListingAndSourcePath(){
  try {
    OptionsParser.parse(new String[]{"-f","hdfs://localhost:8020/source/first","hdfs://localhost:8020/source/first","hdfs://localhost:8020/target/"});
    Assert.fail("Both source listing & source paths allowed");
  }
 catch (  IllegalArgumentException ignore) {
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-10 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testPreserve(){
  DistCpOptions options=OptionsParser.parse(new String[]{"-f","hdfs://localhost:8020/source/first","hdfs://localhost:8020/target/"});
  Assert.assertFalse(options.shouldPreserve(FileAttribute.BLOCKSIZE));
  Assert.assertFalse(options.shouldPreserve(FileAttribute.REPLICATION));
  Assert.assertFalse(options.shouldPreserve(FileAttribute.PERMISSION));
  Assert.assertFalse(options.shouldPreserve(FileAttribute.USER));
  Assert.assertFalse(options.shouldPreserve(FileAttribute.GROUP));
  Assert.assertFalse(options.shouldPreserve(FileAttribute.CHECKSUMTYPE));
  options=OptionsParser.parse(new String[]{"-p","-f","hdfs://localhost:8020/source/first","hdfs://localhost:8020/target/"});
  Assert.assertTrue(options.shouldPreserve(FileAttribute.BLOCKSIZE));
  Assert.assertTrue(options.shouldPreserve(FileAttribute.REPLICATION));
  Assert.assertTrue(options.shouldPreserve(FileAttribute.PERMISSION));
  Assert.assertTrue(options.shouldPreserve(FileAttribute.USER));
  Assert.assertTrue(options.shouldPreserve(FileAttribute.GROUP));
  Assert.assertTrue(options.shouldPreserve(FileAttribute.CHECKSUMTYPE));
  Assert.assertFalse(options.shouldPreserve(FileAttribute.ACL));
  Assert.assertFalse(options.shouldPreserve(FileAttribute.XATTR));
  options=OptionsParser.parse(new String[]{"-p","hdfs://localhost:8020/source/first","hdfs://localhost:8020/target/"});
  Assert.assertTrue(options.shouldPreserve(FileAttribute.BLOCKSIZE));
  Assert.assertTrue(options.shouldPreserve(FileAttribute.REPLICATION));
  Assert.assertTrue(options.shouldPreserve(FileAttribute.PERMISSION));
  Assert.assertTrue(options.shouldPreserve(FileAttribute.USER));
  Assert.assertTrue(options.shouldPreserve(FileAttribute.GROUP));
  Assert.assertTrue(options.shouldPreserve(FileAttribute.CHECKSUMTYPE));
  Assert.assertFalse(options.shouldPreserve(FileAttribute.ACL));
  Assert.assertFalse(options.shouldPreserve(FileAttribute.XATTR));
  options=OptionsParser.parse(new String[]{"-pbr","-f","hdfs://localhost:8020/source/first","hdfs://localhost:8020/target/"});
  Assert.assertTrue(options.shouldPreserve(FileAttribute.BLOCKSIZE));
  Assert.assertTrue(options.shouldPreserve(FileAttribute.REPLICATION));
  Assert.assertFalse(options.shouldPreserve(FileAttribute.PERMISSION));
  Assert.assertFalse(options.shouldPreserve(FileAttribute.USER));
  Assert.assertFalse(options.shouldPreserve(FileAttribute.GROUP));
  Assert.assertFalse(options.shouldPreserve(FileAttribute.CHECKSUMTYPE));
  Assert.assertFalse(options.shouldPreserve(FileAttribute.ACL));
  Assert.assertFalse(options.shouldPreserve(FileAttribute.XATTR));
  options=OptionsParser.parse(new String[]{"-pbrgup","-f","hdfs://localhost:8020/source/first","hdfs://localhost:8020/target/"});
  Assert.assertTrue(options.shouldPreserve(FileAttribute.BLOCKSIZE));
  Assert.assertTrue(options.shouldPreserve(FileAttribute.REPLICATION));
  Assert.assertTrue(options.shouldPreserve(FileAttribute.PERMISSION));
  Assert.assertTrue(options.shouldPreserve(FileAttribute.USER));
  Assert.assertTrue(options.shouldPreserve(FileAttribute.GROUP));
  Assert.assertFalse(options.shouldPreserve(FileAttribute.CHECKSUMTYPE));
  Assert.assertFalse(options.shouldPreserve(FileAttribute.ACL));
  Assert.assertFalse(options.shouldPreserve(FileAttribute.XATTR));
  options=OptionsParser.parse(new String[]{"-pbrgupcax","-f","hdfs://localhost:8020/source/first","hdfs://localhost:8020/target/"});
  Assert.assertTrue(options.shouldPreserve(FileAttribute.BLOCKSIZE));
  Assert.assertTrue(options.shouldPreserve(FileAttribute.REPLICATION));
  Assert.assertTrue(options.shouldPreserve(FileAttribute.PERMISSION));
  Assert.assertTrue(options.shouldPreserve(FileAttribute.USER));
  Assert.assertTrue(options.shouldPreserve(FileAttribute.GROUP));
  Assert.assertTrue(options.shouldPreserve(FileAttribute.CHECKSUMTYPE));
  Assert.assertTrue(options.shouldPreserve(FileAttribute.ACL));
  Assert.assertTrue(options.shouldPreserve(FileAttribute.XATTR));
  options=OptionsParser.parse(new String[]{"-pc","-f","hdfs://localhost:8020/source/first","hdfs://localhost:8020/target/"});
  Assert.assertFalse(options.shouldPreserve(FileAttribute.BLOCKSIZE));
  Assert.assertFalse(options.shouldPreserve(FileAttribute.REPLICATION));
  Assert.assertFalse(options.shouldPreserve(FileAttribute.PERMISSION));
  Assert.assertFalse(options.shouldPreserve(FileAttribute.USER));
  Assert.assertFalse(options.shouldPreserve(FileAttribute.GROUP));
  Assert.assertTrue(options.shouldPreserve(FileAttribute.CHECKSUMTYPE));
  Assert.assertFalse(options.shouldPreserve(FileAttribute.ACL));
  Assert.assertFalse(options.shouldPreserve(FileAttribute.XATTR));
  options=OptionsParser.parse(new String[]{"-p","-f","hdfs://localhost:8020/source/first","hdfs://localhost:8020/target/"});
  int i=0;
  Iterator<FileAttribute> attribIterator=options.preserveAttributes();
  while (attribIterator.hasNext()) {
    attribIterator.next();
    i++;
  }
  Assert.assertEquals(i,6);
  try {
    OptionsParser.parse(new String[]{"-pabcd","-f","hdfs://localhost:8020/source/first","hdfs://localhost:8020/target"});
    Assert.fail("Invalid preserve attribute");
  }
 catch (  IllegalArgumentException ignore) {
  }
catch (  NoSuchElementException ignore) {
  }
  options=OptionsParser.parse(new String[]{"-f","hdfs://localhost:8020/source/first","hdfs://localhost:8020/target/"});
  Assert.assertFalse(options.shouldPreserve(FileAttribute.PERMISSION));
  options.preserve(FileAttribute.PERMISSION);
  Assert.assertTrue(options.shouldPreserve(FileAttribute.PERMISSION));
  options.preserve(FileAttribute.PERMISSION);
  Assert.assertTrue(options.shouldPreserve(FileAttribute.PERMISSION));
}

</code></pre>

<br>
<pre class="type-2 type-7 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testAppendOption(){
  Configuration conf=new Configuration();
  Assert.assertFalse(conf.getBoolean(DistCpOptionSwitch.APPEND.getConfigLabel(),false));
  Assert.assertFalse(conf.getBoolean(DistCpOptionSwitch.SYNC_FOLDERS.getConfigLabel(),false));
  DistCpOptions options=OptionsParser.parse(new String[]{"-update","-append","hdfs://localhost:8020/source/first","hdfs://localhost:8020/target/"});
  options.appendToConf(conf);
  Assert.assertTrue(conf.getBoolean(DistCpOptionSwitch.APPEND.getConfigLabel(),false));
  Assert.assertTrue(conf.getBoolean(DistCpOptionSwitch.SYNC_FOLDERS.getConfigLabel(),false));
  try {
    options=OptionsParser.parse(new String[]{"-append","hdfs://localhost:8020/source/first","hdfs://localhost:8020/target/"});
    fail("Append should fail if update option is not specified");
  }
 catch (  IllegalArgumentException e) {
    GenericTestUtils.assertExceptionContains("Append is valid only with update options",e);
  }
  try {
    options=OptionsParser.parse(new String[]{"-append","-update","-skipcrccheck","hdfs://localhost:8020/source/first","hdfs://localhost:8020/target/"});
    fail("Append should fail if skipCrc option is specified");
  }
 catch (  IllegalArgumentException e) {
    GenericTestUtils.assertExceptionContains("Append is disallowed when skipping CRC",e);
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testMissingSourceInfo(){
  try {
    OptionsParser.parse(new String[]{"hdfs://localhost:8020/target/"});
    Assert.fail("Neither source listing not source paths present");
  }
 catch (  IllegalArgumentException ignore) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.tools.TestTools </h4><pre class="type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testDFSAdminInvalidUsageHelp(){
  ImmutableSet<String> args=ImmutableSet.of("-report","-saveNamespace","-rollEdits","-restoreFailedStorage","-refreshNodes","-finalizeUpgrade","-metasave","-refreshUserToGroupsMappings","-printTopology","-refreshNamenodes","-deleteBlockPool","-setBalancerBandwidth","-fetchImage");
  try {
    for (    String arg : args)     assertTrue(ToolRunner.run(new DFSAdmin(),fillArgs(arg)) == -1);
    assertTrue(ToolRunner.run(new DFSAdmin(),new String[]{"-help","-some"}) == 0);
  }
 catch (  Exception e) {
    fail("testDFSAdminHelp error" + e);
  }
  String pattern="Usage: java DFSAdmin";
  checkOutput(new String[]{"-cancel","-renew"},pattern,System.err,DFSAdmin.class);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.tools.mapred.TestCopyCommitter </h4><pre class="type-9 type-11 type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testDeleteMissingFlatInterleavedFiles(){
  TaskAttemptContext taskAttemptContext=getTaskAttemptContext(config);
  JobContext jobContext=new JobContextImpl(taskAttemptContext.getConfiguration(),taskAttemptContext.getTaskAttemptID().getJobID());
  Configuration conf=jobContext.getConfiguration();
  String sourceBase;
  String targetBase;
  FileSystem fs=null;
  try {
    OutputCommitter committer=new CopyCommitter(null,taskAttemptContext);
    fs=FileSystem.get(conf);
    sourceBase="/tmp1/" + String.valueOf(rand.nextLong());
    targetBase="/tmp1/" + String.valueOf(rand.nextLong());
    TestDistCpUtils.createFile(fs,sourceBase + "/1");
    TestDistCpUtils.createFile(fs,sourceBase + "/3");
    TestDistCpUtils.createFile(fs,sourceBase + "/4");
    TestDistCpUtils.createFile(fs,sourceBase + "/5");
    TestDistCpUtils.createFile(fs,sourceBase + "/7");
    TestDistCpUtils.createFile(fs,sourceBase + "/8");
    TestDistCpUtils.createFile(fs,sourceBase + "/9");
    TestDistCpUtils.createFile(fs,targetBase + "/2");
    TestDistCpUtils.createFile(fs,targetBase + "/4");
    TestDistCpUtils.createFile(fs,targetBase + "/5");
    TestDistCpUtils.createFile(fs,targetBase + "/7");
    TestDistCpUtils.createFile(fs,targetBase + "/9");
    TestDistCpUtils.createFile(fs,targetBase + "/A");
    DistCpOptions options=new DistCpOptions(Arrays.asList(new Path(sourceBase)),new Path("/out"));
    options.setSyncFolder(true);
    options.setDeleteMissing(true);
    options.appendToConf(conf);
    CopyListing listing=new GlobbedCopyListing(conf,CREDENTIALS);
    Path listingFile=new Path("/tmp1/" + String.valueOf(rand.nextLong()));
    listing.buildListing(listingFile,options);
    conf.set(DistCpConstants.CONF_LABEL_TARGET_WORK_PATH,targetBase);
    conf.set(DistCpConstants.CONF_LABEL_TARGET_FINAL_PATH,targetBase);
    committer.commitJob(jobContext);
    if (!TestDistCpUtils.checkIfFoldersAreInSync(fs,targetBase,sourceBase)) {
      Assert.fail("Source and target folders are not in sync");
    }
    Assert.assertEquals(fs.listStatus(new Path(targetBase)).length,4);
    committer.commitJob(jobContext);
    if (!TestDistCpUtils.checkIfFoldersAreInSync(fs,targetBase,sourceBase)) {
      Assert.fail("Source and target folders are not in sync");
    }
    Assert.assertEquals(fs.listStatus(new Path(targetBase)).length,4);
  }
 catch (  IOException e) {
    LOG.error("Exception encountered while testing for delete missing",e);
    Assert.fail("Delete missing failure");
  }
 finally {
    TestDistCpUtils.delete(fs,"/tmp1");
    conf.set(DistCpConstants.CONF_LABEL_DELETE_MISSING,"false");
  }
}

</code></pre>

<br>
<pre class="type-9 type-2 type-7 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testAtomicCommitExistingFinal(){
  TaskAttemptContext taskAttemptContext=getTaskAttemptContext(config);
  JobContext jobContext=new JobContextImpl(taskAttemptContext.getConfiguration(),taskAttemptContext.getTaskAttemptID().getJobID());
  Configuration conf=jobContext.getConfiguration();
  String workPath="/tmp1/" + String.valueOf(rand.nextLong());
  String finalPath="/tmp1/" + String.valueOf(rand.nextLong());
  FileSystem fs=null;
  try {
    OutputCommitter committer=new CopyCommitter(null,taskAttemptContext);
    fs=FileSystem.get(conf);
    fs.mkdirs(new Path(workPath));
    fs.mkdirs(new Path(finalPath));
    conf.set(DistCpConstants.CONF_LABEL_TARGET_WORK_PATH,workPath);
    conf.set(DistCpConstants.CONF_LABEL_TARGET_FINAL_PATH,finalPath);
    conf.setBoolean(DistCpConstants.CONF_LABEL_ATOMIC_COPY,true);
    Assert.assertTrue(fs.exists(new Path(workPath)));
    Assert.assertTrue(fs.exists(new Path(finalPath)));
    try {
      committer.commitJob(jobContext);
      Assert.fail("Should not be able to atomic-commit to pre-existing path.");
    }
 catch (    Exception exception) {
      Assert.assertTrue(fs.exists(new Path(workPath)));
      Assert.assertTrue(fs.exists(new Path(finalPath)));
      LOG.info("Atomic-commit Test pass.");
    }
  }
 catch (  IOException e) {
    LOG.error("Exception encountered while testing for atomic commit.",e);
    Assert.fail("Atomic commit failure");
  }
 finally {
    TestDistCpUtils.delete(fs,workPath);
    TestDistCpUtils.delete(fs,finalPath);
    conf.setBoolean(DistCpConstants.CONF_LABEL_ATOMIC_COPY,false);
  }
}

</code></pre>

<br>
<pre class="type-11 type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testPreserveStatus(){
  TaskAttemptContext taskAttemptContext=getTaskAttemptContext(config);
  JobContext jobContext=new JobContextImpl(taskAttemptContext.getConfiguration(),taskAttemptContext.getTaskAttemptID().getJobID());
  Configuration conf=jobContext.getConfiguration();
  String sourceBase;
  String targetBase;
  FileSystem fs=null;
  try {
    OutputCommitter committer=new CopyCommitter(null,taskAttemptContext);
    fs=FileSystem.get(conf);
    FsPermission sourcePerm=new FsPermission((short)511);
    FsPermission initialPerm=new FsPermission((short)448);
    sourceBase=TestDistCpUtils.createTestSetup(fs,sourcePerm);
    targetBase=TestDistCpUtils.createTestSetup(fs,initialPerm);
    DistCpOptions options=new DistCpOptions(Arrays.asList(new Path(sourceBase)),new Path("/out"));
    options.preserve(FileAttribute.PERMISSION);
    options.appendToConf(conf);
    options.setTargetPathExists(false);
    CopyListing listing=new GlobbedCopyListing(conf,CREDENTIALS);
    Path listingFile=new Path("/tmp1/" + String.valueOf(rand.nextLong()));
    listing.buildListing(listingFile,options);
    conf.set(DistCpConstants.CONF_LABEL_TARGET_WORK_PATH,targetBase);
    committer.commitJob(jobContext);
    if (!checkDirectoryPermissions(fs,targetBase,sourcePerm)) {
      Assert.fail("Permission don't match");
    }
    committer.commitJob(jobContext);
    if (!checkDirectoryPermissions(fs,targetBase,sourcePerm)) {
      Assert.fail("Permission don't match");
    }
  }
 catch (  IOException e) {
    LOG.error("Exception encountered while testing for preserve status",e);
    Assert.fail("Preserve status failure");
  }
 finally {
    TestDistCpUtils.delete(fs,"/tmp1");
    conf.unset(DistCpConstants.CONF_LABEL_PRESERVE_STATUS);
  }
}

</code></pre>

<br>
<pre class="type-8 type-2 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Allocates resources before the execution of the test cases">TestInitializer</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Allocates resources before the execution of the test cases
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Before public void createMetaFolder(){
  config.set(DistCpConstants.CONF_LABEL_META_FOLDER,"/meta");
  Path meta=new Path("/meta");
  try {
    cluster.getFileSystem().mkdirs(meta);
  }
 catch (  IOException e) {
    LOG.error("Exception encountered while creating meta folder",e);
    Assert.fail("Unable to create meta folder");
  }
}

</code></pre>

<br>
<pre class="type-9 type-2 type-7 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testAtomicCommitMissingFinal(){
  TaskAttemptContext taskAttemptContext=getTaskAttemptContext(config);
  JobContext jobContext=new JobContextImpl(taskAttemptContext.getConfiguration(),taskAttemptContext.getTaskAttemptID().getJobID());
  Configuration conf=jobContext.getConfiguration();
  String workPath="/tmp1/" + String.valueOf(rand.nextLong());
  String finalPath="/tmp1/" + String.valueOf(rand.nextLong());
  FileSystem fs=null;
  try {
    OutputCommitter committer=new CopyCommitter(null,taskAttemptContext);
    fs=FileSystem.get(conf);
    fs.mkdirs(new Path(workPath));
    conf.set(DistCpConstants.CONF_LABEL_TARGET_WORK_PATH,workPath);
    conf.set(DistCpConstants.CONF_LABEL_TARGET_FINAL_PATH,finalPath);
    conf.setBoolean(DistCpConstants.CONF_LABEL_ATOMIC_COPY,true);
    Assert.assertTrue(fs.exists(new Path(workPath)));
    Assert.assertFalse(fs.exists(new Path(finalPath)));
    committer.commitJob(jobContext);
    Assert.assertFalse(fs.exists(new Path(workPath)));
    Assert.assertTrue(fs.exists(new Path(finalPath)));
    committer.commitJob(jobContext);
    Assert.assertFalse(fs.exists(new Path(workPath)));
    Assert.assertTrue(fs.exists(new Path(finalPath)));
  }
 catch (  IOException e) {
    LOG.error("Exception encountered while testing for preserve status",e);
    Assert.fail("Atomic commit failure");
  }
 finally {
    TestDistCpUtils.delete(fs,workPath);
    TestDistCpUtils.delete(fs,finalPath);
    conf.setBoolean(DistCpConstants.CONF_LABEL_ATOMIC_COPY,false);
  }
}

</code></pre>

<br>
<pre class="type-11 type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testDeleteMissing(){
  TaskAttemptContext taskAttemptContext=getTaskAttemptContext(config);
  JobContext jobContext=new JobContextImpl(taskAttemptContext.getConfiguration(),taskAttemptContext.getTaskAttemptID().getJobID());
  Configuration conf=jobContext.getConfiguration();
  String sourceBase;
  String targetBase;
  FileSystem fs=null;
  try {
    OutputCommitter committer=new CopyCommitter(null,taskAttemptContext);
    fs=FileSystem.get(conf);
    sourceBase=TestDistCpUtils.createTestSetup(fs,FsPermission.getDefault());
    targetBase=TestDistCpUtils.createTestSetup(fs,FsPermission.getDefault());
    String targetBaseAdd=TestDistCpUtils.createTestSetup(fs,FsPermission.getDefault());
    fs.rename(new Path(targetBaseAdd),new Path(targetBase));
    DistCpOptions options=new DistCpOptions(Arrays.asList(new Path(sourceBase)),new Path("/out"));
    options.setSyncFolder(true);
    options.setDeleteMissing(true);
    options.appendToConf(conf);
    CopyListing listing=new GlobbedCopyListing(conf,CREDENTIALS);
    Path listingFile=new Path("/tmp1/" + String.valueOf(rand.nextLong()));
    listing.buildListing(listingFile,options);
    conf.set(DistCpConstants.CONF_LABEL_TARGET_WORK_PATH,targetBase);
    conf.set(DistCpConstants.CONF_LABEL_TARGET_FINAL_PATH,targetBase);
    committer.commitJob(jobContext);
    if (!TestDistCpUtils.checkIfFoldersAreInSync(fs,targetBase,sourceBase)) {
      Assert.fail("Source and target folders are not in sync");
    }
    if (!TestDistCpUtils.checkIfFoldersAreInSync(fs,sourceBase,targetBase)) {
      Assert.fail("Source and target folders are not in sync");
    }
    committer.commitJob(jobContext);
    if (!TestDistCpUtils.checkIfFoldersAreInSync(fs,targetBase,sourceBase)) {
      Assert.fail("Source and target folders are not in sync");
    }
    if (!TestDistCpUtils.checkIfFoldersAreInSync(fs,sourceBase,targetBase)) {
      Assert.fail("Source and target folders are not in sync");
    }
  }
 catch (  Throwable e) {
    LOG.error("Exception encountered while testing for delete missing",e);
    Assert.fail("Delete missing failure");
  }
 finally {
    TestDistCpUtils.delete(fs,"/tmp1");
    conf.set(DistCpConstants.CONF_LABEL_DELETE_MISSING,"false");
  }
}

</code></pre>

<br>
<pre class="type-9 type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testNoCommitAction(){
  TaskAttemptContext taskAttemptContext=getTaskAttemptContext(config);
  JobContext jobContext=new JobContextImpl(taskAttemptContext.getConfiguration(),taskAttemptContext.getTaskAttemptID().getJobID());
  try {
    OutputCommitter committer=new CopyCommitter(null,taskAttemptContext);
    committer.commitJob(jobContext);
    Assert.assertEquals(taskAttemptContext.getStatus(),"Commit Successful");
    committer.commitJob(jobContext);
    Assert.assertEquals(taskAttemptContext.getStatus(),"Commit Successful");
  }
 catch (  IOException e) {
    LOG.error("Exception encountered ",e);
    Assert.fail("Commit failed");
  }
}

</code></pre>

<br>
<pre class="type-4 type-11 type-2 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Releases resources used by the test cases">TestCleaner</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Releases resources used by the test cases
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@After public void cleanupMetaFolder(){
  Path meta=new Path("/meta");
  try {
    if (cluster.getFileSystem().exists(meta)) {
      cluster.getFileSystem().delete(meta,true);
      Assert.fail("Expected meta folder to be deleted");
    }
  }
 catch (  IOException e) {
    LOG.error("Exception encountered while cleaning up folder",e);
    Assert.fail("Unable to clean up meta folder");
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.tools.mapred.TestCopyMapper </h4><pre class="type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=40000) public void testCopyFailOnBlockSizeDifference(){
  try {
    deleteState();
    createSourceDataWithDifferentBlockSize();
    FileSystem fs=cluster.getFileSystem();
    CopyMapper copyMapper=new CopyMapper();
    StubContext stubContext=new StubContext(getConfiguration(),null,0);
    Mapper<Text,CopyListingFileStatus,Text,Text>.Context context=stubContext.getContext();
    Configuration configuration=context.getConfiguration();
    EnumSet<DistCpOptions.FileAttribute> fileAttributes=EnumSet.noneOf(DistCpOptions.FileAttribute.class);
    configuration.set(DistCpOptionSwitch.PRESERVE_STATUS.getConfigLabel(),DistCpUtils.packAttributes(fileAttributes));
    copyMapper.setup(context);
    for (    Path path : pathList) {
      final FileStatus fileStatus=fs.getFileStatus(path);
      copyMapper.map(new Text(DistCpUtils.getRelativePath(new Path(SOURCE_PATH),path)),new CopyListingFileStatus(fileStatus),context);
    }
    Assert.fail("Copy should have failed because of block-size difference.");
  }
 catch (  Exception exception) {
    Assert.assertTrue("Failure exception should have suggested the use of -pb.",exception.getCause().getCause().getMessage().contains("pb"));
    Assert.assertTrue("Failure exception should have suggested the use of -skipCrc.",exception.getCause().getCause().getMessage().contains("skipCrc"));
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test(timeout=40000) public void testFailCopyWithAccessControlException(){
  try {
    deleteState();
    createSourceData();
    UserGroupInformation tmpUser=UserGroupInformation.createRemoteUser("guest");
    final CopyMapper copyMapper=new CopyMapper();
    final StubContext stubContext=tmpUser.doAs(new PrivilegedAction<StubContext>(){
      @Override public StubContext run(){
        try {
          return new StubContext(getConfiguration(),null,0);
        }
 catch (        Exception e) {
          LOG.error("Exception encountered ",e);
          throw new RuntimeException(e);
        }
      }
    }
);
    EnumSet<DistCpOptions.FileAttribute> preserveStatus=EnumSet.allOf(DistCpOptions.FileAttribute.class);
    preserveStatus.remove(DistCpOptions.FileAttribute.ACL);
    preserveStatus.remove(DistCpOptions.FileAttribute.XATTR);
    final Mapper<Text,CopyListingFileStatus,Text,Text>.Context context=stubContext.getContext();
    context.getConfiguration().set(DistCpConstants.CONF_LABEL_PRESERVE_STATUS,DistCpUtils.packAttributes(preserveStatus));
    touchFile(SOURCE_PATH + "/src/file");
    OutputStream out=cluster.getFileSystem().create(new Path(TARGET_PATH + "/src/file"));
    out.write("hello world".getBytes());
    out.close();
    cluster.getFileSystem().setPermission(new Path(SOURCE_PATH + "/src/file"),new FsPermission(FsAction.READ,FsAction.READ,FsAction.READ));
    cluster.getFileSystem().setPermission(new Path(TARGET_PATH + "/src/file"),new FsPermission(FsAction.READ,FsAction.READ,FsAction.READ));
    final FileSystem tmpFS=tmpUser.doAs(new PrivilegedAction<FileSystem>(){
      @Override public FileSystem run(){
        try {
          return FileSystem.get(configuration);
        }
 catch (        IOException e) {
          LOG.error("Exception encountered ",e);
          Assert.fail("Test failed: " + e.getMessage());
          throw new RuntimeException("Test ought to fail here");
        }
      }
    }
);
    tmpUser.doAs(new PrivilegedAction<Integer>(){
      @Override public Integer run(){
        try {
          copyMapper.setup(context);
          copyMapper.map(new Text("/src/file"),new CopyListingFileStatus(tmpFS.getFileStatus(new Path(SOURCE_PATH + "/src/file"))),context);
          Assert.fail("Didn't expect the file to be copied");
        }
 catch (        AccessControlException ignore) {
        }
catch (        Exception e) {
          if (e.getCause() == null || e.getCause().getCause() == null || !(e.getCause().getCause() instanceof AccessControlException)) {
            throw new RuntimeException(e);
          }
        }
        return null;
      }
    }
);
  }
 catch (  Exception e) {
    LOG.error("Exception encountered ",e);
    Assert.fail("Test failed: " + e.getMessage());
  }
}

</code></pre>

<br>
<pre class="type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=40000) public void testDirToFile(){
  try {
    deleteState();
    createSourceData();
    FileSystem fs=cluster.getFileSystem();
    CopyMapper copyMapper=new CopyMapper();
    StubContext stubContext=new StubContext(getConfiguration(),null,0);
    Mapper<Text,CopyListingFileStatus,Text,Text>.Context context=stubContext.getContext();
    mkdirs(SOURCE_PATH + "/src/file");
    touchFile(TARGET_PATH + "/src/file");
    try {
      copyMapper.setup(context);
      copyMapper.map(new Text("/src/file"),new CopyListingFileStatus(fs.getFileStatus(new Path(SOURCE_PATH + "/src/file"))),context);
    }
 catch (    IOException e) {
      Assert.assertTrue(e.getMessage().startsWith("Can't replace"));
    }
  }
 catch (  Exception e) {
    LOG.error("Exception encountered ",e);
    Assert.fail("Test failed: " + e.getMessage());
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-10 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=40000) public void testSkipCopyNoPerms(){
  try {
    deleteState();
    createSourceData();
    UserGroupInformation tmpUser=UserGroupInformation.createRemoteUser("guest");
    final CopyMapper copyMapper=new CopyMapper();
    final StubContext stubContext=tmpUser.doAs(new PrivilegedAction<StubContext>(){
      @Override public StubContext run(){
        try {
          return new StubContext(getConfiguration(),null,0);
        }
 catch (        Exception e) {
          LOG.error("Exception encountered ",e);
          throw new RuntimeException(e);
        }
      }
    }
);
    final Mapper<Text,CopyListingFileStatus,Text,Text>.Context context=stubContext.getContext();
    EnumSet<DistCpOptions.FileAttribute> preserveStatus=EnumSet.allOf(DistCpOptions.FileAttribute.class);
    preserveStatus.remove(DistCpOptions.FileAttribute.ACL);
    preserveStatus.remove(DistCpOptions.FileAttribute.XATTR);
    context.getConfiguration().set(DistCpConstants.CONF_LABEL_PRESERVE_STATUS,DistCpUtils.packAttributes(preserveStatus));
    touchFile(SOURCE_PATH + "/src/file");
    touchFile(TARGET_PATH + "/src/file");
    cluster.getFileSystem().setPermission(new Path(SOURCE_PATH + "/src/file"),new FsPermission(FsAction.READ,FsAction.READ,FsAction.READ));
    cluster.getFileSystem().setPermission(new Path(TARGET_PATH + "/src/file"),new FsPermission(FsAction.READ,FsAction.READ,FsAction.READ));
    final FileSystem tmpFS=tmpUser.doAs(new PrivilegedAction<FileSystem>(){
      @Override public FileSystem run(){
        try {
          return FileSystem.get(configuration);
        }
 catch (        IOException e) {
          LOG.error("Exception encountered ",e);
          Assert.fail("Test failed: " + e.getMessage());
          throw new RuntimeException("Test ought to fail here");
        }
      }
    }
);
    tmpUser.doAs(new PrivilegedAction<Integer>(){
      @Override public Integer run(){
        try {
          copyMapper.setup(context);
          copyMapper.map(new Text("/src/file"),new CopyListingFileStatus(tmpFS.getFileStatus(new Path(SOURCE_PATH + "/src/file"))),context);
          Assert.assertEquals(stubContext.getWriter().values().size(),1);
          Assert.assertTrue(stubContext.getWriter().values().get(0).toString().startsWith("SKIP"));
          Assert.assertTrue(stubContext.getWriter().values().get(0).toString().contains(SOURCE_PATH + "/src/file"));
        }
 catch (        Exception e) {
          throw new RuntimeException(e);
        }
        return null;
      }
    }
);
  }
 catch (  Exception e) {
    LOG.error("Exception encountered ",e);
    Assert.fail("Test failed: " + e.getMessage());
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test(timeout=40000) public void testCopyReadableFiles(){
  try {
    deleteState();
    createSourceData();
    UserGroupInformation tmpUser=UserGroupInformation.createRemoteUser("guest");
    final CopyMapper copyMapper=new CopyMapper();
    final Mapper<Text,CopyListingFileStatus,Text,Text>.Context context=tmpUser.doAs(new PrivilegedAction<Mapper<Text,CopyListingFileStatus,Text,Text>.Context>(){
      @Override public Mapper<Text,CopyListingFileStatus,Text,Text>.Context run(){
        try {
          StubContext stubContext=new StubContext(getConfiguration(),null,0);
          return stubContext.getContext();
        }
 catch (        Exception e) {
          LOG.error("Exception encountered ",e);
          throw new RuntimeException(e);
        }
      }
    }
);
    touchFile(SOURCE_PATH + "/src/file");
    mkdirs(TARGET_PATH);
    cluster.getFileSystem().setPermission(new Path(SOURCE_PATH + "/src/file"),new FsPermission(FsAction.READ,FsAction.READ,FsAction.READ));
    cluster.getFileSystem().setPermission(new Path(TARGET_PATH),new FsPermission((short)511));
    final FileSystem tmpFS=tmpUser.doAs(new PrivilegedAction<FileSystem>(){
      @Override public FileSystem run(){
        try {
          return FileSystem.get(configuration);
        }
 catch (        IOException e) {
          LOG.error("Exception encountered ",e);
          Assert.fail("Test failed: " + e.getMessage());
          throw new RuntimeException("Test ought to fail here");
        }
      }
    }
);
    tmpUser.doAs(new PrivilegedAction<Integer>(){
      @Override public Integer run(){
        try {
          copyMapper.setup(context);
          copyMapper.map(new Text("/src/file"),new CopyListingFileStatus(tmpFS.getFileStatus(new Path(SOURCE_PATH + "/src/file"))),context);
        }
 catch (        Exception e) {
          throw new RuntimeException(e);
        }
        return null;
      }
    }
);
  }
 catch (  Exception e) {
    LOG.error("Exception encountered ",e);
    Assert.fail("Test failed: " + e.getMessage());
  }
}

</code></pre>

<br>
<pre class="type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=40000) public void testPreserve(){
  try {
    deleteState();
    createSourceData();
    UserGroupInformation tmpUser=UserGroupInformation.createRemoteUser("guest");
    final CopyMapper copyMapper=new CopyMapper();
    final Mapper<Text,CopyListingFileStatus,Text,Text>.Context context=tmpUser.doAs(new PrivilegedAction<Mapper<Text,CopyListingFileStatus,Text,Text>.Context>(){
      @Override public Mapper<Text,CopyListingFileStatus,Text,Text>.Context run(){
        try {
          StubContext stubContext=new StubContext(getConfiguration(),null,0);
          return stubContext.getContext();
        }
 catch (        Exception e) {
          LOG.error("Exception encountered ",e);
          throw new RuntimeException(e);
        }
      }
    }
);
    EnumSet<DistCpOptions.FileAttribute> preserveStatus=EnumSet.allOf(DistCpOptions.FileAttribute.class);
    preserveStatus.remove(DistCpOptions.FileAttribute.ACL);
    preserveStatus.remove(DistCpOptions.FileAttribute.XATTR);
    context.getConfiguration().set(DistCpConstants.CONF_LABEL_PRESERVE_STATUS,DistCpUtils.packAttributes(preserveStatus));
    touchFile(SOURCE_PATH + "/src/file");
    mkdirs(TARGET_PATH);
    cluster.getFileSystem().setPermission(new Path(TARGET_PATH),new FsPermission((short)511));
    final FileSystem tmpFS=tmpUser.doAs(new PrivilegedAction<FileSystem>(){
      @Override public FileSystem run(){
        try {
          return FileSystem.get(configuration);
        }
 catch (        IOException e) {
          LOG.error("Exception encountered ",e);
          Assert.fail("Test failed: " + e.getMessage());
          throw new RuntimeException("Test ought to fail here");
        }
      }
    }
);
    tmpUser.doAs(new PrivilegedAction<Integer>(){
      @Override public Integer run(){
        try {
          copyMapper.setup(context);
          copyMapper.map(new Text("/src/file"),new CopyListingFileStatus(tmpFS.getFileStatus(new Path(SOURCE_PATH + "/src/file"))),context);
          Assert.fail("Expected copy to fail");
        }
 catch (        AccessControlException e) {
          Assert.assertTrue("Got exception: " + e.getMessage(),true);
        }
catch (        Exception e) {
          throw new RuntimeException(e);
        }
        return null;
      }
    }
);
  }
 catch (  Exception e) {
    LOG.error("Exception encountered ",e);
    Assert.fail("Test failed: " + e.getMessage());
  }
}

</code></pre>

<br>
<pre class="type-9 type-2 type-7 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * If a single file is being copied to a location where the file (of the same
 * name) already exists, then the file shouldn't be skipped.
 */
@Test(timeout=40000) public void testSingleFileCopy(){
  try {
    deleteState();
    touchFile(SOURCE_PATH + "/1");
    Path sourceFilePath=pathList.get(0);
    Path targetFilePath=new Path(sourceFilePath.toString().replaceAll(SOURCE_PATH,TARGET_PATH));
    touchFile(targetFilePath.toString());
    FileSystem fs=cluster.getFileSystem();
    CopyMapper copyMapper=new CopyMapper();
    StubContext stubContext=new StubContext(getConfiguration(),null,0);
    Mapper<Text,CopyListingFileStatus,Text,Text>.Context context=stubContext.getContext();
    context.getConfiguration().set(DistCpConstants.CONF_LABEL_TARGET_FINAL_PATH,targetFilePath.getParent().toString());
    copyMapper.setup(context);
    final CopyListingFileStatus sourceFileStatus=new CopyListingFileStatus(fs.getFileStatus(sourceFilePath));
    long before=fs.getFileStatus(targetFilePath).getModificationTime();
    copyMapper.map(new Text(DistCpUtils.getRelativePath(new Path(SOURCE_PATH),sourceFilePath)),sourceFileStatus,context);
    long after=fs.getFileStatus(targetFilePath).getModificationTime();
    Assert.assertTrue("File should have been skipped",before == after);
    context.getConfiguration().set(DistCpConstants.CONF_LABEL_TARGET_FINAL_PATH,targetFilePath.toString());
    copyMapper.setup(context);
    before=fs.getFileStatus(targetFilePath).getModificationTime();
    try {
      Thread.sleep(2);
    }
 catch (    Throwable ignore) {
    }
    copyMapper.map(new Text(DistCpUtils.getRelativePath(new Path(SOURCE_PATH),sourceFilePath)),sourceFileStatus,context);
    after=fs.getFileStatus(targetFilePath).getModificationTime();
    Assert.assertTrue("File should have been overwritten.",before < after);
  }
 catch (  Exception exception) {
    Assert.fail("Unexpected exception: " + exception.getMessage());
    exception.printStackTrace();
  }
}

</code></pre>

<br>
<pre class="type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=40000) public void testFileToDir(){
  try {
    deleteState();
    createSourceData();
    FileSystem fs=cluster.getFileSystem();
    CopyMapper copyMapper=new CopyMapper();
    StubContext stubContext=new StubContext(getConfiguration(),null,0);
    Mapper<Text,CopyListingFileStatus,Text,Text>.Context context=stubContext.getContext();
    touchFile(SOURCE_PATH + "/src/file");
    mkdirs(TARGET_PATH + "/src/file");
    try {
      copyMapper.setup(context);
      copyMapper.map(new Text("/src/file"),new CopyListingFileStatus(fs.getFileStatus(new Path(SOURCE_PATH + "/src/file"))),context);
    }
 catch (    IOException e) {
      Assert.assertTrue(e.getMessage().startsWith("Can't replace"));
    }
  }
 catch (  Exception e) {
    LOG.error("Exception encountered ",e);
    Assert.fail("Test failed: " + e.getMessage());
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.tools.mapred.TestCopyOutputFormat </h4><pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testSetWorkingDirectory(){
  try {
    Job job=Job.getInstance(new Configuration());
    Assert.assertEquals(null,CopyOutputFormat.getWorkingDirectory(job));
    job.getConfiguration().set(DistCpConstants.CONF_LABEL_TARGET_WORK_PATH,"");
    Assert.assertEquals(null,CopyOutputFormat.getWorkingDirectory(job));
    Path directory=new Path("/tmp/test");
    CopyOutputFormat.setWorkingDirectory(job,directory);
    Assert.assertEquals(directory,CopyOutputFormat.getWorkingDirectory(job));
    Assert.assertEquals(directory.toString(),job.getConfiguration().get(DistCpConstants.CONF_LABEL_TARGET_WORK_PATH));
  }
 catch (  IOException e) {
    LOG.error("Exception encountered while running test",e);
    Assert.fail("Failed while testing for set Working Directory");
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testSetCommitDirectory(){
  try {
    Job job=Job.getInstance(new Configuration());
    Assert.assertEquals(null,CopyOutputFormat.getCommitDirectory(job));
    job.getConfiguration().set(DistCpConstants.CONF_LABEL_TARGET_FINAL_PATH,"");
    Assert.assertEquals(null,CopyOutputFormat.getCommitDirectory(job));
    Path directory=new Path("/tmp/test");
    CopyOutputFormat.setCommitDirectory(job,directory);
    Assert.assertEquals(directory,CopyOutputFormat.getCommitDirectory(job));
    Assert.assertEquals(directory.toString(),job.getConfiguration().get(DistCpConstants.CONF_LABEL_TARGET_FINAL_PATH));
  }
 catch (  IOException e) {
    LOG.error("Exception encountered while running test",e);
    Assert.fail("Failed while testing for set Commit Directory");
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testGetOutputCommitter(){
  try {
    TaskAttemptContext context=new TaskAttemptContextImpl(new Configuration(),new TaskAttemptID("200707121733",1,TaskType.MAP,1,1));
    context.getConfiguration().set("mapred.output.dir","/out");
    Assert.assertTrue(new CopyOutputFormat().getOutputCommitter(context) instanceof CopyCommitter);
  }
 catch (  IOException e) {
    LOG.error("Exception encountered ",e);
    Assert.fail("Unable to get output committer");
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testCheckOutputSpecs(){
  try {
    OutputFormat outputFormat=new CopyOutputFormat();
    Job job=Job.getInstance(new Configuration());
    JobID jobID=new JobID("200707121733",1);
    try {
      JobContext context=new JobContextImpl(job.getConfiguration(),jobID);
      outputFormat.checkOutputSpecs(context);
      Assert.fail("No checking for invalid work/commit path");
    }
 catch (    IllegalStateException ignore) {
    }
    CopyOutputFormat.setWorkingDirectory(job,new Path("/tmp/work"));
    try {
      JobContext context=new JobContextImpl(job.getConfiguration(),jobID);
      outputFormat.checkOutputSpecs(context);
      Assert.fail("No checking for invalid commit path");
    }
 catch (    IllegalStateException ignore) {
    }
    job.getConfiguration().set(DistCpConstants.CONF_LABEL_TARGET_WORK_PATH,"");
    CopyOutputFormat.setCommitDirectory(job,new Path("/tmp/commit"));
    try {
      JobContext context=new JobContextImpl(job.getConfiguration(),jobID);
      outputFormat.checkOutputSpecs(context);
      Assert.fail("No checking for invalid work path");
    }
 catch (    IllegalStateException ignore) {
    }
    CopyOutputFormat.setWorkingDirectory(job,new Path("/tmp/work"));
    CopyOutputFormat.setCommitDirectory(job,new Path("/tmp/commit"));
    try {
      JobContext context=new JobContextImpl(job.getConfiguration(),jobID);
      outputFormat.checkOutputSpecs(context);
    }
 catch (    IllegalStateException ignore) {
      Assert.fail("Output spec check failed.");
    }
  }
 catch (  IOException e) {
    LOG.error("Exception encountered while testing checkoutput specs",e);
    Assert.fail("Checkoutput Spec failure");
  }
catch (  InterruptedException e) {
    LOG.error("Exception encountered while testing checkoutput specs",e);
    Assert.fail("Checkoutput Spec failure");
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.tools.rumen.TestHistograms </h4><pre class="type-9 type-13 type-11 type-2 type-7 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions in iterations
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * @throws IOExceptionThere should be files in the directory named by
 * ${test.build.data}/rumen/histogram-test .
 * There will be pairs of files, inputXxx.json and goldXxx.json .
 * We read the input file as a HistogramRawTestData in json. Then we
 * create a Histogram using the data field, and then a
 * LoggedDiscreteCDF using the percentiles and scale field. Finally,
 * we read the corresponding goldXxx.json as a LoggedDiscreteCDF and
 * deepCompare them.
 */
@Test public void testHistograms() throws IOException {
  final Configuration conf=new Configuration();
  final FileSystem lfs=FileSystem.getLocal(conf);
  final Path rootInputDir=new Path(System.getProperty("test.tools.input.dir","")).makeQualified(lfs);
  final Path rootInputFile=new Path(rootInputDir,"rumen/histogram-tests");
  FileStatus[] tests=lfs.listStatus(rootInputFile);
  for (int i=0; i < tests.length; ++i) {
    Path filePath=tests[i].getPath();
    String fileName=filePath.getName();
    if (fileName.startsWith("input")) {
      String testName=fileName.substring("input".length());
      Path goldFilePath=new Path(rootInputFile,"gold" + testName);
      assertTrue("Gold file dies not exist",lfs.exists(goldFilePath));
      LoggedDiscreteCDF newResult=histogramFileToCDF(filePath,lfs);
      System.out.println("Testing a Histogram for " + fileName);
      FSDataInputStream goldStream=lfs.open(goldFilePath);
      JsonObjectMapperParser<LoggedDiscreteCDF> parser=new JsonObjectMapperParser<LoggedDiscreteCDF>(goldStream,LoggedDiscreteCDF.class);
      try {
        LoggedDiscreteCDF dcdf=parser.getNext();
        dcdf.deepCompare(newResult,new TreePath(null,"<root>"));
      }
 catch (      DeepInequalityException e) {
        fail(e.path.toString());
      }
 finally {
        parser.close();
      }
    }
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.tools.util.TestDistCpUtils </h4><pre class="type-9 type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testPreserve(){
  try {
    FileSystem fs=FileSystem.get(config);
    EnumSet<FileAttribute> attributes=EnumSet.noneOf(FileAttribute.class);
    Path path=new Path("/tmp/abc");
    Path src=new Path("/tmp/src");
    fs.mkdirs(path);
    fs.mkdirs(src);
    CopyListingFileStatus srcStatus=new CopyListingFileStatus(fs.getFileStatus(src));
    FsPermission noPerm=new FsPermission((short)0);
    fs.setPermission(path,noPerm);
    fs.setOwner(path,"nobody","nobody");
    DistCpUtils.preserve(fs,path,srcStatus,attributes,false);
    FileStatus target=fs.getFileStatus(path);
    Assert.assertEquals(target.getPermission(),noPerm);
    Assert.assertEquals(target.getOwner(),"nobody");
    Assert.assertEquals(target.getGroup(),"nobody");
    attributes.add(FileAttribute.PERMISSION);
    DistCpUtils.preserve(fs,path,srcStatus,attributes,false);
    target=fs.getFileStatus(path);
    Assert.assertEquals(target.getPermission(),srcStatus.getPermission());
    Assert.assertEquals(target.getOwner(),"nobody");
    Assert.assertEquals(target.getGroup(),"nobody");
    attributes.add(FileAttribute.GROUP);
    attributes.add(FileAttribute.USER);
    DistCpUtils.preserve(fs,path,srcStatus,attributes,false);
    target=fs.getFileStatus(path);
    Assert.assertEquals(target.getPermission(),srcStatus.getPermission());
    Assert.assertEquals(target.getOwner(),srcStatus.getOwner());
    Assert.assertEquals(target.getGroup(),srcStatus.getGroup());
    fs.delete(path,true);
    fs.delete(src,true);
  }
 catch (  IOException e) {
    LOG.error("Exception encountered ",e);
    Assert.fail("Preserve test failure");
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.util.TestAsyncDiskService </h4><pre class="type-11 type-2 type-1 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects are null
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * This test creates some ExampleTasks and runs them. 
 */
@Test public void testAsyncDiskService() throws Throwable {
  String[] vols=new String[]{"/0","/1"};
  AsyncDiskService service=new AsyncDiskService(vols);
  int total=100;
  for (int i=0; i < total; i++) {
    service.execute(vols[i % 2],new ExampleTask());
  }
  Exception e=null;
  try {
    service.execute("no_such_volume",new ExampleTask());
  }
 catch (  RuntimeException ex) {
    e=ex;
  }
  assertNotNull("Executing a task on a non-existing volume should throw an " + "Exception.",e);
  service.shutdown();
  if (!service.awaitTermination(5000)) {
    fail("AsyncDiskService didn't shutdown in 5 seconds.");
  }
  assertEquals(total,count);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.util.TestClasspath </h4><pre class="type-9 type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testUnrecognized(){
  try {
    Classpath.main(new String[]{"--notarealoption"});
    fail("expected exit");
  }
 catch (  ExitUtil.ExitException e) {
    assertTrue(stdout.toByteArray().length == 0);
    String strErr=new String(stderr.toByteArray(),UTF8);
    assertTrue(strErr.contains("unrecognized option"));
  }
}

</code></pre>

<br>
<pre class="type-9 type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testJarFileMissing() throws IOException {
  try {
    Classpath.main(new String[]{"--jar"});
    fail("expected exit");
  }
 catch (  ExitUtil.ExitException e) {
    assertTrue(stdout.toByteArray().length == 0);
    String strErr=new String(stderr.toByteArray(),UTF8);
    assertTrue(strErr.contains("requires path of jar"));
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.util.TestGSet </h4><pre class="type-13 type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testExceptionCases(){
{
    final LightWeightGSet<Integer,Integer> gset=new LightWeightGSet<Integer,Integer>(16);
    try {
      gset.contains(null);
      Assert.fail();
    }
 catch (    NullPointerException e) {
      LightWeightGSet.LOG.info("GOOD: getting " + e,e);
    }
  }
{
    final LightWeightGSet<Integer,Integer> gset=new LightWeightGSet<Integer,Integer>(16);
    try {
      gset.get(null);
      Assert.fail();
    }
 catch (    NullPointerException e) {
      LightWeightGSet.LOG.info("GOOD: getting " + e,e);
    }
  }
{
    final LightWeightGSet<Integer,Integer> gset=new LightWeightGSet<Integer,Integer>(16);
    try {
      gset.put(null);
      Assert.fail();
    }
 catch (    NullPointerException e) {
      LightWeightGSet.LOG.info("GOOD: getting " + e,e);
    }
    try {
      gset.put(1);
      Assert.fail();
    }
 catch (    IllegalArgumentException e) {
      LightWeightGSet.LOG.info("GOOD: getting " + e,e);
    }
  }
{
    final IntElement[] data=new IntElement[5];
    for (int i=0; i < data.length; i++) {
      data[i]=new IntElement(i,i);
    }
    for (int v=1; v < data.length - 1; v++) {
{
        final GSet<IntElement,IntElement> gset=createGSet(data);
        for (        IntElement i : gset) {
          if (i.value == v) {
            gset.remove(data[0]);
          }
        }
        try {
          for (          IntElement i : gset) {
            if (i.value == v) {
              gset.remove(data[1]);
            }
          }
          Assert.fail();
        }
 catch (        ConcurrentModificationException e) {
          LightWeightGSet.LOG.info("GOOD: getting " + e,e);
        }
      }
{
        final GSet<IntElement,IntElement> gset=createGSet(data);
        try {
          for (          IntElement i : gset) {
            if (i.value == v) {
              gset.put(data[0]);
            }
          }
          Assert.fail();
        }
 catch (        ConcurrentModificationException e) {
          LightWeightGSet.LOG.info("GOOD: getting " + e,e);
        }
      }
{
        final GSet<IntElement,IntElement> gset=createGSet(data);
        try {
          for (          IntElement i : gset) {
            if (i.value == v) {
              gset.put(data[3]);
            }
          }
          Assert.fail();
        }
 catch (        ConcurrentModificationException e) {
          LightWeightGSet.LOG.info("GOOD: getting " + e,e);
        }
      }
    }
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.util.TestHostsFileReader </h4><pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testCreateHostFileReaderWithNonexistentFile() throws Exception {
  try {
    new HostsFileReader(HOSTS_TEST_DIR + "/doesnt-exist",HOSTS_TEST_DIR + "/doesnt-exist");
    Assert.fail("Should throw FileNotFoundException");
  }
 catch (  FileNotFoundException ex) {
  }
}

</code></pre>

<br>
<pre class="type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testRefreshHostFileReaderWithNonexistentFile() throws Exception {
  FileWriter efw=new FileWriter(excludesFile);
  FileWriter ifw=new FileWriter(includesFile);
  efw.close();
  ifw.close();
  HostsFileReader hfp=new HostsFileReader(includesFile,excludesFile);
  assertTrue(INCLUDES_FILE.delete());
  try {
    hfp.refresh();
    Assert.fail("Should throw FileNotFoundException");
  }
 catch (  FileNotFoundException ex) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.util.TestIdentityHashStore </h4><pre class="type-13 type-2 type-7 type-10 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testAdditionsAndRemovals(){
  IdentityHashStore<Key,Integer> store=new IdentityHashStore<Key,Integer>(0);
  final int NUM_KEYS=1000;
  LOG.debug("generating " + NUM_KEYS + " keys");
  final List<Key> keys=new ArrayList<Key>(NUM_KEYS);
  for (int i=0; i < NUM_KEYS; i++) {
    keys.add(new Key("key " + i));
  }
  for (int i=0; i < NUM_KEYS; i++) {
    store.put(keys.get(i),i);
  }
  store.visitAll(new Visitor<Key,Integer>(){
    @Override public void accept(    Key k,    Integer v){
      Assert.assertTrue(keys.contains(k));
    }
  }
);
  for (int i=0; i < NUM_KEYS; i++) {
    Assert.assertEquals(Integer.valueOf(i),store.remove(keys.get(i)));
  }
  store.visitAll(new Visitor<Key,Integer>(){
    @Override public void accept(    Key k,    Integer v){
      Assert.fail("expected all entries to be removed");
    }
  }
);
  Assert.assertTrue("expected the store to be " + "empty, but found " + store.numElements() + " elements.",store.isEmpty());
  Assert.assertEquals(1024,store.capacity());
}

</code></pre>

<br>
<pre class="type-2 type-7 type-10 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testStartingWithZeroCapacity(){
  IdentityHashStore<Key,Integer> store=new IdentityHashStore<Key,Integer>(0);
  store.visitAll(new Visitor<Key,Integer>(){
    @Override public void accept(    Key k,    Integer v){
      Assert.fail("found key " + k + " in empty IdentityHashStore.");
    }
  }
);
  Assert.assertTrue(store.isEmpty());
  final Key key1=new Key("key1");
  Integer value1=new Integer(100);
  store.put(key1,value1);
  Assert.assertTrue(!store.isEmpty());
  Assert.assertEquals(value1,store.get(key1));
  store.visitAll(new Visitor<Key,Integer>(){
    @Override public void accept(    Key k,    Integer v){
      Assert.assertEquals(key1,k);
    }
  }
);
  Assert.assertEquals(value1,store.remove(key1));
  Assert.assertTrue(store.isEmpty());
}

</code></pre>

<br>
<pre class="type-13 type-2 type-7 type-10 type-1 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects are null
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testDuplicateInserts(){
  IdentityHashStore<Key,Integer> store=new IdentityHashStore<Key,Integer>(4);
  store.visitAll(new Visitor<Key,Integer>(){
    @Override public void accept(    Key k,    Integer v){
      Assert.fail("found key " + k + " in empty IdentityHashStore.");
    }
  }
);
  Assert.assertTrue(store.isEmpty());
  Key key1=new Key("key1");
  Integer value1=new Integer(100);
  Integer value2=new Integer(200);
  Integer value3=new Integer(300);
  store.put(key1,value1);
  Key equalToKey1=new Key("key1");
  Assert.assertNull(store.get(equalToKey1));
  Assert.assertTrue(!store.isEmpty());
  Assert.assertEquals(value1,store.get(key1));
  store.put(key1,value2);
  store.put(key1,value3);
  final List<Integer> allValues=new LinkedList<Integer>();
  store.visitAll(new Visitor<Key,Integer>(){
    @Override public void accept(    Key k,    Integer v){
      allValues.add(v);
    }
  }
);
  Assert.assertEquals(3,allValues.size());
  for (int i=0; i < 3; i++) {
    Integer value=store.remove(key1);
    Assert.assertTrue(allValues.remove(value));
  }
  Assert.assertNull(store.remove(key1));
  Assert.assertTrue(store.isEmpty());
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.util.TestMachineList </h4><pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testInvalidCIDR(){
  try {
    new MachineList(INVALID_CIDR);
    fail("Expected IllegalArgumentException");
  }
 catch (  IllegalArgumentException e) {
  }
catch (  Throwable t) {
    fail("Expected only IllegalArgumentException");
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.util.TestNativeCodeLoader </h4><pre class="type-11 type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testNativeCodeLoaded(){
  if (requireTestJni() == false) {
    LOG.info("TestNativeCodeLoader: libhadoop.so testing is not required.");
    return;
  }
  if (!NativeCodeLoader.isNativeCodeLoaded()) {
    fail("TestNativeCodeLoader: libhadoop.so testing was required, but " + "libhadoop.so was not loaded.");
  }
  assertFalse(NativeCodeLoader.getLibraryName().isEmpty());
  assertFalse(ZlibFactory.getLibraryName().isEmpty());
  if (NativeCodeLoader.buildSupportsSnappy()) {
    assertFalse(SnappyCodec.getLibraryName().isEmpty());
  }
  if (NativeCodeLoader.buildSupportsOpenssl()) {
    assertFalse(OpensslCipher.getLibraryName().isEmpty());
  }
  assertFalse(Lz4Codec.getLibraryName().isEmpty());
  LOG.info("TestNativeCodeLoader: libhadoop.so is loaded.");
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.util.TestReflectionUtils </h4><pre class="type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testCantCreate(){
  try {
    ReflectionUtils.newInstance(NoDefaultCtor.class,null);
    fail("invalid call should fail");
  }
 catch (  RuntimeException rte) {
    assertEquals(NoSuchMethodException.class,rte.getCause().getClass());
  }
}

</code></pre>

<br>
<pre class="type-11 type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testThreadSafe() throws Exception {
  Thread[] th=new Thread[32];
  for (int i=0; i < th.length; i++) {
    th[i]=new Thread(){
      @Override public void run(){
        try {
          doTestCache();
        }
 catch (        Throwable t) {
          failure=t;
        }
      }
    }
;
    th[i].start();
  }
  for (int i=0; i < th.length; i++) {
    th[i].join();
  }
  if (failure != null) {
    failure.printStackTrace();
    fail(failure.getMessage());
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.util.TestSignalLogger </h4><pre class="type-2 type-15 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Sets implicit assumptions ">AssumptionSetter</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Sets implicit assumptions 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testInstall() throws Exception {
  Assume.assumeTrue(SystemUtils.IS_OS_UNIX);
  SignalLogger.INSTANCE.register(LOG);
  try {
    SignalLogger.INSTANCE.register(LOG);
    Assert.fail("expected IllegalStateException from double registration");
  }
 catch (  IllegalStateException e) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.util.TestStringUtils </h4><pre class="type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=30000) public void testUnescapeString() throws Exception {
  assertEquals(NULL_STR,StringUtils.unEscapeString(NULL_STR));
  assertEquals(EMPTY_STR,StringUtils.unEscapeString(EMPTY_STR));
  assertEquals(STR_WO_SPECIAL_CHARS,StringUtils.unEscapeString(STR_WO_SPECIAL_CHARS));
  try {
    StringUtils.unEscapeString(STR_WITH_COMMA);
    fail("Should throw IllegalArgumentException");
  }
 catch (  IllegalArgumentException e) {
  }
  assertEquals(STR_WITH_COMMA,StringUtils.unEscapeString(ESCAPED_STR_WITH_COMMA));
  try {
    StringUtils.unEscapeString(STR_WITH_ESCAPE);
    fail("Should throw IllegalArgumentException");
  }
 catch (  IllegalArgumentException e) {
  }
  assertEquals(STR_WITH_ESCAPE,StringUtils.unEscapeString(ESCAPED_STR_WITH_ESCAPE));
  try {
    StringUtils.unEscapeString(STR_WITH_BOTH2);
    fail("Should throw IllegalArgumentException");
  }
 catch (  IllegalArgumentException e) {
  }
  assertEquals(STR_WITH_BOTH2,StringUtils.unEscapeString(ESCAPED_STR_WITH_BOTH2));
}

</code></pre>

<br>
<pre class="type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=30000) public void testStringToURI(){
  String[] str=new String[]{"file://"};
  try {
    StringUtils.stringToURI(str);
    fail("Ignoring URISyntaxException while creating URI from string file://");
  }
 catch (  IllegalArgumentException iae) {
    assertEquals("Failed to create uri for file://",iae.getMessage());
  }
}

</code></pre>

<br>
<pre class="type-13 type-2 type-6 type-20 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values related to public fields.">PublicFieldVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Verifies values related to public fields.
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=30000) public void testTraditionalBinaryPrefix() throws Exception {
  String[] symbol={"k","m","g","t","p","e"};
  long m=1024;
  for (  String s : symbol) {
    assertEquals(0,string2long(0 + s));
    assertEquals(m,string2long(1 + s));
    m*=1024;
  }
  assertEquals(0L,string2long("0"));
  assertEquals(1024L,string2long("1k"));
  assertEquals(-1024L,string2long("-1k"));
  assertEquals(1259520L,string2long("1230K"));
  assertEquals(-1259520L,string2long("-1230K"));
  assertEquals(104857600L,string2long("100m"));
  assertEquals(-104857600L,string2long("-100M"));
  assertEquals(956703965184L,string2long("891g"));
  assertEquals(-956703965184L,string2long("-891G"));
  assertEquals(501377302265856L,string2long("456t"));
  assertEquals(-501377302265856L,string2long("-456T"));
  assertEquals(11258999068426240L,string2long("10p"));
  assertEquals(-11258999068426240L,string2long("-10P"));
  assertEquals(1152921504606846976L,string2long("1e"));
  assertEquals(-1152921504606846976L,string2long("-1E"));
  String tooLargeNumStr="10e";
  try {
    string2long(tooLargeNumStr);
    fail("Test passed for a number " + tooLargeNumStr + " too large");
  }
 catch (  IllegalArgumentException e) {
    assertEquals(tooLargeNumStr + " does not fit in a Long",e.getMessage());
  }
  String tooSmallNumStr="-10e";
  try {
    string2long(tooSmallNumStr);
    fail("Test passed for a number " + tooSmallNumStr + " too small");
  }
 catch (  IllegalArgumentException e) {
    assertEquals(tooSmallNumStr + " does not fit in a Long",e.getMessage());
  }
  String invalidFormatNumStr="10kb";
  char invalidPrefix='b';
  try {
    string2long(invalidFormatNumStr);
    fail("Test passed for a number " + invalidFormatNumStr + " has invalid format");
  }
 catch (  IllegalArgumentException e) {
    assertEquals("Invalid size prefix '" + invalidPrefix + "' in '"+ invalidFormatNumStr+ "'. Allowed prefixes are k, m, g, t, p, e(case insensitive)",e.getMessage());
  }
  assertEquals("0",long2String(0,null,2));
  for (int decimalPlace=0; decimalPlace < 2; decimalPlace++) {
    for (int n=1; n < TraditionalBinaryPrefix.KILO.value; n++) {
      assertEquals(n + "",long2String(n,null,decimalPlace));
      assertEquals(-n + "",long2String(-n,null,decimalPlace));
    }
    assertEquals("1 K",long2String(1L << 10,null,decimalPlace));
    assertEquals("-1 K",long2String(-1L << 10,null,decimalPlace));
  }
  assertEquals("8.00 E",long2String(Long.MAX_VALUE,null,2));
  assertEquals("8.00 E",long2String(Long.MAX_VALUE - 1,null,2));
  assertEquals("-8 E",long2String(Long.MIN_VALUE,null,2));
  assertEquals("-8.00 E",long2String(Long.MIN_VALUE + 1,null,2));
  final String[] zeros={" ",".0 ",".00 "};
  for (int decimalPlace=0; decimalPlace < zeros.length; decimalPlace++) {
    final String trailingZeros=zeros[decimalPlace];
    for (int e=11; e < Long.SIZE - 1; e++) {
      final TraditionalBinaryPrefix p=TraditionalBinaryPrefix.values()[e / 10 - 1];
{
        final long n=1L << e;
        final String expected=(n / p.value) + " " + p.symbol;
        assertEquals("n=" + n,expected,long2String(n,null,2));
      }
{
        final long n=(1L << e) + 1;
        final String expected=(n / p.value) + trailingZeros + p.symbol;
        assertEquals("n=" + n,expected,long2String(n,null,decimalPlace));
      }
{
        final long n=(1L << e) - 1;
        final String expected=((n + 1) / p.value) + trailingZeros + p.symbol;
        assertEquals("n=" + n,expected,long2String(n,null,decimalPlace));
      }
    }
  }
  assertEquals("1.50 K",long2String(3L << 9,null,2));
  assertEquals("1.5 K",long2String(3L << 9,null,1));
  assertEquals("1.50 M",long2String(3L << 19,null,2));
  assertEquals("2 M",long2String(3L << 19,null,0));
  assertEquals("3 G",long2String(3L << 30,null,2));
  assertEquals("0 B",StringUtils.byteDesc(0));
  assertEquals("-100 B",StringUtils.byteDesc(-100));
  assertEquals("1 KB",StringUtils.byteDesc(1024));
  assertEquals("1.50 KB",StringUtils.byteDesc(3L << 9));
  assertEquals("1.50 MB",StringUtils.byteDesc(3L << 19));
  assertEquals("3 GB",StringUtils.byteDesc(3L << 30));
  assertEquals("10%",StringUtils.formatPercent(0.1,0));
  assertEquals("10.0%",StringUtils.formatPercent(0.1,1));
  assertEquals("10.00%",StringUtils.formatPercent(0.1,2));
  assertEquals("1%",StringUtils.formatPercent(0.00543,0));
  assertEquals("0.5%",StringUtils.formatPercent(0.00543,1));
  assertEquals("0.54%",StringUtils.formatPercent(0.00543,2));
  assertEquals("0.543%",StringUtils.formatPercent(0.00543,3));
  assertEquals("0.5430%",StringUtils.formatPercent(0.00543,4));
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.util.TestWinUtils </h4><pre class="type-9 type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=30000) public void testSymlinkRejectsForwardSlashesInLink() throws IOException {
  File newFile=new File(TEST_DIR,"file");
  assertTrue(newFile.createNewFile());
  String target=newFile.getPath();
  String link=new File(TEST_DIR,"link").getPath().replaceAll("\\\\","/");
  try {
    Shell.execCommand(Shell.WINUTILS,"symlink",link,target);
    fail(String.format("did not receive expected failure creating symlink " + "with forward slashes in link: link = %s, target = %s",link,target));
  }
 catch (  IOException e) {
    LOG.info("Expected: Failed to create symlink with forward slashes in target");
  }
}

</code></pre>

<br>
<pre class="type-9 type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=30000) public void testSymlinkRejectsForwardSlashesInTarget() throws IOException {
  File newFile=new File(TEST_DIR,"file");
  assertTrue(newFile.createNewFile());
  String target=newFile.getPath().replaceAll("\\\\","/");
  String link=new File(TEST_DIR,"link").getPath();
  try {
    Shell.execCommand(Shell.WINUTILS,"symlink",link,target);
    fail(String.format("did not receive expected failure creating symlink " + "with forward slashes in target: link = %s, target = %s",link,target));
  }
 catch (  IOException e) {
    LOG.info("Expected: Failed to create symlink with forward slashes in target");
  }
}

</code></pre>

<br>
<pre class="type-9 type-2 type-10 type-21 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies logic rules using matcher-style statements">ConditionMatcher</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies logic rules using matcher-style statements
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=30000) public void testReadLink() throws IOException {
  File dir1=new File(TEST_DIR,"dir1");
  assertTrue(dir1.mkdirs());
  File file1=new File(dir1,"file1.txt");
  assertTrue(file1.createNewFile());
  File dirLink=new File(TEST_DIR,"dlink");
  File fileLink=new File(TEST_DIR,"flink");
  Shell.execCommand(Shell.WINUTILS,"symlink",dirLink.toString(),dir1.toString());
  Shell.execCommand(Shell.WINUTILS,"symlink",fileLink.toString(),file1.toString());
  String readLinkOutput=Shell.execCommand(Shell.WINUTILS,"readlink",dirLink.toString());
  assertThat(readLinkOutput,equalTo(dir1.toString()));
  readLinkOutput=Shell.execCommand(Shell.WINUTILS,"readlink",fileLink.toString());
  assertThat(readLinkOutput,equalTo(file1.toString()));
  try {
    Shell.execCommand(Shell.WINUTILS,"readlink","");
    fail("Failed to get Shell.ExitCodeException when reading bad symlink");
  }
 catch (  Shell.ExitCodeException ece) {
    assertThat(ece.getExitCode(),is(1));
  }
  try {
    Shell.execCommand(Shell.WINUTILS,"readlink","ThereIsNoSuchLink");
    fail("Failed to get Shell.ExitCodeException when reading bad symlink");
  }
 catch (  Shell.ExitCodeException ece) {
    assertThat(ece.getExitCode(),is(1));
  }
  try {
    Shell.execCommand(Shell.WINUTILS,"readlink",dir1.toString());
    fail("Failed to get Shell.ExitCodeException when reading bad symlink");
  }
 catch (  Shell.ExitCodeException ece) {
    assertThat(ece.getExitCode(),is(1));
  }
  try {
    Shell.execCommand(Shell.WINUTILS,"readlink",file1.toString());
    fail("Failed to get Shell.ExitCodeException when reading bad symlink");
  }
 catch (  Shell.ExitCodeException ece) {
    assertThat(ece.getExitCode(),is(1));
  }
  try {
    Shell.execCommand(Shell.WINUTILS,"readlink","a","b");
    fail("Failed to get Shell.ExitCodeException with bad parameters");
  }
 catch (  Shell.ExitCodeException ece) {
    assertThat(ece.getExitCode(),is(1));
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.util.TestZKUtil </h4><pre class="type-2 type-10 type-1 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies whether objects are null
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testConfIndirection() throws IOException {
  assertNull(ZKUtil.resolveConfIndirection(null));
  assertEquals("x",ZKUtil.resolveConfIndirection("x"));
  TEST_FILE.getParentFile().mkdirs();
  Files.write("hello world",TEST_FILE,Charsets.UTF_8);
  assertEquals("hello world",ZKUtil.resolveConfIndirection("@" + TEST_FILE.getAbsolutePath()));
  try {
    ZKUtil.resolveConfIndirection("@" + BOGUS_FILE);
    fail("Did not throw for non-existent file reference");
  }
 catch (  FileNotFoundException fnfe) {
    assertTrue(fnfe.getMessage().startsWith(BOGUS_FILE));
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.yarn.TestRPC </h4><pre class="type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testUnknownCall(){
  Configuration conf=new Configuration();
  conf.set(YarnConfiguration.IPC_RPC_IMPL,HadoopYarnProtoRPC.class.getName());
  YarnRPC rpc=YarnRPC.create(conf);
  String bindAddr="localhost:0";
  InetSocketAddress addr=NetUtils.createSocketAddr(bindAddr);
  Server server=rpc.getServer(ContainerManagementProtocol.class,new DummyContainerManager(),addr,conf,null,1);
  server.start();
  ApplicationClientProtocol proxy=(ApplicationClientProtocol)rpc.getProxy(ApplicationClientProtocol.class,NetUtils.getConnectAddress(server),conf);
  try {
    proxy.getNewApplication(Records.newRecord(GetNewApplicationRequest.class));
    Assert.fail("Excepted RPC call to fail with unknown method.");
  }
 catch (  YarnException e) {
    Assert.assertTrue(e.getMessage().matches("Unknown method getNewApplication called on.*" + "org.apache.hadoop.yarn.proto.ApplicationClientProtocol" + "\\$ApplicationClientProtocolService\\$BlockingInterface protocol."));
  }
catch (  Exception e) {
    e.printStackTrace();
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.yarn.TestRecordFactory </h4><pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testPbRecordFactory(){
  RecordFactory pbRecordFactory=RecordFactoryPBImpl.get();
  try {
    AllocateResponse response=pbRecordFactory.newRecordInstance(AllocateResponse.class);
    Assert.assertEquals(AllocateResponsePBImpl.class,response.getClass());
  }
 catch (  YarnRuntimeException e) {
    e.printStackTrace();
    Assert.fail("Failed to crete record");
  }
  try {
    AllocateRequest response=pbRecordFactory.newRecordInstance(AllocateRequest.class);
    Assert.assertEquals(AllocateRequestPBImpl.class,response.getClass());
  }
 catch (  YarnRuntimeException e) {
    e.printStackTrace();
    Assert.fail("Failed to crete record");
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.yarn.TestResourceTrackerPBClientImpl </h4><pre class="type-2 type-7 type-10 type-1 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test the method registerNodeManager. Method should return a not null
 * result.
 */
@Test public void testResourceTrackerPBClientImpl() throws Exception {
  RegisterNodeManagerRequest request=recordFactory.newRecordInstance(RegisterNodeManagerRequest.class);
  assertNotNull(client.registerNodeManager(request));
  ResourceTrackerTestImpl.exception=true;
  try {
    client.registerNodeManager(request);
    fail("there  should be YarnException");
  }
 catch (  YarnException e) {
    assertTrue(e.getMessage().startsWith("testMessage"));
  }
 finally {
    ResourceTrackerTestImpl.exception=false;
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-10 type-1 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test the method nodeHeartbeat. Method should return a not null result.
 */
@Test public void testNodeHeartbeat() throws Exception {
  NodeHeartbeatRequest request=recordFactory.newRecordInstance(NodeHeartbeatRequest.class);
  assertNotNull(client.nodeHeartbeat(request));
  ResourceTrackerTestImpl.exception=true;
  try {
    client.nodeHeartbeat(request);
    fail("there  should be YarnException");
  }
 catch (  YarnException e) {
    assertTrue(e.getMessage().startsWith("testMessage"));
  }
 finally {
    ResourceTrackerTestImpl.exception=false;
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.yarn.TestRpcFactoryProvider </h4><pre class="type-9 type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testFactoryProvider(){
  Configuration conf=new Configuration();
  RpcClientFactory clientFactory=null;
  RpcServerFactory serverFactory=null;
  clientFactory=RpcFactoryProvider.getClientFactory(conf);
  serverFactory=RpcFactoryProvider.getServerFactory(conf);
  Assert.assertEquals(RpcClientFactoryPBImpl.class,clientFactory.getClass());
  Assert.assertEquals(RpcServerFactoryPBImpl.class,serverFactory.getClass());
  conf.set(YarnConfiguration.IPC_CLIENT_FACTORY_CLASS,"unknown");
  conf.set(YarnConfiguration.IPC_SERVER_FACTORY_CLASS,"unknown");
  conf.set(YarnConfiguration.IPC_RECORD_FACTORY_CLASS,"unknown");
  try {
    clientFactory=RpcFactoryProvider.getClientFactory(conf);
    Assert.fail("Expected an exception - unknown serializer");
  }
 catch (  YarnRuntimeException e) {
  }
  try {
    serverFactory=RpcFactoryProvider.getServerFactory(conf);
    Assert.fail("Expected an exception - unknown serializer");
  }
 catch (  YarnRuntimeException e) {
  }
  conf=new Configuration();
  conf.set(YarnConfiguration.IPC_CLIENT_FACTORY_CLASS,"NonExistantClass");
  conf.set(YarnConfiguration.IPC_SERVER_FACTORY_CLASS,RpcServerFactoryPBImpl.class.getName());
  try {
    clientFactory=RpcFactoryProvider.getClientFactory(conf);
    Assert.fail("Expected an exception - unknown class");
  }
 catch (  YarnRuntimeException e) {
  }
  try {
    serverFactory=RpcFactoryProvider.getServerFactory(conf);
  }
 catch (  YarnRuntimeException e) {
    Assert.fail("Error while loading factory using reflection: [" + RpcServerFactoryPBImpl.class.getName() + "]");
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.yarn.TestYSCRecordFactory </h4><pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testPbRecordFactory(){
  RecordFactory pbRecordFactory=RecordFactoryPBImpl.get();
  try {
    NodeHeartbeatRequest request=pbRecordFactory.newRecordInstance(NodeHeartbeatRequest.class);
    Assert.assertEquals(NodeHeartbeatRequestPBImpl.class,request.getClass());
  }
 catch (  YarnRuntimeException e) {
    e.printStackTrace();
    Assert.fail("Failed to crete record");
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.yarn.api.records.impl.pb.TestSerializedExceptionPBImpl </h4><pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testDeserialize() throws Exception {
  Exception ex=new Exception("test exception");
  SerializedExceptionPBImpl pb=new SerializedExceptionPBImpl();
  try {
    pb.deSerialize();
    Assert.fail("deSerialze should throw YarnRuntimeException");
  }
 catch (  YarnRuntimeException e) {
    Assert.assertEquals(ClassNotFoundException.class,e.getCause().getClass());
  }
  pb.init(ex);
  Assert.assertEquals(ex.toString(),pb.deSerialize().toString());
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.yarn.applications.distributedshell.TestDistributedShell </h4><pre class="type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=90000) public void testDSShellWithInvalidArgs() throws Exception {
  Client client=new Client(new Configuration(yarnCluster.getConfig()));
  LOG.info("Initializing DS Client with no args");
  try {
    client.init(new String[]{});
    Assert.fail("Exception is expected");
  }
 catch (  IllegalArgumentException e) {
    Assert.assertTrue("The throw exception is not expected",e.getMessage().contains("No args"));
  }
  LOG.info("Initializing DS Client with no jar file");
  try {
    String[] args={"--num_containers","2","--shell_command",Shell.WINDOWS ? "dir" : "ls","--master_memory","512","--container_memory","128"};
    client.init(args);
    Assert.fail("Exception is expected");
  }
 catch (  IllegalArgumentException e) {
    Assert.assertTrue("The throw exception is not expected",e.getMessage().contains("No jar"));
  }
  LOG.info("Initializing DS Client with no shell command");
  try {
    String[] args={"--jar",APPMASTER_JAR,"--num_containers","2","--master_memory","512","--container_memory","128"};
    client.init(args);
    Assert.fail("Exception is expected");
  }
 catch (  IllegalArgumentException e) {
    Assert.assertTrue("The throw exception is not expected",e.getMessage().contains("No shell command"));
  }
  LOG.info("Initializing DS Client with invalid no. of containers");
  try {
    String[] args={"--jar",APPMASTER_JAR,"--num_containers","-1","--shell_command",Shell.WINDOWS ? "dir" : "ls","--master_memory","512","--container_memory","128"};
    client.init(args);
    Assert.fail("Exception is expected");
  }
 catch (  IllegalArgumentException e) {
    Assert.assertTrue("The throw exception is not expected",e.getMessage().contains("Invalid no. of containers"));
  }
  LOG.info("Initializing DS Client with invalid no. of vcores");
  try {
    String[] args={"--jar",APPMASTER_JAR,"--num_containers","2","--shell_command",Shell.WINDOWS ? "dir" : "ls","--master_memory","512","--master_vcores","-2","--container_memory","128","--container_vcores","1"};
    client.init(args);
    Assert.fail("Exception is expected");
  }
 catch (  IllegalArgumentException e) {
    Assert.assertTrue("The throw exception is not expected",e.getMessage().contains("Invalid virtual cores specified"));
  }
  LOG.info("Initializing DS Client with --shell_command and --shell_script");
  try {
    String[] args={"--jar",APPMASTER_JAR,"--num_containers","2","--shell_command",Shell.WINDOWS ? "dir" : "ls","--master_memory","512","--master_vcores","2","--container_memory","128","--container_vcores","1","--shell_script","test.sh"};
    client.init(args);
    Assert.fail("Exception is expected");
  }
 catch (  IllegalArgumentException e) {
    Assert.assertTrue("The throw exception is not expected",e.getMessage().contains("Can not specify shell_command option " + "and shell_script option at the same time"));
  }
  LOG.info("Initializing DS Client without --shell_command and --shell_script");
  try {
    String[] args={"--jar",APPMASTER_JAR,"--num_containers","2","--master_memory","512","--master_vcores","2","--container_memory","128","--container_vcores","1"};
    client.init(args);
    Assert.fail("Exception is expected");
  }
 catch (  IllegalArgumentException e) {
    Assert.assertTrue("The throw exception is not expected",e.getMessage().contains("No shell command or shell script specified " + "to be executed by application master"));
  }
}

</code></pre>

<br>
<pre class="type-9 type-11 type-2 type-7 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=90000) public void testDSShellWithCustomLogPropertyFile() throws Exception {
  final File basedir=new File("target",TestDistributedShell.class.getName());
  final File tmpDir=new File(basedir,"tmpDir");
  tmpDir.mkdirs();
  final File customLogProperty=new File(tmpDir,"custom_log4j.properties");
  if (customLogProperty.exists()) {
    customLogProperty.delete();
  }
  if (!customLogProperty.createNewFile()) {
    Assert.fail("Can not create custom log4j property file.");
  }
  PrintWriter fileWriter=new PrintWriter(customLogProperty);
  fileWriter.write("log4j.rootLogger=debug,stdout");
  fileWriter.close();
  String[] args={"--jar",APPMASTER_JAR,"--num_containers","3","--shell_command","echo","--shell_args","HADOOP","--log_properties",customLogProperty.getAbsolutePath(),"--master_memory","512","--master_vcores","2","--container_memory","128","--container_vcores","1"};
  final Log LOG_Client=LogFactory.getLog(Client.class);
  Assert.assertTrue(LOG_Client.isInfoEnabled());
  Assert.assertFalse(LOG_Client.isDebugEnabled());
  final Log LOG_AM=LogFactory.getLog(ApplicationMaster.class);
  Assert.assertTrue(LOG_AM.isInfoEnabled());
  Assert.assertFalse(LOG_AM.isDebugEnabled());
  LOG.info("Initializing DS Client");
  final Client client=new Client(new Configuration(yarnCluster.getConfig()));
  boolean initSuccess=client.init(args);
  Assert.assertTrue(initSuccess);
  LOG.info("Running DS Client");
  boolean result=client.run();
  LOG.info("Client run completed. Result=" + result);
  Assert.assertTrue(verifyContainerLog(3,null,true,"DEBUG") > 10);
  Assert.assertTrue(LOG_Client.isInfoEnabled());
  Assert.assertTrue(LOG_Client.isDebugEnabled());
  Assert.assertTrue(LOG_AM.isInfoEnabled());
  Assert.assertTrue(LOG_AM.isDebugEnabled());
}

</code></pre>

<br>
<pre class="type-9 type-11 type-2 type-7 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=90000) public void testDSShellWithShellScript() throws Exception {
  final File basedir=new File("target",TestDistributedShell.class.getName());
  final File tmpDir=new File(basedir,"tmpDir");
  tmpDir.mkdirs();
  final File customShellScript=new File(tmpDir,"custom_script.sh");
  if (customShellScript.exists()) {
    customShellScript.delete();
  }
  if (!customShellScript.createNewFile()) {
    Assert.fail("Can not create custom shell script file.");
  }
  PrintWriter fileWriter=new PrintWriter(customShellScript);
  fileWriter.write("echo testDSShellWithShellScript");
  fileWriter.close();
  System.out.println(customShellScript.getAbsolutePath());
  String[] args={"--jar",APPMASTER_JAR,"--num_containers","1","--shell_script",customShellScript.getAbsolutePath(),"--master_memory","512","--master_vcores","2","--container_memory","128","--container_vcores","1"};
  LOG.info("Initializing DS Client");
  final Client client=new Client(new Configuration(yarnCluster.getConfig()));
  boolean initSuccess=client.init(args);
  Assert.assertTrue(initSuccess);
  LOG.info("Running DS Client");
  boolean result=client.run();
  LOG.info("Client run completed. Result=" + result);
  List<String> expectedContent=new ArrayList<String>();
  expectedContent.add("testDSShellWithShellScript");
  verifyContainerLog(1,expectedContent,false,"");
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.yarn.applications.unmanagedamlauncher.TestUnmanagedAMLauncher </h4><pre class="type-2 type-7 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=30000) public void testUMALauncherError() throws Exception {
  String classpath=getTestRuntimeClasspath();
  String javaHome=System.getenv("JAVA_HOME");
  if (javaHome == null) {
    LOG.fatal("JAVA_HOME not defined. Test not running.");
    return;
  }
  String[] args={"--classpath",classpath,"--queue","default","--cmd",javaHome + "/bin/java -Xmx512m " + TestUnmanagedAMLauncher.class.getCanonicalName()+ " failure"};
  LOG.info("Initializing Launcher");
  UnmanagedAMLauncher launcher=new UnmanagedAMLauncher(new Configuration(yarnCluster.getConfig()));
  boolean initSuccess=launcher.init(args);
  Assert.assertTrue(initSuccess);
  LOG.info("Running Launcher");
  try {
    launcher.run();
    fail("Expected an exception to occur as launch should have failed");
  }
 catch (  RuntimeException e) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.yarn.client.api.impl.TestAMRMClient </h4><pre class="type-9 type-2 type-7 type-10 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testAllocationWithBlacklist() throws YarnException, IOException {
  AMRMClientImpl<ContainerRequest> amClient=null;
  try {
    amClient=(AMRMClientImpl<ContainerRequest>)AMRMClient.<ContainerRequest>createAMRMClient();
    amClient.init(conf);
    amClient.start();
    amClient.registerApplicationMaster("Host",10000,"");
    assertEquals(0,amClient.ask.size());
    assertEquals(0,amClient.release.size());
    ContainerRequest storedContainer1=new ContainerRequest(capability,nodes,racks,priority);
    amClient.addContainerRequest(storedContainer1);
    assertEquals(3,amClient.ask.size());
    assertEquals(0,amClient.release.size());
    List<String> localNodeBlacklist=new ArrayList<String>();
    localNodeBlacklist.add(node);
    amClient.updateBlacklist(localNodeBlacklist,null);
    int allocatedContainerCount=getAllocatedContainersNumber(amClient,DEFAULT_ITERATION);
    assertEquals(0,allocatedContainerCount);
    amClient.updateBlacklist(null,localNodeBlacklist);
    ContainerRequest storedContainer2=new ContainerRequest(capability,nodes,racks,priority);
    amClient.addContainerRequest(storedContainer2);
    allocatedContainerCount=getAllocatedContainersNumber(amClient,DEFAULT_ITERATION);
    assertEquals(2,allocatedContainerCount);
    assertTrue(amClient.blacklistAdditions.isEmpty());
    assertTrue(amClient.blacklistRemovals.isEmpty());
    ContainerRequest invalidContainerRequest=new ContainerRequest(Resource.newInstance(-1024,1),nodes,racks,priority);
    amClient.addContainerRequest(invalidContainerRequest);
    amClient.updateBlacklist(localNodeBlacklist,null);
    try {
      amClient.allocate(0.1f);
      fail("there should be an exception here.");
    }
 catch (    Exception e) {
      assertEquals(1,amClient.blacklistAdditions.size());
    }
  }
  finally {
    if (amClient != null && amClient.getServiceState() == STATE.STARTED) {
      amClient.stop();
    }
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-10 type-1 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects are null
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testAMRMClientOnAMRMTokenRollOver() throws YarnException, IOException {
  AMRMClient<ContainerRequest> amClient=null;
  try {
    AMRMTokenSecretManager amrmTokenSecretManager=yarnCluster.getResourceManager().getRMContext().getAMRMTokenSecretManager();
    amClient=AMRMClient.<ContainerRequest>createAMRMClient();
    amClient.init(conf);
    amClient.start();
    Long startTime=System.currentTimeMillis();
    amClient.registerApplicationMaster("Host",10000,"");
    org.apache.hadoop.security.token.Token<AMRMTokenIdentifier> amrmToken_1=getAMRMToken();
    Assert.assertNotNull(amrmToken_1);
    Assert.assertEquals(amrmToken_1.decodeIdentifier().getKeyId(),amrmTokenSecretManager.getMasterKey().getMasterKey().getKeyId());
    while (System.currentTimeMillis() - startTime < rolling_interval_sec * 1000) {
      amClient.allocate(0.1f);
      try {
        Thread.sleep(1000);
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
    }
    amClient.allocate(0.1f);
    org.apache.hadoop.security.token.Token<AMRMTokenIdentifier> amrmToken_2=getAMRMToken();
    Assert.assertNotNull(amrmToken_2);
    Assert.assertEquals(amrmToken_2.decodeIdentifier().getKeyId(),amrmTokenSecretManager.getMasterKey().getMasterKey().getKeyId());
    Assert.assertNotEquals(amrmToken_1,amrmToken_2);
    amClient.allocate(0.1f);
    while (true) {
      if (amrmToken_2.decodeIdentifier().getKeyId() != amrmTokenSecretManager.getCurrnetMasterKeyData().getMasterKey().getKeyId()) {
        if (amrmTokenSecretManager.getNextMasterKeyData() == null) {
          break;
        }
 else         if (amrmToken_2.decodeIdentifier().getKeyId() != amrmTokenSecretManager.getNextMasterKeyData().getMasterKey().getKeyId()) {
          break;
        }
      }
      amClient.allocate(0.1f);
      try {
        Thread.sleep(1000);
      }
 catch (      InterruptedException e) {
      }
    }
    try {
      UserGroupInformation testUser=UserGroupInformation.createRemoteUser("testUser");
      SecurityUtil.setTokenService(amrmToken_2,yarnCluster.getResourceManager().getApplicationMasterService().getBindAddress());
      testUser.addToken(amrmToken_2);
      testUser.doAs(new PrivilegedAction<ApplicationMasterProtocol>(){
        @Override public ApplicationMasterProtocol run(){
          return (ApplicationMasterProtocol)YarnRPC.create(conf).getProxy(ApplicationMasterProtocol.class,yarnCluster.getResourceManager().getApplicationMasterService().getBindAddress(),conf);
        }
      }
).allocate(Records.newRecord(AllocateRequest.class));
      Assert.fail("The old Token should not work");
    }
 catch (    Exception ex) {
      Assert.assertTrue(ex instanceof InvalidToken);
      Assert.assertTrue(ex.getMessage().contains("Invalid AMRMToken from " + amrmToken_2.decodeIdentifier().getApplicationAttemptId()));
    }
    amClient.unregisterApplicationMaster(FinalApplicationStatus.SUCCEEDED,null,null);
  }
  finally {
    if (amClient != null && amClient.getServiceState() == STATE.STARTED) {
      amClient.stop();
    }
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.yarn.client.api.impl.TestAMRMClientOnRMRestart </h4><pre class="type-2 type-7 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=30000) public void testAMRMClientOnAMRMTokenRollOverOnRMRestart() throws Exception {
  conf.setLong(YarnConfiguration.RM_AMRM_TOKEN_MASTER_KEY_ROLLING_INTERVAL_SECS,rolling_interval_sec);
  conf.setLong(YarnConfiguration.RM_AM_EXPIRY_INTERVAL_MS,am_expire_ms);
  MemoryRMStateStore memStore=new MemoryRMStateStore();
  memStore.init(conf);
  MyResourceManager2 rm1=new MyResourceManager2(conf,memStore);
  rm1.start();
  DrainDispatcher dispatcher=(DrainDispatcher)rm1.getRMContext().getDispatcher();
  Long startTime=System.currentTimeMillis();
  RMApp app=rm1.submitApp(1024);
  dispatcher.await();
  MockNM nm1=new MockNM("h1:1234",15120,rm1.getResourceTrackerService());
  nm1.registerNode();
  nm1.nodeHeartbeat(true);
  dispatcher.await();
  ApplicationAttemptId appAttemptId=app.getCurrentAppAttempt().getAppAttemptId();
  rm1.sendAMLaunched(appAttemptId);
  dispatcher.await();
  AMRMTokenSecretManager amrmTokenSecretManagerForRM1=rm1.getRMContext().getAMRMTokenSecretManager();
  org.apache.hadoop.security.token.Token<AMRMTokenIdentifier> token=amrmTokenSecretManagerForRM1.createAndGetAMRMToken(appAttemptId);
  UserGroupInformation ugi=UserGroupInformation.getCurrentUser();
  ugi.addTokenIdentifier(token.decodeIdentifier());
  AMRMClient<ContainerRequest> amClient=new MyAMRMClientImpl(rm1);
  amClient.init(conf);
  amClient.start();
  amClient.registerApplicationMaster("h1",10000,"");
  amClient.allocate(0.1f);
  while (System.currentTimeMillis() - startTime < rolling_interval_sec * 1000) {
    amClient.allocate(0.1f);
    try {
      Thread.sleep(1000);
    }
 catch (    InterruptedException e) {
    }
  }
  Assert.assertTrue(amrmTokenSecretManagerForRM1.getMasterKey().getMasterKey().getKeyId() != token.decodeIdentifier().getKeyId());
  amClient.allocate(0.1f);
  org.apache.hadoop.security.token.Token<AMRMTokenIdentifier> newToken=amrmTokenSecretManagerForRM1.createAndGetAMRMToken(appAttemptId);
  int waitCount=0;
  while (waitCount++ <= 50) {
    if (amrmTokenSecretManagerForRM1.getCurrnetMasterKeyData().getMasterKey().getKeyId() != token.decodeIdentifier().getKeyId()) {
      break;
    }
    try {
      amClient.allocate(0.1f);
    }
 catch (    Exception ex) {
      break;
    }
    Thread.sleep(500);
  }
  Assert.assertTrue(amrmTokenSecretManagerForRM1.getNextMasterKeyData() == null);
  Assert.assertTrue(amrmTokenSecretManagerForRM1.getCurrnetMasterKeyData().getMasterKey().getKeyId() == newToken.decodeIdentifier().getKeyId());
  conf.set(YarnConfiguration.RM_SCHEDULER_ADDRESS,"0.0.0.0:9030");
  final MyResourceManager2 rm2=new MyResourceManager2(conf,memStore);
  rm2.start();
  nm1.setResourceTrackerService(rm2.getResourceTrackerService());
  ((MyAMRMClientImpl)amClient).updateRMProxy(rm2);
  dispatcher=(DrainDispatcher)rm2.getRMContext().getDispatcher();
  AMRMTokenSecretManager amrmTokenSecretManagerForRM2=rm2.getRMContext().getAMRMTokenSecretManager();
  Assert.assertTrue(amrmTokenSecretManagerForRM2.getCurrnetMasterKeyData().getMasterKey().getKeyId() == newToken.decodeIdentifier().getKeyId());
  Assert.assertTrue(amrmTokenSecretManagerForRM2.getNextMasterKeyData() == null);
  try {
    UserGroupInformation testUser=UserGroupInformation.createRemoteUser("testUser");
    SecurityUtil.setTokenService(token,rm2.getApplicationMasterService().getBindAddress());
    testUser.addToken(token);
    testUser.doAs(new PrivilegedAction<ApplicationMasterProtocol>(){
      @Override public ApplicationMasterProtocol run(){
        return (ApplicationMasterProtocol)YarnRPC.create(conf).getProxy(ApplicationMasterProtocol.class,rm2.getApplicationMasterService().getBindAddress(),conf);
      }
    }
).allocate(Records.newRecord(AllocateRequest.class));
    Assert.fail("The old Token should not work");
  }
 catch (  Exception ex) {
    Assert.assertTrue(ex instanceof InvalidToken);
    Assert.assertTrue(ex.getMessage().contains("Invalid AMRMToken from " + token.decodeIdentifier().getApplicationAttemptId()));
  }
  amClient.allocate(0.1f);
  amClient.unregisterApplicationMaster(FinalApplicationStatus.SUCCEEDED,null,null);
  amClient.stop();
  rm1.stop();
  rm2.stop();
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.yarn.client.api.impl.TestNMClient </h4><pre class="type-11 type-8 type-2 type-7 type-1 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Allocates resources before the execution of the test cases">TestInitializer</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions inside branch conditions
- Allocates resources before the execution of the test cases
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Before public void setup() throws YarnException, IOException {
  conf=new YarnConfiguration();
  yarnCluster=new MiniYARNCluster(TestAMRMClient.class.getName(),nodeCount,1,1);
  yarnCluster.init(conf);
  yarnCluster.start();
  assertNotNull(yarnCluster);
  assertEquals(STATE.STARTED,yarnCluster.getServiceState());
  yarnClient=(YarnClientImpl)YarnClient.createYarnClient();
  yarnClient.init(conf);
  yarnClient.start();
  assertNotNull(yarnClient);
  assertEquals(STATE.STARTED,yarnClient.getServiceState());
  nodeReports=yarnClient.getNodeReports(NodeState.RUNNING);
  ApplicationSubmissionContext appContext=yarnClient.createApplication().getApplicationSubmissionContext();
  ApplicationId appId=appContext.getApplicationId();
  appContext.setApplicationName("Test");
  Priority pri=Priority.newInstance(0);
  appContext.setPriority(pri);
  appContext.setQueue("default");
  ContainerLaunchContext amContainer=Records.newRecord(ContainerLaunchContext.class);
  appContext.setAMContainerSpec(amContainer);
  appContext.setUnmanagedAM(true);
  SubmitApplicationRequest appRequest=Records.newRecord(SubmitApplicationRequest.class);
  appRequest.setApplicationSubmissionContext(appContext);
  yarnClient.submitApplication(appContext);
  int iterationsLeft=30;
  RMAppAttempt appAttempt=null;
  while (iterationsLeft > 0) {
    ApplicationReport appReport=yarnClient.getApplicationReport(appId);
    if (appReport.getYarnApplicationState() == YarnApplicationState.ACCEPTED) {
      attemptId=appReport.getCurrentApplicationAttemptId();
      appAttempt=yarnCluster.getResourceManager().getRMContext().getRMApps().get(attemptId.getApplicationId()).getCurrentAppAttempt();
      while (true) {
        if (appAttempt.getAppAttemptState() == RMAppAttemptState.LAUNCHED) {
          break;
        }
      }
      break;
    }
    sleep(1000);
    --iterationsLeft;
  }
  if (iterationsLeft == 0) {
    fail("Application hasn't bee started");
  }
  UserGroupInformation.setLoginUser(UserGroupInformation.createRemoteUser(UserGroupInformation.getCurrentUser().getUserName()));
  UserGroupInformation.getCurrentUser().addToken(appAttempt.getAMRMToken());
  nmTokenCache=new NMTokenCache();
  rmClient=(AMRMClientImpl<ContainerRequest>)AMRMClient.<ContainerRequest>createAMRMClient();
  rmClient.setNMTokenCache(nmTokenCache);
  rmClient.init(conf);
  rmClient.start();
  assertNotNull(rmClient);
  assertEquals(STATE.STARTED,rmClient.getServiceState());
  nmClient=(NMClientImpl)NMClient.createNMClient();
  nmClient.setNMTokenCache(rmClient.getNMTokenCache());
  nmClient.init(conf);
  nmClient.start();
  assertNotNull(nmClient);
  assertEquals(STATE.STARTED,nmClient.getServiceState());
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.yarn.client.api.impl.TestTimelineClient </h4><pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testPostEntities() throws Exception {
  mockClientResponse(client,ClientResponse.Status.OK,false,false);
  try {
    TimelinePutResponse response=client.putEntities(generateEntity());
    Assert.assertEquals(0,response.getErrors().size());
  }
 catch (  YarnException e) {
    Assert.fail("Exception is not expected");
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testPostEntitiesWithError() throws Exception {
  mockClientResponse(client,ClientResponse.Status.OK,true,false);
  try {
    TimelinePutResponse response=client.putEntities(generateEntity());
    Assert.assertEquals(1,response.getErrors().size());
    Assert.assertEquals("test entity id",response.getErrors().get(0).getEntityId());
    Assert.assertEquals("test entity type",response.getErrors().get(0).getEntityType());
    Assert.assertEquals(TimelinePutResponse.TimelinePutError.IO_EXCEPTION,response.getErrors().get(0).getErrorCode());
  }
 catch (  YarnException e) {
    Assert.fail("Exception is not expected");
  }
}

</code></pre>

<br>
<pre class="type-9 type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testPostEntitiesTimelineServiceDefaultNotEnabled() throws Exception {
  YarnConfiguration conf=new YarnConfiguration();
  conf.unset(YarnConfiguration.TIMELINE_SERVICE_ENABLED);
  TimelineClientImpl client=createTimelineClient(conf);
  mockClientResponse(client,ClientResponse.Status.INTERNAL_SERVER_ERROR,false,false);
  try {
    TimelinePutResponse response=client.putEntities(generateEntity());
    Assert.assertEquals(0,response.getErrors().size());
  }
 catch (  YarnException e) {
    Assert.fail("putEntities should already return before throwing the exception");
  }
}

</code></pre>

<br>
<pre class="type-9 type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testPostEntitiesTimelineServiceNotEnabled() throws Exception {
  YarnConfiguration conf=new YarnConfiguration();
  conf.setBoolean(YarnConfiguration.TIMELINE_SERVICE_ENABLED,false);
  TimelineClientImpl client=createTimelineClient(conf);
  mockClientResponse(client,ClientResponse.Status.INTERNAL_SERVER_ERROR,false,false);
  try {
    TimelinePutResponse response=client.putEntities(generateEntity());
    Assert.assertEquals(0,response.getErrors().size());
  }
 catch (  YarnException e) {
    Assert.fail("putEntities should already return before throwing the exception");
  }
}

</code></pre>

<br>
<pre class="type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testPostEntitiesConnectionRefused() throws Exception {
  mockClientResponse(client,null,false,true);
  try {
    client.putEntities(generateEntity());
    Assert.fail("RuntimeException is expected");
  }
 catch (  RuntimeException re) {
    Assert.assertTrue(re instanceof ClientHandlerException);
  }
}

</code></pre>

<br>
<pre class="type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testPostEntitiesNoResponse() throws Exception {
  mockClientResponse(client,ClientResponse.Status.INTERNAL_SERVER_ERROR,false,false);
  try {
    client.putEntities(generateEntity());
    Assert.fail("Exception is expected");
  }
 catch (  YarnException e) {
    Assert.assertTrue(e.getMessage().contains("Failed to get the response from the timeline server."));
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.yarn.client.api.impl.TestYarnClient </h4><pre class="type-9 type-13 type-11 type-2 type-7 type-1 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions in iterations
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=30000) public void testAMMRTokens() throws Exception {
  MiniYARNCluster cluster=new MiniYARNCluster("testMRAMTokens",1,1,1);
  YarnClient rmClient=null;
  try {
    cluster.init(new YarnConfiguration());
    cluster.start();
    final Configuration yarnConf=cluster.getConfig();
    rmClient=YarnClient.createYarnClient();
    rmClient.init(yarnConf);
    rmClient.start();
    ApplicationId appId=createApp(rmClient,false);
    waitTillAccepted(rmClient,appId);
    Assert.assertNull(rmClient.getAMRMToken(appId));
    appId=createApp(rmClient,true);
    waitTillAccepted(rmClient,appId);
    long start=System.currentTimeMillis();
    while (rmClient.getAMRMToken(appId) == null) {
      if (System.currentTimeMillis() - start > 20 * 1000) {
        Assert.fail("AMRM token is null");
      }
      Thread.sleep(100);
    }
    Assert.assertNotNull(rmClient.getAMRMToken(appId));
    UserGroupInformation other=UserGroupInformation.createUserForTesting("foo",new String[]{});
    appId=other.doAs(new PrivilegedExceptionAction<ApplicationId>(){
      @Override public ApplicationId run() throws Exception {
        YarnClient rmClient=YarnClient.createYarnClient();
        rmClient.init(yarnConf);
        rmClient.start();
        ApplicationId appId=createApp(rmClient,true);
        waitTillAccepted(rmClient,appId);
        long start=System.currentTimeMillis();
        while (rmClient.getAMRMToken(appId) == null) {
          if (System.currentTimeMillis() - start > 20 * 1000) {
            Assert.fail("AMRM token is null");
          }
          Thread.sleep(100);
        }
        Assert.assertNotNull(rmClient.getAMRMToken(appId));
        return appId;
      }
    }
);
    Assert.assertNull(rmClient.getAMRMToken(appId));
  }
  finally {
    if (rmClient != null) {
      rmClient.stop();
    }
    cluster.stop();
  }
}

</code></pre>

<br>
<pre class="type-13 type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@SuppressWarnings("deprecation") @Test(timeout=30000) public void testSubmitApplication(){
  Configuration conf=new Configuration();
  conf.setLong(YarnConfiguration.YARN_CLIENT_APP_SUBMISSION_POLL_INTERVAL_MS,100);
  final YarnClient client=new MockYarnClient();
  client.init(conf);
  client.start();
  YarnApplicationState[] exitStates=new YarnApplicationState[]{YarnApplicationState.SUBMITTED,YarnApplicationState.ACCEPTED,YarnApplicationState.RUNNING,YarnApplicationState.FINISHED,YarnApplicationState.FAILED,YarnApplicationState.KILLED};
  ApplicationSubmissionContext contextWithoutApplicationId=mock(ApplicationSubmissionContext.class);
  try {
    client.submitApplication(contextWithoutApplicationId);
    Assert.fail("Should throw the ApplicationIdNotProvidedException");
  }
 catch (  YarnException e) {
    Assert.assertTrue(e instanceof ApplicationIdNotProvidedException);
    Assert.assertTrue(e.getMessage().contains("ApplicationId is not provided in ApplicationSubmissionContext"));
  }
catch (  IOException e) {
    Assert.fail("IOException is not expected.");
  }
  for (int i=0; i < exitStates.length; ++i) {
    ApplicationSubmissionContext context=mock(ApplicationSubmissionContext.class);
    ApplicationId applicationId=ApplicationId.newInstance(System.currentTimeMillis(),i);
    when(context.getApplicationId()).thenReturn(applicationId);
    ((MockYarnClient)client).setYarnApplicationState(exitStates[i]);
    try {
      client.submitApplication(context);
    }
 catch (    YarnException e) {
      Assert.fail("Exception is not expected.");
    }
catch (    IOException e) {
      Assert.fail("Exception is not expected.");
    }
    verify(((MockYarnClient)client).mockReport,times(4 * i + 4)).getYarnApplicationState();
  }
  client.stop();
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.yarn.client.cli.TestYarnCLI </h4><pre class="type-2 type-7 type-19 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether two objects/variables are the same">IdentityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether two objects/variables are the same
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testKillApplication() throws Exception {
  ApplicationCLI cli=createAndGetAppCLI();
  ApplicationId applicationId=ApplicationId.newInstance(1234,5);
  ApplicationReport newApplicationReport2=ApplicationReport.newInstance(applicationId,ApplicationAttemptId.newInstance(applicationId,1),"user","queue","appname","host",124,null,YarnApplicationState.FINISHED,"diagnostics","url",0,0,FinalApplicationStatus.SUCCEEDED,null,"N/A",0.53789f,"YARN",null);
  when(client.getApplicationReport(any(ApplicationId.class))).thenReturn(newApplicationReport2);
  int result=cli.run(new String[]{"application","-kill",applicationId.toString()});
  assertEquals(0,result);
  verify(client,times(0)).killApplication(any(ApplicationId.class));
  verify(sysOut).println("Application " + applicationId + " has already finished ");
  ApplicationReport newApplicationReport=ApplicationReport.newInstance(applicationId,ApplicationAttemptId.newInstance(applicationId,1),"user","queue","appname","host",124,null,YarnApplicationState.RUNNING,"diagnostics","url",0,0,FinalApplicationStatus.SUCCEEDED,null,"N/A",0.53789f,"YARN",null);
  when(client.getApplicationReport(any(ApplicationId.class))).thenReturn(newApplicationReport);
  result=cli.run(new String[]{"application","-kill",applicationId.toString()});
  assertEquals(0,result);
  verify(client).killApplication(any(ApplicationId.class));
  verify(sysOut).println("Killing application application_1234_0005");
  doThrow(new ApplicationNotFoundException("Application with id '" + applicationId + "' doesn't exist in RM.")).when(client).getApplicationReport(applicationId);
  cli=createAndGetAppCLI();
  try {
    int exitCode=cli.run(new String[]{"application","-kill",applicationId.toString()});
    verify(sysOut).println("Application with id '" + applicationId + "' doesn't exist in RM.");
    Assert.assertNotSame("should return non-zero exit code.",0,exitCode);
  }
 catch (  ApplicationNotFoundException appEx) {
    Assert.fail("application -kill should not throw" + "ApplicationNotFoundException. " + appEx);
  }
catch (  Exception e) {
    Assert.fail("Unexpected exception: " + e);
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-10 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testGetApplicationReportException() throws Exception {
  ApplicationCLI cli=createAndGetAppCLI();
  ApplicationId applicationId=ApplicationId.newInstance(1234,5);
  when(client.getApplicationReport(any(ApplicationId.class))).thenThrow(new ApplicationNotFoundException("History file for application" + applicationId + " is not found"));
  try {
    cli.run(new String[]{"application","-status",applicationId.toString()});
    Assert.fail();
  }
 catch (  Exception ex) {
    Assert.assertTrue(ex instanceof ApplicationNotFoundException);
    Assert.assertEquals("History file for application" + applicationId + " is not found",ex.getMessage());
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-10 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testMoveApplicationAcrossQueues() throws Exception {
  ApplicationCLI cli=createAndGetAppCLI();
  ApplicationId applicationId=ApplicationId.newInstance(1234,5);
  ApplicationReport newApplicationReport2=ApplicationReport.newInstance(applicationId,ApplicationAttemptId.newInstance(applicationId,1),"user","queue","appname","host",124,null,YarnApplicationState.FINISHED,"diagnostics","url",0,0,FinalApplicationStatus.SUCCEEDED,null,"N/A",0.53789f,"YARN",null);
  when(client.getApplicationReport(any(ApplicationId.class))).thenReturn(newApplicationReport2);
  int result=cli.run(new String[]{"application","-movetoqueue",applicationId.toString(),"-queue","targetqueue"});
  assertEquals(0,result);
  verify(client,times(0)).moveApplicationAcrossQueues(any(ApplicationId.class),any(String.class));
  verify(sysOut).println("Application " + applicationId + " has already finished ");
  ApplicationReport newApplicationReport=ApplicationReport.newInstance(applicationId,ApplicationAttemptId.newInstance(applicationId,1),"user","queue","appname","host",124,null,YarnApplicationState.RUNNING,"diagnostics","url",0,0,FinalApplicationStatus.SUCCEEDED,null,"N/A",0.53789f,"YARN",null);
  when(client.getApplicationReport(any(ApplicationId.class))).thenReturn(newApplicationReport);
  result=cli.run(new String[]{"application","-movetoqueue",applicationId.toString(),"-queue","targetqueue"});
  assertEquals(0,result);
  verify(client).moveApplicationAcrossQueues(any(ApplicationId.class),any(String.class));
  verify(sysOut).println("Moving application application_1234_0005 to queue targetqueue");
  verify(sysOut).println("Successfully completed move.");
  doThrow(new ApplicationNotFoundException("Application with id '" + applicationId + "' doesn't exist in RM.")).when(client).moveApplicationAcrossQueues(applicationId,"targetqueue");
  cli=createAndGetAppCLI();
  try {
    result=cli.run(new String[]{"application","-movetoqueue",applicationId.toString(),"-queue","targetqueue"});
    Assert.fail();
  }
 catch (  Exception ex) {
    Assert.assertTrue(ex instanceof ApplicationNotFoundException);
    Assert.assertEquals("Application with id '" + applicationId + "' doesn't exist in RM.",ex.getMessage());
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.yarn.conf.TestHAUtil </h4><pre class="type-9 type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testVerifyAndSetConfiguration() throws Exception {
  try {
    HAUtil.verifyAndSetConfiguration(conf);
  }
 catch (  YarnRuntimeException e) {
    fail("Should not throw any exceptions.");
  }
  assertEquals("Should be saved as Trimmed collection",StringUtils.getStringCollection(RM_NODE_IDS),HAUtil.getRMHAIds(conf));
  assertEquals("Should be saved as Trimmed string",RM1_NODE_ID,HAUtil.getRMHAId(conf));
  for (  String confKey : YarnConfiguration.getServiceAddressConfKeys(conf)) {
    assertEquals("RPC address not set for " + confKey,RM1_ADDRESS,conf.get(confKey));
  }
  conf.clear();
  conf.set(YarnConfiguration.RM_HA_IDS,RM1_NODE_ID);
  try {
    HAUtil.verifyAndSetConfiguration(conf);
  }
 catch (  YarnRuntimeException e) {
    assertEquals("YarnRuntimeException by verifyAndSetRMHAIds()",HAUtil.BAD_CONFIG_MESSAGE_PREFIX + HAUtil.getInvalidValueMessage(YarnConfiguration.RM_HA_IDS,conf.get(YarnConfiguration.RM_HA_IDS) + "\nHA mode requires atleast two RMs"),e.getMessage());
  }
  conf.clear();
  conf.set(YarnConfiguration.RM_HA_IDS,RM1_NODE_ID + "," + RM2_NODE_ID);
  for (  String confKey : YarnConfiguration.getServiceAddressConfKeys(conf)) {
    conf.set(HAUtil.addSuffix(confKey,RM1_NODE_ID),RM1_ADDRESS);
    conf.set(HAUtil.addSuffix(confKey,RM2_NODE_ID),RM2_ADDRESS);
  }
  try {
    HAUtil.verifyAndSetConfiguration(conf);
  }
 catch (  YarnRuntimeException e) {
    assertEquals("YarnRuntimeException by getRMId()",HAUtil.BAD_CONFIG_MESSAGE_PREFIX + HAUtil.getNeedToSetValueMessage(YarnConfiguration.RM_HA_ID),e.getMessage());
  }
  conf.clear();
  conf.set(YarnConfiguration.RM_HA_ID,RM_INVALID_NODE_ID);
  conf.set(YarnConfiguration.RM_HA_IDS,RM_INVALID_NODE_ID + "," + RM1_NODE_ID);
  for (  String confKey : YarnConfiguration.getServiceAddressConfKeys(conf)) {
    conf.set(confKey + RM_INVALID_NODE_ID,RM_INVALID_NODE_ID);
  }
  try {
    HAUtil.verifyAndSetConfiguration(conf);
  }
 catch (  YarnRuntimeException e) {
    assertEquals("YarnRuntimeException by addSuffix()",HAUtil.BAD_CONFIG_MESSAGE_PREFIX + HAUtil.getInvalidValueMessage(YarnConfiguration.RM_HA_ID,RM_INVALID_NODE_ID),e.getMessage());
  }
  conf.clear();
  conf.set(YarnConfiguration.RM_HA_ID,RM1_NODE_ID);
  conf.set(YarnConfiguration.RM_HA_IDS,RM1_NODE_ID + "," + RM2_NODE_ID);
  try {
    HAUtil.verifyAndSetConfiguration(conf);
    fail("Should throw YarnRuntimeException. by Configuration#set()");
  }
 catch (  YarnRuntimeException e) {
    String confKey=HAUtil.addSuffix(YarnConfiguration.RM_ADDRESS,RM1_NODE_ID);
    assertEquals("YarnRuntimeException by Configuration#set()",HAUtil.BAD_CONFIG_MESSAGE_PREFIX + HAUtil.getNeedToSetValueMessage(HAUtil.addSuffix(YarnConfiguration.RM_HOSTNAME,RM1_NODE_ID) + " or " + confKey),e.getMessage());
  }
  conf.clear();
  conf.set(YarnConfiguration.RM_HA_IDS,RM2_NODE_ID + "," + RM3_NODE_ID);
  conf.set(YarnConfiguration.RM_HA_ID,RM1_NODE_ID_UNTRIMMED);
  for (  String confKey : YarnConfiguration.getServiceAddressConfKeys(conf)) {
    conf.set(HAUtil.addSuffix(confKey,RM1_NODE_ID),RM1_ADDRESS_UNTRIMMED);
    conf.set(HAUtil.addSuffix(confKey,RM2_NODE_ID),RM2_ADDRESS);
    conf.set(HAUtil.addSuffix(confKey,RM3_NODE_ID),RM3_ADDRESS);
  }
  try {
    HAUtil.verifyAndSetConfiguration(conf);
  }
 catch (  YarnRuntimeException e) {
    assertEquals("YarnRuntimeException by getRMId()'s validation",HAUtil.BAD_CONFIG_MESSAGE_PREFIX + HAUtil.getRMHAIdNeedToBeIncludedMessage("[rm2, rm3]",RM1_NODE_ID),e.getMessage());
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.yarn.logaggregation.TestAggregatedLogFormat </h4><pre class="type-11 type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testForCorruptedAggregatedLogs() throws Exception {
  Configuration conf=new Configuration();
  File workDir=new File(testWorkDir,"testReadAcontainerLogs1");
  Path remoteAppLogFile=new Path(workDir.getAbsolutePath(),"aggregatedLogFile");
  Path srcFileRoot=new Path(workDir.getAbsolutePath(),"srcFiles");
  ContainerId testContainerId=TestContainerId.newContainerId(1,1,1,1);
  Path t=new Path(srcFileRoot,testContainerId.getApplicationAttemptId().getApplicationId().toString());
  Path srcFilePath=new Path(t,testContainerId.toString());
  long numChars=950000;
  writeSrcFileAndALog(srcFilePath,"stdout",numChars,remoteAppLogFile,srcFileRoot,testContainerId);
  LogReader logReader=new LogReader(conf,remoteAppLogFile);
  LogKey rLogKey=new LogKey();
  DataInputStream dis=logReader.next(rLogKey);
  Writer writer=new StringWriter();
  try {
    LogReader.readAcontainerLogs(dis,writer);
  }
 catch (  Exception e) {
    if (e.toString().contains("NumberFormatException")) {
      Assert.fail("Aggregated logs are corrupted.");
    }
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.yarn.server.applicationhistoryservice.TestApplicationHistoryServer </h4><pre class="type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testLaunch() throws Exception {
  ExitUtil.disableSystemExit();
  try {
    historyServer=ApplicationHistoryServer.launchAppHistoryServer(new String[0]);
  }
 catch (  ExitUtil.ExitException e) {
    assertEquals(0,e.status);
    ExitUtil.resetFirstExitException();
    fail();
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.yarn.server.applicationhistoryservice.TestFileSystemApplicationHistoryStore </h4><pre class="type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testWriteAfterApplicationFinish() throws IOException {
  LOG.info("Starting testWriteAfterApplicationFinish");
  ApplicationId appId=ApplicationId.newInstance(0,1);
  writeApplicationStartData(appId);
  writeApplicationFinishData(appId);
  ApplicationAttemptId appAttemptId=ApplicationAttemptId.newInstance(appId,1);
  try {
    writeApplicationAttemptStartData(appAttemptId);
    Assert.fail();
  }
 catch (  IOException e) {
    Assert.assertTrue(e.getMessage().contains("is not opened"));
  }
  try {
    writeApplicationAttemptFinishData(appAttemptId);
    Assert.fail();
  }
 catch (  IOException e) {
    Assert.assertTrue(e.getMessage().contains("is not opened"));
  }
  ContainerId containerId=ContainerId.newInstance(appAttemptId,1);
  try {
    writeContainerStartData(containerId);
    Assert.fail();
  }
 catch (  IOException e) {
    Assert.assertTrue(e.getMessage().contains("is not opened"));
  }
  try {
    writeContainerFinishData(containerId);
    Assert.fail();
  }
 catch (  IOException e) {
    Assert.assertTrue(e.getMessage().contains("is not opened"));
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.yarn.server.applicationhistoryservice.TestMemoryApplicationHistoryStore </h4><pre class="type-9 type-13 type-2 type-7 type-10 type-1 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions in iterations
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects are null
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testReadWriteApplicationAttemptHistory() throws Exception {
  ApplicationId appId=ApplicationId.newInstance(0,1);
  ApplicationAttemptId appAttemptId=ApplicationAttemptId.newInstance(appId,1);
  try {
    writeApplicationAttemptFinishData(appAttemptId);
    Assert.fail();
  }
 catch (  IOException e) {
    Assert.assertTrue(e.getMessage().contains("is stored before the start information"));
  }
  int numAppAttempts=5;
  writeApplicationStartData(appId);
  for (int i=1; i <= numAppAttempts; ++i) {
    appAttemptId=ApplicationAttemptId.newInstance(appId,i);
    writeApplicationAttemptStartData(appAttemptId);
    writeApplicationAttemptFinishData(appAttemptId);
  }
  Assert.assertEquals(numAppAttempts,store.getApplicationAttempts(appId).size());
  for (int i=1; i <= numAppAttempts; ++i) {
    appAttemptId=ApplicationAttemptId.newInstance(appId,i);
    ApplicationAttemptHistoryData data=store.getApplicationAttempt(appAttemptId);
    Assert.assertNotNull(data);
    Assert.assertEquals(appAttemptId.toString(),data.getHost());
    Assert.assertEquals(appAttemptId.toString(),data.getDiagnosticsInfo());
  }
  writeApplicationFinishData(appId);
  appAttemptId=ApplicationAttemptId.newInstance(appId,1);
  try {
    writeApplicationAttemptStartData(appAttemptId);
    Assert.fail();
  }
 catch (  IOException e) {
    Assert.assertTrue(e.getMessage().contains("is already stored"));
  }
  try {
    writeApplicationAttemptFinishData(appAttemptId);
    Assert.fail();
  }
 catch (  IOException e) {
    Assert.assertTrue(e.getMessage().contains("is already stored"));
  }
}

</code></pre>

<br>
<pre class="type-9 type-13 type-2 type-7 type-10 type-1 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions in iterations
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects are null
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testReadWriteApplicationHistory() throws Exception {
  ApplicationId appId=ApplicationId.newInstance(0,1);
  try {
    writeApplicationFinishData(appId);
    Assert.fail();
  }
 catch (  IOException e) {
    Assert.assertTrue(e.getMessage().contains("is stored before the start information"));
  }
  int numApps=5;
  for (int i=1; i <= numApps; ++i) {
    appId=ApplicationId.newInstance(0,i);
    writeApplicationStartData(appId);
    writeApplicationFinishData(appId);
  }
  Assert.assertEquals(numApps,store.getAllApplications().size());
  for (int i=1; i <= numApps; ++i) {
    appId=ApplicationId.newInstance(0,i);
    ApplicationHistoryData data=store.getApplication(appId);
    Assert.assertNotNull(data);
    Assert.assertEquals(appId.toString(),data.getApplicationName());
    Assert.assertEquals(appId.toString(),data.getDiagnosticsInfo());
  }
  appId=ApplicationId.newInstance(0,1);
  try {
    writeApplicationStartData(appId);
    Assert.fail();
  }
 catch (  IOException e) {
    Assert.assertTrue(e.getMessage().contains("is already stored"));
  }
  try {
    writeApplicationFinishData(appId);
    Assert.fail();
  }
 catch (  IOException e) {
    Assert.assertTrue(e.getMessage().contains("is already stored"));
  }
}

</code></pre>

<br>
<pre class="type-9 type-13 type-2 type-7 type-10 type-1 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions in iterations
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects are null
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testReadWriteContainerHistory() throws Exception {
  ApplicationId appId=ApplicationId.newInstance(0,1);
  ApplicationAttemptId appAttemptId=ApplicationAttemptId.newInstance(appId,1);
  ContainerId containerId=ContainerId.newInstance(appAttemptId,1);
  try {
    writeContainerFinishData(containerId);
    Assert.fail();
  }
 catch (  IOException e) {
    Assert.assertTrue(e.getMessage().contains("is stored before the start information"));
  }
  writeApplicationAttemptStartData(appAttemptId);
  int numContainers=5;
  for (int i=1; i <= numContainers; ++i) {
    containerId=ContainerId.newInstance(appAttemptId,i);
    writeContainerStartData(containerId);
    writeContainerFinishData(containerId);
  }
  Assert.assertEquals(numContainers,store.getContainers(appAttemptId).size());
  for (int i=1; i <= numContainers; ++i) {
    containerId=ContainerId.newInstance(appAttemptId,i);
    ContainerHistoryData data=store.getContainer(containerId);
    Assert.assertNotNull(data);
    Assert.assertEquals(Priority.newInstance(containerId.getId()),data.getPriority());
    Assert.assertEquals(containerId.toString(),data.getDiagnosticsInfo());
  }
  ContainerHistoryData masterContainer=store.getAMContainer(appAttemptId);
  Assert.assertNotNull(masterContainer);
  Assert.assertEquals(ContainerId.newInstance(appAttemptId,1),masterContainer.getContainerId());
  writeApplicationAttemptFinishData(appAttemptId);
  containerId=ContainerId.newInstance(appAttemptId,1);
  try {
    writeContainerStartData(containerId);
    Assert.fail();
  }
 catch (  IOException e) {
    Assert.assertTrue(e.getMessage().contains("is already stored"));
  }
  try {
    writeContainerFinishData(containerId);
    Assert.fail();
  }
 catch (  IOException e) {
    Assert.assertTrue(e.getMessage().contains("is already stored"));
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.yarn.server.applicationhistoryservice.webapp.TestAHSWebServices </h4><pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testInvalidUri2() throws JSONException, Exception {
  WebResource r=resource();
  String responseStr="";
  try {
    responseStr=r.accept(MediaType.APPLICATION_JSON).get(String.class);
    fail("should have thrown exception on invalid uri");
  }
 catch (  UniformInterfaceException ue) {
    ClientResponse response=ue.getResponse();
    assertEquals(Status.NOT_FOUND,response.getClientResponseStatus());
    WebServicesTestUtils.checkStringMatch("error string exists and shouldn't","",responseStr);
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testInvalidAccept() throws JSONException, Exception {
  WebResource r=resource();
  String responseStr="";
  try {
    responseStr=r.path("ws").path("v1").path("applicationhistory").accept(MediaType.TEXT_PLAIN).get(String.class);
    fail("should have thrown exception on invalid uri");
  }
 catch (  UniformInterfaceException ue) {
    ClientResponse response=ue.getResponse();
    assertEquals(Status.INTERNAL_SERVER_ERROR,response.getClientResponseStatus());
    WebServicesTestUtils.checkStringMatch("error string exists and shouldn't","",responseStr);
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testInvalidUri() throws JSONException, Exception {
  WebResource r=resource();
  String responseStr="";
  try {
    responseStr=r.path("ws").path("v1").path("applicationhistory").path("bogus").accept(MediaType.APPLICATION_JSON).get(String.class);
    fail("should have thrown exception on invalid uri");
  }
 catch (  UniformInterfaceException ue) {
    ClientResponse response=ue.getResponse();
    assertEquals(Status.NOT_FOUND,response.getClientResponseStatus());
    WebServicesTestUtils.checkStringMatch("error string exists and shouldn't","",responseStr);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.yarn.server.nodemanager.TestLinuxContainerExecutor </h4><pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testNonsecureUsernamePattern() throws Exception {
  try {
    Configuration conf=new YarnConfiguration();
    conf.set(CommonConfigurationKeysPublic.HADOOP_SECURITY_AUTHENTICATION,"simple");
    UserGroupInformation.setConfiguration(conf);
    LinuxContainerExecutor lce=new LinuxContainerExecutor();
    lce.setConf(conf);
    lce.verifyUsernamePattern("foo");
    try {
      lce.verifyUsernamePattern("foo/x");
      Assert.fail();
    }
 catch (    IllegalArgumentException ex) {
    }
catch (    Throwable ex) {
      Assert.fail(ex.toString());
    }
    conf.set(YarnConfiguration.NM_NONSECURE_MODE_USER_PATTERN_KEY,"foo");
    lce=new LinuxContainerExecutor();
    lce.setConf(conf);
    lce.verifyUsernamePattern("foo");
    try {
      lce.verifyUsernamePattern("bar");
      Assert.fail();
    }
 catch (    IllegalArgumentException ex) {
    }
catch (    Throwable ex) {
      Assert.fail(ex.toString());
    }
    conf=new YarnConfiguration();
    conf.set(CommonConfigurationKeysPublic.HADOOP_SECURITY_AUTHENTICATION,"kerberos");
    UserGroupInformation.setConfiguration(conf);
    lce=new LinuxContainerExecutor();
    lce.setConf(conf);
    lce.verifyUsernamePattern("foo");
    lce.verifyUsernamePattern("foo/w");
  }
  finally {
    Configuration conf=new YarnConfiguration();
    conf.set(CommonConfigurationKeysPublic.HADOOP_SECURITY_AUTHENTICATION,"simple");
    UserGroupInformation.setConfiguration(conf);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.yarn.server.nodemanager.TestLinuxContainerExecutorWithMocks </h4><pre class="type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=5000) public void testStartLocalizer() throws IOException {
  InetSocketAddress address=InetSocketAddress.createUnresolved("localhost",8040);
  Path nmPrivateCTokensPath=new Path("file:///bin/nmPrivateCTokensPath");
  try {
    mockExec.startLocalizer(nmPrivateCTokensPath,address,"test","application_0","12345",dirsHandler.getLocalDirs(),dirsHandler.getLogDirs());
    List<String> result=readMockParams();
    Assert.assertEquals(result.size(),17);
    Assert.assertEquals(result.get(0),YarnConfiguration.DEFAULT_NM_NONSECURE_MODE_LOCAL_USER);
    Assert.assertEquals(result.get(1),"test");
    Assert.assertEquals(result.get(2),"0");
    Assert.assertEquals(result.get(3),"application_0");
    Assert.assertEquals(result.get(4),"/bin/nmPrivateCTokensPath");
    Assert.assertEquals(result.get(8),"-classpath");
    Assert.assertEquals(result.get(11),"org.apache.hadoop.yarn.server.nodemanager.containermanager.localizer.ContainerLocalizer");
    Assert.assertEquals(result.get(12),"test");
    Assert.assertEquals(result.get(13),"application_0");
    Assert.assertEquals(result.get(14),"12345");
    Assert.assertEquals(result.get(15),"localhost");
    Assert.assertEquals(result.get(16),"8040");
  }
 catch (  InterruptedException e) {
    LOG.error("Error:" + e.getMessage(),e);
    Assert.fail();
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.yarn.server.nodemanager.TestLocalDirsHandlerService </h4><pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testValidPathsDirHandlerService(){
  Configuration conf=new YarnConfiguration();
  String localDir1=new File("file:///" + testDir,"localDir1").getPath();
  String localDir2=new File("hdfs:///" + testDir,"localDir2").getPath();
  conf.set(YarnConfiguration.NM_LOCAL_DIRS,localDir1 + "," + localDir2);
  String logDir1=new File("file:///" + testDir,"logDir1").getPath();
  conf.set(YarnConfiguration.NM_LOG_DIRS,logDir1);
  LocalDirsHandlerService dirSvc=new LocalDirsHandlerService();
  try {
    dirSvc.init(conf);
    Assert.fail("Service should have thrown an exception due to wrong URI");
  }
 catch (  YarnRuntimeException e) {
  }
  Assert.assertEquals("Service should not be inited",STATE.STOPPED,dirSvc.getServiceState());
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.yarn.server.nodemanager.TestNodeManager </h4><pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testContainerExecutorInitCall(){
  NodeManager nm=new NodeManager();
  YarnConfiguration conf=new YarnConfiguration();
  conf.setClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,InvalidContainerExecutor.class,ContainerExecutor.class);
  try {
    nm.init(conf);
    fail("Init should fail");
  }
 catch (  YarnRuntimeException e) {
    assert (e.getCause().getMessage().contains("dummy executor init called"));
  }
 finally {
    nm.stop();
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.yarn.server.nodemanager.TestNodeStatusUpdater </h4><pre class="type-2 type-7 type-10 type-1 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=150000) public void testNMConnectionToRM() throws Exception {
  final long delta=50000;
  final long connectionWaitMs=5000;
  final long connectionRetryIntervalMs=1000;
  final long rmStartIntervalMS=2 * 1000;
  conf.setLong(YarnConfiguration.RESOURCEMANAGER_CONNECT_MAX_WAIT_MS,connectionWaitMs);
  conf.setLong(YarnConfiguration.RESOURCEMANAGER_CONNECT_RETRY_INTERVAL_MS,connectionRetryIntervalMs);
  NodeManagerWithCustomNodeStatusUpdater nmWithUpdater;
  nm=nmWithUpdater=new NodeManagerWithCustomNodeStatusUpdater(){
    @Override protected NodeStatusUpdater createUpdater(    Context context,    Dispatcher dispatcher,    NodeHealthCheckerService healthChecker){
      NodeStatusUpdater nodeStatusUpdater=new MyNodeStatusUpdater4(context,dispatcher,healthChecker,metrics,rmStartIntervalMS,true);
      return nodeStatusUpdater;
    }
  }
;
  nm.init(conf);
  long waitStartTime=System.currentTimeMillis();
  try {
    nm.start();
    Assert.fail("NM should have failed to start due to RM connect failure");
  }
 catch (  Exception e) {
    long t=System.currentTimeMillis();
    long duration=t - waitStartTime;
    boolean waitTimeValid=(duration >= connectionWaitMs) && (duration < (connectionWaitMs + delta));
    if (!waitTimeValid) {
      throw new Exception("NM should have tried re-connecting to RM during " + "period of at least " + connectionWaitMs + " ms, but "+ "stopped retrying within "+ (connectionWaitMs + delta)+ " ms: "+ e,e);
    }
  }
  nm=nmWithUpdater=new NodeManagerWithCustomNodeStatusUpdater(){
    @Override protected NodeStatusUpdater createUpdater(    Context context,    Dispatcher dispatcher,    NodeHealthCheckerService healthChecker){
      NodeStatusUpdater nodeStatusUpdater=new MyNodeStatusUpdater4(context,dispatcher,healthChecker,metrics,rmStartIntervalMS,false);
      return nodeStatusUpdater;
    }
  }
;
  nm.init(conf);
  NodeStatusUpdater updater=nmWithUpdater.getUpdater();
  Assert.assertNotNull("Updater not yet created ",updater);
  waitStartTime=System.currentTimeMillis();
  try {
    nm.start();
  }
 catch (  Exception ex) {
    LOG.error("NM should have started successfully " + "after connecting to RM.",ex);
    throw ex;
  }
  long duration=System.currentTimeMillis() - waitStartTime;
  MyNodeStatusUpdater4 myUpdater=(MyNodeStatusUpdater4)updater;
  Assert.assertTrue("NM started before updater triggered",myUpdater.isTriggered());
  Assert.assertTrue("NM should have connected to RM after " + "the start interval of " + rmStartIntervalMS + ": actual "+ duration+ " "+ myUpdater,(duration >= rmStartIntervalMS));
  Assert.assertTrue("NM should have connected to RM less than " + (rmStartIntervalMS + delta) + " milliseconds of RM starting up: actual "+ duration+ " "+ myUpdater,(duration < (rmStartIntervalMS + delta)));
}

</code></pre>

<br>
<pre class="type-13 type-11 type-2 type-7 type-10 type-6 type-20 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values related to public fields.">PublicFieldVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Verifies values related to public fields.
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testNMRegistration() throws InterruptedException {
  nm=new NodeManager(){
    @Override protected NodeStatusUpdater createNodeStatusUpdater(    Context context,    Dispatcher dispatcher,    NodeHealthCheckerService healthChecker){
      return new MyNodeStatusUpdater(context,dispatcher,healthChecker,metrics);
    }
  }
;
  YarnConfiguration conf=createNMConfig();
  nm.init(conf);
  Object[] services=nm.getServices().toArray();
  Object lastService=services[services.length - 1];
  Assert.assertTrue("last service is NOT the node status updater",lastService instanceof NodeStatusUpdater);
  new Thread(){
    public void run(){
      try {
        nm.start();
      }
 catch (      Throwable e) {
        TestNodeStatusUpdater.this.nmStartError=e;
        throw new YarnRuntimeException(e);
      }
    }
  }
.start();
  System.out.println(" ----- thread already started.." + nm.getServiceState());
  int waitCount=0;
  while (nm.getServiceState() == STATE.INITED && waitCount++ != 50) {
    LOG.info("Waiting for NM to start..");
    if (nmStartError != null) {
      LOG.error("Error during startup. ",nmStartError);
      Assert.fail(nmStartError.getCause().getMessage());
    }
    Thread.sleep(2000);
  }
  if (nm.getServiceState() != STATE.STARTED) {
    Assert.fail("NodeManager failed to start");
  }
  waitCount=0;
  while (heartBeatID <= 3 && waitCount++ != 200) {
    Thread.sleep(1000);
  }
  Assert.assertFalse(heartBeatID <= 3);
  Assert.assertEquals("Number of registered NMs is wrong!!",1,this.registeredNodes.size());
  nm.stop();
}

</code></pre>

<br>
<pre class="type-11 type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * Test completed containerStatus get back up when heart beat lost, and will
 * be sent via next heart beat.
 */
@Test(timeout=200000) public void testCompletedContainerStatusBackup() throws Exception {
  nm=new NodeManager(){
    @Override protected NodeStatusUpdater createNodeStatusUpdater(    Context context,    Dispatcher dispatcher,    NodeHealthCheckerService healthChecker){
      MyNodeStatusUpdater2 myNodeStatusUpdater=new MyNodeStatusUpdater2(context,dispatcher,healthChecker,metrics);
      return myNodeStatusUpdater;
    }
    @Override protected NMContext createNMContext(    NMContainerTokenSecretManager containerTokenSecretManager,    NMTokenSecretManagerInNM nmTokenSecretManager,    NMStateStoreService store){
      return new MyNMContext(containerTokenSecretManager,nmTokenSecretManager);
    }
  }
;
  YarnConfiguration conf=createNMConfig();
  nm.init(conf);
  nm.start();
  int waitCount=0;
  while (heartBeatID <= 3 && waitCount++ != 20) {
    Thread.sleep(500);
  }
  if (assertionFailedInThread.get()) {
    Assert.fail("ContainerStatus Backup failed");
  }
  nm.stop();
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.yarn.server.nodemanager.TestRecordFactory </h4><pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testPbRecordFactory(){
  RecordFactory pbRecordFactory=RecordFactoryPBImpl.get();
  try {
    LocalizerHeartbeatResponse response=pbRecordFactory.newRecordInstance(LocalizerHeartbeatResponse.class);
    Assert.assertEquals(LocalizerHeartbeatResponsePBImpl.class,response.getClass());
  }
 catch (  YarnRuntimeException e) {
    e.printStackTrace();
    Assert.fail("Failed to crete record");
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.yarn.server.nodemanager.containermanager.TestAuxServices </h4><pre class="type-11 type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testAuxServices(){
  Configuration conf=new Configuration();
  conf.setStrings(YarnConfiguration.NM_AUX_SERVICES,new String[]{"Asrv","Bsrv"});
  conf.setClass(String.format(YarnConfiguration.NM_AUX_SERVICE_FMT,"Asrv"),ServiceA.class,Service.class);
  conf.setClass(String.format(YarnConfiguration.NM_AUX_SERVICE_FMT,"Bsrv"),ServiceB.class,Service.class);
  final AuxServices aux=new AuxServices();
  aux.init(conf);
  int latch=1;
  for (  Service s : aux.getServices()) {
    assertEquals(INITED,s.getServiceState());
    if (s instanceof ServiceA) {
      latch*=2;
    }
 else     if (s instanceof ServiceB) {
      latch*=3;
    }
 else     fail("Unexpected service type " + s.getClass());
  }
  assertEquals("Invalid mix of services",6,latch);
  aux.start();
  for (  Service s : aux.getServices()) {
    assertEquals(STARTED,s.getServiceState());
  }
  aux.stop();
  for (  Service s : aux.getServices()) {
    assertEquals(STOPPED,s.getServiceState());
  }
}

</code></pre>

<br>
<pre class="type-11 type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testAuxServicesMeta(){
  Configuration conf=new Configuration();
  conf.setStrings(YarnConfiguration.NM_AUX_SERVICES,new String[]{"Asrv","Bsrv"});
  conf.setClass(String.format(YarnConfiguration.NM_AUX_SERVICE_FMT,"Asrv"),ServiceA.class,Service.class);
  conf.setClass(String.format(YarnConfiguration.NM_AUX_SERVICE_FMT,"Bsrv"),ServiceB.class,Service.class);
  final AuxServices aux=new AuxServices();
  aux.init(conf);
  int latch=1;
  for (  Service s : aux.getServices()) {
    assertEquals(INITED,s.getServiceState());
    if (s instanceof ServiceA) {
      latch*=2;
    }
 else     if (s instanceof ServiceB) {
      latch*=3;
    }
 else     fail("Unexpected service type " + s.getClass());
  }
  assertEquals("Invalid mix of services",6,latch);
  aux.start();
  for (  Service s : aux.getServices()) {
    assertEquals(STARTED,s.getServiceState());
  }
  Map<String,ByteBuffer> meta=aux.getMetaData();
  assertEquals(2,meta.size());
  assertEquals("A",new String(meta.get("Asrv").array()));
  assertEquals("B",new String(meta.get("Bsrv").array()));
  aux.stop();
  for (  Service s : aux.getServices()) {
    assertEquals(STOPPED,s.getServiceState());
  }
}

</code></pre>

<br>
<pre class="type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testValidAuxServiceName(){
  final AuxServices aux=new AuxServices();
  Configuration conf=new Configuration();
  conf.setStrings(YarnConfiguration.NM_AUX_SERVICES,new String[]{"Asrv1","Bsrv_2"});
  conf.setClass(String.format(YarnConfiguration.NM_AUX_SERVICE_FMT,"Asrv1"),ServiceA.class,Service.class);
  conf.setClass(String.format(YarnConfiguration.NM_AUX_SERVICE_FMT,"Bsrv_2"),ServiceB.class,Service.class);
  try {
    aux.init(conf);
  }
 catch (  Exception ex) {
    Assert.fail("Should not receive the exception.");
  }
  final AuxServices aux1=new AuxServices();
  conf.setStrings(YarnConfiguration.NM_AUX_SERVICES,new String[]{"1Asrv1"});
  conf.setClass(String.format(YarnConfiguration.NM_AUX_SERVICE_FMT,"1Asrv1"),ServiceA.class,Service.class);
  try {
    aux1.init(conf);
    Assert.fail("Should receive the exception.");
  }
 catch (  Exception ex) {
    assertTrue(ex.getMessage().contains("The ServiceName: 1Asrv1 set in " + "yarn.nodemanager.aux-services is invalid.The valid service name " + "should only contain a-zA-Z0-9_ and can not start with numbers"));
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.yarn.server.nodemanager.containermanager.launcher.TestContainerLaunch </h4><pre class="type-9 type-2 type-7 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=20000) public void testInvalidEnvSyntaxDiagnostics() throws IOException {
  File shellFile=null;
  try {
    shellFile=Shell.appendScriptExtension(tmpDir,"hello");
    Map<Path,List<String>> resources=new HashMap<Path,List<String>>();
    FileOutputStream fos=new FileOutputStream(shellFile);
    FileUtil.setExecutable(shellFile,true);
    Map<String,String> env=new HashMap<String,String>();
    env.put("APPLICATION_WORKFLOW_CONTEXT","{\"workflowId\":\"609f91c5cd83\"," + "\"workflowName\":\"\n\ninsert table " + "\npartition (cd_education_status)\nselect cd_demo_sk, cd_gender, ");
    List<String> commands=new ArrayList<String>();
    ContainerLaunch.writeLaunchEnv(fos,env,resources,commands);
    fos.flush();
    fos.close();
    Map<String,String> cmdEnv=new HashMap<String,String>();
    cmdEnv.put("LANG","C");
    Shell.ShellCommandExecutor shexc=new Shell.ShellCommandExecutor(new String[]{shellFile.getAbsolutePath()},tmpDir,cmdEnv);
    String diagnostics=null;
    try {
      shexc.execute();
      Assert.fail("Should catch exception");
    }
 catch (    ExitCodeException e) {
      diagnostics=e.getMessage();
    }
    Assert.assertTrue(diagnostics.contains(Shell.WINDOWS ? "is not recognized as an internal or external command" : "command not found"));
    Assert.assertTrue(shexc.getExitCode() != 0);
  }
  finally {
    if (shellFile != null && shellFile.exists()) {
      shellFile.delete();
    }
  }
}

</code></pre>

<br>
<pre class="type-2 type-15 type-6 type-21 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Sets implicit assumptions ">AssumptionSetter</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies logic rules using matcher-style statements">ConditionMatcher</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Sets implicit assumptions 
- Verifies whether objects/variable are equal to an expected value 
- Verifies logic rules using matcher-style statements
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=10000) public void testWindowsShellScriptBuilderMkdir() throws IOException {
  String mkDirCmd="@if not exist \"\" mkdir \"\"";
  Assume.assumeTrue(Shell.WINDOWS);
  assertEquals(8191,Shell.WINDOWS_MAX_SHELL_LENGHT);
  ShellScriptBuilder builder=ShellScriptBuilder.create();
  builder.mkdir(new Path(org.apache.commons.lang.StringUtils.repeat("A",1024)));
  builder.mkdir(new Path(org.apache.commons.lang.StringUtils.repeat("E",(Shell.WINDOWS_MAX_SHELL_LENGHT - mkDirCmd.length()) / 2)));
  try {
    builder.mkdir(new Path(org.apache.commons.lang.StringUtils.repeat("X",(Shell.WINDOWS_MAX_SHELL_LENGHT - mkDirCmd.length()) / 2 + 1)));
    fail("long mkdir was expected to throw");
  }
 catch (  IOException e) {
    assertThat(e.getMessage(),containsString(expectedMessage));
  }
}

</code></pre>

<br>
<pre class="type-9 type-2 type-7 type-10 type-1 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=20000) public void testInvalidSymlinkDiagnostics() throws IOException {
  File shellFile=null;
  File tempFile=null;
  String symLink=Shell.WINDOWS ? "test.cmd" : "test";
  File symLinkFile=null;
  try {
    shellFile=Shell.appendScriptExtension(tmpDir,"hello");
    tempFile=Shell.appendScriptExtension(tmpDir,"temp");
    String timeoutCommand=Shell.WINDOWS ? "@echo \"hello\"" : "echo \"hello\"";
    PrintWriter writer=new PrintWriter(new FileOutputStream(shellFile));
    FileUtil.setExecutable(shellFile,true);
    writer.println(timeoutCommand);
    writer.close();
    Map<Path,List<String>> resources=new HashMap<Path,List<String>>();
    Path invalidPath=new Path(shellFile.getAbsolutePath() + "randomPath");
    resources.put(invalidPath,Arrays.asList(symLink));
    FileOutputStream fos=new FileOutputStream(tempFile);
    Map<String,String> env=new HashMap<String,String>();
    List<String> commands=new ArrayList<String>();
    if (Shell.WINDOWS) {
      commands.add("cmd");
      commands.add("/c");
      commands.add("\"" + symLink + "\"");
    }
 else {
      commands.add("/bin/sh ./\\\"" + symLink + "\\\"");
    }
    ContainerLaunch.writeLaunchEnv(fos,env,resources,commands);
    fos.flush();
    fos.close();
    FileUtil.setExecutable(tempFile,true);
    Shell.ShellCommandExecutor shexc=new Shell.ShellCommandExecutor(new String[]{tempFile.getAbsolutePath()},tmpDir);
    String diagnostics=null;
    try {
      shexc.execute();
      Assert.fail("Should catch exception");
    }
 catch (    ExitCodeException e) {
      diagnostics=e.getMessage();
    }
    Assert.assertNotNull(diagnostics);
    Assert.assertTrue(shexc.getExitCode() != 0);
    symLinkFile=new File(tmpDir,symLink);
  }
  finally {
    if (shellFile != null && shellFile.exists()) {
      shellFile.delete();
    }
    if (tempFile != null && tempFile.exists()) {
      tempFile.delete();
    }
    if (symLinkFile != null && symLinkFile.exists()) {
      symLinkFile.delete();
    }
  }
}

</code></pre>

<br>
<pre class="type-2 type-15 type-6 type-21 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Sets implicit assumptions ">AssumptionSetter</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies logic rules using matcher-style statements">ConditionMatcher</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Sets implicit assumptions 
- Verifies whether objects/variable are equal to an expected value 
- Verifies logic rules using matcher-style statements
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=10000) public void testWindowsShellScriptBuilderLink() throws IOException {
  Assume.assumeTrue(Shell.WINDOWS);
  String linkCmd="@" + Shell.WINUTILS + " symlink \"\" \"\"";
  assertEquals(8191,Shell.WINDOWS_MAX_SHELL_LENGHT);
  ShellScriptBuilder builder=ShellScriptBuilder.create();
  builder.link(new Path(org.apache.commons.lang.StringUtils.repeat("A",1024)),new Path(org.apache.commons.lang.StringUtils.repeat("B",1024)));
  builder.link(new Path(org.apache.commons.lang.StringUtils.repeat("E",(Shell.WINDOWS_MAX_SHELL_LENGHT - linkCmd.length()) / 2)),new Path(org.apache.commons.lang.StringUtils.repeat("F",(Shell.WINDOWS_MAX_SHELL_LENGHT - linkCmd.length()) / 2)));
  try {
    builder.link(new Path(org.apache.commons.lang.StringUtils.repeat("X",(Shell.WINDOWS_MAX_SHELL_LENGHT - linkCmd.length()) / 2 + 1)),new Path(org.apache.commons.lang.StringUtils.repeat("Y",(Shell.WINDOWS_MAX_SHELL_LENGHT - linkCmd.length()) / 2) + 1));
    fail("long link was expected to throw");
  }
 catch (  IOException e) {
    assertThat(e.getMessage(),containsString(expectedMessage));
  }
}

</code></pre>

<br>
<pre class="type-2 type-15 type-6 type-21 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Sets implicit assumptions ">AssumptionSetter</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies logic rules using matcher-style statements">ConditionMatcher</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Sets implicit assumptions 
- Verifies whether objects/variable are equal to an expected value 
- Verifies logic rules using matcher-style statements
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=10000) public void testWindowsShellScriptBuilderCommand() throws IOException {
  String callCmd="@call ";
  Assume.assumeTrue(Shell.WINDOWS);
  assertEquals(8191,Shell.WINDOWS_MAX_SHELL_LENGHT);
  ShellScriptBuilder builder=ShellScriptBuilder.create();
  builder.command(Arrays.asList(org.apache.commons.lang.StringUtils.repeat("A",1024)));
  builder.command(Arrays.asList(org.apache.commons.lang.StringUtils.repeat("E",Shell.WINDOWS_MAX_SHELL_LENGHT - callCmd.length())));
  try {
    builder.command(Arrays.asList(org.apache.commons.lang.StringUtils.repeat("X",Shell.WINDOWS_MAX_SHELL_LENGHT - callCmd.length() + 1)));
    fail("longCommand was expected to throw");
  }
 catch (  IOException e) {
    assertThat(e.getMessage(),containsString(expectedMessage));
  }
  builder.command(Arrays.asList(org.apache.commons.lang.StringUtils.repeat("A",1024),org.apache.commons.lang.StringUtils.repeat("A",1024),org.apache.commons.lang.StringUtils.repeat("A",1024)));
  builder.command(Arrays.asList(org.apache.commons.lang.StringUtils.repeat("E",4095),org.apache.commons.lang.StringUtils.repeat("E",2047),org.apache.commons.lang.StringUtils.repeat("E",2047 - callCmd.length())));
  try {
    builder.command(Arrays.asList(org.apache.commons.lang.StringUtils.repeat("X",4095),org.apache.commons.lang.StringUtils.repeat("X",2047),org.apache.commons.lang.StringUtils.repeat("X",2048 - callCmd.length())));
    fail("long commands was expected to throw");
  }
 catch (  IOException e) {
    assertThat(e.getMessage(),containsString(expectedMessage));
  }
}

</code></pre>

<br>
<pre class="type-2 type-15 type-6 type-21 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Sets implicit assumptions ">AssumptionSetter</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies logic rules using matcher-style statements">ConditionMatcher</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Sets implicit assumptions 
- Verifies whether objects/variable are equal to an expected value 
- Verifies logic rules using matcher-style statements
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=10000) public void testWindowsShellScriptBuilderEnv() throws IOException {
  Assume.assumeTrue(Shell.WINDOWS);
  assertEquals(8191,Shell.WINDOWS_MAX_SHELL_LENGHT);
  ShellScriptBuilder builder=ShellScriptBuilder.create();
  builder.env("somekey",org.apache.commons.lang.StringUtils.repeat("A",1024));
  builder.env("somekey",org.apache.commons.lang.StringUtils.repeat("A",Shell.WINDOWS_MAX_SHELL_LENGHT - ("@set somekey=").length()));
  try {
    builder.env("somekey",org.apache.commons.lang.StringUtils.repeat("A",Shell.WINDOWS_MAX_SHELL_LENGHT - ("@set somekey=").length()) + 1);
    fail("long env was expected to throw");
  }
 catch (  IOException e) {
    assertThat(e.getMessage(),containsString(expectedMessage));
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * Test that script exists with non-zero exit code when command fails.
 * @throws IOException
 */
@Test(timeout=10000) public void testShellScriptBuilderNonZeroExitCode() throws IOException {
  ShellScriptBuilder builder=ShellScriptBuilder.create();
  builder.command(Arrays.asList(new String[]{"unknownCommand"}));
  File shellFile=Shell.appendScriptExtension(tmpDir,"testShellScriptBuilderError");
  PrintStream writer=new PrintStream(new FileOutputStream(shellFile));
  builder.write(writer);
  writer.close();
  try {
    FileUtil.setExecutable(shellFile,true);
    Shell.ShellCommandExecutor shexc=new Shell.ShellCommandExecutor(new String[]{shellFile.getAbsolutePath()},tmpDir);
    try {
      shexc.execute();
      fail("builder shell command was expected to throw");
    }
 catch (    IOException e) {
      System.out.println("Received an expected exception: " + e.getMessage());
    }
  }
  finally {
    FileUtil.fullyDelete(shellFile);
  }
}

</code></pre>

<br>
<pre class="type-9 type-2 type-7 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=20000) public void testContainerLaunchStdoutAndStderrDiagnostics() throws IOException {
  File shellFile=null;
  try {
    shellFile=Shell.appendScriptExtension(tmpDir,"hello");
    String command=Shell.WINDOWS ? "@echo \"hello\" & @echo \"error\" 1>&2 & exit /b 2" : "echo \"hello\"; echo \"error\" 1>&2; exit 2;";
    PrintWriter writer=new PrintWriter(new FileOutputStream(shellFile));
    FileUtil.setExecutable(shellFile,true);
    writer.println(command);
    writer.close();
    Map<Path,List<String>> resources=new HashMap<Path,List<String>>();
    FileOutputStream fos=new FileOutputStream(shellFile,true);
    Map<String,String> env=new HashMap<String,String>();
    List<String> commands=new ArrayList<String>();
    commands.add(command);
    ContainerLaunch.writeLaunchEnv(fos,env,resources,commands);
    fos.flush();
    fos.close();
    Shell.ShellCommandExecutor shexc=new Shell.ShellCommandExecutor(new String[]{shellFile.getAbsolutePath()},tmpDir);
    String diagnostics=null;
    try {
      shexc.execute();
      Assert.fail("Should catch exception");
    }
 catch (    ExitCodeException e) {
      diagnostics=e.getMessage();
    }
    Assert.assertTrue(diagnostics.contains("error"));
    Assert.assertTrue(shexc.getOutput().contains("hello"));
    Assert.assertTrue(shexc.getExitCode() == 2);
  }
  finally {
    if (shellFile != null && shellFile.exists()) {
      shellFile.delete();
    }
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.yarn.server.nodemanager.containermanager.localizer.TestLocalResourcesTrackerImpl </h4><pre class="type-9 type-11 type-2 type-7 type-10 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=10000) @SuppressWarnings("unchecked") public void testConsistency(){
  String user="testuser";
  DrainDispatcher dispatcher=null;
  try {
    Configuration conf=new Configuration();
    dispatcher=createDispatcher(conf);
    EventHandler<LocalizerEvent> localizerEventHandler=mock(EventHandler.class);
    EventHandler<LocalizerEvent> containerEventHandler=mock(EventHandler.class);
    dispatcher.register(LocalizerEventType.class,localizerEventHandler);
    dispatcher.register(ContainerEventType.class,containerEventHandler);
    ContainerId cId1=BuilderUtils.newContainerId(1,1,1,1);
    LocalizerContext lc1=new LocalizerContext(user,cId1,null);
    LocalResourceRequest req1=createLocalResourceRequest(user,1,1,LocalResourceVisibility.PUBLIC);
    LocalizedResource lr1=createLocalizedResource(req1,dispatcher);
    ConcurrentMap<LocalResourceRequest,LocalizedResource> localrsrc=new ConcurrentHashMap<LocalResourceRequest,LocalizedResource>();
    localrsrc.put(req1,lr1);
    LocalResourcesTracker tracker=new LocalResourcesTrackerImpl(user,null,dispatcher,localrsrc,false,conf,new NMNullStateStoreService());
    ResourceEvent req11Event=new ResourceRequestEvent(req1,LocalResourceVisibility.PUBLIC,lc1);
    ResourceEvent rel11Event=new ResourceReleaseEvent(req1,cId1);
    tracker.handle(req11Event);
    dispatcher.await();
    Assert.assertEquals(1,lr1.getRefCount());
    dispatcher.await();
    verifyTrackedResourceCount(tracker,1);
    ResourceLocalizedEvent rle=new ResourceLocalizedEvent(req1,new Path("file:///tmp/r1"),1);
    lr1.handle(rle);
    Assert.assertTrue(lr1.getState().equals(ResourceState.LOCALIZED));
    Assert.assertTrue(createdummylocalizefile(new Path("file:///tmp/r1")));
    LocalizedResource rsrcbefore=tracker.iterator().next();
    File resFile=new File(lr1.getLocalPath().toUri().getRawPath().toString());
    Assert.assertTrue(resFile.exists());
    Assert.assertTrue(resFile.delete());
    tracker.handle(req11Event);
    dispatcher.await();
    lr1.handle(rle);
    Assert.assertTrue(lr1.getState().equals(ResourceState.LOCALIZED));
    LocalizedResource rsrcafter=tracker.iterator().next();
    if (rsrcbefore == rsrcafter) {
      Assert.fail("Localized resource should not be equal");
    }
    tracker.handle(rel11Event);
  }
  finally {
    if (dispatcher != null) {
      dispatcher.stop();
    }
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.yarn.server.nodemanager.recovery.TestNMLeveldbStateStoreService </h4><pre class="type-2 type-7 type-10 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testCheckVersion() throws IOException {
  Version defaultVersion=stateStore.getCurrentVersion();
  Assert.assertEquals(defaultVersion,stateStore.loadVersion());
  Version compatibleVersion=Version.newInstance(defaultVersion.getMajorVersion(),defaultVersion.getMinorVersion() + 2);
  stateStore.storeVersion(compatibleVersion);
  Assert.assertEquals(compatibleVersion,stateStore.loadVersion());
  restartStateStore();
  Assert.assertEquals(defaultVersion,stateStore.loadVersion());
  Version incompatibleVersion=Version.newInstance(defaultVersion.getMajorVersion() + 1,defaultVersion.getMinorVersion());
  stateStore.storeVersion(incompatibleVersion);
  try {
    restartStateStore();
    Assert.fail("Incompatible version, should expect fail here.");
  }
 catch (  ServiceStateException e) {
    Assert.assertTrue("Exception message mismatch",e.getMessage().contains("Incompatible version for NM state:"));
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.yarn.server.nodemanager.security.TestNMContainerTokenSecretManager </h4><pre class="type-9 type-2 type-7 type-10 type-1 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects are null
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testRecovery() throws IOException {
  YarnConfiguration conf=new YarnConfiguration();
  conf.setBoolean(YarnConfiguration.NM_RECOVERY_ENABLED,true);
  final NodeId nodeId=NodeId.newInstance("somehost",1234);
  final ContainerId cid1=BuilderUtils.newContainerId(1,1,1,1);
  final ContainerId cid2=BuilderUtils.newContainerId(2,2,2,2);
  ContainerTokenKeyGeneratorForTest keygen=new ContainerTokenKeyGeneratorForTest(conf);
  NMMemoryStateStoreService stateStore=new NMMemoryStateStoreService();
  stateStore.init(conf);
  stateStore.start();
  NMContainerTokenSecretManager secretMgr=new NMContainerTokenSecretManager(conf,stateStore);
  secretMgr.setNodeId(nodeId);
  MasterKey currentKey=keygen.generateKey();
  secretMgr.setMasterKey(currentKey);
  ContainerTokenIdentifier tokenId1=createContainerTokenId(cid1,nodeId,"user1",secretMgr);
  ContainerTokenIdentifier tokenId2=createContainerTokenId(cid2,nodeId,"user2",secretMgr);
  assertNotNull(secretMgr.retrievePassword(tokenId1));
  assertNotNull(secretMgr.retrievePassword(tokenId2));
  secretMgr=new NMContainerTokenSecretManager(conf,stateStore);
  secretMgr.setNodeId(nodeId);
  secretMgr.recover();
  assertEquals(currentKey,secretMgr.getCurrentKey());
  assertTrue(secretMgr.isValidStartContainerRequest(tokenId1));
  assertTrue(secretMgr.isValidStartContainerRequest(tokenId2));
  assertNotNull(secretMgr.retrievePassword(tokenId1));
  assertNotNull(secretMgr.retrievePassword(tokenId2));
  secretMgr.startContainerSuccessful(tokenId2);
  currentKey=keygen.generateKey();
  secretMgr.setMasterKey(currentKey);
  secretMgr=new NMContainerTokenSecretManager(conf,stateStore);
  secretMgr.setNodeId(nodeId);
  secretMgr.recover();
  assertEquals(currentKey,secretMgr.getCurrentKey());
  assertTrue(secretMgr.isValidStartContainerRequest(tokenId1));
  assertFalse(secretMgr.isValidStartContainerRequest(tokenId2));
  assertNotNull(secretMgr.retrievePassword(tokenId1));
  assertNotNull(secretMgr.retrievePassword(tokenId2));
  currentKey=keygen.generateKey();
  secretMgr.setMasterKey(currentKey);
  secretMgr=new NMContainerTokenSecretManager(conf,stateStore);
  secretMgr.setNodeId(nodeId);
  secretMgr.recover();
  assertEquals(currentKey,secretMgr.getCurrentKey());
  assertTrue(secretMgr.isValidStartContainerRequest(tokenId1));
  assertFalse(secretMgr.isValidStartContainerRequest(tokenId2));
  try {
    secretMgr.retrievePassword(tokenId1);
    fail("token should not be valid");
  }
 catch (  InvalidToken e) {
  }
  try {
    secretMgr.retrievePassword(tokenId2);
    fail("token should not be valid");
  }
 catch (  InvalidToken e) {
  }
  stateStore.close();
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.yarn.server.nodemanager.security.TestNMTokenSecretManagerInNM </h4><pre class="type-2 type-7 type-10 type-1 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects are null
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testRecovery() throws IOException {
  YarnConfiguration conf=new YarnConfiguration();
  conf.setBoolean(YarnConfiguration.NM_RECOVERY_ENABLED,true);
  final NodeId nodeId=NodeId.newInstance("somehost",1234);
  final ApplicationAttemptId attempt1=ApplicationAttemptId.newInstance(ApplicationId.newInstance(1,1),1);
  final ApplicationAttemptId attempt2=ApplicationAttemptId.newInstance(ApplicationId.newInstance(2,2),2);
  NMTokenKeyGeneratorForTest keygen=new NMTokenKeyGeneratorForTest();
  NMMemoryStateStoreService stateStore=new NMMemoryStateStoreService();
  stateStore.init(conf);
  stateStore.start();
  NMTokenSecretManagerInNM secretMgr=new NMTokenSecretManagerInNM(stateStore);
  secretMgr.setNodeId(nodeId);
  MasterKey currentKey=keygen.generateKey();
  secretMgr.setMasterKey(currentKey);
  NMTokenIdentifier attemptToken1=getNMTokenId(secretMgr.createNMToken(attempt1,nodeId,"user1"));
  NMTokenIdentifier attemptToken2=getNMTokenId(secretMgr.createNMToken(attempt2,nodeId,"user2"));
  secretMgr.appAttemptStartContainer(attemptToken1);
  secretMgr.appAttemptStartContainer(attemptToken2);
  assertTrue(secretMgr.isAppAttemptNMTokenKeyPresent(attempt1));
  assertTrue(secretMgr.isAppAttemptNMTokenKeyPresent(attempt2));
  assertNotNull(secretMgr.retrievePassword(attemptToken1));
  assertNotNull(secretMgr.retrievePassword(attemptToken2));
  secretMgr=new NMTokenSecretManagerInNM(stateStore);
  secretMgr.recover();
  secretMgr.setNodeId(nodeId);
  assertEquals(currentKey,secretMgr.getCurrentKey());
  assertTrue(secretMgr.isAppAttemptNMTokenKeyPresent(attempt1));
  assertTrue(secretMgr.isAppAttemptNMTokenKeyPresent(attempt2));
  assertNotNull(secretMgr.retrievePassword(attemptToken1));
  assertNotNull(secretMgr.retrievePassword(attemptToken2));
  currentKey=keygen.generateKey();
  secretMgr.setMasterKey(currentKey);
  secretMgr.appFinished(attempt1.getApplicationId());
  secretMgr=new NMTokenSecretManagerInNM(stateStore);
  secretMgr.recover();
  secretMgr.setNodeId(nodeId);
  assertEquals(currentKey,secretMgr.getCurrentKey());
  assertFalse(secretMgr.isAppAttemptNMTokenKeyPresent(attempt1));
  assertTrue(secretMgr.isAppAttemptNMTokenKeyPresent(attempt2));
  assertNotNull(secretMgr.retrievePassword(attemptToken1));
  assertNotNull(secretMgr.retrievePassword(attemptToken2));
  currentKey=keygen.generateKey();
  secretMgr.setMasterKey(currentKey);
  secretMgr=new NMTokenSecretManagerInNM(stateStore);
  secretMgr.recover();
  secretMgr.setNodeId(nodeId);
  assertEquals(currentKey,secretMgr.getCurrentKey());
  assertFalse(secretMgr.isAppAttemptNMTokenKeyPresent(attempt1));
  assertTrue(secretMgr.isAppAttemptNMTokenKeyPresent(attempt2));
  try {
    secretMgr.retrievePassword(attemptToken1);
    fail("attempt token should not still be valid");
  }
 catch (  InvalidToken e) {
  }
  assertNotNull(secretMgr.retrievePassword(attemptToken2));
  secretMgr.appFinished(attempt2.getApplicationId());
  secretMgr=new NMTokenSecretManagerInNM(stateStore);
  secretMgr.recover();
  secretMgr.setNodeId(nodeId);
  assertEquals(currentKey,secretMgr.getCurrentKey());
  assertFalse(secretMgr.isAppAttemptNMTokenKeyPresent(attempt1));
  assertFalse(secretMgr.isAppAttemptNMTokenKeyPresent(attempt2));
  try {
    secretMgr.retrievePassword(attemptToken1);
    fail("attempt token should not still be valid");
  }
 catch (  InvalidToken e) {
  }
  try {
    secretMgr.retrievePassword(attemptToken2);
    fail("attempt token should not still be valid");
  }
 catch (  InvalidToken e) {
  }
  stateStore.close();
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.yarn.server.nodemanager.util.TestProcessIdFileReader </h4><pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test(timeout=30000) public void testNullPath(){
  String pid=null;
  try {
    pid=ProcessIdFileReader.getProcessId(null);
    fail("Expected an error to be thrown for null path");
  }
 catch (  Exception e) {
  }
  assert (pid == null);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.yarn.server.nodemanager.webapp.TestNMWebServices </h4><pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testInvalidUri2() throws JSONException, Exception {
  WebResource r=resource();
  String responseStr="";
  try {
    responseStr=r.accept(MediaType.APPLICATION_JSON).get(String.class);
    fail("should have thrown exception on invalid uri");
  }
 catch (  UniformInterfaceException ue) {
    ClientResponse response=ue.getResponse();
    assertEquals(Status.NOT_FOUND,response.getClientResponseStatus());
    WebServicesTestUtils.checkStringMatch("error string exists and shouldn't","",responseStr);
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testInvalidUri() throws JSONException, Exception {
  WebResource r=resource();
  String responseStr="";
  try {
    responseStr=r.path("ws").path("v1").path("node").path("bogus").accept(MediaType.APPLICATION_JSON).get(String.class);
    fail("should have thrown exception on invalid uri");
  }
 catch (  UniformInterfaceException ue) {
    ClientResponse response=ue.getResponse();
    assertEquals(Status.NOT_FOUND,response.getClientResponseStatus());
    WebServicesTestUtils.checkStringMatch("error string exists and shouldn't","",responseStr);
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testInvalidAccept() throws JSONException, Exception {
  WebResource r=resource();
  String responseStr="";
  try {
    responseStr=r.path("ws").path("v1").path("node").accept(MediaType.TEXT_PLAIN).get(String.class);
    fail("should have thrown exception on invalid uri");
  }
 catch (  UniformInterfaceException ue) {
    ClientResponse response=ue.getResponse();
    assertEquals(Status.INTERNAL_SERVER_ERROR,response.getClientResponseStatus());
    WebServicesTestUtils.checkStringMatch("error string exists and shouldn't","",responseStr);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.yarn.server.nodemanager.webapp.TestNMWebServicesApps </h4><pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testNodeSingleAppsMissing() throws JSONException, Exception {
  WebResource r=resource();
  Application app=new MockApp(1);
  nmContext.getApplications().put(app.getAppId(),app);
  addAppContainers(app);
  Application app2=new MockApp(2);
  nmContext.getApplications().put(app2.getAppId(),app2);
  addAppContainers(app2);
  try {
    r.path("ws").path("v1").path("node").path("apps").path("application_1234_0009").accept(MediaType.APPLICATION_JSON).get(JSONObject.class);
    fail("should have thrown exception on invalid user query");
  }
 catch (  UniformInterfaceException ue) {
    ClientResponse response=ue.getResponse();
    assertEquals(Status.NOT_FOUND,response.getClientResponseStatus());
    assertEquals(MediaType.APPLICATION_JSON_TYPE,response.getType());
    JSONObject msg=response.getEntity(JSONObject.class);
    JSONObject exception=msg.getJSONObject("RemoteException");
    assertEquals("incorrect number of elements",3,exception.length());
    String message=exception.getString("message");
    String type=exception.getString("exception");
    String classname=exception.getString("javaClassName");
    WebServicesTestUtils.checkStringMatch("exception message","java.lang.Exception: app with id application_1234_0009 not found",message);
    WebServicesTestUtils.checkStringMatch("exception type","NotFoundException",type);
    WebServicesTestUtils.checkStringMatch("exception classname","org.apache.hadoop.yarn.webapp.NotFoundException",classname);
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testNodeAppsUserEmpty() throws JSONException, Exception {
  WebResource r=resource();
  Application app=new MockApp(1);
  nmContext.getApplications().put(app.getAppId(),app);
  addAppContainers(app);
  Application app2=new MockApp("foo",1234,2);
  nmContext.getApplications().put(app2.getAppId(),app2);
  addAppContainers(app2);
  try {
    r.path("ws").path("v1").path("node").path("apps").queryParam("user","").accept(MediaType.APPLICATION_JSON).get(JSONObject.class);
    fail("should have thrown exception on invalid user query");
  }
 catch (  UniformInterfaceException ue) {
    ClientResponse response=ue.getResponse();
    assertEquals(Status.BAD_REQUEST,response.getClientResponseStatus());
    assertEquals(MediaType.APPLICATION_JSON_TYPE,response.getType());
    JSONObject msg=response.getEntity(JSONObject.class);
    JSONObject exception=msg.getJSONObject("RemoteException");
    assertEquals("incorrect number of elements",3,exception.length());
    String message=exception.getString("message");
    String type=exception.getString("exception");
    String classname=exception.getString("javaClassName");
    WebServicesTestUtils.checkStringMatch("exception message","java.lang.Exception: Error: You must specify a non-empty string for the user",message);
    WebServicesTestUtils.checkStringMatch("exception type","BadRequestException",type);
    WebServicesTestUtils.checkStringMatch("exception classname","org.apache.hadoop.yarn.webapp.BadRequestException",classname);
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testNodeAppsStateInvalidDefault() throws JSONException, Exception {
  WebResource r=resource();
  Application app=new MockApp(1);
  nmContext.getApplications().put(app.getAppId(),app);
  addAppContainers(app);
  Application app2=new MockApp("foo",1234,2);
  nmContext.getApplications().put(app2.getAppId(),app2);
  addAppContainers(app2);
  try {
    r.path("ws").path("v1").path("node").path("apps").queryParam("state","FOO_STATE").get(JSONObject.class);
    fail("should have thrown exception on invalid user query");
  }
 catch (  UniformInterfaceException ue) {
    ClientResponse response=ue.getResponse();
    assertEquals(Status.BAD_REQUEST,response.getClientResponseStatus());
    assertEquals(MediaType.APPLICATION_JSON_TYPE,response.getType());
    JSONObject msg=response.getEntity(JSONObject.class);
    JSONObject exception=msg.getJSONObject("RemoteException");
    assertEquals("incorrect number of elements",3,exception.length());
    String message=exception.getString("message");
    String type=exception.getString("exception");
    String classname=exception.getString("javaClassName");
    verifyStateInvalidException(message,type,classname);
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testNodeAppsStateInvalid() throws JSONException, Exception {
  WebResource r=resource();
  Application app=new MockApp(1);
  nmContext.getApplications().put(app.getAppId(),app);
  addAppContainers(app);
  Application app2=new MockApp("foo",1234,2);
  nmContext.getApplications().put(app2.getAppId(),app2);
  addAppContainers(app2);
  try {
    r.path("ws").path("v1").path("node").path("apps").queryParam("state","FOO_STATE").accept(MediaType.APPLICATION_JSON).get(JSONObject.class);
    fail("should have thrown exception on invalid user query");
  }
 catch (  UniformInterfaceException ue) {
    ClientResponse response=ue.getResponse();
    assertEquals(Status.BAD_REQUEST,response.getClientResponseStatus());
    assertEquals(MediaType.APPLICATION_JSON_TYPE,response.getType());
    JSONObject msg=response.getEntity(JSONObject.class);
    JSONObject exception=msg.getJSONObject("RemoteException");
    assertEquals("incorrect number of elements",3,exception.length());
    String message=exception.getString("message");
    String type=exception.getString("exception");
    String classname=exception.getString("javaClassName");
    verifyStateInvalidException(message,type,classname);
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testNodeSingleAppsInvalid() throws JSONException, Exception {
  WebResource r=resource();
  Application app=new MockApp(1);
  nmContext.getApplications().put(app.getAppId(),app);
  addAppContainers(app);
  Application app2=new MockApp(2);
  nmContext.getApplications().put(app2.getAppId(),app2);
  addAppContainers(app2);
  try {
    r.path("ws").path("v1").path("node").path("apps").path("app_foo_0000").accept(MediaType.APPLICATION_JSON).get(JSONObject.class);
    fail("should have thrown exception on invalid user query");
  }
 catch (  UniformInterfaceException ue) {
    ClientResponse response=ue.getResponse();
    assertEquals(Status.BAD_REQUEST,response.getClientResponseStatus());
    assertEquals(MediaType.APPLICATION_JSON_TYPE,response.getType());
    JSONObject msg=response.getEntity(JSONObject.class);
    JSONObject exception=msg.getJSONObject("RemoteException");
    assertEquals("incorrect number of elements",3,exception.length());
    String message=exception.getString("message");
    String type=exception.getString("exception");
    String classname=exception.getString("javaClassName");
    WebServicesTestUtils.checkStringMatch("exception message","For input string: \"foo\"",message);
    WebServicesTestUtils.checkStringMatch("exception type","NumberFormatException",type);
    WebServicesTestUtils.checkStringMatch("exception classname","java.lang.NumberFormatException",classname);
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testNodeAppsStateInvalidXML() throws JSONException, Exception {
  WebResource r=resource();
  Application app=new MockApp(1);
  nmContext.getApplications().put(app.getAppId(),app);
  addAppContainers(app);
  Application app2=new MockApp("foo",1234,2);
  nmContext.getApplications().put(app2.getAppId(),app2);
  addAppContainers(app2);
  try {
    r.path("ws").path("v1").path("node").path("apps").queryParam("state","FOO_STATE").accept(MediaType.APPLICATION_XML).get(JSONObject.class);
    fail("should have thrown exception on invalid user query");
  }
 catch (  UniformInterfaceException ue) {
    ClientResponse response=ue.getResponse();
    assertEquals(Status.BAD_REQUEST,response.getClientResponseStatus());
    assertEquals(MediaType.APPLICATION_XML_TYPE,response.getType());
    String msg=response.getEntity(String.class);
    DocumentBuilderFactory dbf=DocumentBuilderFactory.newInstance();
    DocumentBuilder db=dbf.newDocumentBuilder();
    InputSource is=new InputSource();
    is.setCharacterStream(new StringReader(msg));
    Document dom=db.parse(is);
    NodeList nodes=dom.getElementsByTagName("RemoteException");
    Element element=(Element)nodes.item(0);
    String message=WebServicesTestUtils.getXmlString(element,"message");
    String type=WebServicesTestUtils.getXmlString(element,"exception");
    String classname=WebServicesTestUtils.getXmlString(element,"javaClassName");
    verifyStateInvalidException(message,type,classname);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.yarn.server.nodemanager.webapp.TestNMWebServicesContainers </h4><pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testSingleContainerInvalid() throws JSONException, Exception {
  WebResource r=resource();
  Application app=new MockApp(1);
  nmContext.getApplications().put(app.getAppId(),app);
  addAppContainers(app);
  Application app2=new MockApp(2);
  nmContext.getApplications().put(app2.getAppId(),app2);
  addAppContainers(app2);
  try {
    r.path("ws").path("v1").path("node").path("containers").path("container_foo_1234").accept(MediaType.APPLICATION_JSON).get(JSONObject.class);
    fail("should have thrown exception on invalid user query");
  }
 catch (  UniformInterfaceException ue) {
    ClientResponse response=ue.getResponse();
    assertEquals(Status.BAD_REQUEST,response.getClientResponseStatus());
    assertEquals(MediaType.APPLICATION_JSON_TYPE,response.getType());
    JSONObject msg=response.getEntity(JSONObject.class);
    JSONObject exception=msg.getJSONObject("RemoteException");
    assertEquals("incorrect number of elements",3,exception.length());
    String message=exception.getString("message");
    String type=exception.getString("exception");
    String classname=exception.getString("javaClassName");
    WebServicesTestUtils.checkStringMatch("exception message","java.lang.Exception: invalid container id, container_foo_1234",message);
    WebServicesTestUtils.checkStringMatch("exception type","BadRequestException",type);
    WebServicesTestUtils.checkStringMatch("exception classname","org.apache.hadoop.yarn.webapp.BadRequestException",classname);
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testSingleContainerWrong() throws JSONException, Exception {
  WebResource r=resource();
  Application app=new MockApp(1);
  nmContext.getApplications().put(app.getAppId(),app);
  addAppContainers(app);
  Application app2=new MockApp(2);
  nmContext.getApplications().put(app2.getAppId(),app2);
  addAppContainers(app2);
  try {
    r.path("ws").path("v1").path("node").path("containers").path("container_1234_0001_01_000005").accept(MediaType.APPLICATION_JSON).get(JSONObject.class);
    fail("should have thrown exception on invalid user query");
  }
 catch (  UniformInterfaceException ue) {
    ClientResponse response=ue.getResponse();
    assertEquals(Status.NOT_FOUND,response.getClientResponseStatus());
    assertEquals(MediaType.APPLICATION_JSON_TYPE,response.getType());
    JSONObject msg=response.getEntity(JSONObject.class);
    JSONObject exception=msg.getJSONObject("RemoteException");
    assertEquals("incorrect number of elements",3,exception.length());
    String message=exception.getString("message");
    String type=exception.getString("exception");
    String classname=exception.getString("javaClassName");
    WebServicesTestUtils.checkStringMatch("exception message","java.lang.Exception: container with id, container_1234_0001_01_000005, not found",message);
    WebServicesTestUtils.checkStringMatch("exception type","NotFoundException",type);
    WebServicesTestUtils.checkStringMatch("exception classname","org.apache.hadoop.yarn.webapp.NotFoundException",classname);
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testSingleContainerInvalid2() throws JSONException, Exception {
  WebResource r=resource();
  Application app=new MockApp(1);
  nmContext.getApplications().put(app.getAppId(),app);
  addAppContainers(app);
  Application app2=new MockApp(2);
  nmContext.getApplications().put(app2.getAppId(),app2);
  addAppContainers(app2);
  try {
    r.path("ws").path("v1").path("node").path("containers").path("container_1234_0001").accept(MediaType.APPLICATION_JSON).get(JSONObject.class);
    fail("should have thrown exception on invalid user query");
  }
 catch (  UniformInterfaceException ue) {
    ClientResponse response=ue.getResponse();
    assertEquals(Status.BAD_REQUEST,response.getClientResponseStatus());
    assertEquals(MediaType.APPLICATION_JSON_TYPE,response.getType());
    JSONObject msg=response.getEntity(JSONObject.class);
    JSONObject exception=msg.getJSONObject("RemoteException");
    assertEquals("incorrect number of elements",3,exception.length());
    String message=exception.getString("message");
    String type=exception.getString("exception");
    String classname=exception.getString("javaClassName");
    WebServicesTestUtils.checkStringMatch("exception message","java.lang.Exception: invalid container id, container_1234_0001",message);
    WebServicesTestUtils.checkStringMatch("exception type","BadRequestException",type);
    WebServicesTestUtils.checkStringMatch("exception classname","org.apache.hadoop.yarn.webapp.BadRequestException",classname);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.yarn.server.resourcemanager.TestAMAuthorization </h4><pre class="type-11 type-2 type-10 type-1 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testUnauthorizedAccess() throws Exception {
  MyContainerManager containerManager=new MyContainerManager();
  rm=new MockRMWithAMS(conf,containerManager);
  rm.start();
  MockNM nm1=rm.registerNode("localhost:1234",5120);
  RMApp app=rm.submitApp(1024);
  nm1.nodeHeartbeat(true);
  int waitCount=0;
  while (containerManager.containerTokens == null && waitCount++ < 40) {
    LOG.info("Waiting for AM Launch to happen..");
    Thread.sleep(1000);
  }
  Assert.assertNotNull(containerManager.containerTokens);
  RMAppAttempt attempt=app.getCurrentAppAttempt();
  ApplicationAttemptId applicationAttemptId=attempt.getAppAttemptId();
  waitForLaunchedState(attempt);
  final Configuration conf=rm.getConfig();
  final YarnRPC rpc=YarnRPC.create(conf);
  final InetSocketAddress serviceAddr=conf.getSocketAddr(YarnConfiguration.RM_SCHEDULER_ADDRESS,YarnConfiguration.DEFAULT_RM_SCHEDULER_ADDRESS,YarnConfiguration.DEFAULT_RM_SCHEDULER_PORT);
  UserGroupInformation currentUser=UserGroupInformation.createRemoteUser(applicationAttemptId.toString());
  ApplicationMasterProtocol client=currentUser.doAs(new PrivilegedAction<ApplicationMasterProtocol>(){
    @Override public ApplicationMasterProtocol run(){
      return (ApplicationMasterProtocol)rpc.getProxy(ApplicationMasterProtocol.class,serviceAddr,conf);
    }
  }
);
  RegisterApplicationMasterRequest request=Records.newRecord(RegisterApplicationMasterRequest.class);
  try {
    client.registerApplicationMaster(request);
    Assert.fail("Should fail with authorization error");
  }
 catch (  Exception e) {
    if (isCause(AccessControlException.class,e)) {
      String expectedMessage="";
      if (UserGroupInformation.isSecurityEnabled()) {
        expectedMessage="Client cannot authenticate via:[TOKEN]";
      }
 else {
        expectedMessage="SIMPLE authentication is not enabled.  Available:[TOKEN]";
      }
      Assert.assertTrue(e.getCause().getMessage().contains(expectedMessage));
    }
 else {
      throw e;
    }
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.yarn.server.resourcemanager.TestAppManager </h4><pre class="type-9 type-2 type-7 type-10 type-1 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects are null
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=30000) public void testRMAppSubmitDuplicateApplicationId() throws Exception {
  ApplicationId appId=MockApps.newAppID(0);
  asContext.setApplicationId(appId);
  RMApp appOrig=rmContext.getRMApps().get(appId);
  Assert.assertTrue("app name matches but shouldn't","testApp1" != appOrig.getName());
  try {
    appMonitor.submitApplication(asContext,"test");
    Assert.fail("Exception is expected when applicationId is duplicate.");
  }
 catch (  YarnException e) {
    Assert.assertTrue("The thrown exception is not the expectd one.",e.getMessage().contains("Cannot add a duplicate!"));
  }
  RMApp app=rmContext.getRMApps().get(appId);
  Assert.assertNotNull("app is null",app);
  Assert.assertEquals("app id doesn't match",appId,app.getApplicationId());
  Assert.assertEquals("app state doesn't match",RMAppState.FINISHED,app.getState());
}

</code></pre>

<br>
<pre class="type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=30000) public void testRMAppSubmitInvalidResourceRequest() throws Exception {
  asContext.setResource(Resources.createResource(YarnConfiguration.DEFAULT_RM_SCHEDULER_MAXIMUM_ALLOCATION_MB + 1));
  try {
    appMonitor.submitApplication(asContext,"test");
    Assert.fail("Application submission should fail because resource" + " request is invalid.");
  }
 catch (  YarnException e) {
    Assert.assertTrue("The thrown exception is not" + " InvalidResourceRequestException",e.getMessage().contains("Invalid resource request"));
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.yarn.server.resourcemanager.TestApplicationMasterService </h4><pre class="type-2 type-7 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=600000) public void testInvalidContainerReleaseRequest() throws Exception {
  MockRM rm=new MockRM(conf);
  try {
    rm.start();
    MockNM nm1=rm.registerNode("127.0.0.1:1234",6 * GB);
    RMApp app1=rm.submitApp(1024);
    nm1.nodeHeartbeat(true);
    RMAppAttempt attempt1=app1.getCurrentAppAttempt();
    MockAM am1=rm.sendAMLaunched(attempt1.getAppAttemptId());
    am1.registerAppAttempt();
    am1.addRequests(new String[]{"127.0.0.1"},GB,1,1);
    AllocateResponse alloc1Response=am1.schedule();
    nm1.nodeHeartbeat(true);
    while (alloc1Response.getAllocatedContainers().size() < 1) {
      LOG.info("Waiting for containers to be created for app 1...");
      sleep(1000);
      alloc1Response=am1.schedule();
    }
    Assert.assertTrue(alloc1Response.getAllocatedContainers().size() > 0);
    RMApp app2=rm.submitApp(1024);
    nm1.nodeHeartbeat(true);
    RMAppAttempt attempt2=app2.getCurrentAppAttempt();
    MockAM am2=rm.sendAMLaunched(attempt2.getAppAttemptId());
    am2.registerAppAttempt();
    ContainerId cId=alloc1Response.getAllocatedContainers().get(0).getId();
    am2.addContainerToBeReleased(cId);
    try {
      am2.schedule();
      Assert.fail("Exception was expected!!");
    }
 catch (    InvalidContainerReleaseException e) {
      StringBuilder sb=new StringBuilder("Cannot release container : ");
      sb.append(cId.toString());
      sb.append(" not belonging to this application attempt : ");
      sb.append(attempt2.getAppAttemptId().toString());
      Assert.assertTrue(e.getMessage().contains(sb.toString()));
    }
  }
  finally {
    if (rm != null) {
      rm.stop();
    }
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.yarn.server.resourcemanager.TestClientRMService </h4><pre class="type-9 type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testForceKillNonExistingApplication() throws YarnException {
  RMContext rmContext=mock(RMContext.class);
  when(rmContext.getRMApps()).thenReturn(new ConcurrentHashMap<ApplicationId,RMApp>());
  ClientRMService rmService=new ClientRMService(rmContext,null,null,null,null,null);
  ApplicationId applicationId=BuilderUtils.newApplicationId(System.currentTimeMillis(),0);
  KillApplicationRequest request=KillApplicationRequest.newInstance(applicationId);
  try {
    rmService.forceKillApplication(request);
    Assert.fail();
  }
 catch (  ApplicationNotFoundException ex) {
    Assert.assertEquals(ex.getMessage(),"Trying to kill an absent " + "application " + request.getApplicationId());
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testGetApplicationReport() throws YarnException {
  RMContext rmContext=mock(RMContext.class);
  when(rmContext.getRMApps()).thenReturn(new ConcurrentHashMap<ApplicationId,RMApp>());
  ClientRMService rmService=new ClientRMService(rmContext,null,null,null,null,null);
  RecordFactory recordFactory=RecordFactoryProvider.getRecordFactory(null);
  GetApplicationReportRequest request=recordFactory.newRecordInstance(GetApplicationReportRequest.class);
  request.setApplicationId(ApplicationId.newInstance(0,0));
  try {
    rmService.getApplicationReport(request);
    Assert.fail();
  }
 catch (  ApplicationNotFoundException ex) {
    Assert.assertEquals(ex.getMessage(),"Application with id '" + request.getApplicationId() + "' doesn't exist in RM.");
  }
}

</code></pre>

<br>
<pre class="type-9 type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testGetContainerReport() throws YarnException, IOException {
  ClientRMService rmService=createRMService();
  RecordFactory recordFactory=RecordFactoryProvider.getRecordFactory(null);
  GetContainerReportRequest request=recordFactory.newRecordInstance(GetContainerReportRequest.class);
  ApplicationAttemptId attemptId=ApplicationAttemptId.newInstance(ApplicationId.newInstance(123456,1),1);
  ContainerId containerId=ContainerId.newInstance(attemptId,1);
  request.setContainerId(containerId);
  try {
    GetContainerReportResponse response=rmService.getContainerReport(request);
    Assert.assertEquals(containerId,response.getContainerReport().getContainerId());
  }
 catch (  ApplicationNotFoundException ex) {
    Assert.fail(ex.getMessage());
  }
}

</code></pre>

<br>
<pre class="type-9 type-2 type-7 type-1 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=30000) @SuppressWarnings("rawtypes") public void testAppSubmit() throws Exception {
  YarnScheduler yarnScheduler=mockYarnScheduler();
  RMContext rmContext=mock(RMContext.class);
  mockRMContext(yarnScheduler,rmContext);
  RMStateStore stateStore=mock(RMStateStore.class);
  when(rmContext.getStateStore()).thenReturn(stateStore);
  RMAppManager appManager=new RMAppManager(rmContext,yarnScheduler,null,mock(ApplicationACLsManager.class),new Configuration());
  when(rmContext.getDispatcher().getEventHandler()).thenReturn(new EventHandler<Event>(){
    public void handle(    Event event){
    }
  }
);
  ApplicationId appId1=getApplicationId(100);
  ApplicationACLsManager mockAclsManager=mock(ApplicationACLsManager.class);
  when(mockAclsManager.checkAccess(UserGroupInformation.getCurrentUser(),ApplicationAccessType.VIEW_APP,null,appId1)).thenReturn(true);
  QueueACLsManager mockQueueACLsManager=mock(QueueACLsManager.class);
  when(mockQueueACLsManager.checkAccess(any(UserGroupInformation.class),any(QueueACL.class),anyString())).thenReturn(true);
  ClientRMService rmService=new ClientRMService(rmContext,yarnScheduler,appManager,mockAclsManager,mockQueueACLsManager,null);
  SubmitApplicationRequest submitRequest1=mockSubmitAppRequest(appId1,null,null);
  try {
    rmService.submitApplication(submitRequest1);
  }
 catch (  YarnException e) {
    Assert.fail("Exception is not expected.");
  }
  RMApp app1=rmContext.getRMApps().get(appId1);
  Assert.assertNotNull("app doesn't exist",app1);
  Assert.assertEquals("app name doesn't match",YarnConfiguration.DEFAULT_APPLICATION_NAME,app1.getName());
  Assert.assertEquals("app queue doesn't match",YarnConfiguration.DEFAULT_QUEUE_NAME,app1.getQueue());
  String name=MockApps.newAppName();
  String queue=MockApps.newQueue();
  ApplicationId appId2=getApplicationId(101);
  SubmitApplicationRequest submitRequest2=mockSubmitAppRequest(appId2,name,queue);
  submitRequest2.getApplicationSubmissionContext().setApplicationType("matchType");
  try {
    rmService.submitApplication(submitRequest2);
  }
 catch (  YarnException e) {
    Assert.fail("Exception is not expected.");
  }
  RMApp app2=rmContext.getRMApps().get(appId2);
  Assert.assertNotNull("app doesn't exist",app2);
  Assert.assertEquals("app name doesn't match",name,app2.getName());
  Assert.assertEquals("app queue doesn't match",queue,app2.getQueue());
  try {
    rmService.submitApplication(submitRequest2);
  }
 catch (  YarnException e) {
    Assert.fail("Exception is not expected.");
  }
  GetApplicationsRequest getAllAppsRequest=GetApplicationsRequest.newInstance(new HashSet<String>());
  GetApplicationsResponse getAllApplicationsResponse=rmService.getApplications(getAllAppsRequest);
  Assert.assertEquals(5,getAllApplicationsResponse.getApplicationList().size());
  Set<String> appTypes=new HashSet<String>();
  appTypes.add("matchType");
  getAllAppsRequest=GetApplicationsRequest.newInstance(appTypes);
  getAllApplicationsResponse=rmService.getApplications(getAllAppsRequest);
  Assert.assertEquals(1,getAllApplicationsResponse.getApplicationList().size());
  Assert.assertEquals(appId2,getAllApplicationsResponse.getApplicationList().get(0).getApplicationId());
}

</code></pre>

<br>
<pre class="type-2 type-7 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testTokenRenewalWrongUser() throws Exception {
  try {
    owner.doAs(new PrivilegedExceptionAction<Void>(){
      @Override public Void run() throws Exception {
        try {
          checkTokenRenewal(owner,other);
          return null;
        }
 catch (        YarnException ex) {
          Assert.assertTrue(ex.getMessage().contains(owner.getUserName() + " tries to renew a token with renewer " + other.getUserName()));
          throw ex;
        }
      }
    }
);
  }
 catch (  Exception e) {
    return;
  }
  Assert.fail("renew should have failed");
}

</code></pre>

<br>
<pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testGetApplicationAttemptReport() throws YarnException, IOException {
  ClientRMService rmService=createRMService();
  RecordFactory recordFactory=RecordFactoryProvider.getRecordFactory(null);
  GetApplicationAttemptReportRequest request=recordFactory.newRecordInstance(GetApplicationAttemptReportRequest.class);
  ApplicationAttemptId attemptId=ApplicationAttemptId.newInstance(ApplicationId.newInstance(123456,1),1);
  request.setApplicationAttemptId(attemptId);
  try {
    GetApplicationAttemptReportResponse response=rmService.getApplicationAttemptReport(request);
    Assert.assertEquals(attemptId,response.getApplicationAttemptReport().getApplicationAttemptId());
  }
 catch (  ApplicationNotFoundException ex) {
    Assert.fail(ex.getMessage());
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testGetApplicationAttempts() throws YarnException, IOException {
  ClientRMService rmService=createRMService();
  RecordFactory recordFactory=RecordFactoryProvider.getRecordFactory(null);
  GetApplicationAttemptsRequest request=recordFactory.newRecordInstance(GetApplicationAttemptsRequest.class);
  ApplicationAttemptId attemptId=ApplicationAttemptId.newInstance(ApplicationId.newInstance(123456,1),1);
  request.setApplicationId(ApplicationId.newInstance(123456,1));
  try {
    GetApplicationAttemptsResponse response=rmService.getApplicationAttempts(request);
    Assert.assertEquals(1,response.getApplicationAttemptList().size());
    Assert.assertEquals(attemptId,response.getApplicationAttemptList().get(0).getApplicationAttemptId());
  }
 catch (  ApplicationNotFoundException ex) {
    Assert.fail(ex.getMessage());
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testTokenCancellationByWrongUser(){
  RMContext rmContext=mock(RMContext.class);
  final ClientRMService rmService=new ClientRMService(rmContext,null,null,null,null,dtsm);
  UserGroupInformation[] kerbTestOwners={owner,other,tester,ownerKerb,otherKerb};
  UserGroupInformation[] kerbTestRenewers={owner,other,ownerKerb,otherKerb};
  for (  final UserGroupInformation tokOwner : kerbTestOwners) {
    for (    final UserGroupInformation tokRenewer : kerbTestRenewers) {
      try {
        testerKerb.doAs(new PrivilegedExceptionAction<Void>(){
          @Override public Void run() throws Exception {
            try {
              checkTokenCancellation(rmService,tokOwner,tokRenewer);
              Assert.fail("We should not reach here; token owner = " + tokOwner.getUserName() + ", renewer = "+ tokRenewer.getUserName());
              return null;
            }
 catch (            YarnException e) {
              Assert.assertTrue(e.getMessage().contains(testerKerb.getUserName() + " is not authorized to cancel the token"));
              return null;
            }
          }
        }
);
      }
 catch (      Exception e) {
        Assert.fail("Unexpected exception; " + e.getMessage());
      }
    }
  }
  UserGroupInformation[] simpleTestOwners={owner,other,ownerKerb,otherKerb,testerKerb};
  UserGroupInformation[] simpleTestRenewers={owner,other,ownerKerb,otherKerb};
  for (  final UserGroupInformation tokOwner : simpleTestOwners) {
    for (    final UserGroupInformation tokRenewer : simpleTestRenewers) {
      try {
        tester.doAs(new PrivilegedExceptionAction<Void>(){
          @Override public Void run() throws Exception {
            try {
              checkTokenCancellation(tokOwner,tokRenewer);
              Assert.fail("We should not reach here; token owner = " + tokOwner.getUserName() + ", renewer = "+ tokRenewer.getUserName());
              return null;
            }
 catch (            YarnException ex) {
              Assert.assertTrue(ex.getMessage().contains(tester.getUserName() + " is not authorized to cancel the token"));
              return null;
            }
          }
        }
);
      }
 catch (      Exception e) {
        Assert.fail("Unexpected exception; " + e.getMessage());
      }
    }
  }
}

</code></pre>

<br>
<pre class="type-9 type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testGetContainers() throws YarnException, IOException {
  ClientRMService rmService=createRMService();
  RecordFactory recordFactory=RecordFactoryProvider.getRecordFactory(null);
  GetContainersRequest request=recordFactory.newRecordInstance(GetContainersRequest.class);
  ApplicationAttemptId attemptId=ApplicationAttemptId.newInstance(ApplicationId.newInstance(123456,1),1);
  ContainerId containerId=ContainerId.newInstance(attemptId,1);
  request.setApplicationAttemptId(attemptId);
  try {
    GetContainersResponse response=rmService.getContainers(request);
    Assert.assertEquals(containerId,response.getContainerList().get(0).getContainerId());
  }
 catch (  ApplicationNotFoundException ex) {
    Assert.fail(ex.getMessage());
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.yarn.server.resourcemanager.TestClientRMTokens </h4><pre class="type-2 type-10 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testDelegationToken() throws IOException, InterruptedException {
  final YarnConfiguration conf=new YarnConfiguration();
  conf.set(YarnConfiguration.RM_PRINCIPAL,"testuser/localhost@apache.org");
  conf.set(CommonConfigurationKeysPublic.HADOOP_SECURITY_AUTHENTICATION,"kerberos");
  UserGroupInformation.setConfiguration(conf);
  ResourceScheduler scheduler=createMockScheduler(conf);
  long initialInterval=10000l;
  long maxLifetime=20000l;
  long renewInterval=10000l;
  RMDelegationTokenSecretManager rmDtSecretManager=createRMDelegationTokenSecretManager(initialInterval,maxLifetime,renewInterval);
  rmDtSecretManager.startThreads();
  LOG.info("Creating DelegationTokenSecretManager with initialInterval: " + initialInterval + ", maxLifetime: "+ maxLifetime+ ", renewInterval: "+ renewInterval);
  final ClientRMService clientRMService=new ClientRMServiceForTest(conf,scheduler,rmDtSecretManager);
  clientRMService.init(conf);
  clientRMService.start();
  ApplicationClientProtocol clientRMWithDT=null;
  try {
    UserGroupInformation loggedInUser=UserGroupInformation.createRemoteUser("testrenewer@APACHE.ORG");
    Assert.assertEquals("testrenewer",loggedInUser.getShortUserName());
    loggedInUser.setAuthenticationMethod(AuthenticationMethod.KERBEROS);
    org.apache.hadoop.yarn.api.records.Token token=getDelegationToken(loggedInUser,clientRMService,loggedInUser.getShortUserName());
    long tokenFetchTime=System.currentTimeMillis();
    LOG.info("Got delegation token at: " + tokenFetchTime);
    clientRMWithDT=getClientRMProtocolWithDT(token,clientRMService.getBindAddress(),"loginuser1",conf);
    GetNewApplicationRequest request=Records.newRecord(GetNewApplicationRequest.class);
    try {
      clientRMWithDT.getNewApplication(request);
    }
 catch (    IOException e) {
      fail("Unexpected exception" + e);
    }
catch (    YarnException e) {
      fail("Unexpected exception" + e);
    }
    while (System.currentTimeMillis() < tokenFetchTime + initialInterval / 2) {
      Thread.sleep(500l);
    }
    long nextExpTime=renewDelegationToken(loggedInUser,clientRMService,token);
    long renewalTime=System.currentTimeMillis();
    LOG.info("Renewed token at: " + renewalTime + ", NextExpiryTime: "+ nextExpTime);
    while (System.currentTimeMillis() > tokenFetchTime + initialInterval && System.currentTimeMillis() < nextExpTime) {
      Thread.sleep(500l);
    }
    Thread.sleep(50l);
    try {
      clientRMWithDT.getNewApplication(request);
    }
 catch (    IOException e) {
      fail("Unexpected exception" + e);
    }
catch (    YarnException e) {
      fail("Unexpected exception" + e);
    }
    while (System.currentTimeMillis() < renewalTime + renewInterval) {
      Thread.sleep(500l);
    }
    Thread.sleep(50l);
    LOG.info("At time: " + System.currentTimeMillis() + ", token should be invalid");
    try {
      clientRMWithDT.getNewApplication(request);
      fail("Should not have succeeded with an expired token");
    }
 catch (    Exception e) {
      assertEquals(InvalidToken.class.getName(),e.getClass().getName());
      assertTrue(e.getMessage().contains("is expired"));
    }
    if (clientRMWithDT != null) {
      RPC.stopProxy(clientRMWithDT);
      clientRMWithDT=null;
    }
    token=getDelegationToken(loggedInUser,clientRMService,loggedInUser.getShortUserName());
    tokenFetchTime=System.currentTimeMillis();
    LOG.info("Got delegation token at: " + tokenFetchTime);
    clientRMWithDT=getClientRMProtocolWithDT(token,clientRMService.getBindAddress(),"loginuser2",conf);
    request=Records.newRecord(GetNewApplicationRequest.class);
    try {
      clientRMWithDT.getNewApplication(request);
    }
 catch (    IOException e) {
      fail("Unexpected exception" + e);
    }
catch (    YarnException e) {
      fail("Unexpected exception" + e);
    }
    cancelDelegationToken(loggedInUser,clientRMService,token);
    if (clientRMWithDT != null) {
      RPC.stopProxy(clientRMWithDT);
      clientRMWithDT=null;
    }
    clientRMWithDT=getClientRMProtocolWithDT(token,clientRMService.getBindAddress(),"loginuser2",conf);
    LOG.info("Cancelled delegation token at: " + System.currentTimeMillis());
    try {
      clientRMWithDT.getNewApplication(request);
      fail("Should not have succeeded with a cancelled delegation token");
    }
 catch (    IOException e) {
    }
catch (    YarnException e) {
    }
  }
  finally {
    rmDtSecretManager.stopThreads();
    if (clientRMWithDT != null) {
      RPC.stopProxy(clientRMWithDT);
    }
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.yarn.server.resourcemanager.TestFifoScheduler </h4><pre class="type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=30000) public void testConfValidation() throws Exception {
  FifoScheduler scheduler=new FifoScheduler();
  Configuration conf=new YarnConfiguration();
  conf.setInt(YarnConfiguration.RM_SCHEDULER_MINIMUM_ALLOCATION_MB,2048);
  conf.setInt(YarnConfiguration.RM_SCHEDULER_MAXIMUM_ALLOCATION_MB,1024);
  try {
    scheduler.serviceInit(conf);
    fail("Exception is expected because the min memory allocation is" + " larger than the max memory allocation.");
  }
 catch (  YarnRuntimeException e) {
    assertTrue("The thrown exception is not the expected one.",e.getMessage().startsWith("Invalid resource scheduler memory"));
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testAllocateContainerOnNodeWithoutOffSwitchSpecified() throws Exception {
  Logger rootLogger=LogManager.getRootLogger();
  rootLogger.setLevel(Level.DEBUG);
  MockRM rm=new MockRM(conf);
  rm.start();
  MockNM nm1=rm.registerNode("127.0.0.1:1234",6 * GB);
  RMApp app1=rm.submitApp(2048);
  nm1.nodeHeartbeat(true);
  RMAppAttempt attempt1=app1.getCurrentAppAttempt();
  MockAM am1=rm.sendAMLaunched(attempt1.getAppAttemptId());
  am1.registerAppAttempt();
  List<ResourceRequest> requests=new ArrayList<ResourceRequest>();
  requests.add(am1.createResourceReq("127.0.0.1",1 * GB,1,1));
  requests.add(am1.createResourceReq("/default-rack",1 * GB,1,1));
  am1.allocate(requests,null);
  try {
    nm1.nodeHeartbeat(true);
  }
 catch (  NullPointerException e) {
    Assert.fail("NPE when allocating container on node but " + "forget to set off-switch request should be handled");
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testNodeUpdateBeforeAppAttemptInit() throws Exception {
  FifoScheduler scheduler=new FifoScheduler();
  MockRM rm=new MockRM(conf);
  scheduler.setRMContext(rm.getRMContext());
  scheduler.init(conf);
  scheduler.start();
  scheduler.reinitialize(conf,rm.getRMContext());
  RMNode node=MockNodes.newNodeInfo(1,Resources.createResource(1024,4),1,"127.0.0.1");
  scheduler.handle(new NodeAddedSchedulerEvent(node));
  ApplicationId appId=ApplicationId.newInstance(0,1);
  scheduler.addApplication(appId,"queue1","user1",false);
  NodeUpdateSchedulerEvent updateEvent=new NodeUpdateSchedulerEvent(node);
  try {
    scheduler.handle(updateEvent);
  }
 catch (  NullPointerException e) {
    Assert.fail();
  }
  ApplicationAttemptId attId=ApplicationAttemptId.newInstance(appId,1);
  scheduler.addApplicationAttempt(attId,false,false);
  rm.stop();
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.yarn.server.resourcemanager.TestKillApplicationWithRMHA </h4><pre class="type-2 type-7 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=20000) public void testKillAppWhenFailoverHappensAtNewState() throws Exception {
  startRMsWithCustomizedRMAppManager();
  MockNM nm1=new MockNM("127.0.0.1:1234",15120,rm1.getResourceTrackerService());
  nm1.registerNode();
  RMApp app0=rm1.submitApp(200,"",UserGroupInformation.getCurrentUser().getShortUserName(),null,false,null,configuration.getInt(YarnConfiguration.RM_AM_MAX_ATTEMPTS,YarnConfiguration.DEFAULT_RM_AM_MAX_ATTEMPTS),null,null,false,false);
  try {
    failOverAndKillApp(app0.getApplicationId(),RMAppState.NEW);
    fail("Should get an exception here");
  }
 catch (  ApplicationNotFoundException ex) {
    Assert.assertTrue(ex.getMessage().contains("Trying to kill an absent application " + app0.getApplicationId()));
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.yarn.server.resourcemanager.TestMoveApplication </h4><pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=10000) public void testMoveTooLate() throws Exception {
  Application application=new Application("user1",resourceManager);
  ApplicationId appId=application.getApplicationId();
  application.submit();
  ClientRMService clientRMService=resourceManager.getClientRMService();
  clientRMService.forceKillApplication(KillApplicationRequest.newInstance(appId));
  RMApp rmApp=resourceManager.getRMContext().getRMApps().get(appId);
  while (rmApp.getState() != RMAppState.KILLED) {
    Thread.sleep(100);
  }
  try {
    clientRMService.moveApplicationAcrossQueues(MoveApplicationAcrossQueuesRequest.newInstance(appId,"newqueue"));
    fail("Should have hit exception");
  }
 catch (  YarnException ex) {
    assertEquals(YarnException.class,ex.getClass());
    assertEquals("App in KILLED state cannot be moved.",ex.getMessage());
  }
}

</code></pre>

<br>
<pre class="type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testMoveRejectedByScheduler() throws Exception {
  failMove=true;
  Application application=new Application("user1",resourceManager);
  application.submit();
  RMApp app=resourceManager.rmContext.getRMApps().get(application.getApplicationId());
  while (app.getState() != RMAppState.ACCEPTED) {
    Thread.sleep(100);
  }
  ClientRMService clientRMService=resourceManager.getClientRMService();
  try {
    clientRMService.moveApplicationAcrossQueues(MoveApplicationAcrossQueuesRequest.newInstance(application.getApplicationId(),"newqueue"));
    fail("Should have hit exception");
  }
 catch (  YarnException ex) {
    assertEquals("Move not supported",ex.getCause().getMessage());
  }
}

</code></pre>

<br>
<pre class="type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testMoveRejectedByPermissions() throws Exception {
  failMove=true;
  final Application application=new Application("user1",resourceManager);
  application.submit();
  final ClientRMService clientRMService=resourceManager.getClientRMService();
  try {
    UserGroupInformation.createRemoteUser("otheruser").doAs(new PrivilegedExceptionAction<MoveApplicationAcrossQueuesResponse>(){
      @Override public MoveApplicationAcrossQueuesResponse run() throws Exception {
        return clientRMService.moveApplicationAcrossQueues(MoveApplicationAcrossQueuesRequest.newInstance(application.getApplicationId(),"newqueue"));
      }
    }
);
    fail("Should have hit exception");
  }
 catch (  Exception ex) {
    assertEquals(AccessControlException.class,ex.getCause().getCause().getClass());
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.yarn.server.resourcemanager.TestRMAdminService </h4><pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testRefreshUserToGroupsMappingsWithLocalConfigurationProvider(){
  rm=new MockRM(configuration);
  rm.init(configuration);
  rm.start();
  try {
    rm.adminService.refreshUserToGroupsMappings(RefreshUserToGroupsMappingsRequest.newInstance());
  }
 catch (  Exception ex) {
    fail("Using localConfigurationProvider. Should not get any exception.");
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testAdminRefreshQueuesWithLocalConfigurationProvider() throws IOException, YarnException {
  rm=new MockRM(configuration);
  rm.init(configuration);
  rm.start();
  CapacityScheduler cs=(CapacityScheduler)rm.getRMContext().getScheduler();
  int maxAppsBefore=cs.getConfiguration().getMaximumSystemApplications();
  try {
    rm.adminService.refreshQueues(RefreshQueuesRequest.newInstance());
    Assert.assertEquals(maxAppsBefore,cs.getConfiguration().getMaximumSystemApplications());
  }
 catch (  Exception ex) {
    fail("Using localConfigurationProvider. Should not get any exception.");
  }
}

</code></pre>

<br>
<pre class="type-9 type-11 type-2 type-7 type-10 type-6 type-20 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values related to public fields.">PublicFieldVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Verifies values related to public fields.
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testRMInitialsWithFileSystemBasedConfigurationProvider() throws Exception {
  configuration.set(YarnConfiguration.RM_CONFIGURATION_PROVIDER_CLASS,"org.apache.hadoop.yarn.FileSystemBasedConfigurationProvider");
  final File excludeHostsFile=new File(tmpDir.toString(),"excludeHosts");
  if (excludeHostsFile.exists()) {
    excludeHostsFile.delete();
  }
  if (!excludeHostsFile.createNewFile()) {
    Assert.fail("Can not create " + "excludeHosts");
  }
  PrintWriter fileWriter=new PrintWriter(excludeHostsFile);
  fileWriter.write("0.0.0.0:123");
  fileWriter.close();
  uploadToRemoteFileSystem(new Path(excludeHostsFile.getAbsolutePath()));
  YarnConfiguration yarnConf=new YarnConfiguration();
  yarnConf.set(YarnConfiguration.YARN_ADMIN_ACL,"world:anyone:rwcda");
  yarnConf.set(YarnConfiguration.RM_NODES_EXCLUDE_FILE_PATH,this.workingPath + "/excludeHosts");
  uploadConfiguration(yarnConf,"yarn-site.xml");
  CapacitySchedulerConfiguration csConf=new CapacitySchedulerConfiguration();
  csConf.set("yarn.scheduler.capacity.maximum-applications","5000");
  uploadConfiguration(csConf,"capacity-scheduler.xml");
  String aclsString="alice,bob users,wheel";
  Configuration newConf=new Configuration();
  newConf.set("security.applicationclient.protocol.acl",aclsString);
  uploadConfiguration(newConf,"hadoop-policy.xml");
  Configuration conf=new Configuration();
  conf.setBoolean(CommonConfigurationKeysPublic.HADOOP_SECURITY_AUTHORIZATION,true);
  conf.set("hadoop.proxyuser.test.groups","test_groups");
  conf.set("hadoop.proxyuser.test.hosts","test_hosts");
  conf.setClass(CommonConfigurationKeys.HADOOP_SECURITY_GROUP_MAPPING,MockUnixGroupsMapping.class,GroupMappingServiceProvider.class);
  uploadConfiguration(conf,"core-site.xml");
  MockUnixGroupsMapping.updateGroups();
  ResourceManager resourceManager=null;
  try {
    try {
      resourceManager=new ResourceManager();
      resourceManager.init(configuration);
      resourceManager.start();
    }
 catch (    Exception ex) {
      fail("Should not get any exceptions");
    }
    Set<String> excludeHosts=resourceManager.getRMContext().getNodesListManager().getHostsReader().getExcludedHosts();
    Assert.assertTrue(excludeHosts.size() == 1);
    Assert.assertTrue(excludeHosts.contains("0.0.0.0:123"));
    String aclStringAfter=resourceManager.adminService.getAccessControlList().getAclString().trim();
    Assert.assertEquals(aclStringAfter,"world:anyone:rwcda");
    CapacityScheduler cs=(CapacityScheduler)resourceManager.getRMContext().getScheduler();
    int maxAppsAfter=cs.getConfiguration().getMaximumSystemApplications();
    Assert.assertEquals(maxAppsAfter,5000);
    ServiceAuthorizationManager adminServiceServiceManager=resourceManager.adminService.getServer().getServiceAuthorizationManager();
    verifyServiceACLsRefresh(adminServiceServiceManager,org.apache.hadoop.yarn.api.ApplicationClientProtocolPB.class,aclsString);
    ServiceAuthorizationManager clientRMServiceServiceManager=resourceManager.getRMContext().getClientRMService().getServer().getServiceAuthorizationManager();
    verifyServiceACLsRefresh(clientRMServiceServiceManager,org.apache.hadoop.yarn.api.ApplicationClientProtocolPB.class,aclsString);
    ServiceAuthorizationManager appMasterService=resourceManager.getRMContext().getApplicationMasterService().getServer().getServiceAuthorizationManager();
    verifyServiceACLsRefresh(appMasterService,org.apache.hadoop.yarn.api.ApplicationClientProtocolPB.class,aclsString);
    ServiceAuthorizationManager RTService=resourceManager.getRMContext().getResourceTrackerService().getServer().getServiceAuthorizationManager();
    verifyServiceACLsRefresh(RTService,org.apache.hadoop.yarn.api.ApplicationClientProtocolPB.class,aclsString);
    Assert.assertTrue(ProxyUsers.getDefaultImpersonationProvider().getProxyGroups().get("hadoop.proxyuser.test.groups").size() == 1);
    Assert.assertTrue(ProxyUsers.getDefaultImpersonationProvider().getProxyGroups().get("hadoop.proxyuser.test.groups").contains("test_groups"));
    Assert.assertTrue(ProxyUsers.getDefaultImpersonationProvider().getProxyHosts().get("hadoop.proxyuser.test.hosts").size() == 1);
    Assert.assertTrue(ProxyUsers.getDefaultImpersonationProvider().getProxyHosts().get("hadoop.proxyuser.test.hosts").contains("test_hosts"));
    List<String> groupAfter=Groups.getUserToGroupsMappingService(configuration).getGroups(UserGroupInformation.getCurrentUser().getUserName());
    Assert.assertTrue(groupAfter.contains("test_group_D") && groupAfter.contains("test_group_E") && groupAfter.contains("test_group_F")&& groupAfter.size() == 3);
  }
  finally {
    if (resourceManager != null) {
      resourceManager.stop();
    }
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testRefreshNodesWithLocalConfigurationProvider(){
  rm=new MockRM(configuration);
  rm.init(configuration);
  rm.start();
  try {
    rm.adminService.refreshNodes(RefreshNodesRequest.newInstance());
  }
 catch (  Exception ex) {
    fail("Using localConfigurationProvider. Should not get any exception.");
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testRMStartsWithoutConfigurationFilesProvided(){
  configuration.set(YarnConfiguration.RM_CONFIGURATION_PROVIDER_CLASS,"org.apache.hadoop.yarn.FileSystemBasedConfigurationProvider");
  try {
    rm=new MockRM(configuration);
    rm.init(configuration);
    rm.start();
  }
 catch (  Exception ex) {
    fail("Should not get any exceptions");
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-10 type-6 type-20 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values related to public fields.">PublicFieldVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Verifies values related to public fields.
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testAdminAclsWithFileSystemBasedConfigurationProvider() throws IOException, YarnException {
  configuration.set(YarnConfiguration.RM_CONFIGURATION_PROVIDER_CLASS,"org.apache.hadoop.yarn.FileSystemBasedConfigurationProvider");
  uploadDefaultConfiguration();
  try {
    rm=new MockRM(configuration);
    rm.init(configuration);
    rm.start();
  }
 catch (  Exception ex) {
    fail("Should not get any exceptions");
  }
  String aclStringBefore=rm.adminService.getAccessControlList().getAclString().trim();
  YarnConfiguration yarnConf=new YarnConfiguration();
  yarnConf.set(YarnConfiguration.YARN_ADMIN_ACL,"world:anyone:rwcda");
  uploadConfiguration(yarnConf,"yarn-site.xml");
  rm.adminService.refreshAdminAcls(RefreshAdminAclsRequest.newInstance());
  String aclStringAfter=rm.adminService.getAccessControlList().getAclString().trim();
  Assert.assertTrue(!aclStringAfter.equals(aclStringBefore));
  Assert.assertEquals(aclStringAfter,"world:anyone:rwcda");
}

</code></pre>

<br>
<pre class="type-9 type-2 type-7 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testRefreshUserToGroupsMappingsWithFileSystemBasedConfigurationProvider() throws IOException, YarnException {
  configuration.set(YarnConfiguration.RM_CONFIGURATION_PROVIDER_CLASS,"org.apache.hadoop.yarn.FileSystemBasedConfigurationProvider");
  String[] defaultTestUserGroups={"dummy_group1","dummy_group2"};
  UserGroupInformation ugi=UserGroupInformation.createUserForTesting("dummyUser",defaultTestUserGroups);
  String user=ugi.getUserName();
  List<String> groupWithInit=new ArrayList<String>(2);
  for (int i=0; i < ugi.getGroupNames().length; i++) {
    groupWithInit.add(ugi.getGroupNames()[i]);
  }
  uploadDefaultConfiguration();
  Configuration conf=new Configuration();
  conf.setClass(CommonConfigurationKeys.HADOOP_SECURITY_GROUP_MAPPING,MockUnixGroupsMapping.class,GroupMappingServiceProvider.class);
  uploadConfiguration(conf,"core-site.xml");
  try {
    rm=new MockRM(configuration);
    rm.init(configuration);
    rm.start();
  }
 catch (  Exception ex) {
    fail("Should not get any exceptions");
  }
  List<String> groupBefore=new ArrayList<String>(Groups.getUserToGroupsMappingService(configuration).getGroups(user));
  Assert.assertTrue(groupBefore.contains("test_group_A") && groupBefore.contains("test_group_B") && groupBefore.contains("test_group_C")&& groupBefore.size() == 3);
  Assert.assertTrue(groupWithInit.size() != groupBefore.size());
  Assert.assertFalse(groupWithInit.contains("test_group_A") || groupWithInit.contains("test_group_B") || groupWithInit.contains("test_group_C"));
  MockUnixGroupsMapping.updateGroups();
  rm.adminService.refreshUserToGroupsMappings(RefreshUserToGroupsMappingsRequest.newInstance());
  List<String> groupAfter=Groups.getUserToGroupsMappingService(configuration).getGroups(user);
  Assert.assertTrue(groupAfter.contains("test_group_D") && groupAfter.contains("test_group_E") && groupAfter.contains("test_group_F")&& groupAfter.size() == 3);
}

</code></pre>

<br>
<pre class="type-11 type-2 type-7 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testRefreshNodesWithFileSystemBasedConfigurationProvider() throws IOException, YarnException {
  configuration.set(YarnConfiguration.RM_CONFIGURATION_PROVIDER_CLASS,"org.apache.hadoop.yarn.FileSystemBasedConfigurationProvider");
  uploadDefaultConfiguration();
  try {
    rm=new MockRM(configuration);
    rm.init(configuration);
    rm.start();
  }
 catch (  Exception ex) {
    fail("Should not get any exceptions");
  }
  final File excludeHostsFile=new File(tmpDir.toString(),"excludeHosts");
  if (excludeHostsFile.exists()) {
    excludeHostsFile.delete();
  }
  if (!excludeHostsFile.createNewFile()) {
    Assert.fail("Can not create " + "excludeHosts");
  }
  PrintWriter fileWriter=new PrintWriter(excludeHostsFile);
  fileWriter.write("0.0.0.0:123");
  fileWriter.close();
  uploadToRemoteFileSystem(new Path(excludeHostsFile.getAbsolutePath()));
  Configuration yarnConf=new YarnConfiguration();
  yarnConf.set(YarnConfiguration.RM_NODES_EXCLUDE_FILE_PATH,this.workingPath + "/excludeHosts");
  uploadConfiguration(yarnConf,YarnConfiguration.YARN_SITE_CONFIGURATION_FILE);
  rm.adminService.refreshNodes(RefreshNodesRequest.newInstance());
  Set<String> excludeHosts=rm.getNodesListManager().getHostsReader().getExcludedHosts();
  Assert.assertTrue(excludeHosts.size() == 1);
  Assert.assertTrue(excludeHosts.contains("0.0.0.0:123"));
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testServiceAclsRefreshWithFileSystemBasedConfigurationProvider() throws IOException, YarnException {
  configuration.setBoolean(CommonConfigurationKeysPublic.HADOOP_SECURITY_AUTHORIZATION,true);
  configuration.set(YarnConfiguration.RM_CONFIGURATION_PROVIDER_CLASS,"org.apache.hadoop.yarn.FileSystemBasedConfigurationProvider");
  ResourceManager resourceManager=null;
  try {
    uploadDefaultConfiguration();
    Configuration conf=new Configuration();
    conf.setBoolean(CommonConfigurationKeysPublic.HADOOP_SECURITY_AUTHORIZATION,true);
    uploadConfiguration(conf,"core-site.xml");
    try {
      resourceManager=new ResourceManager();
      resourceManager.init(configuration);
      resourceManager.start();
    }
 catch (    Exception ex) {
      fail("Should not get any exceptions");
    }
    String aclsString="alice,bob users,wheel";
    Configuration newConf=new Configuration();
    newConf.set("security.applicationclient.protocol.acl",aclsString);
    uploadConfiguration(newConf,"hadoop-policy.xml");
    resourceManager.adminService.refreshServiceAcls(RefreshServiceAclsRequest.newInstance());
    ServiceAuthorizationManager adminServiceServiceManager=resourceManager.adminService.getServer().getServiceAuthorizationManager();
    verifyServiceACLsRefresh(adminServiceServiceManager,org.apache.hadoop.yarn.api.ApplicationClientProtocolPB.class,aclsString);
    ServiceAuthorizationManager clientRMServiceServiceManager=resourceManager.getRMContext().getClientRMService().getServer().getServiceAuthorizationManager();
    verifyServiceACLsRefresh(clientRMServiceServiceManager,org.apache.hadoop.yarn.api.ApplicationClientProtocolPB.class,aclsString);
    ServiceAuthorizationManager appMasterService=resourceManager.getRMContext().getApplicationMasterService().getServer().getServiceAuthorizationManager();
    verifyServiceACLsRefresh(appMasterService,org.apache.hadoop.yarn.api.ApplicationClientProtocolPB.class,aclsString);
    ServiceAuthorizationManager RTService=resourceManager.getRMContext().getResourceTrackerService().getServer().getServiceAuthorizationManager();
    verifyServiceACLsRefresh(RTService,org.apache.hadoop.yarn.api.ApplicationClientProtocolPB.class,aclsString);
  }
  finally {
    if (resourceManager != null) {
      resourceManager.stop();
    }
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testAdminAclsWithLocalConfigurationProvider(){
  rm=new MockRM(configuration);
  rm.init(configuration);
  rm.start();
  try {
    rm.adminService.refreshAdminAcls(RefreshAdminAclsRequest.newInstance());
  }
 catch (  Exception ex) {
    fail("Using localConfigurationProvider. Should not get any exception.");
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testServiceAclsRefreshWithLocalConfigurationProvider(){
  configuration.setBoolean(CommonConfigurationKeysPublic.HADOOP_SECURITY_AUTHORIZATION,true);
  ResourceManager resourceManager=null;
  try {
    resourceManager=new ResourceManager();
    resourceManager.init(configuration);
    resourceManager.start();
    resourceManager.adminService.refreshServiceAcls(RefreshServiceAclsRequest.newInstance());
  }
 catch (  Exception ex) {
    fail("Using localConfigurationProvider. Should not get any exception.");
  }
 finally {
    if (resourceManager != null) {
      resourceManager.stop();
    }
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testRefreshSuperUserGroupsWithLocalConfigurationProvider(){
  rm=new MockRM(configuration);
  rm.init(configuration);
  rm.start();
  try {
    rm.adminService.refreshSuperUserGroupsConfiguration(RefreshSuperUserGroupsConfigurationRequest.newInstance());
  }
 catch (  Exception ex) {
    fail("Using localConfigurationProvider. Should not get any exception.");
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-10 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testAdminRefreshQueuesWithFileSystemBasedConfigurationProvider() throws IOException, YarnException {
  configuration.set(YarnConfiguration.RM_CONFIGURATION_PROVIDER_CLASS,"org.apache.hadoop.yarn.FileSystemBasedConfigurationProvider");
  uploadDefaultConfiguration();
  try {
    rm=new MockRM(configuration);
    rm.init(configuration);
    rm.start();
  }
 catch (  Exception ex) {
    fail("Should not get any exceptions");
  }
  CapacityScheduler cs=(CapacityScheduler)rm.getRMContext().getScheduler();
  int maxAppsBefore=cs.getConfiguration().getMaximumSystemApplications();
  CapacitySchedulerConfiguration csConf=new CapacitySchedulerConfiguration();
  csConf.set("yarn.scheduler.capacity.maximum-applications","5000");
  uploadConfiguration(csConf,"capacity-scheduler.xml");
  rm.adminService.refreshQueues(RefreshQueuesRequest.newInstance());
  int maxAppsAfter=cs.getConfiguration().getMaximumSystemApplications();
  Assert.assertEquals(maxAppsAfter,5000);
  Assert.assertTrue(maxAppsAfter != maxAppsBefore);
}

</code></pre>

<br>
<pre class="type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testRefreshSuperUserGroupsWithFileSystemBasedConfigurationProvider() throws IOException, YarnException {
  configuration.set(YarnConfiguration.RM_CONFIGURATION_PROVIDER_CLASS,"org.apache.hadoop.yarn.FileSystemBasedConfigurationProvider");
  uploadDefaultConfiguration();
  try {
    rm=new MockRM(configuration);
    rm.init(configuration);
    rm.start();
  }
 catch (  Exception ex) {
    fail("Should not get any exceptions");
  }
  Configuration coreConf=new Configuration(false);
  coreConf.set("hadoop.proxyuser.test.groups","test_groups");
  coreConf.set("hadoop.proxyuser.test.hosts","test_hosts");
  uploadConfiguration(coreConf,"core-site.xml");
  rm.adminService.refreshSuperUserGroupsConfiguration(RefreshSuperUserGroupsConfigurationRequest.newInstance());
  Assert.assertTrue(ProxyUsers.getDefaultImpersonationProvider().getProxyGroups().get("hadoop.proxyuser.test.groups").size() == 1);
  Assert.assertTrue(ProxyUsers.getDefaultImpersonationProvider().getProxyGroups().get("hadoop.proxyuser.test.groups").contains("test_groups"));
  Assert.assertTrue(ProxyUsers.getDefaultImpersonationProvider().getProxyHosts().get("hadoop.proxyuser.test.hosts").size() == 1);
  Assert.assertTrue(ProxyUsers.getDefaultImpersonationProvider().getProxyHosts().get("hadoop.proxyuser.test.hosts").contains("test_hosts"));
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.yarn.server.resourcemanager.TestRMHA </h4><pre class="type-2 type-7 type-10 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testHAIDLookup(){
  Configuration conf=new YarnConfiguration(configuration);
  rm=new MockRM(conf);
  rm.init(conf);
  assertEquals(conf.get(YarnConfiguration.RM_HA_ID),RM2_NODE_ID);
  configuration.set(YarnConfiguration.RM_HA_ID,RM1_NODE_ID);
  conf=new YarnConfiguration(configuration);
  rm=new MockRM(conf);
  rm.init(conf);
  assertEquals(conf.get(YarnConfiguration.RM_HA_ID),RM1_NODE_ID);
  configuration.set(YarnConfiguration.RM_HA_IDS,RM1_NODE_ID + "," + RM3_NODE_ID);
  configuration.unset(YarnConfiguration.RM_HA_ID);
  conf=new YarnConfiguration(configuration);
  try {
    rm=new MockRM(conf);
    rm.init(conf);
    fail("Should get an exception here.");
  }
 catch (  Exception ex) {
    Assert.assertTrue(ex.getMessage().contains("Invalid configuration! Can not find valid RM_HA_ID."));
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testTransitionsWhenAutomaticFailoverEnabled() throws Exception {
  final String ERR_UNFORCED_REQUEST="User request succeeded even when " + "automatic failover is enabled";
  Configuration conf=new YarnConfiguration(configuration);
  rm=new MockRM(conf);
  rm.init(conf);
  rm.start();
  StateChangeRequestInfo requestInfo=new StateChangeRequestInfo(HAServiceProtocol.RequestSource.REQUEST_BY_USER);
  try {
    rm.adminService.transitionToStandby(requestInfo);
    fail(ERR_UNFORCED_REQUEST);
  }
 catch (  AccessControlException e) {
  }
  checkMonitorHealth();
  checkStandbyRMFunctionality();
  try {
    rm.adminService.transitionToActive(requestInfo);
    fail(ERR_UNFORCED_REQUEST);
  }
 catch (  AccessControlException e) {
  }
  checkMonitorHealth();
  checkStandbyRMFunctionality();
  final String ERR_FORCED_REQUEST="Forced request by user should work " + "even if automatic failover is enabled";
  requestInfo=new StateChangeRequestInfo(HAServiceProtocol.RequestSource.REQUEST_BY_USER_FORCED);
  try {
    rm.adminService.transitionToStandby(requestInfo);
  }
 catch (  AccessControlException e) {
    fail(ERR_FORCED_REQUEST);
  }
  checkMonitorHealth();
  checkStandbyRMFunctionality();
  try {
    rm.adminService.transitionToActive(requestInfo);
  }
 catch (  AccessControlException e) {
    fail(ERR_FORCED_REQUEST);
  }
  checkMonitorHealth();
  checkActiveRMFunctionality();
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.yarn.server.resourcemanager.TestRMRestart </h4><pre class="type-2 type-7 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=10000) public void testRMShutdown() throws Exception {
  MemoryRMStateStore memStore=new MemoryRMStateStore(){
    @Override public synchronized void checkVersion() throws Exception {
      throw new Exception("Invalid version.");
    }
  }
;
  memStore.init(conf);
  MockRM rm1=null;
  try {
    rm1=new MockRM(conf,memStore);
    rm1.start();
    Assert.fail();
  }
 catch (  Exception e) {
    Assert.assertTrue(e.getMessage().contains("Invalid version."));
  }
  Assert.assertTrue(rm1.getServiceState() == STATE.STOPPED);
}

</code></pre>

<br>
<pre class="type-9 type-2 type-7 type-10 type-1 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects are null
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testRMDelegationTokenRestoredOnRMRestart() throws Exception {
  conf.setInt(YarnConfiguration.RM_AM_MAX_ATTEMPTS,2);
  conf.set(CommonConfigurationKeysPublic.HADOOP_SECURITY_AUTHENTICATION,"kerberos");
  conf.set(YarnConfiguration.RM_ADDRESS,"localhost:8032");
  UserGroupInformation.setConfiguration(conf);
  MemoryRMStateStore memStore=new MemoryRMStateStore();
  memStore.init(conf);
  RMState rmState=memStore.getState();
  Map<ApplicationId,ApplicationState> rmAppState=rmState.getApplicationState();
  Map<RMDelegationTokenIdentifier,Long> rmDTState=rmState.getRMDTSecretManagerState().getTokenState();
  Set<DelegationKey> rmDTMasterKeyState=rmState.getRMDTSecretManagerState().getMasterKeyState();
  MockRM rm1=new TestSecurityMockRM(conf,memStore);
  rm1.start();
  Credentials ts=new Credentials();
  GetDelegationTokenRequest request1=GetDelegationTokenRequest.newInstance("renewer1");
  UserGroupInformation.getCurrentUser().setAuthenticationMethod(AuthMethod.KERBEROS);
  GetDelegationTokenResponse response1=rm1.getClientRMService().getDelegationToken(request1);
  org.apache.hadoop.yarn.api.records.Token delegationToken1=response1.getRMDelegationToken();
  Token<RMDelegationTokenIdentifier> token1=ConverterUtils.convertFromYarn(delegationToken1,rmAddr);
  RMDelegationTokenIdentifier dtId1=token1.decodeIdentifier();
  HashSet<RMDelegationTokenIdentifier> tokenIdentSet=new HashSet<RMDelegationTokenIdentifier>();
  ts.addToken(token1.getService(),token1);
  tokenIdentSet.add(dtId1);
  RMApp app=rm1.submitApp(200,"name","user",new HashMap<ApplicationAccessType,String>(),false,"default",1,ts);
  ApplicationState appState=rmAppState.get(app.getApplicationId());
  Assert.assertNotNull(appState);
  Set<DelegationKey> allKeysRM1=rm1.getRMContext().getRMDelegationTokenSecretManager().getAllMasterKeys();
  Assert.assertEquals(allKeysRM1,rmDTMasterKeyState);
  Map<RMDelegationTokenIdentifier,Long> allTokensRM1=rm1.getRMContext().getRMDelegationTokenSecretManager().getAllTokens();
  Assert.assertEquals(tokenIdentSet,allTokensRM1.keySet());
  Assert.assertEquals(allTokensRM1,rmDTState);
  Assert.assertEquals(rm1.getRMContext().getRMDelegationTokenSecretManager().getLatestDTSequenceNumber(),rmState.getRMDTSecretManagerState().getDTSequenceNumber());
  GetDelegationTokenRequest request2=GetDelegationTokenRequest.newInstance("renewer2");
  GetDelegationTokenResponse response2=rm1.getClientRMService().getDelegationToken(request2);
  org.apache.hadoop.yarn.api.records.Token delegationToken2=response2.getRMDelegationToken();
  Token<RMDelegationTokenIdentifier> token2=ConverterUtils.convertFromYarn(delegationToken2,rmAddr);
  RMDelegationTokenIdentifier dtId2=token2.decodeIdentifier();
  try {
    rm1.getRMContext().getRMDelegationTokenSecretManager().cancelToken(token2,UserGroupInformation.getCurrentUser().getUserName());
  }
 catch (  Exception e) {
    Assert.fail();
  }
  Assert.assertEquals(rm1.getRMContext().getRMDelegationTokenSecretManager().getLatestDTSequenceNumber(),dtId2.getSequenceNumber());
  Assert.assertFalse(rmDTState.containsKey(dtId2));
  MockRM rm2=new TestSecurityMockRM(conf,memStore);
  rm2.start();
  Map<RMDelegationTokenIdentifier,Long> allTokensRM2=rm2.getRMContext().getRMDelegationTokenSecretManager().getAllTokens();
  Assert.assertEquals(allTokensRM2.keySet(),allTokensRM1.keySet());
  Assert.assertTrue(rm2.getRMContext().getRMDelegationTokenSecretManager().getAllMasterKeys().containsAll(allKeysRM1));
  Assert.assertEquals(rm1.getRMContext().getRMDelegationTokenSecretManager().getLatestDTSequenceNumber(),rm2.getRMContext().getRMDelegationTokenSecretManager().getLatestDTSequenceNumber());
  Long renewDateBeforeRenew=allTokensRM2.get(dtId1);
  try {
    Thread.sleep(1);
    rm2.getRMContext().getRMDelegationTokenSecretManager().renewToken(token1,"renewer1");
  }
 catch (  Exception e) {
    Assert.fail();
  }
  allTokensRM2=rm2.getRMContext().getRMDelegationTokenSecretManager().getAllTokens();
  Long renewDateAfterRenew=allTokensRM2.get(dtId1);
  Assert.assertTrue(renewDateAfterRenew > renewDateBeforeRenew);
  Assert.assertTrue(rmDTState.containsValue(renewDateAfterRenew));
  Assert.assertFalse(rmDTState.containsValue(renewDateBeforeRenew));
  try {
    rm2.getRMContext().getRMDelegationTokenSecretManager().cancelToken(token1,UserGroupInformation.getCurrentUser().getUserName());
  }
 catch (  Exception e) {
    Assert.fail();
  }
  allTokensRM2=rm2.getRMContext().getRMDelegationTokenSecretManager().getAllTokens();
  Assert.assertFalse(allTokensRM2.containsKey(dtId1));
  Assert.assertFalse(rmDTState.containsKey(dtId1));
  rm1.stop();
  rm2.stop();
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.yarn.server.resourcemanager.TestResourceManager </h4><pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test(timeout=30000) public void testResourceManagerInitConfigValidation() throws Exception {
  Configuration conf=new YarnConfiguration();
  conf.setInt(YarnConfiguration.RM_AM_MAX_ATTEMPTS,-1);
  resourceManager=new ResourceManager();
  try {
    resourceManager.init(conf);
    fail("Exception is expected because the global max attempts" + " is negative.");
  }
 catch (  YarnRuntimeException e) {
    if (!e.getMessage().startsWith("Invalid global max attempts configuration"))     throw e;
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.yarn.server.resourcemanager.TestSubmitApplicationWithRMHA </h4><pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testHandleRMHAafterSubmitApplicationCallWithoutSavedApplicationState() throws Exception {
  startRMsWithCustomizedRMAppManager();
  RMApp app0=rm1.submitApp(200,"",UserGroupInformation.getCurrentUser().getShortUserName(),null,false,null,configuration.getInt(YarnConfiguration.RM_AM_MAX_ATTEMPTS,YarnConfiguration.DEFAULT_RM_AM_MAX_ATTEMPTS),null,null,false,false);
  explicitFailover();
  try {
    rm2.getApplicationReport(app0.getApplicationId());
    Assert.fail("Should get ApplicationNotFoundException here");
  }
 catch (  ApplicationNotFoundException ex) {
  }
  RMApp app1=rm2.submitApp(200,"",UserGroupInformation.getCurrentUser().getShortUserName(),null,false,null,configuration.getInt(YarnConfiguration.RM_AM_MAX_ATTEMPTS,YarnConfiguration.DEFAULT_RM_AM_MAX_ATTEMPTS),null,null,false,false,true,app0.getApplicationId());
  verifySubmitApp(rm2,app1,app0.getApplicationId());
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.yarn.server.resourcemanager.monitor.TestSchedulingMonitor </h4><pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test(timeout=10000) public void testRMStarts(){
  Configuration conf=new YarnConfiguration();
  conf.setBoolean(YarnConfiguration.RM_SCHEDULER_ENABLE_MONITORS,true);
  conf.set(YarnConfiguration.RM_SCHEDULER_MONITOR_POLICIES,ProportionalCapacityPreemptionPolicy.class.getCanonicalName());
  ResourceManager rm=new ResourceManager();
  try {
    rm.init(conf);
  }
 catch (  Exception e) {
    fail("ResourceManager does not start when " + YarnConfiguration.RM_SCHEDULER_ENABLE_MONITORS + " is set to true");
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.yarn.server.resourcemanager.monitor.capacity.TestProportionalCapacityPreemptionPolicy </h4><pre class="type-11 type-2 type-1 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testPolicyInitializeAfterSchedulerInitialized(){
  Configuration conf=new Configuration();
  conf.set(YarnConfiguration.RM_SCHEDULER_MONITOR_POLICIES,ProportionalCapacityPreemptionPolicy.class.getCanonicalName());
  conf.setBoolean(YarnConfiguration.RM_SCHEDULER_ENABLE_MONITORS,true);
  @SuppressWarnings("resource") MockRM rm=new MockRM(conf);
  rm.init(conf);
  for (  Service service : rm.getRMActiveService().getServices()) {
    if (service instanceof SchedulingMonitor) {
      ProportionalCapacityPreemptionPolicy policy=(ProportionalCapacityPreemptionPolicy)((SchedulingMonitor)service).getSchedulingEditPolicy();
      assertNotNull(policy.getResourceCalculator());
      return;
    }
  }
  fail("Failed to find SchedulingMonitor service, please check what happened");
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.yarn.server.resourcemanager.recovery.TestZKRMStateStoreZKClientConnections </h4><pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test(timeout=20000) public void testSetZKAcl(){
  TestZKClient zkClientTester=new TestZKClient();
  YarnConfiguration conf=new YarnConfiguration();
  conf.set(YarnConfiguration.RM_ZK_ACL,"world:anyone:rwca");
  try {
    zkClientTester.store.zkClient.delete(zkClientTester.store.znodeWorkingPath,-1);
    fail("Shouldn't be able to delete path");
  }
 catch (  Exception e) {
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test(timeout=20000) public void testInvalidZKAclConfiguration(){
  TestZKClient zkClientTester=new TestZKClient();
  YarnConfiguration conf=new YarnConfiguration();
  conf.set(YarnConfiguration.RM_ZK_ACL,"randomstring&*");
  try {
    zkClientTester.getRMStateStore(conf);
    fail("ZKRMStateStore created with bad ACL");
  }
 catch (  ZKUtil.BadAclFormatException bafe) {
  }
catch (  Exception e) {
    String error="Incorrect exception on BadAclFormat";
    LOG.error(error,e);
    fail(error);
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=20000) public void testZKSessionTimeout() throws Exception {
  TestZKClient zkClientTester=new TestZKClient();
  String path="/test";
  YarnConfiguration conf=new YarnConfiguration();
  conf.setInt(YarnConfiguration.RM_ZK_TIMEOUT_MS,ZK_TIMEOUT_MS);
  ZKRMStateStore store=(ZKRMStateStore)zkClientTester.getRMStateStore(conf);
  TestDispatcher dispatcher=new TestDispatcher();
  store.setRMDispatcher(dispatcher);
  zkClientTester.forExpire=true;
  store.createWithRetries(path,null,ZooDefs.Ids.OPEN_ACL_UNSAFE,CreateMode.PERSISTENT);
  store.getDataWithRetries(path,true);
  store.setDataWithRetries(path,"bytes".getBytes(),0);
  zkClientTester.syncBarrier.await();
  try {
    byte[] ret=store.getDataWithRetries(path,false);
    assertEquals("bytes",new String(ret));
  }
 catch (  Exception e) {
    String error="New session creation failed";
    LOG.error(error,e);
    fail(error);
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-10 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=20000) public void testZKClientDisconnectAndReconnect() throws Exception {
  TestZKClient zkClientTester=new TestZKClient();
  String path="/test";
  YarnConfiguration conf=new YarnConfiguration();
  conf.setInt(YarnConfiguration.RM_ZK_TIMEOUT_MS,ZK_TIMEOUT_MS);
  ZKRMStateStore store=(ZKRMStateStore)zkClientTester.getRMStateStore(conf);
  TestDispatcher dispatcher=new TestDispatcher();
  store.setRMDispatcher(dispatcher);
  store.createWithRetries(path,null,ZooDefs.Ids.OPEN_ACL_UNSAFE,CreateMode.PERSISTENT);
  store.getDataWithRetries(path,true);
  store.setDataWithRetries(path,"newBytes".getBytes(),0);
  stopServer();
  zkClientTester.watcher.waitForDisconnected(ZK_OP_WAIT_TIME);
  try {
    store.getDataWithRetries(path,true);
    fail("Expected ZKClient time out exception");
  }
 catch (  Exception e) {
    assertTrue(e.getMessage().contains("Wait for ZKClient creation timed out"));
  }
  startServer();
  zkClientTester.watcher.waitForConnected(ZK_OP_WAIT_TIME);
  byte[] ret=null;
  try {
    ret=store.getDataWithRetries(path,true);
  }
 catch (  Exception e) {
    String error="ZKRMStateStore Session restore failed";
    LOG.error(error,e);
    fail(error);
  }
  assertEquals("newBytes",new String(ret));
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.yarn.server.resourcemanager.scheduler.TestQueueMetrics </h4><pre class="type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testCollectAllMetrics(){
  String queueName="single";
  QueueMetrics.forQueue(ms,queueName,null,false,conf);
  MetricsSource queueSource=queueSource(ms,queueName);
  checkApps(queueSource,0,0,0,0,0,0,true);
  try {
    checkApps(queueSource,0,0,0,0,0,0,false);
    Assert.fail();
  }
 catch (  AssertionError e) {
    Assert.assertTrue(e.getMessage().contains("Expected exactly one metric for name "));
  }
  checkApps(queueSource,0,0,0,0,0,0,true);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.yarn.server.resourcemanager.scheduler.TestSchedulerUtils </h4><pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test(timeout=30000) public void testValidateResourceRequest(){
  Resource maxResource=Resources.createResource(YarnConfiguration.DEFAULT_RM_SCHEDULER_MAXIMUM_ALLOCATION_MB,YarnConfiguration.DEFAULT_RM_SCHEDULER_MAXIMUM_ALLOCATION_VCORES);
  try {
    Resource resource=Resources.createResource(0,YarnConfiguration.DEFAULT_RM_SCHEDULER_MINIMUM_ALLOCATION_VCORES);
    ResourceRequest resReq=BuilderUtils.newResourceRequest(mock(Priority.class),ResourceRequest.ANY,resource,1);
    SchedulerUtils.validateResourceRequest(resReq,maxResource);
  }
 catch (  InvalidResourceRequestException e) {
    fail("Zero memory should be accepted");
  }
  try {
    Resource resource=Resources.createResource(YarnConfiguration.DEFAULT_RM_SCHEDULER_MINIMUM_ALLOCATION_MB,0);
    ResourceRequest resReq=BuilderUtils.newResourceRequest(mock(Priority.class),ResourceRequest.ANY,resource,1);
    SchedulerUtils.validateResourceRequest(resReq,maxResource);
  }
 catch (  InvalidResourceRequestException e) {
    fail("Zero vcores should be accepted");
  }
  try {
    Resource resource=Resources.createResource(YarnConfiguration.DEFAULT_RM_SCHEDULER_MAXIMUM_ALLOCATION_MB,YarnConfiguration.DEFAULT_RM_SCHEDULER_MINIMUM_ALLOCATION_VCORES);
    ResourceRequest resReq=BuilderUtils.newResourceRequest(mock(Priority.class),ResourceRequest.ANY,resource,1);
    SchedulerUtils.validateResourceRequest(resReq,maxResource);
  }
 catch (  InvalidResourceRequestException e) {
    fail("Max memory should be accepted");
  }
  try {
    Resource resource=Resources.createResource(YarnConfiguration.DEFAULT_RM_SCHEDULER_MINIMUM_ALLOCATION_MB,YarnConfiguration.DEFAULT_RM_SCHEDULER_MAXIMUM_ALLOCATION_VCORES);
    ResourceRequest resReq=BuilderUtils.newResourceRequest(mock(Priority.class),ResourceRequest.ANY,resource,1);
    SchedulerUtils.validateResourceRequest(resReq,maxResource);
  }
 catch (  InvalidResourceRequestException e) {
    fail("Max vcores should not be accepted");
  }
  try {
    Resource resource=Resources.createResource(-1,YarnConfiguration.DEFAULT_RM_SCHEDULER_MINIMUM_ALLOCATION_VCORES);
    ResourceRequest resReq=BuilderUtils.newResourceRequest(mock(Priority.class),ResourceRequest.ANY,resource,1);
    SchedulerUtils.validateResourceRequest(resReq,maxResource);
    fail("Negative memory should not be accepted");
  }
 catch (  InvalidResourceRequestException e) {
  }
  try {
    Resource resource=Resources.createResource(YarnConfiguration.DEFAULT_RM_SCHEDULER_MINIMUM_ALLOCATION_MB,-1);
    ResourceRequest resReq=BuilderUtils.newResourceRequest(mock(Priority.class),ResourceRequest.ANY,resource,1);
    SchedulerUtils.validateResourceRequest(resReq,maxResource);
    fail("Negative vcores should not be accepted");
  }
 catch (  InvalidResourceRequestException e) {
  }
  try {
    Resource resource=Resources.createResource(YarnConfiguration.DEFAULT_RM_SCHEDULER_MAXIMUM_ALLOCATION_MB + 1,YarnConfiguration.DEFAULT_RM_SCHEDULER_MINIMUM_ALLOCATION_VCORES);
    ResourceRequest resReq=BuilderUtils.newResourceRequest(mock(Priority.class),ResourceRequest.ANY,resource,1);
    SchedulerUtils.validateResourceRequest(resReq,maxResource);
    fail("More than max memory should not be accepted");
  }
 catch (  InvalidResourceRequestException e) {
  }
  try {
    Resource resource=Resources.createResource(YarnConfiguration.DEFAULT_RM_SCHEDULER_MINIMUM_ALLOCATION_MB,YarnConfiguration.DEFAULT_RM_SCHEDULER_MAXIMUM_ALLOCATION_VCORES + 1);
    ResourceRequest resReq=BuilderUtils.newResourceRequest(mock(Priority.class),ResourceRequest.ANY,resource,1);
    SchedulerUtils.validateResourceRequest(resReq,maxResource);
    fail("More than max vcores should not be accepted");
  }
 catch (  InvalidResourceRequestException e) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.yarn.server.resourcemanager.scheduler.capacity.TestCapacityScheduler </h4><pre class="type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=30000) public void testConfValidation() throws Exception {
  ResourceScheduler scheduler=new CapacityScheduler();
  scheduler.setRMContext(resourceManager.getRMContext());
  Configuration conf=new YarnConfiguration();
  conf.setInt(YarnConfiguration.RM_SCHEDULER_MINIMUM_ALLOCATION_MB,2048);
  conf.setInt(YarnConfiguration.RM_SCHEDULER_MAXIMUM_ALLOCATION_MB,1024);
  try {
    scheduler.reinitialize(conf,mockContext);
    fail("Exception is expected because the min memory allocation is" + " larger than the max memory allocation.");
  }
 catch (  YarnRuntimeException e) {
    assertTrue("The thrown exception is not the expected one.",e.getMessage().startsWith("Invalid resource scheduler memory"));
  }
  conf=new YarnConfiguration();
  conf.setInt(YarnConfiguration.RM_SCHEDULER_MINIMUM_ALLOCATION_VCORES,2);
  conf.setInt(YarnConfiguration.RM_SCHEDULER_MAXIMUM_ALLOCATION_VCORES,1);
  try {
    scheduler.reinitialize(conf,mockContext);
    fail("Exception is expected because the min vcores allocation is" + " larger than the max vcores allocation.");
  }
 catch (  YarnRuntimeException e) {
    assertTrue("The thrown exception is not the expected one.",e.getMessage().startsWith("Invalid resource scheduler vcores"));
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-10 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testMoveAllAppsInvalidDestination() throws Exception {
  MockRM rm=setUpMove();
  AbstractYarnScheduler scheduler=(AbstractYarnScheduler)rm.getResourceScheduler();
  RMApp app=rm.submitApp(GB,"test-move-1","user_0",null,"a1");
  ApplicationAttemptId appAttemptId=rm.getApplicationReport(app.getApplicationId()).getCurrentApplicationAttemptId();
  List<ApplicationAttemptId> appsInA1=scheduler.getAppsInQueue("a1");
  assertEquals(1,appsInA1.size());
  List<ApplicationAttemptId> appsInA=scheduler.getAppsInQueue("a");
  assertTrue(appsInA.contains(appAttemptId));
  assertEquals(1,appsInA.size());
  List<ApplicationAttemptId> appsInRoot=scheduler.getAppsInQueue("root");
  assertTrue(appsInRoot.contains(appAttemptId));
  assertEquals(1,appsInRoot.size());
  List<ApplicationAttemptId> appsInB1=scheduler.getAppsInQueue("b1");
  assertTrue(appsInB1.isEmpty());
  List<ApplicationAttemptId> appsInB=scheduler.getAppsInQueue("b");
  assertTrue(appsInB.isEmpty());
  try {
    scheduler.moveAllApps("a1","DOES_NOT_EXIST");
    Assert.fail();
  }
 catch (  YarnException e) {
  }
  appsInA1=scheduler.getAppsInQueue("a1");
  assertEquals(1,appsInA1.size());
  appsInA=scheduler.getAppsInQueue("a");
  assertTrue(appsInA.contains(appAttemptId));
  assertEquals(1,appsInA.size());
  appsInRoot=scheduler.getAppsInQueue("root");
  assertTrue(appsInRoot.contains(appAttemptId));
  assertEquals(1,appsInRoot.size());
  appsInB1=scheduler.getAppsInQueue("b1");
  assertTrue(appsInB1.isEmpty());
  appsInB=scheduler.getAppsInQueue("b");
  assertTrue(appsInB.isEmpty());
  rm.stop();
}

</code></pre>

<br>
<pre class="type-2 type-7 type-10 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testMoveAllAppsInvalidSource() throws Exception {
  MockRM rm=setUpMove();
  AbstractYarnScheduler scheduler=(AbstractYarnScheduler)rm.getResourceScheduler();
  RMApp app=rm.submitApp(GB,"test-move-1","user_0",null,"a1");
  ApplicationAttemptId appAttemptId=rm.getApplicationReport(app.getApplicationId()).getCurrentApplicationAttemptId();
  List<ApplicationAttemptId> appsInA1=scheduler.getAppsInQueue("a1");
  assertEquals(1,appsInA1.size());
  List<ApplicationAttemptId> appsInA=scheduler.getAppsInQueue("a");
  assertTrue(appsInA.contains(appAttemptId));
  assertEquals(1,appsInA.size());
  List<ApplicationAttemptId> appsInRoot=scheduler.getAppsInQueue("root");
  assertTrue(appsInRoot.contains(appAttemptId));
  assertEquals(1,appsInRoot.size());
  List<ApplicationAttemptId> appsInB1=scheduler.getAppsInQueue("b1");
  assertTrue(appsInB1.isEmpty());
  List<ApplicationAttemptId> appsInB=scheduler.getAppsInQueue("b");
  assertTrue(appsInB.isEmpty());
  try {
    scheduler.moveAllApps("DOES_NOT_EXIST","b1");
    Assert.fail();
  }
 catch (  YarnException e) {
  }
  appsInA1=scheduler.getAppsInQueue("a1");
  assertEquals(1,appsInA1.size());
  appsInA=scheduler.getAppsInQueue("a");
  assertTrue(appsInA.contains(appAttemptId));
  assertEquals(1,appsInA.size());
  appsInRoot=scheduler.getAppsInQueue("root");
  assertTrue(appsInRoot.contains(appAttemptId));
  assertEquals(1,appsInRoot.size());
  appsInB1=scheduler.getAppsInQueue("b1");
  assertTrue(appsInB1.isEmpty());
  appsInB=scheduler.getAppsInQueue("b");
  assertTrue(appsInB.isEmpty());
  rm.stop();
}

</code></pre>

<br>
<pre class="type-2 type-7 type-10 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testKillAllAppsInvalidSource() throws Exception {
  MockRM rm=setUpMove();
  AbstractYarnScheduler scheduler=(AbstractYarnScheduler)rm.getResourceScheduler();
  RMApp app=rm.submitApp(GB,"test-move-1","user_0",null,"a1");
  ApplicationAttemptId appAttemptId=rm.getApplicationReport(app.getApplicationId()).getCurrentApplicationAttemptId();
  List<ApplicationAttemptId> appsInA1=scheduler.getAppsInQueue("a1");
  assertEquals(1,appsInA1.size());
  List<ApplicationAttemptId> appsInA=scheduler.getAppsInQueue("a");
  assertTrue(appsInA.contains(appAttemptId));
  assertEquals(1,appsInA.size());
  List<ApplicationAttemptId> appsInRoot=scheduler.getAppsInQueue("root");
  assertTrue(appsInRoot.contains(appAttemptId));
  assertEquals(1,appsInRoot.size());
  try {
    scheduler.killAllAppsInQueue("DOES_NOT_EXIST");
    Assert.fail();
  }
 catch (  YarnException e) {
  }
  appsInA1=scheduler.getAppsInQueue("a1");
  assertEquals(1,appsInA1.size());
  appsInA=scheduler.getAppsInQueue("a");
  assertTrue(appsInA.contains(appAttemptId));
  assertEquals(1,appsInA.size());
  appsInRoot=scheduler.getAppsInQueue("root");
  assertTrue(appsInRoot.contains(appAttemptId));
  assertEquals(1,appsInRoot.size());
  rm.stop();
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.yarn.server.resourcemanager.scheduler.capacity.TestLeafQueue </h4><pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testAllocateContainerOnNodeWithoutOffSwitchSpecified() throws Exception {
  LeafQueue a=stubLeafQueue((LeafQueue)queues.get(B));
  final String user_0="user_0";
  final ApplicationAttemptId appAttemptId_0=TestUtils.getMockApplicationAttemptId(0,0);
  FiCaSchedulerApp app_0=new FiCaSchedulerApp(appAttemptId_0,user_0,a,mock(ActiveUsersManager.class),rmContext);
  a.submitApplicationAttempt(app_0,user_0);
  final ApplicationAttemptId appAttemptId_1=TestUtils.getMockApplicationAttemptId(1,0);
  FiCaSchedulerApp app_1=new FiCaSchedulerApp(appAttemptId_1,user_0,a,mock(ActiveUsersManager.class),rmContext);
  a.submitApplicationAttempt(app_1,user_0);
  String host_0="127.0.0.1";
  FiCaSchedulerNode node_0=TestUtils.getMockNode(host_0,DEFAULT_RACK,0,8 * GB);
  final int numNodes=1;
  Resource clusterResource=Resources.createResource(numNodes * (8 * GB),numNodes * 16);
  when(csContext.getNumClusterNodes()).thenReturn(numNodes);
  Priority priority=TestUtils.createMockPriority(1);
  app_0.updateResourceRequests(Arrays.asList(TestUtils.createResourceRequest("127.0.0.1",1 * GB,3,true,priority,recordFactory),TestUtils.createResourceRequest(DEFAULT_RACK,1 * GB,3,true,priority,recordFactory)));
  try {
    a.assignContainers(clusterResource,node_0);
  }
 catch (  NullPointerException e) {
    Assert.fail("NPE when allocating container on node but " + "forget to set off-switch request should be handled");
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.yarn.server.resourcemanager.scheduler.capacity.TestParentQueue </h4><pre class="type-11 type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testSingleLevelQueuesPrecision() throws Exception {
  setupSingleLevelQueues(csConf);
  final String Q_A=CapacitySchedulerConfiguration.ROOT + "." + "a";
  csConf.setCapacity(Q_A,30);
  final String Q_B=CapacitySchedulerConfiguration.ROOT + "." + "b";
  csConf.setCapacity(Q_B,70.5F);
  Map<String,CSQueue> queues=new HashMap<String,CSQueue>();
  boolean exceptionOccured=false;
  try {
    CapacityScheduler.parseQueue(csContext,csConf,null,CapacitySchedulerConfiguration.ROOT,queues,queues,TestUtils.spyHook);
  }
 catch (  IllegalArgumentException ie) {
    exceptionOccured=true;
  }
  if (!exceptionOccured) {
    Assert.fail("Capacity is more then 100% so should be failed.");
  }
  csConf.setCapacity(Q_A,30);
  csConf.setCapacity(Q_B,70);
  exceptionOccured=false;
  queues.clear();
  try {
    CapacityScheduler.parseQueue(csContext,csConf,null,CapacitySchedulerConfiguration.ROOT,queues,queues,TestUtils.spyHook);
  }
 catch (  IllegalArgumentException ie) {
    exceptionOccured=true;
  }
  if (exceptionOccured) {
    Assert.fail("Capacity is 100% so should not be failed.");
  }
  csConf.setCapacity(Q_A,30);
  csConf.setCapacity(Q_B,70.005F);
  exceptionOccured=false;
  queues.clear();
  try {
    CapacityScheduler.parseQueue(csContext,csConf,null,CapacitySchedulerConfiguration.ROOT,queues,queues,TestUtils.spyHook);
  }
 catch (  IllegalArgumentException ie) {
    exceptionOccured=true;
  }
  if (exceptionOccured) {
    Assert.fail("Capacity is under PRECISION which is .05% so should not be failed.");
  }
}

</code></pre>

<br>
<pre class="type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testQueueCapacityZero() throws Exception {
  setupMultiLevelQueues(csConf);
  final String Q_B=CapacitySchedulerConfiguration.ROOT + "." + B;
  csConf.setCapacity(Q_B,0);
  csConf.setCapacity(Q_B + "." + B1,0);
  csConf.setCapacity(Q_B + "." + B2,0);
  csConf.setCapacity(Q_B + "." + B3,0);
  final String Q_A=CapacitySchedulerConfiguration.ROOT + "." + A;
  csConf.setCapacity(Q_A,60);
  Map<String,CSQueue> queues=new HashMap<String,CSQueue>();
  try {
    CapacityScheduler.parseQueue(csContext,csConf,null,CapacitySchedulerConfiguration.ROOT,queues,queues,TestUtils.spyHook);
  }
 catch (  IllegalArgumentException e) {
    fail("Failed to create queues with 0 capacity: " + e);
  }
  assertTrue("Failed to create queues with 0 capacity",true);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.yarn.server.resourcemanager.scheduler.fair.TestFairScheduler </h4><pre class="type-2 type-10 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testContinuousSchedulingWithNodeRemoved() throws Exception {
  scheduler.init(conf);
  scheduler.start();
  Assert.assertTrue("Continuous scheduling should be disabled.",!scheduler.isContinuousSchedulingEnabled());
  RMNode node1=MockNodes.newNodeInfo(1,Resources.createResource(8 * 1024,8),1,"127.0.0.1");
  NodeAddedSchedulerEvent nodeEvent1=new NodeAddedSchedulerEvent(node1);
  scheduler.handle(nodeEvent1);
  RMNode node2=MockNodes.newNodeInfo(1,Resources.createResource(8 * 1024,8),2,"127.0.0.2");
  NodeAddedSchedulerEvent nodeEvent2=new NodeAddedSchedulerEvent(node2);
  scheduler.handle(nodeEvent2);
  Assert.assertEquals("We should have two alive nodes.",2,scheduler.getNumClusterNodes());
  NodeRemovedSchedulerEvent removeNode1=new NodeRemovedSchedulerEvent(node1);
  scheduler.handle(removeNode1);
  Assert.assertEquals("We should only have one alive node.",1,scheduler.getNumClusterNodes());
  try {
    scheduler.continuousSchedulingAttempt();
  }
 catch (  Exception e) {
    fail("Exception happened when doing continuous scheduling. " + e.toString());
  }
}

</code></pre>

<br>
<pre class="type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=30000) public void testConfValidation() throws Exception {
  FairScheduler scheduler=new FairScheduler();
  Configuration conf=new YarnConfiguration();
  conf.setInt(YarnConfiguration.RM_SCHEDULER_MINIMUM_ALLOCATION_MB,2048);
  conf.setInt(YarnConfiguration.RM_SCHEDULER_MAXIMUM_ALLOCATION_MB,1024);
  try {
    scheduler.serviceInit(conf);
    fail("Exception is expected because the min memory allocation is" + " larger than the max memory allocation.");
  }
 catch (  YarnRuntimeException e) {
    assertTrue("The thrown exception is not the expected one.",e.getMessage().startsWith("Invalid resource scheduler memory"));
  }
  conf=new YarnConfiguration();
  conf.setInt(YarnConfiguration.RM_SCHEDULER_MINIMUM_ALLOCATION_VCORES,2);
  conf.setInt(YarnConfiguration.RM_SCHEDULER_MAXIMUM_ALLOCATION_VCORES,1);
  try {
    scheduler.serviceInit(conf);
    fail("Exception is expected because the min vcores allocation is" + " larger than the max vcores allocation.");
  }
 catch (  YarnRuntimeException e) {
    assertTrue("The thrown exception is not the expected one.",e.getMessage().startsWith("Invalid resource scheduler vcores"));
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.yarn.server.resourcemanager.security.TestAMRMTokens </h4><pre class="type-9 type-2 type-7 type-10 type-1 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Validate master-key-roll-over and that tokens are usable even after
 * master-key-roll-over.
 * @throws Exception
 */
@Test public void testMasterKeyRollOver() throws Exception {
  conf.setLong(YarnConfiguration.RM_AMRM_TOKEN_MASTER_KEY_ROLLING_INTERVAL_SECS,rolling_interval_sec);
  conf.setLong(YarnConfiguration.RM_AM_EXPIRY_INTERVAL_MS,am_expire_ms);
  MyContainerManager containerManager=new MyContainerManager();
  final MockRMWithAMS rm=new MockRMWithAMS(conf,containerManager);
  rm.start();
  Long startTime=System.currentTimeMillis();
  final Configuration conf=rm.getConfig();
  final YarnRPC rpc=YarnRPC.create(conf);
  ApplicationMasterProtocol rmClient=null;
  AMRMTokenSecretManager appTokenSecretManager=rm.getRMContext().getAMRMTokenSecretManager();
  MasterKeyData oldKey=appTokenSecretManager.getMasterKey();
  Assert.assertNotNull(oldKey);
  try {
    MockNM nm1=rm.registerNode("localhost:1234",5120);
    RMApp app=rm.submitApp(1024);
    nm1.nodeHeartbeat(true);
    int waitCount=0;
    while (containerManager.containerTokens == null && waitCount++ < maxWaitAttempts) {
      LOG.info("Waiting for AM Launch to happen..");
      Thread.sleep(1000);
    }
    Assert.assertNotNull(containerManager.containerTokens);
    RMAppAttempt attempt=app.getCurrentAppAttempt();
    ApplicationAttemptId applicationAttemptId=attempt.getAppAttemptId();
    UserGroupInformation currentUser=UserGroupInformation.createRemoteUser(applicationAttemptId.toString());
    Credentials credentials=containerManager.getContainerCredentials();
    final InetSocketAddress rmBindAddress=rm.getApplicationMasterService().getBindAddress();
    Token<? extends TokenIdentifier> amRMToken=MockRMWithAMS.setupAndReturnAMRMToken(rmBindAddress,credentials.getAllTokens());
    currentUser.addToken(amRMToken);
    rmClient=createRMClient(rm,conf,rpc,currentUser);
    RegisterApplicationMasterRequest request=Records.newRecord(RegisterApplicationMasterRequest.class);
    rmClient.registerApplicationMaster(request);
    AllocateRequest allocateRequest=Records.newRecord(AllocateRequest.class);
    Assert.assertTrue(rmClient.allocate(allocateRequest).getAMCommand() == null);
    while (System.currentTimeMillis() - startTime < rolling_interval_sec * 1000) {
      rmClient.allocate(allocateRequest);
      Thread.sleep(500);
    }
    MasterKeyData newKey=appTokenSecretManager.getMasterKey();
    Assert.assertNotNull(newKey);
    Assert.assertFalse("Master key should have changed!",oldKey.equals(newKey));
    rpc.stopProxy(rmClient,conf);
    rmClient=createRMClient(rm,conf,rpc,currentUser);
    Assert.assertTrue(rmClient.allocate(allocateRequest).getAMCommand() == null);
    waitCount=0;
    while (waitCount++ <= maxWaitAttempts) {
      if (appTokenSecretManager.getCurrnetMasterKeyData() != oldKey) {
        break;
      }
      try {
        rmClient.allocate(allocateRequest);
      }
 catch (      Exception ex) {
        break;
      }
      Thread.sleep(200);
    }
    Assert.assertTrue(appTokenSecretManager.getCurrnetMasterKeyData().equals(newKey));
    Assert.assertTrue(appTokenSecretManager.getMasterKey().equals(newKey));
    Assert.assertTrue(appTokenSecretManager.getNextMasterKeyData() == null);
    Token<AMRMTokenIdentifier> newToken=appTokenSecretManager.createAndGetAMRMToken(applicationAttemptId);
    SecurityUtil.setTokenService(newToken,rmBindAddress);
    currentUser.addToken(newToken);
    rpc.stopProxy(rmClient,conf);
    rmClient=createRMClient(rm,conf,rpc,currentUser);
    allocateRequest=Records.newRecord(AllocateRequest.class);
    Assert.assertTrue(rmClient.allocate(allocateRequest).getAMCommand() == null);
    rpc.stopProxy(rmClient,conf);
    try {
      currentUser.addToken(amRMToken);
      rmClient=createRMClient(rm,conf,rpc,currentUser);
      allocateRequest=Records.newRecord(AllocateRequest.class);
      Assert.assertTrue(rmClient.allocate(allocateRequest).getAMCommand() == null);
      Assert.fail("The old Token should not work");
    }
 catch (    Exception ex) {
    }
  }
  finally {
    rm.stop();
    if (rmClient != null) {
      rpc.stopProxy(rmClient,conf);
    }
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-10 type-1 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Validate that application tokens are unusable after the
 * application-finishes.
 * @throws Exception
 */
@SuppressWarnings("unchecked") @Test public void testTokenExpiry() throws Exception {
  MyContainerManager containerManager=new MyContainerManager();
  final MockRMWithAMS rm=new MockRMWithAMS(conf,containerManager);
  rm.start();
  final Configuration conf=rm.getConfig();
  final YarnRPC rpc=YarnRPC.create(conf);
  ApplicationMasterProtocol rmClient=null;
  try {
    MockNM nm1=rm.registerNode("localhost:1234",5120);
    RMApp app=rm.submitApp(1024);
    nm1.nodeHeartbeat(true);
    int waitCount=0;
    while (containerManager.containerTokens == null && waitCount++ < 20) {
      LOG.info("Waiting for AM Launch to happen..");
      Thread.sleep(1000);
    }
    Assert.assertNotNull(containerManager.containerTokens);
    RMAppAttempt attempt=app.getCurrentAppAttempt();
    ApplicationAttemptId applicationAttemptId=attempt.getAppAttemptId();
    UserGroupInformation currentUser=UserGroupInformation.createRemoteUser(applicationAttemptId.toString());
    Credentials credentials=containerManager.getContainerCredentials();
    final InetSocketAddress rmBindAddress=rm.getApplicationMasterService().getBindAddress();
    Token<? extends TokenIdentifier> amRMToken=MockRMWithAMS.setupAndReturnAMRMToken(rmBindAddress,credentials.getAllTokens());
    currentUser.addToken(amRMToken);
    rmClient=createRMClient(rm,conf,rpc,currentUser);
    RegisterApplicationMasterRequest request=Records.newRecord(RegisterApplicationMasterRequest.class);
    rmClient.registerApplicationMaster(request);
    FinishApplicationMasterRequest finishAMRequest=Records.newRecord(FinishApplicationMasterRequest.class);
    finishAMRequest.setFinalApplicationStatus(FinalApplicationStatus.SUCCEEDED);
    finishAMRequest.setDiagnostics("diagnostics");
    finishAMRequest.setTrackingUrl("url");
    rmClient.finishApplicationMaster(finishAMRequest);
    ContainerStatus containerStatus=BuilderUtils.newContainerStatus(attempt.getMasterContainer().getId(),ContainerState.COMPLETE,"AM Container Finished",0);
    rm.getRMContext().getDispatcher().getEventHandler().handle(new RMAppAttemptContainerFinishedEvent(applicationAttemptId,containerStatus));
    int count=0;
    while (attempt.getState() != RMAppAttemptState.FINISHED && count < maxWaitAttempts) {
      Thread.sleep(100);
      count++;
    }
    Assert.assertTrue(attempt.getState() == RMAppAttemptState.FINISHED);
    rpc.stopProxy(rmClient,conf);
    rmClient=createRMClient(rm,conf,rpc,currentUser);
    AllocateRequest allocateRequest=Records.newRecord(AllocateRequest.class);
    try {
      rmClient.allocate(allocateRequest);
      Assert.fail("You got to be kidding me! " + "Using App tokens after app-finish should fail!");
    }
 catch (    Throwable t) {
      LOG.info("Exception found is ",t);
      Assert.assertTrue(t.getCause().getMessage().contains(applicationAttemptId.toString() + " not found in AMRMTokenSecretManager."));
    }
  }
  finally {
    rm.stop();
    if (rmClient != null) {
      rpc.stopProxy(rmClient,conf);
    }
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.yarn.server.resourcemanager.security.TestClientToAMTokens </h4><pre class="type-2 type-7 type-10 type-1 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testClientToAMTokens() throws Exception {
  final Configuration conf=new Configuration();
  conf.set(CommonConfigurationKeysPublic.HADOOP_SECURITY_AUTHENTICATION,"kerberos");
  UserGroupInformation.setConfiguration(conf);
  ContainerManagementProtocol containerManager=mock(ContainerManagementProtocol.class);
  StartContainersResponse mockResponse=mock(StartContainersResponse.class);
  when(containerManager.startContainers((StartContainersRequest)any())).thenReturn(mockResponse);
  final DrainDispatcher dispatcher=new DrainDispatcher();
  MockRM rm=new MockRMWithCustomAMLauncher(conf,containerManager){
    protected ClientRMService createClientRMService(){
      return new ClientRMService(this.rmContext,scheduler,this.rmAppManager,this.applicationACLsManager,this.queueACLsManager,getRMContext().getRMDelegationTokenSecretManager());
    }
    @Override protected Dispatcher createDispatcher(){
      return dispatcher;
    }
    @Override protected void doSecureLogin() throws IOException {
    }
  }
;
  rm.start();
  RMApp app=rm.submitApp(1024);
  MockNM nm1=rm.registerNode("localhost:1234",3072);
  nm1.nodeHeartbeat(true);
  dispatcher.await();
  nm1.nodeHeartbeat(true);
  dispatcher.await();
  ApplicationAttemptId appAttempt=app.getCurrentAppAttempt().getAppAttemptId();
  final MockAM mockAM=new MockAM(rm.getRMContext(),rm.getApplicationMasterService(),app.getCurrentAppAttempt().getAppAttemptId());
  UserGroupInformation appUgi=UserGroupInformation.createRemoteUser(appAttempt.toString());
  RegisterApplicationMasterResponse response=appUgi.doAs(new PrivilegedAction<RegisterApplicationMasterResponse>(){
    @Override public RegisterApplicationMasterResponse run(){
      RegisterApplicationMasterResponse response=null;
      try {
        response=mockAM.registerAppAttempt();
      }
 catch (      Exception e) {
        Assert.fail("Exception was not expected");
      }
      return response;
    }
  }
);
  GetApplicationReportRequest request=Records.newRecord(GetApplicationReportRequest.class);
  request.setApplicationId(app.getApplicationId());
  GetApplicationReportResponse reportResponse=rm.getClientRMService().getApplicationReport(request);
  ApplicationReport appReport=reportResponse.getApplicationReport();
  org.apache.hadoop.yarn.api.records.Token originalClientToAMToken=appReport.getClientToAMToken();
  Assert.assertNotNull(response.getClientToAMTokenMasterKey());
  Assert.assertTrue(response.getClientToAMTokenMasterKey().array().length > 0);
  ApplicationAttemptId appAttemptId=app.getAppAttempts().keySet().iterator().next();
  Assert.assertNotNull(appAttemptId);
  final CustomAM am=new CustomAM(appAttemptId,response.getClientToAMTokenMasterKey().array());
  am.init(conf);
  am.start();
  SecurityUtil.setSecurityInfoProviders(new CustomSecurityInfo());
  try {
    CustomProtocol client=(CustomProtocol)RPC.getProxy(CustomProtocol.class,1L,am.address,conf);
    client.ping();
    fail("Access by unauthenticated user should fail!!");
  }
 catch (  Exception e) {
    Assert.assertFalse(am.pinged);
  }
  Token<ClientToAMTokenIdentifier> token=ConverterUtils.convertFromYarn(originalClientToAMToken,am.address);
  verifyTokenWithTamperedID(conf,am,token);
  verifyTokenWithTamperedUserName(conf,am,token);
  verifyValidToken(conf,am,token);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.yarn.server.resourcemanager.security.TestDelegationTokenRenewer </h4><pre class="type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=20000) public void testAppSubmissionWithInvalidDelegationToken() throws Exception {
  Configuration conf=new Configuration();
  conf.set(CommonConfigurationKeysPublic.HADOOP_SECURITY_AUTHENTICATION,"kerberos");
  UserGroupInformation.setConfiguration(conf);
  MockRM rm=new MockRM(conf);
  ByteBuffer tokens=ByteBuffer.wrap("BOGUS".getBytes());
  ContainerLaunchContext amContainer=ContainerLaunchContext.newInstance(new HashMap<String,LocalResource>(),new HashMap<String,String>(),new ArrayList<String>(),new HashMap<String,ByteBuffer>(),tokens,new HashMap<ApplicationAccessType,String>());
  ApplicationSubmissionContext appSubContext=ApplicationSubmissionContext.newInstance(ApplicationId.newInstance(1234121,0),"BOGUS","default",Priority.UNDEFINED,amContainer,false,true,1,Resource.newInstance(1024,1),"BOGUS");
  SubmitApplicationRequest request=SubmitApplicationRequest.newInstance(appSubContext);
  try {
    rm.getClientRMService().submitApplication(request);
    fail("Error was excepted.");
  }
 catch (  YarnException e) {
    Assert.assertTrue(e.getMessage().contains("Bad header found in token storage"));
  }
}

</code></pre>

<br>
<pre class="type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=20000) public void testDTRonAppSubmission() throws IOException, InterruptedException, BrokenBarrierException {
  final Credentials credsx=new Credentials();
  final Token<?> tokenx=mock(Token.class);
  credsx.addToken(new Text("token"),tokenx);
  doReturn(true).when(tokenx).isManaged();
  doThrow(new IOException("boom")).when(tokenx).renew(any(Configuration.class));
  final DelegationTokenRenewer dtr=createNewDelegationTokenRenewer(conf,counter);
  RMContext mockContext=mock(RMContext.class);
  ClientRMService mockClientRMService=mock(ClientRMService.class);
  when(mockContext.getClientRMService()).thenReturn(mockClientRMService);
  InetSocketAddress sockAddr=InetSocketAddress.createUnresolved("localhost",1234);
  when(mockClientRMService.getBindAddress()).thenReturn(sockAddr);
  dtr.setRMContext(mockContext);
  when(mockContext.getDelegationTokenRenewer()).thenReturn(dtr);
  dtr.init(conf);
  dtr.start();
  try {
    dtr.addApplicationSync(mock(ApplicationId.class),credsx,false);
    fail("Catch IOException on app submission");
  }
 catch (  IOException e) {
    Assert.assertTrue(e.getMessage().contains(tokenx.toString()));
    Assert.assertTrue(e.getCause().toString().contains("boom"));
  }
}

</code></pre>

<br>
<pre class="type-9 type-13 type-11 type-2 type-7 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions in iterations
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60000) public void testAppRejectionWithCancelledDelegationToken() throws Exception {
  MyFS dfs=(MyFS)FileSystem.get(conf);
  LOG.info("dfs=" + (Object)dfs.hashCode() + ";conf="+ conf.hashCode());
  MyToken token=dfs.getDelegationToken("user1");
  token.cancelToken();
  Credentials ts=new Credentials();
  ts.addToken(token.getKind(),token);
  ApplicationId appId=BuilderUtils.newApplicationId(0,0);
  delegationTokenRenewer.addApplicationAsync(appId,ts,true);
  int waitCnt=20;
  while (waitCnt-- > 0) {
    if (!eventQueue.isEmpty()) {
      Event evt=eventQueue.take();
      if (evt.getType() == RMAppEventType.APP_REJECTED) {
        Assert.assertTrue(((RMAppEvent)evt).getApplicationId().equals(appId));
        return;
      }
    }
 else {
      Thread.sleep(500);
    }
  }
  fail("App submission with a cancelled token should have failed");
}

</code></pre>

<br>
<pre class="type-9 type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Basic idea of the test:
 * 1. create tokens.
 * 2. Mark one of them to be renewed in 2 seconds (instead of
 * 24 hours)
 * 3. register them for renewal
 * 4. sleep for 3 seconds
 * 5. count number of renewals (should 3 initial ones + one extra)
 * 6. register another token for 2 seconds 
 * 7. cancel it immediately
 * 8. Sleep and check that the 2 seconds renew didn't happen 
 * (totally 5 renewals)
 * 9. check cancellation
 * @throws IOException
 * @throws URISyntaxException
 */
@Test(timeout=60000) public void testDTRenewal() throws Exception {
  MyFS dfs=(MyFS)FileSystem.get(conf);
  LOG.info("dfs=" + (Object)dfs.hashCode() + ";conf="+ conf.hashCode());
  MyToken token1, token2, token3;
  token1=dfs.getDelegationToken("user1");
  token2=dfs.getDelegationToken("user2");
  token3=dfs.getDelegationToken("user3");
  Renewer.tokenToRenewIn2Sec=token1;
  LOG.info("token=" + token1 + " should be renewed for 2 secs");
  String nn1=DelegationTokenRenewer.SCHEME + "://host1:0";
  String nn2=DelegationTokenRenewer.SCHEME + "://host2:0";
  String nn3=DelegationTokenRenewer.SCHEME + "://host3:0";
  Credentials ts=new Credentials();
  ts.addToken(new Text(nn1),token1);
  ts.addToken(new Text(nn2),token2);
  ts.addToken(new Text(nn3),token3);
  ApplicationId applicationId_0=BuilderUtils.newApplicationId(0,0);
  delegationTokenRenewer.addApplicationAsync(applicationId_0,ts,true);
  waitForEventsToGetProcessed(delegationTokenRenewer);
  int numberOfExpectedRenewals=3 + 1;
  int attempts=10;
  while (attempts-- > 0) {
    try {
      Thread.sleep(3 * 1000);
    }
 catch (    InterruptedException e) {
    }
    if (Renewer.counter == numberOfExpectedRenewals)     break;
  }
  LOG.info("dfs=" + dfs.hashCode() + ";Counter = "+ Renewer.counter+ ";t="+ Renewer.lastRenewed);
  assertEquals("renew wasn't called as many times as expected(4):",numberOfExpectedRenewals,Renewer.counter);
  assertEquals("most recently renewed token mismatch",Renewer.lastRenewed,token1);
  ts=new Credentials();
  MyToken token4=dfs.getDelegationToken("user4");
  Renewer.tokenToRenewIn2Sec=token4;
  LOG.info("token=" + token4 + " should be renewed for 2 secs");
  String nn4=DelegationTokenRenewer.SCHEME + "://host4:0";
  ts.addToken(new Text(nn4),token4);
  ApplicationId applicationId_1=BuilderUtils.newApplicationId(0,1);
  delegationTokenRenewer.addApplicationAsync(applicationId_1,ts,true);
  waitForEventsToGetProcessed(delegationTokenRenewer);
  delegationTokenRenewer.applicationFinished(applicationId_1);
  waitForEventsToGetProcessed(delegationTokenRenewer);
  numberOfExpectedRenewals=Renewer.counter;
  try {
    Thread.sleep(6 * 1000);
  }
 catch (  InterruptedException e) {
  }
  LOG.info("Counter = " + Renewer.counter + ";t="+ Renewer.lastRenewed);
  assertEquals("renew wasn't called as many times as expected",numberOfExpectedRenewals,Renewer.counter);
  try {
    token4.renew(conf);
    fail("Renewal of cancelled token should have failed");
  }
 catch (  InvalidToken ite) {
  }
}

</code></pre>

<br>
<pre class="type-9 type-11 type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Basic idea of the test:
 * 0. Setup token KEEP_ALIVE
 * 1. create tokens.
 * 2. register them for renewal - to be cancelled on app complete
 * 3. Complete app.
 * 4. Verify token is alive within the KEEP_ALIVE time
 * 5. Verify token has been cancelled after the KEEP_ALIVE_TIME
 * @throws IOException
 * @throws URISyntaxException
 */
@Test(timeout=60000) public void testDTKeepAlive1() throws Exception {
  Configuration lconf=new Configuration(conf);
  lconf.setBoolean(YarnConfiguration.LOG_AGGREGATION_ENABLED,true);
  lconf.setLong(YarnConfiguration.RM_NM_EXPIRY_INTERVAL_MS,6000l);
  lconf.setLong(YarnConfiguration.RM_DELAYED_DELEGATION_TOKEN_REMOVAL_INTERVAL_MS,1000l);
  DelegationTokenRenewer localDtr=createNewDelegationTokenRenewer(lconf,counter);
  RMContext mockContext=mock(RMContext.class);
  ClientRMService mockClientRMService=mock(ClientRMService.class);
  when(mockContext.getClientRMService()).thenReturn(mockClientRMService);
  when(mockContext.getDelegationTokenRenewer()).thenReturn(localDtr);
  when(mockContext.getDispatcher()).thenReturn(dispatcher);
  InetSocketAddress sockAddr=InetSocketAddress.createUnresolved("localhost",1234);
  when(mockClientRMService.getBindAddress()).thenReturn(sockAddr);
  localDtr.setRMContext(mockContext);
  localDtr.init(lconf);
  localDtr.start();
  MyFS dfs=(MyFS)FileSystem.get(lconf);
  LOG.info("dfs=" + (Object)dfs.hashCode() + ";conf="+ lconf.hashCode());
  Credentials ts=new Credentials();
  MyToken token1=dfs.getDelegationToken("user1");
  String nn1=DelegationTokenRenewer.SCHEME + "://host1:0";
  ts.addToken(new Text(nn1),token1);
  ApplicationId applicationId_0=BuilderUtils.newApplicationId(0,0);
  localDtr.addApplicationAsync(applicationId_0,ts,true);
  waitForEventsToGetProcessed(localDtr);
  if (!eventQueue.isEmpty()) {
    Event evt=eventQueue.take();
    if (evt instanceof RMAppEvent) {
      Assert.assertEquals(((RMAppEvent)evt).getType(),RMAppEventType.START);
    }
 else {
      fail("RMAppEvent.START was expected!!");
    }
  }
  localDtr.applicationFinished(applicationId_0);
  waitForEventsToGetProcessed(localDtr);
  token1.renew(lconf);
  Thread.sleep(10000l);
  try {
    token1.renew(lconf);
    fail("Renewal of cancelled token should have failed");
  }
 catch (  InvalidToken ite) {
  }
}

</code></pre>

<br>
<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * Basic idea of the test:
 * 0. Setup token KEEP_ALIVE
 * 1. create tokens.
 * 2. register them for renewal - to be cancelled on app complete
 * 3. Complete app.
 * 4. Verify token is alive within the KEEP_ALIVE time
 * 5. Send an explicity KEEP_ALIVE_REQUEST
 * 6. Verify token KEEP_ALIVE time is renewed.
 * 7. Verify token has been cancelled after the renewed KEEP_ALIVE_TIME.
 * @throws IOException
 * @throws URISyntaxException
 */
@Test(timeout=60000) public void testDTKeepAlive2() throws Exception {
  Configuration lconf=new Configuration(conf);
  lconf.setBoolean(YarnConfiguration.LOG_AGGREGATION_ENABLED,true);
  lconf.setLong(YarnConfiguration.RM_NM_EXPIRY_INTERVAL_MS,6000l);
  lconf.setLong(YarnConfiguration.RM_DELAYED_DELEGATION_TOKEN_REMOVAL_INTERVAL_MS,1000l);
  DelegationTokenRenewer localDtr=createNewDelegationTokenRenewer(conf,counter);
  RMContext mockContext=mock(RMContext.class);
  ClientRMService mockClientRMService=mock(ClientRMService.class);
  when(mockContext.getClientRMService()).thenReturn(mockClientRMService);
  when(mockContext.getDelegationTokenRenewer()).thenReturn(localDtr);
  when(mockContext.getDispatcher()).thenReturn(dispatcher);
  InetSocketAddress sockAddr=InetSocketAddress.createUnresolved("localhost",1234);
  when(mockClientRMService.getBindAddress()).thenReturn(sockAddr);
  localDtr.setRMContext(mockContext);
  localDtr.init(lconf);
  localDtr.start();
  MyFS dfs=(MyFS)FileSystem.get(lconf);
  LOG.info("dfs=" + (Object)dfs.hashCode() + ";conf="+ lconf.hashCode());
  Credentials ts=new Credentials();
  MyToken token1=dfs.getDelegationToken("user1");
  String nn1=DelegationTokenRenewer.SCHEME + "://host1:0";
  ts.addToken(new Text(nn1),token1);
  ApplicationId applicationId_0=BuilderUtils.newApplicationId(0,0);
  localDtr.addApplicationAsync(applicationId_0,ts,true);
  localDtr.applicationFinished(applicationId_0);
  waitForEventsToGetProcessed(delegationTokenRenewer);
  localDtr.updateKeepAliveApplications(Collections.singletonList(applicationId_0));
  token1.renew(lconf);
  Thread.sleep(4500l);
  token1.renew(lconf);
  Thread.sleep(3000l);
  try {
    token1.renew(lconf);
    fail("Renewal of cancelled token should have failed");
  }
 catch (  InvalidToken ite) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.yarn.server.resourcemanager.webapp.TestRMWebServices </h4><pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testInvalidAccept() throws JSONException, Exception {
  WebResource r=resource();
  String responseStr="";
  try {
    responseStr=r.path("ws").path("v1").path("cluster").accept(MediaType.TEXT_PLAIN).get(String.class);
    fail("should have thrown exception on invalid uri");
  }
 catch (  UniformInterfaceException ue) {
    ClientResponse response=ue.getResponse();
    assertEquals(Status.INTERNAL_SERVER_ERROR,response.getClientResponseStatus());
    WebServicesTestUtils.checkStringMatch("error string exists and shouldn't","",responseStr);
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testInvalidUri2() throws JSONException, Exception {
  WebResource r=resource();
  String responseStr="";
  try {
    responseStr=r.accept(MediaType.APPLICATION_JSON).get(String.class);
    fail("should have thrown exception on invalid uri");
  }
 catch (  UniformInterfaceException ue) {
    ClientResponse response=ue.getResponse();
    assertEquals(Status.NOT_FOUND,response.getClientResponseStatus());
    WebServicesTestUtils.checkStringMatch("error string exists and shouldn't","",responseStr);
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testInvalidUri() throws JSONException, Exception {
  WebResource r=resource();
  String responseStr="";
  try {
    responseStr=r.path("ws").path("v1").path("cluster").path("bogus").accept(MediaType.APPLICATION_JSON).get(String.class);
    fail("should have thrown exception on invalid uri");
  }
 catch (  UniformInterfaceException ue) {
    ClientResponse response=ue.getResponse();
    assertEquals(Status.NOT_FOUND,response.getClientResponseStatus());
    WebServicesTestUtils.checkStringMatch("error string exists and shouldn't","",responseStr);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.yarn.server.resourcemanager.webapp.TestRMWebServicesApps </h4><pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testNonexistApp() throws JSONException, Exception {
  rm.start();
  MockNM amNodeManager=rm.registerNode("127.0.0.1:1234",2048);
  rm.submitApp(CONTAINER_MB,"testwordcount","user1");
  amNodeManager.nodeHeartbeat(true);
  WebResource r=resource();
  try {
    r.path("ws").path("v1").path("cluster").path("apps").path("application_00000_0099").accept(MediaType.APPLICATION_JSON).get(JSONObject.class);
    fail("should have thrown exception on invalid appid");
  }
 catch (  UniformInterfaceException ue) {
    ClientResponse response=ue.getResponse();
    assertEquals(Status.NOT_FOUND,response.getClientResponseStatus());
    assertEquals(MediaType.APPLICATION_JSON_TYPE,response.getType());
    JSONObject msg=response.getEntity(JSONObject.class);
    JSONObject exception=msg.getJSONObject("RemoteException");
    assertEquals("incorrect number of elements",3,exception.length());
    String message=exception.getString("message");
    String type=exception.getString("exception");
    String classname=exception.getString("javaClassName");
    WebServicesTestUtils.checkStringMatch("exception message","java.lang.Exception: app with id: application_00000_0099 not found",message);
    WebServicesTestUtils.checkStringMatch("exception type","NotFoundException",type);
    WebServicesTestUtils.checkStringMatch("exception classname","org.apache.hadoop.yarn.webapp.NotFoundException",classname);
  }
 finally {
    rm.stop();
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testAppsQueryFinalStatusInvalid() throws JSONException, Exception {
  rm.start();
  MockNM amNodeManager=rm.registerNode("127.0.0.1:1234",2048);
  rm.submitApp(CONTAINER_MB);
  amNodeManager.nodeHeartbeat(true);
  WebResource r=resource();
  try {
    r.path("ws").path("v1").path("cluster").path("apps").queryParam("finalStatus","INVALID_test").accept(MediaType.APPLICATION_JSON).get(JSONObject.class);
    fail("should have thrown exception on invalid state query");
  }
 catch (  UniformInterfaceException ue) {
    ClientResponse response=ue.getResponse();
    assertEquals(Status.BAD_REQUEST,response.getClientResponseStatus());
    assertEquals(MediaType.APPLICATION_JSON_TYPE,response.getType());
    JSONObject msg=response.getEntity(JSONObject.class);
    JSONObject exception=msg.getJSONObject("RemoteException");
    assertEquals("incorrect number of elements",3,exception.length());
    String message=exception.getString("message");
    String type=exception.getString("exception");
    String classname=exception.getString("javaClassName");
    WebServicesTestUtils.checkStringContains("exception message","org.apache.hadoop.yarn.api.records.FinalApplicationStatus.INVALID_test",message);
    WebServicesTestUtils.checkStringMatch("exception type","IllegalArgumentException",type);
    WebServicesTestUtils.checkStringMatch("exception classname","java.lang.IllegalArgumentException",classname);
  }
 finally {
    rm.stop();
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testInvalidApp() throws JSONException, Exception {
  rm.start();
  MockNM amNodeManager=rm.registerNode("127.0.0.1:1234",2048);
  rm.submitApp(CONTAINER_MB);
  amNodeManager.nodeHeartbeat(true);
  WebResource r=resource();
  try {
    r.path("ws").path("v1").path("cluster").path("apps").path("application_invalid_12").accept(MediaType.APPLICATION_JSON).get(JSONObject.class);
    fail("should have thrown exception on invalid appid");
  }
 catch (  UniformInterfaceException ue) {
    ClientResponse response=ue.getResponse();
    assertEquals(Status.BAD_REQUEST,response.getClientResponseStatus());
    assertEquals(MediaType.APPLICATION_JSON_TYPE,response.getType());
    JSONObject msg=response.getEntity(JSONObject.class);
    JSONObject exception=msg.getJSONObject("RemoteException");
    assertEquals("incorrect number of elements",3,exception.length());
    String message=exception.getString("message");
    String type=exception.getString("exception");
    String classname=exception.getString("javaClassName");
    WebServicesTestUtils.checkStringMatch("exception message","For input string: \"invalid\"",message);
    WebServicesTestUtils.checkStringMatch("exception type","NumberFormatException",type);
    WebServicesTestUtils.checkStringMatch("exception classname","java.lang.NumberFormatException",classname);
  }
 finally {
    rm.stop();
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testAppsQueryStatesInvalid() throws JSONException, Exception {
  rm.start();
  MockNM amNodeManager=rm.registerNode("127.0.0.1:1234",2048);
  rm.submitApp(CONTAINER_MB);
  amNodeManager.nodeHeartbeat(true);
  WebResource r=resource();
  try {
    r.path("ws").path("v1").path("cluster").path("apps").queryParam("states","INVALID_test").accept(MediaType.APPLICATION_JSON).get(JSONObject.class);
    fail("should have thrown exception on invalid state query");
  }
 catch (  UniformInterfaceException ue) {
    ClientResponse response=ue.getResponse();
    assertEquals(Status.BAD_REQUEST,response.getClientResponseStatus());
    assertEquals(MediaType.APPLICATION_JSON_TYPE,response.getType());
    JSONObject msg=response.getEntity(JSONObject.class);
    JSONObject exception=msg.getJSONObject("RemoteException");
    assertEquals("incorrect number of elements",3,exception.length());
    String message=exception.getString("message");
    String type=exception.getString("exception");
    String classname=exception.getString("javaClassName");
    WebServicesTestUtils.checkStringContains("exception message","Invalid application-state INVALID_test",message);
    WebServicesTestUtils.checkStringMatch("exception type","BadRequestException",type);
    WebServicesTestUtils.checkStringMatch("exception classname","org.apache.hadoop.yarn.webapp.BadRequestException",classname);
  }
 finally {
    rm.stop();
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testInvalidAppAttempts() throws JSONException, Exception {
  rm.start();
  MockNM amNodeManager=rm.registerNode("127.0.0.1:1234",2048);
  rm.submitApp(CONTAINER_MB);
  amNodeManager.nodeHeartbeat(true);
  WebResource r=resource();
  try {
    r.path("ws").path("v1").path("cluster").path("apps").path("application_invalid_12").accept(MediaType.APPLICATION_JSON).get(JSONObject.class);
    fail("should have thrown exception on invalid appid");
  }
 catch (  UniformInterfaceException ue) {
    ClientResponse response=ue.getResponse();
    assertEquals(Status.BAD_REQUEST,response.getClientResponseStatus());
    assertEquals(MediaType.APPLICATION_JSON_TYPE,response.getType());
    JSONObject msg=response.getEntity(JSONObject.class);
    JSONObject exception=msg.getJSONObject("RemoteException");
    assertEquals("incorrect number of elements",3,exception.length());
    String message=exception.getString("message");
    String type=exception.getString("exception");
    String classname=exception.getString("javaClassName");
    WebServicesTestUtils.checkStringMatch("exception message","For input string: \"invalid\"",message);
    WebServicesTestUtils.checkStringMatch("exception type","NumberFormatException",type);
    WebServicesTestUtils.checkStringMatch("exception classname","java.lang.NumberFormatException",classname);
  }
 finally {
    rm.stop();
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testNonexistAppAttempts() throws JSONException, Exception {
  rm.start();
  MockNM amNodeManager=rm.registerNode("127.0.0.1:1234",2048);
  rm.submitApp(CONTAINER_MB,"testwordcount","user1");
  amNodeManager.nodeHeartbeat(true);
  WebResource r=resource();
  try {
    r.path("ws").path("v1").path("cluster").path("apps").path("application_00000_0099").accept(MediaType.APPLICATION_JSON).get(JSONObject.class);
    fail("should have thrown exception on invalid appid");
  }
 catch (  UniformInterfaceException ue) {
    ClientResponse response=ue.getResponse();
    assertEquals(Status.NOT_FOUND,response.getClientResponseStatus());
    assertEquals(MediaType.APPLICATION_JSON_TYPE,response.getType());
    JSONObject msg=response.getEntity(JSONObject.class);
    JSONObject exception=msg.getJSONObject("RemoteException");
    assertEquals("incorrect number of elements",3,exception.length());
    String message=exception.getString("message");
    String type=exception.getString("exception");
    String classname=exception.getString("javaClassName");
    WebServicesTestUtils.checkStringMatch("exception message","java.lang.Exception: app with id: application_00000_0099 not found",message);
    WebServicesTestUtils.checkStringMatch("exception type","NotFoundException",type);
    WebServicesTestUtils.checkStringMatch("exception classname","org.apache.hadoop.yarn.webapp.NotFoundException",classname);
  }
 finally {
    rm.stop();
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testAppsQueryStateInvalid() throws JSONException, Exception {
  rm.start();
  MockNM amNodeManager=rm.registerNode("127.0.0.1:1234",2048);
  rm.submitApp(CONTAINER_MB);
  amNodeManager.nodeHeartbeat(true);
  WebResource r=resource();
  try {
    r.path("ws").path("v1").path("cluster").path("apps").queryParam("state","INVALID_test").accept(MediaType.APPLICATION_JSON).get(JSONObject.class);
    fail("should have thrown exception on invalid state query");
  }
 catch (  UniformInterfaceException ue) {
    ClientResponse response=ue.getResponse();
    assertEquals(Status.BAD_REQUEST,response.getClientResponseStatus());
    assertEquals(MediaType.APPLICATION_JSON_TYPE,response.getType());
    JSONObject msg=response.getEntity(JSONObject.class);
    JSONObject exception=msg.getJSONObject("RemoteException");
    assertEquals("incorrect number of elements",3,exception.length());
    String message=exception.getString("message");
    String type=exception.getString("exception");
    String classname=exception.getString("javaClassName");
    WebServicesTestUtils.checkStringContains("exception message","Invalid application-state INVALID_test",message);
    WebServicesTestUtils.checkStringMatch("exception type","BadRequestException",type);
    WebServicesTestUtils.checkStringMatch("exception classname","org.apache.hadoop.yarn.webapp.BadRequestException",classname);
  }
 finally {
    rm.stop();
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.yarn.server.resourcemanager.webapp.TestRMWebServicesDelegationTokenAuthentication </h4><pre class="type-9 type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testCancelledDelegationToken() throws Exception {
  String token=getDelegationToken("client");
  cancelDelegationToken(token);
  ApplicationSubmissionContextInfo app=new ApplicationSubmissionContextInfo();
  String appid="application_123_0";
  app.setApplicationId(appid);
  String requestBody=getMarshalledAppInfo(app);
  URL url=new URL("http://localhost:8088/ws/v1/cluster/apps");
  HttpURLConnection conn=(HttpURLConnection)url.openConnection();
  conn.setRequestProperty(DelegationTokenHeader,token);
  setupConn(conn,"POST",MediaType.APPLICATION_XML,requestBody);
  try {
    conn.getInputStream();
    fail("Authentication should fail with expired delegation tokens");
  }
 catch (  IOException e) {
    assertEquals(Status.FORBIDDEN.getStatusCode(),conn.getResponseCode());
  }
  return;
}

</code></pre>

<br>
<pre class="type-9 type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testDelegationTokenOps() throws Exception {
  String token=getDelegationToken("client");
  String createRequest="{\"renewer\":\"test\"}";
  String renewRequest="{\"token\": \"" + token + "\"}";
  String[] requests={createRequest,renewRequest};
  for (  String requestBody : requests) {
    URL url=new URL("http://localhost:8088/ws/v1/cluster/delegation-token");
    HttpURLConnection conn=(HttpURLConnection)url.openConnection();
    conn.setRequestProperty(DelegationTokenHeader,token);
    setupConn(conn,"POST",MediaType.APPLICATION_JSON,requestBody);
    try {
      conn.getInputStream();
      fail("Creation/Renewing delegation tokens should not be " + "allowed with token auth");
    }
 catch (    IOException e) {
      assertEquals(Status.FORBIDDEN.getStatusCode(),conn.getResponseCode());
    }
  }
  URL url=new URL("http://localhost:8088/ws/v1/cluster/delegation-token");
  HttpURLConnection conn=(HttpURLConnection)url.openConnection();
  conn.setRequestProperty(DelegationTokenHeader,token);
  conn.setRequestProperty(RMWebServices.DELEGATION_TOKEN_HEADER,token);
  setupConn(conn,"DELETE",null,null);
  try {
    conn.getInputStream();
    fail("Cancelling delegation tokens should not be allowed with token auth");
  }
 catch (  IOException e) {
    assertEquals(Status.FORBIDDEN.getStatusCode(),conn.getResponseCode());
  }
  return;
}

</code></pre>

<br>
<pre class="type-9 type-2 type-7 type-10 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testDelegationTokenAuth() throws Exception {
  final String token=getDelegationToken("test");
  ApplicationSubmissionContextInfo app=new ApplicationSubmissionContextInfo();
  String appid="application_123_0";
  app.setApplicationId(appid);
  String requestBody=getMarshalledAppInfo(app);
  URL url=new URL("http://localhost:8088/ws/v1/cluster/apps");
  HttpURLConnection conn=(HttpURLConnection)url.openConnection();
  setupConn(conn,"POST","application/xml",requestBody);
  try {
    conn.getInputStream();
    fail("we should not be here");
  }
 catch (  IOException e) {
    assertEquals(Status.UNAUTHORIZED.getStatusCode(),conn.getResponseCode());
  }
  conn=(HttpURLConnection)url.openConnection();
  conn.setRequestProperty(DelegationTokenHeader,token);
  setupConn(conn,"POST",MediaType.APPLICATION_XML,requestBody);
  conn.getInputStream();
  boolean appExists=rm.getRMContext().getRMApps().containsKey(ConverterUtils.toApplicationId(appid));
  assertTrue(appExists);
  RMApp actualApp=rm.getRMContext().getRMApps().get(ConverterUtils.toApplicationId(appid));
  String owner=actualApp.getUser();
  assertEquals("client",owner);
  return;
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.yarn.server.resourcemanager.webapp.TestRMWebServicesNodes </h4><pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testNonexistNode() throws JSONException, Exception {
  rm.registerNode("h1:1234",5120);
  rm.registerNode("h2:1235",5121);
  WebResource r=resource();
  try {
    r.path("ws").path("v1").path("cluster").path("nodes").path("node_invalid:99").accept(MediaType.APPLICATION_JSON).get(JSONObject.class);
    fail("should have thrown exception on non-existent nodeid");
  }
 catch (  UniformInterfaceException ue) {
    ClientResponse response=ue.getResponse();
    assertEquals(Status.NOT_FOUND,response.getClientResponseStatus());
    assertEquals(MediaType.APPLICATION_JSON_TYPE,response.getType());
    JSONObject msg=response.getEntity(JSONObject.class);
    JSONObject exception=msg.getJSONObject("RemoteException");
    assertEquals("incorrect number of elements",3,exception.length());
    String message=exception.getString("message");
    String type=exception.getString("exception");
    String classname=exception.getString("javaClassName");
    verifyNonexistNodeException(message,type,classname);
  }
 finally {
    rm.stop();
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testNodesQueryStateInvalid() throws JSONException, Exception {
  WebResource r=resource();
  rm.registerNode("h1:1234",5120);
  rm.registerNode("h2:1235",5121);
  try {
    r.path("ws").path("v1").path("cluster").path("nodes").queryParam("states","BOGUSSTATE").accept(MediaType.APPLICATION_JSON).get(JSONObject.class);
    fail("should have thrown exception querying invalid state");
  }
 catch (  UniformInterfaceException ue) {
    ClientResponse response=ue.getResponse();
    assertEquals(Status.BAD_REQUEST,response.getClientResponseStatus());
    assertEquals(MediaType.APPLICATION_JSON_TYPE,response.getType());
    JSONObject msg=response.getEntity(JSONObject.class);
    JSONObject exception=msg.getJSONObject("RemoteException");
    assertEquals("incorrect number of elements",3,exception.length());
    String message=exception.getString("message");
    String type=exception.getString("exception");
    String classname=exception.getString("javaClassName");
    WebServicesTestUtils.checkStringContains("exception message","org.apache.hadoop.yarn.api.records.NodeState.BOGUSSTATE",message);
    WebServicesTestUtils.checkStringMatch("exception type","IllegalArgumentException",type);
    WebServicesTestUtils.checkStringMatch("exception classname","java.lang.IllegalArgumentException",classname);
  }
 finally {
    rm.stop();
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testNonexistNodeXML() throws JSONException, Exception {
  rm.registerNode("h1:1234",5120);
  rm.registerNode("h2:1235",5121);
  WebResource r=resource();
  try {
    r.path("ws").path("v1").path("cluster").path("nodes").path("node_invalid:99").accept(MediaType.APPLICATION_XML).get(JSONObject.class);
    fail("should have thrown exception on non-existent nodeid");
  }
 catch (  UniformInterfaceException ue) {
    ClientResponse response=ue.getResponse();
    assertEquals(Status.NOT_FOUND,response.getClientResponseStatus());
    assertEquals(MediaType.APPLICATION_XML_TYPE,response.getType());
    String msg=response.getEntity(String.class);
    System.out.println(msg);
    DocumentBuilderFactory dbf=DocumentBuilderFactory.newInstance();
    DocumentBuilder db=dbf.newDocumentBuilder();
    InputSource is=new InputSource();
    is.setCharacterStream(new StringReader(msg));
    Document dom=db.parse(is);
    NodeList nodes=dom.getElementsByTagName("RemoteException");
    Element element=(Element)nodes.item(0);
    String message=WebServicesTestUtils.getXmlString(element,"message");
    String type=WebServicesTestUtils.getXmlString(element,"exception");
    String classname=WebServicesTestUtils.getXmlString(element,"javaClassName");
    verifyNonexistNodeException(message,type,classname);
  }
 finally {
    rm.stop();
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testInvalidNode() throws JSONException, Exception {
  rm.registerNode("h1:1234",5120);
  rm.registerNode("h2:1235",5121);
  WebResource r=resource();
  try {
    r.path("ws").path("v1").path("cluster").path("nodes").path("node_invalid_foo").accept(MediaType.APPLICATION_JSON).get(JSONObject.class);
    fail("should have thrown exception on non-existent nodeid");
  }
 catch (  UniformInterfaceException ue) {
    ClientResponse response=ue.getResponse();
    assertEquals(Status.BAD_REQUEST,response.getClientResponseStatus());
    assertEquals(MediaType.APPLICATION_JSON_TYPE,response.getType());
    JSONObject msg=response.getEntity(JSONObject.class);
    JSONObject exception=msg.getJSONObject("RemoteException");
    assertEquals("incorrect number of elements",3,exception.length());
    String message=exception.getString("message");
    String type=exception.getString("exception");
    String classname=exception.getString("javaClassName");
    WebServicesTestUtils.checkStringMatch("exception message","Invalid NodeId \\[node_invalid_foo\\]. Expected host:port",message);
    WebServicesTestUtils.checkStringMatch("exception type","IllegalArgumentException",type);
    WebServicesTestUtils.checkStringMatch("exception classname","java.lang.IllegalArgumentException",classname);
  }
 finally {
    rm.stop();
  }
}

</code></pre>

<br>
<pre class="type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testNonexistNodeDefault() throws JSONException, Exception {
  rm.registerNode("h1:1234",5120);
  rm.registerNode("h2:1235",5121);
  WebResource r=resource();
  try {
    r.path("ws").path("v1").path("cluster").path("nodes").path("node_invalid:99").get(JSONObject.class);
    fail("should have thrown exception on non-existent nodeid");
  }
 catch (  UniformInterfaceException ue) {
    ClientResponse response=ue.getResponse();
    assertEquals(Status.NOT_FOUND,response.getClientResponseStatus());
    assertEquals(MediaType.APPLICATION_JSON_TYPE,response.getType());
    JSONObject msg=response.getEntity(JSONObject.class);
    JSONObject exception=msg.getJSONObject("RemoteException");
    assertEquals("incorrect number of elements",3,exception.length());
    String message=exception.getString("message");
    String type=exception.getString("exception");
    String classname=exception.getString("javaClassName");
    verifyNonexistNodeException(message,type,classname);
  }
 finally {
    rm.stop();
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.yarn.server.resourcemanager.webapp.TestRMWebappAuthentication </h4><pre class="type-9 type-2 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testSimpleAuth() throws Exception {
  rm.start();
  URL url=new URL("http://localhost:8088/cluster");
  HttpURLConnection conn=(HttpURLConnection)url.openConnection();
  try {
    conn.getInputStream();
    assertEquals(Status.OK.getStatusCode(),conn.getResponseCode());
  }
 catch (  Exception e) {
    fail("Fetching url failed");
  }
  if (UserGroupInformation.isSecurityEnabled()) {
    testAnonymousKerberosUser();
  }
 else {
    testAnonymousSimpleUser();
  }
  rm.stop();
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.yarn.server.timeline.TestLeveldbTimelineStore </h4><pre class="type-2 type-7 type-10 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testCheckVersion() throws IOException {
  LeveldbTimelineStore dbStore=(LeveldbTimelineStore)store;
  Version defaultVersion=dbStore.getCurrentVersion();
  Assert.assertEquals(defaultVersion,dbStore.loadVersion());
  Version compatibleVersion=Version.newInstance(defaultVersion.getMajorVersion(),defaultVersion.getMinorVersion() + 2);
  dbStore.storeVersion(compatibleVersion);
  Assert.assertEquals(compatibleVersion,dbStore.loadVersion());
  restartTimelineStore();
  dbStore=(LeveldbTimelineStore)store;
  Assert.assertEquals(defaultVersion,dbStore.loadVersion());
  Version incompatibleVersion=Version.newInstance(defaultVersion.getMajorVersion() + 1,defaultVersion.getMinorVersion());
  dbStore.storeVersion(incompatibleVersion);
  try {
    restartTimelineStore();
    Assert.fail("Incompatible version, should expect fail here.");
  }
 catch (  ServiceStateException e) {
    Assert.assertTrue("Exception message mismatch",e.getMessage().contains("Incompatible version for timeline store"));
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.yarn.server.timeline.security.TestTimelineACLsManager </h4><pre class="type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testCorruptedOwnerInfo() throws Exception {
  Configuration conf=new YarnConfiguration();
  conf.setBoolean(YarnConfiguration.YARN_ACL_ENABLE,true);
  conf.set(YarnConfiguration.YARN_ADMIN_ACL,"owner");
  TimelineACLsManager timelineACLsManager=new TimelineACLsManager(conf);
  TimelineEntity entity=new TimelineEntity();
  try {
    timelineACLsManager.checkAccess(UserGroupInformation.createRemoteUser("owner"),entity);
    Assert.fail("Exception is expected");
  }
 catch (  YarnException e) {
    Assert.assertTrue("It's not the exact expected exception",e.getMessage().contains("is corrupted."));
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.yarn.server.utils.TestLeveldbIterator </h4><pre class="type-9 type-2 type-7 type-10 type-1 type-20 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values related to public fields.">PublicFieldVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects are null
- Verifies values related to public fields.
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testExceptionHandling() throws Exception {
  InvocationHandler rtExcHandler=new InvocationHandler(){
    @Override public Object invoke(    Object proxy,    Method method,    Object[] args) throws Throwable {
      throw new RuntimeException("forced runtime error");
    }
  }
;
  DBIterator dbiter=(DBIterator)Proxy.newProxyInstance(DBIterator.class.getClassLoader(),new Class[]{DBIterator.class},rtExcHandler);
  LeveldbIterator iter=new LeveldbIterator(dbiter);
  for (  CallInfo ci : RTEXC_METHODS) {
    Method method=iter.getClass().getMethod(ci.methodName,ci.argTypes);
    assertNotNull("unable to locate method " + ci.methodName,method);
    try {
      method.invoke(iter,ci.args);
      fail("operation should have thrown");
    }
 catch (    InvocationTargetException ite) {
      Throwable exc=ite.getTargetException();
      assertTrue("Method " + ci.methodName + " threw non-DBException: "+ exc,exc instanceof DBException);
      assertFalse("Method " + ci.methodName + " double-wrapped DBException",exc.getCause() instanceof DBException);
    }
  }
  try {
    iter.close();
    fail("operation shoul have thrown");
  }
 catch (  IOException e) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.yarn.server.webproxy.amfilter.TestAmFilter </h4><pre class="type-2 type-7 type-10 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test AmIpFilter
 */
@Test(timeout=1000) @SuppressWarnings("deprecation") public void testFilter() throws Exception {
  Map<String,String> params=new HashMap<String,String>();
  params.put(AmIpFilter.PROXY_HOST,proxyHost);
  params.put(AmIpFilter.PROXY_URI_BASE,proxyUri);
  FilterConfig config=new DummyFilterConfig(params);
  FilterChain chain=new FilterChain(){
    @Override public void doFilter(    ServletRequest servletRequest,    ServletResponse servletResponse) throws IOException, ServletException {
      doFilterRequest=servletRequest.getClass().getName();
      if (servletRequest instanceof AmIpServletRequestWrapper) {
        servletWrapper=(AmIpServletRequestWrapper)servletRequest;
      }
    }
  }
;
  AmIpFilter testFilter=new AmIpFilter();
  testFilter.init(config);
  HttpServletResponseForTest response=new HttpServletResponseForTest();
  ServletRequest failRequest=Mockito.mock(ServletRequest.class);
  try {
    testFilter.doFilter(failRequest,response,chain);
    fail();
  }
 catch (  ServletException e) {
    assertEquals("This filter only works for HTTP/HTTPS",e.getMessage());
  }
  HttpServletRequest request=Mockito.mock(HttpServletRequest.class);
  Mockito.when(request.getRemoteAddr()).thenReturn("redirect");
  Mockito.when(request.getRequestURI()).thenReturn("/redirect");
  testFilter.doFilter(request,response,chain);
  assertEquals("http://bogus/redirect",response.getRedirect());
  Mockito.when(request.getRemoteAddr()).thenReturn("127.0.0.1");
  testFilter.doFilter(request,response,chain);
  assertTrue(doFilterRequest.contains("javax.servlet.http.HttpServletRequest"));
  Cookie[] cookies=new Cookie[1];
  cookies[0]=new Cookie(WebAppProxyServlet.PROXY_USER_COOKIE_NAME,"user");
  Mockito.when(request.getCookies()).thenReturn(cookies);
  testFilter.doFilter(request,response,chain);
  assertEquals("org.apache.hadoop.yarn.server.webproxy.amfilter.AmIpServletRequestWrapper",doFilterRequest);
  assertEquals("user",servletWrapper.getUserPrincipal().getName());
  assertEquals("user",servletWrapper.getRemoteUser());
  assertFalse(servletWrapper.isUserInRole(""));
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.yarn.sls.TestSLSRunner </h4><pre class="type-13 type-11 type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test @SuppressWarnings("all") public void testSimulatorRunning() throws Exception {
  File tempDir=new File("target",UUID.randomUUID().toString());
  final List<Throwable> exceptionList=Collections.synchronizedList(new ArrayList<Throwable>());
  Thread.setDefaultUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler(){
    @Override public void uncaughtException(    Thread t,    Throwable e){
      exceptionList.add(e);
    }
  }
);
  File slsOutputDir=new File(tempDir.getAbsolutePath() + "/slsoutput/");
  String args[]=new String[]{"-inputrumen","src/main/data/2jobs2min-rumen-jh.json","-output",slsOutputDir.getAbsolutePath()};
  SLSRunner.main(args);
  int count=20;
  while (count >= 0) {
    Thread.sleep(1000);
    if (!exceptionList.isEmpty()) {
      SLSRunner.getRunner().stop();
      Assert.fail("TestSLSRunner catched exception from child thread " + "(TaskRunner.Task): " + exceptionList.get(0).getMessage());
      break;
    }
    count--;
  }
  SLSRunner.getRunner().stop();
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.yarn.util.TestFSDownload </h4><pre class="type-9 type-2 type-7 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=10000) public void testDownloadBadPublic() throws IOException, URISyntaxException, InterruptedException {
  Configuration conf=new Configuration();
  conf.set(CommonConfigurationKeys.FS_PERMISSIONS_UMASK_KEY,"077");
  FileContext files=FileContext.getLocalFSFileContext(conf);
  final Path basedir=files.makeQualified(new Path("target",TestFSDownload.class.getSimpleName()));
  files.mkdir(basedir,null,true);
  conf.setStrings(TestFSDownload.class.getName(),basedir.toString());
  Map<LocalResource,LocalResourceVisibility> rsrcVis=new HashMap<LocalResource,LocalResourceVisibility>();
  Random rand=new Random();
  long sharedSeed=rand.nextLong();
  rand.setSeed(sharedSeed);
  System.out.println("SEED: " + sharedSeed);
  Map<LocalResource,Future<Path>> pending=new HashMap<LocalResource,Future<Path>>();
  ExecutorService exec=Executors.newSingleThreadExecutor();
  LocalDirAllocator dirs=new LocalDirAllocator(TestFSDownload.class.getName());
  int size=512;
  LocalResourceVisibility vis=LocalResourceVisibility.PUBLIC;
  Path path=new Path(basedir,"test-file");
  LocalResource rsrc=createFile(files,path,size,rand,vis);
  rsrcVis.put(rsrc,vis);
  Path destPath=dirs.getLocalPathForWrite(basedir.toString(),size,conf);
  destPath=new Path(destPath,Long.toString(uniqueNumberGenerator.incrementAndGet()));
  FSDownload fsd=new FSDownload(files,UserGroupInformation.getCurrentUser(),conf,destPath,rsrc);
  pending.put(rsrc,exec.submit(fsd));
  exec.shutdown();
  while (!exec.awaitTermination(1000,TimeUnit.MILLISECONDS))   ;
  Assert.assertTrue(pending.get(rsrc).isDone());
  try {
    for (    Map.Entry<LocalResource,Future<Path>> p : pending.entrySet()) {
      p.getValue().get();
      Assert.fail("We localized a file that is not public.");
    }
  }
 catch (  ExecutionException e) {
    Assert.assertTrue(e.getCause() instanceof IOException);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.yarn.util.TestProcfsBasedProcessTree </h4><pre class="type-9 type-13 type-11 type-2 type-7 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions in iterations
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=30000) public void testProcessTree() throws Exception {
  try {
    Assert.assertTrue(ProcfsBasedProcessTree.isAvailable());
  }
 catch (  Exception e) {
    LOG.info(StringUtils.stringifyException(e));
    Assert.assertTrue("ProcfsBaseProcessTree should be available on Linux",false);
    return;
  }
  Random rm=new Random();
  File tempFile=new File(TEST_ROOT_DIR,getClass().getName() + "_shellScript_" + rm.nextInt()+ ".sh");
  tempFile.deleteOnExit();
  shellScript=TEST_ROOT_DIR + File.separator + tempFile.getName();
  tempFile=new File(TEST_ROOT_DIR,getClass().getName() + "_pidFile_" + rm.nextInt()+ ".pid");
  tempFile.deleteOnExit();
  pidFile=TEST_ROOT_DIR + File.separator + tempFile.getName();
  lowestDescendant=TEST_ROOT_DIR + File.separator + "lowestDescendantPidFile";
  try {
    FileWriter fWriter=new FileWriter(shellScript);
    fWriter.write("# rogue task\n" + "sleep 1\n" + "echo hello\n"+ "if [ $1 -ne 0 ]\n"+ "then\n"+ " sh " + shellScript + " $(($1-1))\n"+ "else\n"+ " echo $$ > "+ lowestDescendant+ "\n"+ " while true\n do\n"+ "  sleep 5\n"+ " done\n"+ "fi");
    fWriter.close();
  }
 catch (  IOException ioe) {
    LOG.info("Error: " + ioe);
    return;
  }
  Thread t=new RogueTaskThread();
  t.start();
  String pid=getRogueTaskPID();
  LOG.info("Root process pid: " + pid);
  ProcfsBasedProcessTree p=createProcessTree(pid);
  p.updateProcessTree();
  LOG.info("ProcessTree: " + p.toString());
  File leaf=new File(lowestDescendant);
  while (!leaf.exists()) {
    try {
      Thread.sleep(500);
    }
 catch (    InterruptedException ie) {
      break;
    }
  }
  p.updateProcessTree();
  LOG.info("ProcessTree: " + p.toString());
  String processTreeDump=p.getProcessTreeDump();
  destroyProcessTree(pid);
  boolean isAlive=true;
  for (int tries=100; tries > 0; tries--) {
    if (isSetsidAvailable()) {
      isAlive=isAnyProcessInTreeAlive(p);
    }
 else {
      isAlive=isAlive(pid);
    }
    if (!isAlive) {
      break;
    }
    Thread.sleep(100);
  }
  if (isAlive) {
    fail("ProcessTree shouldn't be alive");
  }
  LOG.info("Process-tree dump follows: \n" + processTreeDump);
  Assert.assertTrue("Process-tree dump doesn't start with a proper header",processTreeDump.startsWith("\t|- PID PPID PGRPID SESSID CMD_NAME " + "USER_MODE_TIME(MILLIS) SYSTEM_TIME(MILLIS) VMEM_USAGE(BYTES) " + "RSSMEM_USAGE(PAGES) FULL_CMD_LINE\n"));
  for (int i=N; i >= 0; i--) {
    String cmdLineDump="\\|- [0-9]+ [0-9]+ [0-9]+ [0-9]+ \\(sh\\)" + " [0-9]+ [0-9]+ [0-9]+ [0-9]+ sh " + shellScript + " "+ i;
    Pattern pat=Pattern.compile(cmdLineDump);
    Matcher mat=pat.matcher(processTreeDump);
    Assert.assertTrue("Process-tree dump doesn't contain the cmdLineDump of " + i + "th process!",mat.find());
  }
  try {
    t.join(2000);
    LOG.info("RogueTaskThread successfully joined.");
  }
 catch (  InterruptedException ie) {
    LOG.info("Interrupted while joining RogueTaskThread.");
  }
  p.updateProcessTree();
  Assert.assertFalse("ProcessTree must have been gone",isAlive(pid));
  Assert.assertTrue("Cumulative vmem for the gone-process is " + p.getCumulativeVmem() + " . It should be zero.",p.getCumulativeVmem() == 0);
  Assert.assertTrue(p.toString().equals("[ ]"));
}

</code></pre>

<br>
<script>$(document).ready(function() {
  $('pre code').each(function(i, block) {
    hljs.highlightBlock(block);
  });
});</script>
