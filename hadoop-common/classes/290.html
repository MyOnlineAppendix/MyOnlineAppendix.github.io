<h3 style="margin:0px">Class: org.apache.hadoop.hdfs.TestFileCreation (22 methods) </h3><br><pre style="padding:0"><code class="html"><div id="tags"><button id="7"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('7')" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls"><kbd id="tag-7"class="label-info"style="display: inline-block;font-size:7pt" >InternalCallVerifier&nbsp;(8)</kbd></button>&nbsp;<button id="10"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('10')" data-toggle="tooltip" title="Verifies boolean conditions"><kbd id="tag-10"class="label-info"style="display: inline-block;font-size:7pt" >BooleanVerifier&nbsp;(7)</kbd></button>&nbsp;<button id="6"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('6')" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value "><kbd id="tag-6"class="label-info"style="display: inline-block;font-size:7pt" >EqualityVerifier&nbsp;(7)</kbd></button>&nbsp;<button id="5"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('5')" data-toggle="tooltip" title="Executes methods or other tests from the same test unit"><kbd id="tag-5"class="label-info"style="display: inline-block;font-size:7pt" >ExecutionTester&nbsp;(7)</kbd></button>&nbsp;<button id="2"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('2')" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure"><kbd id="tag-2"class="label-info"style="display: inline-block;font-size:7pt" >UtilityVerifier&nbsp;(4)</kbd></button>&nbsp;<button id="3"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('3')" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes"><kbd id="tag-3"class="label-info"style="display: inline-block;font-size:7pt" >HybridVerifier&nbsp;(3)</kbd></button>&nbsp;<button id="20"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('20')" data-toggle="tooltip" title="Verifies values related to public fields."><kbd id="tag-20"class="label-info"style="display: inline-block;font-size:7pt" >PublicFieldVerifier&nbsp;(3)</kbd></button>&nbsp;<button id="9"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('9')" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) "><kbd id="tag-9"class="label-info"style="display: inline-block;font-size:7pt" >APIUtilityVerifier&nbsp;(3)</kbd></button>&nbsp;<button id="13"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('13')" data-toggle="tooltip" title="Verifies assertions in iterations"><kbd id="tag-13"class="label-info"style="display: inline-block;font-size:7pt" >IterativeVerifier&nbsp;(2)</kbd></button>&nbsp;<button id="15"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('15')" data-toggle="tooltip" title="Sets implicit assumptions "><kbd id="tag-15"class="label-info"style="display: inline-block;font-size:7pt" >AssumptionSetter&nbsp;(2)</kbd></button>&nbsp;<button id="18"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('18')" data-toggle="tooltip" title="Invokes logging operations"><kbd id="tag-18"class="label-info"style="display: inline-block;font-size:7pt" >Logger&nbsp;(1)</kbd></button>&nbsp;<button id="11"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('11')" data-toggle="tooltip" title="Verifies assertions inside branch conditions"><kbd id="tag-11"class="label-info"style="display: inline-block;font-size:7pt" >BranchVerifier&nbsp;(1)</kbd></button>&nbsp;</div></code></pre><center><button onclick="showBlocks()" style="margin:6px">Update filter <span class="glyphicon glyphicon-refresh" aria-hidden="true"></span> </button></center><br>
<pre class="type-7 type-10 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
"></span><br>
/** 
 * Test that file data does not become corrupted even in the face of errors.
 */
@Test public void testFileCreationError1() throws IOException {
  Configuration conf=new HdfsConfiguration();
  conf.setInt(DFS_NAMENODE_HEARTBEAT_RECHECK_INTERVAL_KEY,1000);
  conf.setInt(DFS_HEARTBEAT_INTERVAL_KEY,1);
  if (simulatedStorage) {
    SimulatedFSDataset.setFactory(conf);
  }
  MiniDFSCluster cluster=new MiniDFSCluster.Builder(conf).build();
  FileSystem fs=cluster.getFileSystem();
  cluster.waitActive();
  InetSocketAddress addr=new InetSocketAddress("localhost",cluster.getNameNodePort());
  DFSClient client=new DFSClient(addr,conf);
  try {
    Path file1=new Path("/filestatus.dat");
    FSDataOutputStream stm=createFile(fs,file1,1);
    assertTrue(file1 + " should be a file",fs.getFileStatus(file1).isFile());
    System.out.println("Path : \"" + file1 + "\"");
    cluster.shutdownDataNodes();
    while (true) {
      DatanodeInfo[] info=client.datanodeReport(HdfsConstants.DatanodeReportType.LIVE);
      if (info.length == 0) {
        break;
      }
      System.out.println("testFileCreationError1: waiting for datanode " + " to die.");
      try {
        Thread.sleep(1000);
      }
 catch (      InterruptedException e) {
      }
    }
    byte[] buffer=AppendTestUtil.randomBytes(seed,1);
    try {
      stm.write(buffer);
      stm.close();
    }
 catch (    Exception e) {
      System.out.println("Encountered expected exception");
    }
    LocatedBlocks locations=client.getNamenode().getBlockLocations(file1.toString(),0,Long.MAX_VALUE);
    System.out.println("locations = " + locations.locatedBlockCount());
    assertTrue("Error blocks were not cleaned up",locations.locatedBlockCount() == 0);
  }
  finally {
    cluster.shutdown();
    client.close();
  }
}

</code></pre>

<pre class="type-15 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Sets implicit assumptions ">AssumptionSetter</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Sets implicit assumptions 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Same test but the client should use DN hostnames 
 */
@Test public void testFileCreationUsingHostname() throws IOException {
  assumeTrue(System.getProperty("os.name").startsWith("Linux"));
  checkFileCreation(null,true);
}

</code></pre>

<pre class="type-13 type-7 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
"></span><br>
/** 
 * Test creating two files at the same time. 
 */
@Test public void testConcurrentFileCreation() throws IOException {
  Configuration conf=new HdfsConfiguration();
  MiniDFSCluster cluster=new MiniDFSCluster.Builder(conf).build();
  try {
    FileSystem fs=cluster.getFileSystem();
    Path[] p={new Path("/foo"),new Path("/bar")};
    FSDataOutputStream[] out={fs.create(p[0]),fs.create(p[1])};
    int i=0;
    for (; i < 100; i++) {
      out[0].write(i);
      out[1].write(i);
    }
    out[0].close();
    for (; i < 200; i++) {
      out[1].write(i);
    }
    out[1].close();
    FSDataInputStream[] in={fs.open(p[0]),fs.open(p[1])};
    for (i=0; i < 100; i++) {
      assertEquals(i,in[0].read());
    }
    for (i=0; i < 200; i++) {
      assertEquals(i,in[1].read());
    }
  }
  finally {
    if (cluster != null) {
      cluster.shutdown();
    }
  }
}

</code></pre>

<pre class="type-9 type-11 type-7 type-10 type-6 type-20 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values related to public fields.">PublicFieldVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions inside branch conditions
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Verifies values related to public fields.
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Create a file, write something, hflush but not close.
 * Then change lease period and wait for lease recovery.
 * Finally, read the block directly from each Datanode and verify the content.
 */
@Test public void testLeaseExpireHardLimit() throws Exception {
  System.out.println("testLeaseExpireHardLimit start");
  final long leasePeriod=1000;
  final int DATANODE_NUM=3;
  Configuration conf=new HdfsConfiguration();
  conf.setInt(DFS_NAMENODE_HEARTBEAT_RECHECK_INTERVAL_KEY,1000);
  conf.setInt(DFS_HEARTBEAT_INTERVAL_KEY,1);
  MiniDFSCluster cluster=new MiniDFSCluster.Builder(conf).numDataNodes(DATANODE_NUM).build();
  DistributedFileSystem dfs=null;
  try {
    cluster.waitActive();
    dfs=cluster.getFileSystem();
    final String f=DIR + "foo";
    final Path fpath=new Path(f);
    HdfsDataOutputStream out=create(dfs,fpath,DATANODE_NUM);
    out.write("something".getBytes());
    out.hflush();
    int actualRepl=out.getCurrentBlockReplication();
    assertTrue(f + " should be replicated to " + DATANODE_NUM+ " datanodes.",actualRepl == DATANODE_NUM);
    cluster.setLeasePeriod(leasePeriod,leasePeriod);
    try {
      Thread.sleep(5 * leasePeriod);
    }
 catch (    InterruptedException e) {
    }
    LocatedBlocks locations=dfs.dfs.getNamenode().getBlockLocations(f,0,Long.MAX_VALUE);
    assertEquals(1,locations.locatedBlockCount());
    LocatedBlock locatedblock=locations.getLocatedBlocks().get(0);
    int successcount=0;
    for (    DatanodeInfo datanodeinfo : locatedblock.getLocations()) {
      DataNode datanode=cluster.getDataNode(datanodeinfo.getIpcPort());
      ExtendedBlock blk=locatedblock.getBlock();
      Block b=DataNodeTestUtils.getFSDataset(datanode).getStoredBlock(blk.getBlockPoolId(),blk.getBlockId());
      final File blockfile=DataNodeTestUtils.getFile(datanode,blk.getBlockPoolId(),b.getBlockId());
      System.out.println("blockfile=" + blockfile);
      if (blockfile != null) {
        BufferedReader in=new BufferedReader(new FileReader(blockfile));
        assertEquals("something",in.readLine());
        in.close();
        successcount++;
      }
    }
    System.out.println("successcount=" + successcount);
    assertTrue(successcount > 0);
  }
  finally {
    IOUtils.closeStream(dfs);
    cluster.shutdown();
  }
  System.out.println("testLeaseExpireHardLimit successful");
}

</code></pre>

<pre class="type-10 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies boolean conditions
"></span><br>
/** 
 * Test that all open files are closed when client dies abnormally.
 */
@Test public void testDFSClientDeath() throws IOException, InterruptedException {
  Configuration conf=new HdfsConfiguration();
  System.out.println("Testing adbornal client death.");
  if (simulatedStorage) {
    SimulatedFSDataset.setFactory(conf);
  }
  MiniDFSCluster cluster=new MiniDFSCluster.Builder(conf).build();
  FileSystem fs=cluster.getFileSystem();
  DistributedFileSystem dfs=(DistributedFileSystem)fs;
  DFSClient dfsclient=dfs.dfs;
  try {
    Path file1=new Path("/clienttest.dat");
    FSDataOutputStream stm=createFile(fs,file1,1);
    System.out.println("Created file clienttest.dat");
    writeFile(stm);
    dfsclient.close();
    assertTrue(file1 + " does not exist.",AppendTestUtil.createHdfsWithDifferentUsername(conf).exists(file1));
  }
  finally {
    cluster.shutdown();
  }
}

</code></pre>

<pre class="type-9 type-7 type-10 type-6 type-20 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values related to public fields.">PublicFieldVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Verifies values related to public fields.
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test that file leases are persisted across namenode restarts.
 */
@Test public void testFileCreationNamenodeRestart() throws IOException {
  Configuration conf=new HdfsConfiguration();
  final int MAX_IDLE_TIME=2000;
  conf.setInt("ipc.client.connection.maxidletime",MAX_IDLE_TIME);
  conf.setInt(DFS_NAMENODE_HEARTBEAT_RECHECK_INTERVAL_KEY,1000);
  conf.setInt(DFS_HEARTBEAT_INTERVAL_KEY,1);
  if (simulatedStorage) {
    SimulatedFSDataset.setFactory(conf);
  }
  MiniDFSCluster cluster=new MiniDFSCluster.Builder(conf).build();
  DistributedFileSystem fs=null;
  try {
    cluster.waitActive();
    fs=cluster.getFileSystem();
    final int nnport=cluster.getNameNodePort();
    Path file1=new Path("/filestatus.dat");
    HdfsDataOutputStream stm=create(fs,file1,1);
    System.out.println("testFileCreationNamenodeRestart: " + "Created file " + file1);
    assertEquals(file1 + " should be replicated to 1 datanode.",1,stm.getCurrentBlockReplication());
    writeFile(stm,numBlocks * blockSize);
    stm.hflush();
    assertEquals(file1 + " should still be replicated to 1 datanode.",1,stm.getCurrentBlockReplication());
    Path fileRenamed=new Path("/filestatusRenamed.dat");
    fs.rename(file1,fileRenamed);
    System.out.println("testFileCreationNamenodeRestart: " + "Renamed file " + file1 + " to "+ fileRenamed);
    file1=fileRenamed;
    Path file2=new Path("/filestatus2.dat");
    FSDataOutputStream stm2=createFile(fs,file2,1);
    System.out.println("testFileCreationNamenodeRestart: " + "Created file " + file2);
    Path file3=new Path("/user/home/fullpath.dat");
    FSDataOutputStream stm3=createFile(fs,file3,1);
    System.out.println("testFileCreationNamenodeRestart: " + "Created file " + file3);
    Path file4=new Path("/user/home/fullpath4.dat");
    FSDataOutputStream stm4=createFile(fs,file4,1);
    System.out.println("testFileCreationNamenodeRestart: " + "Created file " + file4);
    fs.mkdirs(new Path("/bin"));
    fs.rename(new Path("/user/home"),new Path("/bin"));
    Path file3new=new Path("/bin/home/fullpath.dat");
    System.out.println("testFileCreationNamenodeRestart: " + "Renamed file " + file3 + " to "+ file3new);
    Path file4new=new Path("/bin/home/fullpath4.dat");
    System.out.println("testFileCreationNamenodeRestart: " + "Renamed file " + file4 + " to "+ file4new);
    cluster.shutdown();
    try {
      Thread.sleep(2 * MAX_IDLE_TIME);
    }
 catch (    InterruptedException e) {
    }
    cluster=new MiniDFSCluster.Builder(conf).nameNodePort(nnport).format(false).build();
    cluster.waitActive();
    cluster.shutdown();
    try {
      Thread.sleep(5000);
    }
 catch (    InterruptedException e) {
    }
    cluster=new MiniDFSCluster.Builder(conf).nameNodePort(nnport).format(false).build();
    cluster.waitActive();
    fs=cluster.getFileSystem();
    DFSOutputStream dfstream=(DFSOutputStream)(stm.getWrappedStream());
    dfstream.setTestFilename(file1.toString());
    dfstream=(DFSOutputStream)(stm3.getWrappedStream());
    dfstream.setTestFilename(file3new.toString());
    dfstream=(DFSOutputStream)(stm4.getWrappedStream());
    dfstream.setTestFilename(file4new.toString());
    byte[] buffer=AppendTestUtil.randomBytes(seed,1);
    stm.write(buffer);
    stm.close();
    stm2.write(buffer);
    stm2.close();
    stm3.close();
    stm4.close();
    DFSClient client=fs.dfs;
    LocatedBlocks locations=client.getNamenode().getBlockLocations(file1.toString(),0,Long.MAX_VALUE);
    System.out.println("locations = " + locations.locatedBlockCount());
    assertTrue("Error blocks were not cleaned up for file " + file1,locations.locatedBlockCount() == 3);
    locations=client.getNamenode().getBlockLocations(file2.toString(),0,Long.MAX_VALUE);
    System.out.println("locations = " + locations.locatedBlockCount());
    assertTrue("Error blocks were not cleaned up for file " + file2,locations.locatedBlockCount() == 1);
  }
  finally {
    IOUtils.closeStream(fs);
    cluster.shutdown();
  }
}

</code></pre>

<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * test addBlock(..) when replication<min and excludeNodes==null. 
 */
@Test public void testFileCreationError3() throws IOException {
  System.out.println("testFileCreationError3 start");
  Configuration conf=new HdfsConfiguration();
  MiniDFSCluster cluster=new MiniDFSCluster.Builder(conf).numDataNodes(0).build();
  DistributedFileSystem dfs=null;
  try {
    cluster.waitActive();
    dfs=cluster.getFileSystem();
    DFSClient client=dfs.dfs;
    final Path f=new Path("/foo.txt");
    createFile(dfs,f,3);
    try {
      cluster.getNameNodeRpc().addBlock(f.toString(),client.clientName,null,null,INodeId.GRANDFATHER_INODE_ID,null);
      fail();
    }
 catch (    IOException ioe) {
      FileSystem.LOG.info("GOOD!",ioe);
    }
    System.out.println("testFileCreationError3 successful");
  }
  finally {
    IOUtils.closeStream(dfs);
    cluster.shutdown();
  }
}

</code></pre>

<pre class="type-7 type-6 type-20 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values related to public fields.">PublicFieldVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Verifies values related to public fields.
"></span><br>
/** 
 * Test that the filesystem removes the last block from a file if its
 * lease expires.
 */
@Test public void testFileCreationError2() throws IOException {
  long leasePeriod=1000;
  System.out.println("testFileCreationError2 start");
  Configuration conf=new HdfsConfiguration();
  conf.setInt(DFS_NAMENODE_HEARTBEAT_RECHECK_INTERVAL_KEY,1000);
  conf.setInt(DFS_HEARTBEAT_INTERVAL_KEY,1);
  if (simulatedStorage) {
    SimulatedFSDataset.setFactory(conf);
  }
  MiniDFSCluster cluster=new MiniDFSCluster.Builder(conf).build();
  DistributedFileSystem dfs=null;
  try {
    cluster.waitActive();
    dfs=cluster.getFileSystem();
    DFSClient client=dfs.dfs;
    Path file1=new Path("/filestatus.dat");
    createFile(dfs,file1,1);
    System.out.println("testFileCreationError2: " + "Created file filestatus.dat with one replicas.");
    LocatedBlocks locations=client.getNamenode().getBlockLocations(file1.toString(),0,Long.MAX_VALUE);
    System.out.println("testFileCreationError2: " + "The file has " + locations.locatedBlockCount() + " blocks.");
    LocatedBlock location=client.getNamenode().addBlock(file1.toString(),client.clientName,null,null,INodeId.GRANDFATHER_INODE_ID,null);
    System.out.println("testFileCreationError2: " + "Added block " + location.getBlock());
    locations=client.getNamenode().getBlockLocations(file1.toString(),0,Long.MAX_VALUE);
    int count=locations.locatedBlockCount();
    System.out.println("testFileCreationError2: " + "The file now has " + count + " blocks.");
    cluster.setLeasePeriod(leasePeriod,leasePeriod);
    try {
      Thread.sleep(5 * leasePeriod);
    }
 catch (    InterruptedException e) {
    }
    locations=client.getNamenode().getBlockLocations(file1.toString(),0,Long.MAX_VALUE);
    System.out.println("testFileCreationError2: " + "locations = " + locations.locatedBlockCount());
    assertEquals(0,locations.locatedBlockCount());
    System.out.println("testFileCreationError2 successful");
  }
  finally {
    IOUtils.closeStream(dfs);
    cluster.shutdown();
  }
}

</code></pre>

<pre class="type-18 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Invokes logging operations">Logger</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Invokes logging operations
- Executes methods or other tests from the same test unit
"></span><br>
@Test public void testFsClose() throws Exception {
  System.out.println("test file system close start");
  final int DATANODE_NUM=3;
  Configuration conf=new HdfsConfiguration();
  MiniDFSCluster cluster=new MiniDFSCluster.Builder(conf).numDataNodes(DATANODE_NUM).build();
  DistributedFileSystem dfs=null;
  try {
    cluster.waitActive();
    dfs=cluster.getFileSystem();
    final String f=DIR + "foofs";
    final Path fpath=new Path(f);
    FSDataOutputStream out=TestFileCreation.createFile(dfs,fpath,DATANODE_NUM);
    out.write("something".getBytes());
    dfs.close();
  }
  finally {
    System.out.println("testFsClose successful");
    cluster.shutdown();
  }
}

</code></pre>

<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * Test complete(..) - verifies that the fileId in the request
 * matches that of the Inode.
 * This test checks that FileNotFoundException exception is thrown in case
 * the fileId does not match.
 */
@Test public void testFileIdMismatch() throws IOException {
  Configuration conf=new HdfsConfiguration();
  MiniDFSCluster cluster=new MiniDFSCluster.Builder(conf).numDataNodes(3).build();
  DistributedFileSystem dfs=null;
  try {
    cluster.waitActive();
    dfs=cluster.getFileSystem();
    DFSClient client=dfs.dfs;
    final Path f=new Path("/testFileIdMismatch.txt");
    createFile(dfs,f,3);
    long someOtherFileId=-1;
    try {
      cluster.getNameNodeRpc().complete(f.toString(),client.clientName,null,someOtherFileId);
      fail();
    }
 catch (    LeaseExpiredException e) {
      FileSystem.LOG.info("Caught Expected LeaseExpiredException: ",e);
    }
  }
  finally {
    IOUtils.closeStream(dfs);
    cluster.shutdown();
  }
}

</code></pre>

<pre class="type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test public void testFileCreation() throws IOException {
  checkFileCreation(null,false);
}

</code></pre>

<pre class="type-9 type-7 type-10 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
"></span><br>
/** 
 * Test deleteOnExit
 */
@Test public void testDeleteOnExit() throws IOException {
  Configuration conf=new HdfsConfiguration();
  if (simulatedStorage) {
    SimulatedFSDataset.setFactory(conf);
  }
  MiniDFSCluster cluster=new MiniDFSCluster.Builder(conf).build();
  FileSystem fs=cluster.getFileSystem();
  FileSystem localfs=FileSystem.getLocal(conf);
  try {
    Path file1=new Path("filestatus.dat");
    Path file2=new Path("filestatus2.dat");
    Path file3=new Path("filestatus3.dat");
    FSDataOutputStream stm1=createFile(fs,file1,1);
    FSDataOutputStream stm2=createFile(fs,file2,1);
    FSDataOutputStream stm3=createFile(localfs,file3,1);
    System.out.println("DeleteOnExit: Created files.");
    writeFile(stm1);
    writeFile(stm3);
    stm1.close();
    stm2.close();
    stm3.close();
    fs.deleteOnExit(file1);
    fs.deleteOnExit(file2);
    localfs.deleteOnExit(file3);
    fs.close();
    localfs.close();
    fs=null;
    localfs=null;
    fs=cluster.getFileSystem();
    localfs=FileSystem.getLocal(conf);
    assertTrue(file1 + " still exists inspite of deletOnExit set.",!fs.exists(file1));
    assertTrue(file2 + " still exists inspite of deletOnExit set.",!fs.exists(file2));
    assertTrue(file3 + " still exists inspite of deletOnExit set.",!localfs.exists(file3));
    System.out.println("DeleteOnExit successful.");
  }
  finally {
    IOUtils.closeStream(fs);
    IOUtils.closeStream(localfs);
    cluster.shutdown();
  }
}

</code></pre>

<pre class="type-2 type-15 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Sets implicit assumptions ">AssumptionSetter</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Sets implicit assumptions 
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Same test but the client should bind to a local interface 
 */
@Test public void testFileCreationSetLocalInterface() throws IOException {
  assumeTrue(System.getProperty("os.name").startsWith("Linux"));
  checkFileCreation("lo",false);
  try {
    checkFileCreation("bogus-interface",false);
    fail("Able to specify a bogus interface");
  }
 catch (  UnknownHostException e) {
    assertEquals("No such interface bogus-interface",e.getMessage());
  }
}

</code></pre>

<pre class="type-10 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies boolean conditions
"></span><br>
/** 
 * Test file creation using createNonRecursive().
 */
@Test public void testFileCreationNonRecursive() throws IOException {
  Configuration conf=new HdfsConfiguration();
  if (simulatedStorage) {
    SimulatedFSDataset.setFactory(conf);
  }
  MiniDFSCluster cluster=new MiniDFSCluster.Builder(conf).build();
  FileSystem fs=cluster.getFileSystem();
  final Path path=new Path("/" + Time.now() + "-testFileCreationNonRecursive");
  FSDataOutputStream out=null;
  try {
    IOException expectedException=null;
    final String nonExistDir="/non-exist-" + Time.now();
    fs.delete(new Path(nonExistDir),true);
    EnumSet<CreateFlag> createFlag=EnumSet.of(CreateFlag.CREATE);
    out=createNonRecursive(fs,path,1,createFlag);
    out.close();
    try {
      createNonRecursive(fs,new Path(path,"Create"),1,createFlag);
    }
 catch (    IOException e) {
      expectedException=e;
    }
    assertTrue("Create a file when parent directory exists as a file" + " should throw ParentNotDirectoryException ",expectedException != null && expectedException instanceof ParentNotDirectoryException);
    fs.delete(path,true);
    final Path path2=new Path(nonExistDir + "/testCreateNonRecursive");
    expectedException=null;
    try {
      createNonRecursive(fs,path2,1,createFlag);
    }
 catch (    IOException e) {
      expectedException=e;
    }
    assertTrue("Create a file in a non-exist dir using" + " createNonRecursive() should throw FileNotFoundException ",expectedException != null && expectedException instanceof FileNotFoundException);
    EnumSet<CreateFlag> overwriteFlag=EnumSet.of(CreateFlag.CREATE,CreateFlag.OVERWRITE);
    out=createNonRecursive(fs,path,1,overwriteFlag);
    out.close();
    expectedException=null;
    try {
      createNonRecursive(fs,new Path(path,"Overwrite"),1,overwriteFlag);
    }
 catch (    IOException e) {
      expectedException=e;
    }
    assertTrue("Overwrite a file when parent directory exists as a file" + " should throw ParentNotDirectoryException ",expectedException != null && expectedException instanceof ParentNotDirectoryException);
    fs.delete(path,true);
    final Path path3=new Path(nonExistDir + "/testOverwriteNonRecursive");
    expectedException=null;
    try {
      createNonRecursive(fs,path3,1,overwriteFlag);
    }
 catch (    IOException e) {
      expectedException=e;
    }
    assertTrue("Overwrite a file in a non-exist dir using" + " createNonRecursive() should throw FileNotFoundException ",expectedException != null && expectedException instanceof FileNotFoundException);
  }
  finally {
    fs.close();
    cluster.shutdown();
  }
}

</code></pre>

<pre class="type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Another regression test for HDFS-3626. This one creates files using
 * a Path instantiated from a string object.
 */
@Test public void testCreateNonCanonicalPathAndRestartFromString() throws Exception {
  doCreateTest(CreationMethod.PATH_FROM_STRING);
}

</code></pre>

<pre class="type-13 type-7 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
"></span><br>
/** 
 * Test creating a file whose data gets sync when closed
 */
@Test public void testFileCreationSyncOnClose() throws IOException {
  Configuration conf=new HdfsConfiguration();
  conf.setBoolean(DFS_DATANODE_SYNCONCLOSE_KEY,true);
  MiniDFSCluster cluster=new MiniDFSCluster.Builder(conf).build();
  try {
    FileSystem fs=cluster.getFileSystem();
    Path[] p={new Path("/foo"),new Path("/bar")};
    FSDataOutputStream[] out={fs.create(p[0]),fs.create(p[1])};
    int i=0;
    for (; i < 100; i++) {
      out[0].write(i);
      out[1].write(i);
    }
    out[0].close();
    for (; i < 200; i++) {
      out[1].write(i);
    }
    out[1].close();
    FSDataInputStream[] in={fs.open(p[0]),fs.open(p[1])};
    for (i=0; i < 100; i++) {
      assertEquals(i,in[0].read());
    }
    for (i=0; i < 200; i++) {
      assertEquals(i,in[1].read());
    }
  }
  finally {
    if (cluster != null) {
      cluster.shutdown();
    }
  }
}

</code></pre>

<pre class="type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Test that file data becomes available before file is closed.
 */
@Test public void testFileCreationSimulated() throws IOException {
  simulatedStorage=true;
  testFileCreation();
  simulatedStorage=false;
}

</code></pre>

<pre class="type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Regression test for HDFS-3626. Creates a file using a non-canonical path
 * (i.e. with extra slashes between components) and makes sure that the NN
 * can properly restart.
 * This test RPCs directly to the NN, to ensure that even an old client
 * which passes an invalid path won't cause corrupt edits.
 */
@Test public void testCreateNonCanonicalPathAndRestartRpc() throws Exception {
  doCreateTest(CreationMethod.DIRECT_NN_RPC);
}

</code></pre>

<pre class="type-7 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
"></span><br>
/** 
 * Test that server default values can be retrieved on the client side
 */
@Test public void testServerDefaults() throws IOException {
  Configuration conf=new HdfsConfiguration();
  conf.setLong(DFS_BLOCK_SIZE_KEY,DFS_BLOCK_SIZE_DEFAULT);
  conf.setInt(DFS_BYTES_PER_CHECKSUM_KEY,DFS_BYTES_PER_CHECKSUM_DEFAULT);
  conf.setInt(DFS_CLIENT_WRITE_PACKET_SIZE_KEY,DFS_CLIENT_WRITE_PACKET_SIZE_DEFAULT);
  conf.setInt(DFS_REPLICATION_KEY,DFS_REPLICATION_DEFAULT + 1);
  conf.setInt(IO_FILE_BUFFER_SIZE_KEY,IO_FILE_BUFFER_SIZE_DEFAULT);
  MiniDFSCluster cluster=new MiniDFSCluster.Builder(conf).numDataNodes(DFSConfigKeys.DFS_REPLICATION_DEFAULT + 1).build();
  cluster.waitActive();
  FileSystem fs=cluster.getFileSystem();
  try {
    FsServerDefaults serverDefaults=fs.getServerDefaults();
    assertEquals(DFS_BLOCK_SIZE_DEFAULT,serverDefaults.getBlockSize());
    assertEquals(DFS_BYTES_PER_CHECKSUM_DEFAULT,serverDefaults.getBytesPerChecksum());
    assertEquals(DFS_CLIENT_WRITE_PACKET_SIZE_DEFAULT,serverDefaults.getWritePacketSize());
    assertEquals(DFS_REPLICATION_DEFAULT + 1,serverDefaults.getReplication());
    assertEquals(IO_FILE_BUFFER_SIZE_DEFAULT,serverDefaults.getFileBufferSize());
  }
  finally {
    fs.close();
    cluster.shutdown();
  }
}

</code></pre>

<pre class="type-10 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies boolean conditions
"></span><br>
@Test public void testFsCloseAfterClusterShutdown() throws IOException {
  System.out.println("test testFsCloseAfterClusterShutdown start");
  final int DATANODE_NUM=3;
  Configuration conf=new HdfsConfiguration();
  conf.setInt(DFS_NAMENODE_REPLICATION_MIN_KEY,3);
  conf.setBoolean("ipc.client.ping",false);
  conf.setInt("ipc.ping.interval",10000);
  MiniDFSCluster cluster=new MiniDFSCluster.Builder(conf).numDataNodes(DATANODE_NUM).build();
  DistributedFileSystem dfs=null;
  try {
    cluster.waitActive();
    dfs=cluster.getFileSystem();
    final String f=DIR + "testFsCloseAfterClusterShutdown";
    final Path fpath=new Path(f);
    FSDataOutputStream out=TestFileCreation.createFile(dfs,fpath,DATANODE_NUM);
    out.write("something_test".getBytes());
    out.hflush();
    cluster.stopDataNode(2);
    boolean hasException=false;
    try {
      out.close();
      System.out.println("testFsCloseAfterClusterShutdown: Error here");
    }
 catch (    IOException e) {
      hasException=true;
    }
    assertTrue("Failed to close file after cluster shutdown",hasException);
  }
  finally {
    System.out.println("testFsCloseAfterClusterShutdown successful");
    if (cluster != null) {
      cluster.shutdown();
    }
  }
}

</code></pre>

<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
/** 
 * Test that a file which is open for write is overwritten by another
 * client. Regression test for HDFS-3755.
 */
@Test public void testOverwriteOpenForWrite() throws Exception {
  Configuration conf=new HdfsConfiguration();
  SimulatedFSDataset.setFactory(conf);
  conf.setBoolean(DFSConfigKeys.DFS_PERMISSIONS_ENABLED_KEY,false);
  final MiniDFSCluster cluster=new MiniDFSCluster.Builder(conf).build();
  FileSystem fs=cluster.getFileSystem();
  UserGroupInformation otherUgi=UserGroupInformation.createUserForTesting("testuser",new String[]{"testgroup"});
  FileSystem fs2=otherUgi.doAs(new PrivilegedExceptionAction<FileSystem>(){
    @Override public FileSystem run() throws Exception {
      return FileSystem.get(cluster.getConfiguration(0));
    }
  }
);
  String metricsName=RPC_DETAILED_METRICS + cluster.getNameNodePort();
  try {
    Path p=new Path("/testfile");
    FSDataOutputStream stm1=fs.create(p);
    stm1.write(1);
    assertCounter("CreateNumOps",1L,getMetrics(metricsName));
    try {
      fs2.create(p,false);
      fail("Did not throw!");
    }
 catch (    IOException abce) {
      GenericTestUtils.assertExceptionContains("already being created by",abce);
    }
    assertCounter("AlreadyBeingCreatedExceptionNumOps",6L,getMetrics(metricsName));
    FSDataOutputStream stm2=fs2.create(p,true);
    stm2.write(2);
    stm2.close();
    try {
      stm1.close();
      fail("Should have exception closing stm1 since it was deleted");
    }
 catch (    IOException ioe) {
      GenericTestUtils.assertExceptionContains("No lease on /testfile",ioe);
      GenericTestUtils.assertExceptionContains("File does not exist.",ioe);
    }
  }
  finally {
    IOUtils.closeStream(fs);
    IOUtils.closeStream(fs2);
    cluster.shutdown();
  }
}

</code></pre>

<pre class="type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Another regression test for HDFS-3626. This one creates files using
 * a Path instantiated from a URI object.
 */
@Test public void testCreateNonCanonicalPathAndRestartFromUri() throws Exception {
  doCreateTest(CreationMethod.PATH_FROM_URI);
}

</code></pre>

<script>$(document).ready(function() {
  $('pre code').each(function(i, block) {
    hljs.highlightBlock(block);
  });
});</script>
