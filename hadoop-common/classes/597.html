<h3 style="margin:0px">Class: org.apache.hadoop.hdfs.server.namenode.snapshot.TestSnapshotDeletion (16 methods) </h3><br><pre style="padding:0"><code class="html"><div id="tags"><button id="7"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('7')" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls"><kbd id="tag-7"class="label-info"style="display: inline-block;font-size:7pt" >InternalCallVerifier&nbsp;(8)</kbd></button>&nbsp;<button id="6"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('6')" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value "><kbd id="tag-6"class="label-info"style="display: inline-block;font-size:7pt" >EqualityVerifier&nbsp;(6)</kbd></button>&nbsp;<button id="5"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('5')" data-toggle="tooltip" title="Executes methods or other tests from the same test unit"><kbd id="tag-5"class="label-info"style="display: inline-block;font-size:7pt" >ExecutionTester&nbsp;(5)</kbd></button>&nbsp;<button id="3"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('3')" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes"><kbd id="tag-3"class="label-info"style="display: inline-block;font-size:7pt" >HybridVerifier&nbsp;(4)</kbd></button>&nbsp;<button id="9"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('9')" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) "><kbd id="tag-9"class="label-info"style="display: inline-block;font-size:7pt" >APIUtilityVerifier&nbsp;(4)</kbd></button>&nbsp;<button id="2"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('2')" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure"><kbd id="tag-2"class="label-info"style="display: inline-block;font-size:7pt" >UtilityVerifier&nbsp;(4)</kbd></button>&nbsp;<button id="10"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('10')" data-toggle="tooltip" title="Verifies boolean conditions"><kbd id="tag-10"class="label-info"style="display: inline-block;font-size:7pt" >BooleanVerifier&nbsp;(3)</kbd></button>&nbsp;<button id="1"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('1')" data-toggle="tooltip" title="Verifies whether objects are null"><kbd id="tag-1"class="label-info"style="display: inline-block;font-size:7pt" >NullVerifier&nbsp;(2)</kbd></button>&nbsp;<button id="8"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('8')" data-toggle="tooltip" title="Allocates resources before the execution of the test cases"><kbd id="tag-8"class="label-info"style="display: inline-block;font-size:7pt" >TestInitializer&nbsp;(1)</kbd></button>&nbsp;<button id="4"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('4')" data-toggle="tooltip" title="Releases resources used by the test cases"><kbd id="tag-4"class="label-info"style="display: inline-block;font-size:7pt" >TestCleaner&nbsp;(1)</kbd></button>&nbsp;</div></code></pre><center><button onclick="showBlocks()" style="margin:6px">Update filter <span class="glyphicon glyphicon-refresh" aria-hidden="true"></span> </button></center><br>
<pre class="type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Test deleting snapshots in more complicated scenarios (snapshot diffs are
 * distributed in the directory sub-tree)
 */
@Test(timeout=300000) public void testCombineSnapshotDiff2() throws Exception {
  testCombineSnapshotDiffImpl(sub,"subsub1/subsubsub1/",3);
}

</code></pre>

<pre class="type-9 type-7 type-10 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
"></span><br>
/** 
 * When combine two snapshots, make sure files/directories created after the 
 * prior snapshot get destroyed.
 */
@Test(timeout=300000) public void testCombineSnapshotDiff3() throws Exception {
  Path dir=new Path("/dir");
  Path subDir1=new Path(dir,"subdir1");
  Path subDir2=new Path(dir,"subdir2");
  hdfs.mkdirs(subDir2);
  Path subsubDir=new Path(subDir1,"subsubdir");
  hdfs.mkdirs(subsubDir);
  SnapshotTestHelper.createSnapshot(hdfs,dir,"s1");
  Path newDir=new Path(subsubDir,"newdir");
  Path newFile=new Path(newDir,"newfile");
  DFSTestUtil.createFile(hdfs,newFile,BLOCKSIZE,REPLICATION,seed);
  Path newFile2=new Path(subDir2,"newfile");
  DFSTestUtil.createFile(hdfs,newFile2,BLOCKSIZE,REPLICATION,seed);
  SnapshotTestHelper.createSnapshot(hdfs,dir,"s2");
  checkQuotaUsageComputation(dir,11,BLOCKSIZE * 2 * REPLICATION);
  hdfs.delete(subsubDir,true);
  hdfs.delete(subDir2,true);
  checkQuotaUsageComputation(dir,14,BLOCKSIZE * 2 * REPLICATION);
  hdfs.deleteSnapshot(dir,"s2");
  checkQuotaUsageComputation(dir,8,0);
  Path subdir1_s1=SnapshotTestHelper.getSnapshotPath(dir,"s1",subDir1.getName());
  Path subdir1_s2=SnapshotTestHelper.getSnapshotPath(dir,"s2",subDir1.getName());
  assertTrue(hdfs.exists(subdir1_s1));
  assertFalse(hdfs.exists(subdir1_s2));
}

</code></pre>

<pre class="type-7 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
"></span><br>
/** 
 * Test deleting snapshots with modification on the metadata of directory 
 */
@Test(timeout=300000) public void testDeleteSnapshotWithDirModification() throws Exception {
  Path file=new Path(sub,"file");
  DFSTestUtil.createFile(hdfs,file,BLOCKSIZE,REPLICATION,seed);
  hdfs.setOwner(sub,"user1","group1");
  SnapshotTestHelper.createSnapshot(hdfs,sub,"s1");
  checkQuotaUsageComputation(sub,3,BLOCKSIZE * 3);
  hdfs.setOwner(sub,"user2","group2");
  checkQuotaUsageComputation(sub,3,BLOCKSIZE * 3);
  hdfs.createSnapshot(sub,"s2");
  checkQuotaUsageComputation(sub,4,BLOCKSIZE * 3);
  hdfs.createSnapshot(sub,"s3");
  checkQuotaUsageComputation(sub,5,BLOCKSIZE * 3);
  hdfs.setOwner(sub,"user3","group3");
  checkQuotaUsageComputation(sub,5,BLOCKSIZE * 3);
  hdfs.deleteSnapshot(sub,"s3");
  checkQuotaUsageComputation(sub,4,BLOCKSIZE * 3);
  FileStatus statusOfS2=hdfs.getFileStatus(new Path(sub,HdfsConstants.DOT_SNAPSHOT_DIR + "/s2"));
  assertEquals("user2",statusOfS2.getOwner());
  assertEquals("group2",statusOfS2.getGroup());
  hdfs.deleteSnapshot(sub,"s2");
  checkQuotaUsageComputation(sub,3,BLOCKSIZE * 3);
  FileStatus statusOfS1=hdfs.getFileStatus(new Path(sub,HdfsConstants.DOT_SNAPSHOT_DIR + "/s1"));
  assertEquals("user1",statusOfS1.getOwner());
  assertEquals("group1",statusOfS1.getGroup());
}

</code></pre>

<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testDeleteSnapshotWithPermissionsDisabled() throws Exception {
  cluster.shutdown();
  Configuration newConf=new Configuration(conf);
  newConf.setBoolean(DFSConfigKeys.DFS_PERMISSIONS_ENABLED_KEY,false);
  cluster=new MiniDFSCluster.Builder(newConf).numDataNodes(0).build();
  cluster.waitActive();
  hdfs=cluster.getFileSystem();
  final Path path=new Path("/dir");
  hdfs.mkdirs(path);
  hdfs.allowSnapshot(path);
  hdfs.mkdirs(new Path(path,"/test"));
  hdfs.createSnapshot(path,"s1");
  UserGroupInformation anotherUser=UserGroupInformation.createRemoteUser("anotheruser");
  anotherUser.doAs(new PrivilegedAction(){
    @Override public Object run(){
      DistributedFileSystem anotherUserFS=null;
      try {
        anotherUserFS=cluster.getFileSystem();
        anotherUserFS.deleteSnapshot(path,"s1");
      }
 catch (      IOException e) {
        fail("Failed to delete snapshot : " + e.getLocalizedMessage());
      }
 finally {
        IOUtils.closeStream(anotherUserFS);
      }
      return null;
    }
  }
);
}

</code></pre>

<pre class="type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Deleting directory with snapshottable descendant with snapshots must fail.
 */
@Test(timeout=300000) public void testDeleteDirectoryWithSnapshot2() throws Exception {
  Path file0=new Path(sub,"file0");
  Path file1=new Path(sub,"file1");
  DFSTestUtil.createFile(hdfs,file0,BLOCKSIZE,REPLICATION,seed);
  DFSTestUtil.createFile(hdfs,file1,BLOCKSIZE,REPLICATION,seed);
  Path subfile1=new Path(subsub,"file0");
  Path subfile2=new Path(subsub,"file1");
  DFSTestUtil.createFile(hdfs,subfile1,BLOCKSIZE,REPLICATION,seed);
  DFSTestUtil.createFile(hdfs,subfile2,BLOCKSIZE,REPLICATION,seed);
  hdfs.allowSnapshot(subsub);
  hdfs.createSnapshot(subsub,"s1");
  exception.expect(RemoteException.class);
  String error=subsub.toString() + " is snapshottable and already has snapshots";
  exception.expectMessage(error);
  hdfs.delete(dir,true);
}

</code></pre>

<pre class="type-9 type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test deleting the earliest (first) snapshot. In this simplest scenario, the 
 * snapshots are taken on the same directory, and we do not need to combine
 * snapshot diffs.
 */
@Test(timeout=300000) public void testDeleteEarliestSnapshot1() throws Exception {
  Path file0=new Path(sub,"file0");
  Path file1=new Path(sub,"file1");
  DFSTestUtil.createFile(hdfs,file0,BLOCKSIZE,REPLICATION,seed);
  DFSTestUtil.createFile(hdfs,file1,BLOCKSIZE,REPLICATION,seed);
  String snapshotName="s1";
  try {
    hdfs.deleteSnapshot(sub,snapshotName);
    fail("SnapshotException expected: " + sub.toString() + " is not snapshottable yet");
  }
 catch (  Exception e) {
    GenericTestUtils.assertExceptionContains("Directory is not a snapshottable directory: " + sub,e);
  }
  hdfs.allowSnapshot(sub);
  try {
    hdfs.deleteSnapshot(sub,snapshotName);
    fail("SnapshotException expected: snapshot " + snapshotName + " does not exist for "+ sub.toString());
  }
 catch (  Exception e) {
    GenericTestUtils.assertExceptionContains("Cannot delete snapshot " + snapshotName + " from path "+ sub.toString()+ ": the snapshot does not exist.",e);
  }
  SnapshotTestHelper.createSnapshot(hdfs,sub,snapshotName);
  checkQuotaUsageComputation(sub,4,BLOCKSIZE * REPLICATION * 2);
  hdfs.deleteSnapshot(sub,snapshotName);
  checkQuotaUsageComputation(sub,3,BLOCKSIZE * REPLICATION * 2);
  hdfs.createSnapshot(sub,snapshotName);
  checkQuotaUsageComputation(sub,4,BLOCKSIZE * REPLICATION * 2);
  Path newFile=new Path(sub,"newFile");
  DFSTestUtil.createFile(hdfs,newFile,BLOCKSIZE,REPLICATION,seed);
  String snapshotName2="s2";
  hdfs.createSnapshot(sub,snapshotName2);
  checkQuotaUsageComputation(sub,6,BLOCKSIZE * REPLICATION * 3);
  Path ss=SnapshotTestHelper.getSnapshotPath(sub,snapshotName2,"newFile");
  FileStatus statusBeforeDeletion=hdfs.getFileStatus(ss);
  hdfs.deleteSnapshot(sub,snapshotName);
  checkQuotaUsageComputation(sub,5,BLOCKSIZE * REPLICATION * 3);
  FileStatus statusAfterDeletion=hdfs.getFileStatus(ss);
  System.out.println("Before deletion: " + statusBeforeDeletion.toString() + "\n"+ "After deletion: "+ statusAfterDeletion.toString());
  assertEquals(statusBeforeDeletion.toString(),statusAfterDeletion.toString());
}

</code></pre>

<pre class="type-2 type-7 type-1 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test deleting the earliest (first) snapshot. In this more complicated 
 * scenario, the snapshots are taken across directories.
 * <pre>
 * The test covers the following scenarios:
 * 1. delete the first diff in the diff list of a directory
 * 2. delete the first diff in the diff list of a file
 * </pre>
 * Also, the recursive cleanTree process should cover both INodeFile and 
 * INodeDirectory.
 */
@Test(timeout=300000) public void testDeleteEarliestSnapshot2() throws Exception {
  Path noChangeDir=new Path(sub,"noChangeDir");
  Path noChangeFile=new Path(noChangeDir,"noChangeFile");
  Path metaChangeFile=new Path(noChangeDir,"metaChangeFile");
  Path metaChangeDir=new Path(noChangeDir,"metaChangeDir");
  Path toDeleteFile=new Path(metaChangeDir,"toDeleteFile");
  DFSTestUtil.createFile(hdfs,noChangeFile,BLOCKSIZE,REPLICATION,seed);
  DFSTestUtil.createFile(hdfs,metaChangeFile,BLOCKSIZE,REPLICATION,seed);
  DFSTestUtil.createFile(hdfs,toDeleteFile,BLOCKSIZE,REPLICATION,seed);
  final INodeFile toDeleteFileNode=TestSnapshotBlocksMap.assertBlockCollection(toDeleteFile.toString(),1,fsdir,blockmanager);
  BlockInfo[] blocks=toDeleteFileNode.getBlocks();
  SnapshotTestHelper.createSnapshot(hdfs,dir,"s0");
  checkQuotaUsageComputation(dir,8,3 * BLOCKSIZE * REPLICATION);
  hdfs.delete(toDeleteFile,true);
  checkQuotaUsageComputation(dir,10,3 * BLOCKSIZE * REPLICATION);
  hdfs.setReplication(metaChangeFile,REPLICATION_1);
  hdfs.setOwner(metaChangeDir,"unknown","unknown");
  checkQuotaUsageComputation(dir,11,3 * BLOCKSIZE * REPLICATION);
  hdfs.createSnapshot(dir,"s1");
  checkQuotaUsageComputation(dir,12,3 * BLOCKSIZE * REPLICATION);
  hdfs.deleteSnapshot(dir,"s0");
  checkQuotaUsageComputation(dir,7,2 * BLOCKSIZE * REPLICATION - BLOCKSIZE);
  for (  BlockInfo b : blocks) {
    assertNull(blockmanager.getBlockCollection(b));
  }
  final INodeDirectory dirNode=fsdir.getINode(dir.toString()).asDirectory();
  Snapshot snapshot0=dirNode.getSnapshot(DFSUtil.string2Bytes("s0"));
  assertNull(snapshot0);
  Snapshot snapshot1=dirNode.getSnapshot(DFSUtil.string2Bytes("s1"));
  DirectoryDiffList diffList=dirNode.getDiffs();
  assertEquals(1,diffList.asList().size());
  assertEquals(snapshot1.getId(),diffList.getLast().getSnapshotId());
  diffList=fsdir.getINode(metaChangeDir.toString()).asDirectory().getDiffs();
  assertEquals(0,diffList.asList().size());
  final INodeDirectory noChangeDirNode=(INodeDirectory)fsdir.getINode(noChangeDir.toString());
  assertEquals(INodeDirectory.class,noChangeDirNode.getClass());
  final INodeFile noChangeFileNode=(INodeFile)fsdir.getINode(noChangeFile.toString());
  assertEquals(INodeFile.class,noChangeFileNode.getClass());
  TestSnapshotBlocksMap.assertBlockCollection(noChangeFile.toString(),1,fsdir,blockmanager);
  FileStatus status=hdfs.getFileStatus(metaChangeDir);
  assertEquals("unknown",status.getOwner());
  assertEquals("unknown",status.getGroup());
  status=hdfs.getFileStatus(metaChangeFile);
  assertEquals(REPLICATION_1,status.getReplication());
  TestSnapshotBlocksMap.assertBlockCollection(metaChangeFile.toString(),1,fsdir,blockmanager);
  try {
    status=hdfs.getFileStatus(toDeleteFile);
    fail("should throw FileNotFoundException");
  }
 catch (  FileNotFoundException e) {
    GenericTestUtils.assertExceptionContains("File does not exist: " + toDeleteFile.toString(),e);
  }
  final Path toDeleteFileInSnapshot=SnapshotTestHelper.getSnapshotPath(dir,"s0",toDeleteFile.toString().substring(dir.toString().length()));
  try {
    status=hdfs.getFileStatus(toDeleteFileInSnapshot);
    fail("should throw FileNotFoundException");
  }
 catch (  FileNotFoundException e) {
    GenericTestUtils.assertExceptionContains("File does not exist: " + toDeleteFileInSnapshot.toString(),e);
  }
}

</code></pre>

<pre class="type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Test deleting snapshots in a more complicated scenario: need to combine
 * snapshot diffs, but no need to handle diffs distributed in a dir tree
 */
@Test(timeout=300000) public void testCombineSnapshotDiff1() throws Exception {
  testCombineSnapshotDiffImpl(sub,"",1);
}

</code></pre>

<pre class="type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Deleting snapshottable directory with snapshots must fail.
 */
@Test(timeout=300000) public void testDeleteDirectoryWithSnapshot() throws Exception {
  Path file0=new Path(sub,"file0");
  Path file1=new Path(sub,"file1");
  DFSTestUtil.createFile(hdfs,file0,BLOCKSIZE,REPLICATION,seed);
  DFSTestUtil.createFile(hdfs,file1,BLOCKSIZE,REPLICATION,seed);
  hdfs.allowSnapshot(sub);
  hdfs.createSnapshot(sub,"s1");
  exception.expect(RemoteException.class);
  String error="The directory " + sub.toString() + " cannot be deleted since "+ sub.toString()+ " is snapshottable and already has snapshots";
  exception.expectMessage(error);
  hdfs.delete(sub,true);
}

</code></pre>

<pre class="type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test(timeout=60000) public void testHANNRestartAfterSnapshotDeletion() throws Exception {
  hdfs.close();
  cluster.shutdown();
  conf=new Configuration();
  cluster=new MiniDFSCluster.Builder(conf).nnTopology(MiniDFSNNTopology.simpleHATopology()).numDataNodes(1).build();
  cluster.transitionToActive(0);
  NameNode snn=cluster.getNameNode(1);
  snn.stop();
  hdfs=(DistributedFileSystem)HATestUtil.configureFailoverFs(cluster,conf);
  Path dir=new Path("/dir");
  Path subDir=new Path(dir,"sub");
  hdfs.mkdirs(dir);
  hdfs.allowSnapshot(dir);
  for (int i=0; i < 5; i++) {
    DFSTestUtil.createFile(hdfs,new Path(subDir,"" + i),100,(short)1,1024L);
  }
  hdfs.createSnapshot(dir,"s0");
  hdfs.delete(subDir,true);
  NameNode ann=cluster.getNameNode(0);
  ann.getRpcServer().rollEditLog();
  hdfs.deleteSnapshot(dir,"s0");
  Thread.sleep(2000);
  NameNodeAdapter.abortEditLogs(ann);
  cluster.restartNameNode(0,false);
  cluster.transitionToActive(0);
  cluster.waitClusterUp();
}

</code></pre>

<pre class="type-7 type-10 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
"></span><br>
@Test public void testDeleteSnapshotCommandWithIllegalArguments() throws Exception {
  ByteArrayOutputStream out=new ByteArrayOutputStream();
  PrintStream psOut=new PrintStream(out);
  System.setOut(psOut);
  System.setErr(psOut);
  FsShell shell=new FsShell();
  shell.setConf(conf);
  String[] argv1={"-deleteSnapshot","/tmp"};
  int val=shell.run(argv1);
  assertTrue(val == -1);
  assertTrue(out.toString().contains(argv1[0] + ": Incorrect number of arguments."));
  out.reset();
  String[] argv2={"-deleteSnapshot","/tmp","s1","s2"};
  val=shell.run(argv2);
  assertTrue(val == -1);
  assertTrue(out.toString().contains(argv2[0] + ": Incorrect number of arguments."));
  psOut.close();
  out.close();
}

</code></pre>

<pre class="type-7 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
"></span><br>
/** 
 * Test applying editlog of operation which deletes a snapshottable directory
 * without snapshots. The snapshottable dir list in snapshot manager should be
 * updated.
 */
@Test(timeout=300000) public void testApplyEditLogForDeletion() throws Exception {
  final Path foo=new Path("/foo");
  final Path bar1=new Path(foo,"bar1");
  final Path bar2=new Path(foo,"bar2");
  hdfs.mkdirs(bar1);
  hdfs.mkdirs(bar2);
  hdfs.allowSnapshot(bar1);
  hdfs.allowSnapshot(bar2);
  assertEquals(2,cluster.getNamesystem().getSnapshotManager().getNumSnapshottableDirs());
  assertEquals(2,cluster.getNamesystem().getSnapshotManager().getSnapshottableDirs().length);
  hdfs.delete(foo,true);
  cluster.restartNameNode(0);
  assertEquals(0,cluster.getNamesystem().getSnapshotManager().getNumSnapshottableDirs());
  assertEquals(0,cluster.getNamesystem().getSnapshotManager().getSnapshottableDirs().length);
  hdfs.setSafeMode(SafeModeAction.SAFEMODE_ENTER);
  hdfs.saveNamespace();
  hdfs.setSafeMode(SafeModeAction.SAFEMODE_LEAVE);
  cluster.restartNameNode(0);
}

</code></pre>

<pre class="type-9 type-7 type-10 type-1 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects are null
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test deleting a directory which is a descendant of a snapshottable
 * directory. In the test we need to cover the following cases:
 * <pre>
 * 1. Delete current INodeFile/INodeDirectory without taking any snapshot.
 * 2. Delete current INodeFile/INodeDirectory while snapshots have been taken 
 * on ancestor(s).
 * 3. Delete current INodeFileWithSnapshot.
 * 4. Delete current INodeDirectoryWithSnapshot.
 * </pre>
 */
@Test(timeout=300000) public void testDeleteCurrentFileDirectory() throws Exception {
  Path deleteDir=new Path(subsub,"deleteDir");
  Path deleteFile=new Path(deleteDir,"deleteFile");
  Path noChangeDirParent=new Path(sub,"noChangeDirParent");
  Path noChangeDir=new Path(noChangeDirParent,"noChangeDir");
  Path noChangeFile=new Path(noChangeDir,"noChangeFile");
  DFSTestUtil.createFile(hdfs,deleteFile,BLOCKSIZE,REPLICATION,seed);
  DFSTestUtil.createFile(hdfs,noChangeFile,BLOCKSIZE,REPLICATION,seed);
  Path metaChangeFile1=new Path(subsub,"metaChangeFile1");
  DFSTestUtil.createFile(hdfs,metaChangeFile1,BLOCKSIZE,REPLICATION,seed);
  Path metaChangeFile2=new Path(noChangeDir,"metaChangeFile2");
  DFSTestUtil.createFile(hdfs,metaChangeFile2,BLOCKSIZE,REPLICATION,seed);
  hdfs.delete(deleteDir,true);
  SnapshotTestHelper.createSnapshot(hdfs,dir,"s0");
  Path tempDir=new Path(dir,"tempdir");
  Path tempFile=new Path(tempDir,"tempfile");
  DFSTestUtil.createFile(hdfs,tempFile,BLOCKSIZE,REPLICATION,seed);
  final INodeFile temp=TestSnapshotBlocksMap.assertBlockCollection(tempFile.toString(),1,fsdir,blockmanager);
  BlockInfo[] blocks=temp.getBlocks();
  hdfs.delete(tempDir,true);
  checkQuotaUsageComputation(dir,9L,BLOCKSIZE * REPLICATION * 3);
  for (  BlockInfo b : blocks) {
    assertNull(blockmanager.getBlockCollection(b));
  }
  Path newFileAfterS0=new Path(subsub,"newFile");
  DFSTestUtil.createFile(hdfs,newFileAfterS0,BLOCKSIZE,REPLICATION,seed);
  hdfs.setReplication(metaChangeFile1,REPLICATION_1);
  hdfs.setReplication(metaChangeFile2,REPLICATION_1);
  SnapshotTestHelper.createSnapshot(hdfs,dir,"s1");
  checkQuotaUsageComputation(dir,14L,BLOCKSIZE * REPLICATION * 4);
  Snapshot snapshot0=fsdir.getINode(dir.toString()).asDirectory().getSnapshot(DFSUtil.string2Bytes("s0"));
  Snapshot snapshot1=fsdir.getINode(dir.toString()).asDirectory().getSnapshot(DFSUtil.string2Bytes("s1"));
  hdfs.delete(noChangeDirParent,true);
  checkQuotaUsageComputation(dir,17L,BLOCKSIZE * REPLICATION * 4);
  Path snapshotNoChangeDir=SnapshotTestHelper.getSnapshotPath(dir,"s1",sub.getName() + "/" + noChangeDirParent.getName()+ "/"+ noChangeDir.getName());
  INodeDirectory snapshotNode=(INodeDirectory)fsdir.getINode(snapshotNoChangeDir.toString());
  assertEquals(INodeDirectory.class,snapshotNode.getClass());
  ReadOnlyList<INode> children=snapshotNode.getChildrenList(Snapshot.CURRENT_STATE_ID);
  assertEquals(2,children.size());
  INode noChangeFileSCopy=children.get(1);
  assertEquals(noChangeFile.getName(),noChangeFileSCopy.getLocalName());
  assertEquals(INodeFile.class,noChangeFileSCopy.getClass());
  TestSnapshotBlocksMap.assertBlockCollection(new Path(snapshotNoChangeDir,noChangeFileSCopy.getLocalName()).toString(),1,fsdir,blockmanager);
  INodeFile metaChangeFile2SCopy=children.get(0).asFile();
  assertEquals(metaChangeFile2.getName(),metaChangeFile2SCopy.getLocalName());
  assertTrue(metaChangeFile2SCopy.isWithSnapshot());
  assertFalse(metaChangeFile2SCopy.isUnderConstruction());
  TestSnapshotBlocksMap.assertBlockCollection(new Path(snapshotNoChangeDir,metaChangeFile2SCopy.getLocalName()).toString(),1,fsdir,blockmanager);
  assertEquals(REPLICATION_1,metaChangeFile2SCopy.getFileReplication(Snapshot.CURRENT_STATE_ID));
  assertEquals(REPLICATION_1,metaChangeFile2SCopy.getFileReplication(snapshot1.getId()));
  assertEquals(REPLICATION,metaChangeFile2SCopy.getFileReplication(snapshot0.getId()));
  Path newFile=new Path(sub,"newFile");
  DFSTestUtil.createFile(hdfs,newFile,BLOCKSIZE,REPLICATION,seed);
  final INodeFile newFileNode=TestSnapshotBlocksMap.assertBlockCollection(newFile.toString(),1,fsdir,blockmanager);
  blocks=newFileNode.getBlocks();
  checkQuotaUsageComputation(dir,18L,BLOCKSIZE * REPLICATION * 5);
  hdfs.delete(sub,true);
  checkQuotaUsageComputation(dir,19L,BLOCKSIZE * REPLICATION * 4);
  for (  BlockInfo b : blocks) {
    assertNull(blockmanager.getBlockCollection(b));
  }
  Path snapshotSub=SnapshotTestHelper.getSnapshotPath(dir,"s1",sub.getName());
  INodeDirectory snapshotNode4Sub=fsdir.getINode(snapshotSub.toString()).asDirectory();
  assertTrue(snapshotNode4Sub.isWithSnapshot());
  assertEquals(1,snapshotNode4Sub.getChildrenList(Snapshot.CURRENT_STATE_ID).size());
  assertEquals(2,snapshotNode4Sub.getChildrenList(snapshot1.getId()).size());
  INode snapshotNode4Subsub=snapshotNode4Sub.getChildrenList(Snapshot.CURRENT_STATE_ID).get(0);
  assertTrue(snapshotNode4Subsub.asDirectory().isWithSnapshot());
  assertTrue(snapshotNode4Sub == snapshotNode4Subsub.getParent());
  INodeDirectory snapshotSubsubDir=(INodeDirectory)snapshotNode4Subsub;
  children=snapshotSubsubDir.getChildrenList(Snapshot.CURRENT_STATE_ID);
  assertEquals(2,children.size());
  assertEquals(children.get(0).getLocalName(),metaChangeFile1.getName());
  assertEquals(children.get(1).getLocalName(),newFileAfterS0.getName());
  children=snapshotSubsubDir.getChildrenList(snapshot0.getId());
  assertEquals(1,children.size());
  INode child=children.get(0);
  assertEquals(child.getLocalName(),metaChangeFile1.getName());
  INodeFile metaChangeFile1SCopy=child.asFile();
  assertTrue(metaChangeFile1SCopy.isWithSnapshot());
  assertFalse(metaChangeFile1SCopy.isUnderConstruction());
  assertEquals(REPLICATION_1,metaChangeFile1SCopy.getFileReplication(Snapshot.CURRENT_STATE_ID));
  assertEquals(REPLICATION_1,metaChangeFile1SCopy.getFileReplication(snapshot1.getId()));
  assertEquals(REPLICATION,metaChangeFile1SCopy.getFileReplication(snapshot0.getId()));
}

</code></pre>

<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Releases resources used by the test cases">TestCleaner</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Releases resources used by the test cases
"></span><br>
@After public void tearDown() throws Exception {
  if (cluster != null) {
    cluster.shutdown();
  }
}

</code></pre>

<pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Allocates resources before the execution of the test cases">TestInitializer</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Allocates resources before the execution of the test cases
"></span><br>
@Before public void setUp() throws Exception {
  conf=new Configuration();
  cluster=new MiniDFSCluster.Builder(conf).numDataNodes(REPLICATION).format(true).build();
  cluster.waitActive();
  fsn=cluster.getNamesystem();
  fsdir=fsn.getFSDirectory();
  blockmanager=fsn.getBlockManager();
  hdfs=cluster.getFileSystem();
}

</code></pre>

<pre class="type-9 type-2 type-7 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * A test covering the case where the snapshot diff to be deleted is renamed 
 * to its previous snapshot. 
 */
@Test(timeout=300000) public void testRenameSnapshotDiff() throws Exception {
  cluster.getNamesystem().getSnapshotManager().setAllowNestedSnapshots(true);
  final Path subFile0=new Path(sub,"file0");
  final Path subsubFile0=new Path(subsub,"file0");
  DFSTestUtil.createFile(hdfs,subFile0,BLOCKSIZE,REPLICATION,seed);
  DFSTestUtil.createFile(hdfs,subsubFile0,BLOCKSIZE,REPLICATION,seed);
  hdfs.setOwner(subsub,"owner","group");
  SnapshotTestHelper.createSnapshot(hdfs,sub,"s0");
  checkQuotaUsageComputation(sub,5,BLOCKSIZE * 6);
  final Path subFile1=new Path(sub,"file1");
  final Path subsubFile1=new Path(subsub,"file1");
  DFSTestUtil.createFile(hdfs,subFile1,BLOCKSIZE,REPLICATION_1,seed);
  DFSTestUtil.createFile(hdfs,subsubFile1,BLOCKSIZE,REPLICATION,seed);
  checkQuotaUsageComputation(sub,8,BLOCKSIZE * 11);
  SnapshotTestHelper.createSnapshot(hdfs,sub,"s1");
  checkQuotaUsageComputation(sub,9,BLOCKSIZE * 11);
  SnapshotTestHelper.createSnapshot(hdfs,dir,"s2");
  checkQuotaUsageComputation(dir,11,BLOCKSIZE * 11);
  checkQuotaUsageComputation(sub,9,BLOCKSIZE * 11);
  hdfs.setOwner(subsub,"unknown","unknown");
  hdfs.setReplication(subsubFile1,REPLICATION_1);
  checkQuotaUsageComputation(dir,13,BLOCKSIZE * 11);
  checkQuotaUsageComputation(sub,11,BLOCKSIZE * 11);
  hdfs.delete(subFile1,true);
  checkQuotaUsageComputation(new Path("/"),16,BLOCKSIZE * 11);
  checkQuotaUsageComputation(dir,15,BLOCKSIZE * 11);
  checkQuotaUsageComputation(sub,13,BLOCKSIZE * 11);
  Path subsubSnapshotCopy=SnapshotTestHelper.getSnapshotPath(dir,"s2",sub.getName() + Path.SEPARATOR + subsub.getName());
  Path subsubFile1SCopy=SnapshotTestHelper.getSnapshotPath(dir,"s2",sub.getName() + Path.SEPARATOR + subsub.getName()+ Path.SEPARATOR+ subsubFile1.getName());
  Path subFile1SCopy=SnapshotTestHelper.getSnapshotPath(dir,"s2",sub.getName() + Path.SEPARATOR + subFile1.getName());
  FileStatus subsubStatus=hdfs.getFileStatus(subsubSnapshotCopy);
  assertEquals("owner",subsubStatus.getOwner());
  assertEquals("group",subsubStatus.getGroup());
  FileStatus subsubFile1Status=hdfs.getFileStatus(subsubFile1SCopy);
  assertEquals(REPLICATION,subsubFile1Status.getReplication());
  FileStatus subFile1Status=hdfs.getFileStatus(subFile1SCopy);
  assertEquals(REPLICATION_1,subFile1Status.getReplication());
  hdfs.deleteSnapshot(dir,"s2");
  checkQuotaUsageComputation(new Path("/"),14,BLOCKSIZE * 11);
  checkQuotaUsageComputation(dir,13,BLOCKSIZE * 11);
  checkQuotaUsageComputation(sub,12,BLOCKSIZE * 11);
  try {
    hdfs.getFileStatus(subsubSnapshotCopy);
    fail("should throw FileNotFoundException");
  }
 catch (  FileNotFoundException e) {
    GenericTestUtils.assertExceptionContains("File does not exist: " + subsubSnapshotCopy.toString(),e);
  }
  try {
    hdfs.getFileStatus(subsubFile1SCopy);
    fail("should throw FileNotFoundException");
  }
 catch (  FileNotFoundException e) {
    GenericTestUtils.assertExceptionContains("File does not exist: " + subsubFile1SCopy.toString(),e);
  }
  try {
    hdfs.getFileStatus(subFile1SCopy);
    fail("should throw FileNotFoundException");
  }
 catch (  FileNotFoundException e) {
    GenericTestUtils.assertExceptionContains("File does not exist: " + subFile1SCopy.toString(),e);
  }
  subsubSnapshotCopy=SnapshotTestHelper.getSnapshotPath(sub,"s1",subsub.getName());
  subsubFile1SCopy=SnapshotTestHelper.getSnapshotPath(sub,"s1",subsub.getName() + Path.SEPARATOR + subsubFile1.getName());
  subFile1SCopy=SnapshotTestHelper.getSnapshotPath(sub,"s1",subFile1.getName());
  subsubStatus=hdfs.getFileStatus(subsubSnapshotCopy);
  assertEquals("owner",subsubStatus.getOwner());
  assertEquals("group",subsubStatus.getGroup());
  subsubFile1Status=hdfs.getFileStatus(subsubFile1SCopy);
  assertEquals(REPLICATION,subsubFile1Status.getReplication());
  subFile1Status=hdfs.getFileStatus(subFile1SCopy);
  assertEquals(REPLICATION_1,subFile1Status.getReplication());
}

</code></pre>

<script>$(document).ready(function() {
  $('pre code').each(function(i, block) {
    hljs.highlightBlock(block);
  });
});</script>
