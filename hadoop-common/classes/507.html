<h3 style="margin:0px">Class: org.apache.hadoop.hdfs.server.namenode.TestFsck (15 methods) </h3><br><pre style="padding:0"><code class="html"><div id="tags"><button id="9"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('9')" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) "><kbd id="tag-9"class="label-info"style="display: inline-block;font-size:7pt" >APIUtilityVerifier&nbsp;(14)</kbd></button>&nbsp;<button id="7"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('7')" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls"><kbd id="tag-7"class="label-info"style="display: inline-block;font-size:7pt" >InternalCallVerifier&nbsp;(12)</kbd></button>&nbsp;<button id="10"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('10')" data-toggle="tooltip" title="Verifies boolean conditions"><kbd id="tag-10"class="label-info"style="display: inline-block;font-size:7pt" >BooleanVerifier&nbsp;(12)</kbd></button>&nbsp;<button id="3"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('3')" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes"><kbd id="tag-3"class="label-info"style="display: inline-block;font-size:7pt" >HybridVerifier&nbsp;(6)</kbd></button>&nbsp;<button id="6"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('6')" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value "><kbd id="tag-6"class="label-info"style="display: inline-block;font-size:7pt" >EqualityVerifier&nbsp;(6)</kbd></button>&nbsp;<button id="13"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('13')" data-toggle="tooltip" title="Verifies assertions in iterations"><kbd id="tag-13"class="label-info"style="display: inline-block;font-size:7pt" >IterativeVerifier&nbsp;(3)</kbd></button>&nbsp;<button id="11"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('11')" data-toggle="tooltip" title="Verifies assertions inside branch conditions"><kbd id="tag-11"class="label-info"style="display: inline-block;font-size:7pt" >BranchVerifier&nbsp;(2)</kbd></button>&nbsp;<button id="1"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('1')" data-toggle="tooltip" title="Verifies whether objects are null"><kbd id="tag-1"class="label-info"style="display: inline-block;font-size:7pt" >NullVerifier&nbsp;(2)</kbd></button>&nbsp;<button id="2"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('2')" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure"><kbd id="tag-2"class="label-info"style="display: inline-block;font-size:7pt" >UtilityVerifier&nbsp;(1)</kbd></button>&nbsp;</div></code></pre><center><button onclick="showBlocks()" style="margin:6px">Update filter <span class="glyphicon glyphicon-refresh" aria-hidden="true"></span> </button></center><br>
<pre class="type-9 type-7 type-10 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test if fsck can return -1 in case of failure
 * @throws Exception
 */
@Test public void testFsckError() throws Exception {
  MiniDFSCluster cluster=null;
  try {
    Configuration conf=new HdfsConfiguration();
    cluster=new MiniDFSCluster.Builder(conf).build();
    String fileName="/test.txt";
    Path filePath=new Path(fileName);
    FileSystem fs=cluster.getFileSystem();
    DFSTestUtil.createFile(fs,filePath,1L,(short)1,1L);
    DFSTestUtil.waitReplication(fs,filePath,(short)1);
    INodeFile node=(INodeFile)cluster.getNamesystem().dir.getNode(fileName,true);
    final BlockInfo[] blocks=node.getBlocks();
    assertEquals(blocks.length,1);
    blocks[0].setNumBytes(-1L);
    String outStr=runFsck(conf,-1,true,fileName);
    System.out.println(outStr);
    assertTrue(outStr.contains(NamenodeFsck.FAILURE_STATUS));
    fs.delete(filePath,true);
  }
  finally {
    if (cluster != null) {
      cluster.shutdown();
    }
  }
}

</code></pre>

<pre class="type-2 type-10 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test fsck with FileNotFound 
 */
@Test public void testFsckFileNotFound() throws Exception {
  final short NUM_REPLICAS=1;
  Configuration conf=new Configuration();
  NameNode namenode=mock(NameNode.class);
  NetworkTopology nettop=mock(NetworkTopology.class);
  Map<String,String[]> pmap=new HashMap<String,String[]>();
  Writer result=new StringWriter();
  PrintWriter out=new PrintWriter(result,true);
  InetAddress remoteAddress=InetAddress.getLocalHost();
  FSNamesystem fsName=mock(FSNamesystem.class);
  BlockManager blockManager=mock(BlockManager.class);
  DatanodeManager dnManager=mock(DatanodeManager.class);
  when(namenode.getNamesystem()).thenReturn(fsName);
  when(fsName.getBlockLocations(anyString(),anyLong(),anyLong(),anyBoolean(),anyBoolean(),anyBoolean())).thenThrow(new FileNotFoundException());
  when(fsName.getBlockManager()).thenReturn(blockManager);
  when(blockManager.getDatanodeManager()).thenReturn(dnManager);
  NamenodeFsck fsck=new NamenodeFsck(conf,namenode,nettop,pmap,out,NUM_REPLICAS,(short)1,remoteAddress);
  String pathString="/tmp/testFile";
  long length=123L;
  boolean isDir=false;
  int blockReplication=1;
  long blockSize=128 * 1024L;
  long modTime=123123123L;
  long accessTime=123123120L;
  FsPermission perms=FsPermission.getDefault();
  String owner="foo";
  String group="bar";
  byte[] symlink=null;
  byte[] path=new byte[128];
  path=DFSUtil.string2Bytes(pathString);
  long fileId=312321L;
  int numChildren=1;
  HdfsFileStatus file=new HdfsFileStatus(length,isDir,blockReplication,blockSize,modTime,accessTime,perms,owner,group,symlink,path,fileId,numChildren,null);
  Result res=new Result(conf);
  try {
    fsck.check(pathString,file,res);
  }
 catch (  Exception e) {
    fail("Unexpected exception " + e.getMessage());
  }
  assertTrue(res.toString().contains("HEALTHY"));
}

</code></pre>

<pre class="type-9 type-7 type-10 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
"></span><br>
/** 
 * Test fsck with permission set on inodes 
 */
@Test public void testFsckPermission() throws Exception {
  final DFSTestUtil util=new DFSTestUtil.Builder().setName(getClass().getSimpleName()).setNumFiles(20).build();
  final Configuration conf=new HdfsConfiguration();
  conf.setLong(DFSConfigKeys.DFS_BLOCKREPORT_INTERVAL_MSEC_KEY,10000L);
  MiniDFSCluster cluster=null;
  try {
    cluster=new MiniDFSCluster.Builder(conf).numDataNodes(4).build();
    final MiniDFSCluster c2=cluster;
    final String dir="/dfsck";
    final Path dirpath=new Path(dir);
    final FileSystem fs=c2.getFileSystem();
    util.createFiles(fs,dir);
    util.waitReplication(fs,dir,(short)3);
    fs.setPermission(dirpath,new FsPermission((short)0700));
    UserGroupInformation fakeUGI=UserGroupInformation.createUserForTesting("ProbablyNotARealUserName",new String[]{"ShangriLa"});
    fakeUGI.doAs(new PrivilegedExceptionAction(){
      @Override public Object run() throws Exception {
        System.out.println(runFsck(conf,-1,true,dir));
        return null;
      }
    }
);
    fs.setPermission(dirpath,new FsPermission((short)0777));
    fakeUGI.doAs(new PrivilegedExceptionAction(){
      @Override public Object run() throws Exception {
        final String outStr=runFsck(conf,0,true,dir);
        System.out.println(outStr);
        assertTrue(outStr.contains(NamenodeFsck.HEALTHY_STATUS));
        return null;
      }
    }
);
    util.cleanup(fs,dir);
  }
  finally {
    if (cluster != null) {
      cluster.shutdown();
    }
  }
}

</code></pre>

<pre class="type-9 type-7 type-1 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Tests that the # of missing block replicas and expected replicas is correct
 * @throws IOException
 */
@Test public void testFsckMissingReplicas() throws IOException {
  final short REPL_FACTOR=2;
  final short NUM_REPLICAS=1;
  final short NUM_BLOCKS=3;
  final long blockSize=512;
  Configuration conf=new Configuration();
  conf.setLong(DFSConfigKeys.DFS_BLOCK_SIZE_KEY,blockSize);
  MiniDFSCluster cluster=null;
  DistributedFileSystem dfs=null;
  try {
    cluster=new MiniDFSCluster.Builder(conf).numDataNodes(NUM_REPLICAS).build();
    assertNotNull("Failed Cluster Creation",cluster);
    cluster.waitClusterUp();
    dfs=cluster.getFileSystem();
    assertNotNull("Failed to get FileSystem",dfs);
    final String pathString=new String("/testfile");
    final Path path=new Path(pathString);
    long fileLen=blockSize * NUM_BLOCKS;
    DFSTestUtil.createFile(dfs,path,fileLen,REPL_FACTOR,1);
    NameNode namenode=cluster.getNameNode();
    NetworkTopology nettop=cluster.getNamesystem().getBlockManager().getDatanodeManager().getNetworkTopology();
    Map<String,String[]> pmap=new HashMap<String,String[]>();
    Writer result=new StringWriter();
    PrintWriter out=new PrintWriter(result,true);
    InetAddress remoteAddress=InetAddress.getLocalHost();
    NamenodeFsck fsck=new NamenodeFsck(conf,namenode,nettop,pmap,out,NUM_REPLICAS,(short)1,remoteAddress);
    final HdfsFileStatus file=namenode.getRpcServer().getFileInfo(pathString);
    assertNotNull(file);
    Result res=new Result(conf);
    fsck.check(pathString,file,res);
    System.out.println(result.toString());
    assertEquals(res.missingReplicas,(NUM_BLOCKS * REPL_FACTOR) - (NUM_BLOCKS * NUM_REPLICAS));
    assertEquals(res.numExpectedReplicas,NUM_BLOCKS * REPL_FACTOR);
  }
  finally {
    if (dfs != null) {
      dfs.close();
    }
    if (cluster != null) {
      cluster.shutdown();
    }
  }
}

</code></pre>

<pre class="type-9 type-7 type-10 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * do fsck 
 */
@Test public void testFsck() throws Exception {
  DFSTestUtil util=new DFSTestUtil.Builder().setName("TestFsck").setNumFiles(20).build();
  MiniDFSCluster cluster=null;
  FileSystem fs=null;
  try {
    Configuration conf=new HdfsConfiguration();
    final long precision=1L;
    conf.setLong(DFSConfigKeys.DFS_NAMENODE_ACCESSTIME_PRECISION_KEY,precision);
    conf.setLong(DFSConfigKeys.DFS_BLOCKREPORT_INTERVAL_MSEC_KEY,10000L);
    cluster=new MiniDFSCluster.Builder(conf).numDataNodes(4).build();
    fs=cluster.getFileSystem();
    final String fileName="/srcdat";
    util.createFiles(fs,fileName);
    util.waitReplication(fs,fileName,(short)3);
    final Path file=new Path(fileName);
    long aTime=fs.getFileStatus(file).getAccessTime();
    Thread.sleep(precision);
    setupAuditLogs();
    String outStr=runFsck(conf,0,true,"/");
    verifyAuditLogs();
    assertEquals(aTime,fs.getFileStatus(file).getAccessTime());
    System.out.println(outStr);
    assertTrue(outStr.contains(NamenodeFsck.HEALTHY_STATUS));
    if (fs != null) {
      try {
        fs.close();
      }
 catch (      Exception e) {
      }
    }
    cluster.shutdown();
    cluster=new MiniDFSCluster.Builder(conf).numDataNodes(0).format(false).build();
    outStr=runFsck(conf,1,true,"/");
    assertTrue(outStr.contains(NamenodeFsck.CORRUPT_STATUS));
    System.out.println(outStr);
    cluster.startDataNodes(conf,4,true,null,null);
    cluster.waitActive();
    cluster.waitClusterUp();
    fs=cluster.getFileSystem();
    util.cleanup(fs,"/srcdat");
  }
  finally {
    if (fs != null) {
      try {
        fs.close();
      }
 catch (      Exception e) {
      }
    }
    if (cluster != null) {
      cluster.shutdown();
    }
  }
}

</code></pre>

<pre class="type-9 type-7 type-10 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
"></span><br>
@Test public void testCorruptBlock() throws Exception {
  Configuration conf=new HdfsConfiguration();
  conf.setLong(DFSConfigKeys.DFS_BLOCKREPORT_INTERVAL_MSEC_KEY,1000);
  conf.setInt(DFSConfigKeys.DFS_CLIENT_RETRY_WINDOW_BASE,10);
  FileSystem fs=null;
  DFSClient dfsClient=null;
  LocatedBlocks blocks=null;
  int replicaCount=0;
  Random random=new Random();
  String outStr=null;
  short factor=1;
  MiniDFSCluster cluster=null;
  try {
    cluster=new MiniDFSCluster.Builder(conf).numDataNodes(1).build();
    cluster.waitActive();
    fs=cluster.getFileSystem();
    Path file1=new Path("/testCorruptBlock");
    DFSTestUtil.createFile(fs,file1,1024,factor,0);
    DFSTestUtil.waitReplication(fs,file1,factor);
    ExtendedBlock block=DFSTestUtil.getFirstBlock(fs,file1);
    outStr=runFsck(conf,0,true,"/");
    System.out.println(outStr);
    assertTrue(outStr.contains(NamenodeFsck.HEALTHY_STATUS));
    File blockFile=MiniDFSCluster.getBlockFile(0,block);
    if (blockFile != null && blockFile.exists()) {
      RandomAccessFile raFile=new RandomAccessFile(blockFile,"rw");
      FileChannel channel=raFile.getChannel();
      String badString="BADBAD";
      int rand=random.nextInt((int)channel.size() / 2);
      raFile.seek(rand);
      raFile.write(badString.getBytes());
      raFile.close();
    }
    try {
      IOUtils.copyBytes(fs.open(file1),new IOUtils.NullOutputStream(),conf,true);
    }
 catch (    IOException ie) {
    }
    dfsClient=new DFSClient(new InetSocketAddress("localhost",cluster.getNameNodePort()),conf);
    blocks=dfsClient.getNamenode().getBlockLocations(file1.toString(),0,Long.MAX_VALUE);
    replicaCount=blocks.get(0).getLocations().length;
    while (replicaCount != factor) {
      try {
        Thread.sleep(100);
      }
 catch (      InterruptedException ignore) {
      }
      blocks=dfsClient.getNamenode().getBlockLocations(file1.toString(),0,Long.MAX_VALUE);
      replicaCount=blocks.get(0).getLocations().length;
    }
    assertTrue(blocks.get(0).isCorrupt());
    outStr=runFsck(conf,1,true,"/");
    System.out.println(outStr);
    assertTrue(outStr.contains(NamenodeFsck.CORRUPT_STATUS));
    assertTrue(outStr.contains("testCorruptBlock"));
  }
  finally {
    if (cluster != null) {
      cluster.shutdown();
    }
  }
}

</code></pre>

<pre class="type-9 type-7 type-1 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Tests that the # of misreplaced replicas is correct
 * @throws IOException
 */
@Test public void testFsckMisPlacedReplicas() throws IOException {
  final short REPL_FACTOR=2;
  short NUM_DN=2;
  final short NUM_BLOCKS=3;
  final long blockSize=512;
  String[] racks={"/rack1","/rack1"};
  String[] hosts={"host1","host2"};
  Configuration conf=new Configuration();
  conf.setLong(DFSConfigKeys.DFS_BLOCK_SIZE_KEY,blockSize);
  MiniDFSCluster cluster=null;
  DistributedFileSystem dfs=null;
  try {
    cluster=new MiniDFSCluster.Builder(conf).numDataNodes(NUM_DN).hosts(hosts).racks(racks).build();
    assertNotNull("Failed Cluster Creation",cluster);
    cluster.waitClusterUp();
    dfs=cluster.getFileSystem();
    assertNotNull("Failed to get FileSystem",dfs);
    final String pathString=new String("/testfile");
    final Path path=new Path(pathString);
    long fileLen=blockSize * NUM_BLOCKS;
    DFSTestUtil.createFile(dfs,path,fileLen,REPL_FACTOR,1);
    NameNode namenode=cluster.getNameNode();
    NetworkTopology nettop=cluster.getNamesystem().getBlockManager().getDatanodeManager().getNetworkTopology();
    nettop.add(DFSTestUtil.getDatanodeDescriptor("/rack2","/host3"));
    NUM_DN++;
    Map<String,String[]> pmap=new HashMap<String,String[]>();
    Writer result=new StringWriter();
    PrintWriter out=new PrintWriter(result,true);
    InetAddress remoteAddress=InetAddress.getLocalHost();
    NamenodeFsck fsck=new NamenodeFsck(conf,namenode,nettop,pmap,out,NUM_DN,REPL_FACTOR,remoteAddress);
    final HdfsFileStatus file=namenode.getRpcServer().getFileInfo(pathString);
    assertNotNull(file);
    Result res=new Result(conf);
    fsck.check(pathString,file,res);
    assertEquals(res.numMisReplicatedBlocks,NUM_BLOCKS);
  }
  finally {
    if (dfs != null) {
      dfs.close();
    }
    if (cluster != null) {
      cluster.shutdown();
    }
  }
}

</code></pre>

<pre class="type-9 type-10 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies boolean conditions
"></span><br>
/** 
 * Test for including the snapshot files in fsck report
 */
@Test public void testFsckForSnapshotFiles() throws Exception {
  final Configuration conf=new HdfsConfiguration();
  MiniDFSCluster cluster=new MiniDFSCluster.Builder(conf).numDataNodes(1).build();
  try {
    String runFsck=runFsck(conf,0,true,"/","-includeSnapshots","-files");
    assertTrue(runFsck.contains("HEALTHY"));
    final String fileName="/srcdat";
    DistributedFileSystem hdfs=cluster.getFileSystem();
    Path file1=new Path(fileName);
    DFSTestUtil.createFile(hdfs,file1,1024,(short)1,1000L);
    hdfs.allowSnapshot(new Path("/"));
    hdfs.createSnapshot(new Path("/"),"mySnapShot");
    runFsck=runFsck(conf,0,true,"/","-includeSnapshots","-files");
    assertTrue(runFsck.contains("/.snapshot/mySnapShot/srcdat"));
    runFsck=runFsck(conf,0,true,"/","-files");
    assertFalse(runFsck.contains("mySnapShot"));
  }
  finally {
    cluster.shutdown();
  }
}

</code></pre>

<pre class="type-9 type-13 type-11 type-7 type-10 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions in iterations
- Verifies assertions inside branch conditions
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
"></span><br>
@Test public void testFsckMoveAndDelete() throws Exception {
  final int MAX_MOVE_TRIES=5;
  DFSTestUtil util=new DFSTestUtil.Builder().setName("TestFsckMoveAndDelete").setNumFiles(5).build();
  MiniDFSCluster cluster=null;
  FileSystem fs=null;
  try {
    Configuration conf=new HdfsConfiguration();
    conf.setLong(DFSConfigKeys.DFS_BLOCKREPORT_INTERVAL_MSEC_KEY,10000L);
    conf.setInt(DFSConfigKeys.DFS_DATANODE_DIRECTORYSCAN_INTERVAL_KEY,1);
    cluster=new MiniDFSCluster.Builder(conf).numDataNodes(4).build();
    String topDir="/srcdat";
    fs=cluster.getFileSystem();
    cluster.waitActive();
    util.createFiles(fs,topDir);
    util.waitReplication(fs,topDir,(short)3);
    String outStr=runFsck(conf,0,true,"/");
    assertTrue(outStr.contains(NamenodeFsck.HEALTHY_STATUS));
    String[] fileNames=util.getFileNames(topDir);
    DFSClient dfsClient=new DFSClient(new InetSocketAddress("localhost",cluster.getNameNodePort()),conf);
    String corruptFileName=fileNames[0];
    ExtendedBlock block=dfsClient.getNamenode().getBlockLocations(corruptFileName,0,Long.MAX_VALUE).get(0).getBlock();
    for (int i=0; i < 4; i++) {
      File blockFile=MiniDFSCluster.getBlockFile(i,block);
      if (blockFile != null && blockFile.exists()) {
        assertTrue(blockFile.delete());
      }
    }
    outStr=runFsck(conf,1,false,"/");
    while (!outStr.contains(NamenodeFsck.CORRUPT_STATUS)) {
      try {
        Thread.sleep(100);
      }
 catch (      InterruptedException ignore) {
      }
      outStr=runFsck(conf,1,false,"/");
    }
    for (int i=0; i < MAX_MOVE_TRIES; i++) {
      outStr=runFsck(conf,1,true,"/","-move");
      assertTrue(outStr.contains(NamenodeFsck.CORRUPT_STATUS));
      String[] newFileNames=util.getFileNames(topDir);
      boolean found=false;
      for (      String f : newFileNames) {
        if (f.equals(corruptFileName)) {
          found=true;
          break;
        }
      }
      assertTrue(found);
    }
    outStr=runFsck(conf,1,true,"/","-move","-delete");
    assertTrue(outStr.contains(NamenodeFsck.CORRUPT_STATUS));
    outStr=runFsck(conf,0,true,"/");
    assertTrue(outStr.contains(NamenodeFsck.HEALTHY_STATUS));
    util.cleanup(fs,topDir);
    if (fs != null) {
      try {
        fs.close();
      }
 catch (      Exception e) {
      }
    }
    cluster.shutdown();
  }
  finally {
    if (fs != null) {
      try {
        fs.close();
      }
 catch (      Exception e) {
      }
    }
    if (cluster != null) {
      cluster.shutdown();
    }
  }
}

</code></pre>

<pre class="type-9 type-13 type-11 type-7 type-10 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions in iterations
- Verifies assertions inside branch conditions
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
"></span><br>
@Test public void testFsckMove() throws Exception {
  Configuration conf=new HdfsConfiguration();
  final int DFS_BLOCK_SIZE=1024;
  final int NUM_DATANODES=4;
  conf.setLong(DFSConfigKeys.DFS_BLOCK_SIZE_KEY,DFS_BLOCK_SIZE);
  conf.setLong(DFSConfigKeys.DFS_BLOCKREPORT_INTERVAL_MSEC_KEY,10000L);
  conf.setInt(DFSConfigKeys.DFS_DATANODE_DIRECTORYSCAN_INTERVAL_KEY,1);
  DFSTestUtil util=new DFSTestUtil("TestFsck",5,3,(5 * DFS_BLOCK_SIZE) + (DFS_BLOCK_SIZE - 1),5 * DFS_BLOCK_SIZE);
  MiniDFSCluster cluster=null;
  FileSystem fs=null;
  try {
    cluster=new MiniDFSCluster.Builder(conf).numDataNodes(NUM_DATANODES).build();
    String topDir="/srcdat";
    fs=cluster.getFileSystem();
    cluster.waitActive();
    util.createFiles(fs,topDir);
    util.waitReplication(fs,topDir,(short)3);
    String outStr=runFsck(conf,0,true,"/");
    assertTrue(outStr.contains(NamenodeFsck.HEALTHY_STATUS));
    DFSClient dfsClient=new DFSClient(new InetSocketAddress("localhost",cluster.getNameNodePort()),conf);
    String fileNames[]=util.getFileNames(topDir);
    CorruptedTestFile ctFiles[]=new CorruptedTestFile[]{new CorruptedTestFile(fileNames[0],Sets.newHashSet(0),dfsClient,NUM_DATANODES,DFS_BLOCK_SIZE),new CorruptedTestFile(fileNames[1],Sets.newHashSet(2,3),dfsClient,NUM_DATANODES,DFS_BLOCK_SIZE),new CorruptedTestFile(fileNames[2],Sets.newHashSet(4),dfsClient,NUM_DATANODES,DFS_BLOCK_SIZE),new CorruptedTestFile(fileNames[3],Sets.newHashSet(0,1,2,3),dfsClient,NUM_DATANODES,DFS_BLOCK_SIZE),new CorruptedTestFile(fileNames[4],Sets.newHashSet(1,2,3,4),dfsClient,NUM_DATANODES,DFS_BLOCK_SIZE)};
    int totalMissingBlocks=0;
    for (    CorruptedTestFile ctFile : ctFiles) {
      totalMissingBlocks+=ctFile.getTotalMissingBlocks();
    }
    for (    CorruptedTestFile ctFile : ctFiles) {
      ctFile.removeBlocks();
    }
    while (true) {
      outStr=runFsck(conf,1,false,"/");
      String numCorrupt=null;
      for (      String line : outStr.split(LINE_SEPARATOR)) {
        Matcher m=numCorruptBlocksPattern.matcher(line);
        if (m.matches()) {
          numCorrupt=m.group(1);
          break;
        }
      }
      if (numCorrupt == null) {
        throw new IOException("failed to find number of corrupt " + "blocks in fsck output.");
      }
      if (numCorrupt.equals(Integer.toString(totalMissingBlocks))) {
        assertTrue(outStr.contains(NamenodeFsck.CORRUPT_STATUS));
        break;
      }
      try {
        Thread.sleep(100);
      }
 catch (      InterruptedException ignore) {
      }
    }
    outStr=runFsck(conf,1,false,"/","-move");
    assertTrue(outStr.contains(NamenodeFsck.CORRUPT_STATUS));
    for (    CorruptedTestFile ctFile : ctFiles) {
      ctFile.checkSalvagedRemains();
    }
    outStr=runFsck(conf,1,true,"/","-delete");
    assertTrue(outStr.contains(NamenodeFsck.CORRUPT_STATUS));
    outStr=runFsck(conf,0,true,"/");
    assertTrue(outStr.contains(NamenodeFsck.HEALTHY_STATUS));
    util.cleanup(fs,topDir);
  }
  finally {
    if (fs != null) {
      try {
        fs.close();
      }
 catch (      Exception e) {
      }
    }
    if (cluster != null) {
      cluster.shutdown();
    }
  }
}

</code></pre>

<pre class="type-9 type-10 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies boolean conditions
"></span><br>
/** 
 * Test for checking fsck command on illegal arguments should print the proper
 * usage.
 */
@Test public void testToCheckTheFsckCommandOnIllegalArguments() throws Exception {
  MiniDFSCluster cluster=null;
  try {
    Configuration conf=new HdfsConfiguration();
    cluster=new MiniDFSCluster.Builder(conf).build();
    String fileName="/test.txt";
    Path filePath=new Path(fileName);
    FileSystem fs=cluster.getFileSystem();
    DFSTestUtil.createFile(fs,filePath,1L,(short)1,1L);
    DFSTestUtil.waitReplication(fs,filePath,(short)1);
    String outStr=runFsck(conf,-1,true,fileName,"-thisIsNotAValidFlag");
    System.out.println(outStr);
    assertTrue(!outStr.contains(NamenodeFsck.HEALTHY_STATUS));
    outStr=runFsck(conf,-1,true,"/",fileName);
    System.out.println(outStr);
    assertTrue(!outStr.contains(NamenodeFsck.HEALTHY_STATUS));
    fs.delete(filePath,true);
  }
  finally {
    if (cluster != null) {
      cluster.shutdown();
    }
  }
}

</code></pre>

<pre class="type-9 type-7 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
"></span><br>
@Test public void testFsckNonExistent() throws Exception {
  DFSTestUtil util=new DFSTestUtil.Builder().setName("TestFsck").setNumFiles(20).build();
  MiniDFSCluster cluster=null;
  FileSystem fs=null;
  try {
    Configuration conf=new HdfsConfiguration();
    conf.setLong(DFSConfigKeys.DFS_BLOCKREPORT_INTERVAL_MSEC_KEY,10000L);
    cluster=new MiniDFSCluster.Builder(conf).numDataNodes(4).build();
    fs=cluster.getFileSystem();
    util.createFiles(fs,"/srcdat");
    util.waitReplication(fs,"/srcdat",(short)3);
    String outStr=runFsck(conf,0,true,"/non-existent");
    assertEquals(-1,outStr.indexOf(NamenodeFsck.HEALTHY_STATUS));
    System.out.println(outStr);
    util.cleanup(fs,"/srcdat");
  }
  finally {
    if (fs != null) {
      try {
        fs.close();
      }
 catch (      Exception e) {
      }
    }
    if (cluster != null) {
      cluster.shutdown();
    }
  }
}

</code></pre>

<pre class="type-9 type-7 type-10 type-6 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test fsck with symlinks in the filesystem 
 */
@Test public void testFsckSymlink() throws Exception {
  final DFSTestUtil util=new DFSTestUtil.Builder().setName(getClass().getSimpleName()).setNumFiles(1).build();
  final Configuration conf=new HdfsConfiguration();
  conf.setLong(DFSConfigKeys.DFS_BLOCKREPORT_INTERVAL_MSEC_KEY,10000L);
  MiniDFSCluster cluster=null;
  FileSystem fs=null;
  try {
    final long precision=1L;
    conf.setLong(DFSConfigKeys.DFS_NAMENODE_ACCESSTIME_PRECISION_KEY,precision);
    conf.setLong(DFSConfigKeys.DFS_BLOCKREPORT_INTERVAL_MSEC_KEY,10000L);
    cluster=new MiniDFSCluster.Builder(conf).numDataNodes(4).build();
    fs=cluster.getFileSystem();
    final String fileName="/srcdat";
    util.createFiles(fs,fileName);
    final FileContext fc=FileContext.getFileContext(cluster.getConfiguration(0));
    final Path file=new Path(fileName);
    final Path symlink=new Path("/srcdat-symlink");
    fc.createSymlink(file,symlink,false);
    util.waitReplication(fs,fileName,(short)3);
    long aTime=fc.getFileStatus(symlink).getAccessTime();
    Thread.sleep(precision);
    setupAuditLogs();
    String outStr=runFsck(conf,0,true,"/");
    verifyAuditLogs();
    assertEquals(aTime,fc.getFileStatus(symlink).getAccessTime());
    System.out.println(outStr);
    assertTrue(outStr.contains(NamenodeFsck.HEALTHY_STATUS));
    assertTrue(outStr.contains("Total symlinks:\t\t1"));
    util.cleanup(fs,fileName);
  }
  finally {
    if (fs != null) {
      try {
        fs.close();
      }
 catch (      Exception e) {
      }
    }
    if (cluster != null) {
      cluster.shutdown();
    }
  }
}

</code></pre>

<pre class="type-9 type-13 type-7 type-10 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions in iterations
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
"></span><br>
/** 
 * check if option -list-corruptfiles of fsck command works properly 
 */
@Test public void testFsckListCorruptFilesBlocks() throws Exception {
  Configuration conf=new Configuration();
  conf.setLong(DFSConfigKeys.DFS_BLOCKREPORT_INTERVAL_MSEC_KEY,1000);
  conf.setInt(DFSConfigKeys.DFS_DATANODE_DIRECTORYSCAN_INTERVAL_KEY,1);
  FileSystem fs=null;
  MiniDFSCluster cluster=null;
  try {
    cluster=new MiniDFSCluster.Builder(conf).build();
    cluster.waitActive();
    fs=cluster.getFileSystem();
    DFSTestUtil util=new DFSTestUtil.Builder().setName("testGetCorruptFiles").setNumFiles(3).setMaxLevels(1).setMaxSize(1024).build();
    util.createFiles(fs,"/corruptData",(short)1);
    util.waitReplication(fs,"/corruptData",(short)1);
    String outStr=runFsck(conf,0,false,"/corruptData","-list-corruptfileblocks");
    System.out.println("1. good fsck out: " + outStr);
    assertTrue(outStr.contains("has 0 CORRUPT files"));
    final String bpid=cluster.getNamesystem().getBlockPoolId();
    for (int i=0; i < 4; i++) {
      for (int j=0; j <= 1; j++) {
        File storageDir=cluster.getInstanceStorageDir(i,j);
        File data_dir=MiniDFSCluster.getFinalizedDir(storageDir,bpid);
        List<File> metadataFiles=MiniDFSCluster.getAllBlockMetadataFiles(data_dir);
        if (metadataFiles == null)         continue;
        for (        File metadataFile : metadataFiles) {
          File blockFile=Block.metaToBlockFile(metadataFile);
          assertTrue("Cannot remove file.",blockFile.delete());
          assertTrue("Cannot remove file.",metadataFile.delete());
        }
      }
    }
    final NamenodeProtocols namenode=cluster.getNameNodeRpc();
    CorruptFileBlocks corruptFileBlocks=namenode.listCorruptFileBlocks("/corruptData",null);
    int numCorrupt=corruptFileBlocks.getFiles().length;
    while (numCorrupt == 0) {
      Thread.sleep(1000);
      corruptFileBlocks=namenode.listCorruptFileBlocks("/corruptData",null);
      numCorrupt=corruptFileBlocks.getFiles().length;
    }
    outStr=runFsck(conf,-1,true,"/corruptData","-list-corruptfileblocks");
    System.out.println("2. bad fsck out: " + outStr);
    assertTrue(outStr.contains("has 3 CORRUPT files"));
    util.createFiles(fs,"/goodData");
    outStr=runFsck(conf,0,true,"/goodData","-list-corruptfileblocks");
    System.out.println("3. good fsck out: " + outStr);
    assertTrue(outStr.contains("has 0 CORRUPT files"));
    util.cleanup(fs,"/corruptData");
    util.cleanup(fs,"/goodData");
  }
  finally {
    if (cluster != null) {
      cluster.shutdown();
    }
  }
}

</code></pre>

<pre class="type-9 type-7 type-10 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
"></span><br>
@Test public void testFsckOpenFiles() throws Exception {
  DFSTestUtil util=new DFSTestUtil.Builder().setName("TestFsck").setNumFiles(4).build();
  MiniDFSCluster cluster=null;
  FileSystem fs=null;
  try {
    Configuration conf=new HdfsConfiguration();
    conf.setLong(DFSConfigKeys.DFS_BLOCKREPORT_INTERVAL_MSEC_KEY,10000L);
    cluster=new MiniDFSCluster.Builder(conf).numDataNodes(4).build();
    String topDir="/srcdat";
    String randomString="HADOOP  ";
    fs=cluster.getFileSystem();
    cluster.waitActive();
    util.createFiles(fs,topDir);
    util.waitReplication(fs,topDir,(short)3);
    String outStr=runFsck(conf,0,true,"/");
    assertTrue(outStr.contains(NamenodeFsck.HEALTHY_STATUS));
    Path openFile=new Path(topDir + "/openFile");
    FSDataOutputStream out=fs.create(openFile);
    int writeCount=0;
    while (writeCount != 100) {
      out.write(randomString.getBytes());
      writeCount++;
    }
    outStr=runFsck(conf,0,true,topDir);
    System.out.println(outStr);
    assertTrue(outStr.contains(NamenodeFsck.HEALTHY_STATUS));
    assertFalse(outStr.contains("OPENFORWRITE"));
    outStr=runFsck(conf,0,true,topDir,"-openforwrite");
    System.out.println(outStr);
    assertTrue(outStr.contains("OPENFORWRITE"));
    assertTrue(outStr.contains("openFile"));
    out.close();
    outStr=runFsck(conf,0,true,topDir);
    System.out.println(outStr);
    assertTrue(outStr.contains(NamenodeFsck.HEALTHY_STATUS));
    assertFalse(outStr.contains("OPENFORWRITE"));
    util.cleanup(fs,topDir);
    if (fs != null) {
      try {
        fs.close();
      }
 catch (      Exception e) {
      }
    }
    cluster.shutdown();
  }
  finally {
    if (fs != null) {
      try {
        fs.close();
      }
 catch (      Exception e) {
      }
    }
    if (cluster != null) {
      cluster.shutdown();
    }
  }
}

</code></pre>

<script>$(document).ready(function() {
  $('pre code').each(function(i, block) {
    hljs.highlightBlock(block);
  });
});</script>
