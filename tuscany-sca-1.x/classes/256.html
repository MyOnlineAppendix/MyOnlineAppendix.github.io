<h3 style="margin:0px">Class: org.apache.tuscany.sca.vtest.javaapi.annotations.property.PropertyAnnotationTestCase (9 methods) </h3><br><pre style="padding:0"><code class="html"><div id="tags"><button id="6"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('6')" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value "><kbd id="tag-6"class="label-info"style="display: inline-block;font-size:7pt" >EqualityVerifier&nbsp;(7)</kbd></button>&nbsp;<button id="1"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('1')" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls"><kbd id="tag-1"class="label-info"style="display: inline-block;font-size:7pt" >InternalCallVerifier&nbsp;(7)</kbd></button>&nbsp;<button id="4"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('4')" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes"><kbd id="tag-4"class="label-info"style="display: inline-block;font-size:7pt" >HybridVerifier&nbsp;(5)</kbd></button>&nbsp;<button id="3"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('3')" data-toggle="tooltip" title="Verifies whether objects are null"><kbd id="tag-3"class="label-info"style="display: inline-block;font-size:7pt" >NullVerifier&nbsp;(3)</kbd></button>&nbsp;<button id="15"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('15')" data-toggle="tooltip" title="Verifies boolean conditions"><kbd id="tag-15"class="label-info"style="display: inline-block;font-size:7pt" >BooleanVerifier&nbsp;(3)</kbd></button>&nbsp;<button id="2"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('2')" data-toggle="tooltip" title="Is not executed with the test suite"><kbd id="tag-2"class="label-info"style="display: inline-block;font-size:7pt" >IgnoredMethod&nbsp;(1)</kbd></button>&nbsp;<button id="5"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('5')" data-toggle="tooltip" title="Releases resources used by the test cases"><kbd id="tag-5"class="label-info"style="display: inline-block;font-size:7pt" >TestCleaner&nbsp;(1)</kbd></button>&nbsp;</div></code></pre><center><button onclick="showBlocks()" style="margin:6px">Update filter <span class="glyphicon glyphicon-refresh" aria-hidden="true"></span> </button></center><br>
<pre class="type-1 type-3 type-6 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Lines 1141 to 1162:<br>
 * 1.8.5. "@Constructor"<br>
 * ...<br>
 * The "@Constructor" annotation is used to mark a particular constructor to
 * use when instantiating a Java component implementation.<br>
 * The "@Constructor" annotation has the following attribute:<br>
 * <li>value (optional) � identifies the property/reference names that
 * correspond to each of the constructor arguments. The position in the
 * array determines which of the arguments are being named.</li>
 * <p>
 * cService1 - "@Constructor" without value and constructor arguments<br>
 * cService2 - "@Constructor" without value but with constructor arguments<br>
 * cService3 - "@Constructor" with values and constructor arguments<br>
 * cService4 - "@Constructor" with values and constructor arguments where
 * value, property and parameter names are same<br>
 * cService5 - "@Constructor" with switched values and constructor arguments<br>
 * cService6 - "@Constructor" with wrong values<br>
 */
@Test public void atProperty6() throws Exception {
  Assert.assertNull(cService1.getB1Name());
  Assert.assertNull(cService1.getP2());
  Assert.assertEquals(0,cService1.getP3());
  Assert.assertNull(cService1.getP4());
  Assert.assertEquals("NoArgument",cService1.getConstructor());
  Assert.assertEquals("BService",cService2.getB1Name());
  Assert.assertEquals("p2",cService2.getP2());
  Assert.assertEquals(3,cService2.getP3());
  Assert.assertEquals("p4",cService2.getP4());
  Assert.assertEquals("AllArguments",cService2.getConstructor());
  Assert.assertEquals("BService",cService3.getB1Name());
  Assert.assertEquals("p2",cService3.getP2());
  Assert.assertEquals(3,cService3.getP3());
  Assert.assertEquals("p4",cService3.getP4());
  Assert.assertEquals("AllArguments",cService3.getConstructor());
  Assert.assertEquals("BService",cService4.getB1Name());
  Assert.assertEquals("p2",cService4.getP2());
  Assert.assertEquals(3,cService4.getP3());
  Assert.assertEquals("p4",cService4.getP4());
  Assert.assertEquals("AllArguments",cService4.getConstructor());
  Assert.assertEquals("BService",cService5.getB1Name());
  Assert.assertEquals("p4",cService5.getP2());
  Assert.assertEquals(3,cService5.getP3());
  Assert.assertEquals("p2",cService5.getP4());
  Assert.assertEquals("SwitchedValues",cService5.getConstructor());
}

</code></pre>

<pre class="type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies whether objects/variable are equal to an expected value 
"></span><br>
/** 
 * Lines 1349 to 1352:<br>
 * Properties may also be injected via public setter methods even when the
 * "@Property" annotation is not present. However, the
 * @Property annotation must be used in order to inject a property onto a
 * non-public field. In the case where there is no "@Property"
 * annotation, the name of the property is the same as the name of
 * the field or setter.<br>
 * <p>
 * p13 is an un-annotated public field which should be injected
 * via field<br>
 */
@Test public void atProperty2() throws Exception {
  Assert.assertEquals("p13",anotherAService.getP13());
}

</code></pre>

<pre class="type-1 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
"></span><br>
/** 
 * Lines 1369 to 1370:<br>
 * If the property is defined as an array or as a java.util.Collection, then
 * the implied component type has a property with a many attribute set to
 * true.<br>
 * <p>
 * p19 - a List and injected via field with no element<br>
 * p20 - a List and injected via setter<br>
 * p21 - an array and injected via field<br>
 */
@Test public void atProperty5() throws Exception {
  Assert.assertEquals(0,aService.getP19Size());
  Assert.assertEquals(1,aService.getP20Size());
  Assert.assertEquals("p20",aService.getP20(0));
  Assert.assertEquals(3,aService.getP21Size());
  Assert.assertEquals(2,aService.getP21(0));
  Assert.assertEquals(1,aService.getP21(1));
  Assert.assertEquals(21,aService.getP21(2));
}

</code></pre>

<pre class="type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Releases resources used by the test cases">TestCleaner</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Releases resources used by the test cases
"></span><br>
@AfterClass public static void destroy() throws Exception {
  System.out.println("Cleaning up");
  ServiceFinder.cleanup();
}

</code></pre>

<pre class="type-1 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
"></span><br>
/** 
 * Lines 1343 to 1348:<br>
 * The "@Property" annotation type is used to annotate a Java class field or
 * a setter method that is used to inject an SCA property value. The type of
 * the property injected, which can be a simple Java type or a complex Java
 * type, is defined by the type of the Java class field or the type of the
 * setter method input argument.<br>
 * The "@Property" annotation may be used on protected or public fields and
 * on setter methods or on a constructor method.<br>
 * <p>
 * p1 - simple Java type injected via field<br>
 * p2 - simple Java type injected via field<br>
 * p3 - simple Java type injected via setter<br>
 * p4 - simple Java type injected via setter and required=true<br>
 * p5 - simple Java type injected via constructor parameter<br>
 * p6 - simple Java type injected via constructor parameter<br>
 * p7 - complex Java type injected via field and required=true<br>
 * p8 - complex Java type injected via field<br>
 * p9 - complex Java type injected via setter<br>
 * p10 - complex Java type injected via setter<br>
 * p11 - complex Java type injected via constructor parameter<br>
 * p12 - complex Java type injected via constructor parameter<br>
 */
@Test public void atProperty1() throws Exception {
  Assert.assertEquals("p1",aService.getP1());
  Assert.assertEquals("p2",aService.getP2());
  Assert.assertEquals("p3",aService.getP3());
  Assert.assertEquals("p4",aService.getP4());
  Assert.assertEquals("p5",aService.getP5());
  Assert.assertEquals("p6",aService.getP6());
  Assert.assertEquals("p7.aString",aService.getP7AString());
  Assert.assertEquals(7,aService.getP7BInt());
  Assert.assertEquals("p8.aString",aService.getP8AString());
  Assert.assertEquals(8,aService.getP8BInt());
  Assert.assertEquals("p9.aString",aService.getP9AString());
  Assert.assertEquals(9,aService.getP9BInt());
  Assert.assertEquals("p10.aString",aService.getP10AString());
  Assert.assertEquals(10,aService.getP10BInt());
  Assert.assertEquals("p11.aString",aService.getP11AString());
  Assert.assertEquals(11,aService.getP11BInt());
  Assert.assertEquals("p12.aString",aService.getP12AString());
  Assert.assertEquals(12,aService.getP12BInt());
}

</code></pre>

<pre class="type-1 type-3 type-6 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Lines 1355 to 1357:<br>
 * The "@Property" annotation has the following attributes:<br>
 * <li>name (optional) � the name of the property, defaults to the name of
 * the field of the Java class</li>
 * <li>required (optional) � specifies whether injection is required,
 * defaults to false</li>
 * <p>
 * p15 - injected via field with different name "pFifteen"<br>
 * p16 - injected via setter with different name "pSixteen"<br>
 * p17 - injected via field but not defined in composite<br>
 * p18 - injected via setter but not defined in composite<br>
 * @TODO - Need to test required=true but not defined in composite (The
 * specification does not describe the proper behaviour in this
 * situation.)
 */
@Test public void atProperty4() throws Exception {
  Assert.assertEquals("p15",aService.getP15());
  Assert.assertEquals("p16",aService.getP16());
  Assert.assertNull(aService.getP17());
  Assert.assertNull(aService.getP18());
}

</code></pre>

<pre class="type-1 type-15 type-6 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Lines 1349 to 1352:<br>
 * 1.8.13. "@Property"<br>
 * ...<br>
 * Properties may also be injected via public setter methods even when the
 * "@Property" annotation is not present. However, the "@Property"
 * annotation must be used in order to inject a property onto a non-public
 * field. In the case where there is no "@Property" annotation, the name of
 * the property is the same as the name of the field or setter.
 * <p>
 * p24 is un-annotated protected field which should be injected via public
 * setter<br>
 * p25 is un-annotated private field which should be injected via public
 * setter<br>
 */
@Test public void atProperty8() throws Exception {
  Assert.assertEquals("p24",anotherAService.getP24());
  Assert.assertTrue(anotherAService.getP24SetterIsCalled());
  Assert.assertEquals("p25",anotherAService.getP25());
  Assert.assertTrue(anotherAService.getP25SetterIsCalled());
}

</code></pre>

<pre class="type-1 type-15 type-3 type-2 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Is not executed with the test suite">IgnoredMethod</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects are null
- Is not executed with the test suite
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Lines 1349 to 1352:<br>
 * 1.8.13. "@Property"<br>
 * ...<br>
 * Properties may also be injected via public setter methods even when the
 * "@Property" annotation is not present. However, the "@Property"
 * annotation must be used in order to inject a property onto a non-public
 * field. In the case where there is no "@Property" annotation, the name of
 * the property is the same as the name of the field or setter.
 * <p>
 * p22 is unannotated protected field which should not be injected p23 is
 * un-annotated protected which should not be injected via protected setter<br>
 */
@Test @Ignore("JIRA-2289 - p23 failed") public void atProperty7() throws Exception {
  Assert.assertNull(anotherAService.getP22());
  Assert.assertNull(anotherAService.getP23());
  Assert.assertFalse(anotherAService.getP23SetterIsCalled());
}

</code></pre>

<pre class="type-1 type-15 type-6 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Line 1353:<br>
 * Where there is both a setter method and a field for a property, the
 * setter method is used.<br>
 * <p>
 * p14 is an un-annotated public field, it should be injected via public
 * setter<br>
 */
@Test public void atProperty3() throws Exception {
  Assert.assertEquals("p14",anotherAService.getP14());
  Assert.assertTrue(anotherAService.getP14SetterIsCalled());
}

</code></pre>

<script>$(document).ready(function() {
  $('pre code').each(function(i, block) {
    hljs.highlightBlock(block);
  });
});</script>
