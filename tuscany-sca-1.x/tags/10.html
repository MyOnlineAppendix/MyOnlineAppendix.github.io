<h3><span class=" glyphicon glyphicon-tag"/>&nbspLogger</h3><kbd>Invokes logging operations</kbd><br><br><br><h4 style="margin:0px">Class: domainmgr.DomainManagerBasicTestCase </h4><pre class="type-10 type-9 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Invokes logging operations">Logger</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Invokes logging operations
- Executes methods or other tests from the same test unit
"></span><br>
@Test public void test() throws Exception {
  Process domainMgr=null;
  TestNode tripsNode=null;
  TestNode toursNode=null;
  try {
    System.out.println("Starting domain manager");
    String[] domainCommand={"" + home + "/bin/java","-cp","" + classpath + "","org.apache.tuscany.sca.node.launcher.DomainManagerLauncher"};
    String userdir=System.getProperty("user.dir");
    domainMgr=Runtime.getRuntime().exec(domainCommand,null,new File(userdir + "/target/test-classes/domain/"));
    InputStream domainErr=domainMgr.getErrorStream();
    domainErrReader=new BufferedReader(new InputStreamReader(domainErr));
    InputStream domainOut=domainMgr.getInputStream();
    domainOutReader=new BufferedReader(new InputStreamReader(domainOut));
    OutputStream domainIn=domainMgr.getOutputStream();
    while (true) {
      checkDomainOut();
      String line=domainErrReader.readLine();
      if (line == null) {
        throw new IllegalStateException("Error starting Domain Manager process");
      }
      System.out.println("DomainMgr.e: " + line);
      if (line.contains("SEVERE:")) {
        throw new IllegalStateException("Domain manager reported error: " + line);
      }
      if (line.contains("INFO: Press 'q' to quit, 'r' to restart.")) {
        System.out.println("Domain manager started successfully");
        break;
      }
    }
    checkDomainOut();
    tripsNode=new TestNode("TripsNode",userdir + "/../trips/target/");
    tripsNode.start();
    toursNode=new TestNode("ToursNode",userdir + "/../tours/target/");
    toursNode.start();
    SCANode clientNode=SCANodeFactory.newInstance().createSCANodeFromURL("http://localhost:9990/node-config/ClientNode");
    checkDomainErr();
    checkDomainOut();
    clientNode.start();
    Runnable client=((SCAClient)clientNode).getService(Runnable.class,"TestClient/Runnable");
    client.run();
    tripsNode.checkNodeErr();
    tripsNode.checkNodeOut();
    toursNode.checkNodeErr();
    toursNode.checkNodeOut();
    clientNode.stop();
    toursNode.stopNode();
    tripsNode.stopNode();
    System.out.println("Stopping domain manager");
    domainIn.write('q');
    domainIn.flush();
    while (true) {
      checkDomainOut();
      String line=domainErrReader.readLine();
      if (line == null) {
        throw new IllegalStateException("Error stopping Domain Manager process");
      }
      System.out.println("DomainMgr.e: " + line);
      if (line.contains("SEVERE:")) {
        throw new IllegalStateException("Domain manager reported error: " + line);
      }
      if (line.contains("INFO: SCA Domain Manager is now stopped.")) {
        System.out.println("Domain manager stopped successfully");
        break;
      }
    }
    checkDomainOut();
    int value=domainMgr.waitFor();
    if (value != 0) {
      throw new IllegalStateException("Domain Manager process exit value " + value);
    }
  }
 catch (  Exception ex) {
    if (tripsNode != null) {
      tripsNode.destroyNode();
    }
    if (toursNode != null) {
      toursNode.destroyNode();
    }
    if (domainMgr != null) {
      System.out.println("Destroying domain");
      try {
        domainMgr.destroy();
      }
 catch (      Exception e) {
      }
    }
    throw ex;
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: domainmgr.DomainManagerErrorTestCase </h4><pre class="type-10 type-9 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Invokes logging operations">Logger</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Invokes logging operations
- Executes methods or other tests from the same test unit
"></span><br>
@Test public void test() throws Exception {
  TestNode paymentNode=null;
  try {
    System.out.println("Starting domain manager");
    String[] domainCommand={"" + home + "/bin/java","-cp","" + classpath + "","org.apache.tuscany.sca.node.launcher.DomainManagerLauncher"};
    String userdir=System.getProperty("user.dir");
    domainMgr=runtime.exec(domainCommand,null,new File(userdir + "/target/test-classes/domain/"));
    InputStream domainErr=domainMgr.getErrorStream();
    domainErrReader=new BufferedReader(new InputStreamReader(domainErr));
    InputStream domainOut=domainMgr.getInputStream();
    domainOutReader=new BufferedReader(new InputStreamReader(domainOut));
    domainIn=domainMgr.getOutputStream();
    while (true) {
      checkDomainOut();
      String line=domainErrReader.readLine();
      if (line == null) {
        throw new IllegalStateException("Error starting Domain Manager process");
      }
      System.out.println("DomainMgr.e: " + line);
      if (line.contains("SEVERE:")) {
        throw new IllegalStateException("Domain manager reported error: " + line);
      }
      if (line.contains("INFO: Press 'q' to quit, 'r' to restart.")) {
        System.out.println("Domain manager started successfully");
        break;
      }
    }
    checkDomainOut();
    paymentNode=new TestNode("PaymentNode",userdir + "/../payment/target/");
    paymentNode.start();
    paymentNode.stopNode();
    stopDomain();
  }
 catch (  Exception ex) {
    if (paymentNode != null) {
      paymentNode.destroyNode();
    }
    if (domainMgr != null) {
      System.out.println("Destroying domain");
      try {
        domainMgr.destroy();
      }
 catch (      Exception e) {
      }
    }
    throw ex;
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: domainmgr.DomainManagerTransactionTestCase </h4><pre class="type-10 type-9 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Invokes logging operations">Logger</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Invokes logging operations
- Executes methods or other tests from the same test unit
"></span><br>
@Test public void test() throws Exception {
  TestNode paymentNode=null;
  try {
    System.out.println("Starting domain manager");
    String[] domainCommand={"" + home + "/bin/java","-cp","" + classpath + "","org.apache.tuscany.sca.node.launcher.DomainManagerLauncher"};
    String userdir=System.getProperty("user.dir");
    domainMgr=runtime.exec(domainCommand,null,new File(userdir + "/target/test-classes/domain/"));
    InputStream domainErr=domainMgr.getErrorStream();
    domainErrReader=new BufferedReader(new InputStreamReader(domainErr));
    InputStream domainOut=domainMgr.getInputStream();
    domainOutReader=new BufferedReader(new InputStreamReader(domainOut));
    domainIn=domainMgr.getOutputStream();
    while (true) {
      checkDomainOut();
      String line=domainErrReader.readLine();
      if (line == null) {
        throw new IllegalStateException("Error starting Domain Manager process");
      }
      System.out.println("DomainMgr.e: " + line);
      if (line.contains("SEVERE:")) {
        throw new IllegalStateException("Domain manager reported error: " + line);
      }
      if (line.contains("INFO: Press 'q' to quit, 'r' to restart.")) {
        System.out.println("Domain manager started successfully");
        break;
      }
    }
    checkDomainOut();
    paymentNode=new TestNode("PaymentNode",userdir + "/../payment/target/");
    paymentNode.start();
    paymentNode.stopNode();
    stopDomain();
  }
 catch (  Exception ex) {
    if (paymentNode != null) {
      paymentNode.destroyNode();
    }
    if (domainMgr != null) {
      System.out.println("Destroying domain");
      try {
        domainMgr.destroy();
      }
 catch (      Exception e) {
      }
    }
    throw ex;
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.tuscany.databinding.jaxb.axiom.JAXB2OMTestCase </h4><pre class="type-10 type-9 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Invokes logging operations">Logger</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Invokes logging operations
- Executes methods or other tests from the same test unit
"></span><br>
@Test public void testTransformElement() throws Exception {
  JAXBElement<PurchaseOrderType> po=createPO();
  DataType<?> sourceDataType=new DataTypeImpl<XMLType>(PurchaseOrderType.class,XMLType.UNKNOWN);
  DataType<?> targetDataType=new DataTypeImpl<XMLType>(PurchaseOrderType.class,new XMLType(po.getName(),null));
  TransformationContext tContext=new TransformationContextImpl();
  tContext.setSourceDataType(sourceDataType);
  tContext.setTargetDataType(targetDataType);
  JAXBContextHelper.createJAXBContext(tContext,true);
  long start=System.currentTimeMillis();
  JAXB2OMElement t1=new JAXB2OMElement();
  OMElement om=t1.transform(po,tContext);
  long duration1=System.currentTimeMillis() - start;
  StringWriter sw=new StringWriter();
  om.serializeAndConsume(sw);
  System.out.println(sw.toString());
  start=System.currentTimeMillis();
  Node node=new JAXB2Node().transform(po,tContext);
  XMLStreamReader reader=new Node2XMLStreamReader().transform(node,null);
  om=new StAXOMBuilder(reader).getDocumentElement();
  sw=new StringWriter();
  om.serializeAndConsume(sw);
  long duration2=System.currentTimeMillis() - start;
  System.out.println(sw.toString());
  System.out.println(duration1 + " vs. " + duration2);
}

</code></pre>

<br>
<pre class="type-10 type-9 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Invokes logging operations">Logger</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Invokes logging operations
- Executes methods or other tests from the same test unit
"></span><br>
@Test public void testTransformType() throws Exception {
  JAXBElement<PurchaseOrderType> po=createPO();
  DataType<?> sourceDataType=new DataTypeImpl<XMLType>(PurchaseOrderType.class,XMLType.UNKNOWN);
  DataType<?> targetDataType=new DataTypeImpl<XMLType>(PurchaseOrderType.class,new XMLType(po.getName(),null));
  TransformationContext tContext=new TransformationContextImpl();
  tContext.setSourceDataType(sourceDataType);
  tContext.setTargetDataType(targetDataType);
  OMElement om=new JAXB2OMElement().transform(po.getValue(),tContext);
  StringWriter sw=new StringWriter();
  om.serializeAndConsume(sw);
  System.out.println(sw.toString());
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.tuscany.sca.aspectj.TracingTestCase </h4><pre class="type-10 type-9 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Invokes logging operations">Logger</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Invokes logging operations
- Executes methods or other tests from the same test unit
"></span><br>
@Test public void testAOP(){
  Logger log=Logger.getLogger(getClass().getName());
  System.out.println("doSomething()");
  log.info("Hello, Log");
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.tuscany.sca.binding.gdata.GoogleContactsServiceTestCase </h4><pre class="type-10 type-9 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Invokes logging operations">Logger</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Invokes logging operations
- Executes methods or other tests from the same test unit
"></span><br>
@Test public void testClientDelete() throws Exception {
  if (testService == null) {
    return;
  }
  Entry newEntry=new Entry();
  newEntry.setTitle(new PlainTextConstruct("contactEntryShouldNotApear"));
  newEntry.setContent(new PlainTextConstruct("contactByBloggerShouldNotAppear"));
  Entry postedEntry=testService.clientPost(newEntry);
  Thread.sleep(Constants.SLEEP_INTERVAL);
  int idStartPosition=postedEntry.getId().lastIndexOf("/");
  String postedEntryID=postedEntry.getId().substring(idStartPosition + 1);
  for (int i=0; i < 5; i++) {
    try {
      Entry entry00=testService.clientGetEntry(postedEntryID);
      break;
    }
 catch (    Exception e) {
      if (i < 4) {
        System.out.println("Get failed, retrying...");
      }
 else {
        throw e;
      }
    }
  }
  for (int i=0; i < 5; i++) {
    try {
      testService.clientDelete(postedEntryID);
      break;
    }
 catch (    Exception e) {
      if (i < 4) {
        System.out.println("Delete failed, retrying...");
      }
 else {
        throw e;
      }
    }
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.tuscany.sca.binding.ws.axis2.itests.pojo.POJOWSTestCase </h4><pre class="type-10 type-9 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Invokes logging operations">Logger</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Invokes logging operations
- Executes methods or other tests from the same test unit
"></span><br>
@Test public void testWS() throws Exception {
  SCAContribution contrib=new SCAContribution("c1","target/test-classes");
  SCANode node=SCANodeFactory.newInstance().createSCANode("org/apache/tuscany/sca/binding/ws/axis2/itests/pojo/test.composite",contrib);
  node.start();
  node.stop();
  System.out.println("Test server stopped");
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.tuscany.sca.binding.ws.wsdlgen.Interface2WSDLGeneratorTestCase </h4><pre class="type-10 type-9 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Invokes logging operations">Logger</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Invokes logging operations
- Executes methods or other tests from the same test unit
"></span><br>
@Test public void testGenerate() throws Exception {
  DefaultJavaInterfaceFactory iFactory=new DefaultJavaInterfaceFactory();
  JavaInterface iface=iFactory.createJavaInterface(TestJavaInterface.class);
  DefaultDataBindingExtensionPoint dataBindings=new DefaultDataBindingExtensionPoint();
  JAXWSFaultExceptionMapper faultExceptionMapper=new JAXWSFaultExceptionMapper(dataBindings,null);
  new JAXWSJavaInterfaceProcessor(dataBindings,faultExceptionMapper,null).visitInterface(iface);
  new DataBindingJavaInterfaceProcessor(dataBindings).visitInterface(iface);
  DefaultModelFactoryExtensionPoint modelFactories=new DefaultModelFactoryExtensionPoint();
  WSDLDefinition wsdlDefinition=new DefaultWSDLFactory(modelFactories).createWSDLDefinition();
  DefaultXSDFactory factory=new DefaultXSDFactory();
  Interface2WSDLGenerator generator=new Interface2WSDLGenerator(false,new XSDModelResolver(null,null),dataBindings,factory,null);
  Definition definition=generator.generate(iface,wsdlDefinition);
  WSDLWriter writer=generator.getFactory().newWSDLWriter();
  StringWriter sw=new StringWriter();
  writer.writeWSDL(definition,sw);
  System.out.println(sw.toString());
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.tuscany.sca.databinding.jaxb.JAXBContextCacheTestCase </h4><pre class="type-10 type-9 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Invokes logging operations">Logger</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Invokes logging operations
- Executes methods or other tests from the same test unit
"></span><br>
@Test public void testPerf() throws JAXBException {
  JAXBContextCache cache=new JAXBContextCache();
  long start=System.currentTimeMillis();
  for (int i=0; i < 100; i++) {
    JAXBContext context=JAXBContext.newInstance(String.class);
  }
  long end=System.currentTimeMillis();
  long d1=end - start;
  start=System.currentTimeMillis();
  for (int i=0; i < 100; i++) {
    JAXBContext context=cache.getJAXBContext(String.class);
  }
  end=System.currentTimeMillis();
  long d2=end - start;
  System.out.println(d1 + "ms vs. " + d2+ "ms");
  start=System.currentTimeMillis();
  for (int i=0; i < 20; i++) {
    JAXBContext context=JAXBContext.newInstance(PurchaseOrderType.class);
  }
  end=System.currentTimeMillis();
  d1=end - start;
  start=System.currentTimeMillis();
  for (int i=0; i < 20; i++) {
    JAXBContext context=cache.getJAXBContext(PurchaseOrderType.class);
  }
  end=System.currentTimeMillis();
  d2=end - start;
  System.out.println(d1 + "ms vs. " + d2+ "ms");
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.tuscany.sca.interfacedef.java.jaxws.JavaReflectionHelperTestCase </h4><pre class="type-10 type-9 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Invokes logging operations">Logger</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Invokes logging operations
- Executes methods or other tests from the same test unit
"></span><br>
@Test public void testSignature() throws Exception {
  for (  Field f : TestGenericClass.class.getDeclaredFields()) {
    String sig=CodeGenerationHelper.getSignature(f.getGenericType());
    System.out.println(sig);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.tuscany.sca.interfacedef.java.jaxws.WrapperBeanGeneratorTestCase </h4><pre class="type-10 type-9 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Invokes logging operations">Logger</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Invokes logging operations
- Executes methods or other tests from the same test unit
"></span><br>
@Test public void testGenerateSchema() throws Exception {
  List<Class<?>> classes=new WrapperBeanGenerator().generateWrapperBeans(TestInterface.class);
  JAXBContext context=JAXBContextHelper.createJAXBContext(classes.toArray(new Class<?>[classes.size()]));
  Map<String,String> results=JAXBTypeHelper.generateSchema(context);
  for (  String xsd : results.values()) {
    System.out.println(xsd);
  }
}

</code></pre>

<br>
<pre class="type-10 type-9 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Invokes logging operations">Logger</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Invokes logging operations
- Executes methods or other tests from the same test unit
"></span><br>
@Test public void testGenerate() throws Exception {
  List<Class<?>> classes=new WrapperBeanGenerator().generateWrapperBeans(TestInterface.class);
  for (  Class<?> cls : classes) {
    for (    Field f : cls.getDeclaredFields()) {
      System.out.println(f.getName());
      System.out.println(f.getGenericType());
      for (      Annotation a : f.getAnnotations()) {
        System.out.println(a);
      }
    }
    for (    Method m : cls.getDeclaredMethods()) {
      System.out.println(m);
      for (      Annotation a : m.getAnnotations()) {
        System.out.println(a);
      }
    }
  }
  JAXBContext context=JAXBContextHelper.createJAXBContext(classes.toArray(new Class<?>[classes.size()]));
  for (  Class<?> cls : classes) {
    Object obj=cls.newInstance();
    StringWriter sw=new StringWriter();
    context.createMarshaller().marshal(obj,sw);
    StringReader sr=new StringReader(sw.toString());
    context.createUnmarshaller().unmarshal(new StreamSource(sr),cls);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.tuscany.sca.itest.BasicAuthTestCase </h4><pre class="type-10 type-9 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Invokes logging operations">Logger</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Invokes logging operations
- Executes methods or other tests from the same test unit
"></span><br>
@Test public void testViaSCAClient(){
  String greetings=service.getGreetings("Simon");
  System.out.println(">>>" + greetings);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.tuscany.sca.itest.ConcurrencyTestCase </h4><pre class="type-10 type-9 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Invokes logging operations">Logger</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Invokes logging operations
- Executes methods or other tests from the same test unit
"></span><br>
@Test public void testConcurrency(){
  String greetings=service.getGreetings("Simon");
  System.out.println(">>>" + greetings);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.tuscany.sca.itest.PolicyIdentityTestCase </h4><pre class="type-10 type-9 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Invokes logging operations">Logger</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Invokes logging operations
- Executes methods or other tests from the same test unit
"></span><br>
@Test public void testPolicies(){
  String greetings=service.getGreetings("Luciano");
  System.out.println(">>>" + greetings);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.tuscany.sca.itest.PolicySecurityJSR250TestCase </h4><pre class="type-10 type-9 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Invokes logging operations">Logger</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Invokes logging operations
- Executes methods or other tests from the same test unit
"></span><br>
@Test public void testPolicies(){
  String greetings=service.getGreetings("Luciano");
  System.out.println(">>>" + greetings);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.tuscany.sca.itest.transaction.TransactionTestCase </h4><pre class="type-10 type-9 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Invokes logging operations">Logger</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Invokes logging operations
- Executes methods or other tests from the same test unit
"></span><br>
@Test public void testTransaction() throws Exception {
  TransferService service=domain.getService(TransferService.class,"TransferServiceComponent");
  String[] accounts=service.getAccounts();
  for (int i=0; i < accounts.length; i++) {
    float balance=service.getBalance(accounts[i]);
    System.out.println("[" + i + "] "+ accounts[i]+ ":"+ balance);
  }
  service.transfer(accounts[0],accounts[2],200.0f);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.tuscany.sca.vtest.assembly.ctypefile.CompomnentTypeFileTestCase </h4><pre class="type-10 type-9 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Invokes logging operations">Logger</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Invokes logging operations
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Lines 2204-2205:
 * <p>
 * A constrainingType can be applied to an implementation. In this case, 
 * the implementation's componentType has a constrainingType attribute set to 
 * the QName of the constrainingType.
 * <p>
 * ASM40002
 * <p>
 * If present, the @constrainingType attribute of a <componentType/> element 
 * MUST reference a <constrainingType/> element in the Domain through its QName.
 * <p>
 * Description of how the OSOA function differs from the OASIS function:
 * <p>
 * The OASIS spec explicitly requires the <constrainingType/> element, 
 * whereas the OSOA spec implies the <constrainingType/> element is needed.
 * <p>
 */
@Test public void ASM40002_negative() throws Exception {
  System.out.println("Running ASM40002 negative test");
  init("noconstrainingtype.composite");
  dService=ServiceFinder.getService(DService.class,"DComponent/DService");
  dService.getSomeProperty();
  destroy();
}

</code></pre>

<br>
<pre class="type-10 type-9 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Invokes logging operations">Logger</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Invokes logging operations
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Lines 2204-2205:
 * <p>
 * A constrainingType can be applied to an implementation. In this case, 
 * the implementation's componentType has a constrainingType attribute set to 
 * the QName of the constrainingType.
 * <p>
 * ASM40002
 * <p>
 * If present, the @constrainingType attribute of a <componentType/> element 
 * MUST reference a <constrainingType/> element in the Domain through its QName.
 * <p>
 * Description of how the OSOA function differs from the OASIS function:
 * <p>
 * The OASIS spec explicitly requires the <constrainingType/> element, 
 * whereas the OSOA spec implies the <constrainingType/> element is needed.
 * <p>
 */
@Test public void ASM40002_positive() throws Exception {
  System.out.println("Running ASM40002 positive test");
  init("constrainingtype.composite");
  cService=ServiceFinder.getService(CService.class,"CComponent/CService");
  cService.getSomeProperty();
  destroy();
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.tuscany.sca.vtest.javaapi.conversation.callback.CallbackTestCase </h4><pre class="type-10 type-9 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Invokes logging operations">Logger</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Invokes logging operations
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Lines 658-669
 * <p>
 * Since it is possible for a single implementation class to implement
 * multiple services, it is also possible for callbacks to be defined for
 * each of the services that it implements. The service implementation can
 * include an injected field for each of its callbacks. The runtime injects
 * the callback onto the appropriate field based on the type of the
 * callback. The following shows the declaration of two fields, each of
 * which corresponds to a particular service offered by the implementation.
 * <p>
 * Lines 670,671
 * <p>
 * If a single callback has a type that is compatible with multiple declared
 * callback fields, then all of them will be set.
 */
@Test public void statefulMultiBidirectional() throws Exception {
  System.out.println("Setting up for multi-bidirectional interfaces tests");
  ServiceFinder.init("callback-multi.composite");
  aService=ServiceFinder.getService(AService.class,"AComponent");
  aService.testCallback();
  aService.testCallback2();
}

</code></pre>

<br>
<pre class="type-10 type-9 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Invokes logging operations">Logger</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Invokes logging operations
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Lines 650-654
 * <p>
 * The difference for stateless services is that the callback field would
 * not be available if the component is servicing a request for anything
 * other than the original client. So, the technique used in the previous
 * section, where there was a response from the backend Service which was
 * forwarded as a callback from MyService would not work because the
 * callback field would be null when the message from the backend system was
 * received.
 * <p>
 */
@Test public void statelessCallback3() throws Exception {
  System.out.println("Setting up for stateless callback ref null tests");
  ServiceFinder.init("callback-stateless-callbackfieldnull.composite");
  aService=ServiceFinder.getService(AService.class,"AComponent");
  aService.testCallback();
}

</code></pre>

<br>
<pre class="type-10 type-9 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Invokes logging operations">Logger</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Invokes logging operations
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Lines 675-706
 * <p>
 * In addition to injecting a reference to a callback service, it is also
 * possible to obtain a reference to a Callback instance by annotating a
 * field or method with the "@Callback" annotation. A reference implementing
 * the callback service interface may be obtained using
 * CallableReference.getService(). The following fragments come from a
 * service implementation that uses the callback API:
 * <p>
 * Alternatively a callback may be retrieved programmatically using the
 * RequestContext API. The snippet below show how to retrieve a callback in
 * a method programmatically:
 * <p>
 * Lines 695, 696
 * <p>
 * Alternatively a callback may be retrieved programmatically using the
 * RequestContext API. The snippet below show how to retrieve a callback in
 * a method programmatically:
 */
@Test public void accessingCallbacks() throws Exception {
  System.out.println("Setting up for callback accessing tests");
  ServiceFinder.init("callback-accessing.composite");
  aService=ServiceFinder.getService(AService.class,"AComponent");
  aService.testCallback();
  aService.testCallback2();
}

</code></pre>

<br>
<pre class="type-10 type-9 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Invokes logging operations">Logger</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Invokes logging operations
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Lines 529-610
 * <p>
 * A callback service is a service that is used for asynchronous
 * communication from a service provider back to its client in contrast to
 * the communication through return values from synchronous operations.
 * Callbacks are used by bidirectional services, which are services that
 * have two interfaces: � an interface for the provided service � a callback
 * interface that must be provided by the client
 * <p>
 * Callbacks may be used for both remotable and local services. Either both
 * interfaces of a bidirectional service must be remotable, or both must be
 * local. It is illegal to mix the two. There are two basic forms of
 * callbacks: stateless callbacks and stateful callbacks. A callback
 * interface is declared by using the "@Callback" annotation on a remotable
 * service interface, which takes the Java Class object of the interface as
 * a parameter. The annotation may also be applied to a method or to a field
 * of an implementation, which is used in order to have a callback injected,
 * as explained in the next section.
 * <p>
 * 1.6.7.1. Stateful Callbacks A stateful callback represents a specific
 * implementation instance of the component that is the client of the
 * service. The interface of a stateful callback should be marked as
 * conversational. The following example interfaces define an interaction
 * over stateful callback.
 * <p>
 * An implementation of the service in this example could use the
 * "@Callback" annotation to request that a stateful callback be injected.
 * The following is a fragment of an implementation of the example service.
 * In this example, the request is passed on to some other component, so
 * that the example service acts essentially as an intermediary. Because the
 * service is conversation scoped, the callback will still be available when
 * the backend service sends back its asynchronous response.
 * <p>
 * This fragment must come from an implementation that offers two services,
 * one that it offers to it clients (MyService) and one that is used for
 * receiving callbacks from the back end (MyServiceCallback). The client of
 * this service would also implement the methods defined in
 * MyServiceCallback.
 * <p>
 * Stateful callbacks support some of the same use cases as are supported by
 * the ability to pass service references as parameters. The primary
 * difference is that stateful callbacks do not require any additional
 * parameters be passed with service operations. This can be a great
 * convenience. If the service has many operations and any of those
 * operations could be the first operation of the conversation, it would be
 * unwieldy to have to take a callback parameter as part of every operation,
 * just in case it is the first operation of the conversation. It is also
 * more natural than requiring the application developers to invoke an
 * explicit operation whose only purpose is to pass the callback object that
 * should be used.
 * <p>
 * This tests the *local* bidirectional interfaces option
 */
@Test public void localstatefulCallback() throws Exception {
  System.out.println("Setting up for local callback tests");
  ServiceFinder.init("callback-local.composite");
  aService=ServiceFinder.getService(AService.class,"AComponent");
  aService.testCallback();
}

</code></pre>

<br>
<pre class="type-10 type-9 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Invokes logging operations">Logger</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Invokes logging operations
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Lines 616-621
 * <p>
 * The only information that the client has to work with (other than the
 * parameters of the callback method) is a callback ID object that is passed
 * with requests to the service and is guaranteed to be returned with any
 * callback.
 * <p>
 * The following is a repeat of the client code fragment above, but with the
 * assumption that in this case the MyServiceCallback is stateless. The
 * client in this case needs to set the callback ID before invoking the
 * service and then needs to get the callback ID when the response is
 * received.
 * <p>
 * Lines 747-755
 * <p>
 * The identity that is used to identify a callback request is, by default,
 * generated by the system. However, it is possible to provide an
 * application specified identity that should be used to identify the
 * callback by calling the ServiceReference.setCallbackID() method. This can
 * be used even either stateful or stateless callbacks. The identity will be
 * sent to the service provider, and the binding must guarantee that the
 * service provider will send the ID back when any callback method is
 * invoked. The callback identity has the same restrictions as the
 * conversation ID. It should either be a string or an object that can be
 * serialized into XML. Bindings determine the particular mechanisms to use
 * for transmission of the identity and these may lead to further
 * restrictions when using a given binding.
 * <p>
 * TODO - Need to add explicit test back to stateful for 747-755
 */
@Test public void statelessCallback2() throws Exception {
  System.out.println("Setting up for stateless callback id tests");
  ServiceFinder.init("callback-stateless-callbackid.composite");
  aService=ServiceFinder.getService(AService.class,"AComponent");
  aService.testCallback();
}

</code></pre>

<br>
<pre class="type-10 type-9 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Invokes logging operations">Logger</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Invokes logging operations
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Lines 728-732
 * <p>
 * By default, the client component of a service is assumed to be the
 * callback service for the bidirectional service. However, it is possible
 * to change the callback by using the ServiceReference.setCallback()
 * method. The object passed as the callback should implement the interface
 * defined for the callback, including any additional SCA semantics on that
 * interface such as its scope and whether or not it is remotable.
 * <p>
 * TODO - Need to complete testing of 1.6.7.5 after resolution of t-2312
 */
@Test public void customCallback() throws Exception {
  System.out.println("Setting up for custom callback tests; create domain instance");
  ServiceFinder.init("callback-custom.composite");
  System.out.println("Setting up for custom callback tests; get AService handle");
  aService=ServiceFinder.getService(AService.class,"AComponent");
  aService.testCallback();
}

</code></pre>

<br>
<pre class="type-10 type-9 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Invokes logging operations">Logger</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Invokes logging operations
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Lines 529-610
 * <p>
 * A callback service is a service that is used for asynchronous
 * communication from a service provider back to its client in contrast to
 * the communication through return values from synchronous operations.
 * Callbacks are used by bidirectional services, which are services that
 * have two interfaces: � an interface for the provided service � a callback
 * interface that must be provided by the client
 * <p>
 * Callbacks may be used for both remotable and local services. Either both
 * interfaces of a bidirectional service must be remotable, or both must be
 * local. It is illegal to mix the two. There are two basic forms of
 * callbacks: stateless callbacks and stateful callbacks. A callback
 * interface is declared by using the "@Callback" annotation on a remotable
 * service interface, which takes the Java Class object of the interface as
 * a parameter. The annotation may also be applied to a method or to a field
 * of an implementation, which is used in order to have a callback injected,
 * as explained in the next section.
 * <p>
 * 1.6.7.1. Stateful Callbacks A stateful callback represents a specific
 * implementation instance of the component that is the client of the
 * service. The interface of a stateful callback should be marked as
 * conversational. The following example interfaces define an interaction
 * over stateful callback.
 * <p>
 * An implementation of the service in this example could use the
 * "@Callback" annotation to request that a stateful callback be injected.
 * The following is a fragment of an implementation of the example service.
 * In this example, the request is passed on to some other component, so
 * that the example service acts essentially as an intermediary. Because the
 * service is conversation scoped, the callback will still be available when
 * the backend service sends back its asynchronous response.
 * <p>
 * This fragment must come from an implementation that offers two services,
 * one that it offers to it clients (MyService) and one that is used for
 * receiving callbacks from the back end (MyServiceCallback). The client of
 * this service would also implement the methods defined in
 * MyServiceCallback.
 * <p>
 * Stateful callbacks support some of the same use cases as are supported by
 * the ability to pass service references as parameters. The primary
 * difference is that stateful callbacks do not require any additional
 * parameters be passed with service operations. This can be a great
 * convenience. If the service has many operations and any of those
 * operations could be the first operation of the conversation, it would be
 * unwieldy to have to take a callback parameter as part of every operation,
 * just in case it is the first operation of the conversation. It is also
 * more natural than requiring the application developers to invoke an
 * explicit operation whose only purpose is to pass the callback object that
 * should be used.
 * <p>
 * This tests the *remote* bidirectional interfaces option
 */
@Test public void statefulCallback() throws Exception {
  System.out.println("Setting up for callback tests");
  ServiceFinder.init("callback.composite");
  aService=ServiceFinder.getService(AService.class,"AComponent");
  aService.testCallback();
}

</code></pre>

<br>
<pre class="type-10 type-9 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Invokes logging operations">Logger</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Invokes logging operations
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Lines 613-615
 * <p>
 * A stateless callback interface is a callback whose interface is not
 * marked as conversational. Unlike stateless services, the client of that
 * uses stateless callbacks will not have callback methods routed to an
 * instance of the client that contains any state that is relevant to the
 * conversation.
 * <p>
 * This test is identical in structure to the stateful test except that
 * BServiceCallback is not conversational and we test that the callback is
 * NOT routed to the same instance.
 */
@Test public void statelessCallback() throws Exception {
  System.out.println("Setting up for stateless callback tests");
  ServiceFinder.init("callback-stateless.composite");
  aService=ServiceFinder.getService(AService.class,"AComponent");
  aService.testCallback();
}

</code></pre>

<br>
<pre class="type-10 type-9 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Invokes logging operations">Logger</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Invokes logging operations
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Lines 708-724
 * <p>
 * On the client side, the service that implements the callback can access
 * the callback ID (i.e. reference parameters) that was returned with the
 * callback operation also by accessing the request context, as follows:
 * <p>
 * On the client side, the object returned by the getServiceReference()
 * method represents the service reference that was used to send the
 * original request. The object returned by getCallbackID() represents the
 * identity associated with the callback, which may be a single String or
 * may be an object (as described below in �Customizing the Callback
 * Identity�).
 */
@Test public void callbackId() throws Exception {
  System.out.println("Setting up for callback id tests");
  ServiceFinder.init("callback-id.composite");
  aService=ServiceFinder.getService(AService.class,"AComponent");
  aService.testCallback();
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.zhulei.test.hessian.first.FirstTestCase </h4><pre class="type-10 type-9 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Invokes logging operations">Logger</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Invokes logging operations
- Executes methods or other tests from the same test unit
"></span><br>
@Test public void testServer() throws IOException {
  try {
    HessianProxyFactory proxyFactory=new HessianProxyFactory();
    IFirst service=(IFirst)proxyFactory.create(IFirst.class,"http://localhost:8085/hessian1");
    List<String> datas=service.getData("123","ABC");
    for (int i=0; i < datas.size(); i++) {
      System.out.println(datas.get(i));
    }
  }
 catch (  Exception e) {
    System.out.println(e.getMessage());
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.zhulei.test.hessian.second.SecondTestCase </h4><pre class="type-10 type-9 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Invokes logging operations">Logger</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Invokes logging operations
- Executes methods or other tests from the same test unit
"></span><br>
@Test public void testServer() throws IOException {
  try {
    HessianProxyFactory proxyFactory=new HessianProxyFactory();
    ISecond service=(ISecond)proxyFactory.create(ISecond.class,"http://localhost:8085/hessian2");
    String str=service.getString("XYZ");
    System.out.println(str);
  }
 catch (  Exception e) {
    System.out.println(e.getMessage());
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: scatours.JumpstartTestCase </h4><pre class="type-10 type-9 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Invokes logging operations">Logger</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Invokes logging operations
- Executes methods or other tests from the same test unit
"></span><br>
@Test public void testClient() throws Exception {
  Trips tripProvider=((SCAClient)node).getService(Trips.class,"TripProvider/Trips");
  System.out.println("Trip boooking code = " + tripProvider.checkAvailability("FS1APR4",2));
}

</code></pre>

<br>
<h4 style="margin:0px">Class: scatours.emailgateway.EmailGatewayTestCase </h4><pre class="type-10 type-9 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Invokes logging operations">Logger</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Invokes logging operations
- Executes methods or other tests from the same test unit
"></span><br>
@Test public void testEmailGateway(){
  SCAClient client=(SCAClient)node;
  EmailGateway cc=client.getService(EmailGateway.class,"EmailGatewayClient");
  ObjectFactory objectFactory=new ObjectFactory();
  EmailType email=objectFactory.createEmailType();
  email.setTo("Fred");
  email.setTitle("An email");
  email.setBody("A message");
  System.out.println(cc.sendEmail(email));
}

</code></pre>

<br>
<h4 style="margin:0px">Class: scatours.payment.PaymentTestCase </h4><pre class="type-10 type-9 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Invokes logging operations">Logger</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Invokes logging operations
- Executes methods or other tests from the same test unit
"></span><br>
@Test public void testPayment(){
  SCAClient client=(SCAClient)paymentNode;
  Payment payment=client.getService(Payment.class,"PaymentClient");
  String result=payment.makePaymentMember("Fred",100.00f);
  System.out.println("Result = " + result);
  if (!"OK".equals(result)) {
    throw new RuntimeException(result);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: scatours.payment.creditcard.CreditCardPaymentTestCase </h4><pre class="type-10 type-9 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Invokes logging operations">Logger</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Invokes logging operations
- Executes methods or other tests from the same test unit
"></span><br>
@Test public void testCreditCardPayment(){
  SCAClient client=(SCAClient)node;
  CreditCardPayment cc=client.getService(CreditCardPayment.class,"CreditCardPayment");
  CreditCardPaymentFactory factory=CreditCardPaymentFactory.INSTANCE;
  CreditCardDetailsType ccDetails=factory.createCreditCardDetailsType();
  ccDetails.setCreditCardType("Visa");
  ccDetails.setCreditCardNumber("1111-2222-3333-4444");
  ccDetails.setExpMonth(9);
  ccDetails.setExpYear(2010);
  PayerType ccOwner=factory.createPayerType();
  ccOwner.setName("Fred");
  ccDetails.setCardOwner(ccOwner);
  System.out.println(cc.authorize(ccDetails,100.00f));
}

</code></pre>

<br>
<h4 style="margin:0px">Class: scatours.trip.TripTestCase </h4><pre class="type-10 type-9 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Invokes logging operations">Logger</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Invokes logging operations
- Executes methods or other tests from the same test unit
"></span><br>
@Test public void testPayment(){
  SCAClient client=(SCAClient)tripNode;
  Book booking=client.getService(Book.class,"Trip/Book");
  TripItem tripItem=new TripItem("1234","5678",TripItem.TRIP,"FS1DEC06","Florence and Siena pre-packaged tour","FLR","06/12/09","13/12/09",450,"EUR","http://localhost:8085/tbd");
  System.out.println("Result = " + booking.book(tripItem) + "\n");
}

</code></pre>

<br>
<h4 style="margin:0px">Class: voidtest.VoidArgsReturnTestCase </h4><pre class="type-10 type-9 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Invokes logging operations">Logger</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Invokes logging operations
- Executes methods or other tests from the same test unit
"></span><br>
@Test public void testVoidCases() throws Exception {
  client.runTest();
  System.out.println("Sleeping...");
  Thread.sleep(2000);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: xquery.quote.XQueryQuoteClientTestCase </h4><pre class="type-10 type-9 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Invokes logging operations">Logger</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Invokes logging operations
- Executes methods or other tests from the same test unit
"></span><br>
@Test public void testQuoteJoin(){
  AvailQuote availQuote=QuoteDataUtil.buildAvailQuoteData();
  PriceQuote priceQuote=QuoteDataUtil.buildPriceQuoteData();
  if (SHOW_DEBUG_MSG) {
    System.out.println("Input quote for the price list:");
    QuoteDataUtil.serializeToSystemOut((DataObject)priceQuote,"priceQuote");
    System.out.println();
    System.out.println("Input quote for the availability:");
    QuoteDataUtil.serializeToSystemOut((DataObject)availQuote,"availQuote");
    System.out.println();
  }
  Quote quote=quoteJoinLocal.joinPriceAndAvailQuotes(priceQuote,availQuote,0.1f);
  if (SHOW_DEBUG_MSG) {
    System.out.println();
    System.out.println("Output quote from local join:");
    QuoteDataUtil.serializeToSystemOut((DataObject)quote,"quote");
    System.out.println();
  }
  XQueryQuoteClientTestCase.assertQuote(availQuote,priceQuote,quote,0.1f);
  quote=quoteJoinLocal.joinPriceAndAvailQuotes(priceQuote,availQuote,0.2f);
  if (SHOW_DEBUG_MSG) {
    System.out.println();
    System.out.println("Output quote from local join (second invokation):");
    QuoteDataUtil.serializeToSystemOut((DataObject)quote,"quote");
    System.out.println();
  }
  XQueryQuoteClientTestCase.assertQuote(availQuote,priceQuote,quote,0.2f);
  quote=quoteJoinLocal.joinPriceAndAvailQuotesWs(priceQuote,availQuote,0.1f);
  if (SHOW_DEBUG_MSG) {
    System.out.println();
    System.out.println("Output quote from web service join:");
    QuoteDataUtil.serializeToSystemOut((DataObject)quote,"quote");
    System.out.println();
  }
  XQueryQuoteClientTestCase.assertQuote(availQuote,priceQuote,quote,0.1f);
  quote=quoteJoinLocal.joinPriceAndAvailQuotes();
  if (SHOW_DEBUG_MSG) {
    System.out.println();
    System.out.println("Output quote from properties join:");
    QuoteDataUtil.serializeToSystemOut((DataObject)quote,"quote");
    System.out.println();
  }
  XQueryQuoteClientTestCase.assertQuote(availQuote,priceQuote,quote,0.1f);
  quote=quoteJoinLocal.joinPriceAndAvailQuotes(0.1f);
  if (SHOW_DEBUG_MSG) {
    System.out.println();
    System.out.println("Output quote from external references join:");
    QuoteDataUtil.serializeToSystemOut((DataObject)quote,"quote");
    System.out.println();
  }
  XQueryQuoteClientTestCase.assertQuote(availQuote,priceQuote,quote,0.1f);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: zipcode.ZipCodeClientTestCase </h4><pre class="type-10 type-9 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Invokes logging operations">Logger</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Invokes logging operations
- Executes methods or other tests from the same test unit
"></span><br>
@Test public void testClient() throws Exception {
  System.out.println("Running ZipCodeClient...");
  ZipCodeClient.main(null);
}

</code></pre>

<br>
<script>$(document).ready(function() {
  $('pre code').each(function(i, block) {
    hljs.highlightBlock(block);
  });
});</script>
