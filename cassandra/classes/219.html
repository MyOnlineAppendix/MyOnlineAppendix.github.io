<h3 style="margin:0px">Class: org.apache.cassandra.index.sasi.plan.OperationTest (7 methods) </h3><br><pre style="padding:0"><code class="html"><div id="tags"><button id="7"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('7')" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) "><kbd id="tag-7"class="label-info"style="display: inline-block;font-size:7pt" >APIUtilityVerifier&nbsp;(5)</kbd></button>&nbsp;<button id="4"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('4')" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls"><kbd id="tag-4"class="label-info"style="display: inline-block;font-size:7pt" >InternalCallVerifier&nbsp;(3)</kbd></button>&nbsp;<button id="5"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('5')" data-toggle="tooltip" title="Verifies boolean conditions"><kbd id="tag-5"class="label-info"style="display: inline-block;font-size:7pt" >BooleanVerifier&nbsp;(3)</kbd></button>&nbsp;<button id="2"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('2')" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value "><kbd id="tag-2"class="label-info"style="display: inline-block;font-size:7pt" >EqualityVerifier&nbsp;(2)</kbd></button>&nbsp;<button id="11"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('11')" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes"><kbd id="tag-11"class="label-info"style="display: inline-block;font-size:7pt" >HybridVerifier&nbsp;(1)</kbd></button>&nbsp;<button id="10"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('10')" data-toggle="tooltip" title="Allocates resources before the execution of the test cases"><kbd id="tag-10"class="label-info"style="display: inline-block;font-size:7pt" >TestInitializer&nbsp;(1)</kbd></button>&nbsp;<button id="1"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('1')" data-toggle="tooltip" title="Releases resources used by the test cases"><kbd id="tag-1"class="label-info"style="display: inline-block;font-size:7pt" >TestCleaner&nbsp;(1)</kbd></button>&nbsp;<button id="6"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('6')" data-toggle="tooltip" title="Verifies assertions in iterations"><kbd id="tag-6"class="label-info"style="display: inline-block;font-size:7pt" >IterativeVerifier&nbsp;(1)</kbd></button>&nbsp;<button id="15"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('15')" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure"><kbd id="tag-15"class="label-info"style="display: inline-block;font-size:7pt" >UtilityVerifier&nbsp;(1)</kbd></button>&nbsp;</div></code></pre><center><button onclick="showBlocks()" style="margin:6px">Update filter <span class="glyphicon glyphicon-refresh" aria-hidden="true"></span> </button></center><br>
<pre class="type-7 type-4 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
"></span><br>
@Test public void testSatisfiedByWithMultipleTerms(){
  final ColumnDefinition comment=getColumn(UTF8Type.instance.decompose("comment"));
  Unfiltered row=buildRow(buildCell(comment,UTF8Type.instance.decompose("software engineer is working on a project"),System.currentTimeMillis()));
  Operation.Builder builder=new Operation.Builder(OperationType.AND,controller,new SimpleExpression(comment,Operator.EQ,UTF8Type.instance.decompose("eng is a work")));
  Operation op=builder.complete();
  Assert.assertTrue(op.satisfiedBy(row,false));
  builder=new Operation.Builder(OperationType.AND,controller,new SimpleExpression(comment,Operator.EQ,UTF8Type.instance.decompose("soft works fine")));
  op=builder.complete();
  Assert.assertTrue(op.satisfiedBy(row,false));
}

</code></pre>

<pre class="type-10 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Allocates resources before the execution of the test cases">TestInitializer</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Allocates resources before the execution of the test cases
"></span><br>
@Before public void beforeTest(){
  controller=new QueryController(BACKEND,PartitionRangeReadCommand.allDataRead(BACKEND.metadata,FBUtilities.nowInSeconds()),TimeUnit.SECONDS.toMillis(10));
}

</code></pre>

<pre class="type-6 type-7 type-15 type-4 type-5 type-11 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testSatisfiedBy() throws Exception {
  final ColumnDefinition timestamp=getColumn(UTF8Type.instance.decompose("timestamp"));
  final ColumnDefinition age=getColumn(UTF8Type.instance.decompose("age"));
  Operation.Builder builder=new Operation.Builder(OperationType.AND,controller,new SimpleExpression(age,Operator.NEQ,Int32Type.instance.decompose(5)));
  Operation op=builder.complete();
  Unfiltered row=buildRow(buildCell(age,Int32Type.instance.decompose(6),System.currentTimeMillis()));
  Assert.assertTrue(op.satisfiedBy(row,false));
  row=buildRow(buildCell(age,Int32Type.instance.decompose(5),System.currentTimeMillis()));
  Assert.assertFalse(op.satisfiedBy(row,false));
  row=buildRow(buildCell(age,Int32Type.instance.decompose(6),System.currentTimeMillis()));
  Assert.assertTrue(op.satisfiedBy(row,false));
  builder=new Operation.Builder(OperationType.AND,controller,new SimpleExpression(age,Operator.NEQ,Int32Type.instance.decompose(5)),new SimpleExpression(age,Operator.GT,Int32Type.instance.decompose(1)),new SimpleExpression(age,Operator.NEQ,Int32Type.instance.decompose(6)),new SimpleExpression(age,Operator.LTE,Int32Type.instance.decompose(10)));
  op=builder.complete();
  Set<Integer> exclusions=Sets.newHashSet(0,1,5,6,11);
  for (int i=0; i <= 11; i++) {
    row=buildRow(buildCell(age,Int32Type.instance.decompose(i),System.currentTimeMillis()));
    boolean result=op.satisfiedBy(row,false);
    Assert.assertTrue(exclusions.contains(i) != result);
  }
  builder=new Operation.Builder(OperationType.OR,controller,new SimpleExpression(age,Operator.EQ,Int32Type.instance.decompose(5)),new SimpleExpression(age,Operator.EQ,Int32Type.instance.decompose(6)));
  op=builder.complete();
  exclusions=Sets.newHashSet(0,1,2,3,4,7,8,9,10);
  for (int i=0; i <= 10; i++) {
    row=buildRow(buildCell(age,Int32Type.instance.decompose(i),System.currentTimeMillis()));
    boolean result=op.satisfiedBy(row,false);
    Assert.assertTrue(exclusions.contains(i) != result);
  }
  builder=new Operation.Builder(OperationType.AND,controller);
  builder.add(new SimpleExpression(age,Operator.GTE,Int32Type.instance.decompose(0)));
  builder.add(new SimpleExpression(age,Operator.LT,Int32Type.instance.decompose(10)));
  builder.add(new SimpleExpression(age,Operator.NEQ,Int32Type.instance.decompose(7)));
  op=builder.complete();
  exclusions=Sets.newHashSet(7);
  for (int i=0; i < 10; i++) {
    row=buildRow(buildCell(age,Int32Type.instance.decompose(i),System.currentTimeMillis()));
    boolean result=op.satisfiedBy(row,false);
    Assert.assertTrue(exclusions.contains(i) != result);
  }
  builder=new Operation.Builder(OperationType.AND,controller);
  builder.add(new SimpleExpression(timestamp,Operator.GTE,LongType.instance.decompose(10L)));
  builder.add(new SimpleExpression(age,Operator.EQ,Int32Type.instance.decompose(5)));
  op=builder.complete();
  row=buildRow(buildCell(age,Int32Type.instance.decompose(6),System.currentTimeMillis()),buildCell(timestamp,LongType.instance.decompose(11L),System.currentTimeMillis()));
  Assert.assertFalse(op.satisfiedBy(row,false));
  row=buildRow(buildCell(age,Int32Type.instance.decompose(5),System.currentTimeMillis()),buildCell(timestamp,LongType.instance.decompose(22L),System.currentTimeMillis()));
  Assert.assertTrue(op.satisfiedBy(row,false));
  row=buildRow(buildCell(age,Int32Type.instance.decompose(5),System.currentTimeMillis()),buildCell(timestamp,LongType.instance.decompose(9L),System.currentTimeMillis()));
  Assert.assertFalse(op.satisfiedBy(row,false));
  builder=new Operation.Builder(OperationType.OR,controller,new SimpleExpression(timestamp,Operator.GT,LongType.instance.decompose(10L)));
  builder.setRight(new Operation.Builder(OperationType.AND,controller,new SimpleExpression(age,Operator.GT,Int32Type.instance.decompose(0)),new SimpleExpression(age,Operator.LT,Int32Type.instance.decompose(10))));
  op=builder.complete();
  row=buildRow(buildCell(age,Int32Type.instance.decompose(5),System.currentTimeMillis()),buildCell(timestamp,LongType.instance.decompose(9L),System.currentTimeMillis()));
  Assert.assertTrue(op.satisfiedBy(row,false));
  row=buildRow(buildCell(age,Int32Type.instance.decompose(20),System.currentTimeMillis()),buildCell(timestamp,LongType.instance.decompose(11L),System.currentTimeMillis()));
  Assert.assertTrue(op.satisfiedBy(row,false));
  row=buildRow(buildCell(age,Int32Type.instance.decompose(0),System.currentTimeMillis()),buildCell(timestamp,LongType.instance.decompose(9L),System.currentTimeMillis()));
  Assert.assertFalse(op.satisfiedBy(row,false));
  builder=new Operation.Builder(OperationType.AND,controller);
  builder.add(new SimpleExpression(age,Operator.EQ,Int32Type.instance.decompose(30)));
  op=builder.complete();
  Assert.assertFalse(op.satisfiedBy(null,false));
  Assert.assertFalse(op.satisfiedBy(row,false));
  long now=System.currentTimeMillis();
  row=OperationTest.buildRow(Row.Deletion.regular(new DeletionTime(now - 10,(int)(now / 1000))),buildCell(age,Int32Type.instance.decompose(6),System.currentTimeMillis()));
  Assert.assertFalse(op.satisfiedBy(row,false));
  row=buildRow(deletedCell(age,System.currentTimeMillis(),FBUtilities.nowInSeconds()));
  Assert.assertFalse(op.satisfiedBy(row,true));
  try {
    Assert.assertFalse(op.satisfiedBy(buildRow(),false));
  }
 catch (  IllegalStateException e) {
  }
  try {
    Assert.assertFalse(op.satisfiedBy(buildRow(),true));
  }
 catch (  IllegalStateException e) {
    Assert.fail("IllegalStateException should not be thrown when missing column and allowMissingColumns=true");
  }
}

</code></pre>

<pre class="type-1 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Releases resources used by the test cases">TestCleaner</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Releases resources used by the test cases
"></span><br>
@After public void afterTest(){
  controller.finish();
}

</code></pre>

<pre class="type-7 type-4 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
"></span><br>
@Test public void testSatisfiedByWithClustering(){
  ColumnDefinition location=getColumn(CLUSTERING_BACKEND,UTF8Type.instance.decompose("location"));
  ColumnDefinition age=getColumn(CLUSTERING_BACKEND,UTF8Type.instance.decompose("age"));
  ColumnDefinition height=getColumn(CLUSTERING_BACKEND,UTF8Type.instance.decompose("height"));
  ColumnDefinition score=getColumn(CLUSTERING_BACKEND,UTF8Type.instance.decompose("score"));
  Unfiltered row=buildRow(Clustering.make(UTF8Type.instance.fromString("US"),Int32Type.instance.decompose(27)),buildCell(height,Int32Type.instance.decompose(182),System.currentTimeMillis()),buildCell(score,DoubleType.instance.decompose(1.0d),System.currentTimeMillis()));
  Operation.Builder builder=new Operation.Builder(OperationType.AND,controller);
  builder.add(new SimpleExpression(age,Operator.EQ,Int32Type.instance.decompose(27)));
  builder.add(new SimpleExpression(height,Operator.EQ,Int32Type.instance.decompose(182)));
  Assert.assertTrue(builder.complete().satisfiedBy(row,false));
  builder=new Operation.Builder(OperationType.AND,controller);
  builder.add(new SimpleExpression(age,Operator.EQ,Int32Type.instance.decompose(28)));
  builder.add(new SimpleExpression(height,Operator.EQ,Int32Type.instance.decompose(182)));
  Assert.assertFalse(builder.complete().satisfiedBy(row,false));
  builder=new Operation.Builder(OperationType.AND,controller);
  builder.add(new SimpleExpression(location,Operator.EQ,UTF8Type.instance.decompose("US")));
  builder.add(new SimpleExpression(age,Operator.GTE,Int32Type.instance.decompose(27)));
  Assert.assertTrue(builder.complete().satisfiedBy(row,false));
  builder=new Operation.Builder(OperationType.AND,controller);
  builder.add(new SimpleExpression(location,Operator.EQ,UTF8Type.instance.decompose("BY")));
  builder.add(new SimpleExpression(age,Operator.GTE,Int32Type.instance.decompose(28)));
  Assert.assertFalse(builder.complete().satisfiedBy(row,false));
  builder=new Operation.Builder(OperationType.AND,controller);
  builder.add(new SimpleExpression(location,Operator.EQ,UTF8Type.instance.decompose("US")));
  builder.add(new SimpleExpression(age,Operator.LTE,Int32Type.instance.decompose(27)));
  builder.add(new SimpleExpression(height,Operator.GTE,Int32Type.instance.decompose(182)));
  Assert.assertTrue(builder.complete().satisfiedBy(row,false));
  builder=new Operation.Builder(OperationType.AND,controller);
  builder.add(new SimpleExpression(location,Operator.EQ,UTF8Type.instance.decompose("US")));
  builder.add(new SimpleExpression(height,Operator.GTE,Int32Type.instance.decompose(182)));
  builder.add(new SimpleExpression(score,Operator.EQ,DoubleType.instance.decompose(1.0d)));
  Assert.assertTrue(builder.complete().satisfiedBy(row,false));
  builder=new Operation.Builder(OperationType.AND,controller);
  builder.add(new SimpleExpression(height,Operator.GTE,Int32Type.instance.decompose(182)));
  builder.add(new SimpleExpression(score,Operator.EQ,DoubleType.instance.decompose(1.0d)));
  Assert.assertTrue(builder.complete().satisfiedBy(row,false));
}

</code></pre>

<pre class="type-7 type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies whether objects/variable are equal to an expected value 
"></span><br>
@Test public void testAnalyze() throws Exception {
  final ColumnDefinition firstName=getColumn(UTF8Type.instance.decompose("first_name"));
  final ColumnDefinition age=getColumn(UTF8Type.instance.decompose("age"));
  final ColumnDefinition comment=getColumn(UTF8Type.instance.decompose("comment"));
  Map<Expression.Op,Expression> expressions=convert(Operation.analyzeGroup(controller,OperationType.AND,Arrays.asList(new SimpleExpression(age,Operator.NEQ,Int32Type.instance.decompose(5)),new SimpleExpression(age,Operator.GT,Int32Type.instance.decompose(1)),new SimpleExpression(age,Operator.NEQ,Int32Type.instance.decompose(6)),new SimpleExpression(age,Operator.LTE,Int32Type.instance.decompose(10)))));
  Expression expected=new Expression("age",Int32Type.instance){
{
      operation=Op.RANGE;
      lower=new Bound(Int32Type.instance.decompose(1),false);
      upper=new Bound(Int32Type.instance.decompose(10),true);
      exclusions.add(Int32Type.instance.decompose(5));
      exclusions.add(Int32Type.instance.decompose(6));
    }
  }
;
  Assert.assertEquals(1,expressions.size());
  Assert.assertEquals(expected,expressions.get(Expression.Op.RANGE));
  expressions=convert(Operation.analyzeGroup(controller,OperationType.OR,Arrays.asList(new SimpleExpression(age,Operator.NEQ,Int32Type.instance.decompose(5)),new SimpleExpression(age,Operator.GTE,Int32Type.instance.decompose(7)))));
  Assert.assertEquals(2,expressions.size());
  Assert.assertEquals(new Expression("age",Int32Type.instance){
{
      operation=Op.NOT_EQ;
      lower=new Bound(Int32Type.instance.decompose(5),true);
      upper=lower;
    }
  }
,expressions.get(Expression.Op.NOT_EQ));
  Assert.assertEquals(new Expression("age",Int32Type.instance){
{
      operation=Op.RANGE;
      lower=new Bound(Int32Type.instance.decompose(7),true);
    }
  }
,expressions.get(Expression.Op.RANGE));
  expressions=convert(Operation.analyzeGroup(controller,OperationType.OR,Arrays.asList(new SimpleExpression(age,Operator.NEQ,Int32Type.instance.decompose(5)),new SimpleExpression(age,Operator.LT,Int32Type.instance.decompose(7)))));
  Assert.assertEquals(2,expressions.size());
  Assert.assertEquals(new Expression("age",Int32Type.instance){
{
      operation=Op.RANGE;
      upper=new Bound(Int32Type.instance.decompose(7),false);
    }
  }
,expressions.get(Expression.Op.RANGE));
  Assert.assertEquals(new Expression("age",Int32Type.instance){
{
      operation=Op.NOT_EQ;
      lower=new Bound(Int32Type.instance.decompose(5),true);
      upper=lower;
    }
  }
,expressions.get(Expression.Op.NOT_EQ));
  expressions=convert(Operation.analyzeGroup(controller,OperationType.AND,Arrays.asList(new SimpleExpression(age,Operator.GT,Int32Type.instance.decompose(1)),new SimpleExpression(age,Operator.LT,Int32Type.instance.decompose(7)))));
  Assert.assertEquals(1,expressions.size());
  Assert.assertEquals(new Expression("age",Int32Type.instance){
{
      operation=Op.RANGE;
      lower=new Bound(Int32Type.instance.decompose(1),false);
      upper=new Bound(Int32Type.instance.decompose(7),false);
    }
  }
,expressions.get(Expression.Op.RANGE));
  expressions=convert(Operation.analyzeGroup(controller,OperationType.OR,Arrays.asList(new SimpleExpression(firstName,Operator.EQ,UTF8Type.instance.decompose("a")),new SimpleExpression(firstName,Operator.NEQ,UTF8Type.instance.decompose("b")))));
  Assert.assertEquals(2,expressions.size());
  Assert.assertEquals(new Expression("first_name",UTF8Type.instance){
{
      operation=Op.NOT_EQ;
      lower=new Bound(UTF8Type.instance.decompose("b"),true);
      upper=lower;
    }
  }
,expressions.get(Expression.Op.NOT_EQ));
  Assert.assertEquals(new Expression("first_name",UTF8Type.instance){
{
      operation=Op.EQ;
      lower=upper=new Bound(UTF8Type.instance.decompose("a"),true);
    }
  }
,expressions.get(Expression.Op.EQ));
  ListMultimap<ColumnDefinition,Expression> e=Operation.analyzeGroup(controller,OperationType.OR,Arrays.asList(new SimpleExpression(comment,Operator.EQ,UTF8Type.instance.decompose("soft eng")),new SimpleExpression(comment,Operator.NEQ,UTF8Type.instance.decompose("likes do"))));
  List<Expression> expectedExpressions=new ArrayList<Expression>(2){
{
      add(new Expression("comment",UTF8Type.instance){
{
          operation=Op.EQ;
          lower=new Bound(UTF8Type.instance.decompose("soft"),true);
          upper=lower;
        }
      }
);
      add(new Expression("comment",UTF8Type.instance){
{
          operation=Op.EQ;
          lower=new Bound(UTF8Type.instance.decompose("eng"),true);
          upper=lower;
        }
      }
);
      add(new Expression("comment",UTF8Type.instance){
{
          operation=Op.NOT_EQ;
          lower=new Bound(UTF8Type.instance.decompose("likes"),true);
          upper=lower;
        }
      }
);
      add(new Expression("comment",UTF8Type.instance){
{
          operation=Op.NOT_EQ;
          lower=new Bound(UTF8Type.instance.decompose("do"),true);
          upper=lower;
        }
      }
);
    }
  }
;
  Assert.assertEquals(expectedExpressions,e.get(comment));
  e=Operation.analyzeGroup(controller,OperationType.OR,Arrays.asList(new SimpleExpression(comment,Operator.NEQ,UTF8Type.instance.decompose("likes do")),new SimpleExpression(firstName,Operator.EQ,UTF8Type.instance.decompose("j"))));
  expectedExpressions=new ArrayList<Expression>(2){
{
      add(new Expression("comment",UTF8Type.instance){
{
          operation=Op.NOT_EQ;
          lower=new Bound(UTF8Type.instance.decompose("likes"),true);
          upper=lower;
        }
      }
);
      add(new Expression("comment",UTF8Type.instance){
{
          operation=Op.NOT_EQ;
          lower=new Bound(UTF8Type.instance.decompose("do"),true);
          upper=lower;
        }
      }
);
    }
  }
;
  Assert.assertEquals(expectedExpressions,e.get(comment));
  e=Operation.analyzeGroup(controller,OperationType.OR,Arrays.asList(new SimpleExpression(age,Operator.NEQ,Int32Type.instance.decompose(27)),new SimpleExpression(firstName,Operator.EQ,UTF8Type.instance.decompose("j")),new SimpleExpression(age,Operator.NEQ,Int32Type.instance.decompose(25))));
  expectedExpressions=new ArrayList<Expression>(2){
{
      add(new Expression("age",Int32Type.instance){
{
          operation=Op.NOT_EQ;
          lower=new Bound(Int32Type.instance.decompose(27),true);
          upper=lower;
        }
      }
);
      add(new Expression("age",Int32Type.instance){
{
          operation=Op.NOT_EQ;
          lower=new Bound(Int32Type.instance.decompose(25),true);
          upper=lower;
        }
      }
);
    }
  }
;
  Assert.assertEquals(expectedExpressions,e.get(age));
}

</code></pre>

<pre class="type-7 type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies whether objects/variable are equal to an expected value 
"></span><br>
@Test public void testAnalyzeNotIndexedButDefinedColumn() throws Exception {
  final ColumnDefinition firstName=getColumn(UTF8Type.instance.decompose("first_name"));
  final ColumnDefinition height=getColumn(UTF8Type.instance.decompose("height"));
  Map<Expression.Op,Expression> expressions;
  expressions=convert(Operation.analyzeGroup(controller,OperationType.AND,Arrays.asList(new SimpleExpression(firstName,Operator.EQ,UTF8Type.instance.decompose("a")),new SimpleExpression(height,Operator.NEQ,Int32Type.instance.decompose(5)))));
  Assert.assertEquals(2,expressions.size());
  Assert.assertEquals(new Expression("height",Int32Type.instance){
{
      operation=Op.NOT_EQ;
      lower=new Bound(Int32Type.instance.decompose(5),true);
      upper=lower;
    }
  }
,expressions.get(Expression.Op.NOT_EQ));
  expressions=convert(Operation.analyzeGroup(controller,OperationType.AND,Arrays.asList(new SimpleExpression(firstName,Operator.EQ,UTF8Type.instance.decompose("a")),new SimpleExpression(height,Operator.GT,Int32Type.instance.decompose(0)),new SimpleExpression(height,Operator.NEQ,Int32Type.instance.decompose(5)))));
  Assert.assertEquals(2,expressions.size());
  Assert.assertEquals(new Expression("height",Int32Type.instance){
{
      operation=Op.RANGE;
      lower=new Bound(Int32Type.instance.decompose(0),false);
      exclusions.add(Int32Type.instance.decompose(5));
    }
  }
,expressions.get(Expression.Op.RANGE));
  expressions=convert(Operation.analyzeGroup(controller,OperationType.AND,Arrays.asList(new SimpleExpression(firstName,Operator.EQ,UTF8Type.instance.decompose("a")),new SimpleExpression(height,Operator.NEQ,Int32Type.instance.decompose(5)),new SimpleExpression(height,Operator.GTE,Int32Type.instance.decompose(0)),new SimpleExpression(height,Operator.LT,Int32Type.instance.decompose(10)))));
  Assert.assertEquals(2,expressions.size());
  Assert.assertEquals(new Expression("height",Int32Type.instance){
{
      operation=Op.RANGE;
      lower=new Bound(Int32Type.instance.decompose(0),true);
      upper=new Bound(Int32Type.instance.decompose(10),false);
      exclusions.add(Int32Type.instance.decompose(5));
    }
  }
,expressions.get(Expression.Op.RANGE));
}

</code></pre>

<script>$(document).ready(function() {
  $('pre code').each(function(i, block) {
    hljs.highlightBlock(block);
  });
});</script>
