<h3><span class=" glyphicon glyphicon-tag"/>&nbspConditionMatcher</h3><kbd>Verifies logic rules using matcher-style statements</kbd><br><br><br><h4 style="margin:0px">Class: org.apache.hadoop.hive.ql.io.TestAcidInputFormat </h4><pre class="type-5 type-20 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies logic rules using matcher-style statements">ConditionMatcher</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies logic rules using matcher-style statements
"></span><br>
@Test public void testDeltaMetaDataReadFieldsWithStatementIdsResetsState() throws Exception {
  when(mockDataInput.readLong()).thenReturn(1L,2L);
  when(mockDataInput.readInt()).thenReturn(2,100,101);
  List<Integer> statementIds=new ArrayList<>();
  statementIds.add(97);
  statementIds.add(98);
  statementIds.add(99);
  DeltaMetaData deltaMetaData=new AcidInputFormat.DeltaMetaData(2000L,2001L,statementIds);
  deltaMetaData.readFields(mockDataInput);
  verify(mockDataInput,times(3)).readInt();
  assertThat(deltaMetaData.getMinTxnId(),is(1L));
  assertThat(deltaMetaData.getMaxTxnId(),is(2L));
  assertThat(deltaMetaData.getStmtIds().size(),is(2));
  assertThat(deltaMetaData.getStmtIds().get(0),is(100));
  assertThat(deltaMetaData.getStmtIds().get(1),is(101));
}

</code></pre>

<br>
<pre class="type-5 type-20 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies logic rules using matcher-style statements">ConditionMatcher</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies logic rules using matcher-style statements
"></span><br>
@Test public void testDeltaMetaConstructWithState() throws Exception {
  DeltaMetaData deltaMetaData=new AcidInputFormat.DeltaMetaData(2000L,2001L,Arrays.asList(97,98,99));
  assertThat(deltaMetaData.getMinTxnId(),is(2000L));
  assertThat(deltaMetaData.getMaxTxnId(),is(2001L));
  assertThat(deltaMetaData.getStmtIds().size(),is(3));
  assertThat(deltaMetaData.getStmtIds().get(0),is(97));
  assertThat(deltaMetaData.getStmtIds().get(1),is(98));
  assertThat(deltaMetaData.getStmtIds().get(2),is(99));
}

</code></pre>

<br>
<pre class="type-5 type-20 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies logic rules using matcher-style statements">ConditionMatcher</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies logic rules using matcher-style statements
"></span><br>
@Test public void testDeltaMetaDataReadFieldsWithStatementIds() throws Exception {
  when(mockDataInput.readLong()).thenReturn(1L,2L);
  when(mockDataInput.readInt()).thenReturn(2,100,101);
  DeltaMetaData deltaMetaData=new AcidInputFormat.DeltaMetaData();
  deltaMetaData.readFields(mockDataInput);
  verify(mockDataInput,times(3)).readInt();
  assertThat(deltaMetaData.getMinTxnId(),is(1L));
  assertThat(deltaMetaData.getMaxTxnId(),is(2L));
  assertThat(deltaMetaData.getStmtIds().size(),is(2));
  assertThat(deltaMetaData.getStmtIds().get(0),is(100));
  assertThat(deltaMetaData.getStmtIds().get(1),is(101));
}

</code></pre>

<br>
<pre class="type-5 type-20 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies logic rules using matcher-style statements">ConditionMatcher</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies logic rules using matcher-style statements
"></span><br>
@Test public void testDeltaMetaDataReadFieldsNoStatementIds() throws Exception {
  when(mockDataInput.readLong()).thenReturn(1L,2L);
  when(mockDataInput.readInt()).thenReturn(0);
  DeltaMetaData deltaMetaData=new AcidInputFormat.DeltaMetaData();
  deltaMetaData.readFields(mockDataInput);
  verify(mockDataInput,times(1)).readInt();
  assertThat(deltaMetaData.getMinTxnId(),is(1L));
  assertThat(deltaMetaData.getMaxTxnId(),is(2L));
  assertThat(deltaMetaData.getStmtIds().isEmpty(),is(true));
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hadoop.hive.ql.io.orc.TestRecordReaderImpl </h4><pre class="type-11 type-20 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies logic rules using matcher-style statements">ConditionMatcher</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies logic rules using matcher-style statements
"></span><br>
@Test public void testPartialPlanCompressed() throws Exception {
  DiskRangeList result;
  List<OrcProto.Stream> streams=new ArrayList<OrcProto.Stream>();
  streams.add(OrcProto.Stream.newBuilder().setKind(OrcProto.Stream.Kind.PRESENT).setColumn(1).setLength(1000).build());
  streams.add(OrcProto.Stream.newBuilder().setKind(OrcProto.Stream.Kind.DATA).setColumn(1).setLength(99000).build());
  streams.add(OrcProto.Stream.newBuilder().setKind(OrcProto.Stream.Kind.PRESENT).setColumn(2).setLength(2000).build());
  streams.add(OrcProto.Stream.newBuilder().setKind(OrcProto.Stream.Kind.DATA).setColumn(2).setLength(98000).build());
  boolean[] columns=new boolean[]{true,true,false};
  boolean[] rowGroups=new boolean[]{true,true,false,false,true,false};
  OrcProto.RowIndex[] indexes=new OrcProto.RowIndex[columns.length];
  indexes[1]=OrcProto.RowIndex.newBuilder().addEntry(OrcProto.RowIndexEntry.newBuilder().addPositions(0).addPositions(-1).addPositions(-1).addPositions(-1).addPositions(0).build()).addEntry(OrcProto.RowIndexEntry.newBuilder().addPositions(100).addPositions(-1).addPositions(-1).addPositions(-1).addPositions(10000).build()).addEntry(OrcProto.RowIndexEntry.newBuilder().addPositions(200).addPositions(-1).addPositions(-1).addPositions(-1).addPositions(20000).build()).addEntry(OrcProto.RowIndexEntry.newBuilder().addPositions(300).addPositions(-1).addPositions(-1).addPositions(-1).addPositions(30000).build()).addEntry(OrcProto.RowIndexEntry.newBuilder().addPositions(400).addPositions(-1).addPositions(-1).addPositions(-1).addPositions(40000).build()).addEntry(OrcProto.RowIndexEntry.newBuilder().addPositions(500).addPositions(-1).addPositions(-1).addPositions(-1).addPositions(50000).build()).build();
  List<OrcProto.ColumnEncoding> encodings=new ArrayList<OrcProto.ColumnEncoding>();
  encodings.add(OrcProto.ColumnEncoding.newBuilder().setKind(OrcProto.ColumnEncoding.Kind.DIRECT).build());
  encodings.add(OrcProto.ColumnEncoding.newBuilder().setKind(OrcProto.ColumnEncoding.Kind.DIRECT).build());
  encodings.add(OrcProto.ColumnEncoding.newBuilder().setKind(OrcProto.ColumnEncoding.Kind.DIRECT).build());
  List<OrcProto.Type> types=new ArrayList<OrcProto.Type>();
  types.add(OrcProto.Type.newBuilder().setKind(OrcProto.Type.Kind.STRUCT).addSubtypes(1).addSubtypes(2).addFieldNames("x").addFieldNames("y").build());
  types.add(OrcProto.Type.newBuilder().setKind(OrcProto.Type.Kind.INT).build());
  types.add(OrcProto.Type.newBuilder().setKind(OrcProto.Type.Kind.INT).build());
  result=RecordReaderImpl.planReadPartialDataStreams(streams,indexes,columns,rowGroups,true,encodings,types,32768,false);
  assertThat(result,is(diskRanges(0,1000,100,1000,400,1000,1000,11000 + (2 * 32771),11000,21000 + (2 * 32771),41000,100000)));
  rowGroups=new boolean[]{false,false,false,false,false,true};
  result=RecordReaderImpl.planReadPartialDataStreams(streams,indexes,columns,rowGroups,true,encodings,types,32768,false);
  assertThat(result,is(diskRanges(500,1000,51000,100000)));
}

</code></pre>

<br>
<pre class="type-11 type-20 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies logic rules using matcher-style statements">ConditionMatcher</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies logic rules using matcher-style statements
"></span><br>
@Test public void testPartialPlanString() throws Exception {
  DiskRangeList result;
  List<OrcProto.Stream> streams=new ArrayList<OrcProto.Stream>();
  streams.add(OrcProto.Stream.newBuilder().setKind(OrcProto.Stream.Kind.PRESENT).setColumn(1).setLength(1000).build());
  streams.add(OrcProto.Stream.newBuilder().setKind(OrcProto.Stream.Kind.DATA).setColumn(1).setLength(94000).build());
  streams.add(OrcProto.Stream.newBuilder().setKind(OrcProto.Stream.Kind.LENGTH).setColumn(1).setLength(2000).build());
  streams.add(OrcProto.Stream.newBuilder().setKind(OrcProto.Stream.Kind.DICTIONARY_DATA).setColumn(1).setLength(3000).build());
  streams.add(OrcProto.Stream.newBuilder().setKind(OrcProto.Stream.Kind.PRESENT).setColumn(2).setLength(2000).build());
  streams.add(OrcProto.Stream.newBuilder().setKind(OrcProto.Stream.Kind.DATA).setColumn(2).setLength(98000).build());
  boolean[] columns=new boolean[]{true,true,false};
  boolean[] rowGroups=new boolean[]{false,true,false,false,true,true};
  OrcProto.RowIndex[] indexes=new OrcProto.RowIndex[columns.length];
  indexes[1]=OrcProto.RowIndex.newBuilder().addEntry(OrcProto.RowIndexEntry.newBuilder().addPositions(0).addPositions(-1).addPositions(-1).addPositions(0).build()).addEntry(OrcProto.RowIndexEntry.newBuilder().addPositions(100).addPositions(-1).addPositions(-1).addPositions(10000).build()).addEntry(OrcProto.RowIndexEntry.newBuilder().addPositions(200).addPositions(-1).addPositions(-1).addPositions(20000).build()).addEntry(OrcProto.RowIndexEntry.newBuilder().addPositions(300).addPositions(-1).addPositions(-1).addPositions(30000).build()).addEntry(OrcProto.RowIndexEntry.newBuilder().addPositions(400).addPositions(-1).addPositions(-1).addPositions(40000).build()).addEntry(OrcProto.RowIndexEntry.newBuilder().addPositions(500).addPositions(-1).addPositions(-1).addPositions(50000).build()).build();
  List<OrcProto.ColumnEncoding> encodings=new ArrayList<OrcProto.ColumnEncoding>();
  encodings.add(OrcProto.ColumnEncoding.newBuilder().setKind(OrcProto.ColumnEncoding.Kind.DIRECT).build());
  encodings.add(OrcProto.ColumnEncoding.newBuilder().setKind(OrcProto.ColumnEncoding.Kind.DICTIONARY).build());
  encodings.add(OrcProto.ColumnEncoding.newBuilder().setKind(OrcProto.ColumnEncoding.Kind.DIRECT).build());
  List<OrcProto.Type> types=new ArrayList<OrcProto.Type>();
  types.add(OrcProto.Type.newBuilder().setKind(OrcProto.Type.Kind.STRUCT).addSubtypes(1).addSubtypes(2).addFieldNames("x").addFieldNames("y").build());
  types.add(OrcProto.Type.newBuilder().setKind(OrcProto.Type.Kind.STRING).build());
  types.add(OrcProto.Type.newBuilder().setKind(OrcProto.Type.Kind.INT).build());
  result=RecordReaderImpl.planReadPartialDataStreams(streams,indexes,columns,rowGroups,false,encodings,types,32768,false);
  assertThat(result,is(diskRanges(100,1000,400,1000,500,1000,11000,21000 + RecordReaderUtils.WORST_UNCOMPRESSED_SLOP,41000,51000 + RecordReaderUtils.WORST_UNCOMPRESSED_SLOP,51000,95000,95000,97000,97000,100000)));
}

</code></pre>

<br>
<pre class="type-11 type-8 type-20 type-9 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies logic rules using matcher-style statements">ConditionMatcher</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies whether objects are null
- Verifies logic rules using matcher-style statements
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testPartialPlan() throws Exception {
  DiskRangeList result;
  List<OrcProto.Stream> streams=new ArrayList<OrcProto.Stream>();
  streams.add(OrcProto.Stream.newBuilder().setKind(OrcProto.Stream.Kind.PRESENT).setColumn(1).setLength(1000).build());
  streams.add(OrcProto.Stream.newBuilder().setKind(OrcProto.Stream.Kind.DATA).setColumn(1).setLength(99000).build());
  streams.add(OrcProto.Stream.newBuilder().setKind(OrcProto.Stream.Kind.PRESENT).setColumn(2).setLength(2000).build());
  streams.add(OrcProto.Stream.newBuilder().setKind(OrcProto.Stream.Kind.DATA).setColumn(2).setLength(98000).build());
  boolean[] columns=new boolean[]{true,true,false};
  boolean[] rowGroups=new boolean[]{true,true,false,false,true,false};
  OrcProto.RowIndex[] indexes=new OrcProto.RowIndex[columns.length];
  indexes[1]=OrcProto.RowIndex.newBuilder().addEntry(OrcProto.RowIndexEntry.newBuilder().addPositions(0).addPositions(-1).addPositions(-1).addPositions(0).build()).addEntry(OrcProto.RowIndexEntry.newBuilder().addPositions(100).addPositions(-1).addPositions(-1).addPositions(10000).build()).addEntry(OrcProto.RowIndexEntry.newBuilder().addPositions(200).addPositions(-1).addPositions(-1).addPositions(20000).build()).addEntry(OrcProto.RowIndexEntry.newBuilder().addPositions(300).addPositions(-1).addPositions(-1).addPositions(30000).build()).addEntry(OrcProto.RowIndexEntry.newBuilder().addPositions(400).addPositions(-1).addPositions(-1).addPositions(40000).build()).addEntry(OrcProto.RowIndexEntry.newBuilder().addPositions(500).addPositions(-1).addPositions(-1).addPositions(50000).build()).build();
  List<OrcProto.ColumnEncoding> encodings=new ArrayList<OrcProto.ColumnEncoding>();
  encodings.add(OrcProto.ColumnEncoding.newBuilder().setKind(OrcProto.ColumnEncoding.Kind.DIRECT).build());
  encodings.add(OrcProto.ColumnEncoding.newBuilder().setKind(OrcProto.ColumnEncoding.Kind.DIRECT).build());
  encodings.add(OrcProto.ColumnEncoding.newBuilder().setKind(OrcProto.ColumnEncoding.Kind.DIRECT).build());
  List<OrcProto.Type> types=new ArrayList<OrcProto.Type>();
  types.add(OrcProto.Type.newBuilder().setKind(OrcProto.Type.Kind.STRUCT).addSubtypes(1).addSubtypes(2).addFieldNames("x").addFieldNames("y").build());
  types.add(OrcProto.Type.newBuilder().setKind(OrcProto.Type.Kind.INT).build());
  types.add(OrcProto.Type.newBuilder().setKind(OrcProto.Type.Kind.INT).build());
  result=RecordReaderImpl.planReadPartialDataStreams(streams,indexes,columns,rowGroups,false,encodings,types,32768,false);
  assertThat(result,is(diskRanges(0,1000,100,1000,400,1000,1000,11000 + RecordReaderUtils.WORST_UNCOMPRESSED_SLOP,11000,21000 + RecordReaderUtils.WORST_UNCOMPRESSED_SLOP,41000,51000 + RecordReaderUtils.WORST_UNCOMPRESSED_SLOP)));
  result=RecordReaderImpl.planReadPartialDataStreams(streams,indexes,columns,rowGroups,false,encodings,types,32768,true);
  assertThat(result,is(diskRanges(0,21000 + RecordReaderUtils.WORST_UNCOMPRESSED_SLOP,41000,51000 + RecordReaderUtils.WORST_UNCOMPRESSED_SLOP)));
  rowGroups=new boolean[]{false,false,false,false,false,false};
  result=RecordReaderImpl.planReadPartialDataStreams(streams,indexes,columns,rowGroups,false,encodings,types,32768,false);
  assertNull(result);
  rowGroups=null;
  columns=new boolean[]{true,false,true};
  result=RecordReaderImpl.planReadPartialDataStreams(streams,indexes,columns,null,false,encodings,types,32768,false);
  assertThat(result,is(diskRanges(100000,102000,102000,200000)));
  result=RecordReaderImpl.planReadPartialDataStreams(streams,indexes,columns,null,false,encodings,types,32768,true);
  assertThat(result,is(diskRanges(100000,200000)));
  rowGroups=new boolean[]{false,true,false,false,false,false};
  indexes[2]=indexes[1];
  indexes[1]=null;
  result=RecordReaderImpl.planReadPartialDataStreams(streams,indexes,columns,rowGroups,false,encodings,types,32768,false);
  assertThat(result,is(diskRanges(100100,102000,112000,122000 + RecordReaderUtils.WORST_UNCOMPRESSED_SLOP)));
  result=RecordReaderImpl.planReadPartialDataStreams(streams,indexes,columns,rowGroups,false,encodings,types,32768,true);
  assertThat(result,is(diskRanges(100100,102000,112000,122000 + RecordReaderUtils.WORST_UNCOMPRESSED_SLOP)));
  rowGroups=new boolean[]{false,false,false,false,false,true};
  indexes[1]=indexes[2];
  columns=new boolean[]{true,true,true};
  result=RecordReaderImpl.planReadPartialDataStreams(streams,indexes,columns,rowGroups,false,encodings,types,32768,false);
  assertThat(result,is(diskRanges(500,1000,51000,100000,100500,102000,152000,200000)));
  result=RecordReaderImpl.planReadPartialDataStreams(streams,indexes,columns,rowGroups,false,encodings,types,32768,true);
  assertThat(result,is(diskRanges(500,1000,51000,100000,100500,102000,152000,200000)));
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hive.hcatalog.streaming.mutate.TestMutations </h4><pre class="type-11 type-5 type-20 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies logic rules using matcher-style statements">ConditionMatcher</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies values of objects/variables related to AUT calls
- Verifies logic rules using matcher-style statements
"></span><br>
@Test public void testTransactionBatchAbort() throws Exception {
  Table table=partitionedTableBuilder.addPartition(ASIA_INDIA).create(metaStoreClient);
  MutatorClient client=new MutatorClientBuilder().addSinkTable(table.getDbName(),table.getTableName(),true).metaStoreUri(metaStoreUri).build();
  client.connect();
  Transaction transaction=client.newTransaction();
  List<AcidTable> destinations=client.getTables();
  transaction.begin();
  MutatorFactory mutatorFactory=new ReflectiveMutatorFactory(conf,MutableRecord.class,RECORD_ID_COLUMN,BUCKET_COLUMN_INDEXES);
  MutatorCoordinator coordinator=new MutatorCoordinatorBuilder().metaStoreUri(metaStoreUri).table(destinations.get(0)).mutatorFactory(mutatorFactory).build();
  BucketIdResolver bucketIdResolver=mutatorFactory.newBucketIdResolver(destinations.get(0).getTotalBuckets());
  MutableRecord record1=(MutableRecord)bucketIdResolver.attachBucketIdToRecord(new MutableRecord(1,"Hello streaming"));
  MutableRecord record2=(MutableRecord)bucketIdResolver.attachBucketIdToRecord(new MutableRecord(2,"Welcome to streaming"));
  coordinator.insert(ASIA_INDIA,record1);
  coordinator.insert(ASIA_INDIA,record2);
  coordinator.close();
  transaction.abort();
  assertThat(transaction.getState(),is(ABORTED));
  client.close();
  StreamingAssert streamingAssertions=assertionFactory.newStreamingAssert(table,ASIA_INDIA);
  streamingAssertions.assertNothingWritten();
}

</code></pre>

<br>
<pre class="type-11 type-5 type-20 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies logic rules using matcher-style statements">ConditionMatcher</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies values of objects/variables related to AUT calls
- Verifies logic rules using matcher-style statements
"></span><br>
@Test public void testTransactionBatchEmptyCommitUnpartitioned() throws Exception {
  Table table=unpartitionedTableBuilder.create(metaStoreClient);
  MutatorClient client=new MutatorClientBuilder().addSinkTable(table.getDbName(),table.getTableName(),false).metaStoreUri(metaStoreUri).build();
  client.connect();
  Transaction transaction=client.newTransaction();
  transaction.begin();
  transaction.commit();
  assertThat(transaction.getState(),is(COMMITTED));
  client.close();
}

</code></pre>

<br>
<pre class="type-11 type-5 type-20 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies logic rules using matcher-style statements">ConditionMatcher</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies values of objects/variables related to AUT calls
- Verifies logic rules using matcher-style statements
"></span><br>
@Test public void testMulti() throws Exception {
  Table table=partitionedTableBuilder.addPartition(ASIA_INDIA).create(metaStoreClient);
  MutatorClient client=new MutatorClientBuilder().addSinkTable(table.getDbName(),table.getTableName(),true).metaStoreUri(metaStoreUri).build();
  client.connect();
  Transaction transaction=client.newTransaction();
  List<AcidTable> destinations=client.getTables();
  transaction.begin();
  MutatorFactory mutatorFactory=new ReflectiveMutatorFactory(conf,MutableRecord.class,RECORD_ID_COLUMN,BUCKET_COLUMN_INDEXES);
  MutatorCoordinator coordinator=new MutatorCoordinatorBuilder().metaStoreUri(metaStoreUri).table(destinations.get(0)).mutatorFactory(mutatorFactory).build();
  BucketIdResolver bucketIdResolver=mutatorFactory.newBucketIdResolver(destinations.get(0).getTotalBuckets());
  MutableRecord asiaIndiaRecord1=(MutableRecord)bucketIdResolver.attachBucketIdToRecord(new MutableRecord(1,"Hello streaming"));
  MutableRecord europeUkRecord1=(MutableRecord)bucketIdResolver.attachBucketIdToRecord(new MutableRecord(2,"Hello streaming"));
  MutableRecord europeFranceRecord1=(MutableRecord)bucketIdResolver.attachBucketIdToRecord(new MutableRecord(3,"Hello streaming"));
  MutableRecord europeFranceRecord2=(MutableRecord)bucketIdResolver.attachBucketIdToRecord(new MutableRecord(4,"Bonjour streaming"));
  coordinator.insert(ASIA_INDIA,asiaIndiaRecord1);
  coordinator.insert(EUROPE_UK,europeUkRecord1);
  coordinator.insert(EUROPE_FRANCE,europeFranceRecord1);
  coordinator.insert(EUROPE_FRANCE,europeFranceRecord2);
  coordinator.close();
  transaction.commit();
  StreamingAssert streamingAssertions=assertionFactory.newStreamingAssert(table,ASIA_INDIA);
  streamingAssertions.assertMinTransactionId(1L);
  streamingAssertions.assertMaxTransactionId(1L);
  streamingAssertions.assertExpectedFileCount(1);
  List<Record> readRecords=streamingAssertions.readRecords();
  assertThat(readRecords.size(),is(1));
  assertThat(readRecords.get(0).getRow(),is("{1, Hello streaming}"));
  assertThat(readRecords.get(0).getRecordIdentifier(),is(new RecordIdentifier(1L,0,0L)));
  streamingAssertions=assertionFactory.newStreamingAssert(table,EUROPE_UK);
  streamingAssertions.assertMinTransactionId(1L);
  streamingAssertions.assertMaxTransactionId(1L);
  streamingAssertions.assertExpectedFileCount(1);
  readRecords=streamingAssertions.readRecords();
  assertThat(readRecords.size(),is(1));
  assertThat(readRecords.get(0).getRow(),is("{2, Hello streaming}"));
  assertThat(readRecords.get(0).getRecordIdentifier(),is(new RecordIdentifier(1L,0,0L)));
  streamingAssertions=assertionFactory.newStreamingAssert(table,EUROPE_FRANCE);
  streamingAssertions.assertMinTransactionId(1L);
  streamingAssertions.assertMaxTransactionId(1L);
  streamingAssertions.assertExpectedFileCount(1);
  readRecords=streamingAssertions.readRecords();
  assertThat(readRecords.size(),is(2));
  assertThat(readRecords.get(0).getRow(),is("{3, Hello streaming}"));
  assertThat(readRecords.get(0).getRecordIdentifier(),is(new RecordIdentifier(1L,0,0L)));
  assertThat(readRecords.get(1).getRow(),is("{4, Bonjour streaming}"));
  assertThat(readRecords.get(1).getRecordIdentifier(),is(new RecordIdentifier(1L,0,1L)));
  client.close();
}

</code></pre>

<br>
<pre class="type-11 type-5 type-20 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies logic rules using matcher-style statements">ConditionMatcher</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies values of objects/variables related to AUT calls
- Verifies logic rules using matcher-style statements
"></span><br>
@Test public void testTransactionBatchCommitUnpartitioned() throws Exception {
  Table table=unpartitionedTableBuilder.create(metaStoreClient);
  MutatorClient client=new MutatorClientBuilder().addSinkTable(table.getDbName(),table.getTableName(),false).metaStoreUri(metaStoreUri).build();
  client.connect();
  Transaction transaction=client.newTransaction();
  List<AcidTable> destinations=client.getTables();
  transaction.begin();
  MutatorFactory mutatorFactory=new ReflectiveMutatorFactory(conf,MutableRecord.class,RECORD_ID_COLUMN,BUCKET_COLUMN_INDEXES);
  MutatorCoordinator coordinator=new MutatorCoordinatorBuilder().metaStoreUri(metaStoreUri).table(destinations.get(0)).mutatorFactory(mutatorFactory).build();
  BucketIdResolver bucketIdResolver=mutatorFactory.newBucketIdResolver(destinations.get(0).getTotalBuckets());
  MutableRecord record=(MutableRecord)bucketIdResolver.attachBucketIdToRecord(new MutableRecord(1,"Hello streaming"));
  coordinator.insert(Collections.<String>emptyList(),record);
  coordinator.close();
  transaction.commit();
  StreamingAssert streamingAssertions=assertionFactory.newStreamingAssert(table);
  streamingAssertions.assertMinTransactionId(1L);
  streamingAssertions.assertMaxTransactionId(1L);
  streamingAssertions.assertExpectedFileCount(1);
  List<Record> readRecords=streamingAssertions.readRecords();
  assertThat(readRecords.size(),is(1));
  assertThat(readRecords.get(0).getRow(),is("{1, Hello streaming}"));
  assertThat(readRecords.get(0).getRecordIdentifier(),is(new RecordIdentifier(1L,0,0L)));
  assertThat(transaction.getState(),is(COMMITTED));
  client.close();
}

</code></pre>

<br>
<pre class="type-11 type-5 type-20 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies logic rules using matcher-style statements">ConditionMatcher</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies values of objects/variables related to AUT calls
- Verifies logic rules using matcher-style statements
"></span><br>
@Test public void testUpdatesAndDeletes() throws Exception {
  MutatorFactory mutatorFactory=new ReflectiveMutatorFactory(conf,MutableRecord.class,RECORD_ID_COLUMN,BUCKET_COLUMN_INDEXES);
  Table table=partitionedTableBuilder.addPartition(ASIA_INDIA).addPartition(EUROPE_FRANCE).create(metaStoreClient);
  MutatorClient client=new MutatorClientBuilder().addSinkTable(table.getDbName(),table.getTableName(),true).metaStoreUri(metaStoreUri).build();
  client.connect();
  Transaction insertTransaction=client.newTransaction();
  List<AcidTable> destinations=client.getTables();
  insertTransaction.begin();
  MutatorCoordinator insertCoordinator=new MutatorCoordinatorBuilder().metaStoreUri(metaStoreUri).table(destinations.get(0)).mutatorFactory(mutatorFactory).build();
  BucketIdResolver bucketIdResolver=mutatorFactory.newBucketIdResolver(destinations.get(0).getTotalBuckets());
  MutableRecord asiaIndiaRecord1=(MutableRecord)bucketIdResolver.attachBucketIdToRecord(new MutableRecord(1,"Namaste streaming 1"));
  MutableRecord asiaIndiaRecord2=(MutableRecord)bucketIdResolver.attachBucketIdToRecord(new MutableRecord(2,"Namaste streaming 2"));
  MutableRecord europeUkRecord1=(MutableRecord)bucketIdResolver.attachBucketIdToRecord(new MutableRecord(3,"Hello streaming 1"));
  MutableRecord europeUkRecord2=(MutableRecord)bucketIdResolver.attachBucketIdToRecord(new MutableRecord(4,"Hello streaming 2"));
  MutableRecord europeFranceRecord1=(MutableRecord)bucketIdResolver.attachBucketIdToRecord(new MutableRecord(5,"Bonjour streaming 1"));
  MutableRecord europeFranceRecord2=(MutableRecord)bucketIdResolver.attachBucketIdToRecord(new MutableRecord(6,"Bonjour streaming 2"));
  insertCoordinator.insert(ASIA_INDIA,asiaIndiaRecord1);
  insertCoordinator.insert(ASIA_INDIA,asiaIndiaRecord2);
  insertCoordinator.insert(EUROPE_UK,europeUkRecord1);
  insertCoordinator.insert(EUROPE_UK,europeUkRecord2);
  insertCoordinator.insert(EUROPE_FRANCE,europeFranceRecord1);
  insertCoordinator.insert(EUROPE_FRANCE,europeFranceRecord2);
  insertCoordinator.close();
  insertTransaction.commit();
  assertThat(insertTransaction.getState(),is(COMMITTED));
  client.close();
  client=new MutatorClientBuilder().addSinkTable(table.getDbName(),table.getTableName(),true).metaStoreUri(metaStoreUri).build();
  client.connect();
  Transaction mutateTransaction=client.newTransaction();
  destinations=client.getTables();
  mutateTransaction.begin();
  MutatorCoordinator mutateCoordinator=new MutatorCoordinatorBuilder().metaStoreUri(metaStoreUri).table(destinations.get(0)).mutatorFactory(mutatorFactory).build();
  bucketIdResolver=mutatorFactory.newBucketIdResolver(destinations.get(0).getTotalBuckets());
  MutableRecord asiaIndiaRecord3=(MutableRecord)bucketIdResolver.attachBucketIdToRecord(new MutableRecord(20,"Namaste streaming 3"));
  mutateCoordinator.update(ASIA_INDIA,new MutableRecord(2,"UPDATED: Namaste streaming 2",new RecordIdentifier(1L,0,1L)));
  mutateCoordinator.insert(ASIA_INDIA,asiaIndiaRecord3);
  mutateCoordinator.delete(EUROPE_UK,new MutableRecord(3,"Hello streaming 1",new RecordIdentifier(1L,0,0L)));
  mutateCoordinator.delete(EUROPE_FRANCE,new MutableRecord(5,"Bonjour streaming 1",new RecordIdentifier(1L,0,0L)));
  mutateCoordinator.update(EUROPE_FRANCE,new MutableRecord(6,"UPDATED: Bonjour streaming 2",new RecordIdentifier(1L,0,1L)));
  mutateCoordinator.close();
  mutateTransaction.commit();
  assertThat(mutateTransaction.getState(),is(COMMITTED));
  StreamingAssert indiaAssertions=assertionFactory.newStreamingAssert(table,ASIA_INDIA);
  indiaAssertions.assertMinTransactionId(1L);
  indiaAssertions.assertMaxTransactionId(2L);
  List<Record> indiaRecords=indiaAssertions.readRecords();
  assertThat(indiaRecords.size(),is(3));
  assertThat(indiaRecords.get(0).getRow(),is("{1, Namaste streaming 1}"));
  assertThat(indiaRecords.get(0).getRecordIdentifier(),is(new RecordIdentifier(1L,0,0L)));
  assertThat(indiaRecords.get(1).getRow(),is("{2, UPDATED: Namaste streaming 2}"));
  assertThat(indiaRecords.get(1).getRecordIdentifier(),is(new RecordIdentifier(1L,0,1L)));
  assertThat(indiaRecords.get(2).getRow(),is("{20, Namaste streaming 3}"));
  assertThat(indiaRecords.get(2).getRecordIdentifier(),is(new RecordIdentifier(2L,0,0L)));
  StreamingAssert ukAssertions=assertionFactory.newStreamingAssert(table,EUROPE_UK);
  ukAssertions.assertMinTransactionId(1L);
  ukAssertions.assertMaxTransactionId(2L);
  List<Record> ukRecords=ukAssertions.readRecords();
  assertThat(ukRecords.size(),is(1));
  assertThat(ukRecords.get(0).getRow(),is("{4, Hello streaming 2}"));
  assertThat(ukRecords.get(0).getRecordIdentifier(),is(new RecordIdentifier(1L,0,1L)));
  StreamingAssert franceAssertions=assertionFactory.newStreamingAssert(table,EUROPE_FRANCE);
  franceAssertions.assertMinTransactionId(1L);
  franceAssertions.assertMaxTransactionId(2L);
  List<Record> franceRecords=franceAssertions.readRecords();
  assertThat(franceRecords.size(),is(1));
  assertThat(franceRecords.get(0).getRow(),is("{6, UPDATED: Bonjour streaming 2}"));
  assertThat(franceRecords.get(0).getRecordIdentifier(),is(new RecordIdentifier(1L,0,1L)));
  client.close();
}

</code></pre>

<br>
<pre class="type-11 type-5 type-20 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies logic rules using matcher-style statements">ConditionMatcher</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies values of objects/variables related to AUT calls
- Verifies logic rules using matcher-style statements
"></span><br>
@Test public void testTransactionBatchEmptyAbortPartitioned() throws Exception {
  Table table=partitionedTableBuilder.addPartition(ASIA_INDIA).create(metaStoreClient);
  MutatorClient client=new MutatorClientBuilder().addSinkTable(table.getDbName(),table.getTableName(),true).metaStoreUri(metaStoreUri).build();
  client.connect();
  Transaction transaction=client.newTransaction();
  List<AcidTable> destinations=client.getTables();
  transaction.begin();
  MutatorFactory mutatorFactory=new ReflectiveMutatorFactory(conf,MutableRecord.class,RECORD_ID_COLUMN,BUCKET_COLUMN_INDEXES);
  MutatorCoordinator coordinator=new MutatorCoordinatorBuilder().metaStoreUri(metaStoreUri).table(destinations.get(0)).mutatorFactory(mutatorFactory).build();
  coordinator.close();
  transaction.abort();
  assertThat(transaction.getState(),is(ABORTED));
  client.close();
}

</code></pre>

<br>
<pre class="type-11 type-5 type-20 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies logic rules using matcher-style statements">ConditionMatcher</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies values of objects/variables related to AUT calls
- Verifies logic rules using matcher-style statements
"></span><br>
@Test public void testTransactionBatchCommitPartitioned() throws Exception {
  Table table=partitionedTableBuilder.addPartition(ASIA_INDIA).create(metaStoreClient);
  MutatorClient client=new MutatorClientBuilder().addSinkTable(table.getDbName(),table.getTableName(),true).metaStoreUri(metaStoreUri).build();
  client.connect();
  Transaction transaction=client.newTransaction();
  List<AcidTable> destinations=client.getTables();
  transaction.begin();
  MutatorFactory mutatorFactory=new ReflectiveMutatorFactory(conf,MutableRecord.class,RECORD_ID_COLUMN,BUCKET_COLUMN_INDEXES);
  MutatorCoordinator coordinator=new MutatorCoordinatorBuilder().metaStoreUri(metaStoreUri).table(destinations.get(0)).mutatorFactory(mutatorFactory).build();
  BucketIdResolver bucketIdAppender=mutatorFactory.newBucketIdResolver(destinations.get(0).getTotalBuckets());
  MutableRecord record=(MutableRecord)bucketIdAppender.attachBucketIdToRecord(new MutableRecord(1,"Hello streaming"));
  coordinator.insert(ASIA_INDIA,record);
  coordinator.close();
  transaction.commit();
  StreamingAssert streamingAssertions=assertionFactory.newStreamingAssert(table,ASIA_INDIA);
  streamingAssertions.assertMinTransactionId(1L);
  streamingAssertions.assertMaxTransactionId(1L);
  streamingAssertions.assertExpectedFileCount(1);
  List<Record> readRecords=streamingAssertions.readRecords();
  assertThat(readRecords.size(),is(1));
  assertThat(readRecords.get(0).getRow(),is("{1, Hello streaming}"));
  assertThat(readRecords.get(0).getRecordIdentifier(),is(new RecordIdentifier(1L,0,0L)));
  assertThat(transaction.getState(),is(COMMITTED));
  client.close();
}

</code></pre>

<br>
<pre class="type-11 type-5 type-20 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies logic rules using matcher-style statements">ConditionMatcher</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies values of objects/variables related to AUT calls
- Verifies logic rules using matcher-style statements
"></span><br>
@Test public void testTransactionBatchEmptyAbortUnartitioned() throws Exception {
  Table table=unpartitionedTableBuilder.create(metaStoreClient);
  MutatorClient client=new MutatorClientBuilder().addSinkTable(table.getDbName(),table.getTableName(),false).metaStoreUri(metaStoreUri).build();
  client.connect();
  Transaction transaction=client.newTransaction();
  List<AcidTable> destinations=client.getTables();
  transaction.begin();
  MutatorFactory mutatorFactory=new ReflectiveMutatorFactory(conf,MutableRecord.class,RECORD_ID_COLUMN,BUCKET_COLUMN_INDEXES);
  MutatorCoordinator coordinator=new MutatorCoordinatorBuilder().metaStoreUri(metaStoreUri).table(destinations.get(0)).mutatorFactory(mutatorFactory).build();
  coordinator.close();
  transaction.abort();
  assertThat(transaction.getState(),is(ABORTED));
  client.close();
}

</code></pre>

<br>
<pre class="type-11 type-5 type-20 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies logic rules using matcher-style statements">ConditionMatcher</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies values of objects/variables related to AUT calls
- Verifies logic rules using matcher-style statements
"></span><br>
@Test public void testTransactionBatchEmptyCommitPartitioned() throws Exception {
  Table table=partitionedTableBuilder.addPartition(ASIA_INDIA).create(metaStoreClient);
  MutatorClient client=new MutatorClientBuilder().addSinkTable(table.getDbName(),table.getTableName(),true).metaStoreUri(metaStoreUri).build();
  client.connect();
  Transaction transaction=client.newTransaction();
  transaction.begin();
  transaction.commit();
  assertThat(transaction.getState(),is(COMMITTED));
  client.close();
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hive.hcatalog.streaming.mutate.client.TestAcidTableSerializer </h4><pre class="type-11 type-5 type-20 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies logic rules using matcher-style statements">ConditionMatcher</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies values of objects/variables related to AUT calls
- Verifies logic rules using matcher-style statements
"></span><br>
@Test public void testSerializeDeserializeNoTableNoTransaction() throws Exception {
  AcidTable acidTable=new AcidTable("db_1","table_1",true,TableType.SINK);
  String encoded=AcidTableSerializer.encode(acidTable);
  AcidTable decoded=AcidTableSerializer.decode(encoded);
  assertThat(decoded.getDatabaseName(),is("db_1"));
  assertThat(decoded.getTableName(),is("table_1"));
  assertThat(decoded.createPartitions(),is(true));
  assertThat(decoded.getOutputFormatName(),is(nullValue()));
  assertThat(decoded.getTotalBuckets(),is(0));
  assertThat(decoded.getQualifiedName(),is("DB_1.TABLE_1"));
  assertThat(decoded.getTransactionId(),is(0L));
  assertThat(decoded.getTableType(),is(TableType.SINK));
  assertThat(decoded.getTable(),is(nullValue()));
}

</code></pre>

<br>
<pre class="type-11 type-5 type-20 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies logic rules using matcher-style statements">ConditionMatcher</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies values of objects/variables related to AUT calls
- Verifies logic rules using matcher-style statements
"></span><br>
@Test public void testSerializeDeserialize() throws Exception {
  Database database=StreamingTestUtils.databaseBuilder(new File("/tmp")).name("db_1").build();
  Table table=StreamingTestUtils.tableBuilder(database).name("table_1").addColumn("one","string").addColumn("two","integer").partitionKeys("partition").addPartition("p1").buckets(10).build();
  AcidTable acidTable=new AcidTable("db_1","table_1",true,TableType.SINK);
  acidTable.setTable(table);
  acidTable.setTransactionId(42L);
  String encoded=AcidTableSerializer.encode(acidTable);
  System.out.println(encoded);
  AcidTable decoded=AcidTableSerializer.decode(encoded);
  assertThat(decoded.getDatabaseName(),is("db_1"));
  assertThat(decoded.getTableName(),is("table_1"));
  assertThat(decoded.createPartitions(),is(true));
  assertThat(decoded.getOutputFormatName(),is("org.apache.hadoop.hive.ql.io.orc.OrcOutputFormat"));
  assertThat(decoded.getTotalBuckets(),is(10));
  assertThat(decoded.getQualifiedName(),is("DB_1.TABLE_1"));
  assertThat(decoded.getTransactionId(),is(42L));
  assertThat(decoded.getTableType(),is(TableType.SINK));
  assertThat(decoded.getTable(),is(table));
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hive.hcatalog.streaming.mutate.client.TestMutatorClient </h4><pre class="type-5 type-20 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies logic rules using matcher-style statements">ConditionMatcher</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies logic rules using matcher-style statements
"></span><br>
@Test public void testCheckValidTableConnect() throws Exception {
  List<AcidTable> inTables=new ArrayList<>();
  inTables.add(TABLE_1);
  inTables.add(TABLE_2);
  client=new MutatorClient(mockMetaStoreClient,mockConfiguration,mockLockFailureListener,USER,inTables);
  client.connect();
  List<AcidTable> outTables=client.getTables();
  assertThat(client.isConnected(),is(true));
  assertThat(outTables.size(),is(2));
  assertThat(outTables.get(0).getDatabaseName(),is(DB_NAME));
  assertThat(outTables.get(0).getTableName(),is(TABLE_NAME_1));
  assertThat(outTables.get(0).getTotalBuckets(),is(2));
  assertThat(outTables.get(0).getOutputFormatName(),is(OrcOutputFormat.class.getName()));
  assertThat(outTables.get(0).getTransactionId(),is(0L));
  assertThat(outTables.get(0).getTable(),is(mockTable1));
  assertThat(outTables.get(1).getDatabaseName(),is(DB_NAME));
  assertThat(outTables.get(1).getTableName(),is(TABLE_NAME_2));
  assertThat(outTables.get(1).getTotalBuckets(),is(2));
  assertThat(outTables.get(1).getOutputFormatName(),is(OrcOutputFormat.class.getName()));
  assertThat(outTables.get(1).getTransactionId(),is(0L));
  assertThat(outTables.get(1).getTable(),is(mockTable2));
}

</code></pre>

<br>
<pre class="type-3 type-5 type-20 type-9 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies logic rules using matcher-style statements">ConditionMatcher</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies logic rules using matcher-style statements
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testMetaStoreFailsOnConnect() throws Exception {
  when(mockMetaStoreClient.getTable(anyString(),anyString())).thenThrow(new TException());
  try {
    client.connect();
    fail();
  }
 catch (  ConnectionException e) {
  }
  assertThat(client.isConnected(),is(false));
}

</code></pre>

<br>
<pre class="type-5 type-20 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies logic rules using matcher-style statements">ConditionMatcher</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies logic rules using matcher-style statements
"></span><br>
@Test public void testNewTransaction() throws Exception {
  List<AcidTable> inTables=new ArrayList<>();
  inTables.add(TABLE_1);
  inTables.add(TABLE_2);
  client=new MutatorClient(mockMetaStoreClient,mockConfiguration,mockLockFailureListener,USER,inTables);
  client.connect();
  Transaction transaction=client.newTransaction();
  List<AcidTable> outTables=client.getTables();
  assertThat(client.isConnected(),is(true));
  assertThat(transaction.getTransactionId(),is(TRANSACTION_ID));
  assertThat(transaction.getState(),is(TxnState.INACTIVE));
  assertThat(outTables.get(0).getTransactionId(),is(TRANSACTION_ID));
  assertThat(outTables.get(1).getTransactionId(),is(TRANSACTION_ID));
}

</code></pre>

<br>
<pre class="type-3 type-5 type-20 type-9 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies logic rules using matcher-style statements">ConditionMatcher</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies logic rules using matcher-style statements
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testCheckNonTransactionalTableConnect() throws Exception {
  when(mockParameters.get("transactional")).thenReturn(Boolean.FALSE.toString());
  try {
    client.connect();
    fail();
  }
 catch (  ConnectionException e) {
  }
  assertThat(client.isConnected(),is(false));
}

</code></pre>

<br>
<pre class="type-5 type-20 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies logic rules using matcher-style statements">ConditionMatcher</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies logic rules using matcher-style statements
"></span><br>
@Test public void testCloseClosesClient() throws Exception {
  client.close();
  assertThat(client.isConnected(),is(false));
  verify(mockMetaStoreClient).close();
}

</code></pre>

<br>
<pre class="type-3 type-5 type-20 type-9 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies logic rules using matcher-style statements">ConditionMatcher</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies logic rules using matcher-style statements
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testCheckUnBucketedTableConnect() throws Exception {
  when(mockSd.getNumBuckets()).thenReturn(0);
  try {
    client.connect();
    fail();
  }
 catch (  ConnectionException e) {
  }
  assertThat(client.isConnected(),is(false));
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hive.hcatalog.streaming.mutate.client.TestTransaction </h4><pre class="type-5 type-20 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies logic rules using matcher-style statements">ConditionMatcher</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies logic rules using matcher-style statements
"></span><br>
@Test public void testCommit() throws Exception {
  transaction.commit();
  verify(mockLock).release();
  verify(mockMetaStoreClient).commitTxn(TRANSACTION_ID);
  assertThat(transaction.getState(),is(TransactionBatch.TxnState.COMMITTED));
}

</code></pre>

<br>
<pre class="type-5 type-20 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies logic rules using matcher-style statements">ConditionMatcher</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies logic rules using matcher-style statements
"></span><br>
@Test public void testBeginLockFails() throws Exception {
  doThrow(new LockException("")).when(mockLock).acquire(TRANSACTION_ID);
  try {
    transaction.begin();
  }
 catch (  TransactionException ignore) {
  }
  assertThat(transaction.getState(),is(TransactionBatch.TxnState.INACTIVE));
}

</code></pre>

<br>
<pre class="type-5 type-20 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies logic rules using matcher-style statements">ConditionMatcher</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies logic rules using matcher-style statements
"></span><br>
@Test public void testAbort() throws Exception {
  transaction.abort();
  verify(mockLock).release();
  verify(mockMetaStoreClient).rollbackTxn(TRANSACTION_ID);
  assertThat(transaction.getState(),is(TransactionBatch.TxnState.ABORTED));
}

</code></pre>

<br>
<pre class="type-5 type-20 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies logic rules using matcher-style statements">ConditionMatcher</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies logic rules using matcher-style statements
"></span><br>
@Test public void testInitialState(){
  assertThat(transaction.getState(),is(TransactionBatch.TxnState.INACTIVE));
  assertThat(transaction.getTransactionId(),is(TRANSACTION_ID));
}

</code></pre>

<br>
<pre class="type-5 type-20 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies logic rules using matcher-style statements">ConditionMatcher</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies logic rules using matcher-style statements
"></span><br>
@Test public void testBegin() throws Exception {
  transaction.begin();
  verify(mockLock).acquire(TRANSACTION_ID);
  assertThat(transaction.getState(),is(TransactionBatch.TxnState.OPEN));
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hive.hcatalog.streaming.mutate.worker.TestBucketIdResolverImpl </h4><pre class="type-20 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies logic rules using matcher-style statements">ConditionMatcher</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies logic rules using matcher-style statements
"></span><br>
@Test public void testAttachBucketIdToRecord(){
  MutableRecord record=new MutableRecord(1,"hello");
  capturingBucketIdResolver.attachBucketIdToRecord(record);
  assertThat(record.rowId,is(new RecordIdentifier(-1L,1,-1L)));
  assertThat(record.id,is(1));
  assertThat(record.msg.toString(),is("hello"));
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hive.hcatalog.streaming.mutate.worker.TestMetaStorePartitionHelper </h4><pre class="type-5 type-20 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies logic rules using matcher-style statements">ConditionMatcher</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies logic rules using matcher-style statements
"></span><br>
@Test public void getPathForPartitionedTable() throws Exception {
  Path path=helper.getPathForPartition(PARTITIONED_VALUES);
  assertThat(path,is(PARTITION_PATH));
}

</code></pre>

<br>
<pre class="type-5 type-20 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies logic rules using matcher-style statements">ConditionMatcher</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies logic rules using matcher-style statements
"></span><br>
@Test public void getPathForUnpartitionedTable() throws Exception {
  Path path=helper.getPathForPartition(UNPARTITIONED_VALUES);
  assertThat(path,is(TABLE_PATH));
  verifyZeroInteractions(mockClient);
}

</code></pre>

<br>
<pre class="type-5 type-20 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies logic rules using matcher-style statements">ConditionMatcher</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies logic rules using matcher-style statements
"></span><br>
@Test public void createOnPartitionTable() throws Exception {
  helper.createPartitionIfNotExists(PARTITIONED_VALUES);
  verify(mockClient).add_partition(partitionCaptor.capture());
  Partition actual=partitionCaptor.getValue();
  assertThat(actual.getSd().getLocation(),is(PARTITION_LOCATION));
  assertThat(actual.getValues(),is(PARTITIONED_VALUES));
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hive.hcatalog.streaming.mutate.worker.TestMutatorImpl </h4><pre class="type-5 type-20 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies logic rules using matcher-style statements">ConditionMatcher</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies logic rules using matcher-style statements
"></span><br>
@Test public void testCreatesRecordReader() throws IOException {
  verify(mockOutputFormat).getRecordUpdater(eq(PATH),captureOptions.capture());
  Options options=captureOptions.getValue();
  assertThat(options.getBucket(),is(BUCKET_ID));
  assertThat(options.getConfiguration(),is((Configuration)configuration));
  assertThat(options.getInspector(),is(mockObjectInspector));
  assertThat(options.getRecordIdColumn(),is(RECORD_ID_COLUMN));
  assertThat(options.getMinimumTransactionId(),is(TRANSACTION_ID));
  assertThat(options.getMaximumTransactionId(),is(TRANSACTION_ID));
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hive.hcatalog.streaming.mutate.worker.TestRecordInspectorImpl </h4><pre class="type-20 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies logic rules using matcher-style statements">ConditionMatcher</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies logic rules using matcher-style statements
"></span><br>
@Test public void testExtractRecordIdentifier(){
  RecordIdentifier recordIdentifier=new RecordIdentifier(10L,4,20L);
  MutableRecord record=new MutableRecord(1,"hello",recordIdentifier);
  assertThat(inspector.extractRecordIdentifier(record),is(recordIdentifier));
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hive.hcatalog.streaming.mutate.worker.TestSequenceValidator </h4><pre class="type-5 type-20 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies logic rules using matcher-style statements">ConditionMatcher</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies logic rules using matcher-style statements
"></span><br>
@Test public void testRowIdOutOfSequence(){
  assertThat(validator.isInSequence(new RecordIdentifier(0L,BUCKET_ID,0)),is(true));
  assertThat(validator.isInSequence(new RecordIdentifier(0L,BUCKET_ID,4)),is(true));
  assertThat(validator.isInSequence(new RecordIdentifier(0L,BUCKET_ID,1)),is(false));
}

</code></pre>

<br>
<pre class="type-5 type-20 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies logic rules using matcher-style statements">ConditionMatcher</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies logic rules using matcher-style statements
"></span><br>
@Test public void testRowIdInSequence(){
  assertThat(validator.isInSequence(new RecordIdentifier(0L,BUCKET_ID,0)),is(true));
  assertThat(validator.isInSequence(new RecordIdentifier(0L,BUCKET_ID,1)),is(true));
  assertThat(validator.isInSequence(new RecordIdentifier(0L,BUCKET_ID,4)),is(true));
}

</code></pre>

<br>
<pre class="type-5 type-20 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies logic rules using matcher-style statements">ConditionMatcher</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies logic rules using matcher-style statements
"></span><br>
@Test public void testTxIdInSequence(){
  assertThat(validator.isInSequence(new RecordIdentifier(0L,BUCKET_ID,0)),is(true));
  assertThat(validator.isInSequence(new RecordIdentifier(1L,BUCKET_ID,0)),is(true));
  assertThat(validator.isInSequence(new RecordIdentifier(4L,BUCKET_ID,0)),is(true));
}

</code></pre>

<br>
<pre class="type-20 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies logic rules using matcher-style statements">ConditionMatcher</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies logic rules using matcher-style statements
"></span><br>
@Test public void testSingleInSequence(){
  assertThat(validator.isInSequence(new RecordIdentifier(0L,BUCKET_ID,0)),is(true));
}

</code></pre>

<br>
<pre class="type-5 type-20 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies logic rules using matcher-style statements">ConditionMatcher</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies logic rules using matcher-style statements
"></span><br>
@Test public void testTxIdOutOfSequence(){
  assertThat(validator.isInSequence(new RecordIdentifier(0L,BUCKET_ID,0)),is(true));
  assertThat(validator.isInSequence(new RecordIdentifier(4L,BUCKET_ID,0)),is(true));
  assertThat(validator.isInSequence(new RecordIdentifier(1L,BUCKET_ID,0)),is(false));
}

</code></pre>

<br>
<pre class="type-5 type-20 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies logic rules using matcher-style statements">ConditionMatcher</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies logic rules using matcher-style statements
"></span><br>
@Test public void testMixedOutOfSequence(){
  assertThat(validator.isInSequence(new RecordIdentifier(0L,BUCKET_ID,0)),is(true));
  assertThat(validator.isInSequence(new RecordIdentifier(1L,BUCKET_ID,4)),is(true));
  assertThat(validator.isInSequence(new RecordIdentifier(1L,BUCKET_ID,0)),is(false));
  assertThat(validator.isInSequence(new RecordIdentifier(1L,BUCKET_ID,5)),is(true));
  assertThat(validator.isInSequence(new RecordIdentifier(0L,BUCKET_ID,6)),is(false));
}

</code></pre>

<br>
<pre class="type-5 type-20 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies logic rules using matcher-style statements">ConditionMatcher</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies logic rules using matcher-style statements
"></span><br>
@Test public void testReset(){
  assertThat(validator.isInSequence(new RecordIdentifier(0L,BUCKET_ID,0)),is(true));
  assertThat(validator.isInSequence(new RecordIdentifier(0L,BUCKET_ID,4)),is(true));
  validator.reset();
  assertThat(validator.isInSequence(new RecordIdentifier(0L,BUCKET_ID,1)),is(true));
}

</code></pre>

<br>
<pre class="type-5 type-20 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies logic rules using matcher-style statements">ConditionMatcher</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies logic rules using matcher-style statements
"></span><br>
@Test public void testNegativeTxId(){
  assertThat(validator.isInSequence(new RecordIdentifier(-1L,BUCKET_ID,0)),is(true));
  assertThat(validator.isInSequence(new RecordIdentifier(0L,BUCKET_ID,0)),is(true));
}

</code></pre>

<br>
<pre class="type-5 type-20 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies logic rules using matcher-style statements">ConditionMatcher</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies logic rules using matcher-style statements
"></span><br>
@Test public void testMixedInSequence(){
  assertThat(validator.isInSequence(new RecordIdentifier(0L,BUCKET_ID,0)),is(true));
  assertThat(validator.isInSequence(new RecordIdentifier(0L,BUCKET_ID,1)),is(true));
  assertThat(validator.isInSequence(new RecordIdentifier(1L,BUCKET_ID,0)),is(true));
  assertThat(validator.isInSequence(new RecordIdentifier(1L,BUCKET_ID,1)),is(true));
}

</code></pre>

<br>
<pre class="type-5 type-20 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies logic rules using matcher-style statements">ConditionMatcher</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies logic rules using matcher-style statements
"></span><br>
@Test public void testNegativeRowId(){
  assertThat(validator.isInSequence(new RecordIdentifier(0L,BUCKET_ID,-1)),is(true));
  assertThat(validator.isInSequence(new RecordIdentifier(0L,BUCKET_ID,0)),is(true));
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.hive.hcatalog.streaming.mutate.worker.TestWarehousePartitionHelper </h4><pre class="type-5 type-20 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies logic rules using matcher-style statements">ConditionMatcher</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies logic rules using matcher-style statements
"></span><br>
@Test public void getPathForPartitionedTable() throws Exception {
  Path path=partitionedHelper.getPathForPartition(PARTITIONED_VALUES);
  assertThat(path,is(new Path(TABLE_PATH,"A=1/B=2")));
}

</code></pre>

<br>
<pre class="type-5 type-20 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies logic rules using matcher-style statements">ConditionMatcher</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies logic rules using matcher-style statements
"></span><br>
@Test public void getPathForUnpartitionedTable() throws Exception {
  Path path=unpartitionedHelper.getPathForPartition(UNPARTITIONED_VALUES);
  assertThat(path,is(TABLE_PATH));
}

</code></pre>

<br>
<script>$(document).ready(function() {
  $('pre code').each(function(i, block) {
    hljs.highlightBlock(block);
  });
});</script>
