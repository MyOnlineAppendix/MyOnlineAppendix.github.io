<h3><span class=" glyphicon glyphicon-tag"/>&nbspUtilityVerifier</h3><kbd>Verifies (un)successful execution of the test case by reporting explicitly a failure</kbd><br><br><br><h4 style="margin:0px">Class: org.apache.accumulo.core.cli.TestClientOpts </h4><pre class="type-8 type-5 type-3 type-7 type-2 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void test() throws Exception {
  BatchWriterConfig cfg=new BatchWriterConfig();
  ClientOpts args=new ClientOpts();
  BatchWriterOpts bwOpts=new BatchWriterOpts();
  BatchScannerOpts bsOpts=new BatchScannerOpts();
  try {
    assertNull(args.getPrincipal());
    fail("Expected to receive exception fetching non-existent principal");
  }
 catch (  AccumuloSecurityException e) {
  }
  assertNull(args.getSecurePassword());
  assertNull(args.getToken());
  assertEquals(Long.valueOf(cfg.getMaxLatency(TimeUnit.MILLISECONDS)),bwOpts.batchLatency);
  assertEquals(Long.valueOf(cfg.getTimeout(TimeUnit.MILLISECONDS)),bwOpts.batchTimeout);
  assertEquals(Long.valueOf(cfg.getMaxMemory()),bwOpts.batchMemory);
  assertFalse(args.debug);
  assertFalse(args.trace);
  assertEquals(10,bsOpts.scanThreads.intValue());
  assertEquals(null,args.instance);
  assertEquals(Authorizations.EMPTY,args.auths);
  assertEquals("localhost:2181",args.zookeepers);
  assertFalse(args.help);
  JCommander jc=new JCommander();
  jc.addObject(args);
  jc.addObject(bwOpts);
  jc.addObject(bsOpts);
  jc.parse("-u","bar","-p","foo","--batchLatency","3s","--batchTimeout","2s","--batchMemory","1M","--debug","--trace","--scanThreads","7","-i","instance","--auths","G1,G2,G3","-z","zoohost1,zoohost2","--help");
  assertEquals("bar",args.getPrincipal());
  assertNull(args.getSecurePassword());
  assertEquals(new PasswordToken("foo"),args.getToken());
  assertEquals(Long.valueOf(3000),bwOpts.batchLatency);
  assertEquals(Long.valueOf(2000),bwOpts.batchTimeout);
  assertEquals(Long.valueOf(1024 * 1024),bwOpts.batchMemory);
  assertTrue(args.debug);
  assertTrue(args.trace);
  assertEquals(7,bsOpts.scanThreads.intValue());
  assertEquals("instance",args.instance);
  assertEquals(new Authorizations("G1","G2","G3"),args.auths);
  assertEquals("zoohost1,zoohost2",args.zookeepers);
  assertTrue(args.help);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.accumulo.core.client.RowIteratorTest </h4><pre class="type-8 type-5 type-3 type-2 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testUnreadRow(){
  final RowIterator i=new RowIterator(makeIterator("a b c d","a 1 2 3","b 1 2 3"));
  assertTrue(i.hasNext());
  Iterator<Entry<Key,Value>> firstRow=i.next();
  assertEquals(0,i.getKVCount());
  assertTrue(i.hasNext());
  assertEquals(2,i.getKVCount());
  Iterator<Entry<Key,Value>> nextRow=i.next();
  assertEquals(2,i.getKVCount());
  assertFalse(i.hasNext());
  assertEquals(3,i.getKVCount());
  try {
    firstRow.hasNext();
    fail();
  }
 catch (  IllegalStateException e) {
  }
  try {
    nextRow.next();
    fail();
  }
 catch (  IllegalStateException e) {
  }
}

</code></pre>

<br>
<pre class="type-8 type-5 type-3 type-2 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testRowIterator(){
  List<List<Entry<Key,Value>>> rows=getRows(makeIterator());
  assertEquals(0,rows.size());
  rows=getRows(makeIterator("a b c d"));
  assertEquals(1,rows.size());
  assertEquals(1,rows.get(0).size());
  rows=getRows(makeIterator("a cf cq1 v","a cf cq2 v","a cf cq3 v","b cf cq1 x"));
  assertEquals(2,rows.size());
  assertEquals(3,rows.get(0).size());
  assertEquals(1,rows.get(1).size());
  RowIterator i=new RowIterator(makeIterator());
  try {
    i.next();
    fail();
  }
 catch (  NoSuchElementException ex) {
  }
  i=new RowIterator(makeIterator("a b c d","a 1 2 3"));
  assertTrue(i.hasNext());
  Iterator<Entry<Key,Value>> row=i.next();
  assertTrue(row.hasNext());
  row.next();
  assertTrue(row.hasNext());
  row.next();
  assertFalse(row.hasNext());
  try {
    row.next();
    fail();
  }
 catch (  NoSuchElementException ex) {
  }
  assertEquals(0,i.getKVCount());
  assertFalse(i.hasNext());
  assertEquals(2,i.getKVCount());
  try {
    i.next();
    fail();
  }
 catch (  NoSuchElementException ex) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.accumulo.core.client.TestThrift1474 </h4><pre class="type-8 type-5 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void test() throws IOException, TException, InterruptedException {
  TServerSocket serverTransport=new TServerSocket(0);
  serverTransport.listen();
  int port=serverTransport.getServerSocket().getLocalPort();
  TestServer handler=new TestServer();
  ThriftTest.Processor<ThriftTest.Iface> processor=new ThriftTest.Processor<ThriftTest.Iface>(handler);
  TThreadPoolServer.Args args=new TThreadPoolServer.Args(serverTransport);
  args.stopTimeoutVal=10;
  args.stopTimeoutUnit=TimeUnit.MILLISECONDS;
  final TServer server=new TThreadPoolServer(args.processor(processor));
  Thread thread=new Thread(){
    @Override public void run(){
      server.serve();
    }
  }
;
  thread.start();
  while (!server.isServing()) {
    sleepUninterruptibly(10,TimeUnit.MILLISECONDS);
  }
  TTransport transport=new TSocket("localhost",port);
  transport.open();
  TProtocol protocol=new TBinaryProtocol(transport);
  ThriftTest.Client client=new ThriftTest.Client(protocol);
  assertTrue(client.success());
  assertFalse(client.fails());
  try {
    client.throwsError();
    fail("no exception thrown");
  }
 catch (  ThriftSecurityException ex) {
  }
  server.stop();
  thread.join();
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.accumulo.core.client.impl.ScannerOptionsTest </h4><pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testIteratorConflict(){
  ScannerOptions options=new ScannerOptions();
  options.addScanIterator(new IteratorSetting(1,"NAME",DebugIterator.class));
  try {
    options.addScanIterator(new IteratorSetting(2,"NAME",DebugIterator.class));
    fail();
  }
 catch (  IllegalArgumentException e) {
  }
  try {
    options.addScanIterator(new IteratorSetting(1,"NAME2",DebugIterator.class));
    fail();
  }
 catch (  IllegalArgumentException e) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.accumulo.core.client.impl.TableOperationsHelperTest </h4><pre class="type-8 type-5 type-3 type-2 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testAttachIterator() throws Exception {
  TableOperationsHelper t=getHelper();
  Map<String,String> empty=Collections.emptyMap();
  t.attachIterator("table",new IteratorSetting(10,"someName","foo.bar",empty),EnumSet.of(IteratorScope.scan));
  check(t,"table",new String[]{"table.iterator.scan.someName=10,foo.bar"});
  t.removeIterator("table","someName",EnumSet.of(IteratorScope.scan));
  check(t,"table",new String[]{});
  IteratorSetting setting=new IteratorSetting(10,"someName","foo.bar");
  setting.addOptions(Collections.singletonMap("key","value"));
  t.attachIterator("table",setting,EnumSet.of(IteratorScope.majc));
  setting=new IteratorSetting(10,"someName","foo.bar");
  t.attachIterator("table",setting,EnumSet.of(IteratorScope.scan));
  check(t,"table",new String[]{"table.iterator.majc.someName=10,foo.bar","table.iterator.majc.someName.opt.key=value","table.iterator.scan.someName=10,foo.bar"});
  t.removeIterator("table","someName",EnumSet.of(IteratorScope.scan));
  setting=new IteratorSetting(20,"otherName","some.classname");
  setting.addOptions(Collections.singletonMap("key","value"));
  t.attachIterator("table",setting,EnumSet.of(IteratorScope.majc));
  setting=new IteratorSetting(20,"otherName","some.classname");
  t.attachIterator("table",setting,EnumSet.of(IteratorScope.scan));
  Map<String,EnumSet<IteratorScope>> two=t.listIterators("table");
  Assert.assertEquals(2,two.size());
  Assert.assertTrue(two.containsKey("otherName"));
  Assert.assertTrue(two.get("otherName").size() == 2);
  Assert.assertTrue(two.get("otherName").contains(IteratorScope.majc));
  Assert.assertTrue(two.get("otherName").contains(IteratorScope.scan));
  Assert.assertTrue(two.containsKey("someName"));
  Assert.assertTrue(two.get("someName").size() == 1);
  Assert.assertTrue(two.get("someName").contains(IteratorScope.majc));
  t.removeIterator("table","someName",EnumSet.allOf(IteratorScope.class));
  check(t,"table",new String[]{"table.iterator.majc.otherName=20,some.classname","table.iterator.majc.otherName.opt.key=value","table.iterator.scan.otherName=20,some.classname"});
  setting=t.getIteratorSetting("table","otherName",IteratorScope.scan);
  Assert.assertEquals(20,setting.getPriority());
  Assert.assertEquals("some.classname",setting.getIteratorClass());
  Assert.assertTrue(setting.getOptions().isEmpty());
  setting=t.getIteratorSetting("table","otherName",IteratorScope.majc);
  Assert.assertEquals(20,setting.getPriority());
  Assert.assertEquals("some.classname",setting.getIteratorClass());
  Assert.assertFalse(setting.getOptions().isEmpty());
  Assert.assertEquals(Collections.singletonMap("key","value"),setting.getOptions());
  t.attachIterator("table",setting,EnumSet.of(IteratorScope.minc));
  check(t,"table",new String[]{"table.iterator.majc.otherName=20,some.classname","table.iterator.majc.otherName.opt.key=value","table.iterator.minc.otherName=20,some.classname","table.iterator.minc.otherName.opt.key=value","table.iterator.scan.otherName=20,some.classname"});
  try {
    t.attachIterator("table",setting);
    Assert.fail();
  }
 catch (  AccumuloException e) {
  }
  setting.setName("thirdName");
  try {
    t.attachIterator("table",setting);
    Assert.fail();
  }
 catch (  AccumuloException e) {
  }
  setting.setPriority(10);
  t.setProperty("table","table.iterator.minc.thirdName.opt.key","value");
  try {
    t.attachIterator("table",setting);
    Assert.fail();
  }
 catch (  AccumuloException e) {
  }
  t.removeProperty("table","table.iterator.minc.thirdName.opt.key");
  t.attachIterator("table",setting);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.accumulo.core.client.mock.MockConnectorTest </h4><pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testBadMutations() throws Exception {
  Connector c=new MockConnector("root",new MockInstance());
  c.tableOperations().create("test");
  BatchWriter bw=c.createBatchWriter("test",new BatchWriterConfig().setMaxMemory(10000L).setMaxLatency(1000L,TimeUnit.MILLISECONDS).setMaxWriteThreads(4));
  try {
    bw.addMutation(null);
    Assert.fail("addMutation should throw IAE for null mutation");
  }
 catch (  IllegalArgumentException iae) {
  }
  try {
    bw.addMutations(null);
    Assert.fail("addMutations should throw IAE for null iterable");
  }
 catch (  IllegalArgumentException iae) {
  }
  bw.addMutations(Collections.<Mutation>emptyList());
  Mutation bad=new Mutation("bad");
  try {
    bw.addMutation(bad);
    Assert.fail("addMutation should throw IAE for empty mutation");
  }
 catch (  IllegalArgumentException iae) {
  }
  Mutation good=new Mutation("good");
  good.put(asText(random.nextInt()),asText(random.nextInt()),new Value("good".getBytes()));
  List<Mutation> mutations=new ArrayList<Mutation>();
  mutations.add(good);
  mutations.add(bad);
  try {
    bw.addMutations(mutations);
    Assert.fail("addMutations should throw IAE if it contains empty mutation");
  }
 catch (  IllegalArgumentException iae) {
  }
  bw.close();
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.accumulo.core.client.mock.MockNamespacesTest </h4><pre class="type-8 type-5 type-3 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * This test creates a new namespace "testing" and a table "testing.table1" which puts "table1" into the "testing" namespace. Then we create "testing.table2"
 * which creates "table2" and puts it into "testing" as well. Then we make sure that you can't delete a namespace with tables in it, and then we delete the
 * tables and delete the namespace.
 */
@Test public void testCreateAndDeleteNamespace() throws Exception {
  String namespace="testing";
  String tableName1=namespace + ".table1";
  String tableName2=namespace + ".table2";
  conn.namespaceOperations().create(namespace);
  assertTrue(conn.namespaceOperations().exists(namespace));
  conn.tableOperations().create(tableName1);
  assertTrue(conn.tableOperations().exists(tableName1));
  conn.tableOperations().create(tableName2);
  assertTrue(conn.tableOperations().exists(tableName2));
  try {
    conn.namespaceOperations().delete(namespace);
    fail();
  }
 catch (  NamespaceNotEmptyException e) {
  }
  assertTrue(conn.namespaceOperations().exists(namespace));
  assertTrue(conn.tableOperations().exists(tableName1));
  assertTrue(conn.tableOperations().exists(tableName2));
  conn.tableOperations().delete(tableName2);
  assertTrue(!conn.tableOperations().exists(tableName2));
  assertTrue(conn.namespaceOperations().exists(namespace));
  conn.tableOperations().delete(tableName1);
  assertTrue(!conn.tableOperations().exists(tableName1));
  conn.namespaceOperations().delete(namespace);
  assertTrue(!conn.namespaceOperations().exists(namespace));
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.accumulo.core.client.mock.MockTableOperationsTest </h4><pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testTableNotFound() throws AccumuloException, AccumuloSecurityException, TableExistsException, TableNotFoundException {
  IteratorSetting setting=new IteratorSetting(100,"myvers",VersioningIterator.class);
  String t="tableName";
  try {
    conn.tableOperations().attachIterator(t,setting);
    Assert.fail();
  }
 catch (  TableNotFoundException e) {
  }
  try {
    conn.tableOperations().checkIteratorConflicts(t,setting,EnumSet.allOf(IteratorScope.class));
    Assert.fail();
  }
 catch (  TableNotFoundException e) {
  }
  try {
    conn.tableOperations().delete(t);
    Assert.fail();
  }
 catch (  TableNotFoundException e) {
  }
  try {
    conn.tableOperations().getIteratorSetting(t,"myvers",IteratorScope.scan);
    Assert.fail();
  }
 catch (  TableNotFoundException e) {
  }
  try {
    conn.tableOperations().getProperties(t);
    Assert.fail();
  }
 catch (  TableNotFoundException e) {
  }
  try {
    conn.tableOperations().listSplits(t);
    Assert.fail();
  }
 catch (  TableNotFoundException e) {
  }
  try {
    conn.tableOperations().listIterators(t);
    Assert.fail();
  }
 catch (  TableNotFoundException e) {
  }
  try {
    conn.tableOperations().removeIterator(t,null,EnumSet.noneOf(IteratorScope.class));
    Assert.fail();
  }
 catch (  TableNotFoundException e) {
  }
  try {
    conn.tableOperations().rename(t,t);
    Assert.fail();
  }
 catch (  TableNotFoundException e) {
  }
  conn.tableOperations().create(t);
  try {
    conn.tableOperations().create(t);
    Assert.fail();
  }
 catch (  TableExistsException e) {
  }
  try {
    conn.tableOperations().rename(t,t);
    Assert.fail();
  }
 catch (  TableExistsException e) {
  }
}

</code></pre>

<br>
<pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testCreateUseVersions() throws AccumuloException, AccumuloSecurityException, TableExistsException, TableNotFoundException {
  String t="tableName1";
{
    conn.tableOperations().create(t,new NewTableConfiguration().withoutDefaultIterators().setTimeType(TimeType.LOGICAL));
    writeVersionable(conn,t,3);
    assertVersionable(conn,t,3);
    IteratorSetting settings=new IteratorSetting(20,VersioningIterator.class);
    conn.tableOperations().attachIterator(t,settings);
    assertVersionable(conn,t,1);
    conn.tableOperations().delete(t);
  }
{
    conn.tableOperations().create(t,new NewTableConfiguration().setTimeType(TimeType.MILLIS));
    try {
      IteratorSetting settings=new IteratorSetting(20,VersioningIterator.class);
      conn.tableOperations().attachIterator(t,settings);
      Assert.fail();
    }
 catch (    AccumuloException ex) {
    }
    writeVersionable(conn,t,3);
    assertVersionable(conn,t,1);
    conn.tableOperations().delete(t);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.accumulo.core.client.security.tokens.CredentialProviderTokenTest </h4><pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testMissingClassesThrowsException() throws Exception {
  if (isCredentialProviderAvailable) {
    return;
  }
  try {
    new CredentialProviderToken("root.password",keystorePath);
    Assert.fail("Should fail to create CredentialProviderToken when classes are not available");
  }
 catch (  IOException e) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.accumulo.core.data.MutationTest </h4><pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testPutAfterEquals(){
  Mutation m=new Mutation("r");
  Mutation m2=new Mutation("r2");
  m.equals(m2);
  try {
    m.put("cf","cq","v");
    m2.put("cf","cq","v");
  }
 catch (  IllegalStateException e) {
    fail("Calling Mutation#equals then Mutation#put should not result in an IllegalStateException.");
  }
}

</code></pre>

<br>
<pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testPutAfterHashCode(){
  Mutation m=new Mutation("r");
  m.hashCode();
  try {
    m.put("cf","cq","v");
  }
 catch (  IllegalStateException e) {
    fail("Calling Mutation#hashCode then Mutation#put should not result in an IllegalStateException.");
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.accumulo.core.iterators.aggregation.NumSummationTest </h4><pre class="type-8 type-5 type-3 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void test5(){
  try {
    NumSummation ns=new NumSummation();
    for (long l=-5l; l < 8l; l++) {
      ns.collect(new Value(NumSummation.longToBytes(l)));
    }
    long l=NumSummation.bytesToLong(ns.aggregate().get());
    assertTrue("l was " + l,l == 13);
    ns.collect(new Value(NumSummation.longToBytes(Long.MAX_VALUE)));
    l=NumSummation.bytesToLong(ns.aggregate().get());
    assertTrue("l was " + l,l == Long.MAX_VALUE);
    ns.collect(new Value(NumSummation.longToBytes(Long.MIN_VALUE)));
    l=NumSummation.bytesToLong(ns.aggregate().get());
    assertTrue("l was " + l,l == -1);
    ns.collect(new Value(NumSummation.longToBytes(Long.MIN_VALUE)));
    l=NumSummation.bytesToLong(ns.aggregate().get());
    assertTrue("l was " + l,l == Long.MIN_VALUE);
    ns.collect(new Value(NumSummation.longToBytes(Long.MIN_VALUE)));
    l=NumSummation.bytesToLong(ns.aggregate().get());
    assertTrue("l was " + l,l == Long.MIN_VALUE);
    ns.reset();
    l=NumSummation.bytesToLong(ns.aggregate().get());
    assertTrue("l was " + l,l == 0);
  }
 catch (  IOException|RuntimeException e) {
    fail();
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.accumulo.core.iterators.user.ColumnSliceFilterTest </h4><pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testStartEqualToEndStartExclusiveEndInclusive() throws IOException {
  try {
    ColumnSliceFilter.setSlice(is,"20080202",false,"20080202",true);
    fail("IllegalArgumentException expected but not thrown");
  }
 catch (  IllegalArgumentException expectedException) {
  }
}

</code></pre>

<br>
<pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testStartEqualToEndStartInclusiveEndExclusive() throws IOException {
  try {
    ColumnSliceFilter.setSlice(is,"20080202","20080202");
    fail("IllegalArgumentException expected but not thrown");
  }
 catch (  IllegalArgumentException expectedException) {
  }
}

</code></pre>

<br>
<pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testStartAfterEnd() throws IOException {
  try {
    ColumnSliceFilter.setSlice(is,"20080204","20080202");
    fail("IllegalArgumentException expected but not thrown");
  }
 catch (  IllegalArgumentException expectedException) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.accumulo.core.security.CredentialsTest </h4><pre class="type-8 type-5 type-3 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testMockConnector() throws AccumuloException, DestroyFailedException, AccumuloSecurityException {
  Instance inst=DeprecationUtil.makeMockInstance(test.getMethodName());
  Connector rootConnector=inst.getConnector("root",new PasswordToken());
  PasswordToken testToken=new PasswordToken("testPass");
  rootConnector.securityOperations().createLocalUser("testUser",testToken);
  assertFalse(testToken.isDestroyed());
  testToken.destroy();
  assertTrue(testToken.isDestroyed());
  try {
    inst.getConnector("testUser",testToken);
    fail();
  }
 catch (  AccumuloSecurityException e) {
    assertTrue(e.getSecurityErrorCode().equals(SecurityErrorCode.TOKEN_EXPIRED));
  }
}

</code></pre>

<br>
<pre class="type-8 type-5 type-3 type-2 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testToThrift() throws DestroyFailedException {
  Credentials creds=new Credentials("test",new PasswordToken("testing"));
  TCredentials tCreds=creds.toThrift(inst);
  assertEquals("test",tCreds.getPrincipal());
  assertEquals(PasswordToken.class.getName(),tCreds.getTokenClassName());
  assertArrayEquals(AuthenticationTokenSerializer.serialize(new PasswordToken("testing")),tCreds.getToken());
  creds.getToken().destroy();
  try {
    creds.toThrift(inst);
    fail();
  }
 catch (  Exception e) {
    assertTrue(e instanceof RuntimeException);
    assertTrue(e.getCause() instanceof AccumuloSecurityException);
    assertTrue(AccumuloSecurityException.class.cast(e.getCause()).getSecurityErrorCode().equals(SecurityErrorCode.TOKEN_EXPIRED));
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.accumulo.core.security.VisibilityEvaluatorTest </h4><pre class="type-8 type-5 type-3 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testVisibilityEvaluator() throws VisibilityParseException {
  VisibilityEvaluator ct=new VisibilityEvaluator(new Authorizations(ByteArraySet.fromStrings("one","two","three","four")));
  assertTrue(ct.evaluate(new ColumnVisibility(new byte[0])));
  assertTrue("'and' test",ct.evaluate(new ColumnVisibility("one&two")));
  assertTrue("'or' test",ct.evaluate(new ColumnVisibility("foor|four")));
  assertTrue("'and' and 'or' test",ct.evaluate(new ColumnVisibility("(one&two)|(foo&bar)")));
  for (  String marking : new String[]{"one","one|five","five|one","(one)","(one&two)|(foo&bar)","(one|foo)&three","one|foo|bar","(one|foo)|bar","((one|foo)|bar)&two"}) {
    assertTrue(marking,ct.evaluate(new ColumnVisibility(marking)));
  }
  for (  String marking : new String[]{"five","one&five","five&one","((one|foo)|bar)&goober"}) {
    assertFalse(marking,ct.evaluate(new ColumnVisibility(marking)));
  }
  for (  String marking : new String[]{"one(five)","(five)one","(one)(two)","a|(b(c))"}) {
    try {
      ct.evaluate(new ColumnVisibility(marking));
      fail(marking + " failed to throw");
    }
 catch (    BadArgumentException e) {
    }
  }
  for (  String marking : new String[]{"&(five)","|(five)","(five)&","five|","a|(b)&","(&five)","(five|)"}) {
    try {
      ct.evaluate(new ColumnVisibility(marking));
      fail(marking + " failed to throw");
    }
 catch (    BadArgumentException e) {
    }
  }
  for (  String marking : new String[]{"(",")","(a&b","b|a)"}) {
    try {
      ct.evaluate(new ColumnVisibility(marking));
      fail(marking + " failed to throw");
    }
 catch (    BadArgumentException e) {
    }
  }
}

</code></pre>

<br>
<pre class="type-8 type-2 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testUnescape(){
  assertEquals("a\"b",VisibilityEvaluator.unescape(new ArrayByteSequence("a\\\"b")).toString());
  assertEquals("a\\b",VisibilityEvaluator.unescape(new ArrayByteSequence("a\\\\b")).toString());
  assertEquals("a\\\"b",VisibilityEvaluator.unescape(new ArrayByteSequence("a\\\\\\\"b")).toString());
  assertEquals("\\\"",VisibilityEvaluator.unescape(new ArrayByteSequence("\\\\\\\"")).toString());
  assertEquals("a\\b\\c\\d",VisibilityEvaluator.unescape(new ArrayByteSequence("a\\\\b\\\\c\\\\d")).toString());
  try {
    VisibilityEvaluator.unescape(new ArrayByteSequence("a\\b"));
    fail("Expected failure to unescape invalid escape sequence");
  }
 catch (  IllegalArgumentException e) {
  }
  try {
    VisibilityEvaluator.unescape(new ArrayByteSequence("a\\b\\c"));
    fail("Expected failure to unescape invalid escape sequence");
  }
 catch (  IllegalArgumentException e) {
  }
  try {
    VisibilityEvaluator.unescape(new ArrayByteSequence("a\"b\\"));
    fail("Expected failure to unescape invalid escape sequence");
  }
 catch (  IllegalArgumentException e) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.accumulo.core.util.LocalityGroupUtilTest </h4><pre class="type-9 type-8 type-5 type-3 type-7 type-2 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testColumnFamilySet(){
  ConfigurationCopy conf=new ConfigurationCopy();
  conf.set("table.group.lg1","cf1,cf2");
  conf.set("table.groups.enabled","lg1");
  try {
    Map<String,Set<ByteSequence>> groups=LocalityGroupUtil.getLocalityGroups(conf);
    assertEquals(1,groups.size());
    assertNotNull(groups.get("lg1"));
    assertEquals(2,groups.get("lg1").size());
    assertTrue(groups.get("lg1").contains(new ArrayByteSequence("cf1")));
  }
 catch (  LocalityGroupConfigurationError err) {
    fail();
  }
  try {
    conf.set("table.group.lg2","cf1");
    conf.set("table.groups.enabled","lg1,lg2");
    LocalityGroupUtil.getLocalityGroups(conf);
    fail();
  }
 catch (  LocalityGroupConfigurationError err) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.accumulo.core.util.format.FormatterConfigTest </h4><pre class="type-8 type-3 type-2 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testSetShownLength() throws Exception {
  FormatterConfig config=new FormatterConfig();
  try {
    config.setShownLength(-1);
    fail("Should throw on negative length.");
  }
 catch (  IllegalArgumentException e) {
  }
  config.setShownLength(0);
  assertEquals(0,config.getShownLength());
  assertEquals(true,config.willLimitShowLength());
  config.setShownLength(1);
  assertEquals(1,config.getShownLength());
  assertEquals(true,config.willLimitShowLength());
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.accumulo.examples.simple.filedata.ChunkInputStreamTest </h4><pre class="type-9 type-8 type-5 type-3 type-2 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testBadData() throws IOException {
  ChunkInputStream cis=new ChunkInputStream();
  byte[] b=new byte[20];
  int read;
  PeekingIterator<Entry<Key,Value>> pi=new PeekingIterator<Entry<Key,Value>>(baddata.iterator());
  cis.setSource(pi);
  assumeExceptionOnRead(cis,b);
  assumeExceptionOnClose(cis);
  assertEquals(cis.getVisibilities().toString(),"[A]");
  cis.setSource(pi);
  assumeExceptionOnRead(cis,b);
  assumeExceptionOnClose(cis);
  assertEquals(cis.getVisibilities().toString(),"[B, C]");
  cis.setSource(pi);
  assumeExceptionOnRead(cis,b);
  assumeExceptionOnClose(cis);
  assertEquals(cis.getVisibilities().toString(),"[D, E]");
  cis.setSource(pi);
  assertEquals(read=cis.read(b),8);
  assertEquals(new String(b,0,read),"asdfjkl;");
  assertEquals(read=cis.read(b),-1);
  assertEquals(cis.getVisibilities().toString(),"[F, G]");
  cis.close();
  cis.setSource(pi);
  assumeExceptionOnRead(cis,b);
  cis.close();
  assertEquals(cis.getVisibilities().toString(),"[I, J]");
  try {
    cis.setSource(pi);
    fail();
  }
 catch (  IOException e) {
  }
  assumeExceptionOnClose(cis);
  assertEquals(cis.getVisibilities().toString(),"[K]");
  cis.setSource(pi);
  assertEquals(read=cis.read(b),-1);
  assertEquals(cis.getVisibilities().toString(),"[L]");
  cis.close();
  assertFalse(pi.hasNext());
  pi=new PeekingIterator<Entry<Key,Value>>(baddata.iterator());
  cis.setSource(pi);
  assumeExceptionOnClose(cis);
}

</code></pre>

<br>
<pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testExceptionOnGetVisBeforeClose() throws IOException {
  ChunkInputStream cis=new ChunkInputStream();
  PeekingIterator<Entry<Key,Value>> pi=new PeekingIterator<Entry<Key,Value>>(data.iterator());
  cis.setSource(pi);
  try {
    cis.getVisibilities();
    fail();
  }
 catch (  RuntimeException e) {
  }
  cis.close();
  cis.getVisibilities();
}

</code></pre>

<br>
<pre class="type-9 type-8 type-5 type-3 type-2 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testBadDataWithoutClosing() throws IOException {
  ChunkInputStream cis=new ChunkInputStream();
  byte[] b=new byte[20];
  int read;
  PeekingIterator<Entry<Key,Value>> pi=new PeekingIterator<Entry<Key,Value>>(baddata.iterator());
  cis.setSource(pi);
  assumeExceptionOnRead(cis,b);
  assertEquals(cis.getVisibilities().toString(),"[A]");
  cis.setSource(pi);
  assumeExceptionOnRead(cis,b);
  assertEquals(cis.getVisibilities().toString(),"[B, C]");
  cis.setSource(pi);
  assumeExceptionOnRead(cis,b);
  assertEquals(cis.getVisibilities().toString(),"[D, E]");
  cis.setSource(pi);
  assertEquals(read=cis.read(b),8);
  assertEquals(new String(b,0,read),"asdfjkl;");
  assertEquals(read=cis.read(b),-1);
  assertEquals(cis.getVisibilities().toString(),"[F, G]");
  cis.close();
  cis.setSource(pi);
  assumeExceptionOnRead(cis,b);
  assertEquals(cis.getVisibilities().toString(),"[I, J]");
  try {
    cis.setSource(pi);
    fail();
  }
 catch (  IOException e) {
  }
  assertEquals(cis.getVisibilities().toString(),"[K]");
  cis.setSource(pi);
  assertEquals(read=cis.read(b),-1);
  assertEquals(cis.getVisibilities().toString(),"[L]");
  cis.close();
  assertFalse(pi.hasNext());
  pi=new PeekingIterator<Entry<Key,Value>>(baddata.iterator());
  cis.setSource(pi);
  assumeExceptionOnClose(cis);
}

</code></pre>

<br>
<pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testExceptionOnMultipleSetSourceWithoutClose() throws IOException {
  ChunkInputStream cis=new ChunkInputStream();
  PeekingIterator<Entry<Key,Value>> pi=new PeekingIterator<Entry<Key,Value>>(data.iterator());
  pi=new PeekingIterator<Entry<Key,Value>>(data.iterator());
  cis.setSource(pi);
  try {
    cis.setSource(pi);
    fail();
  }
 catch (  IOException e) {
  }
  cis.close();
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.accumulo.fate.zookeeper.TransactionWatcherTest </h4><pre class="type-8 type-5 type-3 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testTransactionWatcher() throws Exception {
  final String txType="someName";
  final long txid=7;
  final SimpleArbitrator sa=new SimpleArbitrator();
  final TransactionWatcher txw=new TransactionWatcher(sa);
  sa.start(txType,txid);
  try {
    sa.start(txType,txid);
    Assert.fail("simple arbitrator did not throw an exception");
  }
 catch (  Exception ex) {
  }
  txw.isActive(txid);
  Assert.assertFalse(txw.isActive(txid));
  txw.run(txType,txid,new Callable(){
    @Override public Object call() throws Exception {
      Assert.assertTrue(txw.isActive(txid));
      return null;
    }
  }
);
  Assert.assertFalse(txw.isActive(txid));
  Assert.assertFalse(sa.transactionComplete(txType,txid));
  sa.stop(txType,txid);
  Assert.assertFalse(sa.transactionAlive(txType,txid));
  Assert.assertFalse(sa.transactionComplete(txType,txid));
  sa.cleanup(txType,txid);
  Assert.assertTrue(sa.transactionComplete(txType,txid));
  try {
    txw.run(txType,txid,new Callable(){
      @Override public Object call() throws Exception {
        Assert.fail("Should not be able to start a new work on a discontinued transaction");
        return null;
      }
    }
);
    Assert.fail("work against stopped transaction should fail");
  }
 catch (  Exception ex) {
    ;
  }
  final long txid2=9;
  sa.start(txType,txid2);
  txw.run(txType,txid2,new Callable(){
    @Override public Object call() throws Exception {
      Assert.assertTrue(txw.isActive(txid2));
      sa.stop(txType,txid2);
      try {
        txw.run(txType,txid2,new Callable(){
          @Override public Object call() throws Exception {
            Assert.fail("Should not be able to start a new work on a discontinued transaction");
            return null;
          }
        }
);
        Assert.fail("work against a stopped transaction should fail");
      }
 catch (      Exception ex) {
      }
      Assert.assertTrue(txw.isActive(txid2));
      return null;
    }
  }
);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.accumulo.master.state.RootTabletStateStoreTest </h4><pre class="type-8 type-7 type-2 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects are null
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testRootTabletStateStore() throws DistributedStoreException {
  ZooTabletStateStore tstore=new ZooTabletStateStore(new FakeZooStore());
  KeyExtent root=RootTable.EXTENT;
  String sessionId="this is my unique session data";
  TServerInstance server=new TServerInstance(HostAndPort.fromParts("127.0.0.1",10000),sessionId);
  List<Assignment> assignments=Collections.singletonList(new Assignment(root,server));
  tstore.setFutureLocations(assignments);
  int count=0;
  for (  TabletLocationState location : tstore) {
    assertEquals(location.extent,root);
    assertEquals(location.future,server);
    assertNull(location.current);
    count++;
  }
  assertEquals(count,1);
  tstore.setLocations(assignments);
  count=0;
  for (  TabletLocationState location : tstore) {
    assertEquals(location.extent,root);
    assertNull(location.future);
    assertEquals(location.current,server);
    count++;
  }
  assertEquals(count,1);
  TabletLocationState assigned=null;
  try {
    assigned=new TabletLocationState(root,server,null,null,null,false);
  }
 catch (  BadLocationStateException e) {
    fail("Unexpected error " + e);
  }
  tstore.unassign(Collections.singletonList(assigned),null);
  count=0;
  for (  TabletLocationState location : tstore) {
    assertEquals(location.extent,root);
    assertNull(location.future);
    assertNull(location.current);
    count++;
  }
  assertEquals(count,1);
  KeyExtent notRoot=new KeyExtent(new Text("0"),null,null);
  try {
    tstore.setLocations(Collections.singletonList(new Assignment(notRoot,server)));
    Assert.fail("should not get here");
  }
 catch (  IllegalArgumentException ex) {
  }
  try {
    tstore.setFutureLocations(Collections.singletonList(new Assignment(notRoot,server)));
    Assert.fail("should not get here");
  }
 catch (  IllegalArgumentException ex) {
  }
  TabletLocationState broken=null;
  try {
    broken=new TabletLocationState(notRoot,server,null,null,null,false);
  }
 catch (  BadLocationStateException e) {
    fail("Unexpected error " + e);
  }
  try {
    tstore.unassign(Collections.singletonList(broken),null);
    Assert.fail("should not get here");
  }
 catch (  IllegalArgumentException ex) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.accumulo.proxy.ProxyServerTest </h4><pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void updateAndFlushClosesWriterOnExceptionFromFlush() throws Exception {
  ProxyServer server=EasyMock.createMockBuilder(ProxyServer.class).addMockedMethod("getWriter",ByteBuffer.class,String.class,WriterOptions.class).addMockedMethod("addCellsToWriter",Map.class,BatchWriterPlusProblem.class).createMock();
  BatchWriter writer=EasyMock.createMock(BatchWriter.class);
  BatchWriterPlusProblem bwpe=new BatchWriterPlusProblem();
  bwpe.writer=writer;
  MutationsRejectedException mre=EasyMock.createMock(MutationsRejectedException.class);
  final ByteBuffer login=ByteBuffer.wrap("my_login".getBytes(UTF_8));
  final String tableName="table1";
  final Map<ByteBuffer,List<ColumnUpdate>> cells=new HashMap<ByteBuffer,List<ColumnUpdate>>();
  EasyMock.expect(server.getWriter(login,tableName,null)).andReturn(bwpe);
  server.addCellsToWriter(cells,bwpe);
  EasyMock.expectLastCall();
  bwpe.exception=null;
  writer.flush();
  EasyMock.expectLastCall().andThrow(mre);
  writer.close();
  EasyMock.expectLastCall();
  EasyMock.replay(server,writer,mre);
  try {
    server.updateAndFlush(login,tableName,cells);
    Assert.fail("Expected updateAndFlush to throw an exception");
  }
 catch (  org.apache.accumulo.proxy.thrift.MutationsRejectedException e) {
  }
  EasyMock.verify(server,writer,mre);
}

</code></pre>

<br>
<pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void updateAndFlushClosesWriterOnExceptionFromAddCells() throws Exception {
  ProxyServer server=EasyMock.createMockBuilder(ProxyServer.class).addMockedMethod("getWriter",ByteBuffer.class,String.class,WriterOptions.class).addMockedMethod("addCellsToWriter",Map.class,BatchWriterPlusProblem.class).createMock();
  BatchWriter writer=EasyMock.createMock(BatchWriter.class);
  BatchWriterPlusProblem bwpe=new BatchWriterPlusProblem();
  bwpe.writer=writer;
  MutationsRejectedException mre=EasyMock.createMock(MutationsRejectedException.class);
  final ByteBuffer login=ByteBuffer.wrap("my_login".getBytes(UTF_8));
  final String tableName="table1";
  final Map<ByteBuffer,List<ColumnUpdate>> cells=new HashMap<ByteBuffer,List<ColumnUpdate>>();
  EasyMock.expect(server.getWriter(login,tableName,null)).andReturn(bwpe);
  server.addCellsToWriter(cells,bwpe);
  EasyMock.expectLastCall();
  bwpe.exception=mre;
  writer.close();
  EasyMock.expectLastCall();
  EasyMock.replay(server,writer,mre);
  try {
    server.updateAndFlush(login,tableName,cells);
    Assert.fail("Expected updateAndFlush to throw an exception");
  }
 catch (  org.apache.accumulo.proxy.thrift.MutationsRejectedException e) {
  }
  EasyMock.verify(server,writer,mre);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.accumulo.server.fs.VolumeUtilTest </h4><pre class="type-8 type-5 type-3 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testSame() throws Exception {
  FileSystem fs=FileSystem.getLocal(new Configuration());
  Path subdir1=new Path(tempFolder.newFolder().toURI());
  Path subdir2=new Path(tempFolder.newFolder().toURI());
  Path subdir3=new Path(tempFolder.newFolder().toURI());
  Assert.assertFalse(VolumeUtil.same(fs,subdir1,fs,new Path(tempFolder.getRoot().toURI().toString(),"8854339269459287524098238497")));
  Assert.assertFalse(VolumeUtil.same(fs,new Path(tempFolder.getRoot().toURI().toString(),"8854339269459287524098238497"),fs,subdir1));
  Assert.assertTrue(VolumeUtil.same(fs,subdir1,fs,subdir1));
  writeFile(fs,subdir1,"abc","foo");
  writeFile(fs,subdir2,"abc","bar");
  writeFile(fs,subdir3,"abc","foo");
  Assert.assertTrue(VolumeUtil.same(fs,subdir1,fs,subdir1));
  Assert.assertFalse(VolumeUtil.same(fs,subdir1,fs,subdir2));
  Assert.assertFalse(VolumeUtil.same(fs,subdir2,fs,subdir1));
  Assert.assertTrue(VolumeUtil.same(fs,subdir1,fs,subdir3));
  Assert.assertTrue(VolumeUtil.same(fs,subdir3,fs,subdir1));
  writeFile(fs,subdir1,"def","123456");
  writeFile(fs,subdir2,"def","123456");
  writeFile(fs,subdir3,"def","123456");
  Assert.assertTrue(VolumeUtil.same(fs,subdir1,fs,subdir1));
  Assert.assertFalse(VolumeUtil.same(fs,subdir1,fs,subdir2));
  Assert.assertFalse(VolumeUtil.same(fs,subdir2,fs,subdir1));
  Assert.assertTrue(VolumeUtil.same(fs,subdir1,fs,subdir3));
  Assert.assertTrue(VolumeUtil.same(fs,subdir3,fs,subdir1));
  writeFile(fs,subdir3,"ghi","09876");
  Assert.assertFalse(VolumeUtil.same(fs,subdir1,fs,subdir3));
  Assert.assertFalse(VolumeUtil.same(fs,subdir3,fs,subdir1));
  fs.mkdirs(new Path(subdir2,"dir1"));
  try {
    VolumeUtil.same(fs,subdir1,fs,subdir2);
    Assert.fail();
  }
 catch (  IllegalArgumentException e) {
  }
  try {
    VolumeUtil.same(fs,subdir2,fs,subdir1);
    Assert.fail();
  }
 catch (  IllegalArgumentException e) {
  }
  try {
    VolumeUtil.same(fs,subdir1,fs,new Path(subdir2,"def"));
    Assert.fail();
  }
 catch (  IllegalArgumentException e) {
  }
  try {
    VolumeUtil.same(fs,new Path(subdir2,"def"),fs,subdir3);
    Assert.fail();
  }
 catch (  IllegalArgumentException e) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.accumulo.server.rpc.RpcWrapperTest </h4><pre class="type-8 type-2 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testExceptionWrappingForNonOneway() throws Throwable {
  final Object[] args=new Object[0];
  final FakeService impl=new FakeServiceImpl();
  RpcServerInvocationHandler<FakeService> handler=RpcWrapper.getInvocationHandler(impl,Sets.newHashSet("foobar","barfoo"));
  try {
    handler.invoke(impl,FakeServiceImpl.class.getMethod("foo"),args);
    Assert.fail("Expected an exception");
  }
 catch (  TException e) {
    Assert.assertEquals(RTE_MESSAGE,e.getMessage());
  }
  handler.invoke(impl,FakeServiceImpl.class.getMethod("foobar"),args);
}

</code></pre>

<br>
<pre class="type-8 type-2 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testNoExceptionWrappingForOneway() throws Throwable {
  final Object[] args=new Object[0];
  final FakeService impl=new FakeServiceImpl();
  RpcServerInvocationHandler<FakeService> handler=RpcWrapper.getInvocationHandler(impl,Sets.newHashSet("foo","bar"));
  try {
    handler.invoke(impl,FakeServiceImpl.class.getMethod("foo"),args);
    Assert.fail("Expected an exception");
  }
 catch (  RuntimeException e) {
    Assert.assertEquals(RTE_MESSAGE,e.getMessage());
  }
  handler.invoke(impl,FakeServiceImpl.class.getMethod("foobar"),args);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.accumulo.test.ArbitraryTablePropertiesIT </h4><pre class="type-8 type-5 type-2 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void userSetGetTablePropertyWithoutPermission() throws Exception {
  log.debug("Starting userSetGetTablePropertyWithoutPermission test ------------------------");
  ClusterUser user=getUser(1);
  String testUser=user.getPrincipal();
  AuthenticationToken testToken=user.getToken();
  final String tableName=getUniqueNames(1)[0];
  final Connector c=getConnector();
  c.securityOperations().createLocalUser(testUser,(testToken instanceof PasswordToken ? (PasswordToken)testToken : null));
  c.tableOperations().create(tableName);
  String propertyName="table.custom.description";
  String description1="Description";
  Assert.assertTrue(Property.isValidPropertyKey(propertyName));
  Connector testConn=c.getInstance().getConnector(testUser,user.getToken());
  try {
    testConn.tableOperations().setProperty(tableName,propertyName,description1);
    Assert.fail("Was able to set property without permissions");
  }
 catch (  AccumuloSecurityException e) {
  }
  int count=0;
  for (  Entry<String,String> property : testConn.tableOperations().getProperties(tableName)) {
    if (property.getKey().equals(propertyName))     count++;
  }
  Assert.assertEquals(count,0);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.accumulo.test.BadDeleteMarkersCreatedIT </h4><pre class="type-9 type-8 type-3 type-7 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void test() throws Exception {
  String tableName=getUniqueNames(1)[0];
  Connector c=getConnector();
  log.info("Creating table to be deleted");
  c.tableOperations().create(tableName);
  final String tableId=c.tableOperations().tableIdMap().get(tableName);
  Assert.assertNotNull("Expected to find a tableId",tableId);
  SortedSet<Text> splits=new TreeSet<Text>();
  for (int i=0; i < 10; i++) {
    splits.add(new Text("" + i));
  }
  c.tableOperations().addSplits(tableName,splits);
  c.tableOperations().deleteRows(tableName,null,null);
  c.tableOperations().delete(tableName);
  log.info("Sleeping to let garbage collector run");
  sleepUninterruptibly(timeoutFactor * 15,TimeUnit.SECONDS);
  log.info("Verifying that delete markers were deleted");
  Scanner scanner=c.createScanner(MetadataTable.NAME,Authorizations.EMPTY);
  scanner.setRange(MetadataSchema.DeletesSection.getRange());
  for (  Entry<Key,Value> entry : scanner) {
    String row=entry.getKey().getRow().toString();
    if (!row.contains("/" + tableId + "/")) {
      log.info("Ignoring delete entry for a table other than the one we deleted");
      continue;
    }
    Assert.fail("Delete entry should have been deleted by the garbage collector: " + entry.getKey().getRow().toString());
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.accumulo.test.ConditionalWriterIT </h4><pre class="type-9 type-8 type-3 type-2 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testSecurity() throws Exception {
  Connector conn=getConnector();
  String user=null;
  ClientConfiguration clientConf=cluster.getClientConfig();
  final boolean saslEnabled=clientConf.getBoolean(ClientProperty.INSTANCE_RPC_SASL_ENABLED.getKey(),false);
  ClusterUser user1=getUser(0);
  user=user1.getPrincipal();
  if (saslEnabled) {
    conn.securityOperations().createLocalUser(user,null);
  }
 else {
    conn.securityOperations().createLocalUser(user,new PasswordToken(user1.getPassword()));
  }
  String[] tables=getUniqueNames(3);
  String table1=tables[0], table2=tables[1], table3=tables[2];
  conn.tableOperations().create(table1);
  conn.tableOperations().create(table2);
  conn.tableOperations().create(table3);
  conn.securityOperations().grantTablePermission(user,table1,TablePermission.READ);
  conn.securityOperations().grantTablePermission(user,table2,TablePermission.WRITE);
  conn.securityOperations().grantTablePermission(user,table3,TablePermission.READ);
  conn.securityOperations().grantTablePermission(user,table3,TablePermission.WRITE);
  Connector conn2=conn.getInstance().getConnector(user,user1.getToken());
  ConditionalMutation cm1=new ConditionalMutation("r1",new Condition("tx","seq"));
  cm1.put("tx","seq","1");
  cm1.put("data","x","a");
  ConditionalWriter cw1=conn2.createConditionalWriter(table1,new ConditionalWriterConfig());
  ConditionalWriter cw2=conn2.createConditionalWriter(table2,new ConditionalWriterConfig());
  ConditionalWriter cw3=conn2.createConditionalWriter(table3,new ConditionalWriterConfig());
  Assert.assertEquals(Status.ACCEPTED,cw3.write(cm1).getStatus());
  try {
    Status status=cw1.write(cm1).getStatus();
    Assert.fail("Expected exception writing conditional mutation to table the user doesn't have write access to, Got status: " + status);
  }
 catch (  AccumuloSecurityException ase) {
  }
  try {
    Status status=cw2.write(cm1).getStatus();
    Assert.fail("Expected exception writing conditional mutation to table the user doesn't have read access to. Got status: " + status);
  }
 catch (  AccumuloSecurityException ase) {
  }
}

</code></pre>

<br>
<pre class="type-8 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
"></span><br>
@Test public void testError() throws Exception {
  String table=getUniqueNames(1)[0];
  Connector conn=getConnector();
  conn.tableOperations().create(table);
  ConditionalWriter cw=conn.createConditionalWriter(table,new ConditionalWriterConfig());
  IteratorSetting iterSetting=new IteratorSetting(5,BadIterator.class);
  ConditionalMutation cm1=new ConditionalMutation("r1",new Condition("tx","seq").setIterators(iterSetting));
  cm1.put("tx","seq","1");
  cm1.put("data","x","a");
  Result result=cw.write(cm1);
  try {
    Status status=result.getStatus();
    Assert.fail("Expected exception using iterator which throws an error, Got status: " + status);
  }
 catch (  AccumuloException ae) {
  }
  cw.close();
}

</code></pre>

<br>
<pre class="type-8 type-3 type-2 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testBadColVis() throws Exception {
  Connector conn=getConnector();
  String tableName=getUniqueNames(1)[0];
  conn.tableOperations().create(tableName);
  Authorizations auths=new Authorizations("A","B");
  conn.securityOperations().changeUserAuthorizations(getAdminPrincipal(),auths);
  Authorizations filteredAuths=new Authorizations("A");
  ConditionalWriter cw=conn.createConditionalWriter(tableName,new ConditionalWriterConfig().setAuthorizations(filteredAuths));
  ColumnVisibility cva=new ColumnVisibility("A");
  ColumnVisibility cvb=new ColumnVisibility("B");
  ColumnVisibility cvc=new ColumnVisibility("C");
  ConditionalMutation cm0=new ConditionalMutation("99006",new Condition("tx","seq").setVisibility(cvb));
  cm0.put("name","last",cva,"doe");
  cm0.put("name","first",cva,"john");
  cm0.put("tx","seq",cva,"1");
  Assert.assertEquals(Status.INVISIBLE_VISIBILITY,cw.write(cm0).getStatus());
  ConditionalMutation cm1=new ConditionalMutation("99006",new Condition("tx","seq").setVisibility(cvb).setValue("1"));
  cm1.put("name","last",cva,"doe");
  cm1.put("name","first",cva,"john");
  cm1.put("tx","seq",cva,"1");
  Assert.assertEquals(Status.INVISIBLE_VISIBILITY,cw.write(cm1).getStatus());
  ConditionalMutation cm2=new ConditionalMutation("99006",new Condition("tx","seq").setVisibility(cvc));
  cm2.put("name","last",cva,"doe");
  cm2.put("name","first",cva,"john");
  cm2.put("tx","seq",cva,"1");
  Assert.assertEquals(Status.INVISIBLE_VISIBILITY,cw.write(cm2).getStatus());
  ConditionalMutation cm3=new ConditionalMutation("99006",new Condition("tx","seq").setVisibility(cvc).setValue("1"));
  cm3.put("name","last",cva,"doe");
  cm3.put("name","first",cva,"john");
  cm3.put("tx","seq",cva,"1");
  Assert.assertEquals(Status.INVISIBLE_VISIBILITY,cw.write(cm3).getStatus());
  ConditionalMutation cm4=new ConditionalMutation("99006",new Condition("tx","seq").setVisibility(cvb),new Condition("tx","seq").setVisibility(cva));
  cm4.put("name","last",cva,"doe");
  cm4.put("name","first",cva,"john");
  cm4.put("tx","seq",cva,"1");
  Assert.assertEquals(Status.INVISIBLE_VISIBILITY,cw.write(cm4).getStatus());
  ConditionalMutation cm5=new ConditionalMutation("99006",new Condition("tx","seq").setVisibility(cvb).setValue("1"),new Condition("tx","seq").setVisibility(cva).setValue("1"));
  cm5.put("name","last",cva,"doe");
  cm5.put("name","first",cva,"john");
  cm5.put("tx","seq",cva,"1");
  Assert.assertEquals(Status.INVISIBLE_VISIBILITY,cw.write(cm5).getStatus());
  ConditionalMutation cm6=new ConditionalMutation("99006",new Condition("tx","seq").setVisibility(cvb).setValue("1"),new Condition("tx","seq").setVisibility(cva));
  cm6.put("name","last",cva,"doe");
  cm6.put("name","first",cva,"john");
  cm6.put("tx","seq",cva,"1");
  Assert.assertEquals(Status.INVISIBLE_VISIBILITY,cw.write(cm6).getStatus());
  ConditionalMutation cm7=new ConditionalMutation("99006",new Condition("tx","seq").setVisibility(cvb),new Condition("tx","seq").setVisibility(cva).setValue("1"));
  cm7.put("name","last",cva,"doe");
  cm7.put("name","first",cva,"john");
  cm7.put("tx","seq",cva,"1");
  Assert.assertEquals(Status.INVISIBLE_VISIBILITY,cw.write(cm7).getStatus());
  cw.close();
  Authorizations exceedingAuths=new Authorizations("A","B","D");
  ConditionalWriter cw2=conn.createConditionalWriter(tableName,new ConditionalWriterConfig().setAuthorizations(exceedingAuths));
  ConditionalMutation cm8=new ConditionalMutation("99006",new Condition("tx","seq").setVisibility(cvb),new Condition("tx","seq").setVisibility(cva).setValue("1"));
  cm8.put("name","last",cva,"doe");
  cm8.put("name","first",cva,"john");
  cm8.put("tx","seq",cva,"1");
  try {
    Status status=cw2.write(cm8).getStatus();
    Assert.fail("Writing mutation with Authorizations the user doesn't have should fail. Got status: " + status);
  }
 catch (  AccumuloSecurityException ase) {
  }
 finally {
    cw2.close();
  }
}

</code></pre>

<br>
<pre class="type-8 type-3 type-2 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testOffline() throws Exception {
  String table=getUniqueNames(1)[0];
  Connector conn=getConnector();
  conn.tableOperations().create(table);
  ConditionalWriter cw=conn.createConditionalWriter(table,new ConditionalWriterConfig());
  conn.tableOperations().offline(table,true);
  ConditionalMutation cm1=new ConditionalMutation("r1",new Condition("tx","seq"));
  cm1.put("tx","seq","1");
  cm1.put("data","x","a");
  Result result=cw.write(cm1);
  try {
    Status status=result.getStatus();
    Assert.fail("Expected exception writing conditional mutation to offline table. Got status: " + status);
  }
 catch (  AccumuloException ae) {
    Assert.assertEquals(TableOfflineException.class,ae.getCause().getClass());
  }
  cw.close();
  try {
    conn.createConditionalWriter(table,new ConditionalWriterConfig());
    Assert.fail("Expected exception creating conditional writer to offline table");
  }
 catch (  TableOfflineException e) {
  }
}

</code></pre>

<br>
<pre class="type-8 type-3 type-2 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testDeleteTable() throws Exception {
  String table=getUniqueNames(1)[0];
  Connector conn=getConnector();
  try {
    conn.createConditionalWriter(table,new ConditionalWriterConfig());
    Assert.fail("Creating conditional writer for table that doesn't exist should fail");
  }
 catch (  TableNotFoundException e) {
  }
  conn.tableOperations().create(table);
  ConditionalWriter cw=conn.createConditionalWriter(table,new ConditionalWriterConfig());
  conn.tableOperations().delete(table);
  ConditionalMutation cm1=new ConditionalMutation("r1",new Condition("tx","seq"));
  cm1.put("tx","seq","1");
  cm1.put("data","x","a");
  Result result=cw.write(cm1);
  try {
    Status status=result.getStatus();
    Assert.fail("Expected exception writing conditional mutation to deleted table. Got status: " + status);
  }
 catch (  AccumuloException ae) {
    Assert.assertEquals(TableDeletedException.class,ae.getCause().getClass());
  }
}

</code></pre>

<br>
<pre class="type-9 type-11 type-8 type-3 type-2 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testTimeout() throws Exception {
  Connector conn=getConnector();
  String table=getUniqueNames(1)[0];
  conn.tableOperations().create(table);
  ConditionalWriter cw=conn.createConditionalWriter(table,new ConditionalWriterConfig().setTimeout(3,TimeUnit.SECONDS));
  ConditionalMutation cm1=new ConditionalMutation("r1",new Condition("tx","seq"));
  cm1.put("tx","seq","1");
  cm1.put("data","x","a");
  Assert.assertEquals(cw.write(cm1).getStatus(),Status.ACCEPTED);
  IteratorSetting is=new IteratorSetting(5,SlowIterator.class);
  SlowIterator.setSeekSleepTime(is,5000);
  ConditionalMutation cm2=new ConditionalMutation("r1",new Condition("tx","seq").setValue("1").setIterators(is));
  cm2.put("tx","seq","2");
  cm2.put("data","x","b");
  Assert.assertEquals(cw.write(cm2).getStatus(),Status.UNKNOWN);
  Scanner scanner=conn.createScanner(table,Authorizations.EMPTY);
  for (  Entry<Key,Value> entry : scanner) {
    String cf=entry.getKey().getColumnFamilyData().toString();
    String cq=entry.getKey().getColumnQualifierData().toString();
    String val=entry.getValue().toString();
    if (cf.equals("tx") && cq.equals("seq"))     Assert.assertEquals("Unexpected value in tx:seq","1",val);
 else     if (cf.equals("data") && cq.equals("x"))     Assert.assertEquals("Unexpected value in data:x","a",val);
 else     Assert.fail("Saw unexpected column family and qualifier: " + entry);
  }
  ConditionalMutation cm3=new ConditionalMutation("r1",new Condition("tx","seq").setValue("1"));
  cm3.put("tx","seq","2");
  cm3.put("data","x","b");
  Assert.assertEquals(cw.write(cm3).getStatus(),Status.ACCEPTED);
  cw.close();
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.accumulo.test.ExistingMacIT </h4><pre class="type-8 type-5 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testExistingRunningInstance() throws Exception {
  final String table=getUniqueNames(1)[0];
  Connector conn=getConnector();
  conn.tableOperations().create(table);
  BatchWriter bw=conn.createBatchWriter(table,new BatchWriterConfig());
  Mutation m=new Mutation("foo");
  m.put("cf","cq","value");
  bw.addMutation(m);
  bw.close();
  File hadoopConfDir=createTestDir(ExistingMacIT.class.getSimpleName() + "_hadoop_conf_2");
  FileUtils.deleteQuietly(hadoopConfDir);
  assertTrue(hadoopConfDir.mkdirs());
  createEmptyConfig(new File(hadoopConfDir,"core-site.xml"));
  createEmptyConfig(new File(hadoopConfDir,"hdfs-site.xml"));
  File testDir2=createTestDir(ExistingMacIT.class.getSimpleName() + "_3");
  FileUtils.deleteQuietly(testDir2);
  MiniAccumuloConfigImpl macConfig2=new MiniAccumuloConfigImpl(testDir2,"notused");
  macConfig2.useExistingInstance(new File(getCluster().getConfig().getConfDir(),"accumulo-site.xml"),hadoopConfDir);
  System.out.println("conf " + new File(getCluster().getConfig().getConfDir(),"accumulo-site.xml"));
  MiniAccumuloClusterImpl accumulo2=new MiniAccumuloClusterImpl(macConfig2);
  try {
    accumulo2.start();
    Assert.fail("A 2nd MAC instance should not be able to start over an existing MAC instance");
  }
 catch (  RuntimeException e) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.accumulo.test.ImportExportIT </h4><pre class="type-9 type-13 type-11 type-8 type-5 type-3 type-7 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions in iterations
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testExportImportThenScan() throws Exception {
  Connector conn=getConnector();
  String[] tableNames=getUniqueNames(2);
  String srcTable=tableNames[0], destTable=tableNames[1];
  conn.tableOperations().create(srcTable);
  BatchWriter bw=conn.createBatchWriter(srcTable,new BatchWriterConfig());
  for (int row=0; row < 1000; row++) {
    Mutation m=new Mutation(Integer.toString(row));
    for (int col=0; col < 100; col++) {
      m.put(Integer.toString(col),"",Integer.toString(col * 2));
    }
    bw.addMutation(m);
  }
  bw.close();
  conn.tableOperations().compact(srcTable,null,null,true,true);
  FileSystem fs=cluster.getFileSystem();
  Path tmp=cluster.getTemporaryPath();
  log.info("Using FileSystem: " + fs);
  Path baseDir=new Path(tmp,getClass().getName());
  if (fs.exists(baseDir)) {
    log.info("{} exists on filesystem, deleting",baseDir);
    assertTrue("Failed to deleted " + baseDir,fs.delete(baseDir,true));
  }
  log.info("Creating {}",baseDir);
  assertTrue("Failed to create " + baseDir,fs.mkdirs(baseDir));
  Path exportDir=new Path(baseDir,"export");
  Path importDir=new Path(baseDir,"import");
  for (  Path p : new Path[]{exportDir,importDir}) {
    assertTrue("Failed to create " + baseDir,fs.mkdirs(p));
  }
  log.info("Exporting table to {}",exportDir);
  log.info("Importing table from {}",importDir);
  conn.tableOperations().offline(srcTable,true);
  conn.tableOperations().exportTable(srcTable,exportDir.toString());
  Path distcp=new Path(exportDir,"distcp.txt");
  Assert.assertTrue("Distcp file doesn't exist",fs.exists(distcp));
  FSDataInputStream is=fs.open(distcp);
  BufferedReader reader=new BufferedReader(new InputStreamReader(is));
  String line;
  while (null != (line=reader.readLine())) {
    Path p=new Path(line.substring(5));
    Assert.assertTrue("File doesn't exist: " + p,fs.exists(p));
    Path dest=new Path(importDir,p.getName());
    Assert.assertFalse("Did not expect " + dest + " to exist",fs.exists(dest));
    FileUtil.copy(fs,p,fs,dest,false,fs.getConf());
  }
  reader.close();
  log.info("Import dir: {}",Arrays.toString(fs.listStatus(importDir)));
  conn.tableOperations().importTable(destTable,importDir.toString());
  final String tableId=conn.tableOperations().tableIdMap().get(destTable);
  Assert.assertNotNull(tableId);
  log.info("Imported into table with ID: {}",tableId);
  Scanner s=conn.createScanner(MetadataTable.NAME,Authorizations.EMPTY);
  s.setRange(MetadataSchema.TabletsSection.getRange(tableId));
  s.fetchColumnFamily(MetadataSchema.TabletsSection.DataFileColumnFamily.NAME);
  MetadataSchema.TabletsSection.ServerColumnFamily.DIRECTORY_COLUMN.fetch(s);
  for (  Entry<Key,Value> fileEntry : s) {
    Key k=fileEntry.getKey();
    String value=fileEntry.getValue().toString();
    if (k.getColumnFamily().equals(MetadataSchema.TabletsSection.DataFileColumnFamily.NAME)) {
      String fileUri=k.getColumnQualifier().toString();
      Assert.assertFalse("Imported files should have absolute URIs, not relative: " + fileUri,looksLikeRelativePath(fileUri));
    }
 else     if (k.getColumnFamily().equals(MetadataSchema.TabletsSection.ServerColumnFamily.NAME)) {
      Assert.assertFalse("Server directory should have absolute URI, not relative: " + value,looksLikeRelativePath(value));
    }
 else {
      Assert.fail("Got expected pair: " + k + "="+ fileEntry.getValue());
    }
  }
  conn.tableOperations().online(srcTable,true);
  verifyTableEquality(conn,srcTable,destTable);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.accumulo.test.InterruptibleScannersIT </h4><pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void test() throws Exception {
  final String tableName=getUniqueNames(1)[0];
  final Connector conn=getConnector();
  conn.tableOperations().create(tableName);
  final Scanner scanner=conn.createScanner(tableName,Authorizations.EMPTY);
  final IteratorSetting cfg=new IteratorSetting(100,SlowIterator.class);
  SlowIterator.setSeekSleepTime(cfg,60 * 1000);
  scanner.addScanIterator(cfg);
  final Thread scanThread=Thread.currentThread();
  Thread thread=new Thread(){
    @Override public void run(){
      try {
        String tserver=conn.instanceOperations().getTabletServers().iterator().next();
        do {
          ArrayList<ActiveScan> scans=new ArrayList<ActiveScan>(conn.instanceOperations().getActiveScans(tserver));
          Iterator<ActiveScan> iter=scans.iterator();
          while (iter.hasNext()) {
            ActiveScan scan=iter.next();
            if (!getAdminPrincipal().equals(scan.getUser()) || !tableName.equals(scan.getTable())) {
              iter.remove();
            }
          }
          if (!scans.isEmpty()) {
            break;
          }
        }
 while (true);
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
      scanThread.interrupt();
    }
  }
;
  thread.start();
  try {
    Iterators.size(scanner.iterator());
    Assert.fail("Scan should not succeed");
  }
 catch (  Exception ex) {
  }
 finally {
    thread.join();
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.accumulo.test.LargeSplitRowIT </h4><pre class="type-9 type-8 type-3 type-2 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=60 * 1000) public void userAddedSplit() throws Exception {
  log.info("User added split");
  final String tableName=getUniqueNames(1)[0];
  final Connector conn=getConnector();
  conn.tableOperations().create(tableName);
  conn.tableOperations().setProperty(tableName,Property.TABLE_MAX_END_ROW_SIZE.getKey(),"1000");
  BatchWriter batchWriter=conn.createBatchWriter(tableName,new BatchWriterConfig());
  Mutation m=new Mutation("Row");
  m.put("cf","cq","value");
  batchWriter.addMutation(m);
  batchWriter.close();
  SortedSet<Text> partitionKeys=new TreeSet<Text>();
  byte data[]=new byte[(int)(TableConfiguration.getMemoryInBytes(Property.TABLE_MAX_END_ROW_SIZE.getDefaultValue()) + 2)];
  for (int i=0; i < data.length; i++) {
    data[i]='m';
  }
  partitionKeys.add(new Text(data));
  try {
    conn.tableOperations().addSplits(tableName,partitionKeys);
    Assert.fail();
  }
 catch (  AccumuloServerException e) {
  }
  int counter=0;
  final Scanner scanner=conn.createScanner(tableName,Authorizations.EMPTY);
  for (  Entry<Key,Value> entry : scanner) {
    counter++;
    Key k=entry.getKey();
    Assert.assertEquals("Row",k.getRow().toString());
    Assert.assertEquals("cf",k.getColumnFamily().toString());
    Assert.assertEquals("cq",k.getColumnQualifier().toString());
    Assert.assertEquals("value",entry.getValue().toString());
  }
  Assert.assertEquals(1,counter);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.accumulo.test.LocatorIT </h4><pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testBasic() throws Exception {
  Connector conn=getConnector();
  String tableName=getUniqueNames(1)[0];
  conn.tableOperations().create(tableName);
  Range r1=new Range("m");
  Range r2=new Range("o","x");
  String tableId=conn.tableOperations().tableIdMap().get(tableName);
  TabletId t1=newTabletId(tableId,null,null);
  TabletId t2=newTabletId(tableId,"r",null);
  TabletId t3=newTabletId(tableId,null,"r");
  ArrayList<Range> ranges=new ArrayList<>();
  HashSet<String> tservers=new HashSet<>(conn.instanceOperations().getTabletServers());
  ranges.add(r1);
  Locations ret=conn.tableOperations().locate(tableName,ranges);
  assertContains(ret,tservers,ImmutableMap.of(r1,ImmutableSet.of(t1)),ImmutableMap.of(t1,ImmutableSet.of(r1)));
  ranges.add(r2);
  ret=conn.tableOperations().locate(tableName,ranges);
  assertContains(ret,tservers,ImmutableMap.of(r1,ImmutableSet.of(t1),r2,ImmutableSet.of(t1)),ImmutableMap.of(t1,ImmutableSet.of(r1,r2)));
  TreeSet<Text> splits=new TreeSet<Text>();
  splits.add(new Text("r"));
  conn.tableOperations().addSplits(tableName,splits);
  ret=conn.tableOperations().locate(tableName,ranges);
  assertContains(ret,tservers,ImmutableMap.of(r1,ImmutableSet.of(t2),r2,ImmutableSet.of(t2,t3)),ImmutableMap.of(t2,ImmutableSet.of(r1,r2),t3,ImmutableSet.of(r2)));
  conn.tableOperations().offline(tableName,true);
  try {
    conn.tableOperations().locate(tableName,ranges);
    Assert.fail();
  }
 catch (  TableOfflineException e) {
  }
  conn.tableOperations().delete(tableName);
  try {
    conn.tableOperations().locate(tableName,ranges);
    Assert.fail();
  }
 catch (  TableNotFoundException e) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.accumulo.test.MultiTableBatchWriterIT </h4><pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testTableRenameNewWritersNoCaching() throws Exception {
  mtbw=getMultiTableBatchWriter(0);
  try {
    final String[] names=getUniqueNames(4);
    final String table1=names[0], table2=names[1];
    final String newTable1=names[2], newTable2=names[3];
    TableOperations tops=connector.tableOperations();
    tops.create(table1);
    tops.create(table2);
    BatchWriter bw1=mtbw.getBatchWriter(table1), bw2=mtbw.getBatchWriter(table2);
    Mutation m1=new Mutation("foo");
    m1.put("col1","","val1");
    m1.put("col2","","val2");
    bw1.addMutation(m1);
    bw2.addMutation(m1);
    tops.rename(table1,newTable1);
    tops.rename(table2,newTable2);
    try {
      bw1=mtbw.getBatchWriter(table1);
      Assert.fail("Should not have gotten batchwriter for " + table1);
    }
 catch (    TableNotFoundException e) {
    }
    try {
      bw2=mtbw.getBatchWriter(table2);
    }
 catch (    TableNotFoundException e) {
    }
  }
  finally {
    if (null != mtbw) {
      mtbw.close();
    }
  }
}

</code></pre>

<br>
<pre class="type-8 type-5 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testOfflineTableWithoutCache() throws Exception {
  mtbw=getMultiTableBatchWriter(0);
  boolean mutationsRejected=false;
  try {
    final String[] names=getUniqueNames(2);
    final String table1=names[0], table2=names[1];
    TableOperations tops=connector.tableOperations();
    tops.create(table1);
    tops.create(table2);
    BatchWriter bw1=mtbw.getBatchWriter(table1), bw2=mtbw.getBatchWriter(table2);
    Mutation m1=new Mutation("foo");
    m1.put("col1","","val1");
    m1.put("col2","","val2");
    bw1.addMutation(m1);
    bw2.addMutation(m1);
    tops.offline(table1);
    tops.offline(table2);
    try {
      bw1=mtbw.getBatchWriter(table1);
      Assert.fail(table1 + " should be offline");
    }
 catch (    TableOfflineException e) {
      mutationsRejected=true;
    }
    try {
      bw2=mtbw.getBatchWriter(table2);
      Assert.fail(table1 + " should be offline");
    }
 catch (    TableOfflineException e) {
      mutationsRejected=true;
    }
  }
  finally {
    if (null != mtbw) {
      try {
        mtbw.close();
      }
 catch (      MutationsRejectedException e) {
        mutationsRejected=true;
      }
    }
  }
  Assert.assertTrue("Expected mutations to be rejected.",mutationsRejected);
}

</code></pre>

<br>
<pre class="type-8 type-2 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testTableRenameNewWriters() throws Exception {
  try {
    final String[] names=getUniqueNames(4);
    final String table1=names[0], table2=names[1];
    final String newTable1=names[2], newTable2=names[3];
    TableOperations tops=connector.tableOperations();
    tops.create(table1);
    tops.create(table2);
    BatchWriter bw1=mtbw.getBatchWriter(table1), bw2=mtbw.getBatchWriter(table2);
    Mutation m1=new Mutation("foo");
    m1.put("col1","","val1");
    m1.put("col2","","val2");
    bw1.addMutation(m1);
    bw2.addMutation(m1);
    tops.rename(table1,newTable1);
    try {
      bw1=mtbw.getBatchWriter(table1);
      Assert.fail("Should not be able to find this table");
    }
 catch (    TableNotFoundException e) {
    }
    tops.rename(table2,newTable2);
    try {
      bw2=mtbw.getBatchWriter(table2);
      Assert.fail("Should not be able to find this table");
    }
 catch (    TableNotFoundException e) {
    }
    bw1=mtbw.getBatchWriter(newTable1);
    bw2=mtbw.getBatchWriter(newTable2);
    Mutation m2=new Mutation("bar");
    m2.put("col1","","val1");
    m2.put("col2","","val2");
    bw1.addMutation(m2);
    bw2.addMutation(m2);
    mtbw.close();
    Map<Entry<String,String>,String> expectations=new HashMap<Entry<String,String>,String>();
    expectations.put(Maps.immutableEntry("foo","col1"),"val1");
    expectations.put(Maps.immutableEntry("foo","col2"),"val2");
    expectations.put(Maps.immutableEntry("bar","col1"),"val1");
    expectations.put(Maps.immutableEntry("bar","col2"),"val2");
    for (    String table : Arrays.asList(newTable1,newTable2)) {
      Scanner s=connector.createScanner(table,new Authorizations());
      s.setRange(new Range());
      Map<Entry<String,String>,String> actual=new HashMap<Entry<String,String>,String>();
      for (      Entry<Key,Value> entry : s) {
        actual.put(Maps.immutableEntry(entry.getKey().getRow().toString(),entry.getKey().getColumnFamily().toString()),entry.getValue().toString());
      }
      Assert.assertEquals("Differing results for " + table,expectations,actual);
    }
  }
  finally {
    if (null != mtbw) {
      mtbw.close();
    }
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.accumulo.test.NamespacesIT </h4><pre class="type-8 type-5 type-3 type-2 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void renameTable() throws Exception {
  String namespace2=namespace + "_renamed";
  String t1=namespace + ".1";
  String t2=namespace2 + ".2";
  String t3=namespace + ".3";
  String t4=namespace + ".4";
  String t5="5";
  c.namespaceOperations().create(namespace);
  c.namespaceOperations().create(namespace2);
  assertTrue(c.namespaceOperations().exists(namespace));
  assertTrue(c.namespaceOperations().exists(namespace2));
  assertFalse(c.tableOperations().exists(t1));
  assertFalse(c.tableOperations().exists(t2));
  assertFalse(c.tableOperations().exists(t3));
  assertFalse(c.tableOperations().exists(t4));
  assertFalse(c.tableOperations().exists(t5));
  c.tableOperations().create(t1);
  try {
    c.tableOperations().rename(t1,t2);
    fail();
  }
 catch (  AccumuloException e) {
    assertEquals(ThriftTableOperationException.class.getName(),e.getCause().getClass().getName());
    assertEquals(TableOperation.RENAME,((ThriftTableOperationException)e.getCause()).getOp());
    assertEquals(TableOperationExceptionType.INVALID_NAME,((ThriftTableOperationException)e.getCause()).getType());
  }
  try {
    c.tableOperations().rename(t1,t5);
    fail();
  }
 catch (  AccumuloException e) {
    assertEquals(ThriftTableOperationException.class.getName(),e.getCause().getClass().getName());
    assertEquals(TableOperation.RENAME,((ThriftTableOperationException)e.getCause()).getOp());
    assertEquals(TableOperationExceptionType.INVALID_NAME,((ThriftTableOperationException)e.getCause()).getType());
  }
  assertTrue(c.tableOperations().exists(t1));
  assertFalse(c.tableOperations().exists(t2));
  assertFalse(c.tableOperations().exists(t3));
  assertFalse(c.tableOperations().exists(t4));
  assertFalse(c.tableOperations().exists(t5));
  c.tableOperations().rename(t1,t3);
  assertFalse(c.tableOperations().exists(t1));
  assertFalse(c.tableOperations().exists(t2));
  assertTrue(c.tableOperations().exists(t3));
  assertFalse(c.tableOperations().exists(t4));
  assertFalse(c.tableOperations().exists(t5));
}

</code></pre>

<br>
<pre class="type-9 type-8 type-5 type-3 type-2 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void verifyIteratorInheritance() throws Exception {
  String t1=namespace + ".1";
  c.namespaceOperations().create(namespace);
  c.tableOperations().create(t1);
  String iterName=namespace + "_iter";
  BatchWriter bw=c.createBatchWriter(t1,new BatchWriterConfig());
  Mutation m=new Mutation("r");
  m.put("a","b",new Value("abcde".getBytes()));
  bw.addMutation(m);
  bw.flush();
  bw.close();
  IteratorSetting setting=new IteratorSetting(250,iterName,SimpleFilter.class.getName());
  Scanner s=c.createScanner(t1,Authorizations.EMPTY);
  assertTrue(s.iterator().hasNext());
  assertFalse(c.namespaceOperations().listIterators(namespace).containsKey(iterName));
  assertFalse(c.tableOperations().listIterators(t1).containsKey(iterName));
  c.namespaceOperations().checkIteratorConflicts(namespace,setting,EnumSet.allOf(IteratorScope.class));
  c.namespaceOperations().attachIterator(namespace,setting);
  sleepUninterruptibly(2,TimeUnit.SECONDS);
  try {
    c.namespaceOperations().checkIteratorConflicts(namespace,setting,EnumSet.allOf(IteratorScope.class));
    fail();
  }
 catch (  AccumuloException e) {
    assertEquals(IllegalArgumentException.class.getName(),e.getCause().getClass().getName());
  }
  IteratorSetting setting2=c.namespaceOperations().getIteratorSetting(namespace,setting.getName(),IteratorScope.scan);
  assertEquals(setting,setting2);
  assertTrue(c.namespaceOperations().listIterators(namespace).containsKey(iterName));
  assertTrue(c.tableOperations().listIterators(t1).containsKey(iterName));
  s=c.createScanner(t1,Authorizations.EMPTY);
  assertFalse(s.iterator().hasNext());
  c.namespaceOperations().removeIterator(namespace,setting.getName(),EnumSet.allOf(IteratorScope.class));
  sleepUninterruptibly(2,TimeUnit.SECONDS);
  assertFalse(c.namespaceOperations().listIterators(namespace).containsKey(iterName));
  assertFalse(c.tableOperations().listIterators(t1).containsKey(iterName));
  s=c.createScanner(t1,Authorizations.EMPTY);
  assertTrue(s.iterator().hasNext());
}

</code></pre>

<br>
<pre class="type-8 type-5 type-3 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testModifyingPermissions() throws Exception {
  String tableName=namespace + ".modify";
  c.namespaceOperations().create(namespace);
  c.tableOperations().create(tableName);
  assertTrue(c.securityOperations().hasTablePermission(c.whoami(),tableName,TablePermission.READ));
  c.securityOperations().revokeTablePermission(c.whoami(),tableName,TablePermission.READ);
  assertFalse(c.securityOperations().hasTablePermission(c.whoami(),tableName,TablePermission.READ));
  c.securityOperations().grantTablePermission(c.whoami(),tableName,TablePermission.READ);
  assertTrue(c.securityOperations().hasTablePermission(c.whoami(),tableName,TablePermission.READ));
  c.tableOperations().delete(tableName);
  try {
    c.securityOperations().hasTablePermission(c.whoami(),tableName,TablePermission.READ);
    fail();
  }
 catch (  Exception e) {
    if (!(e instanceof AccumuloSecurityException) || !((AccumuloSecurityException)e).getSecurityErrorCode().equals(SecurityErrorCode.TABLE_DOESNT_EXIST))     throw new Exception("Has permission resulted in " + e.getClass().getName(),e);
  }
  try {
    c.securityOperations().grantTablePermission(c.whoami(),tableName,TablePermission.READ);
    fail();
  }
 catch (  Exception e) {
    if (!(e instanceof AccumuloSecurityException) || !((AccumuloSecurityException)e).getSecurityErrorCode().equals(SecurityErrorCode.TABLE_DOESNT_EXIST))     throw new Exception("Has permission resulted in " + e.getClass().getName(),e);
  }
  try {
    c.securityOperations().revokeTablePermission(c.whoami(),tableName,TablePermission.READ);
    fail();
  }
 catch (  Exception e) {
    if (!(e instanceof AccumuloSecurityException) || !((AccumuloSecurityException)e).getSecurityErrorCode().equals(SecurityErrorCode.TABLE_DOESNT_EXIST))     throw new Exception("Has permission resulted in " + e.getClass().getName(),e);
  }
  assertTrue(c.securityOperations().hasNamespacePermission(c.whoami(),namespace,NamespacePermission.READ));
  c.securityOperations().revokeNamespacePermission(c.whoami(),namespace,NamespacePermission.READ);
  assertFalse(c.securityOperations().hasNamespacePermission(c.whoami(),namespace,NamespacePermission.READ));
  c.securityOperations().grantNamespacePermission(c.whoami(),namespace,NamespacePermission.READ);
  assertTrue(c.securityOperations().hasNamespacePermission(c.whoami(),namespace,NamespacePermission.READ));
  c.namespaceOperations().delete(namespace);
  try {
    c.securityOperations().hasTablePermission(c.whoami(),tableName,TablePermission.READ);
    fail();
  }
 catch (  Exception e) {
    if (!(e instanceof AccumuloSecurityException) || !((AccumuloSecurityException)e).getSecurityErrorCode().equals(SecurityErrorCode.TABLE_DOESNT_EXIST))     throw new Exception("Has permission resulted in " + e.getClass().getName(),e);
  }
  try {
    c.securityOperations().grantTablePermission(c.whoami(),tableName,TablePermission.READ);
    fail();
  }
 catch (  Exception e) {
    if (!(e instanceof AccumuloSecurityException) || !((AccumuloSecurityException)e).getSecurityErrorCode().equals(SecurityErrorCode.TABLE_DOESNT_EXIST))     throw new Exception("Has permission resulted in " + e.getClass().getName(),e);
  }
  try {
    c.securityOperations().revokeTablePermission(c.whoami(),tableName,TablePermission.READ);
    fail();
  }
 catch (  Exception e) {
    if (!(e instanceof AccumuloSecurityException) || !((AccumuloSecurityException)e).getSecurityErrorCode().equals(SecurityErrorCode.TABLE_DOESNT_EXIST))     throw new Exception("Has permission resulted in " + e.getClass().getName(),e);
  }
  try {
    c.securityOperations().hasNamespacePermission(c.whoami(),namespace,NamespacePermission.READ);
    fail();
  }
 catch (  Exception e) {
    if (!(e instanceof AccumuloSecurityException) || !((AccumuloSecurityException)e).getSecurityErrorCode().equals(SecurityErrorCode.NAMESPACE_DOESNT_EXIST))     throw new Exception("Has permission resulted in " + e.getClass().getName(),e);
  }
  try {
    c.securityOperations().grantNamespacePermission(c.whoami(),namespace,NamespacePermission.READ);
    fail();
  }
 catch (  Exception e) {
    if (!(e instanceof AccumuloSecurityException) || !((AccumuloSecurityException)e).getSecurityErrorCode().equals(SecurityErrorCode.NAMESPACE_DOESNT_EXIST))     throw new Exception("Has permission resulted in " + e.getClass().getName(),e);
  }
  try {
    c.securityOperations().revokeNamespacePermission(c.whoami(),namespace,NamespacePermission.READ);
    fail();
  }
 catch (  Exception e) {
    if (!(e instanceof AccumuloSecurityException) || !((AccumuloSecurityException)e).getSecurityErrorCode().equals(SecurityErrorCode.NAMESPACE_DOESNT_EXIST))     throw new Exception("Has permission resulted in " + e.getClass().getName(),e);
  }
}

</code></pre>

<br>
<pre class="type-13 type-11 type-8 type-5 type-3 type-2 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void verifyTableOperationsExceptions() throws Exception {
  String tableName=namespace + ".1";
  IteratorSetting setting=new IteratorSetting(200,VersioningIterator.class);
  Text a=new Text("a");
  Text z=new Text("z");
  TableOperations ops=c.tableOperations();
  assertFalse(ops.exists(tableName));
  int numRun=0;
  ACCUMULOEXCEPTIONS_NAMESPACENOTFOUND:   for (int i=0; ; ++i)   try {
switch (i) {
case 0:
      ops.create(tableName);
    fail();
  break;
case 1:
ops.create("a");
ops.clone("a",tableName,true,Collections.<String,String>emptyMap(),Collections.<String>emptySet());
fail();
break;
case 2:
ops.importTable(tableName,System.getProperty("user.dir") + "/target");
fail();
break;
default :
assertEquals(3,i);
assertEquals(3,numRun);
break ACCUMULOEXCEPTIONS_NAMESPACENOTFOUND;
}
}
 catch (Exception e) {
numRun++;
if (!(e instanceof AccumuloException) || !(e.getCause() instanceof NamespaceNotFoundException)) throw new Exception("Case " + i + " resulted in "+ e.getClass().getName(),e);
}
numRun=0;
ACCUMULOEXCEPTIONS_TABLENOTFOUND: for (int i=0; ; ++i) try {
switch (i) {
case 0:
ops.removeConstraint(tableName,0);
fail();
break;
case 1:
ops.removeProperty(tableName,"a");
fail();
break;
case 2:
ops.setProperty(tableName,"a","b");
fail();
break;
default :
assertEquals(3,i);
assertEquals(3,numRun);
break ACCUMULOEXCEPTIONS_TABLENOTFOUND;
}
}
 catch (Exception e) {
numRun++;
if (!(e instanceof AccumuloException) || !(e.getCause() instanceof TableNotFoundException) || !(e.getCause().getCause() instanceof NamespaceNotFoundException)) throw new Exception("Case " + i + " resulted in "+ e.getClass().getName(),e);
}
numRun=0;
TABLENOTFOUNDEXCEPTIONS: for (int i=0; ; ++i) try {
switch (i) {
case 0:
ops.addConstraint(tableName,NumericValueConstraint.class.getName());
fail();
break;
case 1:
ops.addSplits(tableName,new TreeSet<Text>());
fail();
break;
case 2:
ops.attachIterator(tableName,setting);
fail();
break;
case 3:
ops.cancelCompaction(tableName);
fail();
break;
case 4:
ops.checkIteratorConflicts(tableName,setting,EnumSet.allOf(IteratorScope.class));
fail();
break;
case 5:
ops.clearLocatorCache(tableName);
fail();
break;
case 6:
ops.clone(tableName,"2",true,Collections.<String,String>emptyMap(),Collections.<String>emptySet());
fail();
break;
case 7:
ops.compact(tableName,a,z,true,true);
fail();
break;
case 8:
ops.delete(tableName);
fail();
break;
case 9:
ops.deleteRows(tableName,a,z);
fail();
break;
case 10:
ops.splitRangeByTablets(tableName,new Range(),10);
fail();
break;
case 11:
ops.exportTable(tableName,namespace + "_dir");
fail();
break;
case 12:
ops.flush(tableName,a,z,true);
fail();
break;
case 13:
ops.getDiskUsage(Collections.singleton(tableName));
fail();
break;
case 14:
ops.getIteratorSetting(tableName,"a",IteratorScope.scan);
fail();
break;
case 15:
ops.getLocalityGroups(tableName);
fail();
break;
case 16:
ops.getMaxRow(tableName,Authorizations.EMPTY,a,true,z,true);
fail();
break;
case 17:
ops.getProperties(tableName);
fail();
break;
case 18:
ops.importDirectory(tableName,"","",false);
fail();
break;
case 19:
ops.testClassLoad(tableName,VersioningIterator.class.getName(),SortedKeyValueIterator.class.getName());
fail();
break;
case 20:
ops.listConstraints(tableName);
fail();
break;
case 21:
ops.listIterators(tableName);
fail();
break;
case 22:
ops.listSplits(tableName);
fail();
break;
case 23:
ops.merge(tableName,a,z);
fail();
break;
case 24:
ops.offline(tableName,true);
fail();
break;
case 25:
ops.online(tableName,true);
fail();
break;
case 26:
ops.removeIterator(tableName,"a",EnumSet.of(IteratorScope.scan));
fail();
break;
case 27:
ops.rename(tableName,tableName + "2");
fail();
break;
case 28:
ops.setLocalityGroups(tableName,Collections.<String,Set<Text>>emptyMap());
fail();
break;
default :
assertEquals(29,i);
assertEquals(29,numRun);
break TABLENOTFOUNDEXCEPTIONS;
}
}
 catch (Exception e) {
numRun++;
if (!(e instanceof TableNotFoundException) || !(e.getCause() instanceof NamespaceNotFoundException)) throw new Exception("Case " + i + " resulted in "+ e.getClass().getName(),e);
}
}

</code></pre>

<br>
<pre class="type-13 type-11 type-8 type-5 type-3 type-2 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void verifyNamespaceOperationsExceptions() throws Exception {
  IteratorSetting setting=new IteratorSetting(200,VersioningIterator.class);
  NamespaceOperations ops=c.namespaceOperations();
  assertFalse(ops.exists(namespace));
  int numRun=0;
  NAMESPACENOTFOUND:   for (int i=0; ; ++i)   try {
switch (i) {
case 0:
      ops.addConstraint(namespace,NumericValueConstraint.class.getName());
    fail();
  break;
case 1:
ops.attachIterator(namespace,setting);
fail();
break;
case 2:
ops.checkIteratorConflicts(namespace,setting,EnumSet.of(IteratorScope.scan));
fail();
break;
case 3:
ops.delete(namespace);
fail();
break;
case 4:
ops.getIteratorSetting(namespace,"thing",IteratorScope.scan);
fail();
break;
case 5:
ops.getProperties(namespace);
fail();
break;
case 6:
ops.listConstraints(namespace);
fail();
break;
case 7:
ops.listIterators(namespace);
fail();
break;
case 8:
ops.removeConstraint(namespace,1);
fail();
break;
case 9:
ops.removeIterator(namespace,"thing",EnumSet.allOf(IteratorScope.class));
fail();
break;
case 10:
ops.removeProperty(namespace,"a");
fail();
break;
case 11:
ops.rename(namespace,namespace + "2");
fail();
break;
case 12:
ops.setProperty(namespace,"k","v");
fail();
break;
case 13:
ops.testClassLoad(namespace,VersioningIterator.class.getName(),SortedKeyValueIterator.class.getName());
fail();
break;
default :
assertEquals(14,i);
assertEquals(14,numRun);
break NAMESPACENOTFOUND;
}
}
 catch (Exception e) {
numRun++;
if (!(e instanceof NamespaceNotFoundException)) throw new Exception("Case " + i + " resulted in "+ e.getClass().getName(),e);
}
numRun=0;
NAMESPACEEXISTS: for (int i=0; ; ++i) try {
switch (i) {
case 0:
ops.create(namespace + "0");
ops.create(namespace + "0");
fail();
break;
case 1:
ops.create(namespace + i + "_1");
ops.create(namespace + i + "_2");
ops.rename(namespace + i + "_1",namespace + i + "_2");
fail();
break;
case 2:
ops.create(Namespaces.DEFAULT_NAMESPACE);
fail();
break;
case 3:
ops.create(Namespaces.ACCUMULO_NAMESPACE);
fail();
break;
case 4:
ops.create(namespace + i + "_1");
ops.rename(namespace + i + "_1",Namespaces.DEFAULT_NAMESPACE);
fail();
break;
case 5:
ops.create(namespace + i + "_1");
ops.rename(namespace + i + "_1",Namespaces.ACCUMULO_NAMESPACE);
fail();
break;
default :
assertEquals(6,i);
assertEquals(6,numRun);
break NAMESPACEEXISTS;
}
}
 catch (Exception e) {
numRun++;
if (!(e instanceof NamespaceExistsException)) throw new Exception("Case " + i + " resulted in "+ e.getClass().getName(),e);
}
}

</code></pre>

<br>
<pre class="type-8 type-5 type-3 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void loadClass() throws Exception {
  assertTrue(c.namespaceOperations().testClassLoad(Namespaces.DEFAULT_NAMESPACE,VersioningIterator.class.getName(),SortedKeyValueIterator.class.getName()));
  assertFalse(c.namespaceOperations().testClassLoad(Namespaces.DEFAULT_NAMESPACE,"dummy",SortedKeyValueIterator.class.getName()));
  try {
    c.namespaceOperations().testClassLoad(namespace,"dummy","dummy");
    fail();
  }
 catch (  NamespaceNotFoundException e) {
  }
}

</code></pre>

<br>
<pre class="type-8 type-5 type-3 type-2 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void createTableInMissingNamespace() throws Exception {
  String t=namespace + ".1";
  assertFalse(c.namespaceOperations().exists(namespace));
  assertFalse(c.tableOperations().exists(t));
  try {
    c.tableOperations().create(t);
    fail();
  }
 catch (  AccumuloException e) {
    assertEquals(NamespaceNotFoundException.class.getName(),e.getCause().getClass().getName());
    assertFalse(c.namespaceOperations().exists(namespace));
    assertFalse(c.tableOperations().exists(t));
  }
}

</code></pre>

<br>
<pre class="type-9 type-11 type-8 type-5 type-3 type-2 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Tests new Namespace permissions as well as modifications to Table permissions because of namespaces. Checks each permission to first make sure the user
 * doesn't have permission to perform the action, then root grants them the permission and we check to make sure they could perform the action.
 */
@Test public void testPermissions() throws Exception {
  ClusterUser user1=getUser(0), user2=getUser(1), root=getAdminUser();
  String u1=user1.getPrincipal();
  String u2=user2.getPrincipal();
  PasswordToken pass=(null != user1.getPassword() ? new PasswordToken(user1.getPassword()) : null);
  String n1=namespace;
  String t1=n1 + ".1";
  String t2=n1 + ".2";
  String t3=n1 + ".3";
  String n2=namespace + "_2";
  loginAs(root);
  c.namespaceOperations().create(n1);
  c.tableOperations().create(t1);
  c.securityOperations().createLocalUser(u1,pass);
  loginAs(user1);
  Connector user1Con=c.getInstance().getConnector(u1,user1.getToken());
  try {
    user1Con.tableOperations().create(t2);
    fail();
  }
 catch (  AccumuloSecurityException e) {
    expectPermissionDenied(e);
  }
  loginAs(root);
  c.securityOperations().grantNamespacePermission(u1,n1,NamespacePermission.CREATE_TABLE);
  loginAs(user1);
  user1Con.tableOperations().create(t2);
  loginAs(root);
  assertTrue(c.tableOperations().list().contains(t2));
  c.securityOperations().revokeNamespacePermission(u1,n1,NamespacePermission.CREATE_TABLE);
  loginAs(user1);
  try {
    user1Con.tableOperations().delete(t1);
    fail();
  }
 catch (  AccumuloSecurityException e) {
    expectPermissionDenied(e);
  }
  loginAs(root);
  c.securityOperations().grantNamespacePermission(u1,n1,NamespacePermission.DROP_TABLE);
  loginAs(user1);
  user1Con.tableOperations().delete(t1);
  loginAs(root);
  assertTrue(!c.tableOperations().list().contains(t1));
  c.securityOperations().revokeNamespacePermission(u1,n1,NamespacePermission.DROP_TABLE);
  c.tableOperations().create(t3);
  BatchWriter bw=c.createBatchWriter(t3,null);
  Mutation m=new Mutation("row");
  m.put("cf","cq","value");
  bw.addMutation(m);
  bw.close();
  loginAs(user1);
  Iterator<Entry<Key,Value>> i=user1Con.createScanner(t3,new Authorizations()).iterator();
  try {
    i.next();
    fail();
  }
 catch (  RuntimeException e) {
    assertEquals(AccumuloSecurityException.class.getName(),e.getCause().getClass().getName());
    expectPermissionDenied((AccumuloSecurityException)e.getCause());
  }
  loginAs(user1);
  m=new Mutation(u1);
  m.put("cf","cq","turtles");
  bw=user1Con.createBatchWriter(t3,null);
  try {
    bw.addMutation(m);
    bw.close();
    fail();
  }
 catch (  MutationsRejectedException e) {
    assertEquals(1,e.getSecurityErrorCodes().size());
    assertEquals(1,e.getSecurityErrorCodes().entrySet().iterator().next().getValue().size());
switch (e.getSecurityErrorCodes().entrySet().iterator().next().getValue().iterator().next()) {
case PERMISSION_DENIED:
      break;
default :
    fail();
}
}
loginAs(root);
c.securityOperations().grantNamespacePermission(u1,n1,NamespacePermission.READ);
loginAs(user1);
i=user1Con.createScanner(t3,new Authorizations()).iterator();
assertTrue(i.hasNext());
loginAs(root);
c.securityOperations().revokeNamespacePermission(u1,n1,NamespacePermission.READ);
c.securityOperations().grantNamespacePermission(u1,n1,NamespacePermission.WRITE);
loginAs(user1);
m=new Mutation(u1);
m.put("cf","cq","turtles");
bw=user1Con.createBatchWriter(t3,null);
bw.addMutation(m);
bw.close();
loginAs(root);
c.securityOperations().revokeNamespacePermission(u1,n1,NamespacePermission.WRITE);
loginAs(user1);
try {
user1Con.tableOperations().setProperty(t3,Property.TABLE_FILE_MAX.getKey(),"42");
fail();
}
 catch (AccumuloSecurityException e) {
expectPermissionDenied(e);
}
loginAs(root);
c.securityOperations().grantNamespacePermission(u1,n1,NamespacePermission.ALTER_TABLE);
loginAs(user1);
user1Con.tableOperations().setProperty(t3,Property.TABLE_FILE_MAX.getKey(),"42");
user1Con.tableOperations().removeProperty(t3,Property.TABLE_FILE_MAX.getKey());
loginAs(root);
c.securityOperations().revokeNamespacePermission(u1,n1,NamespacePermission.ALTER_TABLE);
loginAs(user1);
try {
user1Con.namespaceOperations().setProperty(n1,Property.TABLE_FILE_MAX.getKey(),"55");
fail();
}
 catch (AccumuloSecurityException e) {
expectPermissionDenied(e);
}
loginAs(root);
c.securityOperations().grantNamespacePermission(u1,n1,NamespacePermission.ALTER_NAMESPACE);
loginAs(user1);
user1Con.namespaceOperations().setProperty(n1,Property.TABLE_FILE_MAX.getKey(),"42");
user1Con.namespaceOperations().removeProperty(n1,Property.TABLE_FILE_MAX.getKey());
loginAs(root);
c.securityOperations().revokeNamespacePermission(u1,n1,NamespacePermission.ALTER_NAMESPACE);
loginAs(root);
c.securityOperations().createLocalUser(u2,(root.getPassword() == null ? null : new PasswordToken(user2.getPassword())));
loginAs(user1);
try {
user1Con.securityOperations().grantNamespacePermission(u2,n1,NamespacePermission.ALTER_NAMESPACE);
fail();
}
 catch (AccumuloSecurityException e) {
expectPermissionDenied(e);
}
loginAs(root);
c.securityOperations().grantNamespacePermission(u1,n1,NamespacePermission.GRANT);
loginAs(user1);
user1Con.securityOperations().grantNamespacePermission(u2,n1,NamespacePermission.ALTER_NAMESPACE);
user1Con.securityOperations().revokeNamespacePermission(u2,n1,NamespacePermission.ALTER_NAMESPACE);
loginAs(root);
c.securityOperations().revokeNamespacePermission(u1,n1,NamespacePermission.GRANT);
loginAs(user1);
try {
user1Con.namespaceOperations().create(n2);
fail();
}
 catch (AccumuloSecurityException e) {
expectPermissionDenied(e);
}
loginAs(root);
c.securityOperations().grantSystemPermission(u1,SystemPermission.CREATE_NAMESPACE);
loginAs(user1);
user1Con.namespaceOperations().create(n2);
loginAs(root);
c.securityOperations().revokeSystemPermission(u1,SystemPermission.CREATE_NAMESPACE);
c.securityOperations().revokeNamespacePermission(u1,n2,NamespacePermission.DROP_NAMESPACE);
loginAs(user1);
try {
user1Con.namespaceOperations().delete(n2);
fail();
}
 catch (AccumuloSecurityException e) {
expectPermissionDenied(e);
}
loginAs(root);
c.securityOperations().grantSystemPermission(u1,SystemPermission.DROP_NAMESPACE);
loginAs(user1);
user1Con.namespaceOperations().delete(n2);
loginAs(root);
c.securityOperations().revokeSystemPermission(u1,SystemPermission.DROP_NAMESPACE);
loginAs(user1);
try {
user1Con.namespaceOperations().setProperty(n1,Property.TABLE_FILE_MAX.getKey(),"33");
fail();
}
 catch (AccumuloSecurityException e) {
expectPermissionDenied(e);
}
loginAs(root);
c.securityOperations().grantSystemPermission(u1,SystemPermission.ALTER_NAMESPACE);
loginAs(user1);
user1Con.namespaceOperations().setProperty(n1,Property.TABLE_FILE_MAX.getKey(),"33");
user1Con.namespaceOperations().removeProperty(n1,Property.TABLE_FILE_MAX.getKey());
loginAs(root);
c.securityOperations().revokeSystemPermission(u1,SystemPermission.ALTER_NAMESPACE);
}

</code></pre>

<br>
<pre class="type-8 type-5 type-3 type-2 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void cloneTable() throws Exception {
  String namespace2=namespace + "_clone";
  String t1=namespace + ".1";
  String t2=namespace + ".2";
  String t3=namespace2 + ".2";
  String k1=Property.TABLE_FILE_MAX.getKey();
  String k2=Property.TABLE_FILE_REPLICATION.getKey();
  String k1v1="55";
  String k1v2="66";
  String k2v1="5";
  String k2v2="6";
  c.namespaceOperations().create(namespace);
  c.tableOperations().create(t1);
  assertTrue(c.tableOperations().exists(t1));
  assertFalse(c.namespaceOperations().exists(namespace2));
  assertFalse(c.tableOperations().exists(t2));
  assertFalse(c.tableOperations().exists(t3));
  try {
    c.tableOperations().clone(t1,t3,false,null,null);
    fail();
  }
 catch (  AccumuloException e) {
    assertEquals(NamespaceNotFoundException.class.getName(),e.getCause().getClass().getName());
  }
  c.namespaceOperations().create(namespace2);
  c.tableOperations().create(t2);
  c.tableOperations().create(t3);
  for (  String t : Arrays.asList(t2,t3)) {
    try {
      c.tableOperations().clone(t1,t,false,null,null);
      fail();
    }
 catch (    TableExistsException e) {
      c.tableOperations().delete(t);
    }
  }
  assertTrue(c.tableOperations().exists(t1));
  assertTrue(c.namespaceOperations().exists(namespace2));
  assertFalse(c.tableOperations().exists(t2));
  assertFalse(c.tableOperations().exists(t3));
  assertFalse(checkNamespaceHasProp(namespace,k1,k1v1));
  assertFalse(checkNamespaceHasProp(namespace2,k1,k1v2));
  assertFalse(checkTableHasProp(t1,k1,k1v1));
  assertFalse(checkTableHasProp(t1,k1,k1v2));
  assertFalse(checkNamespaceHasProp(namespace,k2,k2v1));
  assertFalse(checkNamespaceHasProp(namespace2,k2,k2v1));
  assertFalse(checkTableHasProp(t1,k2,k2v1));
  assertFalse(checkTableHasProp(t1,k2,k2v2));
  c.namespaceOperations().setProperty(namespace,k1,k1v1);
  c.namespaceOperations().setProperty(namespace2,k1,k1v2);
  c.namespaceOperations().setProperty(namespace,k2,k2v1);
  c.namespaceOperations().setProperty(namespace2,k2,k2v1);
  c.tableOperations().setProperty(t1,k2,k2v2);
  assertTrue(checkNamespaceHasProp(namespace,k1,k1v1));
  assertTrue(checkNamespaceHasProp(namespace2,k1,k1v2));
  assertTrue(checkTableHasProp(t1,k1,k1v1));
  assertFalse(checkTableHasProp(t1,k1,k1v2));
  assertTrue(checkNamespaceHasProp(namespace,k2,k2v1));
  assertTrue(checkNamespaceHasProp(namespace2,k2,k2v1));
  assertFalse(checkTableHasProp(t1,k2,k2v1));
  assertTrue(checkTableHasProp(t1,k2,k2v2));
  for (  String t : Arrays.asList(t2,t3))   c.tableOperations().clone(t1,t,false,null,null);
  assertTrue(c.namespaceOperations().exists(namespace2));
  assertTrue(c.tableOperations().exists(t1));
  assertTrue(c.tableOperations().exists(t2));
  assertTrue(c.tableOperations().exists(t3));
  assertTrue(checkTableHasProp(t1,k1,k1v1));
  assertTrue(checkTableHasProp(t2,k1,k1v1));
  assertTrue(checkTableHasProp(t3,k1,k1v2));
  assertTrue(checkTableHasProp(t1,k2,k2v2));
  assertTrue(checkTableHasProp(t2,k2,k2v2));
  assertTrue(checkTableHasProp(t3,k2,k2v2));
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.accumulo.test.SampleIT </h4><pre class="type-8 type-2 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testIterator() throws Exception {
  Connector conn=getConnector();
  String tableName=getUniqueNames(1)[0];
  String clone=tableName + "_clone";
  conn.tableOperations().create(tableName,new NewTableConfiguration().enableSampling(SC1));
  BatchWriter bw=conn.createBatchWriter(tableName,new BatchWriterConfig());
  TreeMap<Key,Value> expected=new TreeMap<Key,Value>();
  writeData(bw,SC1,expected);
  ArrayList<Key> keys=new ArrayList<>(expected.keySet());
  Range range1=new Range(keys.get(6),true,keys.get(11),true);
  Scanner scanner=conn.createScanner(tableName,Authorizations.EMPTY);
  Scanner isoScanner=new IsolatedScanner(conn.createScanner(tableName,Authorizations.EMPTY));
  ClientSideIteratorScanner csiScanner=new ClientSideIteratorScanner(conn.createScanner(tableName,Authorizations.EMPTY));
  BatchScanner bScanner=conn.createBatchScanner(tableName,Authorizations.EMPTY,2);
  csiScanner.setIteratorSamplerConfiguration(SC1);
  List<? extends ScannerBase> scanners=Arrays.asList(scanner,isoScanner,bScanner,csiScanner);
  for (  ScannerBase s : scanners) {
    s.addScanIterator(new IteratorSetting(100,IteratorThatUsesSample.class));
  }
  setRange(range1,scanners);
  for (  ScannerBase s : scanners) {
    Assert.assertEquals(2954,countEntries(s));
  }
  Range range2=new Range(keys.get(5),true,keys.get(18),true);
  setRange(range2,scanners);
  for (  ScannerBase s : scanners) {
    Assert.assertEquals(0,countEntries(s));
  }
  conn.tableOperations().flush(tableName,null,null,true);
  Scanner oScanner=newOfflineScanner(conn,tableName,clone,null);
  oScanner.addScanIterator(new IteratorSetting(100,IteratorThatUsesSample.class));
  scanners=Arrays.asList(scanner,isoScanner,bScanner,csiScanner,oScanner);
  setRange(range1,scanners);
  for (  ScannerBase s : scanners) {
    Assert.assertEquals(2954,countEntries(s));
  }
  setRange(range2,scanners);
  for (  ScannerBase s : scanners) {
    Assert.assertEquals(0,countEntries(s));
  }
  updateSamplingConfig(conn,tableName,SC2);
  csiScanner.setIteratorSamplerConfiguration(SC2);
  oScanner=newOfflineScanner(conn,tableName,clone,null);
  oScanner.addScanIterator(new IteratorSetting(100,IteratorThatUsesSample.class));
  scanners=Arrays.asList(scanner,isoScanner,bScanner,csiScanner,oScanner);
  for (  ScannerBase s : scanners) {
    try {
      countEntries(s);
      Assert.fail("Expected SampleNotPresentException, but it did not happen : " + s.getClass().getSimpleName());
    }
 catch (    SampleNotPresentException e) {
    }
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.accumulo.test.ShellConfigIT </h4><pre class="type-11 type-8 type-5 type-3 type-7 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void experimentalPropTest() throws Exception {
  AuthenticationToken token=getAdminToken();
  File clientConfFile=null;
switch (getClusterType()) {
case MINI:
    MiniAccumuloClusterImpl mac=(MiniAccumuloClusterImpl)getCluster();
  clientConfFile=mac.getConfig().getClientConfFile();
break;
case STANDALONE:
StandaloneAccumuloClusterConfiguration standaloneConf=(StandaloneAccumuloClusterConfiguration)getClusterConfiguration();
clientConfFile=standaloneConf.getClientConfFile();
break;
default :
Assert.fail("Unknown cluster type");
}
Assert.assertNotNull(clientConfFile);
TestShell ts=null;
if (token instanceof PasswordToken) {
String passwd=new String(((PasswordToken)token).getPassword(),UTF_8);
ts=new TestShell(getAdminPrincipal(),passwd,getCluster().getInstanceName(),getCluster().getZooKeepers(),clientConfFile);
}
 else if (token instanceof KerberosToken) {
ts=new TestShell(getAdminPrincipal(),null,getCluster().getInstanceName(),getCluster().getZooKeepers(),clientConfFile);
}
 else {
Assert.fail("Unknown token type");
}
assertTrue(Property.TABLE_VOLUME_CHOOSER.isExperimental());
assertTrue(Property.CRYPTO_CIPHER_ALGORITHM_NAME.isExperimental());
String configOutput=ts.exec("config");
assertTrue(configOutput.contains(Property.TABLE_VOLUME_CHOOSER.getKey()));
assertFalse(configOutput.contains(Property.CRYPTO_CIPHER_ALGORITHM_NAME.getKey()));
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.accumulo.test.ShellServerIT </h4><pre class="type-9 type-8 type-5 type-2 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void scansWithClassLoaderContext() throws Exception {
  try {
    Class.forName("org.apache.accumulo.test.functional.ValueReversingIterator");
    fail("ValueReversingIterator already on the classpath");
  }
 catch (  Exception e) {
    assertTrue(true);
  }
  ts.exec("createtable t");
  make10();
  setupFakeContextPath();
  ts.exec("config -s " + Property.VFS_CONTEXT_CLASSPATH_PROPERTY + FAKE_CONTEXT+ "="+ FAKE_CONTEXT_CLASSPATH);
  ts.exec("config -t t -s table.classpath.context=" + FAKE_CONTEXT);
  ts.exec("setscaniter -n reverse -t t -p 21 -class org.apache.accumulo.test.functional.ValueReversingIterator");
  String result=ts.exec("scan -np -b row1 -e row1");
  assertEquals(2,result.split("\n").length);
  log.error(result);
  assertTrue(result.contains("value"));
  result=ts.exec("scan -np -b row3 -e row5");
  assertEquals(4,result.split("\n").length);
  assertTrue(result.contains("value"));
  result=ts.exec("scan -np -r row3");
  assertEquals(2,result.split("\n").length);
  assertTrue(result.contains("value"));
  result=ts.exec("scan -np -b row:");
  assertEquals(1,result.split("\n").length);
  result=ts.exec("scan -np -b row");
  assertEquals(11,result.split("\n").length);
  assertTrue(result.contains("value"));
  result=ts.exec("scan -np -e row:");
  assertEquals(11,result.split("\n").length);
  assertTrue(result.contains("value"));
  setupRealContextPath();
  ts.exec("config -s " + Property.VFS_CONTEXT_CLASSPATH_PROPERTY + REAL_CONTEXT+ "="+ REAL_CONTEXT_CLASSPATH);
  result=ts.exec("scan -np -b row1 -e row1 -cc " + REAL_CONTEXT);
  log.error(result);
  assertEquals(2,result.split("\n").length);
  assertTrue(result.contains("eulav"));
  assertFalse(result.contains("value"));
  result=ts.exec("scan -np -b row3 -e row5 -cc " + REAL_CONTEXT);
  assertEquals(4,result.split("\n").length);
  assertTrue(result.contains("eulav"));
  assertFalse(result.contains("value"));
  result=ts.exec("scan -np -r row3 -cc " + REAL_CONTEXT);
  assertEquals(2,result.split("\n").length);
  assertTrue(result.contains("eulav"));
  assertFalse(result.contains("value"));
  result=ts.exec("scan -np -b row: -cc " + REAL_CONTEXT);
  assertEquals(1,result.split("\n").length);
  result=ts.exec("scan -np -b row -cc " + REAL_CONTEXT);
  assertEquals(11,result.split("\n").length);
  assertTrue(result.contains("eulav"));
  assertFalse(result.contains("value"));
  result=ts.exec("scan -np -e row: -cc " + REAL_CONTEXT);
  assertEquals(11,result.split("\n").length);
  assertTrue(result.contains("eulav"));
  assertFalse(result.contains("value"));
  ts.exec("deletetable -f t");
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.accumulo.test.TableConfigurationUpdateIT </h4><pre class="type-9 type-11 type-8 type-5 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void test() throws Exception {
  Connector conn=getConnector();
  Instance inst=conn.getInstance();
  String table=getUniqueNames(1)[0];
  conn.tableOperations().create(table);
  final NamespaceConfiguration defaultConf=new NamespaceConfiguration(Namespaces.DEFAULT_NAMESPACE_ID,inst,AccumuloConfiguration.getDefaultConfiguration());
  int randomMax=4;
  int numThreads=2;
  int iterations=100000;
  AccumuloConfiguration tableConf=new TableConfiguration(inst,table,defaultConf);
  long start=System.currentTimeMillis();
  ExecutorService svc=Executors.newFixedThreadPool(numThreads);
  CountDownLatch countDown=new CountDownLatch(numThreads);
  ArrayList<Future<Exception>> futures=new ArrayList<Future<Exception>>(numThreads);
  for (int i=0; i < numThreads; i++) {
    futures.add(svc.submit(new TableConfRunner(randomMax,iterations,tableConf,countDown)));
  }
  svc.shutdown();
  Assert.assertTrue(svc.awaitTermination(60,TimeUnit.MINUTES));
  for (  Future<Exception> fut : futures) {
    Exception e=fut.get();
    if (null != e) {
      Assert.fail("Thread failed with exception " + e);
    }
  }
  long end=System.currentTimeMillis();
  log.debug(tableConf + " with " + iterations+ " iterations and "+ numThreads+ " threads and cache invalidates "+ ((1. / randomMax) * 100.)+ "% took "+ (end - start) / 1000 + " second(s)");
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.accumulo.test.TableOperationsIT </h4><pre class="type-9 type-8 type-3 type-2 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void getDiskUsageErrors() throws TableExistsException, AccumuloException, AccumuloSecurityException, TableNotFoundException, TException {
  String tableName=getUniqueNames(1)[0];
  connector.tableOperations().create(tableName);
  List<DiskUsage> diskUsage=connector.tableOperations().getDiskUsage(Collections.singleton(tableName));
  assertEquals(1,diskUsage.size());
  assertEquals(0,(long)diskUsage.get(0).getUsage());
  assertEquals(tableName,diskUsage.get(0).getTables().iterator().next());
  connector.securityOperations().revokeTablePermission(getAdminPrincipal(),tableName,TablePermission.READ);
  try {
    connector.tableOperations().getDiskUsage(Collections.singleton(tableName));
    fail("Should throw securityexception");
  }
 catch (  AccumuloSecurityException e) {
  }
  connector.tableOperations().delete(tableName);
  try {
    connector.tableOperations().getDiskUsage(Collections.singleton(tableName));
    fail("Should throw tablenotfound");
  }
 catch (  TableNotFoundException e) {
  }
}

</code></pre>

<br>
<pre class="type-11 type-8 type-5 type-2 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testCompactEmptyTableWithGeneratorIterator_Splits_Cancel() throws TableExistsException, AccumuloException, AccumuloSecurityException, TableNotFoundException {
  String tableName=getUniqueNames(1)[0];
  connector.tableOperations().create(tableName);
  SortedSet<Text> splitset=new TreeSet<>();
  splitset.add(new Text("f"));
  connector.tableOperations().addSplits(tableName,splitset);
  List<IteratorSetting> list=new ArrayList<>();
  list.add(new IteratorSetting(15,HardListIterator.class));
  connector.tableOperations().compact(tableName,null,null,list,true,false);
  connector.tableOperations().cancelCompaction(tableName);
  Scanner scanner=connector.createScanner(tableName,Authorizations.EMPTY);
  Map<Key,Value> actual=new TreeMap<>(COMPARE_KEY_TO_COLQ);
  for (  Map.Entry<Key,Value> entry : scanner)   actual.put(entry.getKey(),entry.getValue());
switch (actual.size()) {
case 3:
    assertTrue(HardListIterator.allEntriesToInject.equals(actual));
  break;
case 2:
assertEquals(HardListIterator.allEntriesToInject.headMap(new Key("f")),actual);
break;
case 1:
assertEquals(HardListIterator.allEntriesToInject.tailMap(new Key("f")),actual);
break;
case 0:
break;
default :
Assert.fail("Unexpected number of entries");
break;
}
connector.tableOperations().delete(tableName);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.accumulo.test.TraceRepoDeserializationTest </h4><pre class="type-8 type-10 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies that exceptions are thrown during the test case execution">ExceptionVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies that exceptions are thrown during the test case execution
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(expected=InvalidClassException.class) public void test() throws Exception {
  byte bytes[]=Base64.decodeBase64(oldValue);
  ByteArrayInputStream bais=new ByteArrayInputStream(bytes);
  ObjectInputStream ois=new ObjectInputStream(bais);
  ois.readObject();
  fail("did not throw exception");
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.accumulo.test.UserCompactionStrategyIT </h4><pre class="type-11 type-8 type-3 type-2 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testConcurrent() throws Exception {
  Connector c=getConnector();
  String tableName=getUniqueNames(1)[0];
  c.tableOperations().create(tableName);
  writeRandomValue(c,tableName,1 << 16);
  writeRandomValue(c,tableName,1 << 16);
  c.tableOperations().compact(tableName,new CompactionConfig().setWait(false));
  c.tableOperations().compact(tableName,new CompactionConfig().setWait(true));
  Assert.assertEquals(1,FunctionalTestUtils.countRFiles(c,tableName));
  writeRandomValue(c,tableName,1 << 16);
  IteratorSetting iterConfig=new IteratorSetting(30,SlowIterator.class);
  SlowIterator.setSleepTime(iterConfig,1000);
  long t1=System.currentTimeMillis();
  c.tableOperations().compact(tableName,new CompactionConfig().setWait(false).setIterators(Arrays.asList(iterConfig)));
  try {
    c.tableOperations().compact(tableName,new CompactionConfig().setWait(true));
    if (System.currentTimeMillis() - t1 < 2000)     Assert.fail("Expected compaction to fail because another concurrent compaction set iterators");
  }
 catch (  AccumuloException e) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.accumulo.test.UsersIT </h4><pre class="type-8 type-5 type-3 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testCreateExistingUser() throws Exception {
  ClusterUser user0=getUser(0);
  Connector conn=getConnector();
  Set<String> currentUsers=conn.securityOperations().listLocalUsers();
  if (!currentUsers.contains(user0.getPrincipal())) {
    PasswordToken token=null;
    if (!getCluster().getClientConfig().getBoolean(ClientProperty.INSTANCE_RPC_SASL_ENABLED.getKey(),false)) {
      token=new PasswordToken(user0.getPassword());
    }
    conn.securityOperations().createLocalUser(user0.getPrincipal(),token);
  }
  try {
    conn.securityOperations().createLocalUser(user0.getPrincipal(),new PasswordToken("better_fail"));
    fail("Creating a user that already exists should throw an exception");
  }
 catch (  AccumuloSecurityException e) {
    assertTrue("Expected USER_EXISTS error",SecurityErrorCode.USER_EXISTS == e.getSecurityErrorCode());
    String msg=e.getMessage();
    assertTrue("Error message didn't contain principal: '" + msg + "'",msg.contains(user0.getPrincipal()));
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.accumulo.test.functional.BulkSplitOptimizationIT </h4><pre class="type-11 type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testBulkSplitOptimization() throws Exception {
  final Connector c=getConnector();
  final String tableName=getUniqueNames(1)[0];
  c.tableOperations().create(tableName);
  c.tableOperations().setProperty(tableName,Property.TABLE_MAJC_RATIO.getKey(),"1000");
  c.tableOperations().setProperty(tableName,Property.TABLE_FILE_MAX.getKey(),"1000");
  c.tableOperations().setProperty(tableName,Property.TABLE_SPLIT_THRESHOLD.getKey(),"1G");
  FileSystem fs=cluster.getFileSystem();
  Path testDir=new Path(getUsableDir(),"testmf");
  FunctionalTestUtils.createRFiles(c,fs,testDir.toString(),ROWS,SPLITS,8);
  FileStatus[] stats=fs.listStatus(testDir);
  System.out.println("Number of generated files: " + stats.length);
  FunctionalTestUtils.bulkImport(c,fs,tableName,testDir.toString());
  FunctionalTestUtils.checkSplits(c,tableName,0,0);
  FunctionalTestUtils.checkRFiles(c,tableName,1,1,100,100);
  getConnector().tableOperations().setProperty(tableName,Property.TABLE_SPLIT_THRESHOLD.getKey(),"100K");
  sleepUninterruptibly(2,TimeUnit.SECONDS);
  while (getConnector().tableOperations().listSplits(tableName).size() < 75) {
    sleepUninterruptibly(500,TimeUnit.MILLISECONDS);
  }
  FunctionalTestUtils.checkSplits(c,tableName,50,100);
  VerifyIngest.Opts opts=new VerifyIngest.Opts();
  opts.timestamp=1;
  opts.dataSize=50;
  opts.random=56;
  opts.rows=100000;
  opts.startRow=0;
  opts.cols=1;
  opts.setTableName(tableName);
  AuthenticationToken adminToken=getAdminToken();
  if (adminToken instanceof PasswordToken) {
    PasswordToken token=(PasswordToken)getAdminToken();
    opts.setPassword(new Password(new String(token.getPassword(),UTF_8)));
    opts.setPrincipal(getAdminPrincipal());
  }
 else   if (adminToken instanceof KerberosToken) {
    ClientConfiguration clientConf=cluster.getClientConfig();
    opts.updateKerberosCredentials(clientConf);
  }
 else {
    Assert.fail("Unknown token type");
  }
  VerifyIngest.verifyIngest(c,opts,new ScannerOpts());
  FunctionalTestUtils.checkRFiles(c,tableName,50,100,1,4);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.accumulo.test.functional.CleanUpIT </h4><pre class="type-11 type-8 type-2 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void run() throws Exception {
  String tableName=getUniqueNames(1)[0];
  getConnector().tableOperations().create(tableName);
  BatchWriter bw=getConnector().createBatchWriter(tableName,new BatchWriterConfig());
  Mutation m1=new Mutation("r1");
  m1.put("cf1","cq1",1,"5");
  bw.addMutation(m1);
  bw.flush();
  Scanner scanner=getConnector().createScanner(tableName,new Authorizations());
  int count=0;
  for (  Entry<Key,Value> entry : scanner) {
    count++;
    if (!entry.getValue().toString().equals("5")) {
      Assert.fail("Unexpected value " + entry.getValue());
    }
  }
  Assert.assertEquals("Unexpected count",1,count);
  int threadCount=countThreads();
  if (threadCount < 2) {
    printThreadNames();
    Assert.fail("Not seeing expected threads. Saw " + threadCount);
  }
  CleanUp.shutdownNow();
  Mutation m2=new Mutation("r2");
  m2.put("cf1","cq1",1,"6");
  try {
    bw.addMutation(m1);
    bw.flush();
    Assert.fail("batch writer did not fail");
  }
 catch (  Exception e) {
  }
  try {
    bw.close();
    Assert.fail("batch writer close not fail");
  }
 catch (  Exception e) {
  }
  try {
    count=0;
    Iterator<Entry<Key,Value>> iter=scanner.iterator();
    while (iter.hasNext()) {
      iter.next();
      count++;
    }
    Assert.fail("scanner did not fail");
  }
 catch (  Exception e) {
  }
  threadCount=countThreads();
  if (threadCount > 0) {
    printThreadNames();
    Assert.fail("Threads did not go away. Saw " + threadCount);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.accumulo.test.functional.CredentialsIT </h4><pre class="type-8 type-5 type-3 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testConnectorWithDestroyedToken() throws Exception {
  AuthenticationToken token=getUser(0).getToken();
  assertFalse(token.isDestroyed());
  token.destroy();
  assertTrue(token.isDestroyed());
  try {
    inst.getConnector("non_existent_user",token);
    fail();
  }
 catch (  AccumuloSecurityException e) {
    assertTrue(e.getSecurityErrorCode().equals(SecurityErrorCode.TOKEN_EXPIRED));
  }
}

</code></pre>

<br>
<pre class="type-13 type-8 type-5 type-3 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testDestroyTokenBeforeRPC() throws Exception {
  AuthenticationToken token=getUser(0).getToken();
  Connector userConnector=inst.getConnector(username,token);
  Scanner scanner=userConnector.createScanner(MetadataTable.NAME,Authorizations.EMPTY);
  assertFalse(token.isDestroyed());
  token.destroy();
  assertTrue(token.isDestroyed());
  try {
    Iterator<Entry<Key,Value>> iter=scanner.iterator();
    while (iter.hasNext())     fail();
    fail();
  }
 catch (  Exception e) {
    assertTrue(e instanceof RuntimeException);
    assertTrue(e.getCause() instanceof AccumuloSecurityException);
    assertTrue(AccumuloSecurityException.class.cast(e.getCause()).getSecurityErrorCode().equals(SecurityErrorCode.TOKEN_EXPIRED));
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.accumulo.test.functional.DynamicThreadPoolsIT </h4><pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void test() throws Exception {
  final String[] tables=getUniqueNames(15);
  String firstTable=tables[0];
  Connector c=getConnector();
  c.instanceOperations().setProperty(Property.TSERV_MAJC_MAXCONCURRENT.getKey(),"5");
  TestIngest.Opts opts=new TestIngest.Opts();
  opts.rows=500 * 1000;
  opts.createTable=true;
  opts.setTableName(firstTable);
  ClientConfiguration clientConf=cluster.getClientConfig();
  if (clientConf.getBoolean(ClientProperty.INSTANCE_RPC_SASL_ENABLED.getKey(),false)) {
    opts.updateKerberosCredentials(clientConf);
  }
 else {
    opts.setPrincipal(getAdminPrincipal());
  }
  TestIngest.ingest(c,opts,new BatchWriterOpts());
  c.tableOperations().flush(firstTable,null,null,true);
  for (int i=1; i < tables.length; i++)   c.tableOperations().clone(firstTable,tables[i],true,null,null);
  sleepUninterruptibly(11,TimeUnit.SECONDS);
  Credentials creds=new Credentials(getAdminPrincipal(),getAdminToken());
  for (int i=1; i < tables.length; i++)   c.tableOperations().compact(tables[i],null,null,true,false);
  for (int i=0; i < 30; i++) {
    int count=0;
    MasterClientService.Iface client=null;
    MasterMonitorInfo stats=null;
    try {
      client=MasterClient.getConnectionWithRetry(new ClientContext(c.getInstance(),creds,clientConf));
      stats=client.getMasterStats(Tracer.traceInfo(),creds.toThrift(c.getInstance()));
    }
  finally {
      if (client != null)       MasterClient.close(client);
    }
    for (    TabletServerStatus server : stats.tServerInfo) {
      for (      TableInfo table : server.tableMap.values()) {
        count+=table.majors.running;
      }
    }
    System.out.println("count " + count);
    if (count > 3)     return;
    sleepUninterruptibly(500,TimeUnit.MILLISECONDS);
  }
  fail("Could not observe higher number of threads after changing the config");
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.accumulo.test.functional.ExamplesIT </h4><pre class="type-4 type-11 type-8 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Allocates resources before the execution of the test cases">TestInitializer</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Allocates resources before the execution of the test cases
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Before public void getClusterInfo() throws Exception {
  c=getConnector();
  user=getAdminPrincipal();
  AuthenticationToken token=getAdminToken();
  if (token instanceof KerberosToken) {
    keytab=getAdminUser().getKeytab().getAbsolutePath();
    saslEnabled=true;
  }
 else   if (token instanceof PasswordToken) {
    passwd=new String(((PasswordToken)getAdminToken()).getPassword(),UTF_8);
    saslEnabled=false;
  }
 else {
    Assert.fail("Unknown token type: " + token);
  }
  fs=getCluster().getFileSystem();
  instance=c.getInstance().getInstanceName();
  keepers=c.getInstance().getZooKeepers();
  dir=new Path(cluster.getTemporaryPath(),getClass().getName()).toString();
  origAuths=c.securityOperations().getUserAuthorizations(user);
  c.securityOperations().changeUserAuthorizations(user,new Authorizations(auths.split(",")));
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.accumulo.test.functional.GarbageCollectorIT </h4><pre class="type-9 type-13 type-11 type-8 type-5 type-3 type-2 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions in iterations
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testProperPortAdvertisement() throws Exception {
  Connector conn=getConnector();
  Instance instance=conn.getInstance();
  ZooReaderWriter zk=new ZooReaderWriter(cluster.getZooKeepers(),30000,OUR_SECRET);
  String path=ZooUtil.getRoot(instance) + Constants.ZGC_LOCK;
  for (int i=0; i < 5; i++) {
    List<String> locks;
    try {
      locks=zk.getChildren(path,null);
    }
 catch (    NoNodeException e) {
      Thread.sleep(5000);
      continue;
    }
    if (locks != null && locks.size() > 0) {
      Collections.sort(locks);
      String lockPath=path + "/" + locks.get(0);
      String gcLoc=new String(zk.getData(lockPath,null));
      Assert.assertTrue("Found unexpected data in zookeeper for GC location: " + gcLoc,gcLoc.startsWith(Service.GC_CLIENT.name()));
      int loc=gcLoc.indexOf(ServerServices.SEPARATOR_CHAR);
      Assert.assertNotEquals("Could not find split point of GC location for: " + gcLoc,-1,loc);
      String addr=gcLoc.substring(loc + 1);
      int addrSplit=addr.indexOf(':');
      Assert.assertNotEquals("Could not find split of GC host:port for: " + addr,-1,addrSplit);
      String host=addr.substring(0,addrSplit), port=addr.substring(addrSplit + 1);
      Assert.assertNotEquals("0.0.0.0",host);
      Assert.assertNotEquals(0,Integer.parseInt(port));
      return;
    }
    Thread.sleep(5000);
  }
  Assert.fail("Could not find advertised GC address");
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.accumulo.test.functional.KerberosIT </h4><pre class="type-9 type-8 type-5 type-3 type-7 type-2 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testDelegationTokenAsDifferentUser() throws Exception {
  UserGroupInformation ugi=UserGroupInformation.loginUserFromKeytabAndReturnUGI(rootUser.getPrincipal(),rootUser.getKeytab().getAbsolutePath());
  log.info("Logged in as {}",rootUser.getPrincipal());
  final AuthenticationToken delegationToken;
  try {
    delegationToken=ugi.doAs(new PrivilegedExceptionAction<AuthenticationToken>(){
      @Override public AuthenticationToken run() throws Exception {
        Connector conn=mac.getConnector(rootUser.getPrincipal(),new KerberosToken());
        log.info("Created connector as {}",rootUser.getPrincipal());
        assertEquals(rootUser.getPrincipal(),conn.whoami());
        return conn.securityOperations().getDelegationToken(new DelegationTokenConfig());
      }
    }
);
  }
 catch (  UndeclaredThrowableException ex) {
    throw ex;
  }
  UserGroupInformation userWithoutPrivs=UserGroupInformation.createUserForTesting("fake_user",new String[0]);
  try {
    userWithoutPrivs.doAs(new PrivilegedExceptionAction<Void>(){
      @Override public Void run() throws Exception {
        mac.getConnector("some_other_user",delegationToken);
        return null;
      }
    }
);
    fail("Using a delegation token as a different user should throw an exception");
  }
 catch (  UndeclaredThrowableException e) {
    Throwable cause=e.getCause();
    assertNotNull(cause);
    assertTrue("Expected cause to be AccumuloSecurityException, but was " + cause.getClass(),cause instanceof AccumuloSecurityException);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.accumulo.test.functional.ScannerContextIT </h4><pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testScanContextOverridesTableContext() throws Exception {
  Path baseDir=new Path(System.getProperty("user.dir"));
  Path targetDir=new Path(baseDir,"target");
  Path jarPath=new Path(targetDir,"TestIterators-tests.jar");
  Path dstPath=new Path(CONTEXT_DIR + "/Test.jar");
  fs.copyFromLocalFile(jarPath,dstPath);
  UtilWaitThread.sleep(WAIT);
  try {
    Connector c=getConnector();
    String tableContext="FOO";
    String tableContextProperty=Property.VFS_CONTEXT_CLASSPATH_PROPERTY + tableContext;
    String tableContextDir="file:///tmp";
    String tableContextClasspath=tableContextDir + "/TestFoo.jar";
    c.instanceOperations().setProperty(tableContextProperty,tableContextClasspath);
    c.instanceOperations().setProperty(CONTEXT_PROPERTY,CONTEXT_CLASSPATH);
    String tableName=getUniqueNames(1)[0];
    c.tableOperations().create(tableName);
    c.tableOperations().setProperty(tableName,Property.TABLE_CLASSPATH.getKey(),tableContext);
    BatchWriter bw=c.createBatchWriter(tableName,new BatchWriterConfig());
    for (int i=0; i < ITERATIONS; i++) {
      Mutation m=new Mutation("row" + i);
      m.put("cf","col1","Test");
      bw.addMutation(m);
    }
    bw.close();
    scanCheck(c,tableName,null,null,"Test");
    batchCheck(c,tableName,null,null,"Test");
    IteratorSetting cfg=new IteratorSetting(21,"reverse","org.apache.accumulo.test.functional.ValueReversingIterator");
    try {
      scanCheck(c,tableName,cfg,null,"tseT");
      fail("This should have failed because context was not set");
    }
 catch (    Exception e) {
    }
    try {
      batchCheck(c,tableName,cfg,null,"tseT");
      fail("This should have failed because context was not set");
    }
 catch (    Exception e) {
    }
    scanCheck(c,tableName,cfg,CONTEXT,"tseT");
    batchCheck(c,tableName,cfg,CONTEXT,"tseT");
  }
  finally {
    fs.delete(dstPath,true);
  }
}

</code></pre>

<br>
<pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void test() throws Exception {
  Path baseDir=new Path(System.getProperty("user.dir"));
  Path targetDir=new Path(baseDir,"target");
  Path jarPath=new Path(targetDir,"TestIterators-tests.jar");
  Path dstPath=new Path(CONTEXT_DIR + "/Test.jar");
  fs.copyFromLocalFile(jarPath,dstPath);
  UtilWaitThread.sleep(WAIT);
  try {
    Connector c=getConnector();
    c.instanceOperations().setProperty(CONTEXT_PROPERTY,CONTEXT_CLASSPATH);
    String tableName=getUniqueNames(1)[0];
    c.tableOperations().create(tableName);
    BatchWriter bw=c.createBatchWriter(tableName,new BatchWriterConfig());
    for (int i=0; i < ITERATIONS; i++) {
      Mutation m=new Mutation("row" + i);
      m.put("cf","col1","Test");
      bw.addMutation(m);
    }
    bw.close();
    scanCheck(c,tableName,null,null,"Test");
    batchCheck(c,tableName,null,null,"Test");
    IteratorSetting cfg=new IteratorSetting(21,"reverse","org.apache.accumulo.test.functional.ValueReversingIterator");
    try {
      scanCheck(c,tableName,cfg,null,"tseT");
      fail("This should have failed because context was not set");
    }
 catch (    Exception e) {
    }
    try {
      batchCheck(c,tableName,cfg,null,"tseT");
      fail("This should have failed because context was not set");
    }
 catch (    Exception e) {
    }
    scanCheck(c,tableName,cfg,CONTEXT,"tseT");
    batchCheck(c,tableName,cfg,CONTEXT,"tseT");
  }
  finally {
    fs.delete(dstPath,true);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.accumulo.test.mapred.AccumuloOutputFormatIT </h4><pre class="type-8 type-5 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testMapred() throws Exception {
  Connector connector=getConnector();
  connector.tableOperations().create(testName.getMethodName());
  JobConf job=new JobConf();
  BatchWriterConfig batchConfig=new BatchWriterConfig();
  batchConfig.setMaxLatency(0,TimeUnit.MILLISECONDS);
  batchConfig.setMaxWriteThreads(1);
  batchConfig.setMaxMemory(Long.MAX_VALUE);
  AccumuloOutputFormat outputFormat=new AccumuloOutputFormat();
  AccumuloOutputFormat.setBatchWriterOptions(job,batchConfig);
  AccumuloOutputFormat.setZooKeeperInstance(job,cluster.getClientConfig());
  AccumuloOutputFormat.setConnectorInfo(job,"root",new PasswordToken(ROOT_PASSWORD));
  RecordWriter<Text,Mutation> writer=outputFormat.getRecordWriter(null,job,"Test",null);
  try {
    for (int i=0; i < 3; i++) {
      Mutation m=new Mutation(new Text(String.format("%08d",i)));
      for (int j=0; j < 3; j++) {
        m.put(new Text("cf1"),new Text("cq" + j),new Value((i + "_" + j).getBytes(UTF_8)));
      }
      writer.write(new Text(testName.getMethodName()),m);
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  connector.securityOperations().revokeTablePermission("root",testName.getMethodName(),TablePermission.WRITE);
  try {
    writer.close(null);
    fail("Did not throw exception");
  }
 catch (  IOException ex) {
    log.info(ex.getMessage(),ex);
    assertTrue(ex.getCause() instanceof MutationsRejectedException);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.accumulo.test.mapreduce.AccumuloInputFormatIT </h4><pre class="type-9 type-8 type-3 type-2 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Tests several different paths through the getSplits() method by setting different properties and verifying the results.
 */
@Test public void testGetSplits() throws Exception {
  Connector conn=getConnector();
  String table=getUniqueNames(1)[0];
  conn.tableOperations().create(table);
  insertData(table,currentTimeMillis());
  ClientConfiguration clientConf=cluster.getClientConfig();
  AccumuloConfiguration clusterClientConf=new ConfigurationCopy(new DefaultConfiguration());
  boolean sslEnabled=Boolean.valueOf(clusterClientConf.get(Property.INSTANCE_RPC_SSL_ENABLED));
  if (sslEnabled) {
    ClientProperty[] sslProperties=new ClientProperty[]{ClientProperty.INSTANCE_RPC_SSL_ENABLED,ClientProperty.INSTANCE_RPC_SSL_CLIENT_AUTH,ClientProperty.RPC_SSL_KEYSTORE_PATH,ClientProperty.RPC_SSL_KEYSTORE_TYPE,ClientProperty.RPC_SSL_KEYSTORE_PASSWORD,ClientProperty.RPC_SSL_TRUSTSTORE_PATH,ClientProperty.RPC_SSL_TRUSTSTORE_TYPE,ClientProperty.RPC_SSL_TRUSTSTORE_PASSWORD,ClientProperty.RPC_USE_JSSE,ClientProperty.GENERAL_SECURITY_CREDENTIAL_PROVIDER_PATHS};
    for (    ClientProperty prop : sslProperties) {
      clientConf.setProperty(prop,clusterClientConf.get(prop.getKey()));
    }
  }
  Job job=Job.getInstance();
  AccumuloInputFormat.setInputTableName(job,table);
  AccumuloInputFormat.setZooKeeperInstance(job,clientConf);
  AccumuloInputFormat.setConnectorInfo(job,getAdminPrincipal(),getAdminToken());
  TreeSet<Text> splitsToAdd=new TreeSet<Text>();
  for (int i=0; i < 10000; i+=1000)   splitsToAdd.add(new Text(String.format("%09d",i)));
  conn.tableOperations().addSplits(table,splitsToAdd);
  sleepUninterruptibly(500,TimeUnit.MILLISECONDS);
  Collection<Text> actualSplits=conn.tableOperations().listSplits(table);
  List<InputSplit> splits=inputFormat.getSplits(job);
  assertEquals(actualSplits.size() + 1,splits.size());
  List<Range> ranges=new ArrayList<Range>();
  for (  Text text : actualSplits)   ranges.add(new Range(text));
  AccumuloInputFormat.setRanges(job,ranges);
  splits=inputFormat.getSplits(job);
  assertEquals(actualSplits.size(),splits.size());
  AccumuloInputFormat.setOfflineTableScan(job,true);
  try {
    inputFormat.getSplits(job);
    fail("An exception should have been thrown");
  }
 catch (  IOException e) {
  }
  conn.tableOperations().offline(table,true);
  splits=inputFormat.getSplits(job);
  assertEquals(actualSplits.size(),splits.size());
  ranges=new ArrayList<Range>();
  for (int i=0; i < 5; i++)   ranges.add(new Range(String.format("%09d",i),String.format("%09d",i + 2)));
  AccumuloInputFormat.setRanges(job,ranges);
  splits=inputFormat.getSplits(job);
  assertEquals(2,splits.size());
  AccumuloInputFormat.setAutoAdjustRanges(job,false);
  splits=inputFormat.getSplits(job);
  assertEquals(ranges.size(),splits.size());
  AccumuloInputFormat.setBatchScan(job,true);
  AccumuloInputFormat.setAutoAdjustRanges(job,true);
  AccumuloInputFormat.setOfflineTableScan(job,true);
  try {
    inputFormat.getSplits(job);
    fail("An exception should have been thrown");
  }
 catch (  IllegalArgumentException e) {
  }
  conn.tableOperations().online(table,true);
  AccumuloInputFormat.setOfflineTableScan(job,false);
  splits=inputFormat.getSplits(job);
  assertEquals(2,splits.size());
  AccumuloInputFormat.setScanIsolation(job,true);
  try {
    inputFormat.getSplits(job);
    fail("An exception should have been thrown");
  }
 catch (  IllegalArgumentException e) {
  }
  AccumuloInputFormat.setScanIsolation(job,false);
  splits=inputFormat.getSplits(job);
  assertEquals(2,splits.size());
  AccumuloInputFormat.setLocalIterators(job,true);
  try {
    inputFormat.getSplits(job);
    fail("An exception should have been thrown");
  }
 catch (  IllegalArgumentException e) {
  }
  AccumuloInputFormat.setLocalIterators(job,false);
  conn.tableOperations().online(table);
  splits=inputFormat.getSplits(job);
  for (  InputSplit split : splits)   assert (split instanceof BatchInputSplit);
  assertEquals(2,splits.size());
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.accumulo.test.proxy.SimpleProxyBase </h4><pre class="type-9 type-13 type-8 type-3 type-2 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions in iterations
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testConditionalWriter() throws Exception {
  log.debug("Adding constraint {} to {}",table,NumericValueConstraint.class.getName());
  client.addConstraint(creds,table,NumericValueConstraint.class.getName());
  sleepUninterruptibly(ZOOKEEPER_PROPAGATION_TIME,TimeUnit.MILLISECONDS);
  while (!client.listConstraints(creds,table).containsKey(NumericValueConstraint.class.getName())) {
    log.info("Failed to see constraint");
    Thread.sleep(1000);
  }
  String cwid=client.createConditionalWriter(creds,table,new ConditionalWriterOptions());
  Map<ByteBuffer,ConditionalUpdates> updates=new HashMap<ByteBuffer,ConditionalUpdates>();
  updates.put(s2bb("00345"),new ConditionalUpdates(Arrays.asList(newCondition("meta","seq")),Arrays.asList(newColUpdate("meta","seq",10,"1"),newColUpdate("data","img","73435435"))));
  Map<ByteBuffer,ConditionalStatus> results=client.updateRowsConditionally(cwid,updates);
  assertEquals(1,results.size());
  assertEquals(ConditionalStatus.ACCEPTED,results.get(s2bb("00345")));
  assertScan(new String[][]{{"00345","data","img","73435435"},{"00345","meta","seq","1"}},table);
  updates.clear();
  updates.put(s2bb("00345"),new ConditionalUpdates(Arrays.asList(newCondition("meta","seq")),Arrays.asList(newColUpdate("meta","seq","2"))));
  updates.put(s2bb("00346"),new ConditionalUpdates(Arrays.asList(newCondition("meta","seq")),Arrays.asList(newColUpdate("meta","seq","1"))));
  results=client.updateRowsConditionally(cwid,updates);
  assertEquals(2,results.size());
  assertEquals(ConditionalStatus.REJECTED,results.get(s2bb("00345")));
  assertEquals(ConditionalStatus.ACCEPTED,results.get(s2bb("00346")));
  assertScan(new String[][]{{"00345","data","img","73435435"},{"00345","meta","seq","1"},{"00346","meta","seq","1"}},table);
  updates.clear();
  updates.put(s2bb("00345"),new ConditionalUpdates(Arrays.asList(newCondition("meta","seq","1")),Arrays.asList(newColUpdate("meta","seq",20,"2"),newColUpdate("data","img","567890"))));
  updates.put(s2bb("00346"),new ConditionalUpdates(Arrays.asList(newCondition("meta","seq","2")),Arrays.asList(newColUpdate("meta","seq","3"))));
  results=client.updateRowsConditionally(cwid,updates);
  assertEquals(2,results.size());
  assertEquals(ConditionalStatus.ACCEPTED,results.get(s2bb("00345")));
  assertEquals(ConditionalStatus.REJECTED,results.get(s2bb("00346")));
  assertScan(new String[][]{{"00345","data","img","567890"},{"00345","meta","seq","2"},{"00346","meta","seq","1"}},table);
  updates.clear();
  updates.put(s2bb("00345"),new ConditionalUpdates(Arrays.asList(newCondition("meta","seq",10,"2")),Arrays.asList(newColUpdate("meta","seq",30,"3"),newColUpdate("data","img","1234567890"))));
  results=client.updateRowsConditionally(cwid,updates);
  assertEquals(1,results.size());
  assertEquals(ConditionalStatus.REJECTED,results.get(s2bb("00345")));
  assertScan(new String[][]{{"00345","data","img","567890"},{"00345","meta","seq","2"},{"00346","meta","seq","1"}},table);
  updates.clear();
  updates.put(s2bb("00345"),new ConditionalUpdates(Arrays.asList(newCondition("meta","seq",20,"2")),Arrays.asList(newColUpdate("meta","seq",30,"3"),newColUpdate("data","img","1234567890"))));
  results=client.updateRowsConditionally(cwid,updates);
  assertEquals(1,results.size());
  assertEquals(ConditionalStatus.ACCEPTED,results.get(s2bb("00345")));
  assertScan(new String[][]{{"00345","data","img","1234567890"},{"00345","meta","seq","3"},{"00346","meta","seq","1"}},table);
  client.updateAndFlush(creds,table,Collections.singletonMap(s2bb("00347"),Arrays.asList(newColUpdate("data","count","1"))));
  client.updateAndFlush(creds,table,Collections.singletonMap(s2bb("00347"),Arrays.asList(newColUpdate("data","count","1"))));
  client.updateAndFlush(creds,table,Collections.singletonMap(s2bb("00347"),Arrays.asList(newColUpdate("data","count","1"))));
  updates.clear();
  updates.put(s2bb("00347"),new ConditionalUpdates(Arrays.asList(newCondition("data","count","3")),Arrays.asList(newColUpdate("data","img","1234567890"))));
  results=client.updateRowsConditionally(cwid,updates);
  assertEquals(1,results.size());
  assertEquals(ConditionalStatus.REJECTED,results.get(s2bb("00347")));
  assertScan(new String[][]{{"00345","data","img","1234567890"},{"00345","meta","seq","3"},{"00346","meta","seq","1"},{"00347","data","count","1"}},table);
  Condition iterCond=newCondition("data","count","3");
  Map<String,String> props=new HashMap<String,String>();
  props.put("type","STRING");
  props.put("columns","data:count");
  IteratorSetting is=new IteratorSetting(1,"sumc",SummingCombiner.class.getName(),props);
  iterCond.setIterators(Arrays.asList(is));
  updates.clear();
  updates.put(s2bb("00347"),new ConditionalUpdates(Arrays.asList(iterCond),Arrays.asList(newColUpdate("data","img","1234567890"))));
  results=client.updateRowsConditionally(cwid,updates);
  assertEquals(1,results.size());
  assertEquals(ConditionalStatus.ACCEPTED,results.get(s2bb("00347")));
  assertScan(new String[][]{{"00345","data","img","1234567890"},{"00345","meta","seq","3"},{"00346","meta","seq","1"},{"00347","data","count","1"},{"00347","data","img","1234567890"}},table);
  ConditionalStatus status=null;
  for (int i=0; i < 30; i++) {
    updates.clear();
    updates.put(s2bb("00347"),new ConditionalUpdates(Arrays.asList(newCondition("data","img","1234567890")),Arrays.asList(newColUpdate("data","count","A"))));
    results=client.updateRowsConditionally(cwid,updates);
    assertEquals(1,results.size());
    status=results.get(s2bb("00347"));
    if (ConditionalStatus.VIOLATED != status) {
      log.info("ConditionalUpdate was not rejected by server due to table constraint. Sleeping and retrying");
      Thread.sleep(5000);
      continue;
    }
    assertEquals(ConditionalStatus.VIOLATED,status);
    break;
  }
  assertEquals(ConditionalStatus.VIOLATED,status);
  assertScan(new String[][]{{"00345","data","img","1234567890"},{"00345","meta","seq","3"},{"00346","meta","seq","1"},{"00347","data","count","1"},{"00347","data","img","1234567890"}},table);
  updates.clear();
  updates.put(s2bb("00347"),new ConditionalUpdates(Arrays.asList(newCondition("data","img","565"),newCondition("data","count","2")),Arrays.asList(newColUpdate("data","count","3"),newColUpdate("data","img","0987654321"))));
  results=client.updateRowsConditionally(cwid,updates);
  assertEquals(1,results.size());
  assertEquals(ConditionalStatus.REJECTED,results.get(s2bb("00347")));
  assertScan(new String[][]{{"00345","data","img","1234567890"},{"00345","meta","seq","3"},{"00346","meta","seq","1"},{"00347","data","count","1"},{"00347","data","img","1234567890"}},table);
  updates.clear();
  updates.put(s2bb("00347"),new ConditionalUpdates(Arrays.asList(newCondition("data","img","1234567890"),newCondition("data","count","2")),Arrays.asList(newColUpdate("data","count","3"),newColUpdate("data","img","0987654321"))));
  results=client.updateRowsConditionally(cwid,updates);
  assertEquals(1,results.size());
  assertEquals(ConditionalStatus.REJECTED,results.get(s2bb("00347")));
  assertScan(new String[][]{{"00345","data","img","1234567890"},{"00345","meta","seq","3"},{"00346","meta","seq","1"},{"00347","data","count","1"},{"00347","data","img","1234567890"}},table);
  updates.clear();
  updates.put(s2bb("00347"),new ConditionalUpdates(Arrays.asList(newCondition("data","img","565"),newCondition("data","count","1")),Arrays.asList(newColUpdate("data","count","3"),newColUpdate("data","img","0987654321"))));
  results=client.updateRowsConditionally(cwid,updates);
  assertEquals(1,results.size());
  assertEquals(ConditionalStatus.REJECTED,results.get(s2bb("00347")));
  assertScan(new String[][]{{"00345","data","img","1234567890"},{"00345","meta","seq","3"},{"00346","meta","seq","1"},{"00347","data","count","1"},{"00347","data","img","1234567890"}},table);
  ConditionalStatus result=client.updateRowConditionally(creds,table,s2bb("00347"),new ConditionalUpdates(Arrays.asList(newCondition("data","img","1234567890"),newCondition("data","count","1")),Arrays.asList(newColUpdate("data","count","3"),newColUpdate("data","img","0987654321"))));
  assertEquals(ConditionalStatus.ACCEPTED,result);
  assertScan(new String[][]{{"00345","data","img","1234567890"},{"00345","meta","seq","3"},{"00346","meta","seq","1"},{"00347","data","count","3"},{"00347","data","img","0987654321"}},table);
  client.closeConditionalWriter(cwid);
  try {
    client.updateRowsConditionally(cwid,updates);
    fail("conditional writer not closed");
  }
 catch (  UnknownWriter uk) {
  }
  String principal;
  ClusterUser cwuser=null;
  if (isKerberosEnabled()) {
    cwuser=getKdc().getClientPrincipal(1);
    principal=cwuser.getPrincipal();
    client.createLocalUser(creds,principal,s2bb("unused"));
  }
 else {
    principal="cwuser";
    client.createLocalUser(creds,principal,s2bb("bestpasswordever"));
  }
  client.changeUserAuthorizations(creds,principal,Collections.singleton(s2bb("A")));
  client.grantTablePermission(creds,principal,table,TablePermission.WRITE);
  client.grantTablePermission(creds,principal,table,TablePermission.READ);
  TestProxyClient cwuserProxyClient=null;
  Client origClient=null;
  Map<String,String> cwProperties;
  if (isKerberosEnabled()) {
    UserGroupInformation.loginUserFromKeytab(cwuser.getPrincipal(),cwuser.getKeytab().getAbsolutePath());
    final UserGroupInformation cwuserUgi=UserGroupInformation.getCurrentUser();
    cwuserProxyClient=new TestProxyClient(hostname,proxyPort,factory,proxyPrimary,cwuserUgi);
    origClient=client;
    client=cwuserProxyClient.proxy();
    cwProperties=Collections.emptyMap();
  }
 else {
    cwProperties=Collections.singletonMap("password","bestpasswordever");
  }
  try {
    ByteBuffer cwCreds=client.login(principal,cwProperties);
    cwid=client.createConditionalWriter(cwCreds,table,new ConditionalWriterOptions().setAuthorizations(Collections.singleton(s2bb("A"))));
    updates.clear();
    updates.put(s2bb("00348"),new ConditionalUpdates(Arrays.asList(new Condition(new Column(s2bb("data"),s2bb("c"),s2bb("A")))),Arrays.asList(newColUpdate("data","seq","1"),newColUpdate("data","c","1").setColVisibility(s2bb("A")))));
    updates.put(s2bb("00349"),new ConditionalUpdates(Arrays.asList(new Condition(new Column(s2bb("data"),s2bb("c"),s2bb("B")))),Arrays.asList(newColUpdate("data","seq","1"))));
    results=client.updateRowsConditionally(cwid,updates);
    assertEquals(2,results.size());
    assertEquals(ConditionalStatus.ACCEPTED,results.get(s2bb("00348")));
    assertEquals(ConditionalStatus.INVISIBLE_VISIBILITY,results.get(s2bb("00349")));
    if (isKerberosEnabled()) {
      UserGroupInformation.loginUserFromKeytab(clientPrincipal,clientKeytab.getAbsolutePath());
      client=origClient;
    }
    assertScan(new String[][]{{"00345","data","img","1234567890"},{"00345","meta","seq","3"},{"00346","meta","seq","1"},{"00347","data","count","3"},{"00347","data","img","0987654321"},{"00348","data","seq","1"}},table);
    if (isKerberosEnabled()) {
      UserGroupInformation.loginUserFromKeytab(cwuser.getPrincipal(),cwuser.getKeytab().getAbsolutePath());
      client=cwuserProxyClient.proxy();
    }
    updates.clear();
    updates.clear();
    updates.put(s2bb("00348"),new ConditionalUpdates(Arrays.asList(new Condition(new Column(s2bb("data"),s2bb("c"),s2bb("A"))).setValue(s2bb("0"))),Arrays.asList(newColUpdate("data","seq","2"),newColUpdate("data","c","2").setColVisibility(s2bb("A")))));
    results=client.updateRowsConditionally(cwid,updates);
    assertEquals(1,results.size());
    assertEquals(ConditionalStatus.REJECTED,results.get(s2bb("00348")));
    if (isKerberosEnabled()) {
      UserGroupInformation.loginUserFromKeytab(clientPrincipal,clientKeytab.getAbsolutePath());
      client=origClient;
    }
    assertScan(new String[][]{{"00345","data","img","1234567890"},{"00345","meta","seq","3"},{"00346","meta","seq","1"},{"00347","data","count","3"},{"00347","data","img","0987654321"},{"00348","data","seq","1"}},table);
    if (isKerberosEnabled()) {
      UserGroupInformation.loginUserFromKeytab(cwuser.getPrincipal(),cwuser.getKeytab().getAbsolutePath());
      client=cwuserProxyClient.proxy();
    }
    updates.clear();
    updates.put(s2bb("00348"),new ConditionalUpdates(Arrays.asList(new Condition(new Column(s2bb("data"),s2bb("c"),s2bb("A"))).setValue(s2bb("1"))),Arrays.asList(newColUpdate("data","seq","2"),newColUpdate("data","c","2").setColVisibility(s2bb("A")))));
    results=client.updateRowsConditionally(cwid,updates);
    assertEquals(1,results.size());
    assertEquals(ConditionalStatus.ACCEPTED,results.get(s2bb("00348")));
    if (isKerberosEnabled()) {
      UserGroupInformation.loginUserFromKeytab(clientPrincipal,clientKeytab.getAbsolutePath());
      client=origClient;
    }
    assertScan(new String[][]{{"00345","data","img","1234567890"},{"00345","meta","seq","3"},{"00346","meta","seq","1"},{"00347","data","count","3"},{"00347","data","img","0987654321"},{"00348","data","seq","2"}},table);
    if (isKerberosEnabled()) {
      UserGroupInformation.loginUserFromKeytab(cwuser.getPrincipal(),cwuser.getKeytab().getAbsolutePath());
      client=cwuserProxyClient.proxy();
    }
    client.closeConditionalWriter(cwid);
    try {
      client.updateRowsConditionally(cwid,updates);
      fail("conditional writer not closed");
    }
 catch (    UnknownWriter uk) {
    }
  }
  finally {
    if (isKerberosEnabled()) {
      if (null != cwuserProxyClient) {
        cwuserProxyClient.close();
      }
      UserGroupInformation.loginUserFromKeytab(clientPrincipal,clientKeytab.getAbsolutePath());
      client=origClient;
    }
    client.dropLocalUser(creds,principal);
  }
}

</code></pre>

<br>
<pre class="type-11 type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testBatchWriter() throws Exception {
  client.addConstraint(creds,table,NumericValueConstraint.class.getName());
  sleepUninterruptibly(ZOOKEEPER_PROPAGATION_TIME,TimeUnit.MILLISECONDS);
  WriterOptions writerOptions=new WriterOptions();
  writerOptions.setLatencyMs(10000);
  writerOptions.setMaxMemory(2);
  writerOptions.setThreads(1);
  writerOptions.setTimeoutMs(100000);
  Map<String,Integer> constraints=client.listConstraints(creds,table);
  while (!constraints.containsKey(NumericValueConstraint.class.getName())) {
    log.info("Constraints don't contain NumericValueConstraint");
    Thread.sleep(2000);
    constraints=client.listConstraints(creds,table);
  }
  boolean success=false;
  for (int i=0; i < 15; i++) {
    String batchWriter=client.createWriter(creds,table,writerOptions);
    client.update(batchWriter,mutation("row1","cf","cq","x"));
    client.update(batchWriter,mutation("row1","cf","cq","x"));
    try {
      client.flush(batchWriter);
      log.debug("Constraint failed to fire. Waiting and retrying");
      Thread.sleep(5000);
      continue;
    }
 catch (    MutationsRejectedException ex) {
    }
    try {
      client.closeWriter(batchWriter);
      log.debug("Constraint failed to fire. Waiting and retrying");
      Thread.sleep(5000);
      continue;
    }
 catch (    MutationsRejectedException e) {
    }
    success=true;
    break;
  }
  if (!success) {
    fail("constraint did not fire");
  }
  client.removeConstraint(creds,table,2);
  constraints=client.listConstraints(creds,table);
  while (constraints.containsKey(NumericValueConstraint.class.getName())) {
    log.info("Constraints still contains NumericValueConstraint");
    Thread.sleep(2000);
    constraints=client.listConstraints(creds,table);
  }
  assertScan(new String[][]{},table);
  sleepUninterruptibly(ZOOKEEPER_PROPAGATION_TIME,TimeUnit.MILLISECONDS);
  writerOptions=new WriterOptions();
  writerOptions.setLatencyMs(10000);
  writerOptions.setMaxMemory(3000);
  writerOptions.setThreads(1);
  writerOptions.setTimeoutMs(100000);
  success=false;
  for (int i=0; i < 15; i++) {
    try {
      String batchWriter=client.createWriter(creds,table,writerOptions);
      client.update(batchWriter,mutation("row1","cf","cq","x"));
      client.flush(batchWriter);
      client.closeWriter(batchWriter);
      success=true;
      break;
    }
 catch (    MutationsRejectedException e) {
      log.info("Mutations were rejected, assuming constraint is still active",e);
      Thread.sleep(5000);
    }
  }
  if (!success) {
    fail("Failed to successfully write data after constraint was removed");
  }
  assertScan(new String[][]{{"row1","cf","cq","x"}},table);
  client.deleteTable(creds,table);
}

</code></pre>

<br>
<pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testUnknownWriter() throws Exception {
  String writer=client.createWriter(creds,table,null);
  client.update(writer,mutation("row0","cf","cq","value"));
  client.flush(writer);
  client.update(writer,mutation("row2","cf","cq","value2"));
  client.closeWriter(writer);
  client.update(writer,mutation("row2","cf","cq","value2"));
  try {
    client.flush(writer);
    fail("exception not thrown");
  }
 catch (  UnknownWriter uw) {
  }
  try {
    client.flush("99999");
    fail("exception not thrown");
  }
 catch (  UnknownWriter uw) {
  }
  try {
    client.flush(UUID.randomUUID().toString());
    fail("exception not thrown");
  }
 catch (  UnknownWriter uw) {
  }
  try {
    client.closeWriter("99999");
    fail("exception not thrown");
  }
 catch (  UnknownWriter uw) {
  }
}

</code></pre>

<br>
<pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void iteratorFunctionality() throws Exception {
  HashMap<String,String> options=new HashMap<String,String>();
  options.put("type","STRING");
  options.put("columns","cf");
  IteratorSetting setting=new IteratorSetting(10,table,SummingCombiner.class.getName(),options);
  client.attachIterator(creds,table,setting,EnumSet.allOf(IteratorScope.class));
  for (int i=0; i < 10; i++) {
    client.updateAndFlush(creds,table,mutation("row1","cf","cq","1"));
  }
  assertScan(new String[][]{{"row1","cf","cq","10"}},table);
  try {
    client.checkIteratorConflicts(creds,table,setting,EnumSet.allOf(IteratorScope.class));
    fail("checkIteratorConflicts did not throw an exception");
  }
 catch (  Exception ex) {
  }
  client.deleteRows(creds,table,null,null);
  client.removeIterator(creds,table,"test",EnumSet.allOf(IteratorScope.class));
  String expected[][]=new String[10][];
  for (int i=0; i < 10; i++) {
    client.updateAndFlush(creds,table,mutation("row" + i,"cf","cq","" + i));
    expected[i]=new String[]{"row" + i,"cf","cq","" + i};
    client.flushTable(creds,table,null,null,true);
  }
  assertScan(expected,table);
}

</code></pre>

<br>
<pre class="type-9 type-11 type-8 type-5 type-3 type-7 type-2 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void attachIteratorWithCompactions() throws Exception {
  if (client.tableExists(creds,"slow")) {
    client.deleteTable(creds,"slow");
  }
  client.createTable(creds,"slow",true,TimeType.MILLIS);
  IteratorSetting setting=new IteratorSetting(100,"slow",SlowIterator.class.getName(),Collections.singletonMap("sleepTime","250"));
  client.attachIterator(creds,"slow",setting,EnumSet.allOf(IteratorScope.class));
  for (int i=0; i < 40; i++) {
    client.updateAndFlush(creds,"slow",mutation("row" + i,"cf","cq","value"));
  }
  Map<String,String> map=client.tableIdMap(creds);
  Thread t=new Thread(){
    @Override public void run(){
      TestProxyClient proxyClient2=null;
      try {
        if (isKerberosEnabled()) {
          UserGroupInformation.loginUserFromKeytab(clientPrincipal,clientKeytab.getAbsolutePath());
          proxyClient2=new TestProxyClient(hostname,proxyPort,factory,proxyPrimary,UserGroupInformation.getCurrentUser());
        }
 else {
          proxyClient2=new TestProxyClient(hostname,proxyPort,factory);
        }
        Client client2=proxyClient2.proxy();
        client2.compactTable(creds,"slow",null,null,null,true,true,null);
      }
 catch (      Exception e) {
        throw new RuntimeException(e);
      }
 finally {
        if (null != proxyClient2) {
          proxyClient2.close();
        }
      }
    }
  }
;
  t.start();
  final String desiredTableId=map.get("slow");
  assertNotNull(desiredTableId);
  List<ActiveCompaction> compactions=new ArrayList<ActiveCompaction>();
  for (int i=0; i < 100 && compactions.isEmpty(); i++) {
    for (    String tserver : client.getTabletServers(creds)) {
      List<ActiveCompaction> compactionsOnServer=client.getActiveCompactions(creds,tserver);
      for (      ActiveCompaction compact : compactionsOnServer) {
        if (desiredTableId.equals(compact.getExtent().tableId)) {
          compactions.add(compact);
        }
      }
      if (!compactions.isEmpty())       break;
    }
    sleepUninterruptibly(10,TimeUnit.MILLISECONDS);
  }
  t.join();
  assertFalse(compactions.isEmpty());
  for (  ActiveCompaction c : compactions) {
    if (desiredTableId.equals(c.getExtent().tableId)) {
      assertTrue(c.inputFiles.isEmpty());
      assertEquals(CompactionType.MINOR,c.getType());
      assertEquals(CompactionReason.USER,c.getReason());
      assertEquals("",c.localityGroup);
      assertTrue(c.outputFile.contains("default_tablet"));
      return;
    }
  }
  fail("Expection to find running compaction for table 'slow' but did not find one");
}

</code></pre>

<br>
<pre class="type-8 type-5 type-3 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void tableNotFound() throws Exception {
  final String doesNotExist="doesNotExists";
  try {
    client.addConstraint(creds,doesNotExist,NumericValueConstraint.class.getName());
    fail("exception not thrown");
  }
 catch (  TableNotFoundException ex) {
  }
  try {
    client.addSplits(creds,doesNotExist,Collections.<ByteBuffer>emptySet());
    fail("exception not thrown");
  }
 catch (  TableNotFoundException ex) {
  }
  final IteratorSetting setting=new IteratorSetting(100,"slow",SlowIterator.class.getName(),Collections.singletonMap("sleepTime","200"));
  try {
    client.attachIterator(creds,doesNotExist,setting,EnumSet.allOf(IteratorScope.class));
    fail("exception not thrown");
  }
 catch (  TableNotFoundException ex) {
  }
  try {
    client.cancelCompaction(creds,doesNotExist);
    fail("exception not thrown");
  }
 catch (  TableNotFoundException ex) {
  }
  try {
    client.checkIteratorConflicts(creds,doesNotExist,setting,EnumSet.allOf(IteratorScope.class));
    fail("exception not thrown");
  }
 catch (  TableNotFoundException ex) {
  }
  try {
    client.clearLocatorCache(creds,doesNotExist);
    fail("exception not thrown");
  }
 catch (  TableNotFoundException ex) {
  }
  try {
    final String TABLE_TEST=getUniqueNames(1)[0];
    client.cloneTable(creds,doesNotExist,TABLE_TEST,false,null,null);
    fail("exception not thrown");
  }
 catch (  TableNotFoundException ex) {
  }
  try {
    client.compactTable(creds,doesNotExist,null,null,null,true,false,null);
    fail("exception not thrown");
  }
 catch (  TableNotFoundException ex) {
  }
  try {
    client.createBatchScanner(creds,doesNotExist,new BatchScanOptions());
    fail("exception not thrown");
  }
 catch (  TableNotFoundException ex) {
  }
  try {
    client.createScanner(creds,doesNotExist,new ScanOptions());
    fail("exception not thrown");
  }
 catch (  TableNotFoundException ex) {
  }
  try {
    client.createWriter(creds,doesNotExist,new WriterOptions());
    fail("exception not thrown");
  }
 catch (  TableNotFoundException ex) {
  }
  try {
    client.deleteRows(creds,doesNotExist,null,null);
    fail("exception not thrown");
  }
 catch (  TableNotFoundException ex) {
  }
  try {
    client.deleteTable(creds,doesNotExist);
    fail("exception not thrown");
  }
 catch (  TableNotFoundException ex) {
  }
  try {
    client.exportTable(creds,doesNotExist,"/tmp");
    fail("exception not thrown");
  }
 catch (  TableNotFoundException ex) {
  }
  try {
    client.flushTable(creds,doesNotExist,null,null,false);
    fail("exception not thrown");
  }
 catch (  TableNotFoundException ex) {
  }
  try {
    client.getIteratorSetting(creds,doesNotExist,"foo",IteratorScope.SCAN);
    fail("exception not thrown");
  }
 catch (  TableNotFoundException ex) {
  }
  try {
    client.getLocalityGroups(creds,doesNotExist);
    fail("exception not thrown");
  }
 catch (  TableNotFoundException ex) {
  }
  try {
    client.getMaxRow(creds,doesNotExist,Collections.<ByteBuffer>emptySet(),null,false,null,false);
    fail("exception not thrown");
  }
 catch (  TableNotFoundException ex) {
  }
  try {
    client.getTableProperties(creds,doesNotExist);
    fail("exception not thrown");
  }
 catch (  TableNotFoundException ex) {
  }
  try {
    client.grantTablePermission(creds,"root",doesNotExist,TablePermission.WRITE);
    fail("exception not thrown");
  }
 catch (  TableNotFoundException ex) {
  }
  try {
    client.hasTablePermission(creds,"root",doesNotExist,TablePermission.WRITE);
    fail("exception not thrown");
  }
 catch (  TableNotFoundException ex) {
  }
  try {
    MiniAccumuloClusterImpl cluster=SharedMiniClusterBase.getCluster();
    Path base=cluster.getTemporaryPath();
    Path importDir=new Path(base,"importDir");
    Path failuresDir=new Path(base,"failuresDir");
    assertTrue(cluster.getFileSystem().mkdirs(importDir));
    assertTrue(cluster.getFileSystem().mkdirs(failuresDir));
    client.importDirectory(creds,doesNotExist,importDir.toString(),failuresDir.toString(),true);
    fail("exception not thrown");
  }
 catch (  TableNotFoundException ex) {
  }
  try {
    client.listConstraints(creds,doesNotExist);
    fail("exception not thrown");
  }
 catch (  TableNotFoundException ex) {
  }
  try {
    client.listSplits(creds,doesNotExist,10000);
    fail("exception not thrown");
  }
 catch (  TableNotFoundException ex) {
  }
  try {
    client.mergeTablets(creds,doesNotExist,null,null);
    fail("exception not thrown");
  }
 catch (  TableNotFoundException ex) {
  }
  try {
    client.offlineTable(creds,doesNotExist,false);
    fail("exception not thrown");
  }
 catch (  TableNotFoundException ex) {
  }
  try {
    client.onlineTable(creds,doesNotExist,false);
    fail("exception not thrown");
  }
 catch (  TableNotFoundException ex) {
  }
  try {
    client.removeConstraint(creds,doesNotExist,0);
    fail("exception not thrown");
  }
 catch (  TableNotFoundException ex) {
  }
  try {
    client.removeIterator(creds,doesNotExist,"name",EnumSet.allOf(IteratorScope.class));
    fail("exception not thrown");
  }
 catch (  TableNotFoundException ex) {
  }
  try {
    client.removeTableProperty(creds,doesNotExist,Property.TABLE_FILE_MAX.getKey());
    fail("exception not thrown");
  }
 catch (  TableNotFoundException ex) {
  }
  try {
    client.renameTable(creds,doesNotExist,"someTableName");
    fail("exception not thrown");
  }
 catch (  TableNotFoundException ex) {
  }
  try {
    client.revokeTablePermission(creds,"root",doesNotExist,TablePermission.ALTER_TABLE);
    fail("exception not thrown");
  }
 catch (  TableNotFoundException ex) {
  }
  try {
    client.setTableProperty(creds,doesNotExist,Property.TABLE_FILE_MAX.getKey(),"0");
    fail("exception not thrown");
  }
 catch (  TableNotFoundException ex) {
  }
  try {
    client.splitRangeByTablets(creds,doesNotExist,client.getRowRange(ByteBuffer.wrap("row".getBytes(UTF_8))),10);
    fail("exception not thrown");
  }
 catch (  TableNotFoundException ex) {
  }
  try {
    client.updateAndFlush(creds,doesNotExist,new HashMap<ByteBuffer,List<ColumnUpdate>>());
    fail("exception not thrown");
  }
 catch (  TableNotFoundException ex) {
  }
  try {
    client.getDiskUsage(creds,Collections.singleton(doesNotExist));
    fail("exception not thrown");
  }
 catch (  TableNotFoundException ex) {
  }
  try {
    client.testTableClassLoad(creds,doesNotExist,VersioningIterator.class.getName(),SortedKeyValueIterator.class.getName());
    fail("exception not thrown");
  }
 catch (  TableNotFoundException ex) {
  }
  try {
    client.createConditionalWriter(creds,doesNotExist,new ConditionalWriterOptions());
  }
 catch (  TableNotFoundException ex) {
  }
}

</code></pre>

<br>
<pre class="type-8 type-5 type-3 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void importExportTable() throws Exception {
  String expected[][]=new String[10][];
  for (int i=0; i < 10; i++) {
    client.updateAndFlush(creds,table,mutation("row" + i,"cf","cq","" + i));
    expected[i]=new String[]{"row" + i,"cf","cq","" + i};
    client.flushTable(creds,table,null,null,true);
  }
  assertScan(expected,table);
  MiniAccumuloClusterImpl cluster=SharedMiniClusterBase.getCluster();
  FileSystem fs=cluster.getFileSystem();
  Path base=cluster.getTemporaryPath();
  Path dir=new Path(base,"test");
  assertTrue(fs.mkdirs(dir));
  Path destDir=new Path(base,"test_dest");
  assertTrue(fs.mkdirs(destDir));
  client.offlineTable(creds,table,false);
  client.exportTable(creds,table,dir.toString());
  FSDataInputStream is=fs.open(new Path(dir,"distcp.txt"));
  try (BufferedReader r=new BufferedReader(new InputStreamReader(is,UTF_8))){
    while (true) {
      String line=r.readLine();
      if (line == null)       break;
      Path srcPath=new Path(line);
      FileUtil.copy(fs,srcPath,fs,destDir,false,fs.getConf());
    }
  }
   client.deleteTable(creds,table);
  client.importTable(creds,"testify",destDir.toString());
  assertScan(expected,"testify");
  client.deleteTable(creds,"testify");
  try {
    client.importTable(creds,"testify2",destDir.toString());
    fail();
  }
 catch (  Exception e) {
  }
  assertFalse(client.listTables(creds).contains("testify2"));
}

</code></pre>

<br>
<pre class="type-8 type-5 type-3 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testUnknownScanner() throws Exception {
  String scanner=client.createScanner(creds,table,null);
  assertFalse(client.hasNext(scanner));
  client.closeScanner(scanner);
  try {
    client.hasNext(scanner);
    fail("exception not thrown");
  }
 catch (  UnknownScanner us) {
  }
  try {
    client.closeScanner(scanner);
    fail("exception not thrown");
  }
 catch (  UnknownScanner us) {
  }
  try {
    client.nextEntry("99999999");
    fail("exception not thrown");
  }
 catch (  UnknownScanner us) {
  }
  try {
    client.nextK("99999999",6);
    fail("exception not thrown");
  }
 catch (  UnknownScanner us) {
  }
  try {
    client.hasNext("99999999");
    fail("exception not thrown");
  }
 catch (  UnknownScanner us) {
  }
  try {
    client.hasNext(UUID.randomUUID().toString());
    fail("exception not thrown");
  }
 catch (  UnknownScanner us) {
  }
}

</code></pre>

<br>
<pre class="type-8 type-5 type-3 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void userPermissions() throws Exception {
  String userName=getUniqueNames(1)[0];
  ClusterUser otherClient=null;
  ByteBuffer password=s2bb("password");
  ByteBuffer user;
  TestProxyClient origProxyClient=null;
  Client origClient=null;
  TestProxyClient userProxyClient=null;
  Client userClient=null;
  if (isKerberosEnabled()) {
    otherClient=getKdc().getClientPrincipal(1);
    userName=otherClient.getPrincipal();
    UserGroupInformation.loginUserFromKeytab(otherClient.getPrincipal(),otherClient.getKeytab().getAbsolutePath());
    final UserGroupInformation ugi=UserGroupInformation.getCurrentUser();
    userProxyClient=new TestProxyClient(hostname,proxyPort,factory,proxyPrimary,ugi);
    origProxyClient=proxyClient;
    origClient=client;
    userClient=client=userProxyClient.proxy();
    user=client.login(userName,Collections.<String,String>emptyMap());
  }
 else {
    userName=getUniqueNames(1)[0];
    client.createLocalUser(creds,userName,password);
    user=client.login(userName,s2pp(ByteBufferUtil.toString(password)));
  }
  try {
    client.createTable(user,"fail",true,TimeType.MILLIS);
    fail("should not create the table");
  }
 catch (  AccumuloSecurityException ex) {
    if (isKerberosEnabled()) {
      UserGroupInformation.loginUserFromKeytab(clientPrincipal,clientKeytab.getAbsolutePath());
      client=origClient;
    }
    assertFalse(client.listTables(creds).contains("fail"));
  }
  assertFalse(client.hasSystemPermission(creds,userName,SystemPermission.CREATE_TABLE));
  client.grantSystemPermission(creds,userName,SystemPermission.CREATE_TABLE);
  assertTrue(client.hasSystemPermission(creds,userName,SystemPermission.CREATE_TABLE));
  if (isKerberosEnabled()) {
    UserGroupInformation.loginUserFromKeytab(otherClient.getPrincipal(),otherClient.getKeytab().getAbsolutePath());
    client=userClient;
  }
  client.createTable(user,"success",true,TimeType.MILLIS);
  if (isKerberosEnabled()) {
    UserGroupInformation.loginUserFromKeytab(clientPrincipal,clientKeytab.getAbsolutePath());
    client=origClient;
  }
  assertTrue(client.listTables(creds).contains("success"));
  client.revokeSystemPermission(creds,userName,SystemPermission.CREATE_TABLE);
  assertFalse(client.hasSystemPermission(creds,userName,SystemPermission.CREATE_TABLE));
  try {
    if (isKerberosEnabled()) {
      UserGroupInformation.loginUserFromKeytab(otherClient.getPrincipal(),otherClient.getKeytab().getAbsolutePath());
      client=userClient;
    }
    client.createTable(user,"fail",true,TimeType.MILLIS);
    fail("should not create the table");
  }
 catch (  AccumuloSecurityException ex) {
    if (isKerberosEnabled()) {
      UserGroupInformation.loginUserFromKeytab(clientPrincipal,clientKeytab.getAbsolutePath());
      client=origClient;
    }
    assertFalse(client.listTables(creds).contains("fail"));
  }
  try {
    if (isKerberosEnabled()) {
      UserGroupInformation.loginUserFromKeytab(otherClient.getPrincipal(),otherClient.getKeytab().getAbsolutePath());
      client=userClient;
    }
    String scanner=client.createScanner(user,table,null);
    client.nextK(scanner,100);
    fail("stooge should not read table test");
  }
 catch (  AccumuloSecurityException ex) {
  }
  if (isKerberosEnabled()) {
    UserGroupInformation.loginUserFromKeytab(clientPrincipal,clientKeytab.getAbsolutePath());
    client=origClient;
  }
  assertFalse(client.hasTablePermission(creds,userName,table,TablePermission.READ));
  client.grantTablePermission(creds,userName,table,TablePermission.READ);
  assertTrue(client.hasTablePermission(creds,userName,table,TablePermission.READ));
  if (isKerberosEnabled()) {
    UserGroupInformation.loginUserFromKeytab(otherClient.getPrincipal(),otherClient.getKeytab().getAbsolutePath());
    client=userClient;
  }
  String scanner=client.createScanner(user,table,null);
  client.nextK(scanner,10);
  client.closeScanner(scanner);
  if (isKerberosEnabled()) {
    UserGroupInformation.loginUserFromKeytab(clientPrincipal,clientKeytab.getAbsolutePath());
    client=origClient;
  }
  client.revokeTablePermission(creds,userName,table,TablePermission.READ);
  assertFalse(client.hasTablePermission(creds,userName,table,TablePermission.READ));
  try {
    if (isKerberosEnabled()) {
      UserGroupInformation.loginUserFromKeytab(otherClient.getPrincipal(),otherClient.getKeytab().getAbsolutePath());
      client=userClient;
    }
    scanner=client.createScanner(user,table,null);
    client.nextK(scanner,100);
    fail("stooge should not read table test");
  }
 catch (  AccumuloSecurityException ex) {
  }
  if (isKerberosEnabled()) {
    UserGroupInformation.loginUserFromKeytab(clientPrincipal,clientKeytab.getAbsolutePath());
    client=origClient;
  }
  client.dropLocalUser(creds,userName);
  Set<String> users=client.listLocalUsers(creds);
  assertFalse("Should not see user after they are deleted",users.contains(userName));
  if (isKerberosEnabled()) {
    userProxyClient.close();
    proxyClient=origProxyClient;
    client=origClient;
  }
}

</code></pre>

<br>
<pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testExists() throws Exception {
  client.createTable(creds,"ett1",false,TimeType.MILLIS);
  client.createTable(creds,"ett2",false,TimeType.MILLIS);
  try {
    client.createTable(creds,"ett1",false,TimeType.MILLIS);
    fail("exception not thrown");
  }
 catch (  TableExistsException tee) {
  }
  try {
    client.renameTable(creds,"ett1","ett2");
    fail("exception not thrown");
  }
 catch (  TableExistsException tee) {
  }
  try {
    client.cloneTable(creds,"ett1","ett2",false,new HashMap<String,String>(),new HashSet<String>());
    fail("exception not thrown");
  }
 catch (  TableExistsException tee) {
  }
}

</code></pre>

<br>
<pre class="type-11 type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test(timeout=5000) public void authenticateUserLoginFailure() throws Exception {
  if (!isKerberosEnabled()) {
    try {
      client.authenticateUser(badLogin,"root",s2pp(SharedMiniClusterBase.getRootPassword()));
      fail("Expected AccumuloSecurityException");
    }
 catch (    AccumuloSecurityException e) {
      return;
    }
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.accumulo.test.replication.MultiInstanceReplicationIT </h4><pre class="type-9 type-13 type-8 type-5 type-3 type-7 type-2 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions in iterations
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(timeout=10 * 60 * 1000) public void dataWasReplicatedToThePeer() throws Exception {
  MiniAccumuloConfigImpl peerCfg=new MiniAccumuloConfigImpl(createTestDir(this.getClass().getName() + "_" + this.testName.getMethodName()+ "_peer"),ROOT_PASSWORD);
  peerCfg.setNumTservers(1);
  peerCfg.setInstanceName("peer");
  peerCfg.setProperty(Property.REPLICATION_NAME,"peer");
  updatePeerConfigFromPrimary(getCluster().getConfig(),peerCfg);
  MiniAccumuloClusterImpl peerCluster=new MiniAccumuloClusterImpl(peerCfg);
  peerCluster.start();
  try {
    final Connector connMaster=getConnector();
    final Connector connPeer=peerCluster.getConnector("root",new PasswordToken(ROOT_PASSWORD));
    ReplicationTable.setOnline(connMaster);
    String peerUserName="peer", peerPassword="foo";
    String peerClusterName="peer";
    connPeer.securityOperations().createLocalUser(peerUserName,new PasswordToken(peerPassword));
    connMaster.instanceOperations().setProperty(Property.REPLICATION_PEER_USER.getKey() + peerClusterName,peerUserName);
    connMaster.instanceOperations().setProperty(Property.REPLICATION_PEER_PASSWORD.getKey() + peerClusterName,peerPassword);
    connMaster.instanceOperations().setProperty(Property.REPLICATION_PEERS.getKey() + peerClusterName,ReplicaSystemFactory.getPeerConfigurationValue(AccumuloReplicaSystem.class,AccumuloReplicaSystem.buildConfiguration(peerCluster.getInstanceName(),peerCluster.getZooKeepers())));
    final String masterTable="master", peerTable="peer";
    connMaster.tableOperations().create(masterTable);
    String masterTableId=connMaster.tableOperations().tableIdMap().get(masterTable);
    Assert.assertNotNull(masterTableId);
    connPeer.tableOperations().create(peerTable);
    String peerTableId=connPeer.tableOperations().tableIdMap().get(peerTable);
    Assert.assertNotNull(peerTableId);
    connPeer.securityOperations().grantTablePermission(peerUserName,peerTable,TablePermission.WRITE);
    connMaster.tableOperations().setProperty(masterTable,Property.TABLE_REPLICATION.getKey(),"true");
    connMaster.tableOperations().setProperty(masterTable,Property.TABLE_REPLICATION_TARGET.getKey() + peerClusterName,peerTableId);
    BatchWriter bw=connMaster.createBatchWriter(masterTable,new BatchWriterConfig());
    for (int rows=0; rows < 5000; rows++) {
      Mutation m=new Mutation(Integer.toString(rows));
      for (int cols=0; cols < 100; cols++) {
        String value=Integer.toString(cols);
        m.put(value,"",value);
      }
      bw.addMutation(m);
    }
    bw.close();
    log.info("Wrote all data to master cluster");
    final Set<String> filesNeedingReplication=connMaster.replicationOperations().referencedFiles(masterTable);
    log.info("Files to replicate: " + filesNeedingReplication);
    for (    ProcessReference proc : cluster.getProcesses().get(ServerType.TABLET_SERVER)) {
      cluster.killProcess(ServerType.TABLET_SERVER,proc);
    }
    cluster.exec(TabletServer.class);
    log.info("TabletServer restarted");
    Iterators.size(ReplicationTable.getScanner(connMaster).iterator());
    log.info("TabletServer is online");
    while (!ReplicationTable.isOnline(connMaster)) {
      log.info("Replication table still offline, waiting");
      Thread.sleep(5000);
    }
    log.info("");
    log.info("Fetching metadata records:");
    for (    Entry<Key,Value> kv : connMaster.createScanner(MetadataTable.NAME,Authorizations.EMPTY)) {
      if (ReplicationSection.COLF.equals(kv.getKey().getColumnFamily())) {
        log.info(kv.getKey().toStringNoTruncate() + " " + ProtobufUtil.toString(Status.parseFrom(kv.getValue().get())));
      }
 else {
        log.info(kv.getKey().toStringNoTruncate() + " " + kv.getValue());
      }
    }
    log.info("");
    log.info("Fetching replication records:");
    for (    Entry<Key,Value> kv : ReplicationTable.getScanner(connMaster)) {
      log.info(kv.getKey().toStringNoTruncate() + " " + ProtobufUtil.toString(Status.parseFrom(kv.getValue().get())));
    }
    Future<Boolean> future=executor.submit(new Callable<Boolean>(){
      @Override public Boolean call() throws Exception {
        long then=System.currentTimeMillis();
        connMaster.replicationOperations().drain(masterTable,filesNeedingReplication);
        long now=System.currentTimeMillis();
        log.info("Drain completed in " + (now - then) + "ms");
        return true;
      }
    }
);
    try {
      future.get(60,TimeUnit.SECONDS);
    }
 catch (    TimeoutException e) {
      future.cancel(true);
      Assert.fail("Drain did not finish within 60 seconds");
    }
 finally {
      executor.shutdownNow();
    }
    log.info("drain completed");
    log.info("");
    log.info("Fetching metadata records:");
    for (    Entry<Key,Value> kv : connMaster.createScanner(MetadataTable.NAME,Authorizations.EMPTY)) {
      if (ReplicationSection.COLF.equals(kv.getKey().getColumnFamily())) {
        log.info(kv.getKey().toStringNoTruncate() + " " + ProtobufUtil.toString(Status.parseFrom(kv.getValue().get())));
      }
 else {
        log.info(kv.getKey().toStringNoTruncate() + " " + kv.getValue());
      }
    }
    log.info("");
    log.info("Fetching replication records:");
    for (    Entry<Key,Value> kv : ReplicationTable.getScanner(connMaster)) {
      log.info(kv.getKey().toStringNoTruncate() + " " + ProtobufUtil.toString(Status.parseFrom(kv.getValue().get())));
    }
    Scanner master=connMaster.createScanner(masterTable,Authorizations.EMPTY), peer=connPeer.createScanner(peerTable,Authorizations.EMPTY);
    Iterator<Entry<Key,Value>> masterIter=master.iterator(), peerIter=peer.iterator();
    Entry<Key,Value> masterEntry=null, peerEntry=null;
    while (masterIter.hasNext() && peerIter.hasNext()) {
      masterEntry=masterIter.next();
      peerEntry=peerIter.next();
      Assert.assertEquals(masterEntry.getKey() + " was not equal to " + peerEntry.getKey(),0,masterEntry.getKey().compareTo(peerEntry.getKey(),PartialKey.ROW_COLFAM_COLQUAL_COLVIS));
      Assert.assertEquals(masterEntry.getValue(),peerEntry.getValue());
    }
    log.info("Last master entry: " + masterEntry);
    log.info("Last peer entry: " + peerEntry);
    Assert.assertFalse("Had more data to read from the master",masterIter.hasNext());
    Assert.assertFalse("Had more data to read from the peer",peerIter.hasNext());
  }
  finally {
    peerCluster.stop();
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.accumulo.test.replication.MultiTserverReplicationIT </h4><pre class="type-8 type-3 type-2 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void tserverReplicationServicePortsAreAdvertised() throws Exception {
  Connector conn=getConnector();
  Instance inst=conn.getInstance();
  conn.tableOperations().create("foo");
  Scanner s=conn.createScanner("foo",Authorizations.EMPTY);
  Assert.assertEquals(0,Iterables.size(s));
  ZooReader zreader=new ZooReader(inst.getZooKeepers(),inst.getZooKeepersSessionTimeOut());
  Set<String> tserverHost=new HashSet<>();
  tserverHost.addAll(zreader.getChildren(ZooUtil.getRoot(inst) + Constants.ZTSERVERS));
  Set<HostAndPort> replicationServices=new HashSet<>();
  for (  String tserver : tserverHost) {
    try {
      byte[] portData=zreader.getData(ZooUtil.getRoot(inst) + ReplicationConstants.ZOO_TSERVERS + "/"+ tserver,null);
      HostAndPort replAddress=HostAndPort.fromString(new String(portData,UTF_8));
      replicationServices.add(replAddress);
    }
 catch (    Exception e) {
      log.error("Could not find port for {}",tserver,e);
      Assert.fail("Did not find replication port advertisement for " + tserver);
    }
  }
  Assert.assertEquals("Expected an equal number of replication servicers and tservers",tserverHost.size(),replicationServices.size());
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.accumulo.test.replication.ReplicationIT </h4><pre class="type-9 type-13 type-8 type-5 type-3 type-2 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions in iterations
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void correctRecordsCompleteFile() throws Exception {
  Connector conn=getConnector();
  String table="table1";
  conn.tableOperations().create(table);
  conn.tableOperations().setProperty(table,Property.TABLE_REPLICATION.getKey(),"true");
  BatchWriter bw=conn.createBatchWriter(table,new BatchWriterConfig());
  for (int i=0; i < 10; i++) {
    Mutation m=new Mutation(Integer.toString(i));
    m.put(new byte[0],new byte[0],new byte[0]);
    bw.addMutation(m);
  }
  bw.close();
  boolean online=ReplicationTable.isOnline(conn);
  int attempts=10;
  do {
    if (!online) {
      sleepUninterruptibly(2,TimeUnit.SECONDS);
      online=ReplicationTable.isOnline(conn);
      attempts--;
    }
  }
 while (!online && attempts > 0);
  Assert.assertTrue("Replication table was not online",online);
  for (int i=0; i < 5; i++) {
    if (conn.securityOperations().hasTablePermission("root",ReplicationTable.NAME,TablePermission.READ)) {
      break;
    }
    log.info("Could not read replication table, waiting and will retry");
    Thread.sleep(2000);
  }
  Assert.assertTrue("'root' user could not read the replication table",conn.securityOperations().hasTablePermission("root",ReplicationTable.NAME,TablePermission.READ));
  Set<String> replRows=new HashSet<>();
  Scanner scanner;
  attempts=5;
  while (replRows.isEmpty() && attempts > 0) {
    scanner=ReplicationTable.getScanner(conn);
    StatusSection.limit(scanner);
    for (    Entry<Key,Value> entry : scanner) {
      Key k=entry.getKey();
      String fileUri=k.getRow().toString();
      try {
        new URI(fileUri);
      }
 catch (      URISyntaxException e) {
        Assert.fail("Expected a valid URI: " + fileUri);
      }
      replRows.add(fileUri);
    }
  }
  Set<String> wals=new HashSet<>();
  attempts=5;
  Instance i=conn.getInstance();
  ZooReaderWriter zk=new ZooReaderWriter(i.getZooKeepers(),i.getZooKeepersSessionTimeOut(),"");
  while (wals.isEmpty() && attempts > 0) {
    WalStateManager markers=new WalStateManager(i,zk);
    for (    Entry<Path,WalState> entry : markers.getAllState().entrySet()) {
      wals.add(entry.getKey().toString());
    }
    attempts--;
  }
  Assert.assertEquals("Rows found: " + replRows,1,replRows.size());
  replRows.removeAll(wals);
  Assert.assertEquals(2,wals.size());
  Assert.assertEquals(0,replRows.size());
}

</code></pre>

<br>
<pre class="type-9 type-8 type-3 type-7 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void filesClosedAfterUnused() throws Exception {
  Connector conn=getConnector();
  String table="table";
  conn.tableOperations().create(table);
  String tableId=conn.tableOperations().tableIdMap().get(table);
  Assert.assertNotNull(tableId);
  conn.tableOperations().setProperty(table,Property.TABLE_REPLICATION.getKey(),"true");
  conn.tableOperations().setProperty(table,Property.TABLE_REPLICATION_TARGET.getKey() + "cluster1","1");
  conn.instanceOperations().setProperty(Property.REPLICATION_PEERS.getKey() + "cluster1",ReplicaSystemFactory.getPeerConfigurationValue(MockReplicaSystem.class,"50000"));
  BatchWriter bw=conn.createBatchWriter(table,new BatchWriterConfig());
  Mutation m=new Mutation("one");
  m.put("","","");
  bw.addMutation(m);
  bw.close();
  bw=conn.createBatchWriter(table,new BatchWriterConfig());
  m=new Mutation("three");
  m.put("","","");
  bw.addMutation(m);
  bw.close();
  Scanner s=conn.createScanner(MetadataTable.NAME,Authorizations.EMPTY);
  s.fetchColumnFamily(TabletsSection.LogColumnFamily.NAME);
  s.setRange(TabletsSection.getRange(tableId));
  Set<String> wals=new HashSet<>();
  for (  Entry<Key,Value> entry : s) {
    LogEntry logEntry=LogEntry.fromKeyValue(entry.getKey(),entry.getValue());
    wals.add(new Path(logEntry.filename).toString());
  }
  log.warn("Found wals {}",wals);
  bw=conn.createBatchWriter(table,new BatchWriterConfig());
  m=new Mutation("three");
  byte[] bytes=new byte[1024 * 1024];
  m.put("1".getBytes(),new byte[0],bytes);
  m.put("2".getBytes(),new byte[0],bytes);
  m.put("3".getBytes(),new byte[0],bytes);
  m.put("4".getBytes(),new byte[0],bytes);
  m.put("5".getBytes(),new byte[0],bytes);
  bw.addMutation(m);
  bw.close();
  conn.tableOperations().flush(table,null,null,true);
  while (!ReplicationTable.isOnline(conn)) {
    sleepUninterruptibly(2,TimeUnit.SECONDS);
  }
  for (int i=0; i < 10; i++) {
    s=conn.createScanner(MetadataTable.NAME,Authorizations.EMPTY);
    s.fetchColumnFamily(LogColumnFamily.NAME);
    s.setRange(TabletsSection.getRange(tableId));
    for (    Entry<Key,Value> entry : s) {
      log.info(entry.getKey().toStringNoTruncate() + "=" + entry.getValue());
    }
    try {
      s=ReplicationTable.getScanner(conn);
      StatusSection.limit(s);
      Text buff=new Text();
      boolean allReferencedLogsClosed=true;
      int recordsFound=0;
      for (      Entry<Key,Value> e : s) {
        recordsFound++;
        allReferencedLogsClosed=true;
        StatusSection.getFile(e.getKey(),buff);
        String file=buff.toString();
        if (wals.contains(file)) {
          Status stat=Status.parseFrom(e.getValue().get());
          if (!stat.getClosed()) {
            log.info("{} wasn't closed",file);
            allReferencedLogsClosed=false;
          }
        }
      }
      if (recordsFound > 0 && allReferencedLogsClosed) {
        return;
      }
      Thread.sleep(2000);
    }
 catch (    RuntimeException e) {
      Throwable cause=e.getCause();
      if (cause instanceof AccumuloSecurityException) {
        AccumuloSecurityException ase=(AccumuloSecurityException)cause;
switch (ase.getSecurityErrorCode()) {
case PERMISSION_DENIED:
          Thread.sleep(2000);
        break;
default :
      throw e;
  }
}
}
}
Assert.fail("We had a file that was referenced but didn't get closed");
}

</code></pre>

<br>
<pre class="type-9 type-13 type-11 type-8 type-5 type-3 type-7 type-2 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions in iterations
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void replicatedStatusEntriesAreDeleted() throws Exception {
  getCluster().getClusterControl().stop(ServerType.GARBAGE_COLLECTOR);
  final Connector conn=getConnector();
  log.info("Got connector to MAC");
  String table1="table1";
  Assert.assertFalse(ReplicationTable.isOnline(conn));
  conn.tableOperations().create(table1);
  int attempts=5;
  while (attempts > 0) {
    try {
      conn.tableOperations().setProperty(table1,Property.TABLE_REPLICATION.getKey(),"true");
      conn.tableOperations().setProperty(table1,Property.TABLE_REPLICATION_TARGET.getKey() + "cluster1","4");
      conn.instanceOperations().setProperty(Property.REPLICATION_PEERS.getKey() + "cluster1",ReplicaSystemFactory.getPeerConfigurationValue(MockReplicaSystem.class,"1000"));
      attempts=0;
    }
 catch (    Exception e) {
      attempts--;
      if (attempts <= 0) {
        throw e;
      }
      sleepUninterruptibly(500,TimeUnit.MILLISECONDS);
    }
  }
  String tableId=conn.tableOperations().tableIdMap().get(table1);
  Assert.assertNotNull("Could not determine table id for " + table1,tableId);
  writeSomeData(conn,table1,2000,50);
  conn.tableOperations().flush(table1,null,null,true);
  boolean online=ReplicationTable.isOnline(conn);
  attempts=10;
  do {
    if (!online) {
      sleepUninterruptibly(1,TimeUnit.SECONDS);
      online=ReplicationTable.isOnline(conn);
      attempts--;
    }
  }
 while (!online && attempts > 0);
  Assert.assertTrue("Replication table did not exist",online);
  conn.securityOperations().grantTablePermission("root",ReplicationTable.NAME,TablePermission.WRITE);
  log.info("Checking for replication entries in replication");
  Scanner s;
  Set<String> entries=new HashSet<>();
  for (int i=0; i < 5; i++) {
    s=conn.createScanner(MetadataTable.NAME,Authorizations.EMPTY);
    s.setRange(ReplicationSection.getRange());
    entries.clear();
    for (    Entry<Key,Value> entry : s) {
      entries.add(entry.getKey().getRow().toString());
      log.info("{}={}",entry.getKey().toStringNoTruncate(),entry.getValue());
    }
    if (!entries.isEmpty()) {
      log.info("Replication entries {}",entries);
      break;
    }
    Thread.sleep(1000);
  }
  Assert.assertFalse("Did not find any replication entries in the replication table",entries.isEmpty());
  boolean notFound=true;
  for (int i=0; i < 10 && notFound; i++) {
    try {
      s=ReplicationTable.getScanner(conn);
      WorkSection.limit(s);
      Entry<Key,Value> e=Iterables.getOnlyElement(s);
      log.info("Found entry: " + e.getKey().toStringNoTruncate());
      Text expectedColqual=new ReplicationTarget("cluster1","4",tableId).toText();
      Assert.assertEquals(expectedColqual,e.getKey().getColumnQualifier());
      notFound=false;
    }
 catch (    NoSuchElementException e) {
    }
catch (    IllegalArgumentException e) {
      s=ReplicationTable.getScanner(conn);
      for (      Entry<Key,Value> content : s) {
        log.info(content.getKey().toStringNoTruncate() + " => " + content.getValue());
      }
      Assert.fail("Found more than one work section entry");
    }
catch (    RuntimeException e) {
      Throwable cause=e.getCause();
      if (cause instanceof AccumuloSecurityException) {
        AccumuloSecurityException sec=(AccumuloSecurityException)cause;
switch (sec.getSecurityErrorCode()) {
case PERMISSION_DENIED:
          log.warn("Sleeping because permission was denied");
        break;
default :
      throw e;
  }
}
 else {
  throw e;
}
}
Thread.sleep(2000);
}
if (notFound) {
s=ReplicationTable.getScanner(conn);
for (Entry<Key,Value> content : s) {
log.info(content.getKey().toStringNoTruncate() + " => " + ProtobufUtil.toString(Status.parseFrom(content.getValue().get())));
}
Assert.assertFalse("Did not find the work entry for the status entry",notFound);
}
log.info("Killing tserver");
cluster.getClusterControl().stop(ServerType.TABLET_SERVER);
log.info("Starting tserver");
cluster.getClusterControl().start(ServerType.TABLET_SERVER);
log.info("Waiting to read tables");
sleepUninterruptibly(2 * 3,TimeUnit.SECONDS);
for (String table : new String[]{MetadataTable.NAME,table1}) {
Iterators.size(conn.createScanner(table,Authorizations.EMPTY).iterator());
}
log.info("Recovered metadata:");
s=conn.createScanner(MetadataTable.NAME,Authorizations.EMPTY);
for (Entry<Key,Value> entry : s) {
log.info("{}={}",entry.getKey().toStringNoTruncate(),entry.getValue());
}
cluster.getClusterControl().start(ServerType.GARBAGE_COLLECTOR);
waitForGCLock(conn);
Thread.sleep(1000);
log.info("After GC");
s=conn.createScanner(MetadataTable.NAME,Authorizations.EMPTY);
for (Entry<Key,Value> entry : s) {
log.info("{}={}",entry.getKey().toStringNoTruncate(),entry.getValue());
}
log.info("Checking metadata table for replication entries");
Set<String> remaining=new HashSet<>();
for (int i=0; i < 10; i++) {
s=conn.createScanner(MetadataTable.NAME,Authorizations.EMPTY);
s.setRange(ReplicationSection.getRange());
remaining.clear();
for (Entry<Key,Value> e : s) {
remaining.add(e.getKey().getRow().toString());
}
remaining.retainAll(entries);
if (remaining.isEmpty()) {
break;
}
log.info("remaining {}",remaining);
Thread.sleep(2000);
log.info("");
}
Assert.assertTrue("Replication status messages were not cleaned up from metadata table",remaining.isEmpty());
int recordsFound=0;
for (int i=0; i < 30; i++) {
s=ReplicationTable.getScanner(conn);
recordsFound=0;
for (Entry<Key,Value> entry : s) {
recordsFound++;
log.info("{} {}",entry.getKey().toStringNoTruncate(),ProtobufUtil.toString(Status.parseFrom(entry.getValue().get())));
}
if (recordsFound <= 2) {
break;
}
 else {
Thread.sleep(1000);
log.info("");
}
}
Assert.assertTrue("Found unexpected replication records in the replication table",recordsFound <= 2);
}

</code></pre>

<br>
<pre class="type-9 type-11 type-8 type-5 type-3 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void replicationRecordsAreClosedAfterGarbageCollection() throws Exception {
  getCluster().getClusterControl().stop(ServerType.GARBAGE_COLLECTOR);
  final Connector conn=getConnector();
  ReplicationTable.setOnline(conn);
  conn.securityOperations().grantTablePermission("root",ReplicationTable.NAME,TablePermission.WRITE);
  conn.tableOperations().deleteRows(ReplicationTable.NAME,null,null);
  final AtomicBoolean keepRunning=new AtomicBoolean(true);
  final Set<String> metadataWals=new HashSet<>();
  Thread t=new Thread(new Runnable(){
    @Override public void run(){
      while (keepRunning.get()) {
        try {
          metadataWals.addAll(getLogs(conn).keySet());
        }
 catch (        Exception e) {
          log.error("Metadata table doesn't exist");
        }
      }
    }
  }
);
  t.start();
  String table1="table1", table2="table2", table3="table3";
  try {
    conn.tableOperations().create(table1);
    conn.tableOperations().setProperty(table1,Property.TABLE_REPLICATION.getKey(),"true");
    conn.tableOperations().setProperty(table1,Property.TABLE_REPLICATION_TARGET.getKey() + "cluster1","1");
    conn.instanceOperations().setProperty(Property.REPLICATION_PEERS.getKey() + "cluster1",ReplicaSystemFactory.getPeerConfigurationValue(MockReplicaSystem.class,null));
    writeSomeData(conn,table1,200,500);
    conn.tableOperations().create(table2);
    conn.tableOperations().setProperty(table2,Property.TABLE_REPLICATION.getKey(),"true");
    conn.tableOperations().setProperty(table2,Property.TABLE_REPLICATION_TARGET.getKey() + "cluster1","1");
    writeSomeData(conn,table2,200,500);
    conn.tableOperations().create(table3);
    conn.tableOperations().setProperty(table3,Property.TABLE_REPLICATION.getKey(),"true");
    conn.tableOperations().setProperty(table3,Property.TABLE_REPLICATION_TARGET.getKey() + "cluster1","1");
    writeSomeData(conn,table3,200,500);
    for (    String table : Arrays.asList(table1,table2,table3)) {
      conn.tableOperations().compact(table,null,null,true,true);
    }
  }
  finally {
    keepRunning.set(false);
    t.join(5000);
    Assert.assertFalse(t.isAlive());
  }
  cluster.getClusterControl().stop(ServerType.TABLET_SERVER);
  cluster.getClusterControl().start(ServerType.TABLET_SERVER);
  for (  String table : Arrays.asList(table1,table2,table3)) {
    Iterators.size(conn.createScanner(table,Authorizations.EMPTY).iterator());
  }
  Process gc=cluster.exec(SimpleGarbageCollector.class);
  waitForGCLock(conn);
  Thread.sleep(1000);
  log.info("GC is up and should have had time to run at least once by now");
  try {
    boolean allClosed=true;
    for (int i=0; i < 10; i++) {
      Scanner s=conn.createScanner(MetadataTable.NAME,Authorizations.EMPTY);
      s.setRange(Range.prefix(ReplicationSection.getRowPrefix()));
      Iterator<Entry<Key,Value>> iter=s.iterator();
      long recordsFound=0l;
      while (allClosed && iter.hasNext()) {
        Entry<Key,Value> entry=iter.next();
        String wal=entry.getKey().getRow().toString();
        if (metadataWals.contains(wal)) {
          Status status=Status.parseFrom(entry.getValue().get());
          log.info("{}={}",entry.getKey().toStringNoTruncate(),ProtobufUtil.toString(status));
          allClosed&=status.getClosed();
          recordsFound++;
        }
      }
      log.info("Found {} records from the metadata table",recordsFound);
      if (allClosed) {
        break;
      }
      sleepUninterruptibly(2,TimeUnit.SECONDS);
    }
    if (!allClosed) {
      Scanner s=conn.createScanner(MetadataTable.NAME,Authorizations.EMPTY);
      s.setRange(Range.prefix(ReplicationSection.getRowPrefix()));
      for (      Entry<Key,Value> entry : s) {
        log.info(entry.getKey().toStringNoTruncate() + " " + ProtobufUtil.toString(Status.parseFrom(entry.getValue().get())));
      }
      Assert.fail("Expected all replication records in the metadata table to be closed");
    }
    for (int i=0; i < 10; i++) {
      allClosed=true;
      Scanner s=ReplicationTable.getScanner(conn);
      Iterator<Entry<Key,Value>> iter=s.iterator();
      long recordsFound=0l;
      while (allClosed && iter.hasNext()) {
        Entry<Key,Value> entry=iter.next();
        String wal=entry.getKey().getRow().toString();
        if (metadataWals.contains(wal)) {
          Status status=Status.parseFrom(entry.getValue().get());
          log.info("{}={}",entry.getKey().toStringNoTruncate(),ProtobufUtil.toString(status));
          allClosed&=status.getClosed();
          recordsFound++;
        }
      }
      log.info("Found {} records from the replication table",recordsFound);
      if (allClosed) {
        break;
      }
      sleepUninterruptibly(3,TimeUnit.SECONDS);
    }
    if (!allClosed) {
      Scanner s=ReplicationTable.getScanner(conn);
      StatusSection.limit(s);
      for (      Entry<Key,Value> entry : s) {
        log.info(entry.getKey().toStringNoTruncate() + " " + TextFormat.shortDebugString(Status.parseFrom(entry.getValue().get())));
      }
      Assert.fail("Expected all replication records in the replication table to be closed");
    }
  }
  finally {
    gc.destroy();
    gc.waitFor();
  }
}

</code></pre>

<br>
<pre class="type-9 type-13 type-11 type-8 type-5 type-3 type-7 type-2 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions in iterations
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void correctClusterNameInWorkEntry() throws Exception {
  Connector conn=getConnector();
  String table1="table1";
  Assert.assertFalse(ReplicationTable.isOnline(conn));
  conn.tableOperations().create(table1);
  int attempts=5;
  while (attempts > 0) {
    try {
      conn.tableOperations().setProperty(table1,Property.TABLE_REPLICATION.getKey(),"true");
      conn.tableOperations().setProperty(table1,Property.TABLE_REPLICATION_TARGET.getKey() + "cluster1","4");
      attempts=0;
    }
 catch (    Exception e) {
      attempts--;
      if (attempts <= 0) {
        throw e;
      }
      sleepUninterruptibly(500,TimeUnit.MILLISECONDS);
    }
  }
  writeSomeData(conn,table1,2000,50);
  conn.tableOperations().flush(table1,null,null,true);
  String tableId=conn.tableOperations().tableIdMap().get(table1);
  Assert.assertNotNull("Table ID was null",tableId);
  boolean online=ReplicationTable.isOnline(conn);
  attempts=5;
  do {
    if (!online) {
      sleepUninterruptibly(500,TimeUnit.MILLISECONDS);
      online=ReplicationTable.isOnline(conn);
      attempts--;
    }
  }
 while (!online && attempts > 0);
  Assert.assertTrue("Replication table did not exist",online);
  for (int i=0; i < 5 && !conn.securityOperations().hasTablePermission("root",ReplicationTable.NAME,TablePermission.READ); i++) {
    Thread.sleep(1000);
  }
  Assert.assertTrue(conn.securityOperations().hasTablePermission("root",ReplicationTable.NAME,TablePermission.READ));
  boolean notFound=true;
  Scanner s;
  for (int i=0; i < 10 && notFound; i++) {
    s=ReplicationTable.getScanner(conn);
    WorkSection.limit(s);
    try {
      Entry<Key,Value> e=Iterables.getOnlyElement(s);
      Text expectedColqual=new ReplicationTarget("cluster1","4",tableId).toText();
      Assert.assertEquals(expectedColqual,e.getKey().getColumnQualifier());
      notFound=false;
    }
 catch (    NoSuchElementException e) {
    }
catch (    IllegalArgumentException e) {
      s=ReplicationTable.getScanner(conn);
      for (      Entry<Key,Value> content : s) {
        log.info(content.getKey().toStringNoTruncate() + " => " + content.getValue());
      }
      Assert.fail("Found more than one work section entry");
    }
    Thread.sleep(500);
  }
  if (notFound) {
    s=ReplicationTable.getScanner(conn);
    for (    Entry<Key,Value> content : s) {
      log.info(content.getKey().toStringNoTruncate() + " => " + content.getValue());
    }
    Assert.assertFalse("Did not find the work entry for the status entry",notFound);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.accumulo.test.replication.ReplicationOperationsImplIT </h4><pre class="type-8 type-5 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void laterCreatedLogsDontBlockExecution() throws Exception {
  conn.tableOperations().create("foo");
  Text tableId1=new Text(conn.tableOperations().tableIdMap().get("foo"));
  String file1="/accumulo/wals/tserver+port/" + UUID.randomUUID();
  Status stat=Status.newBuilder().setBegin(0).setEnd(10000).setInfiniteEnd(false).setClosed(false).build();
  BatchWriter bw=ReplicationTable.getBatchWriter(conn);
  Mutation m=new Mutation(file1);
  StatusSection.add(m,tableId1,ProtobufUtil.toValue(stat));
  bw.addMutation(m);
  bw.close();
  bw=conn.createBatchWriter(MetadataTable.NAME,new BatchWriterConfig());
  m=new Mutation(ReplicationSection.getRowPrefix() + file1);
  m.put(ReplicationSection.COLF,tableId1,ProtobufUtil.toValue(stat));
  bw.addMutation(m);
  bw.close();
  log.info("Reading metadata first time");
  for (  Entry<Key,Value> e : conn.createScanner(MetadataTable.NAME,Authorizations.EMPTY)) {
    log.info("{}",e.getKey());
  }
  final AtomicBoolean done=new AtomicBoolean(false);
  final AtomicBoolean exception=new AtomicBoolean(false);
  final ReplicationOperationsImpl roi=getReplicationOperations();
  Thread t=new Thread(new Runnable(){
    @Override public void run(){
      try {
        roi.drain("foo");
      }
 catch (      Exception e) {
        log.error("Got error",e);
        exception.set(true);
      }
      done.set(true);
    }
  }
);
  t.start();
  Thread.sleep(2000);
  bw=conn.createBatchWriter(MetadataTable.NAME,new BatchWriterConfig());
  m=new Mutation(ReplicationSection.getRowPrefix() + "/accumulo/wals/tserver+port/" + UUID.randomUUID());
  m.put(ReplicationSection.COLF,tableId1,ProtobufUtil.toValue(stat));
  bw.addMutation(m);
  m=new Mutation(ReplicationSection.getRowPrefix() + file1);
  m.putDelete(ReplicationSection.COLF,tableId1);
  bw.addMutation(m);
  bw.close();
  log.info("Reading metadata second time");
  for (  Entry<Key,Value> e : conn.createScanner(MetadataTable.NAME,Authorizations.EMPTY)) {
    log.info("{}",e.getKey());
  }
  bw=ReplicationTable.getBatchWriter(conn);
  m=new Mutation(file1);
  m.putDelete(StatusSection.NAME,tableId1);
  bw.addMutation(m);
  bw.close();
  try {
    t.join(5000);
  }
 catch (  InterruptedException e) {
    Assert.fail("ReplicationOperations.drain did not complete");
  }
  Assert.assertTrue("Drain didn't finish",done.get());
}

</code></pre>

<br>
<pre class="type-8 type-5 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void inprogressReplicationRecordsBlockExecution() throws Exception {
  conn.tableOperations().create("foo");
  Text tableId1=new Text(conn.tableOperations().tableIdMap().get("foo"));
  String file1="/accumulo/wals/tserver+port/" + UUID.randomUUID();
  Status stat=Status.newBuilder().setBegin(0).setEnd(10000).setInfiniteEnd(false).setClosed(false).build();
  BatchWriter bw=ReplicationTable.getBatchWriter(conn);
  Mutation m=new Mutation(file1);
  StatusSection.add(m,tableId1,ProtobufUtil.toValue(stat));
  bw.addMutation(m);
  bw.close();
  LogEntry logEntry=new LogEntry(new KeyExtent(new Text(tableId1),null,null),System.currentTimeMillis(),"tserver",file1);
  bw=conn.createBatchWriter(MetadataTable.NAME,new BatchWriterConfig());
  m=new Mutation(ReplicationSection.getRowPrefix() + file1);
  m.put(ReplicationSection.COLF,tableId1,ProtobufUtil.toValue(stat));
  bw.addMutation(m);
  m=new Mutation(logEntry.getRow());
  m.put(logEntry.getColumnFamily(),logEntry.getColumnQualifier(),logEntry.getValue());
  bw.addMutation(m);
  bw.close();
  final AtomicBoolean done=new AtomicBoolean(false);
  final AtomicBoolean exception=new AtomicBoolean(false);
  final ReplicationOperationsImpl roi=getReplicationOperations();
  Thread t=new Thread(new Runnable(){
    @Override public void run(){
      try {
        roi.drain("foo");
      }
 catch (      Exception e) {
        log.error("Got error",e);
        exception.set(true);
      }
      done.set(true);
    }
  }
);
  t.start();
  Assert.assertFalse(done.get());
  Status newStatus=Status.newBuilder().setBegin(1000).setEnd(2000).setInfiniteEnd(false).setClosed(true).build();
  bw=conn.createBatchWriter(MetadataTable.NAME,new BatchWriterConfig());
  m=new Mutation(ReplicationSection.getRowPrefix() + file1);
  m.put(ReplicationSection.COLF,tableId1,ProtobufUtil.toValue(newStatus));
  bw.addMutation(m);
  bw.flush();
  Assert.assertFalse(done.get());
  bw=ReplicationTable.getBatchWriter(conn);
  m=new Mutation(file1);
  m.put(StatusSection.NAME,tableId1,ProtobufUtil.toValue(newStatus));
  bw.addMutation(m);
  bw.flush();
  try {
    t.join(5000);
  }
 catch (  InterruptedException e) {
    Assert.fail("ReplicationOperations.drain did not complete");
  }
  Assert.assertFalse("Drain somehow finished",done.get());
  Assert.assertFalse("Saw unexpected exception",exception.get());
}

</code></pre>

<br>
<pre class="type-8 type-5 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void unrelatedReplicationRecordsDontBlockDrain() throws Exception {
  conn.tableOperations().create("foo");
  conn.tableOperations().create("bar");
  Text tableId1=new Text(conn.tableOperations().tableIdMap().get("foo"));
  Text tableId2=new Text(conn.tableOperations().tableIdMap().get("bar"));
  String file1="/accumulo/wals/tserver+port/" + UUID.randomUUID(), file2="/accumulo/wals/tserver+port/" + UUID.randomUUID();
  Status stat=Status.newBuilder().setBegin(0).setEnd(10000).setInfiniteEnd(false).setClosed(false).build();
  BatchWriter bw=ReplicationTable.getBatchWriter(conn);
  Mutation m=new Mutation(file1);
  StatusSection.add(m,tableId1,ProtobufUtil.toValue(stat));
  bw.addMutation(m);
  m=new Mutation(file2);
  StatusSection.add(m,tableId2,ProtobufUtil.toValue(stat));
  bw.addMutation(m);
  bw.close();
  bw=conn.createBatchWriter(MetadataTable.NAME,new BatchWriterConfig());
  m=new Mutation(ReplicationSection.getRowPrefix() + file1);
  m.put(ReplicationSection.COLF,tableId1,ProtobufUtil.toValue(stat));
  bw.addMutation(m);
  m=new Mutation(ReplicationSection.getRowPrefix() + file2);
  m.put(ReplicationSection.COLF,tableId2,ProtobufUtil.toValue(stat));
  bw.close();
  final AtomicBoolean done=new AtomicBoolean(false);
  final AtomicBoolean exception=new AtomicBoolean(false);
  final ReplicationOperationsImpl roi=getReplicationOperations();
  Thread t=new Thread(new Runnable(){
    @Override public void run(){
      try {
        roi.drain("foo");
      }
 catch (      Exception e) {
        log.error("Got error",e);
        exception.set(true);
      }
      done.set(true);
    }
  }
);
  t.start();
  Assert.assertFalse(done.get());
  bw=conn.createBatchWriter(MetadataTable.NAME,new BatchWriterConfig());
  m=new Mutation(ReplicationSection.getRowPrefix() + file1);
  m.putDelete(ReplicationSection.COLF,tableId1);
  bw.addMutation(m);
  bw.flush();
  Assert.assertFalse(done.get());
  bw=ReplicationTable.getBatchWriter(conn);
  m=new Mutation(file1);
  m.putDelete(StatusSection.NAME,tableId1);
  bw.addMutation(m);
  bw.flush();
  try {
    t.join(5000);
  }
 catch (  InterruptedException e) {
    Assert.fail("ReplicationOperations.drain did not complete");
  }
  Assert.assertTrue("Drain never completed",done.get());
  Assert.assertFalse("Saw unexpected exception",exception.get());
}

</code></pre>

<br>
<pre class="type-8 type-5 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void waitsUntilEntriesAreReplicated() throws Exception {
  conn.tableOperations().create("foo");
  Text tableId=new Text(conn.tableOperations().tableIdMap().get("foo"));
  String file1="/accumulo/wals/tserver+port/" + UUID.randomUUID(), file2="/accumulo/wals/tserver+port/" + UUID.randomUUID();
  Status stat=Status.newBuilder().setBegin(0).setEnd(10000).setInfiniteEnd(false).setClosed(false).build();
  BatchWriter bw=ReplicationTable.getBatchWriter(conn);
  Mutation m=new Mutation(file1);
  StatusSection.add(m,tableId,ProtobufUtil.toValue(stat));
  bw.addMutation(m);
  m=new Mutation(file2);
  StatusSection.add(m,tableId,ProtobufUtil.toValue(stat));
  bw.addMutation(m);
  bw.close();
  bw=conn.createBatchWriter(MetadataTable.NAME,new BatchWriterConfig());
  m=new Mutation(ReplicationSection.getRowPrefix() + file1);
  m.put(ReplicationSection.COLF,tableId,ProtobufUtil.toValue(stat));
  bw.addMutation(m);
  m=new Mutation(ReplicationSection.getRowPrefix() + file2);
  m.put(ReplicationSection.COLF,tableId,ProtobufUtil.toValue(stat));
  bw.close();
  final AtomicBoolean done=new AtomicBoolean(false);
  final AtomicBoolean exception=new AtomicBoolean(false);
  final ReplicationOperationsImpl roi=getReplicationOperations();
  Thread t=new Thread(new Runnable(){
    @Override public void run(){
      try {
        roi.drain("foo");
      }
 catch (      Exception e) {
        log.error("Got error",e);
        exception.set(true);
      }
      done.set(true);
    }
  }
);
  t.start();
  Assert.assertFalse(done.get());
  bw=conn.createBatchWriter(MetadataTable.NAME,new BatchWriterConfig());
  m=new Mutation(ReplicationSection.getRowPrefix() + file1);
  m.putDelete(ReplicationSection.COLF,tableId);
  bw.addMutation(m);
  bw.flush();
  Assert.assertFalse(done.get());
  m=new Mutation(ReplicationSection.getRowPrefix() + file2);
  m.putDelete(ReplicationSection.COLF,tableId);
  bw.addMutation(m);
  bw.flush();
  bw.close();
  Assert.assertFalse(done.get());
  bw=ReplicationTable.getBatchWriter(conn);
  m=new Mutation(file1);
  m.putDelete(StatusSection.NAME,tableId);
  bw.addMutation(m);
  bw.flush();
  Assert.assertFalse(done.get());
  m=new Mutation(file2);
  m.putDelete(StatusSection.NAME,tableId);
  bw.addMutation(m);
  bw.flush();
  try {
    t.join(5000);
  }
 catch (  InterruptedException e) {
    Assert.fail("ReplicationOperations.drain did not complete");
  }
  Assert.assertTrue("Drain never finished",done.get());
  Assert.assertFalse("Saw unexpectetd exception",exception.get());
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.accumulo.test.replication.UnorderedWorkAssignerReplicationIT </h4><pre class="type-9 type-13 type-8 type-5 type-3 type-7 type-2 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions in iterations
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void dataWasReplicatedToThePeer() throws Exception {
  MiniAccumuloConfigImpl peerCfg=new MiniAccumuloConfigImpl(createTestDir(this.getClass().getName() + "_" + this.testName.getMethodName()+ "_peer"),ROOT_PASSWORD);
  peerCfg.setNumTservers(1);
  peerCfg.setInstanceName("peer");
  updatePeerConfigFromPrimary(getCluster().getConfig(),peerCfg);
  peerCfg.setProperty(Property.REPLICATION_NAME,"peer");
  MiniAccumuloClusterImpl peerCluster=new MiniAccumuloClusterImpl(peerCfg);
  peerCluster.start();
  try {
    final Connector connMaster=getConnector();
    final Connector connPeer=peerCluster.getConnector("root",new PasswordToken(ROOT_PASSWORD));
    ReplicationTable.setOnline(connMaster);
    String peerUserName="peer", peerPassword="foo";
    String peerClusterName="peer";
    connPeer.securityOperations().createLocalUser(peerUserName,new PasswordToken(peerPassword));
    connMaster.instanceOperations().setProperty(Property.REPLICATION_PEER_USER.getKey() + peerClusterName,peerUserName);
    connMaster.instanceOperations().setProperty(Property.REPLICATION_PEER_PASSWORD.getKey() + peerClusterName,peerPassword);
    connMaster.instanceOperations().setProperty(Property.REPLICATION_PEERS.getKey() + peerClusterName,ReplicaSystemFactory.getPeerConfigurationValue(AccumuloReplicaSystem.class,AccumuloReplicaSystem.buildConfiguration(peerCluster.getInstanceName(),peerCluster.getZooKeepers())));
    final String masterTable="master", peerTable="peer";
    connMaster.tableOperations().create(masterTable);
    String masterTableId=connMaster.tableOperations().tableIdMap().get(masterTable);
    Assert.assertNotNull(masterTableId);
    connPeer.tableOperations().create(peerTable);
    String peerTableId=connPeer.tableOperations().tableIdMap().get(peerTable);
    Assert.assertNotNull(peerTableId);
    connPeer.securityOperations().grantTablePermission(peerUserName,peerTable,TablePermission.WRITE);
    connMaster.tableOperations().setProperty(masterTable,Property.TABLE_REPLICATION.getKey(),"true");
    connMaster.tableOperations().setProperty(masterTable,Property.TABLE_REPLICATION_TARGET.getKey() + peerClusterName,peerTableId);
    sleepUninterruptibly(3,TimeUnit.SECONDS);
    BatchWriter bw=connMaster.createBatchWriter(masterTable,new BatchWriterConfig());
    for (int rows=0; rows < 5000; rows++) {
      Mutation m=new Mutation(Integer.toString(rows));
      for (int cols=0; cols < 100; cols++) {
        String value=Integer.toString(cols);
        m.put(value,"",value);
      }
      bw.addMutation(m);
    }
    bw.close();
    log.info("Wrote all data to master cluster");
    final Set<String> filesNeedingReplication=connMaster.replicationOperations().referencedFiles(masterTable);
    for (    ProcessReference proc : cluster.getProcesses().get(ServerType.TABLET_SERVER)) {
      cluster.killProcess(ServerType.TABLET_SERVER,proc);
    }
    cluster.exec(TabletServer.class);
    log.info("TabletServer restarted");
    Iterators.size(ReplicationTable.getScanner(connMaster).iterator());
    log.info("TabletServer is online");
    log.info("");
    log.info("Fetching metadata records:");
    for (    Entry<Key,Value> kv : connMaster.createScanner(MetadataTable.NAME,Authorizations.EMPTY)) {
      if (ReplicationSection.COLF.equals(kv.getKey().getColumnFamily())) {
        log.info(kv.getKey().toStringNoTruncate() + " " + ProtobufUtil.toString(Status.parseFrom(kv.getValue().get())));
      }
 else {
        log.info(kv.getKey().toStringNoTruncate() + " " + kv.getValue());
      }
    }
    log.info("");
    log.info("Fetching replication records:");
    for (    Entry<Key,Value> kv : ReplicationTable.getScanner(connMaster)) {
      log.info(kv.getKey().toStringNoTruncate() + " " + ProtobufUtil.toString(Status.parseFrom(kv.getValue().get())));
    }
    Future<Boolean> future=executor.submit(new Callable<Boolean>(){
      @Override public Boolean call() throws Exception {
        connMaster.replicationOperations().drain(masterTable,filesNeedingReplication);
        log.info("Drain completed");
        return true;
      }
    }
);
    long timeoutSeconds=timeoutFactor * 30;
    try {
      future.get(timeoutSeconds,TimeUnit.SECONDS);
    }
 catch (    TimeoutException e) {
      future.cancel(true);
      Assert.fail("Drain did not finish within " + timeoutSeconds + " seconds");
    }
    log.info("drain completed");
    log.info("");
    log.info("Fetching metadata records:");
    for (    Entry<Key,Value> kv : connMaster.createScanner(MetadataTable.NAME,Authorizations.EMPTY)) {
      if (ReplicationSection.COLF.equals(kv.getKey().getColumnFamily())) {
        log.info(kv.getKey().toStringNoTruncate() + " " + ProtobufUtil.toString(Status.parseFrom(kv.getValue().get())));
      }
 else {
        log.info(kv.getKey().toStringNoTruncate() + " " + kv.getValue());
      }
    }
    log.info("");
    log.info("Fetching replication records:");
    for (    Entry<Key,Value> kv : ReplicationTable.getScanner(connMaster)) {
      log.info(kv.getKey().toStringNoTruncate() + " " + ProtobufUtil.toString(Status.parseFrom(kv.getValue().get())));
    }
    Scanner master=connMaster.createScanner(masterTable,Authorizations.EMPTY), peer=connPeer.createScanner(peerTable,Authorizations.EMPTY);
    Iterator<Entry<Key,Value>> masterIter=master.iterator(), peerIter=peer.iterator();
    Entry<Key,Value> masterEntry=null, peerEntry=null;
    while (masterIter.hasNext() && peerIter.hasNext()) {
      masterEntry=masterIter.next();
      peerEntry=peerIter.next();
      Assert.assertEquals(masterEntry.getKey() + " was not equal to " + peerEntry.getKey(),0,masterEntry.getKey().compareTo(peerEntry.getKey(),PartialKey.ROW_COLFAM_COLQUAL_COLVIS));
      Assert.assertEquals(masterEntry.getValue(),peerEntry.getValue());
    }
    log.info("Last master entry: " + masterEntry);
    log.info("Last peer entry: " + peerEntry);
    Assert.assertFalse("Had more data to read from the master",masterIter.hasNext());
    Assert.assertFalse("Had more data to read from the peer",peerIter.hasNext());
  }
  finally {
    peerCluster.stop();
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.accumulo.test.util.CertUtilsTest </h4><pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void createSigned() throws Exception {
  CertUtils certUtils=getUtils();
  File rootKeyStoreFile=new File(folder.getRoot(),"root.jks");
  certUtils.createSelfSignedCert(rootKeyStoreFile,"test",PASSWORD);
  File signedKeyStoreFile=new File(folder.getRoot(),"signed.jks");
  certUtils.createSignedCert(signedKeyStoreFile,"test",PASSWORD,rootKeyStoreFile.getAbsolutePath(),PASSWORD);
  KeyStore rootKeyStore=KeyStore.getInstance(KEYSTORE_TYPE);
  try (FileInputStream fis=new FileInputStream(rootKeyStoreFile)){
    rootKeyStore.load(fis,PASSWORD_CHARS);
  }
   Certificate rootCert=CertUtils.findCert(rootKeyStore);
  KeyStore signedKeyStore=KeyStore.getInstance(KEYSTORE_TYPE);
  try (FileInputStream fis=new FileInputStream(signedKeyStoreFile)){
    signedKeyStore.load(fis,PASSWORD_CHARS);
  }
   Certificate signedCert=CertUtils.findCert(signedKeyStore);
  try {
    signedCert.verify(signedCert.getPublicKey());
    fail("signed cert should not be able to verify itself");
  }
 catch (  SignatureException e) {
  }
  signedCert.verify(rootCert.getPublicKey());
}

</code></pre>

<br>
<pre class="type-8 type-5 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void createPublicSelfSigned() throws Exception {
  CertUtils certUtils=getUtils();
  File rootKeyStoreFile=new File(folder.getRoot(),"root.jks");
  certUtils.createSelfSignedCert(rootKeyStoreFile,"test",PASSWORD);
  File publicKeyStoreFile=new File(folder.getRoot(),"public.jks");
  certUtils.createPublicCert(publicKeyStoreFile,"test",rootKeyStoreFile.getAbsolutePath(),PASSWORD,"");
  KeyStore keyStore=KeyStore.getInstance(KEYSTORE_TYPE);
  try (FileInputStream fis=new FileInputStream(publicKeyStoreFile)){
    keyStore.load(fis,new char[0]);
  }
   try {
    CertUtils.findPrivateKey(keyStore,PASSWORD_CHARS);
    fail("expected not to find private key in keystore");
  }
 catch (  KeyStoreException e) {
    assertTrue(e.getMessage().contains("private key"));
  }
  Certificate cert=CertUtils.findCert(keyStore);
  cert.verify(cert.getPublicKey());
}

</code></pre>

<br>
<pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void publicOnlyVerfication() throws Exception {
  CertUtils certUtils=getUtils();
  File rootKeyStoreFile=new File(folder.getRoot(),"root.jks");
  certUtils.createSelfSignedCert(rootKeyStoreFile,"test",PASSWORD);
  File publicRootKeyStoreFile=new File(folder.getRoot(),"publicroot.jks");
  certUtils.createPublicCert(publicRootKeyStoreFile,"test",rootKeyStoreFile.getAbsolutePath(),PASSWORD,"");
  File signedKeyStoreFile=new File(folder.getRoot(),"signed.jks");
  certUtils.createSignedCert(signedKeyStoreFile,"test",PASSWORD,rootKeyStoreFile.getAbsolutePath(),PASSWORD);
  File publicSignedKeyStoreFile=new File(folder.getRoot(),"publicsigned.jks");
  certUtils.createPublicCert(publicSignedKeyStoreFile,"test",signedKeyStoreFile.getAbsolutePath(),PASSWORD,"");
  KeyStore rootKeyStore=KeyStore.getInstance(KEYSTORE_TYPE);
  try (FileInputStream fis=new FileInputStream(publicRootKeyStoreFile)){
    rootKeyStore.load(fis,new char[0]);
  }
   KeyStore signedKeyStore=KeyStore.getInstance(KEYSTORE_TYPE);
  try (FileInputStream fis=new FileInputStream(publicSignedKeyStoreFile)){
    signedKeyStore.load(fis,new char[0]);
  }
   Certificate rootCert=CertUtils.findCert(rootKeyStore);
  Certificate signedCert=CertUtils.findCert(signedKeyStore);
  try {
    signedCert.verify(signedCert.getPublicKey());
    fail("signed cert should not be able to verify itself");
  }
 catch (  SignatureException e) {
  }
  signedCert.verify(rootCert.getPublicKey());
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.accumulo.tserver.InMemoryMapTest </h4><pre class="type-13 type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testDeepCopyAndDelete() throws Exception {
  for (int i=0; i <= 4; i++)   deepCopyAndDelete(i,false);
  for (int i=1; i <= 4; i++)   try {
    deepCopyAndDelete(i,true);
    fail("i = " + i);
  }
 catch (  IterationInterruptedException iie) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.accumulo.tserver.log.SortedLogRecoveryTest </h4><pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testMissingDefinition(){
  KeyValue entries[]=new KeyValue[]{createKeyValue(OPEN,0,-1,"1")};
  Map<String,KeyValue[]> logs=new TreeMap<String,KeyValue[]>();
  logs.put("testlog",entries);
  try {
    recover(logs,extent);
    Assert.fail("tablet should not have been found");
  }
 catch (  Throwable t) {
  }
}

</code></pre>

<br>
<script>$(document).ready(function() {
  $('pre code').each(function(i, block) {
    hljs.highlightBlock(block);
  });
});</script>
