<h3 style="margin:0px">Class: org.apache.accumulo.test.replication.ReplicationIT (13 methods) </h3><br><pre style="padding:0"><code class="html"><div id="tags"><button id="3"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('3')" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls"><kbd id="tag-3"class="label-info"style="display: inline-block;font-size:7pt" >InternalCallVerifier&nbsp;(11)</kbd></button>&nbsp;<button id="5"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('5')" data-toggle="tooltip" title="Verifies boolean conditions"><kbd id="tag-5"class="label-info"style="display: inline-block;font-size:7pt" >BooleanVerifier&nbsp;(10)</kbd></button>&nbsp;<button id="6"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('6')" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes"><kbd id="tag-6"class="label-info"style="display: inline-block;font-size:7pt" >HybridVerifier&nbsp;(9)</kbd></button>&nbsp;<button id="9"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('9')" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) "><kbd id="tag-9"class="label-info"style="display: inline-block;font-size:7pt" >APIUtilityVerifier&nbsp;(9)</kbd></button>&nbsp;<button id="2"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('2')" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value "><kbd id="tag-2"class="label-info"style="display: inline-block;font-size:7pt" >EqualityVerifier&nbsp;(8)</kbd></button>&nbsp;<button id="11"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('11')" data-toggle="tooltip" title="Verifies assertions inside branch conditions"><kbd id="tag-11"class="label-info"style="display: inline-block;font-size:7pt" >BranchVerifier&nbsp;(5)</kbd></button>&nbsp;<button id="8"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('8')" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure"><kbd id="tag-8"class="label-info"style="display: inline-block;font-size:7pt" >UtilityVerifier&nbsp;(5)</kbd></button>&nbsp;<button id="13"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('13')" data-toggle="tooltip" title="Verifies assertions in iterations"><kbd id="tag-13"class="label-info"style="display: inline-block;font-size:7pt" >IterativeVerifier&nbsp;(4)</kbd></button>&nbsp;<button id="7"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('7')" data-toggle="tooltip" title="Verifies whether objects are null"><kbd id="tag-7"class="label-info"style="display: inline-block;font-size:7pt" >NullVerifier&nbsp;(4)</kbd></button>&nbsp;<button id="1"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('1')" data-toggle="tooltip" title="Executes methods or other tests from the same test unit"><kbd id="tag-1"class="label-info"style="display: inline-block;font-size:7pt" >ExecutionTester&nbsp;(1)</kbd></button>&nbsp;</div></code></pre><center><button onclick="showBlocks()" style="margin:6px">Update filter <span class="glyphicon glyphicon-refresh" aria-hidden="true"></span> </button></center><br>
<pre class="type-9 type-13 type-8 type-5 type-3 type-2 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions in iterations
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void correctRecordsCompleteFile() throws Exception {
  Connector conn=getConnector();
  String table="table1";
  conn.tableOperations().create(table);
  conn.tableOperations().setProperty(table,Property.TABLE_REPLICATION.getKey(),"true");
  BatchWriter bw=conn.createBatchWriter(table,new BatchWriterConfig());
  for (int i=0; i < 10; i++) {
    Mutation m=new Mutation(Integer.toString(i));
    m.put(new byte[0],new byte[0],new byte[0]);
    bw.addMutation(m);
  }
  bw.close();
  boolean online=ReplicationTable.isOnline(conn);
  int attempts=10;
  do {
    if (!online) {
      sleepUninterruptibly(2,TimeUnit.SECONDS);
      online=ReplicationTable.isOnline(conn);
      attempts--;
    }
  }
 while (!online && attempts > 0);
  Assert.assertTrue("Replication table was not online",online);
  for (int i=0; i < 5; i++) {
    if (conn.securityOperations().hasTablePermission("root",ReplicationTable.NAME,TablePermission.READ)) {
      break;
    }
    log.info("Could not read replication table, waiting and will retry");
    Thread.sleep(2000);
  }
  Assert.assertTrue("'root' user could not read the replication table",conn.securityOperations().hasTablePermission("root",ReplicationTable.NAME,TablePermission.READ));
  Set<String> replRows=new HashSet<>();
  Scanner scanner;
  attempts=5;
  while (replRows.isEmpty() && attempts > 0) {
    scanner=ReplicationTable.getScanner(conn);
    StatusSection.limit(scanner);
    for (    Entry<Key,Value> entry : scanner) {
      Key k=entry.getKey();
      String fileUri=k.getRow().toString();
      try {
        new URI(fileUri);
      }
 catch (      URISyntaxException e) {
        Assert.fail("Expected a valid URI: " + fileUri);
      }
      replRows.add(fileUri);
    }
  }
  Set<String> wals=new HashSet<>();
  attempts=5;
  Instance i=conn.getInstance();
  ZooReaderWriter zk=new ZooReaderWriter(i.getZooKeepers(),i.getZooKeepersSessionTimeOut(),"");
  while (wals.isEmpty() && attempts > 0) {
    WalStateManager markers=new WalStateManager(i,zk);
    for (    Entry<Path,WalState> entry : markers.getAllState().entrySet()) {
      wals.add(entry.getKey().toString());
    }
    attempts--;
  }
  Assert.assertEquals("Rows found: " + replRows,1,replRows.size());
  replRows.removeAll(wals);
  Assert.assertEquals(2,wals.size());
  Assert.assertEquals(0,replRows.size());
}

</code></pre>

<pre class="type-9 type-3 type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
"></span><br>
@Test public void combinerWorksOnMetadata() throws Exception {
  Connector conn=getConnector();
  conn.securityOperations().grantTablePermission("root",MetadataTable.NAME,TablePermission.WRITE);
  ReplicationTableUtil.configureMetadataTable(conn,MetadataTable.NAME);
  Status stat1=StatusUtil.fileCreated(100);
  Status stat2=StatusUtil.fileClosed();
  BatchWriter bw=conn.createBatchWriter(MetadataTable.NAME,new BatchWriterConfig());
  Mutation m=new Mutation(ReplicationSection.getRowPrefix() + "file:/accumulo/wals/tserver+port/uuid");
  m.put(ReplicationSection.COLF,new Text("1"),ProtobufUtil.toValue(stat1));
  bw.addMutation(m);
  bw.close();
  Scanner s=conn.createScanner(MetadataTable.NAME,Authorizations.EMPTY);
  s.setRange(ReplicationSection.getRange());
  Status actual=Status.parseFrom(Iterables.getOnlyElement(s).getValue().get());
  Assert.assertEquals(stat1,actual);
  bw=conn.createBatchWriter(MetadataTable.NAME,new BatchWriterConfig());
  m=new Mutation(ReplicationSection.getRowPrefix() + "file:/accumulo/wals/tserver+port/uuid");
  m.put(ReplicationSection.COLF,new Text("1"),ProtobufUtil.toValue(stat2));
  bw.addMutation(m);
  bw.close();
  s=conn.createScanner(MetadataTable.NAME,Authorizations.EMPTY);
  s.setRange(ReplicationSection.getRange());
  actual=Status.parseFrom(Iterables.getOnlyElement(s).getValue().get());
  Status expected=Status.newBuilder().setBegin(0).setEnd(0).setClosed(true).setInfiniteEnd(true).setCreatedTime(100).build();
  Assert.assertEquals(expected,actual);
}

</code></pre>

<pre class="type-9 type-11 type-5 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions inside branch conditions
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
"></span><br>
@Test public void replicationEntriesPrecludeWalDeletion() throws Exception {
  final Connector conn=getConnector();
  String table1="table1", table2="table2", table3="table3";
  final Multimap<String,String> logs=HashMultimap.create();
  final AtomicBoolean keepRunning=new AtomicBoolean(true);
  Thread t=new Thread(new Runnable(){
    @Override public void run(){
      while (keepRunning.get()) {
        try {
          logs.putAll(getAllLogs(conn));
        }
 catch (        Exception e) {
          log.error("Error getting logs",e);
        }
      }
    }
  }
);
  t.start();
  conn.tableOperations().create(table1);
  conn.tableOperations().setProperty(table1,Property.TABLE_REPLICATION.getKey(),"true");
  conn.tableOperations().setProperty(table1,Property.TABLE_REPLICATION_TARGET.getKey() + "cluster1","1");
  Thread.sleep(2000);
  writeSomeData(conn,table1,200,500);
  conn.tableOperations().create(table2);
  conn.tableOperations().setProperty(table2,Property.TABLE_REPLICATION.getKey(),"true");
  conn.tableOperations().setProperty(table2,Property.TABLE_REPLICATION_TARGET.getKey() + "cluster1","1");
  Thread.sleep(2000);
  writeSomeData(conn,table2,200,500);
  conn.tableOperations().create(table3);
  conn.tableOperations().setProperty(table3,Property.TABLE_REPLICATION.getKey(),"true");
  conn.tableOperations().setProperty(table3,Property.TABLE_REPLICATION_TARGET.getKey() + "cluster1","1");
  Thread.sleep(2000);
  writeSomeData(conn,table3,200,500);
  for (  String table : Arrays.asList(table1,table2,table3)) {
    conn.tableOperations().flush(table,null,null,true);
  }
  keepRunning.set(false);
  t.join(5000);
  Thread.sleep(5000);
  Set<String> replFiles=getReferencesToFilesToBeReplicated(conn);
  String replicationTableId=conn.tableOperations().tableIdMap().get(ReplicationTable.NAME);
  Iterator<Entry<String,String>> observedLogs=logs.entries().iterator();
  while (observedLogs.hasNext()) {
    Entry<String,String> observedLog=observedLogs.next();
    if (replicationTableId.equals(observedLog.getValue())) {
      log.info("Removing {} because its tableId is for the replication table",observedLog);
      observedLogs.remove();
    }
  }
  Assert.assertTrue("Metadata log distribution: " + logs + "replFiles "+ replFiles,logs.keySet().containsAll(replFiles));
  Assert.assertTrue("Difference between replication entries and current logs is bigger than one",logs.keySet().size() - replFiles.size() <= 1);
  final Configuration conf=new Configuration();
  for (  String replFile : replFiles) {
    Path p=new Path(replFile);
    FileSystem fs=p.getFileSystem(conf);
    if (!fs.exists(p)) {
      Set<String> currentSet=getReferencesToFilesToBeReplicated(conn);
      log.info("Current references {}",currentSet);
      log.info("Looking for reference to {}",replFile);
      log.info("Contains? {}",currentSet.contains(replFile));
      Assert.assertTrue("File does not exist anymore, it was likely incorrectly garbage collected: " + p,!currentSet.contains(replFile));
    }
  }
}

</code></pre>

<pre class="type-5 type-2 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void replicationTableCreated() throws AccumuloException, AccumuloSecurityException {
  Assert.assertTrue(getConnector().tableOperations().exists(ReplicationTable.NAME));
  Assert.assertEquals(ReplicationTable.ID,getConnector().tableOperations().tableIdMap().get(ReplicationTable.NAME));
}

</code></pre>

<pre class="type-5 type-3 type-2 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void verifyReplicationTableConfig() throws AccumuloException, TableNotFoundException, AccumuloSecurityException {
  TableOperations tops=getConnector().tableOperations();
  Map<String,EnumSet<IteratorScope>> iterators=tops.listIterators(ReplicationTable.NAME);
  Assert.assertEquals(1,iterators.size());
  Assert.assertTrue(iterators.containsKey(ReplicationTable.COMBINER_NAME));
  Assert.assertTrue(iterators.get(ReplicationTable.COMBINER_NAME).containsAll(EnumSet.allOf(IteratorScope.class)));
  for (  IteratorScope scope : EnumSet.allOf(IteratorScope.class)) {
    IteratorSetting is=tops.getIteratorSetting(ReplicationTable.NAME,ReplicationTable.COMBINER_NAME,scope);
    Assert.assertEquals(30,is.getPriority());
    Assert.assertEquals(StatusCombiner.class.getName(),is.getIteratorClass());
    Assert.assertEquals(1,is.getOptions().size());
    Assert.assertTrue(is.getOptions().containsKey("columns"));
    String cols=is.getOptions().get("columns");
    Column statusSectionCol=new Column(StatusSection.NAME);
    Column workSectionCol=new Column(WorkSection.NAME);
    Assert.assertEquals(ColumnSet.encodeColumns(statusSectionCol.getColumnFamily(),statusSectionCol.getColumnQualifier()) + "," + ColumnSet.encodeColumns(workSectionCol.getColumnFamily(),workSectionCol.getColumnQualifier()),cols);
  }
  boolean foundLocalityGroups=false;
  boolean foundLocalityGroupDef1=false;
  boolean foundLocalityGroupDef2=false;
  boolean foundFormatter=false;
  Joiner j=Joiner.on(",");
  Function<Text,String> textToString=new Function<Text,String>(){
    @Override public String apply(    Text text){
      return text.toString();
    }
  }
;
  for (  Entry<String,String> p : tops.getProperties(ReplicationTable.NAME)) {
    String key=p.getKey();
    String val=p.getValue();
    if (key.equals(Property.TABLE_FORMATTER_CLASS.getKey()) && val.equals(StatusFormatter.class.getName())) {
      foundFormatter=true;
    }
 else     if (key.equals(Property.TABLE_LOCALITY_GROUPS.getKey()) && val.equals(j.join(ReplicationTable.LOCALITY_GROUPS.keySet()))) {
      foundLocalityGroups=true;
    }
 else     if (key.startsWith(Property.TABLE_LOCALITY_GROUP_PREFIX.getKey())) {
      if (key.equals(Property.TABLE_LOCALITY_GROUP_PREFIX.getKey() + ReplicationTable.STATUS_LG_NAME) && val.equals(j.join(Iterables.transform(ReplicationTable.STATUS_LG_COLFAMS,textToString)))) {
        foundLocalityGroupDef1=true;
      }
 else       if (key.equals(Property.TABLE_LOCALITY_GROUP_PREFIX.getKey() + ReplicationTable.WORK_LG_NAME) && val.equals(j.join(Iterables.transform(ReplicationTable.WORK_LG_COLFAMS,textToString)))) {
        foundLocalityGroupDef2=true;
      }
    }
  }
  Assert.assertTrue(foundLocalityGroups);
  Assert.assertTrue(foundLocalityGroupDef1);
  Assert.assertTrue(foundLocalityGroupDef2);
  Assert.assertTrue(foundFormatter);
}

</code></pre>

<pre class="type-1 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test public void noDeadlock() throws Exception {
  final Connector conn=getConnector();
  ReplicationTable.setOnline(conn);
  conn.securityOperations().grantTablePermission("root",ReplicationTable.NAME,TablePermission.WRITE);
  conn.tableOperations().deleteRows(ReplicationTable.NAME,null,null);
  String table1="table1", table2="table2", table3="table3";
  conn.tableOperations().create(table1);
  conn.tableOperations().setProperty(table1,Property.TABLE_REPLICATION.getKey(),"true");
  conn.tableOperations().setProperty(table1,Property.TABLE_REPLICATION_TARGET.getKey() + "cluster1","1");
  conn.tableOperations().create(table2);
  conn.tableOperations().setProperty(table2,Property.TABLE_REPLICATION.getKey(),"true");
  conn.tableOperations().setProperty(table2,Property.TABLE_REPLICATION_TARGET.getKey() + "cluster1","1");
  conn.tableOperations().create(table3);
  conn.tableOperations().setProperty(table3,Property.TABLE_REPLICATION.getKey(),"true");
  conn.tableOperations().setProperty(table3,Property.TABLE_REPLICATION_TARGET.getKey() + "cluster1","1");
  writeSomeData(conn,table1,200,500);
  writeSomeData(conn,table2,200,500);
  writeSomeData(conn,table3,200,500);
  for (  String table : Arrays.asList(table1,table2,table3)) {
    conn.tableOperations().flush(table,null,null,true);
  }
  for (  String table : Arrays.asList(table1,table2,table3)) {
    conn.tableOperations().flush(table,null,null,true);
  }
  for (  String table : Arrays.asList(MetadataTable.NAME,table1,table2,table3)) {
    Iterators.size(conn.createScanner(table,Authorizations.EMPTY).iterator());
  }
}

</code></pre>

<pre class="type-9 type-8 type-3 type-7 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void filesClosedAfterUnused() throws Exception {
  Connector conn=getConnector();
  String table="table";
  conn.tableOperations().create(table);
  String tableId=conn.tableOperations().tableIdMap().get(table);
  Assert.assertNotNull(tableId);
  conn.tableOperations().setProperty(table,Property.TABLE_REPLICATION.getKey(),"true");
  conn.tableOperations().setProperty(table,Property.TABLE_REPLICATION_TARGET.getKey() + "cluster1","1");
  conn.instanceOperations().setProperty(Property.REPLICATION_PEERS.getKey() + "cluster1",ReplicaSystemFactory.getPeerConfigurationValue(MockReplicaSystem.class,"50000"));
  BatchWriter bw=conn.createBatchWriter(table,new BatchWriterConfig());
  Mutation m=new Mutation("one");
  m.put("","","");
  bw.addMutation(m);
  bw.close();
  bw=conn.createBatchWriter(table,new BatchWriterConfig());
  m=new Mutation("three");
  m.put("","","");
  bw.addMutation(m);
  bw.close();
  Scanner s=conn.createScanner(MetadataTable.NAME,Authorizations.EMPTY);
  s.fetchColumnFamily(TabletsSection.LogColumnFamily.NAME);
  s.setRange(TabletsSection.getRange(tableId));
  Set<String> wals=new HashSet<>();
  for (  Entry<Key,Value> entry : s) {
    LogEntry logEntry=LogEntry.fromKeyValue(entry.getKey(),entry.getValue());
    wals.add(new Path(logEntry.filename).toString());
  }
  log.warn("Found wals {}",wals);
  bw=conn.createBatchWriter(table,new BatchWriterConfig());
  m=new Mutation("three");
  byte[] bytes=new byte[1024 * 1024];
  m.put("1".getBytes(),new byte[0],bytes);
  m.put("2".getBytes(),new byte[0],bytes);
  m.put("3".getBytes(),new byte[0],bytes);
  m.put("4".getBytes(),new byte[0],bytes);
  m.put("5".getBytes(),new byte[0],bytes);
  bw.addMutation(m);
  bw.close();
  conn.tableOperations().flush(table,null,null,true);
  while (!ReplicationTable.isOnline(conn)) {
    sleepUninterruptibly(2,TimeUnit.SECONDS);
  }
  for (int i=0; i < 10; i++) {
    s=conn.createScanner(MetadataTable.NAME,Authorizations.EMPTY);
    s.fetchColumnFamily(LogColumnFamily.NAME);
    s.setRange(TabletsSection.getRange(tableId));
    for (    Entry<Key,Value> entry : s) {
      log.info(entry.getKey().toStringNoTruncate() + "=" + entry.getValue());
    }
    try {
      s=ReplicationTable.getScanner(conn);
      StatusSection.limit(s);
      Text buff=new Text();
      boolean allReferencedLogsClosed=true;
      int recordsFound=0;
      for (      Entry<Key,Value> e : s) {
        recordsFound++;
        allReferencedLogsClosed=true;
        StatusSection.getFile(e.getKey(),buff);
        String file=buff.toString();
        if (wals.contains(file)) {
          Status stat=Status.parseFrom(e.getValue().get());
          if (!stat.getClosed()) {
            log.info("{} wasn't closed",file);
            allReferencedLogsClosed=false;
          }
        }
      }
      if (recordsFound > 0 && allReferencedLogsClosed) {
        return;
      }
      Thread.sleep(2000);
    }
 catch (    RuntimeException e) {
      Throwable cause=e.getCause();
      if (cause instanceof AccumuloSecurityException) {
        AccumuloSecurityException ase=(AccumuloSecurityException)cause;
switch (ase.getSecurityErrorCode()) {
case PERMISSION_DENIED:
          Thread.sleep(2000);
        break;
default :
      throw e;
  }
}
}
}
Assert.fail("We had a file that was referenced but didn't get closed");
}

</code></pre>

<pre class="type-9 type-13 type-11 type-8 type-5 type-3 type-7 type-2 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions in iterations
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void replicatedStatusEntriesAreDeleted() throws Exception {
  getCluster().getClusterControl().stop(ServerType.GARBAGE_COLLECTOR);
  final Connector conn=getConnector();
  log.info("Got connector to MAC");
  String table1="table1";
  Assert.assertFalse(ReplicationTable.isOnline(conn));
  conn.tableOperations().create(table1);
  int attempts=5;
  while (attempts > 0) {
    try {
      conn.tableOperations().setProperty(table1,Property.TABLE_REPLICATION.getKey(),"true");
      conn.tableOperations().setProperty(table1,Property.TABLE_REPLICATION_TARGET.getKey() + "cluster1","4");
      conn.instanceOperations().setProperty(Property.REPLICATION_PEERS.getKey() + "cluster1",ReplicaSystemFactory.getPeerConfigurationValue(MockReplicaSystem.class,"1000"));
      attempts=0;
    }
 catch (    Exception e) {
      attempts--;
      if (attempts <= 0) {
        throw e;
      }
      sleepUninterruptibly(500,TimeUnit.MILLISECONDS);
    }
  }
  String tableId=conn.tableOperations().tableIdMap().get(table1);
  Assert.assertNotNull("Could not determine table id for " + table1,tableId);
  writeSomeData(conn,table1,2000,50);
  conn.tableOperations().flush(table1,null,null,true);
  boolean online=ReplicationTable.isOnline(conn);
  attempts=10;
  do {
    if (!online) {
      sleepUninterruptibly(1,TimeUnit.SECONDS);
      online=ReplicationTable.isOnline(conn);
      attempts--;
    }
  }
 while (!online && attempts > 0);
  Assert.assertTrue("Replication table did not exist",online);
  conn.securityOperations().grantTablePermission("root",ReplicationTable.NAME,TablePermission.WRITE);
  log.info("Checking for replication entries in replication");
  Scanner s;
  Set<String> entries=new HashSet<>();
  for (int i=0; i < 5; i++) {
    s=conn.createScanner(MetadataTable.NAME,Authorizations.EMPTY);
    s.setRange(ReplicationSection.getRange());
    entries.clear();
    for (    Entry<Key,Value> entry : s) {
      entries.add(entry.getKey().getRow().toString());
      log.info("{}={}",entry.getKey().toStringNoTruncate(),entry.getValue());
    }
    if (!entries.isEmpty()) {
      log.info("Replication entries {}",entries);
      break;
    }
    Thread.sleep(1000);
  }
  Assert.assertFalse("Did not find any replication entries in the replication table",entries.isEmpty());
  boolean notFound=true;
  for (int i=0; i < 10 && notFound; i++) {
    try {
      s=ReplicationTable.getScanner(conn);
      WorkSection.limit(s);
      Entry<Key,Value> e=Iterables.getOnlyElement(s);
      log.info("Found entry: " + e.getKey().toStringNoTruncate());
      Text expectedColqual=new ReplicationTarget("cluster1","4",tableId).toText();
      Assert.assertEquals(expectedColqual,e.getKey().getColumnQualifier());
      notFound=false;
    }
 catch (    NoSuchElementException e) {
    }
catch (    IllegalArgumentException e) {
      s=ReplicationTable.getScanner(conn);
      for (      Entry<Key,Value> content : s) {
        log.info(content.getKey().toStringNoTruncate() + " => " + content.getValue());
      }
      Assert.fail("Found more than one work section entry");
    }
catch (    RuntimeException e) {
      Throwable cause=e.getCause();
      if (cause instanceof AccumuloSecurityException) {
        AccumuloSecurityException sec=(AccumuloSecurityException)cause;
switch (sec.getSecurityErrorCode()) {
case PERMISSION_DENIED:
          log.warn("Sleeping because permission was denied");
        break;
default :
      throw e;
  }
}
 else {
  throw e;
}
}
Thread.sleep(2000);
}
if (notFound) {
s=ReplicationTable.getScanner(conn);
for (Entry<Key,Value> content : s) {
log.info(content.getKey().toStringNoTruncate() + " => " + ProtobufUtil.toString(Status.parseFrom(content.getValue().get())));
}
Assert.assertFalse("Did not find the work entry for the status entry",notFound);
}
log.info("Killing tserver");
cluster.getClusterControl().stop(ServerType.TABLET_SERVER);
log.info("Starting tserver");
cluster.getClusterControl().start(ServerType.TABLET_SERVER);
log.info("Waiting to read tables");
sleepUninterruptibly(2 * 3,TimeUnit.SECONDS);
for (String table : new String[]{MetadataTable.NAME,table1}) {
Iterators.size(conn.createScanner(table,Authorizations.EMPTY).iterator());
}
log.info("Recovered metadata:");
s=conn.createScanner(MetadataTable.NAME,Authorizations.EMPTY);
for (Entry<Key,Value> entry : s) {
log.info("{}={}",entry.getKey().toStringNoTruncate(),entry.getValue());
}
cluster.getClusterControl().start(ServerType.GARBAGE_COLLECTOR);
waitForGCLock(conn);
Thread.sleep(1000);
log.info("After GC");
s=conn.createScanner(MetadataTable.NAME,Authorizations.EMPTY);
for (Entry<Key,Value> entry : s) {
log.info("{}={}",entry.getKey().toStringNoTruncate(),entry.getValue());
}
log.info("Checking metadata table for replication entries");
Set<String> remaining=new HashSet<>();
for (int i=0; i < 10; i++) {
s=conn.createScanner(MetadataTable.NAME,Authorizations.EMPTY);
s.setRange(ReplicationSection.getRange());
remaining.clear();
for (Entry<Key,Value> e : s) {
remaining.add(e.getKey().getRow().toString());
}
remaining.retainAll(entries);
if (remaining.isEmpty()) {
break;
}
log.info("remaining {}",remaining);
Thread.sleep(2000);
log.info("");
}
Assert.assertTrue("Replication status messages were not cleaned up from metadata table",remaining.isEmpty());
int recordsFound=0;
for (int i=0; i < 30; i++) {
s=ReplicationTable.getScanner(conn);
recordsFound=0;
for (Entry<Key,Value> entry : s) {
recordsFound++;
log.info("{} {}",entry.getKey().toStringNoTruncate(),ProtobufUtil.toString(Status.parseFrom(entry.getValue().get())));
}
if (recordsFound <= 2) {
break;
}
 else {
Thread.sleep(1000);
log.info("");
}
}
Assert.assertTrue("Found unexpected replication records in the replication table",recordsFound <= 2);
}

</code></pre>

<pre class="type-9 type-11 type-8 type-5 type-3 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void replicationRecordsAreClosedAfterGarbageCollection() throws Exception {
  getCluster().getClusterControl().stop(ServerType.GARBAGE_COLLECTOR);
  final Connector conn=getConnector();
  ReplicationTable.setOnline(conn);
  conn.securityOperations().grantTablePermission("root",ReplicationTable.NAME,TablePermission.WRITE);
  conn.tableOperations().deleteRows(ReplicationTable.NAME,null,null);
  final AtomicBoolean keepRunning=new AtomicBoolean(true);
  final Set<String> metadataWals=new HashSet<>();
  Thread t=new Thread(new Runnable(){
    @Override public void run(){
      while (keepRunning.get()) {
        try {
          metadataWals.addAll(getLogs(conn).keySet());
        }
 catch (        Exception e) {
          log.error("Metadata table doesn't exist");
        }
      }
    }
  }
);
  t.start();
  String table1="table1", table2="table2", table3="table3";
  try {
    conn.tableOperations().create(table1);
    conn.tableOperations().setProperty(table1,Property.TABLE_REPLICATION.getKey(),"true");
    conn.tableOperations().setProperty(table1,Property.TABLE_REPLICATION_TARGET.getKey() + "cluster1","1");
    conn.instanceOperations().setProperty(Property.REPLICATION_PEERS.getKey() + "cluster1",ReplicaSystemFactory.getPeerConfigurationValue(MockReplicaSystem.class,null));
    writeSomeData(conn,table1,200,500);
    conn.tableOperations().create(table2);
    conn.tableOperations().setProperty(table2,Property.TABLE_REPLICATION.getKey(),"true");
    conn.tableOperations().setProperty(table2,Property.TABLE_REPLICATION_TARGET.getKey() + "cluster1","1");
    writeSomeData(conn,table2,200,500);
    conn.tableOperations().create(table3);
    conn.tableOperations().setProperty(table3,Property.TABLE_REPLICATION.getKey(),"true");
    conn.tableOperations().setProperty(table3,Property.TABLE_REPLICATION_TARGET.getKey() + "cluster1","1");
    writeSomeData(conn,table3,200,500);
    for (    String table : Arrays.asList(table1,table2,table3)) {
      conn.tableOperations().compact(table,null,null,true,true);
    }
  }
  finally {
    keepRunning.set(false);
    t.join(5000);
    Assert.assertFalse(t.isAlive());
  }
  cluster.getClusterControl().stop(ServerType.TABLET_SERVER);
  cluster.getClusterControl().start(ServerType.TABLET_SERVER);
  for (  String table : Arrays.asList(table1,table2,table3)) {
    Iterators.size(conn.createScanner(table,Authorizations.EMPTY).iterator());
  }
  Process gc=cluster.exec(SimpleGarbageCollector.class);
  waitForGCLock(conn);
  Thread.sleep(1000);
  log.info("GC is up and should have had time to run at least once by now");
  try {
    boolean allClosed=true;
    for (int i=0; i < 10; i++) {
      Scanner s=conn.createScanner(MetadataTable.NAME,Authorizations.EMPTY);
      s.setRange(Range.prefix(ReplicationSection.getRowPrefix()));
      Iterator<Entry<Key,Value>> iter=s.iterator();
      long recordsFound=0l;
      while (allClosed && iter.hasNext()) {
        Entry<Key,Value> entry=iter.next();
        String wal=entry.getKey().getRow().toString();
        if (metadataWals.contains(wal)) {
          Status status=Status.parseFrom(entry.getValue().get());
          log.info("{}={}",entry.getKey().toStringNoTruncate(),ProtobufUtil.toString(status));
          allClosed&=status.getClosed();
          recordsFound++;
        }
      }
      log.info("Found {} records from the metadata table",recordsFound);
      if (allClosed) {
        break;
      }
      sleepUninterruptibly(2,TimeUnit.SECONDS);
    }
    if (!allClosed) {
      Scanner s=conn.createScanner(MetadataTable.NAME,Authorizations.EMPTY);
      s.setRange(Range.prefix(ReplicationSection.getRowPrefix()));
      for (      Entry<Key,Value> entry : s) {
        log.info(entry.getKey().toStringNoTruncate() + " " + ProtobufUtil.toString(Status.parseFrom(entry.getValue().get())));
      }
      Assert.fail("Expected all replication records in the metadata table to be closed");
    }
    for (int i=0; i < 10; i++) {
      allClosed=true;
      Scanner s=ReplicationTable.getScanner(conn);
      Iterator<Entry<Key,Value>> iter=s.iterator();
      long recordsFound=0l;
      while (allClosed && iter.hasNext()) {
        Entry<Key,Value> entry=iter.next();
        String wal=entry.getKey().getRow().toString();
        if (metadataWals.contains(wal)) {
          Status status=Status.parseFrom(entry.getValue().get());
          log.info("{}={}",entry.getKey().toStringNoTruncate(),ProtobufUtil.toString(status));
          allClosed&=status.getClosed();
          recordsFound++;
        }
      }
      log.info("Found {} records from the replication table",recordsFound);
      if (allClosed) {
        break;
      }
      sleepUninterruptibly(3,TimeUnit.SECONDS);
    }
    if (!allClosed) {
      Scanner s=ReplicationTable.getScanner(conn);
      StatusSection.limit(s);
      for (      Entry<Key,Value> entry : s) {
        log.info(entry.getKey().toStringNoTruncate() + " " + TextFormat.shortDebugString(Status.parseFrom(entry.getValue().get())));
      }
      Assert.fail("Expected all replication records in the replication table to be closed");
    }
  }
  finally {
    gc.destroy();
    gc.waitFor();
  }
}

</code></pre>

<pre class="type-9 type-5 type-3 type-2 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void twoEntriesForTwoTables() throws Exception {
  Connector conn=getConnector();
  String table1="table1", table2="table2";
  Assert.assertFalse("Replication table already online at the beginning of the test",ReplicationTable.isOnline(conn));
  conn.tableOperations().create(table1);
  conn.tableOperations().create(table2);
  conn.securityOperations().grantTablePermission("root",ReplicationTable.NAME,TablePermission.READ);
  Thread.sleep(5000);
  conn.tableOperations().setProperty(table1,Property.TABLE_REPLICATION.getKey(),"true");
  Assert.assertFalse(ReplicationTable.isOnline(conn));
  writeSomeData(conn,table1,50,50);
  boolean online=ReplicationTable.isOnline(conn);
  int attempts=10;
  do {
    if (!online) {
      sleepUninterruptibly(5,TimeUnit.SECONDS);
      online=ReplicationTable.isOnline(conn);
      attempts--;
    }
  }
 while (!online && attempts > 0);
  Assert.assertTrue("Replication table did not exist",online);
  Assert.assertTrue(ReplicationTable.isOnline(conn));
  Scanner s=ReplicationTable.getScanner(conn);
  StatusSection.limit(s);
  for (int i=0; i < 5; i++) {
    if (Iterators.size(s.iterator()) == 1) {
      break;
    }
    Thread.sleep(1000);
  }
  Entry<Key,Value> entry=Iterators.getOnlyElement(s.iterator());
  Assert.assertEquals("Expected to find replication entry for " + table1,conn.tableOperations().tableIdMap().get(table1),entry.getKey().getColumnQualifier().toString());
  s.close();
  conn.tableOperations().setProperty(table2,Property.TABLE_REPLICATION.getKey(),"true");
  writeSomeData(conn,table2,50,50);
  Set<String> tableIds=Sets.newHashSet(conn.tableOperations().tableIdMap().get(table1),conn.tableOperations().tableIdMap().get(table2));
  Set<String> tableIdsForMetadata=Sets.newHashSet(tableIds);
  List<Entry<Key,Value>> records=new ArrayList<>();
  s=conn.createScanner(MetadataTable.NAME,Authorizations.EMPTY);
  s.setRange(MetadataSchema.ReplicationSection.getRange());
  for (  Entry<Key,Value> metadata : s) {
    records.add(metadata);
    log.debug("Meta: {} => {}",metadata.getKey().toStringNoTruncate(),metadata.getValue().toString());
  }
  Assert.assertEquals("Expected to find 2 records, but actually found " + records,2,records.size());
  for (  Entry<Key,Value> metadata : records) {
    Assert.assertTrue("Expected record to be in metadata but wasn't " + metadata.getKey().toStringNoTruncate() + ", tableIds remaining "+ tableIdsForMetadata,tableIdsForMetadata.remove(metadata.getKey().getColumnQualifier().toString()));
  }
  Assert.assertTrue("Expected that we had removed all metadata entries " + tableIdsForMetadata,tableIdsForMetadata.isEmpty());
  Thread.sleep(5000);
  s=ReplicationTable.getScanner(conn);
  StatusSection.limit(s);
  Iterator<Entry<Key,Value>> iter=s.iterator();
  Assert.assertTrue("Found no records in replication table",iter.hasNext());
  entry=iter.next();
  Assert.assertTrue("Expected to find element in replication table",tableIds.remove(entry.getKey().getColumnQualifier().toString()));
  Assert.assertTrue("Expected to find two elements in replication table, only found one ",iter.hasNext());
  entry=iter.next();
  Assert.assertTrue("Expected to find element in replication table",tableIds.remove(entry.getKey().getColumnQualifier().toString()));
  Assert.assertFalse("Expected to only find two elements in replication table",iter.hasNext());
}

</code></pre>

<pre class="type-9 type-13 type-11 type-8 type-5 type-3 type-7 type-2 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions in iterations
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void correctClusterNameInWorkEntry() throws Exception {
  Connector conn=getConnector();
  String table1="table1";
  Assert.assertFalse(ReplicationTable.isOnline(conn));
  conn.tableOperations().create(table1);
  int attempts=5;
  while (attempts > 0) {
    try {
      conn.tableOperations().setProperty(table1,Property.TABLE_REPLICATION.getKey(),"true");
      conn.tableOperations().setProperty(table1,Property.TABLE_REPLICATION_TARGET.getKey() + "cluster1","4");
      attempts=0;
    }
 catch (    Exception e) {
      attempts--;
      if (attempts <= 0) {
        throw e;
      }
      sleepUninterruptibly(500,TimeUnit.MILLISECONDS);
    }
  }
  writeSomeData(conn,table1,2000,50);
  conn.tableOperations().flush(table1,null,null,true);
  String tableId=conn.tableOperations().tableIdMap().get(table1);
  Assert.assertNotNull("Table ID was null",tableId);
  boolean online=ReplicationTable.isOnline(conn);
  attempts=5;
  do {
    if (!online) {
      sleepUninterruptibly(500,TimeUnit.MILLISECONDS);
      online=ReplicationTable.isOnline(conn);
      attempts--;
    }
  }
 while (!online && attempts > 0);
  Assert.assertTrue("Replication table did not exist",online);
  for (int i=0; i < 5 && !conn.securityOperations().hasTablePermission("root",ReplicationTable.NAME,TablePermission.READ); i++) {
    Thread.sleep(1000);
  }
  Assert.assertTrue(conn.securityOperations().hasTablePermission("root",ReplicationTable.NAME,TablePermission.READ));
  boolean notFound=true;
  Scanner s;
  for (int i=0; i < 10 && notFound; i++) {
    s=ReplicationTable.getScanner(conn);
    WorkSection.limit(s);
    try {
      Entry<Key,Value> e=Iterables.getOnlyElement(s);
      Text expectedColqual=new ReplicationTarget("cluster1","4",tableId).toText();
      Assert.assertEquals(expectedColqual,e.getKey().getColumnQualifier());
      notFound=false;
    }
 catch (    NoSuchElementException e) {
    }
catch (    IllegalArgumentException e) {
      s=ReplicationTable.getScanner(conn);
      for (      Entry<Key,Value> content : s) {
        log.info(content.getKey().toStringNoTruncate() + " => " + content.getValue());
      }
      Assert.fail("Found more than one work section entry");
    }
    Thread.sleep(500);
  }
  if (notFound) {
    s=ReplicationTable.getScanner(conn);
    for (    Entry<Key,Value> content : s) {
      log.info(content.getKey().toStringNoTruncate() + " => " + content.getValue());
    }
    Assert.assertFalse("Did not find the work entry for the status entry",notFound);
  }
}

</code></pre>

<pre class="type-5 type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
"></span><br>
@Test public void noRecordsWithoutReplication() throws Exception {
  Connector conn=getConnector();
  List<String> tables=new ArrayList<>();
  Assert.assertFalse(ReplicationTable.isOnline(conn));
  for (int i=0; i < 5; i++) {
    String name="table" + i;
    tables.add(name);
    conn.tableOperations().create(name);
  }
  Assert.assertFalse(ReplicationTable.isOnline(conn));
  for (  String table : tables) {
    writeSomeData(conn,table,5,5);
  }
  Assert.assertFalse(ReplicationTable.isOnline(conn));
  for (  String table : tables) {
    conn.tableOperations().compact(table,null,null,true,true);
  }
  Assert.assertFalse(ReplicationTable.isOnline(conn));
  for (  String table : tables) {
    conn.tableOperations().delete(table);
  }
  Assert.assertFalse(ReplicationTable.isOnline(conn));
}

</code></pre>

<pre class="type-9 type-13 type-11 type-5 type-3 type-7 type-2 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions in iterations
- Verifies assertions inside branch conditions
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void singleTableWithSingleTarget() throws Exception {
  getCluster().getClusterControl().stop(ServerType.GARBAGE_COLLECTOR);
  Connector conn=getConnector();
  String table1="table1";
  Assert.assertFalse(ReplicationTable.isOnline(conn));
  conn.tableOperations().create(table1);
  int attempts=10;
  while (attempts > 0) {
    try {
      conn.tableOperations().setProperty(table1,Property.TABLE_REPLICATION.getKey(),"true");
      conn.tableOperations().setProperty(table1,Property.TABLE_REPLICATION_TARGET.getKey() + "cluster1","4");
      conn.instanceOperations().setProperty(Property.REPLICATION_PEERS.getKey() + "cluster1",ReplicaSystemFactory.getPeerConfigurationValue(MockReplicaSystem.class,"100000"));
      break;
    }
 catch (    Exception e) {
      attempts--;
      if (attempts <= 0) {
        throw e;
      }
      sleepUninterruptibly(2,TimeUnit.SECONDS);
    }
  }
  writeSomeData(conn,table1,2000,50);
  boolean online=ReplicationTable.isOnline(conn);
  attempts=10;
  do {
    if (!online) {
      sleepUninterruptibly(2,TimeUnit.SECONDS);
      online=ReplicationTable.isOnline(conn);
      attempts--;
    }
  }
 while (!online && attempts > 0);
  Assert.assertTrue("Replication table was never created",online);
  for (int i=0; i < 10 && !conn.tableOperations().listIterators(ReplicationTable.NAME).keySet().contains(ReplicationTable.COMBINER_NAME); i++) {
    sleepUninterruptibly(2,TimeUnit.SECONDS);
  }
  Assert.assertTrue("Combiner was never set on replication table",conn.tableOperations().listIterators(ReplicationTable.NAME).keySet().contains(ReplicationTable.COMBINER_NAME));
  conn.tableOperations().flush(table1,null,null,true);
  Scanner s=ReplicationTable.getScanner(conn);
  StatusSection.limit(s);
  Entry<Key,Value> entry=null;
  Status expectedStatus=StatusUtil.openWithUnknownLength();
  attempts=10;
  while (null == entry && attempts > 0) {
    try {
      entry=Iterables.getOnlyElement(s);
      Status actual=Status.parseFrom(entry.getValue().get());
      if (actual.getInfiniteEnd() != expectedStatus.getInfiniteEnd()) {
        entry=null;
        Thread.sleep(1000);
      }
    }
 catch (    NoSuchElementException e) {
      entry=null;
      Thread.sleep(500);
    }
catch (    IllegalArgumentException e) {
      s=ReplicationTable.getScanner(conn);
      StatusSection.limit(s);
      for (      Entry<Key,Value> content : s) {
        log.info(content.getKey().toStringNoTruncate() + " => " + content.getValue());
      }
      throw e;
    }
 finally {
      attempts--;
    }
  }
  Assert.assertNotNull("Could not find expected entry in replication table",entry);
  Status actual=Status.parseFrom(entry.getValue().get());
  Assert.assertTrue("Expected to find a replication entry that is open with infinite length: " + ProtobufUtil.toString(actual),!actual.getClosed() && actual.getInfiniteEnd());
  boolean notFound=true;
  for (int i=0; i < 10 && notFound; i++) {
    s=ReplicationTable.getScanner(conn);
    WorkSection.limit(s);
    int elementsFound=Iterables.size(s);
    if (0 < elementsFound) {
      Assert.assertEquals(1,elementsFound);
      notFound=false;
    }
    Thread.sleep(500);
  }
  if (notFound) {
    s=ReplicationTable.getScanner(conn);
    for (    Entry<Key,Value> content : s) {
      log.info(content.getKey().toStringNoTruncate() + " => " + content.getValue());
    }
    Assert.assertFalse("Did not find the work entry for the status entry",notFound);
  }
  writeSomeData(conn,table1,3000,50);
  log.info("Issued compaction for table");
  conn.tableOperations().compact(table1,null,null,true,true);
  log.info("Compaction completed");
  Thread.sleep(5000);
  s=ReplicationTable.getScanner(conn);
  StatusSection.limit(s);
  int numRecords=0;
  for (  Entry<Key,Value> e : s) {
    numRecords++;
    log.info("Found status record {}\t{}",e.getKey().toStringNoTruncate(),ProtobufUtil.toString(Status.parseFrom(e.getValue().get())));
  }
  Assert.assertEquals(2,numRecords);
  notFound=true;
  for (int i=0; i < 10 && notFound; i++) {
    s=ReplicationTable.getScanner(conn);
    WorkSection.limit(s);
    int elementsFound=Iterables.size(s);
    if (2 == elementsFound) {
      notFound=false;
    }
    Thread.sleep(500);
  }
  if (notFound) {
    s=ReplicationTable.getScanner(conn);
    for (    Entry<Key,Value> content : s) {
      log.info(content.getKey().toStringNoTruncate() + " => " + content.getValue());
    }
    Assert.assertFalse("Did not find the work entries for the status entries",notFound);
  }
}

</code></pre>

<script>$(document).ready(function() {
  $('pre code').each(function(i, block) {
    hljs.highlightBlock(block);
  });
});</script>
