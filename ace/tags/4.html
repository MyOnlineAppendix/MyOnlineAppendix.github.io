<h3><span class=" glyphicon glyphicon-tag"/>&nbspExecutionTester</h3><kbd>Executes methods or other tests from the same test unit</kbd><br><br><br><h4 style="margin:0px">Class: org.apache.ace.agent.impl.ContentRangeInputStreamTest </h4><pre class="type-5 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies that exceptions are thrown during the test case execution">ExceptionVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies that exceptions are thrown during the test case execution
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Tests that we cannot read partial content without a Content-Range header.
 */
@Test(expectedExceptions=IOException.class) public void testReadPartialContentWithoutContentRangeHeaderFail() throws Exception {
  ConnectionHandler handler=new TestConnectionHandler(new FailingContentConnection(m_content,Failure.PARTIAL_NO_CONTENT_RANGE));
  ContentRangeInputStream is=null;
  try {
    is=new ContentRangeInputStream(handler,m_testURL);
    is.read();
  }
  finally {
    if (is != null) {
      is.close();
    }
  }
}

</code></pre>

<br>
<pre class="type-5 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies that exceptions are thrown during the test case execution">ExceptionVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies that exceptions are thrown during the test case execution
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Tests that we cannot read partial content if the content is not available.
 */
@Test(expectedExceptions=IOException.class) public void testReadPartialContentNotFoundFail() throws Exception {
  ConnectionHandler handler=new TestConnectionHandler(new FailingContentConnection(m_content,Failure.CONTENT_NOT_FOUND));
  ContentRangeInputStream is=null;
  try {
    is=new ContentRangeInputStream(handler,m_testURL);
    is.read();
  }
  finally {
    if (is != null) {
      is.close();
    }
  }
}

</code></pre>

<br>
<pre class="type-5 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies that exceptions are thrown during the test case execution">ExceptionVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies that exceptions are thrown during the test case execution
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Tests that we cannot read partial content if the server returns a complete body.
 */
@Test(expectedExceptions=IOException.class) public void testReadPartialContentWithCompleteBodyFail() throws Exception {
  ConnectionHandler handler=new TestConnectionHandler(new FailingContentConnection(m_content,Failure.PARTIAL_COMPLETE_BODY));
  ContentRangeInputStream is=null;
  try {
    is=new ContentRangeInputStream(handler,m_testURL);
    is.read(new byte[1024]);
    is.read(new byte[1024]);
  }
  finally {
    if (is != null) {
      is.close();
    }
  }
}

</code></pre>

<br>
<pre class="type-5 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies that exceptions are thrown during the test case execution">ExceptionVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies that exceptions are thrown during the test case execution
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Tests that we can read non-partial content and return the expected contents.
 */
@Test(expectedExceptions=IOException.class) public void testReadClosedStreamFail() throws Exception {
  ConnectionHandler handler=new TestConnectionHandler(new CompleteContentConnection(m_content,true));
  ContentRangeInputStream is=new ContentRangeInputStream(handler,m_testURL);
  is.close();
  is.read();
}

</code></pre>

<br>
<pre class="type-5 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies that exceptions are thrown during the test case execution">ExceptionVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies that exceptions are thrown during the test case execution
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Tests that we cannot read partial content if the server returns a complete body.
 */
@Test(expectedExceptions=IOException.class) public void testReadPartialContentWithChangingContentLengthFail() throws Exception {
  ConnectionHandler handler=new TestConnectionHandler(new FailingContentConnection(m_content,Failure.PARTIAL_CHANGING_CONTENT_LENGTH));
  ContentRangeInputStream is=null;
  try {
    is=new ContentRangeInputStream(handler,m_testURL);
    is.read(new byte[1024]);
    is.read(new byte[1024]);
  }
  finally {
    if (is != null) {
      is.close();
    }
  }
}

</code></pre>

<br>
<pre class="type-5 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies that exceptions are thrown during the test case execution">ExceptionVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies that exceptions are thrown during the test case execution
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Tests that we cannot read partial content if given a non-byte range value in the Content-Range header.
 */
@Test(expectedExceptions=IOException.class) public void testReadPartialContentWithoutByteRangeValueFail() throws Exception {
  ConnectionHandler handler=new TestConnectionHandler(new FailingContentConnection(m_content,Failure.PARTIAL_NON_BYTE_RANGE));
  ContentRangeInputStream is=null;
  try {
    is=new ContentRangeInputStream(handler,m_testURL);
    is.read();
  }
  finally {
    if (is != null) {
      is.close();
    }
  }
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Tests that the "Range" header is correctly set.
 */
@Test public void testRangeHeadersCorrectlySetOk() throws Exception {
  String content=m_content;
  PartialContentConnection conn;
  ContentRangeInputStream is;
  conn=new PartialContentConnection(content,false);
  is=new ContentRangeInputStream(new TestConnectionHandler(conn),m_testURL);
  is.read();
  is.close();
  assertRequestHeader(conn,"Range",null);
  conn=new PartialContentConnection(content,false);
  is=new ContentRangeInputStream(new TestConnectionHandler(conn),m_testURL,48);
  is.read();
  is.close();
  assertRequestHeader(conn,"Range","bytes=48-");
  conn=new PartialContentConnection(content,false);
  is=new ContentRangeInputStream(new TestConnectionHandler(conn),m_testURL,48,4752);
  is.read();
  is.close();
  assertRequestHeader(conn,"Range","bytes=48-4800");
}

</code></pre>

<br>
<pre class="type-5 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies that exceptions are thrown during the test case execution">ExceptionVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies that exceptions are thrown during the test case execution
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Tests that we cannot read partial content if the server is not available.
 */
@Test(expectedExceptions=RetryAfterException.class) public void testReadPartialContentServerUnavailableFail() throws Exception {
  ConnectionHandler handler=new TestConnectionHandler(new FailingContentConnection(m_content,Failure.SERVER_UNAVAILABLE));
  ContentRangeInputStream is=null;
  try {
    is=new ContentRangeInputStream(handler,m_testURL);
    is.read();
  }
  finally {
    if (is != null) {
      is.close();
    }
  }
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Tests that we call {@link InputStream#close()} multiple times.
 */
@Test public void testDoubleClosedStreamOk() throws Exception {
  ConnectionHandler handler=new TestConnectionHandler(new CompleteContentConnection(m_content,true));
  ContentRangeInputStream is=new ContentRangeInputStream(handler,m_testURL);
  is.close();
  is.close();
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.ace.agent.impl.CustomControllerTest </h4><pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test public void testDownloading() throws Exception {
  Version current=m_agentControl.getDeploymentHandler().getInstalledVersion();
  Version highest=m_agentControl.getDeploymentHandler().getAvailableVersions().last();
  if (highest.compareTo(current) > 0) {
    DownloadHandle handle=m_agentControl.getDeploymentHandler().getDownloadHandle(highest,true);
    Future<DownloadResult> future=handle.start(null);
    DownloadResult result=future.get();
    if (result.isComplete()) {
      InputStream inputStream=result.getInputStream();
      try {
        m_agentControl.getDeploymentHandler().install(inputStream);
      }
  finally {
        inputStream.close();
      }
    }
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.ace.agent.impl.DeploymentHandlerImplTest </h4><pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test public void testDeployPackage() throws Exception {
  DeploymentHandler deploymentHandler=m_agentContext.getHandler(DeploymentHandler.class);
  InputStream inputStream=deploymentHandler.getInputStream(m_version3,true);
  try {
    deploymentHandler.install(inputStream);
  }
  finally {
    inputStream.close();
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.ace.agent.impl.DownloadHandlerTest </h4><pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test public void testSuccessful_noresume_result() throws Exception {
  DownloadHandler downloadHandler=m_agentContext.getHandler(DownloadHandler.class);
  DownloadHandle handle=downloadHandler.getHandle(m_200url);
  handle.discard();
  Future<DownloadResult> result=handle.start(null);
  assertSuccessful(result,m_200digest);
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test public void testFailed404_noresume_result() throws Exception {
  DownloadHandler downloadHandler=m_agentContext.getHandler(DownloadHandler.class);
  DownloadHandle handle=downloadHandler.getHandle(m_404url);
  Future<DownloadResult> future=handle.start(null);
  assertIOException(future);
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test public void testSuccessful_resume_result() throws Exception {
  DownloadHandler downloadHandler=m_agentContext.getHandler(DownloadHandler.class);
  final DownloadHandle handle=downloadHandler.getHandle(m_200url);
  handle.discard();
  Future<DownloadResult> future=handle.start(new DownloadProgressListener(){
    @Override public void progress(    long read){
      Thread.currentThread().interrupt();
    }
  }
);
  assertStopped(future);
  assertSuccessful(handle.start(null),m_200digest);
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test public void testFailed503_noresume_result() throws Exception {
  DownloadHandler downloadHandler=m_agentContext.getHandler(DownloadHandler.class);
  DownloadHandle handle=downloadHandler.getHandle(m_503url);
  assertRetryException(handle.start(null));
  assertRetryException(handle.start(null));
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.ace.agent.impl.FeedbackHandlerImplTest </h4><pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test public void testSingleFeedbackChannelConfig() throws Exception {
  ConfigurationHandler configurationHandler=m_agentContextImpl.getHandler(ConfigurationHandler.class);
  configureAgent(configurationHandler,CONFIG_FEEDBACK_CHANNELS,AUDITLOG);
  FeedbackHandler feedbackHandler=m_agentContextImpl.getHandler(FeedbackHandler.class);
  assertFeedbackChannelNames(feedbackHandler,AUDITLOG);
  assertFeedbackChannelsPresent(feedbackHandler,AUDITLOG);
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test public void testUpdateConfigRemoveFeedbackChannel() throws Exception {
  ConfigurationHandler configurationHandler=m_agentContextImpl.getHandler(ConfigurationHandler.class);
  configureAgent(configurationHandler,CONFIG_FEEDBACK_CHANNELS,AUDITLOG_AND_CUSTOMCHANNEL);
  FeedbackHandler feedbackHandler=m_agentContextImpl.getHandler(FeedbackHandler.class);
  assertFeedbackChannelNames(feedbackHandler,AUDITLOG,CUSTOMCHANNEL);
  assertFeedbackChannelsPresent(feedbackHandler,AUDITLOG,CUSTOMCHANNEL);
  configureAgent(configurationHandler,CONFIG_FEEDBACK_CHANNELS,AUDITLOG);
  assertFeedbackChannelNames(feedbackHandler,AUDITLOG);
  assertFeedbackChannelsPresent(feedbackHandler,AUDITLOG);
  assertFeedbackChannelsNotPresent(feedbackHandler,CUSTOMCHANNEL);
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test public void testUpdateConfigAddFeedbackChannel() throws Exception {
  ConfigurationHandler configurationHandler=m_agentContextImpl.getHandler(ConfigurationHandler.class);
  configureAgent(configurationHandler,CONFIG_FEEDBACK_CHANNELS,AUDITLOG);
  FeedbackHandler feedbackHandler=m_agentContextImpl.getHandler(FeedbackHandler.class);
  assertFeedbackChannelNames(feedbackHandler,AUDITLOG);
  assertFeedbackChannelsPresent(feedbackHandler,AUDITLOG);
  assertFeedbackChannelsNotPresent(feedbackHandler,CUSTOMCHANNEL);
  configureAgent(configurationHandler,CONFIG_FEEDBACK_CHANNELS,AUDITLOG_AND_CUSTOMCHANNEL);
  assertFeedbackChannelNames(feedbackHandler,AUDITLOG,CUSTOMCHANNEL);
  assertFeedbackChannelsPresent(feedbackHandler,AUDITLOG,CUSTOMCHANNEL);
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Tests that there is always a default channel registered when starting the agent.
 */
@Test public void testDefaultFeedbackChannelPresent() throws Exception {
  FeedbackHandler feedbackHandler=m_agentContextImpl.getHandler(FeedbackHandler.class);
  assertFeedbackChannelNames(feedbackHandler,AUDITLOG);
  assertFeedbackChannelsPresent(feedbackHandler,AUDITLOG);
  assertFeedbackChannelsNotPresent(feedbackHandler,NON_EXISTING_CHANNEL);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.ace.agent.impl.FeedbackStoreTest </h4><pre class="type-11 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Invokes logging operations">Logger</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Invokes logging operations
- Executes methods or other tests from the same test unit
"></span><br>
@Test public void testTimedWrite() throws Exception {
  File storeFile=File.createTempFile("feedback",".store");
  storeFile.deleteOnExit();
  final int recordCount=1000000;
  final FeedbackStore store=new FeedbackStore(storeFile,1);
  long start=System.nanoTime();
  for (int i=0; i < recordCount; i++) {
    store.append(i,"Hello World!".getBytes());
  }
  long end=System.nanoTime();
  System.out.printf("Writing %d records took %.3f ms.%n",recordCount,(end - start) / 1.0e6);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.ace.authentication.impl.AuthenticationServiceImplTest </h4><pre class="type-5 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies that exceptions are thrown during the test case execution">ExceptionVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies that exceptions are thrown during the test case execution
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Tests that an exception is thrown if no context is given.
 */
@Test(groups={UNIT},expectedExceptions=IllegalArgumentException.class) public void testAuthenticateFailsWithoutContext(){
  new AuthenticationServiceImpl().authenticate();
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Tests that without any authentication processors, no authentication will take place.
 */
@Test(groups={UNIT}) public void testAuthenticateFailsWithoutAuthProcessors(){
  assert createAuthenticationService().authenticate("foo","bar") == null;
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Tests that with a single authentication processors, authentication will take place if it is given the correct context.
 */
@Test(groups={UNIT}) public void testAuthenticateSucceedsWithSingleAuthProcessorAndCorrectContext(){
  AuthenticationServiceImpl authService=createAuthenticationService();
  User user=mock(User.class);
  AuthenticationProcessor authProc=mock(AuthenticationProcessor.class);
  when(authProc.canHandle(anyString())).thenReturn(Boolean.TRUE);
  when(authProc.authenticate(Mockito.<UserAdmin>any(),eq("foo"))).thenReturn(user);
  registerAuthProcessor(authService,authProc);
  assert authService.authenticate("foo") != null;
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Tests that with multiple authentication processors, authentication will take place if it is given the correct context.
 */
@Test(groups={UNIT}) public void testAuthenticateSucceedsWithMultipleAuthProcessors(){
  Date now=new Date();
  User user1=mock(User.class);
  User user2=mock(User.class);
  AuthenticationProcessor authProc1=mock(AuthenticationProcessor.class);
  when(authProc1.canHandle(any())).thenAnswer(new Answer<Boolean>(){
    public Boolean answer(    InvocationOnMock invocation) throws Throwable {
      Object[] args=invocation.getArguments();
      return (args.length == 1 && args[0] instanceof Date);
    }
  }
);
  when(authProc1.authenticate(Mockito.<UserAdmin>any(),eq(now))).thenReturn(user1);
  AuthenticationProcessor authProc2=mock(AuthenticationProcessor.class);
  when(authProc2.canHandle(anyString())).thenAnswer(new Answer<Boolean>(){
    public Boolean answer(    InvocationOnMock invocation) throws Throwable {
      Object[] args=invocation.getArguments();
      return (args.length == 1 && args[0] instanceof String);
    }
  }
);
  when(authProc2.authenticate(Mockito.<UserAdmin>any(),eq("foo"))).thenReturn(user2);
  AuthenticationServiceImpl authService=createAuthenticationService();
  registerAuthProcessor(authService,authProc1);
  registerAuthProcessor(authService,authProc2);
  User result=authService.authenticate("foo");
  assert result != null;
  assert user2 == result;
  result=authService.authenticate(now);
  assert result != null;
  assert user1 == result;
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Tests that with a single authentication processors, no authentication will take place if it is the wrong context.
 */
@Test(groups={UNIT}) public void testAuthenticateFailsWithSingleAuthProcessorAndWrongContext(){
  AuthenticationServiceImpl authService=createAuthenticationService();
  AuthenticationProcessor authProc=mock(AuthenticationProcessor.class);
  when(authProc.canHandle(anyString())).thenReturn(Boolean.TRUE);
  registerAuthProcessor(authService,authProc);
  assert authService.authenticate("foo","bar") == null;
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Tests that with multiple authentication processors, the correct ones are returned based on the given context.
 */
@Test(groups={UNIT}) public void testGetProcessorsSelectsCorrectProcessorsBasedOnContext(){
  Date now=new Date();
  User user1=mock(User.class);
  User user2=mock(User.class);
  AuthenticationProcessor authProc1=mock(AuthenticationProcessor.class);
  when(authProc1.canHandle(any())).thenAnswer(new Answer<Boolean>(){
    public Boolean answer(    InvocationOnMock invocation) throws Throwable {
      Object[] args=invocation.getArguments();
      return (args.length == 1 && args[0] instanceof Date);
    }
  }
);
  when(authProc1.authenticate(Mockito.<UserAdmin>any(),eq(now))).thenReturn(user1);
  AuthenticationProcessor authProc2=mock(AuthenticationProcessor.class);
  when(authProc2.canHandle(anyString())).thenAnswer(new Answer<Boolean>(){
    public Boolean answer(    InvocationOnMock invocation) throws Throwable {
      Object[] args=invocation.getArguments();
      return (args.length == 1 && args[0] instanceof String);
    }
  }
);
  when(authProc2.authenticate(Mockito.<UserAdmin>any(),eq("foo"))).thenReturn(user2);
  AuthenticationServiceImpl authService=createAuthenticationService();
  registerAuthProcessor(authService,authProc1);
  registerAuthProcessor(authService,authProc2);
  List<AuthenticationProcessor> processors=authService.getProcessors("foo");
  assert processors != null;
  assert 1 == processors.size();
  processors=authService.getProcessors(now);
  assert processors != null;
  assert 1 == processors.size();
  processors=authService.getProcessors(new Object());
  assert processors != null;
  assert processors.isEmpty();
}

</code></pre>

<br>
<pre class="type-5 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies that exceptions are thrown during the test case execution">ExceptionVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies that exceptions are thrown during the test case execution
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Tests that an exception is thrown if a null context is given.
 */
@Test(groups={UNIT},expectedExceptions=IllegalArgumentException.class) public void testAuthenticateFailsWithNullContext(){
  new AuthenticationServiceImpl().authenticate((Object[])null);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.ace.authentication.processor.basicauth.BasicHttpAuthenticationProcessorTest </h4><pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Tests that updated does not throw an exception for a correct configuration.
 */
@Test(groups={UNIT}) public void testUpdatedDoesAcceptCorrectProperties() throws ConfigurationException {
  final String keyUsername="foo";
  final String keyPassword="bar";
  Dictionary<String,Object> props=new Hashtable<>();
  props.put(PROPERTY_KEY_USERNAME,keyUsername);
  props.put(PROPERTY_KEY_PASSWORD,keyPassword);
  BasicHttpAuthenticationProcessor processor=new BasicHttpAuthenticationProcessor();
  processor.updated(props);
  when(m_servletRequest.getHeader(AUTHORIZATION_HEADER)).thenReturn(createAuthHeaderValue("bob:secret"));
  User user=mock(User.class);
  when(user.getName()).thenReturn("bob");
  when(user.hasCredential(eq(keyPassword),eq("secret"))).thenReturn(Boolean.TRUE);
  when(m_userAdmin.getUser(eq(keyUsername),eq("bob"))).thenReturn(user);
  User result=processor.authenticate(m_userAdmin,m_servletRequest);
  assert result != null : "Expected a valid user to be returned!";
  assert "bob".equals(user.getName()) : "Expected user bob to be returned!";
}

</code></pre>

<br>
<pre class="type-5 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies that exceptions are thrown during the test case execution">ExceptionVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies that exceptions are thrown during the test case execution
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Tests that a class cast exception is thrown for invalid context when calling authenticate.
 */
@Test(groups={UNIT},expectedExceptions=ClassCastException.class) public void testAuthenticateThrowsClassCastForInvalidContext(){
  new BasicHttpAuthenticationProcessor().authenticate(m_userAdmin,new Object());
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Tests that canHandle yields false for any object other than {@link HttpServletRequest}.
 */
@Test(groups={UNIT}) public void testCanHandleDoesNotAcceptUnhandledContext(){
  assert new BasicHttpAuthenticationProcessor().canHandle(new Object()) == false;
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Tests that canHandle yields false for any object other than {@link HttpServletRequest}.
 */
@Test(groups={UNIT}) public void testCanHandleDoesAcceptServletRequest(){
  assert new BasicHttpAuthenticationProcessor().canHandle(mock(HttpServletRequest.class));
}

</code></pre>

<br>
<pre class="type-5 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies that exceptions are thrown during the test case execution">ExceptionVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies that exceptions are thrown during the test case execution
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Tests that updated throws an exception for missing "key.username" property. 
 */
@Test(groups={UNIT},expectedExceptions=ConfigurationException.class) public void testUpdatedDoesNotAcceptEmptyKeyUsername() throws ConfigurationException {
  Dictionary<String,Object> props=new Hashtable<>();
  props.put(PROPERTY_KEY_USERNAME,"");
  props.put(PROPERTY_KEY_PASSWORD,"foo");
  new BasicHttpAuthenticationProcessor().updated(props);
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Tests that a known user with an invalid password will yield null.
 */
@Test(groups={UNIT}) public void testAuthenticateKnownUserWithInvalidPasswordYieldsNull(){
  when(m_servletRequest.getHeader(AUTHORIZATION_HEADER)).thenReturn(createAuthHeaderValue("bob:secret"));
  User user=mock(User.class);
  when(user.getName()).thenReturn("bob");
  when(user.hasCredential(eq("password"),eq("otherSecret"))).thenReturn(Boolean.TRUE);
  when(m_userAdmin.getUser(eq("username"),eq("bob"))).thenReturn(user);
  User result=new BasicHttpAuthenticationProcessor().authenticate(m_userAdmin,m_servletRequest);
  assert result == null : "Expected no result!";
}

</code></pre>

<br>
<pre class="type-5 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies that exceptions are thrown during the test case execution">ExceptionVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies that exceptions are thrown during the test case execution
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Tests that canHandle throws an {@link IllegalArgumentException} for an empty context.
 */
@Test(groups={UNIT},expectedExceptions=IllegalArgumentException.class) public void testCanHandleDoesNotAcceptEmptyArray(){
  new BasicHttpAuthenticationProcessor().canHandle(new Object[0]);
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Tests that a non Base64 authentication header will yield null.
 */
@Test(groups={UNIT}) public void testAuthenticateNonBase64AuthenticationHeaderYieldsNull(){
  when(m_servletRequest.getHeader(AUTHORIZATION_HEADER)).thenReturn("foo");
  User result=new BasicHttpAuthenticationProcessor().authenticate(m_userAdmin,m_servletRequest);
  assert result == null : "Expected no result!";
}

</code></pre>

<br>
<pre class="type-5 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies that exceptions are thrown during the test case execution">ExceptionVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies that exceptions are thrown during the test case execution
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Tests that updated throws an exception for missing "key.password" property. 
 */
@Test(groups={UNIT},expectedExceptions=ConfigurationException.class) public void testUpdatedDoesNotAcceptMissingKeyPassword() throws ConfigurationException {
  Dictionary<String,Object> props=new Hashtable<>();
  props.put(PROPERTY_KEY_USERNAME,"foo");
  new BasicHttpAuthenticationProcessor().updated(props);
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Tests that an invalid authentication header will yield null.
 */
@Test(groups={UNIT}) public void testAuthenticateInvalidAuthenticationHeaderYieldsNull(){
  when(m_servletRequest.getHeader(AUTHORIZATION_HEADER)).thenReturn(createAuthHeaderValue("bob"));
  User user=mock(User.class);
  when(user.getName()).thenReturn("bob");
  when(user.hasCredential(eq("password"),eq("secret"))).thenReturn(Boolean.TRUE);
  when(m_userAdmin.getUser(eq("username"),eq("bob"))).thenReturn(user);
  User result=new BasicHttpAuthenticationProcessor().authenticate(m_userAdmin,m_servletRequest);
  assert result == null : "Expected no result!";
}

</code></pre>

<br>
<pre class="type-5 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies that exceptions are thrown during the test case execution">ExceptionVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies that exceptions are thrown during the test case execution
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Tests that canHandle throws an {@link IllegalArgumentException} for a null context.
 */
@Test(groups={UNIT},expectedExceptions=IllegalArgumentException.class) public void testCanHandleDoesNotAcceptNull(){
  new BasicHttpAuthenticationProcessor().canHandle((Object[])null);
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Tests that an unknown user will yield null.
 */
@Test(groups={UNIT}) public void testAuthenticateUnknownUserYieldsNull(){
  when(m_servletRequest.getHeader(AUTHORIZATION_HEADER)).thenReturn(createAuthHeaderValue("alice:secret"));
  User result=new BasicHttpAuthenticationProcessor().authenticate(m_userAdmin,m_servletRequest);
  assert result == null : "Expected no result!";
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Tests that a known user will not yield null.
 */
@Test(groups={UNIT}) public void testAuthenticateKnownUserYieldsValidResult(){
  when(m_servletRequest.getHeader(AUTHORIZATION_HEADER)).thenReturn(createAuthHeaderValue("bob:secret"));
  User user=mock(User.class);
  when(user.getName()).thenReturn("bob");
  when(user.hasCredential(eq("password"),eq("secret"))).thenReturn(Boolean.TRUE);
  when(m_userAdmin.getUser(eq("username"),eq("bob"))).thenReturn(user);
  User result=new BasicHttpAuthenticationProcessor().authenticate(m_userAdmin,m_servletRequest);
  assert result != null : "Expected a valid user to be returned!";
  assert "bob".equals(user.getName()) : "Expected user bob to be returned!";
}

</code></pre>

<br>
<pre class="type-5 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies that exceptions are thrown during the test case execution">ExceptionVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies that exceptions are thrown during the test case execution
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Tests that updated throws an exception for missing "key.username" property. 
 */
@Test(groups={UNIT},expectedExceptions=ConfigurationException.class) public void testUpdatedDoesNotAcceptMissingKeyUsername() throws ConfigurationException {
  Dictionary<String,Object> props=new Hashtable<>();
  props.put(PROPERTY_KEY_PASSWORD,"foo");
  new BasicHttpAuthenticationProcessor().updated(props);
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Tests that a null authentication header will yield null.
 */
@Test(groups={UNIT}) public void testAuthenticateEmptyAuthenticationHeaderYieldsNull(){
  User result=new BasicHttpAuthenticationProcessor().authenticate(m_userAdmin,m_servletRequest);
  assert result == null : "Expected no result!";
}

</code></pre>

<br>
<pre class="type-5 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies that exceptions are thrown during the test case execution">ExceptionVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies that exceptions are thrown during the test case execution
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Tests that updated throws an exception for missing "key.password" property. 
 */
@Test(groups={UNIT},expectedExceptions=ConfigurationException.class) public void testUpdatedDoesNotAcceptEmptyKeyPassword() throws ConfigurationException {
  Dictionary<String,Object> props=new Hashtable<>();
  props.put(PROPERTY_KEY_USERNAME,"foo");
  props.put(PROPERTY_KEY_PASSWORD,"");
  new BasicHttpAuthenticationProcessor().updated(props);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.ace.authentication.processor.clientcert.ClientCertAuthenticationProcessorTest </h4><pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Tests that authenticating a known user with a valid certificate will not yield null.
 */
@Test(groups={UNIT}) public void testAuthenticateKnownUserYieldsValidResult(){
  X509Certificate[] certChain=createValidCertificateChain("bob");
  when(m_servletRequest.getAttribute(ATTRIBUTE_X509_CERTIFICATE)).thenReturn(certChain);
  User user=mock(User.class);
  when(user.getName()).thenReturn("bob");
  when(m_userAdmin.getUser(eq("username"),eq("bob"))).thenReturn(user);
  User result=createAuthorizationProcessor().authenticate(m_userAdmin,m_servletRequest);
  assert result != null : "Expected a valid user to be returned!";
  assert "bob".equals(user.getName()) : "Expected bob to be returned as user!";
}

</code></pre>

<br>
<pre class="type-5 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies that exceptions are thrown during the test case execution">ExceptionVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies that exceptions are thrown during the test case execution
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Tests that updated throws an exception for missing "username match policy" property.
 */
@Test(groups={UNIT},expectedExceptions=ConfigurationException.class) public void testUpdatedDoesNotAcceptMissingMatchPolicy() throws ConfigurationException {
  Dictionary<String,Object> props=new Hashtable<>();
  props.put(PROPERTY_USERNAME_LOOKUPKEY,"foo");
  props.put(PROPERTY_VERIFY_CERT_VALIDITY,"true");
  createAuthorizationProcessor().updated(props);
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Tests that authenticating a known user with an invalid (expired) certificate will yield null.
 */
@Test(groups={UNIT}) public void testAuthenticateKnownUserWithExpiredCertificateYieldsNull(){
  X509Certificate[] certificateChain=createExpiredCertificateChain("bob");
  PublicKey publickey=certificateChain[0].getPublicKey();
  when(m_servletRequest.getAttribute(ATTRIBUTE_X509_CERTIFICATE)).thenReturn(certificateChain);
  User user=mock(User.class);
  when(user.getName()).thenReturn("bob");
  when(user.hasCredential(eq("publickey"),eq(publickey.getEncoded()))).thenReturn(Boolean.TRUE);
  when(m_userAdmin.getUser(eq("username"),eq("bob"))).thenReturn(user);
  User result=createAuthorizationProcessor().authenticate(m_userAdmin,m_servletRequest);
  assert result == null : "Did not expect a valid user to be returned!";
}

</code></pre>

<br>
<pre class="type-5 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies that exceptions are thrown during the test case execution">ExceptionVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies that exceptions are thrown during the test case execution
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Tests that updated throws an exception for missing "verify cert validity" property.
 */
@Test(groups={UNIT},expectedExceptions=ConfigurationException.class) public void testUpdatedDoesNotAcceptMissingVerifyCertValidity() throws ConfigurationException {
  Dictionary<String,Object> props=new Hashtable<>();
  props.put(PROPERTY_USERNAME_LOOKUPKEY,"foo");
  props.put(PROPERTY_USERNAME_MATCH_POLICY,"foo");
  createAuthorizationProcessor().updated(props);
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Tests that updated does not throw an exception for a correct configuration.
 */
@Test(groups={UNIT}) public void testUpdatedDoesAcceptCorrectProperties() throws ConfigurationException {
  final String lookupKey="anyKey";
  final String matchPolicy="cn";
  Dictionary<String,Object> props=new Hashtable<>();
  props.put(PROPERTY_USERNAME_LOOKUPKEY,lookupKey);
  props.put(PROPERTY_USERNAME_MATCH_POLICY,matchPolicy);
  props.put(PROPERTY_VERIFY_CERT_VALIDITY,"true");
  ClientCertAuthenticationProcessor processor=createAuthorizationProcessor();
  processor.updated(props);
  X509Certificate[] certificateChain=createValidCertificateChain("alice");
  when(m_servletRequest.getAttribute(ATTRIBUTE_X509_CERTIFICATE)).thenReturn(certificateChain);
  User user=mock(User.class);
  when(user.getName()).thenReturn("alice");
  when(m_userAdmin.getUser(eq(lookupKey),eq("alice"))).thenReturn(user);
  User result=processor.authenticate(m_userAdmin,m_servletRequest);
  assert result != null : "Expected a valid user to be returned!";
  assert "alice".equals(user.getName()) : "Expected alice to be returned as user!";
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Tests that canHandle yields false for any object other than {@link HttpServletRequest}.
 */
@Test(groups={UNIT}) public void testCanHandleDoesAcceptServletRequest(){
  when(m_servletRequest.getAttribute(ATTRIBUTE_X509_CERTIFICATE)).thenReturn(createValidCertificateChain("alice"));
  assert createAuthorizationProcessor().canHandle(m_servletRequest);
}

</code></pre>

<br>
<pre class="type-5 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies that exceptions are thrown during the test case execution">ExceptionVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies that exceptions are thrown during the test case execution
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Tests that canHandle throws an {@link IllegalArgumentException} for an empty context.
 */
@Test(groups={UNIT},expectedExceptions=IllegalArgumentException.class) public void testCanHandleDoesNotAcceptEmptyArray(){
  createAuthorizationProcessor().canHandle(new Object[0]);
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Tests that an empty certificate chain will yield null.
 */
@Test(groups={UNIT}) public void testAuthenticateEmptyCertificateChainYieldsNull(){
  when(m_servletRequest.getAttribute(ATTRIBUTE_X509_CERTIFICATE)).thenReturn(new X509Certificate[0]);
  User result=createAuthorizationProcessor().authenticate(m_userAdmin,m_servletRequest);
  assert result == null : "Did not expect a valid user to be returned!";
}

</code></pre>

<br>
<pre class="type-5 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies that exceptions are thrown during the test case execution">ExceptionVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies that exceptions are thrown during the test case execution
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Tests that a class cast exception is thrown for invalid context when calling authenticate.
 */
@Test(groups={UNIT},expectedExceptions=ClassCastException.class) public void testAuthenticateThrowsClassCastForInvalidContext(){
  createAuthorizationProcessor().authenticate(m_userAdmin,new Object());
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Tests that an unknown user will yield null.
 */
@Test(groups={UNIT}) public void testAuthenticateUnknownUserYieldsNull(){
  when(m_servletRequest.getAttribute(ATTRIBUTE_X509_CERTIFICATE)).thenReturn(createValidCertificateChain("bob"));
  User result=createAuthorizationProcessor().authenticate(m_userAdmin,m_servletRequest);
  assert result == null : "Did not expect a valid user to be returned!";
}

</code></pre>

<br>
<pre class="type-5 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies that exceptions are thrown during the test case execution">ExceptionVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies that exceptions are thrown during the test case execution
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Tests that updated throws an exception for missing "username match policy" property.
 */
@Test(groups={UNIT},expectedExceptions=ConfigurationException.class) public void testUpdatedDoesNotAcceptEmptyMatchPolicy() throws ConfigurationException {
  Dictionary<String,Object> props=new Hashtable<>();
  props.put(PROPERTY_USERNAME_LOOKUPKEY,"foo");
  props.put(PROPERTY_USERNAME_MATCH_POLICY,"");
  props.put(PROPERTY_VERIFY_CERT_VALIDITY,"true");
  createAuthorizationProcessor().updated(props);
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Tests that authenticating a known user with a valid certificate chain will not yield null.
 */
@Test(groups={UNIT}) public void testAuthenticateKnownUserWithValidCertificateChainYieldsValidResult() throws ConfigurationException {
  ClientCertAuthenticationProcessor processor=createAuthorizationProcessor();
  final String lookupKey="anyKey";
  final String matchPolicy="dn";
  Dictionary<String,Object> props=new Hashtable<>();
  props.put(PROPERTY_USERNAME_LOOKUPKEY,lookupKey);
  props.put(PROPERTY_USERNAME_MATCH_POLICY,matchPolicy);
  props.put(PROPERTY_VERIFY_CERT_VALIDITY,"true");
  processor.updated(props);
  X509Certificate[] certChain=createValidCertificateChainWithDN("cn=Alice,dc=acme,dc=corp","cn=Fido,ou=dev,dc=acme,dc=corp","cn=Bob,ou=dev,dc=acme,dc=corp");
  when(m_servletRequest.getAttribute(ATTRIBUTE_X509_CERTIFICATE)).thenReturn(certChain);
  User user=mock(User.class);
  when(user.getName()).thenReturn("bob");
  when(m_userAdmin.getUser(eq(lookupKey),eq("DC=corp,DC=acme,OU=dev,CN=Bob"))).thenReturn(user);
  User result=processor.authenticate(m_userAdmin,m_servletRequest);
  assert result != null : "Expected a valid user to be returned!";
  assert "bob".equals(user.getName()) : "Expected bob to be returned as user!";
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Tests that canHandle yields false for any object other than {@link HttpServletRequest}.
 */
@Test(groups={UNIT}) public void testCanHandleDoesNotAcceptUnhandledContext(){
  assert createAuthorizationProcessor().canHandle(new Object()) == false;
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Tests that authenticating a known user with an invalid (not valid) certificate will yield null.
 */
@Test(groups={UNIT}) public void testAuthenticateKnownUserWithNotValidCertificateYieldsNull(){
  X509Certificate[] certificateChain=createExpiredCertificateChain("bob");
  PublicKey publickey=certificateChain[0].getPublicKey();
  when(m_servletRequest.getAttribute(ATTRIBUTE_X509_CERTIFICATE)).thenReturn(createNotValidCertificateChain("bob"));
  User user=mock(User.class);
  when(user.getName()).thenReturn("bob");
  when(user.hasCredential(eq("publickey"),eq(publickey.getEncoded()))).thenReturn(Boolean.TRUE);
  when(m_userAdmin.getUser(eq("username"),eq("bob"))).thenReturn(user);
  User result=createAuthorizationProcessor().authenticate(m_userAdmin,m_servletRequest);
  assert result == null : "Did not expect a valid user to be returned!";
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Tests that a missing cipher suite header will the authenticate method to yield null.
 */
@Test(groups={UNIT}) public void testAuthenticateMissingCipherSuiteHeaderYieldsNull(){
  when(m_servletRequest.getAttribute(ATTRIBUTE_CIPHER_SUITE)).thenReturn(null);
  when(m_servletRequest.getAttribute(ATTRIBUTE_X509_CERTIFICATE)).thenReturn(createValidCertificateChain("bob"));
  User result=createAuthorizationProcessor().authenticate(m_userAdmin,m_servletRequest);
  assert result == null : "Did not expect a valid user to be returned!";
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Tests that a null certificate chain will yield null.
 */
@Test(groups={UNIT}) public void testAuthenticateNoCertificateChainYieldsNull(){
  User result=createAuthorizationProcessor().authenticate(m_userAdmin,m_servletRequest);
  assert result == null : "Did not expect a valid user to be returned!";
}

</code></pre>

<br>
<pre class="type-5 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies that exceptions are thrown during the test case execution">ExceptionVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies that exceptions are thrown during the test case execution
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Tests that updated throws an exception for missing "username lookup key" property.
 */
@Test(groups={UNIT},expectedExceptions=ConfigurationException.class) public void testUpdatedDoesNotAcceptEmptyLookupKey() throws ConfigurationException {
  Dictionary<String,Object> props=new Hashtable<>();
  props.put(PROPERTY_USERNAME_LOOKUPKEY,"");
  props.put(PROPERTY_USERNAME_MATCH_POLICY,"foo");
  props.put(PROPERTY_VERIFY_CERT_VALIDITY,"true");
  createAuthorizationProcessor().updated(props);
}

</code></pre>

<br>
<pre class="type-5 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies that exceptions are thrown during the test case execution">ExceptionVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies that exceptions are thrown during the test case execution
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Tests that updated throws an exception for missing "verify cert validity" property.
 */
@Test(groups={UNIT},expectedExceptions=ConfigurationException.class) public void testUpdatedDoesNotAcceptEmptyVerifyCertValidity() throws ConfigurationException {
  Dictionary<String,Object> props=new Hashtable<>();
  props.put(PROPERTY_USERNAME_LOOKUPKEY,"foo");
  props.put(PROPERTY_USERNAME_MATCH_POLICY,"bar");
  props.put(PROPERTY_VERIFY_CERT_VALIDITY,"");
  createAuthorizationProcessor().updated(props);
}

</code></pre>

<br>
<pre class="type-5 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies that exceptions are thrown during the test case execution">ExceptionVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies that exceptions are thrown during the test case execution
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Tests that updated throws an exception for missing "user name lookup key" property.
 */
@Test(groups={UNIT},expectedExceptions=ConfigurationException.class) public void testUpdatedDoesNotAcceptMissingUsernameLookupKey() throws ConfigurationException {
  Dictionary<String,Object> props=new Hashtable<>();
  props.put(PROPERTY_USERNAME_MATCH_POLICY,"foo");
  props.put(PROPERTY_VERIFY_CERT_VALIDITY,"true");
  createAuthorizationProcessor().updated(props);
}

</code></pre>

<br>
<pre class="type-5 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies that exceptions are thrown during the test case execution">ExceptionVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies that exceptions are thrown during the test case execution
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Tests that canHandle throws an {@link IllegalArgumentException} for a null context.
 */
@Test(groups={UNIT},expectedExceptions=IllegalArgumentException.class) public void testCanHandleDoesNotAcceptNull(){
  createAuthorizationProcessor().canHandle((Object[])null);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.ace.authentication.processor.password.PasswordAuthenticationProcessorTest </h4><pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Tests that canHandle yields true for two strings.
 */
@Test(groups={UNIT}) public void testCanHandleDoesAcceptTwoStrings(){
  assert new PasswordAuthenticationProcessor().canHandle("foo","bar") : "Expected the processor to handle a string!";
}

</code></pre>

<br>
<pre class="type-5 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies that exceptions are thrown during the test case execution">ExceptionVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies that exceptions are thrown during the test case execution
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Tests that canHandle throws an {@link IllegalArgumentException} for an empty context.
 */
@Test(groups={UNIT},expectedExceptions=IllegalArgumentException.class) public void testCanHandleDoesNotAcceptEmptyArray(){
  new PasswordAuthenticationProcessor().canHandle(new Object[0]);
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Tests that canHandle yields true for string and byte array.
 */
@Test(groups={UNIT}) public void testCanHandleDoesAcceptStringAndByteArray(){
  assert new PasswordAuthenticationProcessor().canHandle("foo","bar".getBytes()) : "Expected the processor to handle a byte array!";
}

</code></pre>

<br>
<pre class="type-5 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies that exceptions are thrown during the test case execution">ExceptionVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies that exceptions are thrown during the test case execution
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Tests that canHandle throws an {@link IllegalArgumentException} for a null context.
 */
@Test(groups={UNIT},expectedExceptions=IllegalArgumentException.class) public void testCanHandleDoesNotAcceptNull(){
  new PasswordAuthenticationProcessor().canHandle((Object[])null);
}

</code></pre>

<br>
<pre class="type-5 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies that exceptions are thrown during the test case execution">ExceptionVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies that exceptions are thrown during the test case execution
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Tests that updated throws an exception for missing "password.hashtype" property. 
 */
@Test(groups={UNIT},expectedExceptions=ConfigurationException.class) public void testUpdatedDoesNotAcceptMissingPasswordHashType() throws ConfigurationException {
  Dictionary<String,Object> props=new Hashtable<>();
  props.put(PROPERTY_KEY_USERNAME,"foo");
  props.put(PROPERTY_KEY_PASSWORD,"foo");
  new PasswordAuthenticationProcessor().updated(props);
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Tests that canHandle yields false for too few arguments. 
 */
@Test(groups={UNIT}) public void testCanHandleDoesNotAcceptSingleArgument(){
  assert new PasswordAuthenticationProcessor().canHandle(new Object()) == false : "Expected the processor to NOT handle any object!";
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Tests that authenticating with a null username will yield null.
 */
@Test(groups={UNIT}) public void testAuthenticateNullUserNameYieldsNull(){
  User result=new PasswordAuthenticationProcessor().authenticate(m_userAdmin,null,"secret");
  assert result == null : "Expected no valid user to be returned!";
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Tests that updated does not throw an exception for a correct configuration.
 */
@Test(groups={UNIT}) public void testUpdatedDoesAcceptCorrectProperties() throws ConfigurationException {
  final String keyUsername="foo";
  final String keyPassword="bar";
  Dictionary<String,Object> props=new Hashtable<>();
  props.put(PROPERTY_KEY_USERNAME,keyUsername);
  props.put(PROPERTY_KEY_PASSWORD,keyPassword);
  props.put(PROPERTY_PASSWORD_HASHMETHOD,"sha1");
  PasswordAuthenticationProcessor processor=new PasswordAuthenticationProcessor();
  processor.updated(props);
  byte[] hashedPw=DigestUtils.sha("secret");
  User user=mock(User.class);
  when(user.getName()).thenReturn("bob");
  when(user.hasCredential(eq(keyPassword),eq(hashedPw))).thenReturn(Boolean.TRUE);
  when(m_userAdmin.getUser(eq(keyUsername),eq("bob"))).thenReturn(user);
  User result=processor.authenticate(m_userAdmin,"bob","secret");
  assert result != null : "Expected a valid user to be returned!";
  assert "bob".equals(user.getName()) : "Expected bob to be returned!";
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Tests that canHandle yields false for any object other than {@link HttpServletRequest}.
 */
@Test(groups={UNIT}) public void testCanHandleDoesNotAcceptWrongTypes(){
  assert new PasswordAuthenticationProcessor().canHandle(new Object(),new Object()) == false : "Expected the processor to NOT handle any object!";
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Tests that canHandle yields false for a string and other object. 
 */
@Test(groups={UNIT}) public void testCanHandleDoesNotAcceptStringAndOtherObject(){
  assert new PasswordAuthenticationProcessor().canHandle("foo",new Object()) == false : "Expected the processor to NOT handle any object!";
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Tests that authenticating a known user with a correct password will not yield null.
 */
@Test(groups={UNIT}) public void testAuthenticateKnownUserYieldsValidResult(){
  User user=mock(User.class);
  when(user.getName()).thenReturn("bob");
  when(user.hasCredential(eq("password"),eq("secret"))).thenReturn(Boolean.TRUE);
  when(m_userAdmin.getUser(eq("username"),eq("bob"))).thenReturn(user);
  User result=new PasswordAuthenticationProcessor().authenticate(m_userAdmin,"bob","secret");
  assert result != null : "Expected a valid user to be returned!";
  assert "bob".equals(user.getName()) : "Expected bob to be returned!";
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Tests that authenticating with a null password will yield null.
 */
@Test(groups={UNIT}) public void testAuthenticateNullPasswordYieldsNull(){
  User result=new PasswordAuthenticationProcessor().authenticate(m_userAdmin,"bob",null);
  assert result == null : "Expected no valid user to be returned!";
}

</code></pre>

<br>
<pre class="type-5 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies that exceptions are thrown during the test case execution">ExceptionVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies that exceptions are thrown during the test case execution
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Tests that a class cast exception is thrown for invalid context when calling authenticate.
 */
@Test(groups={UNIT},expectedExceptions=ClassCastException.class) public void testAuthenticateThrowsClassCastForInvalidContext(){
  new PasswordAuthenticationProcessor().authenticate(m_userAdmin,new Object(),"foo");
}

</code></pre>

<br>
<pre class="type-5 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies that exceptions are thrown during the test case execution">ExceptionVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies that exceptions are thrown during the test case execution
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Tests that updated throws an exception for missing "key.username" property. 
 */
@Test(groups={UNIT},expectedExceptions=ConfigurationException.class) public void testUpdatedDoesNotAcceptEmptyKeyUsername() throws ConfigurationException {
  Dictionary<String,Object> props=new Hashtable<>();
  props.put(PROPERTY_KEY_USERNAME,"");
  props.put(PROPERTY_KEY_PASSWORD,"foo");
  props.put(PROPERTY_PASSWORD_HASHMETHOD,"none");
  new PasswordAuthenticationProcessor().updated(props);
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Tests that authenticating a known user with an invalid password will yield null.
 */
@Test(groups={UNIT}) public void testAuthenticateKnownUserWithInvalidPasswordYieldsNull(){
  User user=mock(User.class);
  when(user.getName()).thenReturn("bob");
  when(user.hasCredential(eq("password"),eq("otherSecret"))).thenReturn(Boolean.TRUE);
  when(m_userAdmin.getUser(eq("username"),eq("bob"))).thenReturn(user);
  User result=new PasswordAuthenticationProcessor().authenticate(m_userAdmin,"bob","secret");
  assert result == null : "Expected no valid user to be returned!";
}

</code></pre>

<br>
<pre class="type-5 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies that exceptions are thrown during the test case execution">ExceptionVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies that exceptions are thrown during the test case execution
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Tests that updated throws an exception for missing "key.username" property. 
 */
@Test(groups={UNIT},expectedExceptions=ConfigurationException.class) public void testUpdatedDoesNotAcceptMissingKeyUsername() throws ConfigurationException {
  Dictionary<String,Object> props=new Hashtable<>();
  props.put(PROPERTY_KEY_PASSWORD,"foo");
  props.put(PROPERTY_PASSWORD_HASHMETHOD,"none");
  new PasswordAuthenticationProcessor().updated(props);
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Tests that authenticating an unknown user will yield null.
 */
@Test(groups={UNIT}) public void testAuthenticateUnknownUserYieldsNull(){
  User result=new PasswordAuthenticationProcessor().authenticate(m_userAdmin,"alice","secret");
  assert result == null : "Expected no valid user to be returned!";
}

</code></pre>

<br>
<pre class="type-5 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies that exceptions are thrown during the test case execution">ExceptionVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies that exceptions are thrown during the test case execution
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Tests that updated throws an exception for missing "key.password" property. 
 */
@Test(groups={UNIT},expectedExceptions=ConfigurationException.class) public void testUpdatedDoesNotAcceptEmptyKeyPassword() throws ConfigurationException {
  Dictionary<String,Object> props=new Hashtable<>();
  props.put(PROPERTY_KEY_USERNAME,"foo");
  props.put(PROPERTY_KEY_PASSWORD,"");
  props.put(PROPERTY_PASSWORD_HASHMETHOD,"none");
  new PasswordAuthenticationProcessor().updated(props);
}

</code></pre>

<br>
<pre class="type-5 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies that exceptions are thrown during the test case execution">ExceptionVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies that exceptions are thrown during the test case execution
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Tests that updated throws an exception for missing "key.password" property. 
 */
@Test(groups={UNIT},expectedExceptions=ConfigurationException.class) public void testUpdatedDoesNotAcceptMissingKeyPassword() throws ConfigurationException {
  Dictionary<String,Object> props=new Hashtable<>();
  props.put(PROPERTY_KEY_USERNAME,"foo");
  props.put(PROPERTY_PASSWORD_HASHMETHOD,"none");
  new PasswordAuthenticationProcessor().updated(props);
}

</code></pre>

<br>
<pre class="type-5 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies that exceptions are thrown during the test case execution">ExceptionVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies that exceptions are thrown during the test case execution
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Tests that updated throws an exception for missing "password.hashtype" property. 
 */
@Test(groups={UNIT},expectedExceptions=ConfigurationException.class) public void testUpdatedDoesNotAcceptEmptyPasswordHashType() throws ConfigurationException {
  Dictionary<String,Object> props=new Hashtable<>();
  props.put(PROPERTY_KEY_USERNAME,"foo");
  props.put(PROPERTY_KEY_PASSWORD,"bar");
  props.put(PROPERTY_PASSWORD_HASHMETHOD,"");
  new PasswordAuthenticationProcessor().updated(props);
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Tests that authenticating with a empty username will yield null.
 */
@Test(groups={UNIT}) public void testAuthenticateEmptyUserNameYieldsNull(){
  User result=new PasswordAuthenticationProcessor().authenticate(m_userAdmin,"","secret");
  assert result == null : "Expected no valid user to be returned!";
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.ace.builder.DeploymentPackageBuilderTest </h4><pre class="type-5 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies that exceptions are thrown during the test case execution">ExceptionVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies that exceptions are thrown during the test case execution
- Executes methods or other tests from the same test unit
"></span><br>
@Test(groups={UNIT},expectedExceptions={Exception.class}) public void testResourceWithoutProcessorDeploymentPackage() throws Exception {
  File tempFile=File.createTempFile("output-",".jar");
  FileOutputStream output=new FileOutputStream(tempFile);
  String name="test";
  String version="1.0.0";
  String pid="my.processor";
  File tempArtifactFile=File.createTempFile("artifact-",".jar");
  DeploymentPackageBuilder.createDeploymentPackage(name,version).addArtifact(createArtifact(pid,tempArtifactFile),pid).generate(output);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.ace.client.repository.helper.base.VelocityArtifactPreprocessorTest </h4><pre class="type-5 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies that exceptions are thrown during the test case execution">ExceptionVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies that exceptions are thrown during the test case execution
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Test case for {@link VelocityArtifactPreprocessor#preprocess(String,PropertyResolver,String,String,java.net.URL)}
 */
@Test(groups={UNIT},expectedExceptions={IOException.class}) public void testPreprocessNonExistingTemplateOk() throws Exception {
  String url="file:///path/to/nowhere-" + System.currentTimeMillis();
  createProcessor().preprocess(url,m_resolver,TARGET,VERSION1,m_obrUrl);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.ace.client.repository.impl.ArtifactTest </h4><pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test(groups={TestUtils.UNIT}) public void testArtifactSizeDeterminedByRepository() throws InvalidSyntaxException {
  m_artifactRepository.addHelper(BundleHelper.MIMETYPE,new BundleHelperImpl());
  ArtifactObject artifact=createArtifact(BundleHelper.MIMETYPE,"normalBundle","normalBundle",null,"10");
  List<ArtifactObject> list=m_artifactRepository.get();
  assert (list.size() == 1) && list.contains(artifact) : "Expected a single artifact with the specified mimetype!";
  assert list.get(0).getSize() == 10 : "Expected the size to be filled in!";
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test(groups={TestUtils.UNIT}) public void testResourceProcessorFiltering() throws InvalidSyntaxException {
  m_artifactRepository.addHelper("myMime",new MockHelper());
  m_artifactRepository.addHelper(BundleHelper.MIMETYPE,new BundleHelperImpl());
  createArtifact(BundleHelper.MIMETYPE,"normalBundle","normalBundle",null,"10");
  ArtifactObject resourceProcessor1=createArtifact(BundleHelper.MIMETYPE,"resourceProcessor1","resourceProcessor1","somePID","11");
  ArtifactObject resourceProcessor2=createArtifact(BundleHelper.MIMETYPE,"resourceProcessor2","resourceProcessor2","someOtherPID","12");
  ArtifactObject myArtifact=createArtifact("myMime","myArtifact",null,null,"13");
  assert m_artifactRepository.get().size() == 2 : "We expect to find two artifacts, but we find " + m_artifactRepository.get().size();
  List<ArtifactObject> list=m_artifactRepository.get(m_artifactRepository.createFilter("(!(" + BundleHelper.KEY_SYMBOLICNAME + "=normalBundle))"));
  assert (list.size() == 1) && list.contains(myArtifact) : "We expect to find one artifact when filtering, but we find " + list.size();
  list=m_artifactRepository.getResourceProcessors();
  assert (list.size() == 2) && list.contains(resourceProcessor1) && list.contains(resourceProcessor2) : "We expect to find both our resource processors when asking for them; we find " + list.size() + " artifacts.";
  list=m_artifactRepository.get(m_artifactRepository.createFilter("(mimetype=myMime)"));
  assert (list.size() == 1) && list.contains(myArtifact) : "Expected a single artifact with the specified mimetype!";
  list=m_artifactRepository.get(m_artifactRepository.createFilter("(mimetype=my\\(Mi\\*me)"));
  assert (list.size() == 0) : "Expected no artifact to match the requested filter!";
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test(groups={TestUtils.UNIT}) public void testAttributeChecking(){
  ArtifactHelper helper=new MockHelper("yourURL");
  try {
    createArtifact("myMime","myUrl",null,null,null);
    assert false : "There is no helper for this type of artifact.";
  }
 catch (  IllegalArgumentException iae) {
  }
  m_artifactRepository.addHelper("myMime",helper);
  ArtifactObject obj=createArtifact("myMime","myUrl",null,null,"10");
  assert obj.getURL().equals("yourURL");
  assert obj.getSize() == 10;
  try {
    m_artifactRepository.getHelper("yourMime");
    assert false : "We have not registered this helper.";
  }
 catch (  IllegalArgumentException iae) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.ace.client.repository.impl.CachedRepositoryImplTest </h4><pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Initial checkout: the remote repository contains some data for a given version,
 * we make the cached repository do a checkout, and check whether all data arrives at the
 * right places: in getLocal, and in the backup repository.
 */
@Test(groups={TestUtils.UNIT}) public void testInitialCheckout() throws IllegalArgumentException, IOException {
  Repository m_repository=new MockRepository();
  byte[] testContent=new byte[]{'i','n','i','t','i','a','l'};
  m_repository.commit(new ByteArrayInputStream(testContent),0);
  BackupRepository m_backupRepository=new MockBackupRepository();
  CachedRepository m_cachedRepository=new CachedRepositoryImpl(m_repository,m_backupRepository,0);
  InputStream input=m_cachedRepository.checkout(1);
  byte[] inputBytes=AdminTestUtil.copy(input);
  assert AdminTestUtil.byteArraysEqual(inputBytes,testContent) : "We got something different than 'initial' from checkout: " + new String(inputBytes);
  input=m_cachedRepository.getLocal(false);
  inputBytes=AdminTestUtil.copy(input);
  assert AdminTestUtil.byteArraysEqual(inputBytes,testContent) : "We got something different than 'initial' from getLocal: " + new String(inputBytes);
  input=m_backupRepository.read();
  inputBytes=AdminTestUtil.copy(input);
  assert AdminTestUtil.byteArraysEqual(inputBytes,testContent) : "We got something different than 'initial' from the backup repository: " + new String(inputBytes);
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * After checking out and changing stuff, we want to revert to the old version.
 * @throws IOException
 * @throws IllegalArgumentException
 */
@Test(groups={TestUtils.UNIT}) public void testRevert() throws IllegalArgumentException, IOException {
  Repository m_repository=new MockRepository();
  BackupRepository m_backupRepository=new MockBackupRepository();
  CachedRepository m_cachedRepository=new CachedRepositoryImpl(m_repository,m_backupRepository,0);
  byte[] testContent=new byte[]{'i','n','i','t','i','a','l'};
  InputStream input=new ByteArrayInputStream(testContent);
  m_cachedRepository.commit(input,0);
  m_cachedRepository=new CachedRepositoryImpl(m_repository,m_backupRepository,0);
  input=m_cachedRepository.checkout(1);
  byte[] newTestContent=new byte[]{'n','e','w'};
  m_cachedRepository.writeLocal(new ByteArrayInputStream(newTestContent));
  input=m_cachedRepository.getLocal(false);
  byte[] inputBytes=AdminTestUtil.copy(input);
  assert AdminTestUtil.byteArraysEqual(inputBytes,newTestContent) : "We got something different than 'new' from getLocal: " + new String(inputBytes);
  m_cachedRepository.revert();
  input=m_cachedRepository.getLocal(false);
  inputBytes=AdminTestUtil.copy(input);
  assert AdminTestUtil.byteArraysEqual(inputBytes,testContent) : "We got something different than 'initial' from getLocal: " + new String(inputBytes);
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * There are two types of commit, one that takes an input stream, and one that
 * simply flushes whatever is in the current to the remote repository.
 * After each commit, we should be able to renew the cached repository,
 * and checkout the data we put in before.
 */
@Test(groups={TestUtils.UNIT}) public void testCommit() throws IllegalArgumentException, IOException {
  Repository m_repository=new MockRepository();
  BackupRepository m_backupRepository=new MockBackupRepository();
  CachedRepository m_cachedRepository=new CachedRepositoryImpl(m_repository,m_backupRepository,0);
  byte[] testContent=new byte[]{'i','n','i','t','i','a','l'};
  InputStream input=new ByteArrayInputStream(testContent);
  m_cachedRepository.commit(input,0);
  m_cachedRepository=new CachedRepositoryImpl(m_repository,m_backupRepository,0);
  input=m_cachedRepository.checkout(1);
  byte[] inputBytes=AdminTestUtil.copy(input);
  assert AdminTestUtil.byteArraysEqual(inputBytes,testContent) : "We got something different than 'initial' from checkout: " + new String(inputBytes);
  byte[] newTestContent=new byte[]{'n','e','w'};
  m_cachedRepository.writeLocal(new ByteArrayInputStream(newTestContent));
  m_cachedRepository.commit();
  m_cachedRepository=new CachedRepositoryImpl(m_repository,m_backupRepository,0);
  input=m_cachedRepository.checkout(2);
  inputBytes=AdminTestUtil.copy(input);
  assert AdminTestUtil.byteArraysEqual(inputBytes,newTestContent) : "We got something different than 'new' from checkout: " + new String(inputBytes);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.ace.client.repository.impl.FilebasedBackupRepositoryTest </h4><pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * A basic scenario: we write, backup, write again, and revert.
 */
@Test(groups={TestUtils.UNIT}) public void testFilebasedBackupRepository() throws IOException {
  File current=File.createTempFile("testFilebasedBackupRepository",null);
  File backup=File.createTempFile("testFilebasedBackupRepository",null);
  current.deleteOnExit();
  backup.deleteOnExit();
  FilebasedBackupRepository rep=new FilebasedBackupRepository(current,backup);
  byte[] testContent=new byte[]{'i','n','i','t','i','a','l'};
  rep.write(new ByteArrayInputStream(testContent));
  InputStream input=rep.read();
  byte[] inputBytes=AdminTestUtil.copy(input);
  assert AdminTestUtil.byteArraysEqual(inputBytes,testContent) : "We got something different than 'initial' from read: " + new String(inputBytes);
  rep.backup();
  byte[] newTestContent=new byte[]{'n','e','w'};
  rep.write(new ByteArrayInputStream(newTestContent));
  input=rep.read();
  inputBytes=AdminTestUtil.copy(input);
  assert AdminTestUtil.byteArraysEqual(inputBytes,newTestContent) : "We got something different than 'new' from read: " + new String(inputBytes);
  rep.restore();
  input=rep.read();
  inputBytes=AdminTestUtil.copy(input);
  assert AdminTestUtil.byteArraysEqual(inputBytes,testContent) : "We got something different than 'initial' from read: " + new String(inputBytes);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.ace.client.repository.impl.ModelTest </h4><pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test(groups={TestUtils.UNIT}) public void testDeploymentVersion() throws IOException {
  DeploymentVersionObject version=createBasicDeploymentVersionObject("target1","1",new String[]{"artifact1","artifact2"});
  assert version.getDeploymentArtifacts().length == 2 : "We expect to find two artifacts, but we find " + version.getDeploymentArtifacts().length;
  assert version.getDeploymentArtifacts()[0].getUrl().equals("artifact1");
  assert version.getDeploymentArtifacts()[1].getUrl().equals("artifact2");
  ((DeploymentArtifactImpl)version.getDeploymentArtifacts()[0]).addDirective("myDirective","myValue");
  try {
    createBasicDeploymentVersionObject("target1","1",new String[]{"artifact1","artifact2"});
    assert false : "Creating a deployment version with a target and version that already exists should not be allowed.";
  }
 catch (  IllegalArgumentException iae) {
  }
  assert m_deploymentVersionRepository.get().size() == 1 : "The disallowed version should not be in the repository; we find " + m_deploymentVersionRepository.get().size();
  assert m_deploymentVersionRepository.get().get(0) == version : "Only our newly created version object should be in the repository.";
  ByteArrayOutputStream buffer=new ByteArrayOutputStream();
  RepositorySet deployment=new RepositorySet(null,null,null,null,new ObjectRepositoryImpl[]{m_deploymentVersionRepository},null,"",true);
  new RepositorySerializer(deployment).toXML(buffer);
  initializeRepositoryAdmin();
  assert m_deploymentVersionRepository.get().size() == 0;
  deployment=new RepositorySet(null,null,null,null,new ObjectRepositoryImpl[]{m_deploymentVersionRepository},null,"",true);
  new RepositorySerializer(deployment).fromXML(new ByteArrayInputStream(buffer.toByteArray()));
  assert m_deploymentVersionRepository.get().size() == 1 : "The disallowed version should not be in the repository.";
  assert m_deploymentVersionRepository.get().get(0).equals(version) : "Only our newly created version object should be in the repository.";
  assert m_deploymentVersionRepository.get().get(0).getDeploymentArtifacts().length == 2 : "We expect to find two artifacts, but we find " + m_deploymentVersionRepository.get().get(0).getDeploymentArtifacts().length;
  assert m_deploymentVersionRepository.get().get(0).getDeploymentArtifacts()[0].getUrl().equals("artifact1");
  assert m_deploymentVersionRepository.get().get(0).getDeploymentArtifacts()[0].getKeys().length == 1 : "We expect to find one directive in the first artifact.";
  assert m_deploymentVersionRepository.get().get(0).getDeploymentArtifacts()[0].getDirective("myDirective").equals("myValue") : "The directive should be 'myValue'.";
  assert m_deploymentVersionRepository.get().get(0).getDeploymentArtifacts()[1].getUrl().equals("artifact2");
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * The artifact object can test functionality coming from RepositoryObjectImpl, and ArtifactRepository checks much
 * of ObjectRepositoryImpl.
 * @throws InvalidSyntaxException
 */
@Test(groups={TestUtils.UNIT}) public void testArtifactObjectAndRepository() throws InvalidSyntaxException {
  ArtifactObject a=createBasicArtifactObject("myartifact","1.0.0","1");
  try {
    createBasicArtifactObject("");
    assert false : "Creating an artifact with an empty name is not allowed.";
  }
 catch (  IllegalArgumentException iae) {
  }
  List<FeatureObject> features=a.getFeatures();
  assert features.size() == 0 : "The artifact is not associated, so it should not return any features.";
  assert a.getAttribute(BundleHelper.KEY_SYMBOLICNAME).equals("myartifact") : "We should be able to read an attribute we just put in ourselves.";
  a.addTag("mytag","myvalue");
  assert a.getTag("mytag").equals("myvalue") : "We should be able to read an attribute we just put in ourselves.";
  assert a.getTag(BundleHelper.KEY_SYMBOLICNAME) == null : "We should not find an attribute value when asking for a tag.";
  a.addTag(BundleHelper.KEY_SYMBOLICNAME,"mytagname");
  assert a.getTag(BundleHelper.KEY_SYMBOLICNAME).equals("mytagname") : "We can adds tags that have the same name as a artifact, but still return another value.";
  Dictionary<String,Object> dict=a.getDictionary();
  assert dict.get("mytag") == "myvalue" : "The dictionary of the object should contain all tags.";
  assert dict.get(BundleHelper.KEY_VERSION).equals("1.0.0") : "The dictionary of the object should contain all attributes; we found " + dict.get(BundleHelper.KEY_VERSION);
  String[] foundNames=(String[])dict.get(BundleHelper.KEY_SYMBOLICNAME);
  assert foundNames.length == 2 : "For keys which are used both as a value and as a tag, we should get back both from the dictionary in an array.";
  assert (foundNames[0].equals("myartifact") && foundNames[1].equals("mytagname")) || (foundNames[1].equals("myartifact") && foundNames[0].equals("mytagname")) : "The order is undefined, but we should find both the items we put in for '" + BundleHelper.KEY_SYMBOLICNAME + "'.";
  assert m_artifactRepository.get().size() == 1 : "The repository should contain exactly one artifact.";
  assert m_artifactRepository.get().get(0).equals(a) : "The repository should contain exactly our artifact.";
  ArtifactObject b2=createBasicArtifactObject("myotherartifact","1");
  assert m_artifactRepository.get(createLocalFilter("(" + BundleHelper.KEY_SYMBOLICNAME + "=myartifact)")).size() == 1 : "When filtering for our artifact, we should find only that.";
  assert m_artifactRepository.get(createLocalFilter("(" + BundleHelper.KEY_VERSION + "=1.0.0)")).size() == 2 : "When filtering for a version, we should find two artifacts.";
  try {
    createBasicArtifactObject("myartifact","1.0.0");
    assert false : "Adding a artifact which is identical to one already in the repository should be illegal.";
  }
 catch (  IllegalArgumentException iae) {
  }
  try {
    b2.addAttribute("thenewattribute","withsomevalue");
  }
 catch (  UnsupportedOperationException uoe) {
    assert false : "Adding arbitrary attributes to a artifact object should be allowed.";
  }
  try {
    b2.addAttribute(BundleHelper.KEY_SYMBOLICNAME,"artifact.42");
    assert false : "Changing key attributes in a artifact should not be allowed.";
  }
 catch (  UnsupportedOperationException uoe) {
  }
  try {
    Map<String,String> attr=new HashMap<>();
    attr.put(BundleHelper.KEY_NAME,"mynewartifact");
    Map<String,String> tags=new HashMap<>();
    m_artifactRepository.create(attr,tags);
    assert false : "Creating a artifact without specifying all mandatory atttributes should be illegal.";
  }
 catch (  IllegalArgumentException iae) {
  }
  m_artifactRepository.remove(a);
  try {
    a.addTag("mytag","myvalue");
    assert false : "Deleted objects are not allowed to be changed.";
  }
 catch (  IllegalStateException ise) {
  }
  assert m_artifactRepository.get().size() == 1 : "After removing our first artifact, the repository should contain one artifact.";
  assert m_artifactRepository.get().get(0).equals(b2) : "After removing our first artifact, the repository should contain only our second artifact.";
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Tests the behavior when associating stuff, and removing associations.
 */
@Test(groups={TestUtils.UNIT}) public void testAssociations(){
  initializeRepositoryAdmin();
  ArtifactObject b1=createBasicArtifactObject("artifact1");
  ArtifactObject b2=createBasicArtifactObject("artifact2");
  FeatureObject g1=createBasicFeatureObject("feature1");
  FeatureObject g2=createBasicFeatureObject("feature2");
  FeatureObject g3=createBasicFeatureObject("feature3");
  Artifact2FeatureAssociation b2g1=m_artifact2FeatureRepository.create(b1,g2);
  assert b2g1 != null;
  Artifact2FeatureAssociation b2g2=m_artifact2FeatureRepository.create(b2,g1);
  assert b2g2 != null;
  Artifact2FeatureAssociation b2g3=m_artifact2FeatureRepository.create(b1,g3);
  assert b2g3 != null;
  Artifact2FeatureAssociation b2g4=m_artifact2FeatureRepository.create(b2,g3);
  assert b2g4 != null;
  assert m_artifactRepository.get().size() == 2 : "We should have two artifacts in our repository; we found " + m_artifactRepository.get().size() + ".";
  assert m_featureRepository.get().size() == 3 : "We should have three features in our repository; we found " + m_featureRepository.get().size() + ".";
  assert m_artifact2FeatureRepository.get().size() == 4 : "We should have four associations in our repository; we found " + m_artifact2FeatureRepository.get().size() + ".";
  assert (b2g4.getLeft().size() == 1) && b2g4.getLeft().contains(b2) : "The left side of the fourth association should be artifact 2.";
  assert (b2g4.getRight().size() == 1) && b2g4.getRight().contains(g3) : "The right side of the fourth association should be feature 3.";
  List<FeatureObject> b1features=b1.getFeatures();
  List<FeatureObject> b2features=b2.getFeatures();
  List<ArtifactObject> g1artifacts=g1.getArtifacts();
  List<ArtifactObject> g2artifacts=g2.getArtifacts();
  List<ArtifactObject> g3artifacts=g3.getArtifacts();
  List<DistributionObject> g1distributions=g1.getDistributions();
  List<DistributionObject> g2distributions=g2.getDistributions();
  List<DistributionObject> g3distributions=g3.getDistributions();
  assert g1distributions.size() == 0 : "Feature one should not have any associations to distributions; we found " + g1distributions.size() + ".";
  assert g2distributions.size() == 0 : "Feature two should not have any associations to distributions; we found " + g2distributions.size() + ".";
  assert g3distributions.size() == 0 : "Feature three should not have any associations to distributions; we found " + g3distributions.size() + ".";
  List<FeatureObject> b1expectedFeatures=new ArrayList<>();
  b1expectedFeatures.add(g2);
  b1expectedFeatures.add(g3);
  List<FeatureObject> b2expectedFeatures=new ArrayList<>();
  b2expectedFeatures.add(g1);
  b2expectedFeatures.add(g3);
  List<ArtifactObject> g1expectedArtifacts=new ArrayList<>();
  g1expectedArtifacts.add(b2);
  List<ArtifactObject> g2expectedArtifacts=new ArrayList<>();
  g2expectedArtifacts.add(b1);
  List<ArtifactObject> g3expectedArtifacts=new ArrayList<>();
  g3expectedArtifacts.add(b1);
  g3expectedArtifacts.add(b2);
  assert b1features.containsAll(b1expectedFeatures) && b1expectedFeatures.containsAll(b1features) : "b1 should be associated to exactly features 2 and 3.";
  assert b2features.containsAll(b2expectedFeatures) && b2expectedFeatures.containsAll(b2features) : "b2 should be associated to exactly features 1 and 3.";
  assert g1artifacts.containsAll(g1expectedArtifacts) && g1expectedArtifacts.containsAll(g1artifacts) : "g1 should be associated to exactly artifact 2.";
  assert g2artifacts.containsAll(g2expectedArtifacts) && g2expectedArtifacts.containsAll(g2artifacts) : "g2 should be associated to exactly artifact 1.";
  assert g3artifacts.containsAll(g3expectedArtifacts) && g3expectedArtifacts.containsAll(g3artifacts) : "g3 should be associated to exactly artifacts 1 and 2.";
  m_artifact2FeatureRepository.remove(b2g4);
  b1features=b1.getFeatures();
  b2features=b2.getFeatures();
  g1artifacts=g1.getArtifacts();
  g2artifacts=g2.getArtifacts();
  g3artifacts=g3.getArtifacts();
  b2expectedFeatures.remove(g3);
  g3expectedArtifacts.remove(b2);
  assert b1features.containsAll(b1expectedFeatures) && b1expectedFeatures.containsAll(b1features) : "b1 should be associated to exactly features 2 and 3.";
  assert b2features.containsAll(b2expectedFeatures) && b2expectedFeatures.containsAll(b2features) : "b2 should be associated to exactly feature 1.";
  assert g1artifacts.containsAll(g1expectedArtifacts) && g1expectedArtifacts.containsAll(g1artifacts) : "g1 should be associated to exactly artifact 2.";
  assert g2artifacts.containsAll(g2expectedArtifacts) && g2expectedArtifacts.containsAll(g2artifacts) : "g2 should be associated to exactly artifact 1.";
  assert g3artifacts.containsAll(g3expectedArtifacts) && g3expectedArtifacts.containsAll(g3artifacts) : "g3 should be associated to exactly artifact 1.";
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Not a full-fledged testcase, but a quick test of the correctness of the specified classes for features,
 * distributions and their associations. In essence, this test 'touches' all code which uses generic code which has
 * been tested by TestAssociations.
 */
@Test(groups={TestUtils.UNIT}) public void TestFeature2DistributionAssociations(){
  initializeRepositoryAdmin();
  FeatureObject f1=createBasicFeatureObject("feature1");
  DistributionObject d1=createBasicDistributionObject("distribution1");
  Feature2DistributionAssociation f2d1=m_feature2DistributionRepository.create(f1,d1);
  assert (f2d1.getLeft().size() == 1) && f2d1.getLeft().contains(f1) : "Left side of the association should be our feature.";
  assert (f2d1.getRight().size() == 1) && f2d1.getRight().contains(d1) : "Right side of the association should be our distribution.";
  assert f1.getArtifacts().size() == 0 : "Feature 1 should not be associated with any artifacts; it is associated with " + f1.getArtifacts().size() + ".";
  assert f1.getDistributions().size() == 1 : "Feature 1 should be associated with exactly one distribution; it is associated with " + f1.getDistributions().size() + ".";
  assert d1.getFeatures().size() == 1 : "Distribution 1 should be associated with exactly one feature; it is associated with " + d1.getFeatures().size() + ".";
  assert d1.getTargets().size() == 0 : "Distribution 1 should not be associated with any targets; it is associated with " + d1.getTargets().size() + ".";
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test(groups={TestUtils.UNIT}) public void testModelFiltering() throws InvalidSyntaxException {
  initializeRepositoryAdmin();
  Map<String,String> attributes=new HashMap<>();
  attributes.put("myattribute","theattribute");
  attributes.put("name","attname");
  Map<String,String> tags=new HashMap<>();
  assert m_featureRepository != null : "Something has gone wrong injecting the feature repository.";
  FeatureObject g1=m_featureRepository.create(attributes,tags);
  g1.addTag("mytag","thetag");
  g1.addTag("name","tagname");
  g1.addTag("difficult",")diffi)c*ul\\t");
  assert m_featureRepository.get(createLocalFilter("(myattribute=*)")).size() == 1 : "There should be a myattribute in b1.";
  assert m_featureRepository.get(createLocalFilter("(myattribute=theattribute)")).size() == 1 : "There should be myattribute=theattribute in b1.";
  assert m_featureRepository.get(createLocalFilter("(myattribute=thetag)")).size() == 0 : "There should not be myattribute=thetag in b1.";
  assert m_featureRepository.get(createLocalFilter("(mytag=*)")).size() == 1 : "There should be a mytag in b1.";
  assert m_featureRepository.get(createLocalFilter("(mytag=thetag)")).size() == 1 : "There should be mytag=thetag in b1.";
  assert m_featureRepository.get(createLocalFilter("(mytag=theattribute)")).size() == 0 : "There should not be mytag=theattribute in b1.";
  assert m_featureRepository.get(createLocalFilter("(name=*)")).size() == 1 : "There should be a name parameter in b1.";
  assert m_featureRepository.get(createLocalFilter("(name=attname)")).size() == 1 : "There should be a name=attname in b1.";
  assert m_featureRepository.get(createLocalFilter("(name=tagname)")).size() == 1 : "There should be a name=tagname in b1.";
  assert m_featureRepository.get(createLocalFilter("(name=thetag)")).size() == 0 : "There should not be name=thetag in b1.";
  try {
    m_featureRepository.get(createLocalFilter("(difficult=)diffi)c*ul\\t"));
    assert false : "The non-escaped difficult string should raise an error.";
  }
 catch (  InvalidSyntaxException ex) {
  }
  assert m_featureRepository.get(createLocalFilter("(difficult=" + RepositoryUtil.escapeFilterValue(")diffi)c*ul\\t") + ")")).size() == 1 : "The 'difficult' string should be correctly escaped, and thus return exactly one match.";
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test(groups={TestUtils.UNIT}) public void testAssociationsWithCardinality(){
  ArtifactObject a1=createBasicArtifactObject("a1");
  FeatureObject f1=createBasicFeatureObject("f1");
  FeatureObject f2=createBasicFeatureObject("f2");
  FeatureObject f3=createBasicFeatureObject("f3");
  Map<String,String> props=new HashMap<>();
  props.put(Association.LEFT_ENDPOINT,"(" + BundleHelper.KEY_SYMBOLICNAME + "=a1)");
  props.put(Association.LEFT_CARDINALITY,"1");
  props.put(Association.RIGHT_ENDPOINT,"(" + FeatureObject.KEY_NAME + "=f*)");
  props.put(Association.RIGHT_CARDINALITY,"2");
  Map<String,String> tags=new HashMap<>();
  try {
    m_artifact2FeatureRepository.create(props,tags);
    assert false : "There are three matches for the feature, but we have a cardinality of 2; we should expect a NPE because no comparator is provided.";
  }
 catch (  NullPointerException npe) {
  }
  props.put(Association.RIGHT_CARDINALITY,"3");
  Artifact2FeatureAssociation bg=m_artifact2FeatureRepository.create(props,tags);
  assert bg != null : "Assocating artifact to feature failed?!";
  assert a1.getFeatures().size() == 3 : "The artifact should be associated to three features.";
  assert (f1.getArtifacts().size() == 1) && f1.getArtifacts().contains(a1) : "g1 should be associated to only b1.";
  assert (f2.getArtifacts().size() == 1) && f2.getArtifacts().contains(a1) : "g1 should be associated to only b1.";
  assert (f3.getArtifacts().size() == 1) && f3.getArtifacts().contains(a1) : "g1 should be associated to only b1.";
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Tests that we can create artifacts which contain a certain size (estimate). See ACE-384.
 */
@Test(groups={TestUtils.UNIT}) public void testArtifactObjectSize(){
  ArtifactObject artifactWithSize=createBasicArtifactObject("myartifact","1.0.0","10");
  assert artifactWithSize.getSize() == 10 : "The artifact did not have a valid size?!";
  ArtifactObject artifactWithoutSize=createBasicArtifactObject("artifactWithoutSize","1.0.0",null);
  assert artifactWithoutSize.getSize() == -1L : "The artifact did have a size?!";
  ArtifactObject artifactWithInvalidSize=createBasicArtifactObject("artifactWithInvalidSize","1.0.0","xyz");
  assert artifactWithInvalidSize.getSize() == -1L : "The artifact did have a size?!";
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test(groups={TestUtils.UNIT}) public void testDeploymentRepositoryFilter(){
  String gwId="\\ ( * ) target1)";
  DeploymentVersionObject version1=createBasicDeploymentVersionObject(gwId,"1",new String[]{"artifact1","artifact2"});
  List<DeploymentVersionObject> for1=m_deploymentVersionRepository.getDeploymentVersions(gwId);
  assert for1.size() == 1 : "We expect one version for" + gwId + ", but we find "+ for1.size();
  assert for1.get(0) == version1 : "The only version for" + gwId + "should be version1";
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Tests the correctness of the equals() in RepositoryObject.
 */
@Test(groups={TestUtils.UNIT}) public void testEquals(){
  List<ArtifactObject> artifacts=new ArrayList<>();
  artifacts.add(createBasicArtifactObject("artifact1"));
  artifacts.add(createBasicArtifactObject("artifact2"));
  artifacts.get(1).addTag("thetag","thevalue");
  artifacts.add(createBasicArtifactObject("artifact3"));
  List<ArtifactObject> backupArtifacts=new ArrayList<>();
  backupArtifacts.addAll(artifacts);
  for (  ArtifactObject b : backupArtifacts) {
    artifacts.remove(b);
  }
  assert artifacts.size() == 0 : "The artifacts list should be empty; if not, the ArtifactObject's equals() could be broken.";
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test(groups={TestUtils.UNIT}) public void testRepositorySerialization() throws IOException {
  createBasicArtifactObject("myartifact","1");
  createBasicArtifactObject("myartifact","2");
  ByteArrayOutputStream buffer=new ByteArrayOutputStream();
  RepositorySet store=new RepositorySet(null,null,null,null,new ObjectRepositoryImpl[]{m_artifactRepository,m_artifact2FeatureRepository,m_featureRepository},null,"",true);
  new RepositorySerializer(store).toXML(buffer);
  initializeRepositoryAdmin();
  store=new RepositorySet(null,null,null,null,new ObjectRepositoryImpl[]{m_artifactRepository,m_artifact2FeatureRepository,m_featureRepository},null,"",true);
  new RepositorySerializer(store).fromXML(new ByteArrayInputStream(buffer.toByteArray()));
  assert m_artifactRepository.get().size() == 2 : "We expect to find 2 artifacts, but we find " + m_artifactRepository.get().size();
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test(groups={TestUtils.UNIT}) public void testGetAssociationsWith(){
  initializeRepositoryAdmin();
  ArtifactObject a1=createBasicArtifactObject("artifact1");
  FeatureObject f1=createBasicFeatureObject("feature1");
  Artifact2FeatureAssociation a2f1=m_artifact2FeatureRepository.create(a1,f1);
  List<Artifact2FeatureAssociation> b1Associations=a1.getAssociationsWith(f1);
  List<Artifact2FeatureAssociation> g1Associations=f1.getAssociationsWith(a1);
  assert b1Associations.size() == 1 : "The artifact has exactly one association to the feature, but it shows " + b1Associations.size() + ".";
  assert b1Associations.get(0) == a2f1 : "The artifact's association should be the one we created.";
  assert g1Associations.size() == 1 : "The feature has exactly one association to the artifact.";
  assert g1Associations.get(0) == a2f1 : "The feature's association should be the one we created.";
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test(groups={TestUtils.UNIT}) public void testSerialization() throws IOException {
  ArtifactObject b1=createBasicArtifactObject("artifact1");
  ArtifactObject b2=createBasicArtifactObject("artifact2");
  ArtifactObject b3=createBasicArtifactObject("artifact3");
  FeatureObject g1=createBasicFeatureObject("feature1");
  FeatureObject g2=createBasicFeatureObject("feature2");
  m_artifact2FeatureRepository.create(b1,g1);
  m_artifact2FeatureRepository.create(b2,g2);
  m_artifact2FeatureRepository.create(b3,g2);
  ByteArrayOutputStream buffer=new ByteArrayOutputStream();
  RepositorySet store=new RepositorySet(null,null,null,null,new ObjectRepositoryImpl[]{m_artifactRepository,m_featureRepository,m_artifact2FeatureRepository},null,"",true);
  new RepositorySerializer(store).toXML(buffer);
  initializeRepositoryAdmin();
  store=new RepositorySet(null,null,null,null,new ObjectRepositoryImpl[]{m_artifactRepository,m_featureRepository,m_artifact2FeatureRepository},null,"",true);
  new RepositorySerializer(store).fromXML(new ByteArrayInputStream(buffer.toByteArray()));
  assert m_artifactRepository.get().size() == 3 : "We expect to find 3 artifacts, but we find " + m_artifactRepository.get().size();
  assert m_featureRepository.get().size() == 2 : "We expect to find 2 features, but we find " + m_featureRepository.get().size();
  assert m_artifact2FeatureRepository.get().size() == 3 : "We expect to find 3 associations, but we find " + m_artifact2FeatureRepository.get().size();
  assert b1.isAssociated(g1,FeatureObject.class) : "After serialization, b1 should still be associated with g1.";
  assert !b1.isAssociated(g2,FeatureObject.class) : "After serialization, b1 should not be associated with g1.";
  assert !b2.isAssociated(g1,FeatureObject.class) : "After serialization, b2 should not be associated with g2.";
  assert b2.isAssociated(g2,FeatureObject.class) : "After serialization, b2 should still be associated with g2.";
  assert !b3.isAssociated(g1,FeatureObject.class) : "After serialization, b3 should not be associated with g2.";
  assert b3.isAssociated(g2,FeatureObject.class) : "After serialization, b3 should still be associated with g2.";
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Not a full-fledged testcase, but a quick test of the correctness of the specified classes for distributions,
 * targets and their associations. In essence, this test 'touches' all code which uses generic code which has been
 * tested by TestAssociations.
 */
@Test(groups={TestUtils.UNIT}) public void testDistribution2TargetAssociations(){
  initializeRepositoryAdmin();
  DistributionObject d1=createBasicDistributionObject("distribution1");
  TargetObject t1=createBasicTargetObject("target1");
  m_distribution2TargetRepository.create(d1,t1);
  assert d1.getFeatures().size() == 0 : "Distribution 1 should not be associated with any features; it is associated with " + d1.getFeatures().size() + ".";
  assert d1.getTargets().size() == 1 : "Distribution 1 should be associated with exactly one target; it is associated with " + d1.getTargets().size() + ".";
  assert t1.getDistributions().size() == 1 : "Target 1 should be associated with exactly one distribution; it is associated with " + t1.getDistributions().size() + ".";
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test(groups={TestUtils.UNIT}) public void testDeploymentRepository(){
  DeploymentVersionObject version11=createBasicDeploymentVersionObject("target1","1",new String[]{"artifact1","artifact2"});
  DeploymentVersionObject version12=createBasicDeploymentVersionObject("target1","2",new String[]{"artifact3","artifact4"});
  DeploymentVersionObject version22=createBasicDeploymentVersionObject("target2","2",new String[]{"artifactC","artifactD"});
  DeploymentVersionObject version21=createBasicDeploymentVersionObject("target2","1",new String[]{"artifactA","artifactB"});
  assert m_deploymentVersionRepository.getDeploymentVersions("NotMyTarget").size() == 0 : "The deployment repository should not return" + "any versions when we ask for a target that does not exist, but it returns " + m_deploymentVersionRepository.getDeploymentVersions("NotMyTarget").size();
  List<DeploymentVersionObject> for1=m_deploymentVersionRepository.getDeploymentVersions("target1");
  assert for1.size() == 2 : "We expect two versions for target1, but we find " + for1.size();
  assert for1.get(0) == version11 : "The first version for target1 should be version11";
  assert for1.get(1) == version12 : "The second version for target1 should be version12";
  List<DeploymentVersionObject> for2=m_deploymentVersionRepository.getDeploymentVersions("target2");
  assert for2.size() == 2 : "We expect two versions for target2, but we find " + for2.size();
  assert for2.get(0) == version21 : "The first version for target2 should be version21";
  assert for2.get(1) == version22 : "The second version for target2 should be version22";
  assert m_deploymentVersionRepository.getMostRecentDeploymentVersion("NotMyTarget") == null : "The most recent version for a non-existent target should not exist.";
  assert m_deploymentVersionRepository.getMostRecentDeploymentVersion("target1") == version12 : "The most recent version for target1 should be version12";
  assert m_deploymentVersionRepository.getMostRecentDeploymentVersion("target2") == version22 : "The most recent version for target2 should be version22";
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test(groups={TestUtils.UNIT}) public void testAssociationsWithLists(){
  ArtifactObject b1=createBasicArtifactObject("b1");
  ArtifactObject b2=createBasicArtifactObject("b2");
  ArtifactObject b3=createBasicArtifactObject("b3");
  FeatureObject g1=createBasicFeatureObject("g1");
  FeatureObject g2=createBasicFeatureObject("g2");
  FeatureObject g3=createBasicFeatureObject("g3");
  List<ArtifactObject> artifacts=new ArrayList<>();
  artifacts.add(b1);
  artifacts.add(b2);
  List<FeatureObject> features=new ArrayList<>();
  features.add(g1);
  features.add(g3);
  Artifact2FeatureAssociation bg=m_artifact2FeatureRepository.create(artifacts,features);
  assert bg.getLeft().size() == 2 : "We expect two artifacts on the left side of the association.";
  assert bg.getRight().size() == 2 : "We expect two features on the right side of the association.";
  assert bg.getLeft().contains(b1) : "b1 should be on the left side of the association.";
  assert bg.getLeft().contains(b2) : "b2 should be on the left side of the association.";
  assert !bg.getLeft().contains(b3) : "b3 should not be on the left side of the association.";
  assert bg.getRight().contains(g1) : "g1 should be on the right side of the association.";
  assert !bg.getRight().contains(g2) : "g2 should not be on the right side of the association.";
  assert bg.getRight().contains(g3) : "g3 should be on the right side of the association.";
  List<FeatureObject> foundFeatures=b1.getFeatures();
  assert foundFeatures.size() == 2 : "b1 should be associated with two features.";
  assert foundFeatures.contains(g1) : "b1 should be associated with g1";
  assert !foundFeatures.contains(g2) : "b1 not should be associated with g2";
  assert foundFeatures.contains(g3) : "b1 should be associated with g3";
  foundFeatures=b3.getFeatures();
  assert foundFeatures.size() == 0 : "b3 should not be associated with any features.";
  List<ArtifactObject> foundArtifacts=g3.getArtifacts();
  assert foundArtifacts.size() == 2 : "g1 should be associated with two features.";
  assert foundArtifacts.contains(b1) : "g1 should be associated with b1";
  assert foundArtifacts.contains(b2) : "g1 should be associated with b2";
  assert !foundArtifacts.contains(b3) : "g1 should not be associated with b3";
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.ace.client.repository.impl.RepositoryAdminLoginContextImplTest </h4><pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Test method for {@link RepositoryAdminLoginContextImpl#addDescriptor(RepositorySetDescriptor)}.
 */
@Test(groups={TestUtils.UNIT}) public void testAddDisjointObjectRepositoriesOk() throws Exception {
  RepositoryAdminLoginContextImpl context=new RepositoryAdminLoginContextImpl(Mockito.mock(User.class),"12345");
  context.addDescriptor(new RepositorySetDescriptor(m_location,CUSTOMER,NAME_SHOP,true,ArtifactRepository.class));
  context.addDescriptor(new RepositorySetDescriptor(m_location,CUSTOMER,NAME_DEPLOYMENT,true,FeatureRepository.class));
}

</code></pre>

<br>
<pre class="type-5 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies that exceptions are thrown during the test case execution">ExceptionVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies that exceptions are thrown during the test case execution
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Test method for {@link RepositoryAdminLoginContextImpl#addDescriptor(RepositorySetDescriptor)}.
 */
@Test(groups={TestUtils.UNIT},expectedExceptions={IllegalArgumentException.class}) public void testAddDuplicateObjectRepositoryFail() throws Exception {
  RepositoryAdminLoginContextImpl context=new RepositoryAdminLoginContextImpl(Mockito.mock(User.class),"12345");
  context.addDescriptor(new RepositorySetDescriptor(m_location,CUSTOMER,NAME_SHOP,true,FeatureRepository.class));
  context.addDescriptor(new RepositorySetDescriptor(m_location,CUSTOMER,NAME_DEPLOYMENT,true,FeatureRepository.class));
}

</code></pre>

<br>
<pre class="type-5 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies that exceptions are thrown during the test case execution">ExceptionVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies that exceptions are thrown during the test case execution
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Test method for {@link RepositoryAdminLoginContextImpl#addDescriptor(RepositorySetDescriptor)}.
 */
@Test(groups={TestUtils.UNIT},expectedExceptions={IllegalArgumentException.class}) public void testDuplicateRepositoryNameFail() throws Exception {
  RepositoryAdminLoginContextImpl context=new RepositoryAdminLoginContextImpl(Mockito.mock(User.class),"12345");
  context.addDescriptor(new RepositorySetDescriptor(m_location,CUSTOMER,NAME_SHOP,true,ArtifactRepository.class));
  context.addDescriptor(new RepositorySetDescriptor(m_location,CUSTOMER,NAME_SHOP,true,FeatureRepository.class));
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.ace.configurator.ConfiguratorTest </h4><pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test(groups={UNIT}) public void testRemoveFactoryConfiguration() throws Exception {
  String pid="test-remove";
  String factoryPID="testFactory";
  Properties props=createProperties();
  saveConfiguration(pid,factoryPID,props);
  getAndWaitForConfigurationUpdate(factoryPID);
  removeConfiguration(pid,factoryPID);
  waitForConfigurationDelete(factoryPID);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.ace.connectionfactory.impl.ConnectionFactoryImplTest </h4><pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Test method for {@link org.apache.ace.connectionfactory.impl.ConnectionFactoryImpl#deleted(java.lang.String)}.
 */
@Test(groups={UNIT}) public void testDeleted() throws Exception {
  ConnectionFactoryImpl connFactory=new ConnectionFactoryImpl();
  Dictionary<String,?> props=createBasicAuthConfig(TEST_URL.toExternalForm());
  connFactory.updated("pid1",props);
  UrlCredentials credentials=connFactory.getCredentials(TEST_URL);
  assert credentials != null : "Expected valid credentials to be found!";
  connFactory.deleted("pid1");
  credentials=connFactory.getCredentials(TEST_URL);
  assert credentials == null : "Expected no credentials to be found!";
}

</code></pre>

<br>
<pre class="type-5 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies that exceptions are thrown during the test case execution">ExceptionVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies that exceptions are thrown during the test case execution
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Test method for {@link org.apache.ace.connectionfactory.impl.ConnectionFactoryImpl#createConnection(java.net.URL,org.osgi.service.useradmin.User)}.
 */
@Test(groups={UNIT},expectedExceptions=IllegalArgumentException.class) public void testCreateConnectionNullUserFail() throws Exception {
  new ConnectionFactoryImpl().createConnection(new URL("file:///tmp/foo"),null);
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Test method for {@link org.apache.ace.connectionfactory.impl.ConnectionFactoryImpl#updated(java.lang.String,java.util.Dictionary)}.
 */
@Test(groups={UNIT}) public void testUpdatedInsertsCredentialsOk() throws Exception {
  ConnectionFactoryImpl connFactory=new ConnectionFactoryImpl();
  UrlCredentials credentials=connFactory.getCredentials(TEST_URL);
  assert credentials == null : "Expected no credentials to be found!";
  Dictionary<String,?> props=createBasicAuthConfig(TEST_URL.toExternalForm());
  connFactory.updated("pid1",props);
  credentials=connFactory.getCredentials(TEST_URL);
  assert credentials != null : "Expected valid credentials to be found!";
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Test method for {@link org.apache.ace.connectionfactory.impl.ConnectionFactoryImpl#getBasicAuthCredentials(UrlCredentials)}.
 */
@Test(groups={UNIT}) public void testGetBasicAuthCredentialsOk() throws Exception {
  ConnectionFactoryImpl connFactory=new ConnectionFactoryImpl();
  Dictionary<String,?> props=createBasicAuthConfig(TEST_URL.toExternalForm());
  connFactory.updated("pid1",props);
  UrlCredentials credentials=connFactory.getCredentials(TEST_URL);
  assert credentials != null : "Expected valid credentials to be found!";
  String header=new ConnectionFactoryImpl().getBasicAuthCredentials(credentials.getCredentials());
  assert header != null : "Expected valid HTTP header to be returned!";
  assert header.equals(header.trim()) : "Expected HTTP header not to contain any leading/trailing whitespace!";
  assert "Basic Zm9vOmJhcg==".equals(header) : "Expected HTTP header to be constant!";
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Test method for {@link org.apache.ace.connectionfactory.impl.ConnectionFactoryImpl#updated(java.lang.String,java.util.Dictionary)}.
 */
@Test(groups={UNIT}) public void testUpdatedUpdatesCredentialsOk() throws Exception {
  ConnectionFactoryImpl connFactory=new ConnectionFactoryImpl();
  Dictionary<String,Object> props=createBasicAuthConfig(TEST_URL.toExternalForm());
  connFactory.updated("pid1",props);
  UrlCredentials credentials1=connFactory.getCredentials(TEST_URL);
  assert credentials1 != null : "Expected valid credentials to be found!";
  URL newURL=new URL("http://localhost:8181/test/");
  props.put(UrlCredentialsFactory.KEY_AUTH_BASE_URL,newURL.toExternalForm());
  connFactory.updated("pid1",props);
  UrlCredentials credentials2=connFactory.getCredentials(TEST_URL);
  assert credentials2 == null : "Expected no credentials to be found!";
  credentials2=connFactory.getCredentials(newURL);
  assert credentials2 != null : "Expected valid credentials to be found!";
  assert credentials1 != credentials2 && !credentials1.equals(credentials2) : "Expected not the same credentials to be returned!";
}

</code></pre>

<br>
<pre class="type-5 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies that exceptions are thrown during the test case execution">ExceptionVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies that exceptions are thrown during the test case execution
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Test method for {@link org.apache.ace.connectionfactory.impl.ConnectionFactoryImpl#createConnection(java.net.URL)}.
 */
@Test(groups={UNIT},expectedExceptions=IllegalArgumentException.class) public void testCreateConnectionNullUrlFail() throws Exception {
  new ConnectionFactoryImpl().createConnection(null);
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Test method for {@link org.apache.ace.connectionfactory.impl.ConnectionFactoryImpl#createConnection(java.net.URL,org.osgi.service.useradmin.User)}.
 */
@Test(groups={UNIT}) public void testCreateConnectionOk() throws Exception {
  URLConnection conn=new ConnectionFactoryImpl().createConnection(new URL("file:///tmp/foo"));
  assert conn != null : "Expected valid connection to be created!";
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.ace.connectionfactory.impl.UrlCredentialsFactoryTest </h4><pre class="type-5 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies that exceptions are thrown during the test case execution">ExceptionVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies that exceptions are thrown during the test case execution
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Test method for {@link org.apache.ace.connectionfactory.impl.UrlCredentialsFactory#getCredentials(java.util.Dictionary)}.
 */
@Test(groups={UNIT},expectedExceptions=IllegalArgumentException.class) public void testGetCredentialsWithDictionaryInvalidAuthTypeFail(){
  Dictionary<String,Object> props=new Hashtable<>();
  props.put(UrlCredentialsFactory.KEY_AUTH_BASE_URL,AUTH_BASE_URL);
  props.put(UrlCredentialsFactory.KEY_AUTH_TYPE,"nonsense");
  UrlCredentialsFactory.getCredentials(props);
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Test method for {@link org.apache.ace.connectionfactory.impl.UrlCredentialsFactory#getCredentials(java.util.Dictionary)}.
 */
@Test(groups={UNIT}) public void testGetCredentialsWithDictionaryBasicTypeOk(){
  Dictionary<String,Object> props=new Hashtable<>();
  props.put(UrlCredentialsFactory.KEY_AUTH_BASE_URL,AUTH_BASE_URL);
  props.put(UrlCredentialsFactory.KEY_AUTH_TYPE,"basic");
  props.put(UrlCredentialsFactory.KEY_AUTH_USER_NAME,"foo");
  props.put(UrlCredentialsFactory.KEY_AUTH_USER_PASSWORD,"bar");
  UrlCredentialsFactory.getCredentials(props);
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Test method for {@link org.apache.ace.connectionfactory.impl.UrlCredentialsFactory#getCredentials(java.util.Dictionary)}.
 */
@Test(groups={UNIT}) public void testGetCredentialsWithDictionaryClientCertTypeOk(){
  Dictionary<String,Object> props=new Hashtable<>();
  props.put(UrlCredentialsFactory.KEY_AUTH_BASE_URL,AUTH_BASE_URL);
  props.put(UrlCredentialsFactory.KEY_AUTH_TYPE,"client_cert");
  props.put(UrlCredentialsFactory.KEY_AUTH_TRUSTSTORE_FILE,"foo");
  props.put(UrlCredentialsFactory.KEY_AUTH_TRUSTSTORE_PASS,"bar");
  props.put(UrlCredentialsFactory.KEY_AUTH_KEYSTORE_FILE,"qux");
  props.put(UrlCredentialsFactory.KEY_AUTH_KEYSTORE_PASS,"quu");
  try {
    UrlCredentialsFactory.getCredentials(props);
  }
 catch (  IllegalArgumentException e) {
  }
}

</code></pre>

<br>
<pre class="type-5 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies that exceptions are thrown during the test case execution">ExceptionVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies that exceptions are thrown during the test case execution
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Test method for {@link org.apache.ace.connectionfactory.impl.UrlCredentialsFactory#getCredentials(java.util.Dictionary)}.
 */
@Test(groups={UNIT},expectedExceptions=MissingValueException.class) public void testGetCredentialsWithDictionaryBasicTypeMissingUserNameFail(){
  Dictionary<String,Object> props=new Hashtable<>();
  props.put(UrlCredentialsFactory.KEY_AUTH_BASE_URL,AUTH_BASE_URL);
  props.put(UrlCredentialsFactory.KEY_AUTH_TYPE,"basic");
  props.put(UrlCredentialsFactory.KEY_AUTH_USER_PASSWORD,"bar");
  UrlCredentialsFactory.getCredentials(props);
}

</code></pre>

<br>
<pre class="type-5 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies that exceptions are thrown during the test case execution">ExceptionVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies that exceptions are thrown during the test case execution
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Test method for {@link org.apache.ace.connectionfactory.impl.UrlCredentialsFactory#getCredentials(java.util.Dictionary)}.
 */
@Test(groups={UNIT},expectedExceptions=IllegalArgumentException.class) public void testGetCredentialsWithNullDictionaryFail(){
  UrlCredentialsFactory.getCredentials(null);
}

</code></pre>

<br>
<pre class="type-5 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies that exceptions are thrown during the test case execution">ExceptionVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies that exceptions are thrown during the test case execution
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Test method for {@link org.apache.ace.connectionfactory.impl.UrlCredentialsFactory#getCredentials(java.util.Dictionary)}.
 */
@Test(groups={UNIT},expectedExceptions=MissingValueException.class) public void testGetCredentialsWithDictionaryClientCertTypeMissingKeystorePasswordFail(){
  Dictionary<String,Object> props=new Hashtable<>();
  props.put(UrlCredentialsFactory.KEY_AUTH_BASE_URL,AUTH_BASE_URL);
  props.put(UrlCredentialsFactory.KEY_AUTH_TYPE,"client_cert");
  props.put(UrlCredentialsFactory.KEY_AUTH_TRUSTSTORE_FILE,"bar");
  props.put(UrlCredentialsFactory.KEY_AUTH_TRUSTSTORE_PASS,"qux");
  props.put(UrlCredentialsFactory.KEY_AUTH_KEYSTORE_FILE,"foo");
  UrlCredentialsFactory.getCredentials(props);
}

</code></pre>

<br>
<pre class="type-5 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies that exceptions are thrown during the test case execution">ExceptionVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies that exceptions are thrown during the test case execution
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Test method for {@link org.apache.ace.connectionfactory.impl.UrlCredentialsFactory#getCredentials(java.util.Dictionary,java.lang.String)}.
 */
@Test(groups={UNIT},expectedExceptions=IllegalArgumentException.class) public void testGetCredentialsWithNullPrefixFail(){
  UrlCredentialsFactory.getCredentials(new Hashtable<String,Object>(),null);
}

</code></pre>

<br>
<pre class="type-5 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies that exceptions are thrown during the test case execution">ExceptionVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies that exceptions are thrown during the test case execution
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Test method for {@link org.apache.ace.connectionfactory.impl.UrlCredentialsFactory#getCredentials(java.util.Dictionary)}.
 */
@Test(groups={UNIT},expectedExceptions=MissingValueException.class) public void testGetCredentialsWithDictionaryClientCertTypeMissingTruststorePasswordFail(){
  Dictionary<String,Object> props=new Hashtable<>();
  props.put(UrlCredentialsFactory.KEY_AUTH_BASE_URL,AUTH_BASE_URL);
  props.put(UrlCredentialsFactory.KEY_AUTH_TYPE,"client_cert");
  props.put(UrlCredentialsFactory.KEY_AUTH_KEYSTORE_FILE,"bar");
  props.put(UrlCredentialsFactory.KEY_AUTH_KEYSTORE_PASS,"qux");
  props.put(UrlCredentialsFactory.KEY_AUTH_TRUSTSTORE_FILE,"foo");
  UrlCredentialsFactory.getCredentials(props);
}

</code></pre>

<br>
<pre class="type-5 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies that exceptions are thrown during the test case execution">ExceptionVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies that exceptions are thrown during the test case execution
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Test method for {@link org.apache.ace.connectionfactory.impl.UrlCredentialsFactory#getCredentials(java.util.Dictionary)}.
 */
@Test(groups={UNIT},expectedExceptions=MissingValueException.class) public void testGetCredentialsWithDictionaryClientCertTypeMissingKeystoreFileFail(){
  Dictionary<String,Object> props=new Hashtable<>();
  props.put(UrlCredentialsFactory.KEY_AUTH_BASE_URL,AUTH_BASE_URL);
  props.put(UrlCredentialsFactory.KEY_AUTH_TYPE,"client_cert");
  props.put(UrlCredentialsFactory.KEY_AUTH_TRUSTSTORE_FILE,"bar");
  props.put(UrlCredentialsFactory.KEY_AUTH_TRUSTSTORE_PASS,"qux");
  props.put(UrlCredentialsFactory.KEY_AUTH_KEYSTORE_PASS,"foo");
  UrlCredentialsFactory.getCredentials(props);
}

</code></pre>

<br>
<pre class="type-5 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies that exceptions are thrown during the test case execution">ExceptionVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies that exceptions are thrown during the test case execution
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Test method for {@link org.apache.ace.connectionfactory.impl.UrlCredentialsFactory#getCredentials(java.util.Dictionary)}.
 */
@Test(groups={UNIT},expectedExceptions=MissingValueException.class) public void testGetCredentialsWithDictionaryClientCertTypeMissingTruststoreFileFail(){
  Dictionary<String,Object> props=new Hashtable<>();
  props.put(UrlCredentialsFactory.KEY_AUTH_BASE_URL,AUTH_BASE_URL);
  props.put(UrlCredentialsFactory.KEY_AUTH_TYPE,"client_cert");
  props.put(UrlCredentialsFactory.KEY_AUTH_KEYSTORE_FILE,"bar");
  props.put(UrlCredentialsFactory.KEY_AUTH_KEYSTORE_PASS,"qux");
  props.put(UrlCredentialsFactory.KEY_AUTH_TRUSTSTORE_PASS,"foo");
  UrlCredentialsFactory.getCredentials(props);
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Test method for {@link org.apache.ace.connectionfactory.impl.UrlCredentialsFactory#getCredentials(java.util.Dictionary)}.
 */
@Test(groups={UNIT}) public void testGetCredentialsWithValidDictionaryOk(){
  Dictionary<String,Object> props=new Hashtable<>();
  props.put(UrlCredentialsFactory.KEY_AUTH_BASE_URL,AUTH_BASE_URL);
  props.put(UrlCredentialsFactory.KEY_AUTH_TYPE,"none");
  UrlCredentialsFactory.getCredentials(props);
}

</code></pre>

<br>
<pre class="type-5 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies that exceptions are thrown during the test case execution">ExceptionVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies that exceptions are thrown during the test case execution
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Test method for {@link org.apache.ace.connectionfactory.impl.UrlCredentialsFactory#getCredentials(java.util.Dictionary)}.
 */
@Test(groups={UNIT},expectedExceptions=MissingValueException.class) public void testGetCredentialsWithDictionaryBasicTypeMissingPasswordFail(){
  Dictionary<String,Object> props=new Hashtable<>();
  props.put(UrlCredentialsFactory.KEY_AUTH_BASE_URL,AUTH_BASE_URL);
  props.put(UrlCredentialsFactory.KEY_AUTH_TYPE,"basic");
  props.put(UrlCredentialsFactory.KEY_AUTH_USER_NAME,"bar");
  UrlCredentialsFactory.getCredentials(props);
}

</code></pre>

<br>
<pre class="type-5 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies that exceptions are thrown during the test case execution">ExceptionVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies that exceptions are thrown during the test case execution
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Test method for {@link org.apache.ace.connectionfactory.impl.UrlCredentialsFactory#getCredentials(java.util.Dictionary)}.
 */
@Test(groups={UNIT},expectedExceptions=MissingValueException.class) public void testGetCredentialsWithDictionaryMissingBaseUrlFail(){
  Dictionary<String,Object> props=new Hashtable<>();
  props.put(UrlCredentialsFactory.KEY_AUTH_TYPE,"none");
  UrlCredentialsFactory.getCredentials(props);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.ace.connectionfactory.impl.UrlCredentialsTest </h4><pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Test method for {@link org.apache.ace.connectionfactory.impl.UrlCredentials#matches(java.net.URL)}.
 */
@Test(groups={UNIT}) public void testMatchesNullURLOk() throws Exception {
  UrlCredentials creds=new UrlCredentials(AuthType.NONE,new URL("http://localhost:8080/"));
  assert creds.matches(null) == false : "Null URL should never match any credentials!";
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Test method for {@link org.apache.ace.connectionfactory.impl.UrlCredentials#matches(java.net.URL)}.
 */
@Test(groups={UNIT}) public void testMatchesValidURLOk() throws Exception {
  UrlCredentials creds=new UrlCredentials(AuthType.NONE,new URL("http://localhost:8080/"));
  assert creds.matches(new URL("http://localhost:8080/obr")) : "Base URL should match given URL!";
  assert creds.matches(new URL("http://localhost:8080")) == false : "Base URL shouldn't match given URL!";
  assert creds.matches(new URL("http://localhost:8081/")) == false : "Base URL shouldn't match given URL!";
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.ace.deployment.DeploymentTest </h4><pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test(groups={UNIT}) public void testDeployment() throws Exception {
  Object deploymentPackage=m_deploymentAdminDeployer.install(null);
  assert m_deploymentAdminDeployer.getName(deploymentPackage).equals(MOCK_NAME) : "Installation of mock deployment package failed";
  assert m_deploymentAdminDeployer.getVersion(deploymentPackage).equals(MOCK_VERSION) : "Installation of mock deployment package failed";
  assert ((DeploymentPackage)m_deploymentAdminDeployer.list()[0]).getName().equals(MOCK_NAME) : "List result does not match expected result";
  boolean exceptionthrown=false;
  try {
    m_deploymentAdminDeployer.getName(new String("illegalargument"));
  }
 catch (  IllegalArgumentException iae) {
    exceptionthrown=true;
  }
  assert exceptionthrown : "Illegal argument for getName() did not throw exception";
  exceptionthrown=false;
  try {
    m_deploymentAdminDeployer.getVersion(new String("illegalargument"));
  }
 catch (  IllegalArgumentException iae) {
    exceptionthrown=true;
  }
  assert exceptionthrown : "Illegal argument for getVersion() did not throw exception";
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.ace.deployment.provider.repositorybased.BaseRepositoryHandlerTest </h4><pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Tests that a deployment package with a single version can be parsed & found.
 * @throws Exception not part of this test case.
 */
@Test(groups={UNIT}) public void testGatherSingleVersionOk() throws Exception {
  DeploymentPackageVersionCollector handler=new DeploymentPackageVersionCollector(TARGET);
  m_parser.parse(m_inputStream,handler);
  List<Version> versions=handler.getVersions();
  assert versions.size() == 1 : "Expected a single version to be found!";
  assert Version.parseVersion(VERSION1).equals(versions.get(0)) : "Expected version1 to be found!";
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Tests that non existing artifacts of a deployment package with multiple versions can be parsed.
 * @throws Exception not part of this test case.
 */
@Test(groups={UNIT}) public void testGatherNonExistingArtifactsOfMultipleVersionTargetOk() throws Exception {
  DeploymentArtifactCollector handler=new DeploymentArtifactCollector(EMPTYVERSIONTARGET,VERSION2);
  m_parser.parse(m_inputStream,handler);
  List<XmlDeploymentArtifact>[] artifacts=handler.getArtifacts();
  assert artifacts.length == 1 : "Expected a single artifact to be found!";
  assert artifacts[0].isEmpty() : "Expected no deployment artifacts to be found!";
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Tests that single artifact of a deployment package with multiple versions can be parsed & found.
 * @throws Exception not part of this test case.
 */
@Test(groups={UNIT}) public void testGatherSingleArtifactsOfMultipleVersionTargetOk() throws Exception {
  DeploymentArtifactCollector handler=new DeploymentArtifactCollector(MULTIPLEVERSIONTARGET,VERSION3);
  m_parser.parse(m_inputStream,handler);
  List<XmlDeploymentArtifact>[] artifacts=handler.getArtifacts();
  assert artifacts.length == 1 : "Expected a single artifact to be found!";
  assert artifacts[0].size() == 1 : "Expected a single artifact to be found!";
  XmlDeploymentArtifact artifact1=artifacts[0].get(0);
  assert new URL("file:///bundle4").equals(artifact1.getUrl()) : "Expected 'file:///bundle4' URL to be found!";
  assert artifact1.getDirective().size() == 2 : "Expected two directives to be found!";
  assert "bundle4".equals(artifact1.getDirective().get(KEY_SYMBOLICNAME)) : "Expected correct symbolic name to be found!";
  assert "4.0.0".equals(artifact1.getDirective().get(KEY_VERSION)) : "Expected correct bundle version to be found!";
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Tests that multiple artifacts of a deployment package with a single version can be parsed & found.
 * @throws Exception not part of this test case.
 */
@Test(groups={UNIT}) public void testGatherMultipleArtifactsOfMultipleVersionTargetOk() throws Exception {
  DeploymentArtifactCollector handler=new DeploymentArtifactCollector(MULTIPLEVERSIONTARGET,VERSION2);
  m_parser.parse(m_inputStream,handler);
  List<XmlDeploymentArtifact>[] artifacts=handler.getArtifacts();
  assert artifacts.length == 1 : "Expected two artifacts to be found!";
  assert artifacts[0].size() == 2 : "Expected two artifacts to be found!";
  XmlDeploymentArtifact artifact1=artifacts[0].get(0);
  assert new URL("file:///bundle4.1").equals(artifact1.getUrl()) : "Expected 'file:///bundle4.1' URL to be found!";
  assert artifact1.getDirective().size() == 2 : "Expected two directives to be found!";
  assert "bundle4.1".equals(artifact1.getDirective().get(KEY_SYMBOLICNAME)) : "Expected correct symbolic name to be found!";
  assert "4.1.0".equals(artifact1.getDirective().get(KEY_VERSION)) : "Expected correct bundle version to be found!";
  XmlDeploymentArtifact artifact2=artifacts[0].get(1);
  assert new URL("file:///bundle5").equals(artifact2.getUrl()) : "Expected 'file:///bundle5' URL to be found!";
  assert artifact2.getDirective().size() == 2 : "Expected two directives to be found!";
  assert "bundle5".equals(artifact2.getDirective().get(KEY_SYMBOLICNAME)) : "Expected correct symbolic name to be found!";
  assert "5.0.0".equals(artifact2.getDirective().get(KEY_VERSION)) : "Expected correct bundle version to be found!";
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Tests that the single artifact of a deployment package with a single version can be parsed & found.
 * @throws Exception not part of this test case.
 */
@Test(groups={UNIT}) public void testGatherSingleArtifactOk() throws Exception {
  DeploymentArtifactCollector handler=new DeploymentArtifactCollector(TARGET,VERSION1);
  m_parser.parse(m_inputStream,handler);
  List<XmlDeploymentArtifact>[] artifacts=handler.getArtifacts();
  assert artifacts.length == 1 : "Expected a single artifact to be found!";
  assert artifacts[0].size() == 1 : "Expected a single artifact to be found!";
  XmlDeploymentArtifact artifact1=artifacts[0].get(0);
  assert new URL("file:///bundle1").equals(artifact1.getUrl()) : "Expected 'file:///bundle1' URL to be found!";
  assert artifact1.getDirective().size() == 2 : "Expected two directives to be found!";
  assert "bundle1".equals(artifact1.getDirective().get(KEY_SYMBOLICNAME)) : "Expected correct symbolic name to be found!";
  assert "1.0.0".equals(artifact1.getDirective().get(KEY_VERSION)) : "Expected correct bundle version to be found!";
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Tests that a deployment package with multiple versions can be parsed & found.
 * @throws Exception not part of this test case.
 */
@Test(groups={UNIT}) public void testGatherMultipleVersionOk() throws Exception {
  DeploymentPackageVersionCollector handler=new DeploymentPackageVersionCollector(MULTIPLEVERSIONTARGET);
  m_parser.parse(m_inputStream,handler);
  List<Version> versions=handler.getVersions();
  assert versions.size() == 4 : "Expected four versions to be found!";
  assert Version.parseVersion(VERSION1).equals(versions.get(0)) : "Expected version1 to be found!";
  assert Version.parseVersion(VERSION2).equals(versions.get(1)) : "Expected version2 to be found!";
  assert Version.parseVersion(VERSION3).equals(versions.get(2)) : "Expected version3 to be found!";
  assert Version.parseVersion(VERSION4).equals(versions.get(3)) : "Expected version4 to be found!";
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Tests that requesting the artifacts of a deployment package with an invalid version can be done.
 * @throws Exception not part of this test case.
 */
@Test(groups={UNIT}) public void testGatherArtifactsOfMultipleVersionTargetWithInvalidVersionOk() throws Exception {
  DeploymentArtifactCollector handler=new DeploymentArtifactCollector(EMPTYVERSIONTARGET,VERSION3);
  m_parser.parse(m_inputStream,handler);
  try {
    handler.getArtifacts();
    assert false : "Expected no deployment artifacts to be found!";
  }
 catch (  IllegalArgumentException e) {
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.ace.deployment.provider.repositorybased.RepositoryBasedProviderConcurrencyTest </h4><pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test(groups={UNIT}) public void testConcurrentUsersWithLimit() throws Exception {
  setConfigurationForUsers(1);
  new Thread(){
    public void run(){
      try {
        m_backend.getVersions(TARGET);
      }
 catch (      Exception e) {
        m_exception=e;
      }
    }
  }
.start();
  try {
    boolean acquire=m_semaphore.tryAcquire(1,1,TimeUnit.SECONDS);
    assert acquire : "Could not acquire semaphore, no concurrent threads ?";
    m_backend.getVersions(TARGET);
    assert false : "Expected an overloaded exception";
  }
 catch (  OverloadedException oe) {
    assert true;
  }
  assert m_exception == null : "No Exception expected";
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test(groups={UNIT}) public void testConcurrentUsersWithoutLimit() throws Exception {
  setConfigurationForUsers(0);
  new Thread(){
    public void run(){
      try {
        m_backend.getVersions(TARGET);
      }
 catch (      Exception e) {
        m_exception=e;
      }
    }
  }
.start();
  m_semaphore.tryAcquire(1,1,TimeUnit.SECONDS);
  m_backend.getVersions(TARGET);
  assert true;
  assert m_exception == null : "No Exception expected";
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test(groups={UNIT}) public void testNoConcurrentUsersAllowed() throws Exception {
  setConfigurationForUsers(-1);
  try {
    m_backend.getVersions(TARGET);
    assert false : "Expected an overloaded exception";
  }
 catch (  OverloadedException oe) {
    assert true;
  }
catch (  Throwable t) {
    assert false : "Unknown exception";
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.ace.deployment.provider.repositorybased.RepositoryBasedProviderPerformanceTest </h4><pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Test the getBundleData for a single version, returning a single bundle, for a huge XML.
 */
@Test(groups={PERFORMANCE},timeOut=2000) public void testSingleBundleSingleVersionBundleDataFromHugeXml() throws Exception {
  Collection<ArtifactData> bundleData=m_backend.getBundleData(TARGET,"44.0.0");
  assert bundleData.size() == 1 : "Expected one bundle to be found, but found " + bundleData.size();
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Test the getBundleData for a single version, returning a single bundle, for a huge XML.
 */
@Test(groups={PERFORMANCE},timeOut=3000) public void testSingleBundleMultipleVersionBundleDataFromHugeXml() throws Exception {
  Collection<ArtifactData> bundleData=m_backend.getBundleData(TARGET,"40.0.0","44.6.0");
  assert bundleData.size() == 1 : "Expected one bundle to be found, but found " + bundleData.size();
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.ace.deployment.provider.repositorybased.RepositoryBasedProviderTest </h4><pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Test the getBundleData for a two versions, where in the second version a bundle is added
 */
@Test(groups={UNIT}) public void testAddedBundleMultipleVersions() throws Exception {
  Collection<ArtifactData> bundleData=m_backend.getBundleData(MULTIPLEVERSIONTARGET,VERSION3,VERSION1);
  assert bundleData.size() == 2 : "Expected two bundle to be found, but found " + bundleData.size();
  Iterator<ArtifactData> it=bundleData.iterator();
  while (it.hasNext()) {
    ArtifactData data=it.next();
    if (data.getSymbolicName().equals("Bundle4")) {
      assert !data.hasChanged() : "The data (Bundle4) should not have been changed.";
    }
 else {
      assert data.hasChanged() : "The data (Bundle3) should have been changed.";
    }
  }
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Test the getBundleData for an empty version (no bundle URLS are included)
 */
@Test(groups={UNIT}) public void testEmptyDeploymentVersion() throws Exception {
  List<String> versions=m_backend.getVersions(EMPTYVERSIONTARGET);
  assert versions.size() == 2 : "Expected two version to be found, but found " + versions.size();
  Collection<ArtifactData> bundleData=m_backend.getBundleData(EMPTYVERSIONTARGET,VERSION2);
  assert bundleData.size() == 0 : "Expected no bundles to be found, but got: " + bundleData.size();
  Collection<ArtifactData> bundleData2=m_backend.getBundleData(EMPTYVERSIONTARGET,VERSION1,VERSION2);
  assert bundleData2.size() == 0 : "Expected no bundles to be found, but got: " + bundleData2.size();
  Collection<ArtifactData> bundleData3=m_backend.getBundleData(EMPTYVERSIONTARGET,VERSION2,VERSION1);
  assert bundleData3.size() == 1 : "Expected one bundle to be found, but got: " + bundleData3.size();
  assert bundleData3.iterator().next().getVersion().equals("1.0.0");
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * See if the getVersions() methods normal output works
 */
@Test(groups={UNIT}) public void testGetVersion() throws Exception {
  List<String> versions=m_backend.getVersions(TARGET);
  assert versions.size() == 1 : "Expected one version to be found, but found " + versions.size();
  assert versions.get(0).equals(VERSION1) : "Expected version " + VERSION1 + " but found "+ versions.get(0);
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test(groups={UNIT}) public void testArtifactDataManifestGeneration(){
  Attributes B1NoFixpack=BUNDLE1.getManifestAttributes(false);
  assert B1NoFixpack.size() == 2;
  for (  Map.Entry<Object,Object> entry : B1NoFixpack.entrySet()) {
    if (entry.getKey().toString().equals(Constants.BUNDLE_SYMBOLICNAME)) {
      assert entry.getValue().toString().equals(BUNDLE1.getSymbolicName());
    }
 else     if (entry.getKey().toString().equals(Constants.BUNDLE_VERSION)) {
      assert entry.getValue().toString().equals(BUNDLE1.getVersion());
    }
 else {
      assert false : "Unknown header found: " + entry.getKey().toString();
    }
  }
  Attributes B1Fixpack=BUNDLE1.getManifestAttributes(true);
  assert B1Fixpack.size() == 3;
  for (  Map.Entry<Object,Object> entry : B1Fixpack.entrySet()) {
    if (entry.getKey().toString().equals(Constants.BUNDLE_SYMBOLICNAME)) {
      assert entry.getValue().toString().equals(BUNDLE1.getSymbolicName());
    }
 else     if (entry.getKey().toString().equals(Constants.BUNDLE_VERSION)) {
      assert entry.getValue().toString().equals(BUNDLE1.getVersion());
    }
 else     if (entry.getKey().toString().equals("DeploymentPackage-Missing")) {
      assert entry.getValue().toString().equals("true");
    }
 else {
      assert false : "Unknown header found: " + entry.getKey().toString();
    }
  }
  Attributes R1NoFixpack=RESOURCEPROCESSOR1.getManifestAttributes(false);
  assert R1NoFixpack.size() == 3 : "We expect 3 headers, but find " + R1NoFixpack.size();
  for (  Map.Entry<Object,Object> entry : R1NoFixpack.entrySet()) {
    if (entry.getKey().toString().equals(Constants.BUNDLE_SYMBOLICNAME)) {
      assert entry.getValue().toString().equals(RESOURCEPROCESSOR1.getSymbolicName());
    }
 else     if (entry.getKey().toString().equals(Constants.BUNDLE_VERSION)) {
      assert entry.getValue().toString().equals(RESOURCEPROCESSOR1.getVersion());
    }
 else     if (entry.getKey().toString().equals(DIRECTIVE_ISCUSTOMIZER)) {
      assert entry.getValue().toString().equals("true");
    }
 else {
      assert false : "Unknown header found: " + entry.getKey().toString();
    }
  }
  Attributes A1NoFixpack=ARTIFACT1.getManifestAttributes(false);
  assert A1NoFixpack.size() == 1 : "We expect 1 headers, but find " + A1NoFixpack.size();
  for (  Map.Entry<Object,Object> entry : A1NoFixpack.entrySet()) {
    if (entry.getKey().toString().equals(DIRECTIVE_KEY_PROCESSORID)) {
      assert entry.getValue().toString().equals("my.processor.pid");
    }
 else {
      assert false : "Unknown header found: " + entry.getKey().toString();
    }
  }
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Without any checked in data, we should just get back no version,
 * but the provider should not crash.
 * @throws java.io.IOException
 */
@Test(groups={UNIT}) public void testEmptyRepository() throws Exception {
  Repository mock=new MockDeploymentRepository("",null,null);
  TestUtils.configureObject(m_backend,Repository.class,mock);
  List<String> versions=m_backend.getVersions(TARGET);
  assert versions.size() == 0 : "From an empty repository, we should get 0 versions, but we get " + versions.size();
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Test the getBundleData with some resources.
 */
@Test(groups={UNIT}) public void testBundleDataWithResources() throws Exception {
  List<String> versions=m_backend.getVersions(RESOURCETARGET);
  assert versions.size() == 1 : "Expected two version to be found, but found " + versions.size();
  Collection<ArtifactData> bundleData=m_backend.getBundleData(RESOURCETARGET,versions.get(0));
  assert bundleData.size() == 4 : "Expected four bundle to be found, but found " + bundleData.size();
  Iterator<ArtifactData> it=bundleData.iterator();
  while (it.hasNext()) {
    ArtifactData data=it.next();
    if (data.equals(BUNDLE1)) {
    }
 else     if (data.equals(RESOURCEPROCESSOR1)) {
    }
 else     if (data.equals(ARTIFACT1)) {
    }
 else     if (data.equals(ARTIFACT2)) {
      assert data.getFilename().equals("Artifact2");
      assert data.getProcessorPid().equals("my.processor.pid");
    }
 else {
      assert false : "Unknown bundle found";
    }
  }
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Test the getVersions method with an illegal version (not in org.osgi.framework.Version format)
 */
@Test(groups={UNIT}) public void testIllegalVersion() throws Exception {
  List<String> versions=m_backend.getVersions(INVALIDVERSIONTARGET);
  assert versions.isEmpty() : "Expected no versions to be found, but found " + versions.size();
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Test the getBundleData for a two versions, where in the second version a bundle is removed
 */
@Test(groups={UNIT}) public void testRemovedBundleMultipleVersions() throws Exception {
  Collection<ArtifactData> bundleData=m_backend.getBundleData(MULTIPLEVERSIONTARGET,VERSION1,VERSION3);
  assert bundleData.size() == 1 : "Expected one bundle to be found, but found " + bundleData.size();
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Test the getBundleData for a single version, returning a single bundle
 */
@Test(groups={UNIT}) public void testSingleBundleSingleVersionBundleData() throws Exception {
  Collection<ArtifactData> bundleData=m_backend.getBundleData(TARGET,VERSION1);
  assert bundleData.size() == 1 : "Expected one bundle to be found, but found " + bundleData.size();
  assert bundleData.contains(BUNDLE1) : "Expected to find bundle " + BUNDLE1.getSymbolicName();
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Test the getBundleData with an illegal version (i.e. a version that doesn't exist)
 */
@Test(groups={UNIT}) public void testInvalidVersionBundleData() throws Exception {
  try {
    m_backend.getBundleData(TARGET,INVALIDVERSION);
    assert false : "Expected an error because version " + INVALIDVERSION + " doesn't exist for target: "+ TARGET;
  }
 catch (  IllegalArgumentException iae) {
  }
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Test the getBundleData with an illegal target (i.e. a target that doesn't exist)
 */
@Test(groups={UNIT}) public void testInvalidTargetBundleData() throws Exception {
  try {
    m_backend.getBundleData(INVALIDVERSIONTARGET,VERSION1);
    assert false : "Expected an error because version " + VERSION1 + " doesn't exist for target: "+ INVALIDVERSIONTARGET;
  }
 catch (  IllegalArgumentException iae) {
  }
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Test the getBundleData for a two versions, where two bundles have changed
 */
@Test(groups={UNIT}) public void testMultipleChangedBundlesMultipleVersions() throws Exception {
  Collection<ArtifactData> bundleData=m_backend.getBundleData(MULTIPLEVERSIONTARGET,VERSION1,VERSION2);
  assert bundleData.size() == 2 : "Expected two bundles to be found, but found " + bundleData.size();
  Iterator<ArtifactData> it=bundleData.iterator();
  while (it.hasNext()) {
    ArtifactData data=it.next();
    if (data.equals(BUNDLE4_1)) {
      assert data.hasChanged() : "The data should have been changed.";
    }
 else     if (data.equals(BUNDLE5)) {
      assert data.hasChanged() : "The data should have been changed.";
    }
 else {
      assert false : "Unknown bundle found";
    }
  }
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Test with multiple versions. It expects all versions in an ascending order.
 */
@Test(groups={UNIT}) public void testMultipleVersions() throws Exception {
  List<String> versions=m_backend.getVersions(MULTIPLEVERSIONTARGET);
  assert versions.size() == 4 : "Expected three version to be found, but found " + versions.size();
  assert versions.get(0).equals(VERSION1) : "Expected version " + VERSION1 + " but found "+ versions.get(0);
  assert versions.get(1).equals(VERSION2) : "Expected version " + VERSION2 + " but found "+ versions.get(1);
  assert versions.get(2).equals(VERSION3) : "Expected version " + VERSION3 + " but found "+ versions.get(2);
  assert versions.get(3).equals(VERSION4) : "Expected version " + VERSION4 + " but found "+ versions.get(3);
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Test the getBundleData for a two versions, where in the second version one bundle has changed and another hasn't
 */
@Test(groups={UNIT}) public void testSingleChangedBundleMultipleVersions() throws Exception {
  Collection<ArtifactData> bundleData=m_backend.getBundleData(MULTIPLEVERSIONTARGET,VERSION1,VERSION4);
  assert bundleData.size() == 2 : "Expected two bundles to be found, but found " + bundleData.size();
  Iterator<ArtifactData> it=bundleData.iterator();
  while (it.hasNext()) {
    ArtifactData data=it.next();
    if (data.equals(BUNDLE3_2)) {
      assert !data.hasChanged() : "The data should not have been changed.";
    }
 else     if (data.equals(BUNDLE4_2)) {
      assert data.hasChanged() : "The data should have been changed.";
    }
 else {
      assert false : "Unknown bundle found";
    }
  }
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Test the getBundleData for a two versions, returning multiple bundles that haven't changed
 */
@Test(groups={UNIT}) public void testMultipleBundlesMultipleVersions() throws Exception {
  Collection<ArtifactData> bundleData=m_backend.getBundleData(MULTIPLEVERSIONTARGET,VERSION1,VERSION1);
  assert bundleData.size() == 2 : "Expected two bundle to be found, but found " + bundleData.size();
  Iterator<ArtifactData> it=bundleData.iterator();
  while (it.hasNext()) {
    ArtifactData data=it.next();
    assert !data.hasChanged() : "The data should not have been changed.";
  }
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Test the getBundleData for a two versions, returning a single bundle that hasn't changed
 */
@Test(groups={UNIT}) public void testSingleUnchangedBundleMultipleVersions() throws Exception {
  Collection<ArtifactData> bundleData=m_backend.getBundleData(TARGET,VERSION1,VERSION1);
  assert bundleData.size() == 1 : "Expect one bundle, got " + bundleData.size();
  Iterator<ArtifactData> it=bundleData.iterator();
  while (it.hasNext()) {
    ArtifactData data=it.next();
    assert data.getSize() == 100 : "Bundle has no sensible size?! " + data.getSize();
    assert !data.hasChanged() : "The data should not have been changed.";
  }
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * See if the getVersions() methods normal output works with literals ' and "
 */
@Test(groups={UNIT}) public void testGetLiteralTargetVersion() throws Exception {
  List<String> versions=m_backend.getVersions("'");
  assert versions.size() == 1 : "Expected one version to be found, but found " + versions.size();
  assert versions.get(0).equals(VERSION1) : "Expected version " + VERSION1 + " but found "+ versions.get(0);
  versions=m_backend.getVersions("\"");
  assert versions.size() == 1 : "Expected one version to be found, but found " + versions.size();
  assert versions.get(0).equals(VERSION2) : "Expected version " + VERSION2 + " but found "+ versions.get(0);
  versions=m_backend.getVersions("target'\"");
  assert versions.size() == 1 : "Expected one version to be found, but found " + versions.size();
  assert versions.get(0).equals(VERSION3) : "Expected version " + VERSION3 + " but found "+ versions.get(0);
  versions=m_backend.getVersions(" '''' \"\"\"\" ");
  assert versions.size() == 1 : "Expected one version to be found, but found " + versions.size();
  assert versions.get(0).equals(VERSION4) : "Expected version " + VERSION4 + " but found "+ versions.get(0);
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * See if a version with a literal is parsed correct and ignored.
 */
@Test(groups={UNIT}) public void testGetLiteralTargetIllegalVersion() throws Exception {
  List<String> versions=m_backend.getVersions("myTarget");
  assert versions.size() == 0 : "Expected no versions to be found, but found " + versions.size();
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Test the getBundleData for a single version, returning a multiple bundles
 */
@Test(groups={UNIT}) public void testMultipleBundleSingleVersionBundleData() throws Exception {
  Collection<ArtifactData> bundleData=m_backend.getBundleData(MULTIPLEVERSIONTARGET,VERSION1);
  assert bundleData.size() == 2 : "Expected two bundle to be found, but found " + bundleData.size();
  assert bundleData.contains(BUNDLE3) : "Expected to find bundle " + BUNDLE3.getSymbolicName();
  assert bundleData.contains(BUNDLE4) : "Expected to find bundle " + BUNDLE4.getSymbolicName();
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.ace.deployment.service.impl.DeploymentServiceImplTest </h4><pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test(groups={UNIT}) public void testGetHighestLocalVersion(){
  prepareMockEnvironment(new Version[]{VERSION1,VERSION2,VERSION3},null,null);
  Version highestVersion=m_service.getHighestLocalVersion();
  assert highestVersion.equals(VERSION3) : "Highest local version is incorrect, expected " + VERSION3.toString() + " but got "+ highestVersion.toString();
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test(groups={UNIT}) public void testUpdateWithLatestVersion() throws Exception {
  final URL[] urls=prepareMockEnvironment(null,new Version[]{VERSION1,VERSION2,VERSION3},VERSION3);
  TestUtils.configureObject(m_service,Discovery.class,new Discovery(){
    public URL discover(){
      return urls[1];
    }
  }
);
  m_service.update(VERSION3);
  assert m_installCalled : "Install not called?!";
  assert m_correctVersionInstalled : "Wrong version installed?!";
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test(groups={UNIT}) public void testUpdateWithNonLatestVersion() throws Exception {
  final URL[] urls=prepareMockEnvironment(null,new Version[]{VERSION1,VERSION2,VERSION3},VERSION2);
  TestUtils.configureObject(m_service,Discovery.class,new Discovery(){
    public URL discover(){
      return urls[1];
    }
  }
);
  m_service.update(VERSION2);
  assert m_installCalled : "Install not called?!";
  assert m_correctVersionInstalled : "Wrong version installed?!";
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test(groups={UNIT}) public void testGetRemoteVersionsWithURL() throws MalformedURLException, IOException {
  URL[] urls=prepareMockEnvironment(null,new Version[]{VERSION1,VERSION2,VERSION3},null);
  SortedSet<Version> highestVersion=m_service.getRemoteVersions(urls[0]);
  assert !highestVersion.isEmpty() : "Expected versions to return!";
  assert highestVersion.last().equals(VERSION3) : "Highest remote version is incorrect, expected " + VERSION3.toString() + " but got "+ highestVersion.toString();
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.ace.deployment.servlet.DeploymentServletTest </h4><pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test(groups={UNIT}) public void getUpgradeFixPackageWithExistingFromVersion() throws Exception {
  m_requestPathInfo="/existing/versions/2.0.0";
  m_requestCurrentParameter="2.0.0";
  m_servlet.doGet(m_request,m_response);
  assertResponseCode(HttpServletResponse.SC_OK);
  assertResponseOutput(0,100);
  assertGeneratorTargetId("existing");
  assertGeneratorToVersion("2.0.0");
  assertGeneratorFromVersion("2.0.0");
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test public void getSizeForNonExistingTarget() throws Exception {
  m_artifactSize=10;
  m_requestPathInfo="/existing/versions/1.0.0";
  m_servlet.doHead(m_request,m_response);
  assertResponseCode(HttpServletResponse.SC_OK);
  assertResponseHeaderNotPresent("X-ACE-DPSize");
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test(groups={UNIT}) public void getUpgradeFixPackageWithNonExistingToVersion() throws Exception {
  m_requestPathInfo="/existing/versions/3.0.0";
  m_requestCurrentParameter="2.0.0";
  m_servlet.doGet(m_request,m_response);
  assertResponseCode(HttpServletResponse.SC_NOT_FOUND);
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test(groups={UNIT}) public void getUpgradeFixPackageWithNonExistingFromVersion() throws Exception {
  m_requestPathInfo="/existing/versions/2.0.0";
  m_requestCurrentParameter="1.0.0";
  m_servlet.doGet(m_request,m_response);
  assertResponseCode(HttpServletResponse.SC_OK);
  assertResponseOutput(0,100);
  assertGeneratorTargetId("existing");
  assertGeneratorToVersion("2.0.0");
  assertGeneratorFromVersion(null);
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test public void getRangeDataForExistingTarget_badHeaderValue() throws Exception {
  m_requestPathInfo="/existing/versions/2.0.0";
  m_requestRangeHeader="bytes=a-1";
  m_servlet.doGet(m_request,m_response);
  assertResponseCode(HttpServletResponse.SC_OK);
  assertResponseHeaderNotPresent("Content-Length");
  assertResponseOutput(0,100);
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test(groups={UNIT}) public void getUpgradeWithExistingToVersion() throws Exception {
  m_requestPathInfo="/existing/versions/2.0.0";
  m_requestCurrentParameter=null;
  m_servlet.doGet(m_request,m_response);
  assertResponseCode(HttpServletResponse.SC_OK);
  assertResponseOutput(0,100);
  assertGeneratorTargetId("existing");
  assertGeneratorToVersion("2.0.0");
  assertGeneratorFromVersion(null);
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test public void getSizeForExistingTargetWithKnownSize() throws Exception {
  m_artifactSize=10;
  m_requestPathInfo="/existing/versions/2.0.0";
  m_servlet.doHead(m_request,m_response);
  assertResponseCode(HttpServletResponse.SC_OK);
  assertResponseHeaderValue("X-ACE-DPSize","11");
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test public void getDataForExistingTarget() throws Exception {
  m_requestPathInfo="/existing/versions/2.0.0";
  m_servlet.doGet(m_request,m_response);
  assertResponseCode(HttpServletResponse.SC_OK);
  assertResponseHeaderNotPresent("Content-Length");
  assertResponseOutput(0,100);
  assertGeneratorTargetId("existing");
  assertGeneratorToVersion("2.0.0");
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test public void getRangeDataForExistingTarget_firstOKlastTooBig() throws Exception {
  m_requestPathInfo="/existing/versions/2.0.0";
  m_requestRangeHeader="bytes=2-100";
  m_servlet.doGet(m_request,m_response);
  assertResponseCode(HttpServletResponse.SC_PARTIAL_CONTENT);
  assertResponseHeaderNotPresent("Content-Length");
  assertResponseHeaderValue("Content-Range","bytes 2-100/*");
  assertResponseOutput(2,98);
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test public void getSizeForFixPackageExistingTargetWithKnownSize() throws Exception {
  m_artifactSize=10;
  m_requestCurrentParameter="2.0.0";
  m_requestPathInfo="/existing/versions/2.0.0";
  m_servlet.doHead(m_request,m_response);
  assertResponseCode(HttpServletResponse.SC_OK);
  assertResponseHeaderValue("X-ACE-DPSize","22");
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test public void getDataForNonExistingTarget() throws Exception {
  m_requestPathInfo="/nonexisting/versions/2.0.0";
  m_servlet.doGet(m_request,m_response);
  assertResponseCode(HttpServletResponse.SC_NOT_FOUND);
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test(groups={UNIT}) public void getDowngradeFixPackageWithNonExistingToVersion() throws Exception {
  m_requestPathInfo="/existing/versions/1.0.0";
  m_requestCurrentParameter="2.0.0";
  m_servlet.doGet(m_request,m_response);
  assertResponseCode(HttpServletResponse.SC_NOT_FOUND);
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test(groups={UNIT}) public void getRangeDataForExistingTarget_firstOKlastOK() throws Exception {
  m_requestPathInfo="/existing/versions/2.0.0";
  m_requestRangeHeader="bytes=2-50";
  m_servlet.doGet(m_request,m_response);
  assertResponseCode(HttpServletResponse.SC_PARTIAL_CONTENT);
  assertResponseHeaderNotPresent("Content-Length");
  assertResponseHeaderValue("Content-Range","bytes 2-50/*");
  assertResponseOutput(2,49);
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test(groups={UNIT}) public void getUpgradeWithNonExistingToVersion() throws Exception {
  m_requestPathInfo="/existing/versions/3.0.0";
  m_requestCurrentParameter=null;
  m_servlet.doGet(m_request,m_response);
  assertResponseCode(HttpServletResponse.SC_NOT_FOUND);
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test public void getRangeDataForExistingTarget_firstOKlastOK2() throws Exception {
  m_requestPathInfo="/existing/versions/2.0.0";
  m_requestRangeHeader="bytes=2-99";
  m_servlet.doGet(m_request,m_response);
  assertResponseCode(HttpServletResponse.SC_PARTIAL_CONTENT);
  assertResponseHeaderNotPresent("Content-Length");
  assertResponseHeaderValue("Content-Range","bytes 2-99/*");
  assertResponseOutput(2,98);
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test public void getVersionsNonExistingTarget() throws Exception {
  m_requestPathInfo="/nonexisting/versions";
  m_servlet.doGet(m_request,m_response);
  assertResponseCode(HttpServletResponse.SC_NOT_FOUND);
  assertResponseOutput(-1,0);
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test public void getRangeDataForExistingTarget_first0lastOK() throws Exception {
  m_requestPathInfo="/existing/versions/2.0.0";
  m_requestRangeHeader="bytes=0-10";
  m_servlet.doGet(m_request,m_response);
  assertResponseCode(HttpServletResponse.SC_PARTIAL_CONTENT);
  assertResponseHeaderNotPresent("Content-Length");
  assertResponseHeaderValue("Content-Range","bytes 0-10/*");
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test public void getRangeDataForExistingTarget_firstOKlastTooSmall() throws Exception {
  m_requestPathInfo="/existing/versions/2.0.0";
  m_requestRangeHeader="bytes=2-1";
  m_servlet.doGet(m_request,m_response);
  assertResponseCode(HttpServletResponse.SC_OK);
  assertResponseHeaderNotPresent("Content-Length");
  assertResponseOutput(0,100);
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test public void getSizeForExistingTargetWithUnknownSize() throws Exception {
  m_artifactSize=-1;
  m_requestPathInfo="/existing/versions/2.0.0";
  m_servlet.doHead(m_request,m_response);
  assertResponseCode(HttpServletResponse.SC_OK);
  assertResponseHeaderNotPresent("X-ACE-DPSize");
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test public void getDataForBadURL() throws Exception {
  HttpServletRequest garbage=createMockObjectAdapter(HttpServletRequest.class,new Object(){
    @SuppressWarnings("unused") public String getPathInfo(){
      return "/";
    }
  }
);
  m_servlet.doGet(garbage,m_response);
  assertResponseCode(HttpServletResponse.SC_BAD_REQUEST);
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test public void getRangeDataForExistingTarget_firstOKlastANY() throws Exception {
  m_requestPathInfo="/existing/versions/2.0.0";
  m_requestRangeHeader="bytes=2-";
  m_servlet.doGet(m_request,m_response);
  assertResponseCode(HttpServletResponse.SC_PARTIAL_CONTENT);
  assertResponseHeaderNotPresent("Content-Length");
  assertResponseHeaderValue("Content-Range","bytes 2-/*");
  assertResponseOutput(2,98);
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test public void getRangeDataForExistingTarget_firstTooBiglastTooBig() throws Exception {
  m_requestPathInfo="/existing/versions/2.0.0";
  m_requestRangeHeader="bytes=100-110";
  m_servlet.doGet(m_request,m_response);
  assertResponseCode(HttpServletResponse.SC_PARTIAL_CONTENT);
  assertResponseHeaderValue("Content-Range","bytes 100-110/*");
  assertResponseHeaderNotPresent("Content-Length");
  assertResponseOutput(-1,0);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.ace.deployment.streamgenerator.impl.StreamTest </h4><pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Test reading 100 streams concurrently.
 */
@Test(groups={UNIT,BROKEN}) public void hundredStreamsConcurrently() throws Exception {
  ExecutorService e=Executors.newFixedThreadPool(5);
  for (int i=0; i < 10; i++) {
    e.execute(new Runnable(){
      public void run(){
        for (int i=0; i < 10; i++) {
          try {
            isJarInputStreamReadable();
          }
 catch (          Exception e) {
            m_failure=e;
          }
        }
      }
    }
);
  }
  e.shutdown();
  e.awaitTermination(10,TimeUnit.SECONDS);
  assert m_failure == null : "Test failed: " + m_failure.getLocalizedMessage();
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * The specification requires the stream to be readable by JarInputStream (114.3) so make sure it is.
 */
@Test(groups={UNIT}) public void isJarInputStreamReadable() throws Exception {
  isJarInputStreamReadable(new JarInputStream(m_generator.getDeploymentPackage("test","1.0.0")),false);
  isJarInputStreamReadable(new JarInputStream(m_generator.getDeploymentPackage("test","0.0.0","1.0.0")),true);
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Test reading 100 streams sequentially.
 */
@Test(groups={UNIT,BROKEN}) public void hundredStreamsSequentially() throws Exception {
  for (int i=0; i < 100; i++) {
    isJarInputStreamReadable();
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.ace.discovery.property.SimpleDiscoveryTest </h4><pre class="type-5 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies that exceptions are thrown during the test case execution">ExceptionVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies that exceptions are thrown during the test case execution
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Test if setting an invalid configuration is handled correctly.
 * @throws ConfigurationException
 */
@Test(groups={UNIT},expectedExceptions=ConfigurationException.class) public void simpleDiscoveryInvalidConfiguration() throws ConfigurationException {
  Dictionary<String,String> properties=new Hashtable<>();
  properties.put(SERVERURL_KEY,INVALID_URL);
  m_discovery.updated(properties);
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Test if supplying an empty configuration results in the service's default being used.
 * @throws ConfigurationException
 */
@Test(groups={UNIT}) public void simpleDiscoveryEmptyConfiguration() throws ConfigurationException {
  Dictionary<String,String> properties=new Hashtable<>();
  properties.put(SERVERURL_KEY,VALID_URL);
  m_discovery.updated(properties);
  m_discovery.updated(null);
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Test if setting a valid configuration is handled correctly
 * @throws Exception
 */
@Test(groups={UNIT}) public void simpleDiscoveryValidConfiguration() throws ConfigurationException {
  Dictionary<String,String> properties=new Hashtable<>();
  properties.put(SERVERURL_KEY,VALID_URL);
  m_discovery.updated(properties);
  URL url=m_discovery.discover();
  assert VALID_URL.equals(url.toString()) : "Configured url was not returned";
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.ace.identification.ifconfig.IfconfigIdentificationTest </h4><pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test(groups={UNIT}) public void testMacAddressVerifying() throws Exception {
  assert m_identification.isValidMac("FF:FF:FF:FF:FF:FF");
  assert m_identification.isValidMac("01:23:45:67:89:01");
  assert m_identification.isValidMac("0D:C3:45:6A:B9:01");
  assert !m_identification.isValidMac("");
  assert !m_identification.isValidMac("FF:FF:FF:FF:FF");
  assert !m_identification.isValidMac("FF:FF:FF:FF:FF:");
  assert !m_identification.isValidMac("FF:FF:FF:FF:FF:F");
  assert !m_identification.isValidMac("A:B:C:D:E:F");
  assert !m_identification.isValidMac("FF:FF:FF:FF:FF:FG");
  assert !m_identification.isValidMac("FF:FF:FF:FF:FF:FF:");
  assert !m_identification.isValidMac("FF-FF-FF-FF-FF-FF");
  assert !m_identification.isValidMac("thisisnotamacaddr");
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.ace.identification.property.SimpleIdentificationTest </h4><pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Test simple identification
 * @throws Exception
 */
@SuppressWarnings("serial") @Test(groups={UNIT}) public void testSimpleIdentification() throws Exception {
  m_identification.updated(new Hashtable<String,Object>(){
{
      put(IdentificationConstants.IDENTIFICATION_TARGETID_KEY,TEST_ID);
    }
  }
);
  assert TEST_ID.equals(m_identification.getID()) : "target ID does not match configured target ID";
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.ace.it.deployment.provider.filebased.FileBasedProviderTest </h4><pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Test the getBundleData for a single version, returning a single bundle
 */
@Test(groups={UNIT}) public void testSingleBundleSingleVersionBundleData(){
  Collection<ArtifactData> bundleData=m_backend.getBundleData(TARGET,VERSION1);
  assert bundleData.size() == 1 : "Expected one bundle to be found, but found " + bundleData.size();
  assert bundleData.contains(BUNDLE1) : "Expected to find bundle " + BUNDLE1.getSymbolicName();
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Test the getBundleData for a two versions, where in the second version a bundle is removed
 */
@Test(groups={UNIT}) public void testRemovedBundleMultipleVersions(){
  Collection<ArtifactData> bundleData=m_backend.getBundleData(MULTIPLEVERSIONTARGET,VERSION1,VERSION3);
  assert bundleData.size() == 0 : "Expected zero bundle to be found, but found " + bundleData.size();
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Test the getBundleData for a two versions, where in the second version one bundle has changed and another hasn't
 */
@Test(groups={UNIT}) public void testSingleChangedBundleMultipleVersions(){
  Collection<ArtifactData> bundleData=m_backend.getBundleData(MULTIPLEVERSIONTARGET,VERSION1,VERSION4);
  assert bundleData.size() == 2 : "Expected one bundle to be found, but found " + bundleData.size();
  Iterator<ArtifactData> it=bundleData.iterator();
  while (it.hasNext()) {
    ArtifactData data=it.next();
    if (data.equals(BUNDLE3_2)) {
      assert !data.hasChanged() : "The data should not have been changed.";
    }
 else     if (data.equals(BUNDLE4_2)) {
      assert data.hasChanged() : "The data should have been changed.";
    }
 else {
      assert false : "Unknown bundle found";
    }
  }
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Test the getBundleData for a two versions, where in the second version a bundle is added
 */
@Test(groups={UNIT}) public void testAddedBundleMultipleVersions(){
  Collection<ArtifactData> bundleData=m_backend.getBundleData(MULTIPLEVERSIONTARGET,VERSION3,VERSION1);
  assert bundleData.size() == 2 : "Expected two bundle to be found, but found " + bundleData.size();
  Iterator<ArtifactData> it=bundleData.iterator();
  while (it.hasNext()) {
    ArtifactData data=it.next();
    assert data.hasChanged() : "The data should have been changed.";
  }
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * See if the getVersions() methods normal output works
 */
@Test(groups={UNIT}) public void testGetVersion(){
  List<String> versions=m_backend.getVersions(TARGET);
  assert versions.size() == 1 : "Expected one version to be found, but found " + versions.size();
  assert versions.get(0).equals(VERSION1) : "Expected version " + VERSION1 + " but found "+ versions.get(0);
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Test the getBundleData for a single version, returning a multiple bundles
 */
@Test(groups={UNIT}) public void testMultipleBundleSingleVersionBundleData(){
  Collection<ArtifactData> bundleData=m_backend.getBundleData(MULTIPLEVERSIONTARGET,VERSION1);
  assert bundleData.size() == 2 : "Expected two bundle to be found, but found " + bundleData.size();
  assert bundleData.contains(BUNDLE3) : "Expected to find bundle " + BUNDLE3.getSymbolicName();
  assert bundleData.contains(BUNDLE4) : "Expected to find bundle " + BUNDLE4.getSymbolicName();
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Test the getBundleData for a two versions, where two bundles have changed
 */
@Test(groups={UNIT}) public void testMultipleChangedBundlesMultipleVersions(){
  Collection<ArtifactData> bundleData=m_backend.getBundleData(MULTIPLEVERSIONTARGET,VERSION1,VERSION2);
  assert bundleData.size() == 2 : "Expected one bundle to be found, but found " + bundleData.size();
  Iterator<ArtifactData> it=bundleData.iterator();
  while (it.hasNext()) {
    ArtifactData data=it.next();
    if (data.equals(BUNDLE4_1)) {
      assert data.hasChanged() : "The data should have been changed.";
    }
 else     if (data.equals(BUNDLE5)) {
      assert data.hasChanged() : "The data should have been changed.";
    }
 else {
      assert false : "Unknown bundle found";
    }
  }
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Test the getBundleData for a two versions, returning multiple bundles that haven't changed
 */
@Test(groups={UNIT}) public void testMultipleBundlesMultipleVersions(){
  Collection<ArtifactData> bundleData=m_backend.getBundleData(MULTIPLEVERSIONTARGET,VERSION1,VERSION1);
  assert bundleData.size() == 2 : "Expected two bundle to be found, but found " + bundleData.size();
  Iterator<ArtifactData> it=bundleData.iterator();
  while (it.hasNext()) {
    ArtifactData data=it.next();
    assert !data.hasChanged() : "The data should not have been changed.";
  }
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Test the getBundleData for a two versions, returning a single bundle that hasn't changed
 */
@Test(groups={UNIT}) public void testSingleUnchangedBundleMultipleVersions(){
  Collection<ArtifactData> bundleData=m_backend.getBundleData(TARGET,VERSION1,VERSION1);
  assert bundleData.size() == 1 : "Expect one bundle, got " + bundleData.size();
  Iterator<ArtifactData> it=bundleData.iterator();
  while (it.hasNext()) {
    ArtifactData data=it.next();
    assert data.getSize() > 200 : "Bundle has no sensible size?!";
    assert !data.hasChanged() : "The data should not have been changed.";
  }
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Test the getBundleData with an illegal version (i.e. a version that doesn't exist)
 */
@Test(groups={UNIT}) public void testInvalidVersionBundleData(){
  try {
    m_backend.getBundleData(INVALIDVERSIONTARGET,INVALIDVERSION);
    assert false : "Expected an error because version " + INVALIDVERSION + " doesn't exist for target"+ INVALIDVERSIONTARGET;
  }
 catch (  IllegalArgumentException iae) {
  }
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Test the getVersions method with an illegal version (not in org.osgi.framework.Version format)
 */
@Test(groups={UNIT}) public void testIllegalVersion(){
  List<String> versions=m_backend.getVersions(INVALIDVERSIONTARGET);
  assert versions.isEmpty() : "Expected no versions to be found, but found " + versions.size();
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Test with multiple versions. It expects all versions in an ascending order.
 */
@Test(groups={UNIT}) public void testMultipleVersions(){
  List<String> versions=m_backend.getVersions(MULTIPLEVERSIONTARGET);
  assert versions.size() == 4 : "Expected three version to be found, but found " + versions.size();
  assert versions.get(0).equals(VERSION1) : "Expected version " + VERSION1 + " but found "+ versions.get(0);
  assert versions.get(1).equals(VERSION2) : "Expected version " + VERSION2 + " but found "+ versions.get(1);
  assert versions.get(2).equals(VERSION3) : "Expected version " + VERSION3 + " but found "+ versions.get(2);
  assert versions.get(3).equals(VERSION4) : "Expected version " + VERSION4 + " but found "+ versions.get(3);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.ace.log.LogDescriptorTest </h4><pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test(groups={UNIT}) public void deserializeDescriptor(){
  Descriptor descriptor=new Descriptor("gwid,1,2-3");
  assert descriptor.getTargetID().equals("gwid") : "Target ID not correctly parsed.";
  assert descriptor.getStoreID() == 1 : "Log ID not correctly parsed.";
  assert descriptor.getRangeSet().toRepresentation().equals("2-3") : "There should be nothing in the diff between the set in the descriptor and the check-set.";
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test(groups={UNIT}) public void serializeDescriptor(){
  Descriptor descriptor=new Descriptor("gwid",1,new SortedRangeSet("2-3"));
  assert descriptor.toRepresentation().equals("gwid,1,2-3") : "The representation of our descriptor is incorrect:" + descriptor.toRepresentation();
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test(groups={UNIT}) public void deserializeMultiRangeDescriptor(){
  Descriptor descriptor=new Descriptor("gwid,1,1-4$k6$k8$k10-20");
  assert descriptor.getTargetID().equals("gwid") : "Target ID not correctly parsed.";
  assert descriptor.getStoreID() == 1 : "Log ID not correctly parsed.";
  String representation=descriptor.getRangeSet().toRepresentation();
  assert representation.equals("1-4,6,8,10-20") : "There should be nothing in the diff between the set in the descriptor and the check-set, but we parsed: " + representation;
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test(groups={UNIT}) public void deserializeMultiRangeDescriptorWithFunnyGWID(){
  String line="gw$$id,1,1-4$k6$k8$k10-20";
  Descriptor descriptor=new Descriptor(line);
  assert descriptor.getTargetID().equals("gw$id") : "Target ID not correctly parsed.";
  assert descriptor.getStoreID() == 1 : "Log ID not correctly parsed.";
  assert line.equals(descriptor.toRepresentation()) : "Converting the line back to the representation failed.";
  String representation=descriptor.getRangeSet().toRepresentation();
  assert representation.equals("1-4,6,8,10-20") : "There should be nothing in the diff between the set in the descriptor and the check-set, but we parsed: " + representation;
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.ace.log.LogEventTest </h4><pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test(groups={UNIT}) public void deserializeLogEvent(){
  Event e=new Event("gwid$kgwid$n$r$$,1,2,3," + AuditEvent.FRAMEWORK_STARTED + ",a,1,b,2,c,3");
  assert e.getTargetID().equals("gwid,gwid\n\r$") : "Target ID is not correctly parsed";
  assert e.getStoreID() == 1 : "Log ID is not correctly parsed";
  assert e.getID() == 2 : "ID is not correctly parsed";
  assert e.getTime() == 3 : "Time is not correctly parsed";
  assert e.getType() == AuditEvent.FRAMEWORK_STARTED : "Event type is wrong";
  Map<String,String> p=e.getProperties();
  assert p != null : "Properties are not correctly parsed";
  assert p.get("a").equals("1") : "Property a should be 1";
  assert p.get("b").equals("2") : "Property a should be 1";
  assert p.get("c").equals("3") : "Property a should be 1";
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test(groups={UNIT}) public void serializeLogEvent(){
  Event e=new Event("gwid",1,2,3,AuditEvent.FRAMEWORK_STARTED);
  assert e.toRepresentation().equals("gwid,1,2,3," + AuditEvent.FRAMEWORK_STARTED);
  Map<String,String> p=new HashMap<>();
  p.put(AuditEvent.KEY_ID,"my first value");
  e=new Event("gwid",1,2,3,AuditEvent.BUNDLE_INSTALLED,p);
  assert e.toRepresentation().equals("gwid,1,2,3," + AuditEvent.BUNDLE_INSTALLED + ","+ AuditEvent.KEY_ID+ ",my first value");
  e=new Event("gwid,gwid\n\r$",1,2,3,AuditEvent.FRAMEWORK_STARTED);
  assert e.toRepresentation().equals("gwid$kgwid$n$r$$,1,2,3," + AuditEvent.FRAMEWORK_STARTED);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.ace.log.listener.LogTest </h4><pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Test whether after unsetting the Log, no new log entries are added, but that they are added to the cache instead
 * (test the latter by flushing the cache).
 */
@Test(groups={UNIT}) public void testUnsettingLog() throws Exception {
  assert ((MockLog)m_mockLog).getLogEntries().size() == 0 : "MockLog is not empty on start of test";
  m_logProxy.setLog(m_mockLog);
  Dictionary<String,Object> props=new Hashtable<>();
  props.put("test","value");
  m_logProxy.log(1,props);
  assert ((MockLog)m_mockLog).getLogEntries().size() == 1 : "MockLog should have 1 log entry";
  m_logProxy.setLog(null);
  Dictionary<String,Object> props2=new Hashtable<>();
  props2.put("test2","value2");
  m_logProxy.log(2,props2);
  assert ((MockLog)m_mockLog).getLogEntries().size() == 1 : "MockLog should still have 1 log entry";
  m_logProxy.setLog(m_mockLog);
  assert ((MockLog)m_mockLog).getLogEntries().size() == 2 : "MockLog should have 2 log entries";
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Test whether logging to the cache and setting a new Log causes the log entries to be flushed to this new Log.
 */
@Test(groups={UNIT}) public void testLogCacheFlush() throws Exception {
  assert ((MockLog)m_mockLog).getLogEntries().size() == 0 : "MockLog is not empty on start of test";
  Dictionary<String,Object> props=new Hashtable<>();
  String test="test";
  String value="value";
  props.put(test,value);
  m_logProxy.log(1,props);
  assert ((MockLog)m_mockLog).getLogEntries().size() == 0 : "MockLog is not empty, but should be as the log should be in the cache";
  m_logProxy.setLog(m_mockLog);
  assert ((MockLog)m_mockLog).getLogEntries().size() == 1 : "Log should contain 1 entry";
  assert ((MockLog.LogEntry)((MockLog)m_mockLog).getLogEntries().get(0)).getProperties().get(test).equals(value) : "The property should be 'test:value'";
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Basic functionality of the ListenerImpl is covered, the rest of the situations will probably be covered by integration
 * tests. Note: test the deployment event INSTALL only when a BundleContext is available
 */
@SuppressWarnings("unchecked") @Test(groups={UNIT}) public void testEventConverting() throws Exception {
  ListenerImpl listeners=new ListenerImpl(null,m_logProxy);
  listeners.startInternal();
  m_logProxy.setLog(m_mockLog);
  final String symbolicName="org.apache.ace.auditlog.listener.testbundle.a";
  final long bundleId=123;
  final String bundleVersion="1.2.3";
  final String bundleLocation="/home/apache/ace/testbundlea.jar";
  Bundle testBundleA=TestUtils.createMockObjectAdapter(Bundle.class,new Object(){
    @SuppressWarnings("all") public long getBundleId(){
      return bundleId;
    }
    @SuppressWarnings("all") public String getSymbolicName(){
      return symbolicName;
    }
    @SuppressWarnings("all") public Dictionary getHeaders(){
      Dictionary dict=new Properties();
      dict.put(Constants.BUNDLE_VERSION,bundleVersion);
      return dict;
    }
    @SuppressWarnings("all") public String getLocation(){
      return bundleLocation;
    }
  }
);
  BundleEvent bundleEvent=new BundleEvent(BundleEvent.INSTALLED,testBundleA);
  FrameworkEvent frameworkEvent=new FrameworkEvent(FrameworkEvent.INFO,testBundleA,new IllegalStateException());
  listeners.bundleChanged(bundleEvent);
  listeners.frameworkEvent(frameworkEvent);
  listeners.stopInternal();
  List<LogEntry> logEntries=((MockLog)m_mockLog).getLogEntries();
  assert logEntries.size() == 2 : "2 log entries should be logged";
  LogEntry bundleEntry=(LogEntry)logEntries.get(0);
  assert bundleEntry.getType() == AuditEvent.BUNDLE_INSTALLED : "state BUNDLE_INSTALLED (" + AuditEvent.BUNDLE_INSTALLED + ") should be in log but '"+ bundleEntry.getType()+ "' is in log instead";
  Dictionary<String,?> bundleProps=bundleEntry.getProperties();
  assert bundleProps.size() == 4 : "4 properties should be stored, but found: " + bundleProps.size();
  assert bundleProps.get(AuditEvent.KEY_ID).equals(Long.toString(bundleId)) : "id should be " + bundleId + " but is: "+ bundleProps.get(AuditEvent.KEY_ID);
  assert bundleProps.get(AuditEvent.KEY_NAME).equals(symbolicName) : "symbolicName should be " + symbolicName + " but is "+ bundleProps.get(AuditEvent.KEY_NAME);
  assert bundleProps.get(AuditEvent.KEY_VERSION).equals(bundleVersion) : "version should be " + bundleVersion + " but is "+ bundleProps.get(AuditEvent.KEY_VERSION);
  assert bundleProps.get(AuditEvent.KEY_LOCATION).equals(bundleLocation) : "location should be " + bundleLocation + " but is "+ bundleProps.get(AuditEvent.KEY_LOCATION);
  LogEntry frameworkEntry=(LogEntry)logEntries.get(1);
  assert frameworkEntry.getType() == AuditEvent.FRAMEWORK_INFO : "state FRAMEWORK_INFO (" + AuditEvent.FRAMEWORK_INFO + ") should be in log but '"+ frameworkEntry.getType()+ "' is in log instead";
  Dictionary<String,?> frameworkProps=frameworkEntry.getProperties();
  assert frameworkProps.size() == 2 : "2 properties should be stored, but found: " + frameworkProps.size();
  assert frameworkProps.get(AuditEvent.KEY_ID).equals(Long.toString(bundleId)) : "id should be " + bundleId + " but is: "+ frameworkProps.get(AuditEvent.KEY_ID);
  assert frameworkProps.get(AuditEvent.KEY_TYPE).equals(IllegalStateException.class.getName()) : "exceptionType should be " + IllegalStateException.class.getName() + " but is: "+ frameworkProps.get(AuditEvent.KEY_TYPE);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.ace.log.server.servlet.LogServletTest </h4><pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test(groups={UNIT}) public void receiveLowestID() throws Exception {
  MockServletOutputStream output=new MockServletOutputStream();
  boolean result=m_logServlet.handleReceiveIDs(m_range.getTargetID(),String.valueOf(m_range.getStoreID()),null,output);
  assert result;
  String expected="";
  String actual=output.m_text;
  assert expected.equals(actual) : "We expected '" + expected + "', but received '"+ actual+ "'";
  m_mockStore.setLowestID(m_range.getTargetID(),m_range.getStoreID(),5);
  output=new MockServletOutputStream();
  result=m_logServlet.handleReceiveIDs(m_range.getTargetID(),String.valueOf(m_range.getStoreID()),null,output);
  assert result;
  expected=m_range.getTargetID() + "," + m_range.getStoreID()+ ",5\n";
  actual=output.m_text;
  assert expected.equals(actual) : "We expected '" + expected + "', but received '"+ actual+ "'";
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test(groups={UNIT}) public void sendLowestID() throws Exception {
  MockServletInputStream input=new MockServletInputStream();
  String expected=m_range.getTargetID() + "," + m_range.getStoreID()+ ",9\n";
  input.setBytes(expected.getBytes());
  m_logServlet.handleSendIDs(input);
  long lowestID=m_mockStore.getLowestID(m_range.getTargetID(),m_range.getStoreID());
  assert 9 == lowestID : "Expected lowest ID to be 9, but got: " + lowestID;
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test(groups={UNIT}) public void queryLogWithTargetFilter() throws Exception {
  MockServletOutputStream output=new MockServletOutputStream();
  boolean result=m_logServlet.handleQuery(m_range.getTargetID(),null,null,output);
  assert result;
  assert m_range.toRepresentation().equals(output.m_text.trim());
  output.m_text="";
  result=m_logServlet.handleQuery(null,null,null,output);
  assert result;
  assert (m_range.toRepresentation() + "\n").equals(output.m_text);
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test(groups={UNIT}) public void receiveLog() throws Exception {
  MockServletOutputStream output=new MockServletOutputStream();
  boolean result=m_logServlet.handleReceive(m_range.getTargetID(),String.valueOf(m_range.getStoreID()),"1",null,output);
  assert result;
  String expected=m_event1.toRepresentation() + "\n";
  String actual=output.m_text;
  assert expected.equals(actual) : "We expected '" + expected + "', but received '"+ actual+ "'";
  output=new MockServletOutputStream();
  result=m_logServlet.handleReceive(m_range.getTargetID(),String.valueOf(m_range.getStoreID()),null,null,output);
  assert result;
  expected=m_event1.toRepresentation() + "\n" + m_event2.toRepresentation()+ "\n";
  actual=output.m_text;
  assert expected.equals(actual) : "We expected '" + expected + "', but received '"+ actual+ "'";
  ;
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test(groups={UNIT}) public void sendLog() throws Exception {
  MockServletInputStream input=new MockServletInputStream();
  String expected=m_event1.toRepresentation() + "\n" + m_event2.toRepresentation()+ "\n";
  input.setBytes(expected.getBytes());
  m_logServlet.handleSend(input);
  String actual="";
  for (Iterator<Event> i=m_mockStore.m_events.iterator(); i.hasNext(); ) {
    Event event=i.next();
    actual=actual + event.toRepresentation() + "\n";
  }
  assert expected.equals(actual);
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test(groups={UNIT}) public void queryLog() throws Exception {
  MockServletOutputStream output=new MockServletOutputStream();
  boolean result=m_logServlet.handleQuery(m_range.getTargetID(),String.valueOf(m_range.getStoreID()),null,output);
  assert result;
  assert m_range.toRepresentation().equals(output.m_text);
  output.m_text="";
  result=m_logServlet.handleQuery(null,null,null,output);
  assert result;
  assert (m_range.toRepresentation() + "\n").equals(output.m_text);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.ace.log.server.store.impl.LogStoreImplConcurrencyTest </h4><pre class="type-11 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Invokes logging operations">Logger</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Invokes logging operations
- Executes methods or other tests from the same test unit
"></span><br>
@Test public void testTimedWrite() throws Exception {
  File storeFile=File.createTempFile("feedback",".store");
  storeFile.deleteOnExit();
  final int recordCount=10000;
  final LogStoreImpl store=createLogStore();
  long start=System.nanoTime();
  for (int i=0; i < recordCount; i++) {
    store.put(Arrays.asList(new Event("1,2,3,4,5")));
  }
  long end=System.nanoTime();
  System.out.printf("Writing %d records took %.3f ms.%n",recordCount,(end - start) / 1.0e6);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.ace.log.server.store.impl.ServerLogStoreTester </h4><pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@SuppressWarnings("serial") @Test(groups={UNIT}) public void testLogOutOfOrder() throws IOException {
  Map<String,String> props=new HashMap<>();
  props.put("test","bar");
  List<Descriptor> ranges=m_logStore.getDescriptors();
  assert ranges.isEmpty() : "New store should have no ranges.";
  List<Event> events=new ArrayList<>();
  events.add(new Event("t1",1,2,2,AuditEvent.FRAMEWORK_STARTED,props));
  events.add(new Event("t1",1,3,3,AuditEvent.FRAMEWORK_STARTED,props));
  events.add(new Event("t1",1,1,1,AuditEvent.FRAMEWORK_STARTED,props));
  m_logStore.put(events);
  assert m_logStore.getDescriptors().size() == 1 : "Incorrect amount of ranges returned from store";
  List<Event> stored=getStoredEvents();
  Set<String> out=new HashSet<>();
  for (  Event event : stored) {
    out.add(event.toRepresentation());
  }
  assert out.size() == 3 : "Stored events differ from the added.";
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test(groups={UNIT}) public void testCreateLogMessagesConcurrently() throws Exception {
  final Properties props=new Properties();
  props.put("test","bar");
  List<Descriptor> ranges=m_logStore.getDescriptors();
  assert ranges.isEmpty() : "New store should have no ranges.";
  ExecutorService exec=Executors.newFixedThreadPool(10);
  for (  final String target : new String[]{"g1","g2","g3","g4","g5","g6","g7","g8","g9","g10"}) {
    exec.execute(new Runnable(){
      public void run(){
        for (long id=0; id < 1000; id++) {
          try {
            m_logStore.put(target,1,props);
          }
 catch (          IOException e) {
            throw new RuntimeException(e);
          }
        }
      }
    }
);
  }
  exec.shutdown();
  exec.awaitTermination(10,TimeUnit.SECONDS);
  assert m_logStore.getDescriptors().size() == 10 : "Incorrect amount of ranges returned from store: " + m_logStore.getDescriptors().size();
  List<Event> stored=getStoredEvents();
  assert stored.size() == 10000 : "Incorrect number of events got stored: " + stored.size();
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test(groups={TestUtils.UNIT}) public void testLogWithSpecialCharacters() throws IOException {
  String targetID="myta\0rget";
  Event event=new Event(targetID,1,1,System.currentTimeMillis(),AuditEvent.FRAMEWORK_STARTED);
  List<Event> events=new ArrayList<>();
  events.add(event);
  m_logStore.put(events);
  assert m_logStore.getDescriptors().size() == 1 : "Incorrect amount of ranges returned from store: expected 1, found " + m_logStore.getDescriptors().size();
  assert m_logStore.getDescriptors(targetID).size() == 1 : "We expect to find a single event: expected 1, found " + m_logStore.getDescriptors(targetID).size();
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@SuppressWarnings({"rawtypes","unchecked"}) @Test(groups={TestUtils.UNIT}) public void testMaximumNumberOfEvents() throws Exception {
  Dictionary settings=new Properties();
  settings.put(MAXIMUM_NUMBER_OF_EVENTS,"1");
  m_logStore.updated(settings);
  List<Event> events=new ArrayList<>();
  for (  String target : new String[]{"target"}) {
    for (    long log : new long[]{1}) {
      for (      long id : new long[]{1,2}) {
        events.add(new Event(target,log,id,System.currentTimeMillis(),AuditEvent.FRAMEWORK_STARTED,new HashMap<String,String>()));
      }
    }
  }
  m_logStore.put(events);
  List<Descriptor> allDescriptors=m_logStore.getDescriptors();
  assert allDescriptors.size() == 1 : "Expected only one descriptor, found: " + allDescriptors.size();
  for (  Descriptor range : allDescriptors) {
    List<Descriptor> allLogsForTarget=m_logStore.getDescriptors(range.getTargetID());
    for (    Descriptor range2 : allLogsForTarget) {
      List<Event> getEvents=m_logStore.get(m_logStore.getDescriptor(range2.getTargetID(),range2.getStoreID()));
      assert getEvents.size() == 1 : "Only one event expected, found " + getEvents.size();
    }
  }
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@SuppressWarnings("serial") @Test(groups={UNIT}) public void testLog() throws IOException {
  Map<String,String> props=new HashMap<>();
  props.put("test","bar");
  List<Descriptor> ranges=m_logStore.getDescriptors();
  assert ranges.isEmpty() : "New store should have no ranges.";
  List<Event> events=new ArrayList<>();
  for (  String target : new String[]{"g1","g2","g3"}) {
    for (    long log : new long[]{1,2,3,5}) {
      for (      long id : new long[]{1,2,3,20}) {
        events.add(new Event(target,log,id,System.currentTimeMillis(),AuditEvent.FRAMEWORK_STARTED,props));
      }
    }
  }
  m_logStore.put(events);
  assert m_logStore.getDescriptors().size() == 3 * 4 : "Incorrect amount of ranges returned from store";
  List<Event> stored=getStoredEvents();
  Set<String> in=new HashSet<>();
  for (  Event event : events) {
    in.add(event.toRepresentation());
  }
  Set<String> out=new HashSet<>();
  for (  Event event : stored) {
    out.add(event.toRepresentation());
  }
  assert in.equals(out) : "Stored events differ from the added.";
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@SuppressWarnings("serial") @Test(groups={UNIT}) public void testLogLowestID() throws IOException {
  Map<String,String> props=new HashMap<>();
  props.put("test","bar");
  List<Descriptor> ranges=m_logStore.getDescriptors();
  assert ranges.isEmpty() : "New store should have no ranges.";
  List<Event> events=new ArrayList<>();
  assert 0 == m_logStore.getLowestID("target",1) : "Lowest ID should be 0 by default, not: " + m_logStore.getLowestID("target",1);
  m_logStore.setLowestID("target",1,10);
  assert 10 == m_logStore.getLowestID("target",1) : "Lowest ID should be 10, not: " + m_logStore.getLowestID("target",1);
  assert 0 == m_logStore.getLowestID("target",0) : "Lowest ID should be 0 by default, not: " + m_logStore.getLowestID("target",1);
  assert 0 == m_logStore.getLowestID("target2",1) : "Lowest ID should be 0 by default, not: " + m_logStore.getLowestID("target",1);
  for (long id=1; id <= 20; id++) {
    events.add(new Event("target",1,id,System.currentTimeMillis(),AuditEvent.FRAMEWORK_STARTED,props));
  }
  m_logStore.put(events);
  List<Descriptor> descriptors=m_logStore.getDescriptors();
  assert descriptors.size() == 1 : "Incorrect amount of ranges returned from store";
  String range=descriptors.get(0).getRangeSet().toRepresentation();
  assert range.equals("10-20") : "Incorrect range in descriptor: " + range;
  List<Event> stored=getStoredEvents();
  assert stored.size() == 11 : "Exactly 11 events should have been stored";
  m_logStore.setLowestID("target",1,20);
  stored=getStoredEvents();
  assert stored.size() == 1 : "Exactly 1 event should have been stored";
  descriptors=m_logStore.getDescriptors();
  assert descriptors.size() == 1 : "Incorrect amount of ranges returned from store";
  range=descriptors.get(0).getRangeSet().toRepresentation();
  assert range.equals("20") : "Incorrect range in descriptor: " + range;
  m_logStore.setLowestID("target",1,21);
  stored=getStoredEvents();
  assert stored.size() == 0 : "No events should have been stored";
  descriptors=m_logStore.getDescriptors();
  assert descriptors.size() == 1 : "Incorrect amount of ranges returned from store";
  range=descriptors.get(0).getRangeSet().toRepresentation();
  assert range.equals("") : "Incorrect range in descriptor: " + range;
  m_logStore.setLowestID("target",1,100);
  stored=getStoredEvents();
  assert stored.size() == 0 : "No events should have been stored";
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@SuppressWarnings({"rawtypes","unchecked"}) @Test(groups={TestUtils.UNIT}) public void testClean() throws Exception {
  List<Event> events=new ArrayList<>();
  for (  String target : new String[]{"target"}) {
    for (    long log : new long[]{1,2}) {
      for (      long id : new long[]{1,2,3,4}) {
        events.add(new Event(target,log,id,System.currentTimeMillis(),AuditEvent.FRAMEWORK_STARTED,new HashMap<String,String>()));
      }
    }
  }
  m_logStore.put(events);
  Dictionary settings=new Properties();
  settings.put(MAXIMUM_NUMBER_OF_EVENTS,"1");
  m_logStore.updated(settings);
  m_logStore.clean();
  List<Descriptor> allDescriptors=m_logStore.getDescriptors();
  assert allDescriptors.size() == 2 : "Expected two descriptor, found: " + allDescriptors.size();
  for (  Descriptor range : allDescriptors) {
    List<Descriptor> allLogsForTarget=m_logStore.getDescriptors(range.getTargetID());
    for (    Descriptor range2 : allLogsForTarget) {
      List<Event> getEvents=m_logStore.get(m_logStore.getDescriptor(range2.getTargetID(),range2.getStoreID()));
      assert getEvents.size() == 1 : "Only one event expected, found " + getEvents.size();
    }
  }
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@SuppressWarnings("serial") @Test(groups={UNIT}) public void testConcurrentLog() throws IOException, InterruptedException {
  ExecutorService es=Executors.newFixedThreadPool(8);
  final Map<String,String> props=new HashMap<>();
  props.put("test","bar");
  List<Descriptor> ranges=m_logStore.getDescriptors();
  assert ranges.isEmpty() : "New store should have no ranges.";
  for (  String target : new String[]{"g1","g2","g3"}) {
    for (    long log : new long[]{1,2,3,5}) {
      for (long id=0; id < 500; id++) {
        final String t=target;
        final long l=log;
        final long i=id;
        es.execute(new Runnable(){
          @Override public void run(){
            List<Event> list=new ArrayList<>();
            list.add(new Event(t,l,i,System.currentTimeMillis(),AuditEvent.FRAMEWORK_STARTED,props));
            try {
              m_logStore.put(list);
            }
 catch (            IOException e) {
              e.printStackTrace();
            }
          }
        }
);
      }
    }
  }
  es.shutdown();
  es.awaitTermination(60,TimeUnit.SECONDS);
  int size=m_logStore.getDescriptors().size();
  assert size == 3 * 4 : "Incorrect amount of ranges returned from store: " + size;
  List<Event> stored=getStoredEvents();
  Set<String> out=new HashSet<>();
  for (  Event event : stored) {
    out.add(event.toRepresentation());
  }
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@SuppressWarnings({"rawtypes","unchecked"}) @Test(groups={TestUtils.UNIT}) public void testMaximumNumberOfEventsMultipleLogs() throws Exception {
  Dictionary settings=new Properties();
  settings.put(MAXIMUM_NUMBER_OF_EVENTS,"1");
  m_logStore.updated(settings);
  List<Event> events=new ArrayList<>();
  for (  String target : new String[]{"target"}) {
    for (    long log : new long[]{1,2}) {
      for (      long id : new long[]{1,2}) {
        events.add(new Event(target,log,id,System.currentTimeMillis(),AuditEvent.FRAMEWORK_STARTED,new HashMap<String,String>()));
      }
    }
  }
  m_logStore.put(events);
  List<Descriptor> allDescriptors=m_logStore.getDescriptors();
  assert allDescriptors.size() == 2 : "Expected two descriptor, found: " + allDescriptors.size();
  for (  Descriptor range : allDescriptors) {
    List<Descriptor> allLogsForTarget=m_logStore.getDescriptors(range.getTargetID());
    for (    Descriptor range2 : allLogsForTarget) {
      List<Event> getEvents=m_logStore.get(m_logStore.getDescriptor(range2.getTargetID(),range2.getStoreID()));
      assert getEvents.size() == 1 : "Only one event expected, found " + getEvents.size();
    }
  }
}

</code></pre>

<br>
<pre class="type-11 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Invokes logging operations">Logger</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Invokes logging operations
- Executes methods or other tests from the same test unit
"></span><br>
@SuppressWarnings("serial") @Test(groups={UNIT}) public void testLogIDGenerationWithLowestID() throws IOException {
  Dictionary<String,String> props=new Hashtable<>();
  props.put("test","foo");
  long logID=0;
  for (long id=1; id <= 20; id++) {
    Event event=m_logStore.put("target",1,props);
    System.out.println("Event: " + event.toRepresentation());
    logID=event.getStoreID();
  }
  List<Descriptor> descriptors=m_logStore.getDescriptors();
  assert descriptors.size() == 1 : "Incorrect amount of ranges returned from store";
  String range=descriptors.get(0).getRangeSet().toRepresentation();
  assert range.equals("1-20") : "Incorrect range in descriptor: " + range;
  List<Event> stored=getStoredEvents();
  assert stored.size() == 20 : "Exactly 20 events should have been stored";
  m_logStore.setLowestID("target",logID,10);
  assert 10 == m_logStore.getLowestID("target",logID) : "Lowest ID should be 10, not: " + m_logStore.getLowestID("target",logID);
  stored=getStoredEvents();
  assert stored.size() == 11 : "Exactly 11 events should have been stored, we found " + stored.size();
  descriptors=m_logStore.getDescriptors();
  assert descriptors.size() == 1 : "Incorrect amount of ranges returned from store";
  range=descriptors.get(0).getRangeSet().toRepresentation();
  assert range.equals("10-20") : "Incorrect range in descriptor: " + range;
  m_logStore.setLowestID("target",logID,21);
  stored=getStoredEvents();
  assert stored.size() == 0 : "No events should have been stored, we found " + stored.size();
  descriptors=m_logStore.getDescriptors();
  assert descriptors.size() == 1 : "Incorrect amount of ranges returned from store";
  range=descriptors.get(0).getRangeSet().toRepresentation();
  assert range.equals("") : "Incorrect range in descriptor: " + range;
  for (long id=1; id <= 20; id++) {
    System.out.println("Event: " + m_logStore.put("target",1,props).toRepresentation());
  }
  stored=getStoredEvents();
  assert stored.size() == 20 : "Exactly 20 events should have been stored, we found " + stored.size();
  descriptors=m_logStore.getDescriptors();
  assert descriptors.size() == 1 : "Incorrect amount of ranges returned from store";
  range=descriptors.get(0).getRangeSet().toRepresentation();
  assert range.equals("21-40") : "Incorrect range in descriptor: " + range;
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@SuppressWarnings("serial") @Test(groups={UNIT}) public void testLogOutOfOrderOneByOne() throws IOException {
  Map<String,String> props=new HashMap<>();
  props.put("test","bar");
  List<Descriptor> ranges=m_logStore.getDescriptors();
  assert ranges.isEmpty() : "New store should have no ranges.";
  List<Event> events=new ArrayList<>();
  events.add(new Event("t1",1,2,2,AuditEvent.FRAMEWORK_STARTED,props));
  m_logStore.put(events);
  events.clear();
  events.add(new Event("t1",1,3,3,AuditEvent.FRAMEWORK_STARTED,props));
  m_logStore.put(events);
  events.clear();
  events.add(new Event("t1",1,1,1,AuditEvent.FRAMEWORK_STARTED,props));
  m_logStore.put(events);
  assert m_logStore.getDescriptors().size() == 1 : "Incorrect amount of ranges returned from store";
  List<Event> stored=getStoredEvents();
  Set<String> out=new HashSet<>();
  for (  Event event : stored) {
    out.add(event.toRepresentation());
  }
  assert out.size() == 3 : "Stored events differ from the added: " + out.size();
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.ace.log.target.store.impl.GatewayLogStoreTest </h4><pre class="type-5 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies that exceptions are thrown during the test case execution">ExceptionVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies that exceptions are thrown during the test case execution
- Executes methods or other tests from the same test unit
"></span><br>
@Test(groups={UNIT},expectedExceptions={IOException.class}) public void testExceptionHandling() throws IOException {
  m_logStore.handleException(m_logStore.getLog(4711),new IOException("test"));
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@SuppressWarnings({"serial"}) @Test(groups={UNIT}) public void testLog() throws IOException {
  long[] ids=m_logStore.getLogIDs();
  assert ids.length == 1 : "New store should have only one id";
  List<String> events=new ArrayList<>();
  events.add(m_logStore.put(AuditEvent.FRAMEWORK_STARTED,new Properties(){
{
      put("test","test");
    }
  }
).toRepresentation());
  events.add(m_logStore.put(AuditEvent.BUNDLE_INSTALLED,new Properties(){
{
      put("test","test");
    }
  }
).toRepresentation());
  events.add(m_logStore.put(AuditEvent.DEPLOYMENTADMIN_COMPLETE,new Properties(){
{
      put("test","test");
    }
  }
).toRepresentation());
  ids=m_logStore.getLogIDs();
  assert ids.length == 1 : "Error free store should have only one id";
  long highest=m_logStore.getHighestID(ids[0]);
  assert highest == 3 : "Store with 3 entries should have 3 as highest id but was: " + highest;
  List<String> result=new ArrayList<>();
  for (  Event event : (List<Event>)m_logStore.get(ids[0])) {
    result.add(event.toRepresentation());
  }
  assert result.equals(events) : "Events " + events + " should equal full log "+ result;
  result=new ArrayList<>();
  for (  Event event : (List<Event>)m_logStore.get(ids[0],1,highest)) {
    result.add(event.toRepresentation());
  }
  assert result.equals(events) : "Events " + events + " should equal full log "+ result;
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.ace.log.target.task.LogSyncTaskTest </h4><pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test(groups={UNIT}) public synchronized void getRange() throws Exception {
  final Descriptor range=new Descriptor(TARGET_ID,1,new SortedRangeSet("1-10"));
  m_task.getDescriptor(new InputStream(){
    int m_count=0;
    byte[] m_bytes=(range.toRepresentation() + "\n").getBytes();
    @Override public int read() throws IOException {
      if (m_count < m_bytes.length) {
        byte b=m_bytes[m_count];
        m_count++;
        return b;
      }
 else {
        return -1;
      }
    }
  }
);
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test(groups={UNIT}) public synchronized void synchronizeLog() throws Exception {
  final Descriptor range=new Descriptor(TARGET_ID,1,new SortedRangeSet(new long[]{0}));
  final Event event=new Event(TARGET_ID,1,1,1,1);
  final List<Event> events=new ArrayList<>();
  events.add(event);
  InputStream input=new InputStream(){
    byte[] bytes=range.toRepresentation().getBytes();
    int count=0;
    @Override public int read() throws IOException {
      if (count < bytes.length) {
        byte b=bytes[count];
        count++;
        return b;
      }
 else {
        return -1;
      }
    }
  }
;
  TestUtils.configureObject(m_task,LogStore.class,new LogStore(){
    public List<?> get(    long logID,    long from,    long to) throws IOException {
      return events;
    }
    public long getHighestID(    long logID) throws IOException {
      return event.getID();
    }
    public List<?> get(    long logID) throws IOException {
      return null;
    }
    public long[] getLogIDs() throws IOException {
      return null;
    }
    public Event put(    int type,    Dictionary props) throws IOException {
      return null;
    }
  }
);
  MockConnection connection=new MockConnection(new URL("http://mock"));
  m_task.synchronizeLog(1,input,connection);
  String expectedString=event.toRepresentation() + "\n";
  String actualString=connection.getString();
  assert actualString.equals(expectedString) : "We expected " + expectedString + " but received "+ actualString;
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.ace.obr.metadata.bindeximpl.BindexMetadataTest </h4><pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Generate metadata index, verify contents
 */
@Test(groups={UNIT}) public void generateMetaData() throws Exception {
  File dir=File.createTempFile("meta","");
  dir.delete();
  dir.mkdir();
  generateBundle(File.createTempFile("bundle",".jar",dir),"bundle.symbolicname.1","1.0.0");
  generateBundle(File.createTempFile("bundle",".jar",dir),"bundle.symbolicname.2","1.0.0");
  generateBundle(File.createTempFile("bundle",".jar",dir),"bundle.symbolicname.3","1.0.0");
  MetadataGenerator meta=new BIndexMetadataGenerator();
  meta.generateMetadata(dir);
  File index=new File(dir,"repository.xml");
  assert index.exists() : "No repository index was generated";
  assert index.length() > 0 : "Repository index can not be size 0";
  int count=0;
  String line;
  BufferedReader in=new BufferedReader(new FileReader(index));
  while ((line=in.readLine()) != null) {
    if (line.contains("<resource")) {
      count++;
    }
  }
  in.close();
  assert count == 3 : "Expected 3 resources in the repository index, found " + count + ".";
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Generate metadata index with partially invalid contents, verify contents
 */
@Test(groups={UNIT}) public void generatePartiallyInvalidMetaData() throws Exception {
  File dir=File.createTempFile("meta","");
  dir.delete();
  dir.mkdir();
  generateBundle(File.createTempFile("bundle",".jar",dir),"bundle.symbolicname.1","1.0.0");
  generateBundle(File.createTempFile("bundle",".jar",dir),"bundle.symbolicname.2","1.0_0");
  generateBundle(File.createTempFile("bundle",".jar",dir),"bundle.symbolicname.3","1.0.0");
  MetadataGenerator meta=new BIndexMetadataGenerator();
  meta.generateMetadata(dir);
  File index=new File(dir,"repository.xml");
  assert index.exists() : "No repository index was generated";
  assert index.length() > 0 : "Repository index can not be size 0";
  int count=0;
  String line;
  BufferedReader in=new BufferedReader(new FileReader(index));
  while ((line=in.readLine()) != null) {
    if (line.contains("<resource")) {
      count++;
    }
  }
  in.close();
  assert count == 2 : "Expected 2 resources in the repository index, found " + count + ".";
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Generate a metadata index, remove a bundle, regenerate metadata, verify.
 */
@Test(groups={UNIT}) public void updateMetaData() throws Exception {
  File dir=File.createTempFile("meta","");
  dir.delete();
  dir.mkdir();
  File bundle=File.createTempFile("bundle",".jar",dir);
  generateBundle(bundle,"bundle.symbolicname.1","1.0.0");
  MetadataGenerator meta=new BIndexMetadataGenerator();
  meta.generateMetadata(dir);
  bundle.delete();
  meta.generateMetadata(dir);
  File index=new File(dir,"repository.xml");
  assert index.exists() : "No repository index was generated";
  assert index.length() > 0 : "Repository index can not be size 0";
  int count=0;
  String line;
  BufferedReader in=new BufferedReader(new FileReader(index));
  while ((line=in.readLine()) != null) {
    if (line.contains("<resource")) {
      count++;
    }
  }
  in.close();
  assert count == 0 : "Expected 0 resources in the repository index, found " + count + ".";
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.ace.obr.metadata.util.ResourceMetaDataTest </h4><pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test(groups={UNIT}) public void checkConfigurationTemplateMetadataGeneration() throws Exception {
  ResourceMetaData data=ResourceMetaData.getArtifactMetaData("org.foo.configuration-1.0.0.xml-target-1-2.0.0.xml");
  assert "org.foo.configuration-1.0.0.xml-target-1".equals(data.getSymbolicName()) : "Generated symbolic name should be 'org.foo.configuration-1.0.0.xml-target-1', was " + data.getSymbolicName();
  assert "2.0.0".equals(data.getVersion()) : "Generated version should be '2.0.0', was " + data.getVersion();
  assert "xml".equals(data.getExtension()) : "Extension should be 'xml', was " + data.getExtension();
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test(groups={UNIT}) public void checkBundleMetadataGeneration() throws Exception {
  ResourceMetaData data=ResourceMetaData.getBundleMetaData(createBundle("foo.bar","1.0.3"));
  assert "foo.bar".equals(data.getSymbolicName()) : "Generated symbolic name should be 'foo.bar', was " + data.getSymbolicName();
  assert "1.0.3".equals(data.getVersion()) : "Generated version should be '1.0.3', was " + data.getVersion();
  assert "jar".equals(data.getExtension()) : "Extension should be 'xml', was " + data.getExtension();
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test(groups={UNIT}) public void checkArtifactMetadataGeneration() throws Exception {
  ResourceMetaData data=ResourceMetaData.getArtifactMetaData("foo.bar-1.0.3.xml");
  assert "foo.bar".equals(data.getSymbolicName()) : "Generated symbolic name should be 'foo.bar', was " + data.getSymbolicName();
  assert "1.0.3".equals(data.getVersion()) : "Generated version should be '1.0.3', was " + data.getVersion();
  assert "xml".equals(data.getExtension()) : "Extension should be 'xml', was " + data.getExtension();
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.ace.obr.servlet.BundleServletTest </h4><pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test(groups={UNIT}) public void testPostResource() throws Exception {
  m_requestFile="NewFile";
  m_bundleServlet.doPost(m_request,m_response);
  assert m_status == HttpServletResponse.SC_CREATED;
  m_requestFile="ExistingFile";
  m_bundleServlet.doPost(m_request,m_response);
  assert m_status == HttpServletResponse.SC_CONFLICT;
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test(groups={UNIT}) public void testGetValidResource() throws Exception {
  m_requestFile=m_testFile.getName();
  m_bundleServlet.doGet(m_request,m_response);
  assert m_status == HttpServletResponse.SC_OK : "We should have got response code " + HttpServletResponse.SC_OK + " and we got "+ m_status;
  boolean checkStream=checkOutputStreamForFile();
  assert checkStream : "One stream stopped before the other one did.";
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test(groups={UNIT}) public void testGetInValidResource() throws Exception {
  m_requestFile="UnknownFile";
  m_bundleServlet.doGet(m_request,m_response);
  assert m_status == HttpServletResponse.SC_NOT_FOUND : "We should have got response code " + HttpServletResponse.SC_NOT_FOUND + " and we got "+ m_status;
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test(groups={UNIT}) public void testRemoveResource() throws Exception {
  m_requestFile="RemoveMe";
  m_bundleServlet.doDelete(m_request,m_response);
  assert m_status == HttpServletResponse.SC_OK;
  m_requestFile="NonExistingFile";
  m_bundleServlet.doDelete(m_request,m_response);
  assert m_status == HttpServletResponse.SC_NOT_FOUND;
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test(groups={UNIT}) public void testRemoveResourceInPath() throws Exception {
  m_requestFile="path/to/file";
  m_bundleServlet.doDelete(m_request,m_response);
  assert m_status == HttpServletResponse.SC_OK;
  m_requestFile="path/to/NonExistingFile";
  m_bundleServlet.doDelete(m_request,m_response);
  assert m_status == HttpServletResponse.SC_NOT_FOUND;
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.ace.obr.storage.file.BundleFileStoreTest </h4><pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Test whether changing the directory where the bundles are stored to something that is not a directory, this
 * should fail.
 */
@Test(groups={UNIT}) public void updateConfigurationWithIsNotDirectory() throws Exception {
  boolean exceptionThrown=false;
  File file=new File(m_directory.getAbsolutePath(),"file");
  file.createNewFile();
  Dictionary<String,Object> props=new Hashtable<>();
  props.put(OBRFileStoreConstants.FILE_LOCATION_KEY,file.getAbsolutePath());
  try {
    m_bundleStore.updated(props);
  }
 catch (  ConfigurationException e) {
    exceptionThrown=true;
  }
  assert exceptionThrown : "Reconfiguring directory succeeded, but should fail as it is no directory";
  file.delete();
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Test whether the metadata is generated when getting a bundle from the repository.
 */
@Test(groups={UNIT}) public void getBundle() throws Exception {
  m_bundleStore.get(m_bundleSubstitute1.getName());
  assert !m_metadata.generated() : "During getting a bundle, the metadata should not be regenerated.";
}

</code></pre>

<br>
<pre class="type-5 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies that exceptions are thrown during the test case execution">ExceptionVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies that exceptions are thrown during the test case execution
- Executes methods or other tests from the same test unit
"></span><br>
@Test(groups={UNIT},expectedExceptions={IOException.class},expectedExceptionsMessageRegExp="Not a valid bundle and no filename found.*") public void putArtifactFail1() throws Exception {
  File bundle=createTmpResource(null,null);
  m_bundleStore.put(new FileInputStream(bundle),null,false);
}

</code></pre>

<br>
<pre class="type-5 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies that exceptions are thrown during the test case execution">ExceptionVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies that exceptions are thrown during the test case execution
- Executes methods or other tests from the same test unit
"></span><br>
@Test(groups={UNIT},expectedExceptions={IOException.class},expectedExceptionsMessageRegExp="Not a valid bundle and no filename found.*") public void putArtifactFail2() throws Exception {
  File bundle=createTmpResource(null,null);
  m_bundleStore.put(new FileInputStream(bundle),"",false);
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Test whether not configuring the directory (so retrieving the directory returns null), results in a
 * ConfigurationException. Updating with null as dictionary should only clean up things, and nothing else.
 */
@Test(groups={UNIT}) public void updateConfigurationWithNull() throws Exception {
  boolean exceptionThrown=false;
  Dictionary<String,Object> props=new Hashtable<>();
  try {
    m_bundleStore.updated(props);
  }
 catch (  ConfigurationException e) {
    exceptionThrown=true;
  }
  assert exceptionThrown : "Reconfiguring directory succeeded but should fail, as property is supposed to be missing";
  assert !m_metadata.generated() : "After changing the directory, the metadata should not be regenerated.";
  exceptionThrown=false;
  try {
    m_bundleStore.updated(null);
  }
 catch (  ConfigurationException e) {
    exceptionThrown=true;
  }
  assert !exceptionThrown : "Reconfiguring succeeded as the bundle should only do the clean up, and not throw exception";
  assert !m_metadata.generated() : "After changing the directory, the metadata should not be regenerated.";
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Test whether changing the directory where the bundles are stored, does not result in a call to the (mock)
 * metadata generator, as the metadata will only be regenerated after getting a file.
 */
@Test(groups={UNIT}) public void updateConfigurationWithValidConfiguration() throws Exception {
  File subDir=new File(m_directory.getAbsolutePath(),"changedDirectory");
  subDir.mkdir();
  Dictionary<String,Object> props=new Hashtable<>();
  props.put(OBRFileStoreConstants.FILE_LOCATION_KEY,subDir.getAbsolutePath());
  try {
    m_bundleStore.updated(props);
  }
 catch (  ConfigurationException e) {
    assert false : "Reconfiguring directory failed, directory was '" + m_directory + "' but should be '"+ subDir+ "'";
  }
  assert !m_metadata.generated() : "After changing the directory, the metadata should not be regenerated.";
  subDir.delete();
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Test whether not configuring the directory (so retrieving the directory returns null), results in a
 * ConfigurationException.
 */
@Test(groups={UNIT}) public void updateConfigurationWithSameDirectory() throws Exception {
  Dictionary<String,Object> props=new Hashtable<>();
  props.put(OBRFileStoreConstants.FILE_LOCATION_KEY,m_directory.getAbsolutePath());
  try {
    m_bundleStore.updated(props);
  }
 catch (  ConfigurationException e) {
    assert false : "Nothing should happen, as the directory did not change";
  }
  assert !m_metadata.generated() : "After changing the directory, the metadata should not be regenerated.";
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test(groups={UNIT}) public void putArtifactDefaultVersion() throws Exception {
  File bundle=createTmpResource(null,null);
  String filePath=m_bundleStore.put(new FileInputStream(bundle),"foo.bar.xxx",false);
  assert filePath.equals("foo/foo.bar.xxx");
  File file=new File(m_directory,filePath);
  assert file.exists();
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test(groups={UNIT}) public void putBundleSameDuplicate() throws Exception {
  File bundle=createTmpResource("foo.bar","1.0.0");
  String filePath=m_bundleStore.put(new FileInputStream(bundle),null,false);
  assert filePath != null;
  String filePath2=m_bundleStore.put(new FileInputStream(bundle),null,false);
  assert filePath2 != null;
  assert filePath2.equals(filePath);
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Test whether the BundleStore notices the set of bundles has not changed, and thus will not make a call to the
 * (mock) metadata generator.
 */
@Test(groups={UNIT}) public void replaceWithSameBundle() throws Exception {
  m_bundleStore.get("bundleSub1.jar");
  assert m_metadata.numberOfCalls() == 0 : "The MetadataGenerator should not be called";
  FileInputStream inputStream=new FileInputStream(m_bundleSubstitute1);
  byte[] buffer=new byte[1000];
  inputStream.read(buffer);
  inputStream.close();
  m_bundleSubstitute1.delete();
  File newFile=new File(m_directory,"bundleSub1.jar");
  FileOutputStream outputStream=new FileOutputStream(newFile);
  outputStream.write(buffer);
  outputStream.close();
  m_bundleStore.get("bundleSub1.jar");
  assert m_metadata.numberOfCalls() == 0 : "The MetadataGenerator should still not be called";
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test(groups={UNIT}) public void removeBundle() throws Exception {
  File bundle=createTmpResource("foo.bar","1.0.0");
  String filePath=m_bundleStore.put(new FileInputStream(bundle),null,false);
  File file=new File(m_directory,filePath);
  assert file.exists();
  assert m_bundleStore.remove(filePath);
  assert !file.exists();
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test(groups={UNIT}) public void putArtifactMavenVersion() throws Exception {
  File bundle=createTmpResource(null,null);
  String filePath=m_bundleStore.put(new FileInputStream(bundle),"foo.bar-2.3.7-test1.xxx",false);
  assert filePath.equals("foo/foo.bar-2.3.7-test1.xxx");
  File file=new File(m_directory,filePath);
  assert file.exists();
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test(groups={UNIT}) public void putBundleDifferentDuplicate() throws Exception {
  File bundle=createTmpResource("foo.bar","1.0.0",new byte[]{1});
  File bundle2=createTmpResource("foo.bar","1.0.0",new byte[]{2});
  String filePath=m_bundleStore.put(new FileInputStream(bundle),null,false);
  assert filePath != null;
  String filePath2=m_bundleStore.put(new FileInputStream(bundle2),null,false);
  assert filePath2 == null;
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test(groups={UNIT}) public void removeArtifact() throws Exception {
  File bundle=createTmpResource(null,null);
  String filePath=m_bundleStore.put(new FileInputStream(bundle),"foo.bar-2.3.7.test1.xxx",false);
  assert filePath.equals("foo/foo.bar-2.3.7.test1.xxx");
  File file=new File(m_directory,filePath);
  assert file.exists();
  assert m_bundleStore.remove("foo/foo.bar-2.3.7.test1.xxx");
  assert !file.exists();
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test(groups={UNIT}) public void removeBundleFaill() throws Exception {
  File file=new File(m_directory,"no/such/file");
  assert !file.exists();
  assert !m_bundleStore.remove("no/such/file");
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Test whether retrieving the repository.xml results in a call to the (mock) metadata generator, and the original
 * file should correspond with the retrieved file.
 */
@Test(groups={UNIT}) public void getRepositoryFile() throws Exception {
  InputStream newInputStream=m_bundleStore.get("repository.xml");
  assert m_metadata.generated() : "During getting the repository file, the metadata should be regenerated.";
  byte[] orgContentBuffer=new byte[1000];
  newInputStream.read(orgContentBuffer);
  FileInputStream orgInputStream=new FileInputStream(m_bundleRepositoryFile);
  byte[] newContentBuffer=new byte[1000];
  orgInputStream.read(newContentBuffer);
  orgInputStream.close();
  assert Arrays.equals(orgContentBuffer,newContentBuffer) : "The original repository.xml content should equal the newly retrieved content.";
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test(groups={UNIT}) public void putRemoveArtifact() throws Exception {
  File bundle=createTmpResource(null,null);
  String filePath=m_bundleStore.put(new FileInputStream(bundle),"foo.bar-2.3.7.test1.xxx",false);
  assert filePath.equals("foo/foo.bar-2.3.7.test1.xxx");
  File file=new File(m_directory,filePath);
  assert file.exists();
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test(groups={UNIT}) public void putBundle() throws Exception {
  File bundle=createTmpResource("foo.bar","1.0.0");
  String filePath=m_bundleStore.put(new FileInputStream(bundle),null,false);
  assert filePath.equals("foo/foo.bar-1.0.0.jar") : "Path should be 'foo/foo.bar-1.0.0.jar', was " + filePath;
  File file=new File(m_directory,filePath);
  assert file.exists();
}

</code></pre>

<br>
<pre class="type-5 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies that exceptions are thrown during the test case execution">ExceptionVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies that exceptions are thrown during the test case execution
- Executes methods or other tests from the same test unit
"></span><br>
@Test(groups={UNIT},expectedExceptions={IOException.class},expectedExceptionsMessageRegExp="Not a valid bundle and no filename found.*") public void putBundleFail() throws Exception {
  File bundle=createTmpResource(null,"1.0.0");
  String filePath=m_bundleStore.put(new FileInputStream(bundle),null,false);
  assert filePath.equals("foo/bar/foo.bar-1.0.0.jar") : "Path should be 'foo/bar/foo.bar-1.0.0.jar', was " + filePath;
  File file=new File(m_directory,filePath);
  assert file.exists();
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Test whether the BundleStore notices the set of bundles has changed (bundle updated), and makes a call to the
 * (mock) metadata generator.
 */
@Test(groups={UNIT}) public void updateBundle() throws Exception {
  m_bundleStore.get("repository.xml");
  assert m_metadata.numberOfCalls() == 1 : "The MetadataGenerator should be called once";
  m_bundleSubstitute1Larger=createFileWithContent(m_directory.getAbsoluteFile(),"bundleSub1.jar",2000);
  m_bundleStore.get("repository.xml");
  assert m_metadata.numberOfCalls() == 2 : "The MetadataGenerator should be called twice";
  m_bundleSubstitute1Larger.delete();
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Test that the bundle store reutrns null for non-existing files.
 */
@Test(groups={UNIT}) public void getNonExistingBundle() throws Exception {
  assert m_bundleStore.get("blaat") == null : "Getting an non-existing file did not result in null?";
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Test whether the BundleStore notices the set of bundles has changed (bundle added), and makes a call to the
 * (mock) metadata generator. Also a call should be made when a bundle is replaced by another one (number of bundles
 * stay the same, but one bundle is replaced by another).
 */
@Test(groups={UNIT}) public void addBundle() throws Exception {
  m_bundleStore.get("repository.xml");
  assert m_metadata.numberOfCalls() == 1 : "The MetadataGenerator should be called once";
  File bundleSubstituteX=createFileWithContent(m_directory.getAbsoluteFile(),"bundleSubX.jar",2000);
  m_bundleStore.get("repository.xml");
  assert m_metadata.numberOfCalls() == 2 : "The MetadataGenerator should be called twice";
  bundleSubstituteX.delete();
  File bundleSubstituteY=createFileWithContent(m_directory.getAbsoluteFile(),"bundleSubY.jar",2000);
  m_bundleStore.get("repository.xml");
  assert m_metadata.numberOfCalls() == 3 : "The MetadataGenerator should be called three times";
  bundleSubstituteY.delete();
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.ace.range.SortedRangeSetTest </h4><pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test(groups={UNIT}) public void validateRangeIterators(){
  SortedRangeSet srs1=new SortedRangeSet("1-10");
  Iterator i1=srs1.rangeIterator();
  assert i1.hasNext() : "We should have one Range instance in our iterator.";
  assert ((Range)i1.next()).toRepresentation().equals("1-10");
  assert !i1.hasNext() : "There should be only one instance in our iterator.";
  SortedRangeSet srs2=new SortedRangeSet("1-5,8,10-15");
  Iterator i2=srs2.rangeIterator();
  assert i2.hasNext() && i2.next() instanceof Range && i2.hasNext()&& i2.next() instanceof Range&& i2.hasNext()&& i2.next() instanceof Range&& !i2.hasNext() : "There should be exactly three Range instances in our iterator.";
  SortedRangeSet srs3=new SortedRangeSet("");
  assert !srs3.iterator().hasNext() : "Iterator should be empty.";
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test(groups={UNIT}) public void manipulateSimpleRanges(){
  Range r1=new Range("5");
  assert r1.getLow() == 5 : "Lowest value should be 5";
  assert r1.getHigh() == 5 : "Highest value should be 5";
  assert r1.contains(5) : "Range should contain 5";
  assert !r1.contains(4) : "Range should not contain 4";
  assert !r1.contains(6) : "Range should not contain 6";
  assert "5".equals(r1.toRepresentation()) : "Representation should be 5";
  Range r2=new Range("2-6");
  assert r2.getLow() == 2 : "Lowest value should be 2";
  assert r2.getHigh() == 6 : "Highest value should be 6";
  assert r2.contains(6) : "Range should contain 6";
  assert !r2.contains(7) : "Range should not contain 7";
  assert !r2.contains(0) : "Range should not contain 0";
  assert "2-6".equals(r2.toRepresentation()) : "Representation should be 2-6";
  Range r3=new Range(5);
  assert r3.getLow() == 5 : "Lowest value should be 5";
  assert r3.getHigh() == 5 : "Highest value should be 5";
  Range r4=new Range(6,8);
  assert r4.getLow() == 6 : "Lowest value should be 6";
  assert r4.getHigh() == 8 : "Highest value should be 8";
  Range r5=new Range(5);
  r5.setLow(8);
  assert r5.getHigh() == 8 : "Highest value should be 8";
  r5.setHigh(2);
  assert r5.getLow() == 2 : "Lowest value should be 2";
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.ace.repository.impl.RepositoryImplTest </h4><pre class="type-5 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies that exceptions are thrown during the test case execution">ExceptionVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies that exceptions are thrown during the test case execution
- Executes methods or other tests from the same test unit
"></span><br>
@Test(groups={UNIT},expectedExceptions={IllegalArgumentException.class}) public void testGetVersionZeroForEmptyRepositoryFail() throws Exception {
  RepositoryImpl repo=new RepositoryImpl(new File(m_baseDir,"data"),new File(m_baseDir,"tmp"),true);
  repo.get(0);
}

</code></pre>

<br>
<pre class="type-5 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies that exceptions are thrown during the test case execution">ExceptionVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies that exceptions are thrown during the test case execution
- Executes methods or other tests from the same test unit
"></span><br>
@Test(groups={UNIT},expectedExceptions={IOException.class}) public void testCommitNonExistingVersionFail() throws Exception {
  RepositoryImpl repo=new RepositoryImpl(new File(m_baseDir,"data"),new File(m_baseDir,"tmp"),true);
  InputStream data=new ByteArrayInputStream("abc".getBytes());
  repo.commit(data,0);
  data=new ByteArrayInputStream("def".getBytes());
  repo.commit(data,2);
}

</code></pre>

<br>
<pre class="type-5 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies that exceptions are thrown during the test case execution">ExceptionVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies that exceptions are thrown during the test case execution
- Executes methods or other tests from the same test unit
"></span><br>
@Test(groups={UNIT},expectedExceptions={IllegalArgumentException.class}) public void testCheckoutVersionZeroOnEmptyRepositoryFail() throws Exception {
  RepositoryImpl repo=new RepositoryImpl(new File(m_baseDir,"data"),new File(m_baseDir,"tmp"),true);
  repo.checkout(0);
}

</code></pre>

<br>
<pre class="type-5 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies that exceptions are thrown during the test case execution">ExceptionVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies that exceptions are thrown during the test case execution
- Executes methods or other tests from the same test unit
"></span><br>
@Test(groups={UNIT},expectedExceptions={IllegalArgumentException.class}) public void testGetNegativeVersionFail() throws Exception {
  RepositoryImpl repo=new RepositoryImpl(new File(m_baseDir,"data"),new File(m_baseDir,"tmp"),true);
  repo.get(-1);
}

</code></pre>

<br>
<pre class="type-5 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies that exceptions are thrown during the test case execution">ExceptionVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies that exceptions are thrown during the test case execution
- Executes methods or other tests from the same test unit
"></span><br>
@Test(groups={UNIT},expectedExceptions={IllegalArgumentException.class}) public void testPutVersionZeroFail() throws Exception {
  RepositoryImpl repo=new RepositoryImpl(new File(m_baseDir,"data"),new File(m_baseDir,"tmp"),true);
  repo.put(new ByteArrayInputStream("abc".getBytes()),0);
}

</code></pre>

<br>
<pre class="type-5 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies that exceptions are thrown during the test case execution">ExceptionVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies that exceptions are thrown during the test case execution
- Executes methods or other tests from the same test unit
"></span><br>
@Test(groups={UNIT},expectedExceptions={IllegalArgumentException.class}) public void testPutNegativeVersionFail() throws Exception {
  RepositoryImpl repo=new RepositoryImpl(new File(m_baseDir,"data"),new File(m_baseDir,"tmp"),true);
  repo.put(new ByteArrayInputStream("abc".getBytes()),-1);
}

</code></pre>

<br>
<pre class="type-5 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies that exceptions are thrown during the test case execution">ExceptionVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies that exceptions are thrown during the test case execution
- Executes methods or other tests from the same test unit
"></span><br>
@Test(groups={UNIT},expectedExceptions={IOException.class}) public void testCommitIncorrectVersionFail() throws Exception {
  RepositoryImpl repo=new RepositoryImpl(new File(m_baseDir,"data"),new File(m_baseDir,"tmp"),true);
  InputStream data=new ByteArrayInputStream("abc".getBytes());
  repo.commit(data,1);
}

</code></pre>

<br>
<pre class="type-5 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies that exceptions are thrown during the test case execution">ExceptionVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies that exceptions are thrown during the test case execution
- Executes methods or other tests from the same test unit
"></span><br>
@Test(groups={UNIT},expectedExceptions={IllegalArgumentException.class}) public void testCheckoutNegativeVersionFail() throws Exception {
  RepositoryImpl repo=new RepositoryImpl(new File(m_baseDir,"data"),new File(m_baseDir,"tmp"),true);
  repo.checkout(-1);
}

</code></pre>

<br>
<pre class="type-5 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies that exceptions are thrown during the test case execution">ExceptionVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies that exceptions are thrown during the test case execution
- Executes methods or other tests from the same test unit
"></span><br>
@Test(groups={UNIT},expectedExceptions={IOException.class}) public void testCommitExistingVersionFail() throws Exception {
  RepositoryImpl repo=new RepositoryImpl(new File(m_baseDir,"data"),new File(m_baseDir,"tmp"),true);
  InputStream data=new ByteArrayInputStream("abc".getBytes());
  repo.commit(data,0);
  data=new ByteArrayInputStream("def".getBytes());
  repo.commit(data,0);
}

</code></pre>

<br>
<pre class="type-5 type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies that exceptions are thrown during the test case execution">ExceptionVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies that exceptions are thrown during the test case execution
- Executes methods or other tests from the same test unit
"></span><br>
@Test(groups={UNIT},expectedExceptions={IllegalArgumentException.class}) public void testCommitNegativeVersionFail() throws Exception {
  RepositoryImpl repo=new RepositoryImpl(new File(m_baseDir,"data"),new File(m_baseDir,"tmp"),true);
  repo.commit(new ByteArrayInputStream("abc".getBytes()),-1);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.ace.scheduler.ExecuterTest </h4><pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test(groups={UNIT}) public void testStop() throws Exception {
  m_sem=new Semaphore(2);
  Executer executer=new Executer(new Runnable(){
    public void run(){
      try {
        m_sem.tryAcquire(1,TimeUnit.SECONDS);
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
    }
  }
);
  executer.start(10);
  executer.stop();
  Thread.sleep(100);
  assert m_sem.tryAcquire(1,TimeUnit.SECONDS);
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test(groups={UNIT}) public void testTooLongTask() throws Exception {
  final CountDownLatch latch=new CountDownLatch(5);
  Executer executer=new Executer(new Runnable(){
    public void run(){
      try {
        Thread.sleep(20);
        latch.countDown();
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
    }
  }
);
  executer.start(10);
  assert latch.await(1,TimeUnit.SECONDS);
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test(groups={UNIT}) public void testExecute() throws Exception {
  m_sem=new Semaphore(1);
  Executer executer=new Executer(new Runnable(){
    public void run(){
      m_sem.release();
    }
  }
);
  executer.start(100);
  m_sem.acquire();
  assert m_sem.tryAcquire(2,TimeUnit.SECONDS);
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.ace.scheduler.SchedulerTest </h4><pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test(groups={UNIT}) public synchronized void testProcessTask() throws Exception {
  Dictionary<String,Object> props=new Hashtable<>();
  props.put("local.mock.task1",1000);
  m_scheduler.updated(props);
  m_scheduler.addRunnable("local.mock.task1",new Runnable(){
    public void run(){
    }
  }
,"Dummy testing task",null,false);
  assert ((SchedulerTask)m_scheduler.m_tasks.get("local.mock.task1")).isScheduled() : "An executer should exist after adding a matching task and scheduling-recipe";
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test(groups={UNIT}) public synchronized void testRemoveTask() throws Exception {
  m_scheduler.addRunnable("local.mock.task1",new Runnable(){
    public void run(){
    }
  }
,"Dummy testing task",null,false);
  m_scheduler.removeRunnable("nonExistent");
  assert m_scheduler.m_tasks.size() == 1 : "Number of tasks known to the scheduler should still be one after removing a non-existing task";
  m_scheduler.removeRunnable("local.mock.task1");
  assert m_scheduler.m_tasks.isEmpty() : "Number of tasks known to the scheduler should be zero after removing the task we just added";
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test(groups={UNIT}) public synchronized void testSchedulePrevailanceAndRemoval() throws Exception {
  Dictionary<String,Object> props=new Hashtable<>();
  props.put("local.mock.task1",1000l);
  m_scheduler.updated(props);
  assert ((SchedulerTask)m_scheduler.m_tasks.get("local.mock.task1")).getCurrentRecipe().equals(new Long(1000)) : "The schedule for mock task 1 should specify interval 1000, but it specifies " + ((SchedulerTask)m_scheduler.m_tasks.get("local.mock.task1")).getCurrentRecipe();
  assert !((SchedulerTask)m_scheduler.m_tasks.get("local.mock.task1")).isScheduled() : "Since we have not provided a runnable for the scheduler, the tasks should not be scheduled.";
  m_scheduler.addRunnable("local.mock.task1",new Runnable(){
    public void run(){
    }
  }
,"Dummy testing task",2000l,true);
  assert ((SchedulerTask)m_scheduler.m_tasks.get("local.mock.task1")).getCurrentRecipe().equals(new Long(2000)) : "The schedule for mock task 1 should specify interval 2000, but it specifies " + ((SchedulerTask)m_scheduler.m_tasks.get("local.mock.task1")).getCurrentRecipe();
  assert ((SchedulerTask)m_scheduler.m_tasks.get("local.mock.task1")).isScheduled() : "Since we have now provided a runnable for the scheduler, the tasks should be scheduled.";
  m_scheduler.addRunnable("local.mock.task1",new Runnable(){
    public void run(){
    }
  }
,"Dummy testing task",2000l,false);
  assert ((SchedulerTask)m_scheduler.m_tasks.get("local.mock.task1")).getCurrentRecipe().equals(new Long(1000)) : "The schedule for mock task 1 should specify interval 1000, but it specifies " + ((SchedulerTask)m_scheduler.m_tasks.get("local.mock.task1")).getCurrentRecipe();
  assert ((SchedulerTask)m_scheduler.m_tasks.get("local.mock.task1")).isScheduled() : "Since we have now provided a runnable for the scheduler, the tasks should be scheduled.";
  props=new Hashtable<>();
  m_scheduler.updated(props);
  assert ((SchedulerTask)m_scheduler.m_tasks.get("local.mock.task1")).getCurrentRecipe().equals(new Long(2000)) : "The schedule for mock task 1 should specify interval 2000, but it specifies " + ((SchedulerTask)m_scheduler.m_tasks.get("local.mock.task1")).getCurrentRecipe();
  assert ((SchedulerTask)m_scheduler.m_tasks.get("local.mock.task1")).isScheduled() : "Since we have now provided a runnable for the scheduler, the tasks should be scheduled.";
  m_scheduler.removeRunnable("local.mock.task1");
  assert m_scheduler.m_tasks.size() == 0 : "We have now removed all information about mock task 1, so it should be gone now.";
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test(groups={UNIT}) public synchronized void testAdditionalProperties() throws Exception {
  Dictionary<String,Object> props=new Hashtable<>();
  props.put("local.mock.task1","invalidValue");
  m_scheduler.updated(props);
  m_scheduler.addRunnable("local.mock.task1",new Runnable(){
    public void run(){
    }
  }
,"Dummy testing task",null,false);
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test(groups={UNIT}) public synchronized void testAddTask() throws Exception {
  assert m_scheduler.m_tasks.isEmpty();
  m_scheduler.addRunnable("local.mock.task1",new Runnable(){
    public void run(){
    }
  }
,"Dummy testing task",null,false);
  assert m_scheduler.m_tasks.size() == 1 : "Exactly one task should be known to the scheduler";
  SchedulerTask task=(SchedulerTask)m_scheduler.m_tasks.get("local.mock.task1");
  assert "local.mock.task1".equals(task.getName()) : "Task that was just added has a different name than expected";
}

</code></pre>

<br>
<pre class="type-4 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test(groups={UNIT}) public synchronized void testUpdate() throws Exception {
  Dictionary<String,Object> props=new Hashtable<>();
  props.put("local.mock.task1",1000l);
  props.put("local.mock.task2",2000l);
  props.put("local.mock.task3",3000l);
  m_scheduler.updated(props);
  assert m_scheduler.m_tasks.size() == props.size() : "Exactly three schedules should be known to the scheduler";
  assert ((SchedulerTask)m_scheduler.m_tasks.get("local.mock.task1")).getCurrentRecipe().equals(new Long(1000)) : "The schedule for mock task 1 should specify interval 1000, but it specifies " + ((SchedulerTask)m_scheduler.m_tasks.get("local.mock.task1")).getCurrentRecipe();
  props.put("local.mock.task1",4000l);
  m_scheduler.updated(props);
  assert ((SchedulerTask)m_scheduler.m_tasks.get("local.mock.task1")).getCurrentRecipe().equals(new Long(4000)) : "The schedule for mock task 1 should specify interval 4000, but it specifies " + ((SchedulerTask)m_scheduler.m_tasks.get("local.mock.task1")).getCurrentRecipe();
  assert !((SchedulerTask)m_scheduler.m_tasks.get("local.mock.task1")).isScheduled() : "Since we have not provided a runnable for the scheduler, the tasks should not be scheduled.";
}

</code></pre>

<br>
<script>$(document).ready(function() {
  $('pre code').each(function(i, block) {
    hljs.highlightBlock(block);
  });
});</script>
