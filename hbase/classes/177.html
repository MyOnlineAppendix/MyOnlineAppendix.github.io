<h3 style="margin:0px">Class: org.apache.hadoop.hbase.filter.TestFilter (23 methods) </h3><br><pre style="padding:0"><code class="html"><div id="tags"><button id="1"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('1')" data-toggle="tooltip" title="Executes methods or other tests from the same test unit"><kbd id="tag-1"class="label-info"style="display: inline-block;font-size:7pt" >ExecutionTester&nbsp;(15)</kbd></button>&nbsp;<button id="8"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('8')" data-toggle="tooltip" title="Verifies boolean conditions"><kbd id="tag-8"class="label-info"style="display: inline-block;font-size:7pt" >BooleanVerifier&nbsp;(6)</kbd></button>&nbsp;<button id="9"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('9')" data-toggle="tooltip" title="Verifies assertions in iterations"><kbd id="tag-9"class="label-info"style="display: inline-block;font-size:7pt" >IterativeVerifier&nbsp;(4)</kbd></button>&nbsp;<button id="6"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('6')" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes"><kbd id="tag-6"class="label-info"style="display: inline-block;font-size:7pt" >HybridVerifier&nbsp;(2)</kbd></button>&nbsp;<button id="10"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('10')" data-toggle="tooltip" title="Verifies assertions inside branch conditions"><kbd id="tag-10"class="label-info"style="display: inline-block;font-size:7pt" >BranchVerifier&nbsp;(2)</kbd></button>&nbsp;<button id="4"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('4')" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) "><kbd id="tag-4"class="label-info"style="display: inline-block;font-size:7pt" >APIUtilityVerifier&nbsp;(2)</kbd></button>&nbsp;<button id="5"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('5')" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value "><kbd id="tag-5"class="label-info"style="display: inline-block;font-size:7pt" >EqualityVerifier&nbsp;(2)</kbd></button>&nbsp;<button id="2"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('2')" data-toggle="tooltip" title="Allocates resources before the execution of the test cases"><kbd id="tag-2"class="label-info"style="display: inline-block;font-size:7pt" >TestInitializer&nbsp;(1)</kbd></button>&nbsp;<button id="3"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('3')" data-toggle="tooltip" title="Releases resources used by the test cases"><kbd id="tag-3"class="label-info"style="display: inline-block;font-size:7pt" >TestCleaner&nbsp;(1)</kbd></button>&nbsp;</div></code></pre><center><button onclick="showBlocks()" style="margin:6px">Update filter <span class="glyphicon glyphicon-refresh" aria-hidden="true"></span> </button></center><br>
<pre class="type-1 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test public void testPageFilter() throws Exception {
  KeyValue[] expectedKVs={new KeyValue(ROWS_ONE[0],FAMILIES[0],QUALIFIERS_ONE[0],VALUES[0]),new KeyValue(ROWS_ONE[0],FAMILIES[0],QUALIFIERS_ONE[2],VALUES[0]),new KeyValue(ROWS_ONE[0],FAMILIES[0],QUALIFIERS_ONE[3],VALUES[0]),new KeyValue(ROWS_ONE[0],FAMILIES[1],QUALIFIERS_ONE[0],VALUES[0]),new KeyValue(ROWS_ONE[0],FAMILIES[1],QUALIFIERS_ONE[2],VALUES[0]),new KeyValue(ROWS_ONE[0],FAMILIES[1],QUALIFIERS_ONE[3],VALUES[0]),new KeyValue(ROWS_ONE[2],FAMILIES[0],QUALIFIERS_ONE[0],VALUES[0]),new KeyValue(ROWS_ONE[2],FAMILIES[0],QUALIFIERS_ONE[2],VALUES[0]),new KeyValue(ROWS_ONE[2],FAMILIES[0],QUALIFIERS_ONE[3],VALUES[0]),new KeyValue(ROWS_ONE[2],FAMILIES[1],QUALIFIERS_ONE[0],VALUES[0]),new KeyValue(ROWS_ONE[2],FAMILIES[1],QUALIFIERS_ONE[2],VALUES[0]),new KeyValue(ROWS_ONE[2],FAMILIES[1],QUALIFIERS_ONE[3],VALUES[0]),new KeyValue(ROWS_ONE[3],FAMILIES[0],QUALIFIERS_ONE[0],VALUES[0]),new KeyValue(ROWS_ONE[3],FAMILIES[0],QUALIFIERS_ONE[2],VALUES[0]),new KeyValue(ROWS_ONE[3],FAMILIES[0],QUALIFIERS_ONE[3],VALUES[0]),new KeyValue(ROWS_ONE[3],FAMILIES[1],QUALIFIERS_ONE[0],VALUES[0]),new KeyValue(ROWS_ONE[3],FAMILIES[1],QUALIFIERS_ONE[2],VALUES[0]),new KeyValue(ROWS_ONE[3],FAMILIES[1],QUALIFIERS_ONE[3],VALUES[0]),new KeyValue(ROWS_TWO[0],FAMILIES[0],QUALIFIERS_TWO[0],VALUES[1]),new KeyValue(ROWS_TWO[0],FAMILIES[0],QUALIFIERS_TWO[2],VALUES[1]),new KeyValue(ROWS_TWO[0],FAMILIES[0],QUALIFIERS_TWO[3],VALUES[1]),new KeyValue(ROWS_TWO[0],FAMILIES[1],QUALIFIERS_TWO[0],VALUES[1]),new KeyValue(ROWS_TWO[0],FAMILIES[1],QUALIFIERS_TWO[2],VALUES[1]),new KeyValue(ROWS_TWO[0],FAMILIES[1],QUALIFIERS_TWO[3],VALUES[1]),new KeyValue(ROWS_TWO[2],FAMILIES[0],QUALIFIERS_TWO[0],VALUES[1]),new KeyValue(ROWS_TWO[2],FAMILIES[0],QUALIFIERS_TWO[2],VALUES[1]),new KeyValue(ROWS_TWO[2],FAMILIES[0],QUALIFIERS_TWO[3],VALUES[1]),new KeyValue(ROWS_TWO[2],FAMILIES[1],QUALIFIERS_TWO[0],VALUES[1]),new KeyValue(ROWS_TWO[2],FAMILIES[1],QUALIFIERS_TWO[2],VALUES[1]),new KeyValue(ROWS_TWO[2],FAMILIES[1],QUALIFIERS_TWO[3],VALUES[1]),new KeyValue(ROWS_TWO[3],FAMILIES[0],QUALIFIERS_TWO[0],VALUES[1]),new KeyValue(ROWS_TWO[3],FAMILIES[0],QUALIFIERS_TWO[2],VALUES[1]),new KeyValue(ROWS_TWO[3],FAMILIES[0],QUALIFIERS_TWO[3],VALUES[1]),new KeyValue(ROWS_TWO[3],FAMILIES[1],QUALIFIERS_TWO[0],VALUES[1]),new KeyValue(ROWS_TWO[3],FAMILIES[1],QUALIFIERS_TWO[2],VALUES[1]),new KeyValue(ROWS_TWO[3],FAMILIES[1],QUALIFIERS_TWO[3],VALUES[1])};
  long expectedRows=6;
  long expectedKeys=this.colsPerRow;
  Scan s=new Scan();
  s.setFilter(new PageFilter(expectedRows));
  verifyScan(s,expectedRows,expectedKeys);
  s.setFilter(new PageFilter(expectedRows));
  verifyScanFull(s,expectedKVs);
  expectedRows=4;
  expectedKeys=this.colsPerRow;
  s=new Scan();
  s.setFilter(new PageFilter(expectedRows));
  verifyScan(s,expectedRows,expectedKeys);
  s.setFilter(new PageFilter(expectedRows));
  verifyScanFull(s,Arrays.copyOf(expectedKVs,24));
  expectedRows=2;
  expectedKeys=this.colsPerRow;
  s=new Scan();
  s.setFilter(new PageFilter(expectedRows));
  verifyScan(s,expectedRows,expectedKeys);
  s.setFilter(new PageFilter(expectedRows));
  verifyScanFull(s,Arrays.copyOf(expectedKVs,12));
  expectedRows=1;
  expectedKeys=this.colsPerRow;
  s=new Scan();
  s.setFilter(new PageFilter(expectedRows));
  verifyScan(s,expectedRows,expectedKeys);
  s.setFilter(new PageFilter(expectedRows));
  verifyScanFull(s,Arrays.copyOf(expectedKVs,6));
}

</code></pre>

<pre class="type-2 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Allocates resources before the execution of the test cases">TestInitializer</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Allocates resources before the execution of the test cases
"></span><br>
@Before public void setUp() throws Exception {
  HTableDescriptor htd=new HTableDescriptor(TableName.valueOf("TestFilter"));
  htd.addFamily(new HColumnDescriptor(FAMILIES[0]));
  htd.addFamily(new HColumnDescriptor(FAMILIES[1]));
  htd.addFamily(new HColumnDescriptor(FAMILIES_1[0]));
  htd.addFamily(new HColumnDescriptor(FAMILIES_1[1]));
  htd.addFamily(new HColumnDescriptor(NEW_FAMILIES[0]));
  htd.addFamily(new HColumnDescriptor(NEW_FAMILIES[1]));
  HRegionInfo info=new HRegionInfo(htd.getTableName(),null,null,false);
  this.region=HBaseTestingUtility.createRegionAndWAL(info,TEST_UTIL.getDataTestDir(),TEST_UTIL.getConfiguration(),htd);
  for (  byte[] ROW : ROWS_ONE) {
    Put p=new Put(ROW);
    p.setDurability(Durability.SKIP_WAL);
    for (    byte[] QUALIFIER : QUALIFIERS_ONE) {
      p.addColumn(FAMILIES[0],QUALIFIER,VALUES[0]);
    }
    this.region.put(p);
  }
  for (  byte[] ROW : ROWS_TWO) {
    Put p=new Put(ROW);
    p.setDurability(Durability.SKIP_WAL);
    for (    byte[] QUALIFIER : QUALIFIERS_TWO) {
      p.addColumn(FAMILIES[1],QUALIFIER,VALUES[1]);
    }
    this.region.put(p);
  }
  this.region.flush(true);
  for (  byte[] ROW : ROWS_ONE) {
    Put p=new Put(ROW);
    p.setDurability(Durability.SKIP_WAL);
    for (    byte[] QUALIFIER : QUALIFIERS_ONE) {
      p.addColumn(FAMILIES[1],QUALIFIER,VALUES[0]);
    }
    this.region.put(p);
  }
  for (  byte[] ROW : ROWS_TWO) {
    Put p=new Put(ROW);
    p.setDurability(Durability.SKIP_WAL);
    for (    byte[] QUALIFIER : QUALIFIERS_TWO) {
      p.addColumn(FAMILIES[0],QUALIFIER,VALUES[1]);
    }
    this.region.put(p);
  }
  for (  byte[] ROW : ROWS_ONE) {
    Delete d=new Delete(ROW);
    d.addColumns(FAMILIES[0],QUALIFIERS_ONE[1]);
    d.addColumns(FAMILIES[1],QUALIFIERS_ONE[1]);
    this.region.delete(d);
  }
  for (  byte[] ROW : ROWS_TWO) {
    Delete d=new Delete(ROW);
    d.addColumns(FAMILIES[0],QUALIFIERS_TWO[1]);
    d.addColumns(FAMILIES[1],QUALIFIERS_TWO[1]);
    this.region.delete(d);
  }
  colsPerRow-=2;
  for (  byte[] QUALIFIER : QUALIFIERS_ONE) {
    Delete d=new Delete(ROWS_ONE[1]);
    d.addColumns(FAMILIES[0],QUALIFIER);
    d.addColumns(FAMILIES[1],QUALIFIER);
    this.region.delete(d);
  }
  for (  byte[] QUALIFIER : QUALIFIERS_TWO) {
    Delete d=new Delete(ROWS_TWO[1]);
    d.addColumns(FAMILIES[0],QUALIFIER);
    d.addColumns(FAMILIES[1],QUALIFIER);
    this.region.delete(d);
  }
  numRows-=2;
}

</code></pre>

<pre class="type-1 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test public void testNoFilter() throws Exception {
  long expectedRows=this.numRows;
  long expectedKeys=this.colsPerRow;
  Scan s=new Scan();
  verifyScan(s,expectedRows,expectedKeys);
  s=new Scan();
  s.addFamily(FAMILIES[0]);
  verifyScan(s,expectedRows,expectedKeys / 2);
}

</code></pre>

<pre class="type-1 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test public void testValueFilter() throws IOException {
  long expectedRows=this.numRows / 2;
  long expectedKeys=this.colsPerRow;
  Filter f=new ValueFilter(CompareOp.EQUAL,new BinaryComparator(Bytes.toBytes("testValueOne")));
  Scan s=new Scan();
  s.setFilter(f);
  verifyScanNoEarlyOut(s,expectedRows,expectedKeys);
  expectedRows=this.numRows / 2;
  expectedKeys=this.colsPerRow;
  f=new ValueFilter(CompareOp.EQUAL,new BinaryComparator(Bytes.toBytes("testValueTwo")));
  s=new Scan();
  s.setFilter(f);
  verifyScanNoEarlyOut(s,expectedRows,expectedKeys);
  expectedRows=this.numRows;
  expectedKeys=this.colsPerRow;
  f=new ValueFilter(CompareOp.EQUAL,new RegexStringComparator("testValue((One)|(Two))"));
  s=new Scan();
  s.setFilter(f);
  verifyScanNoEarlyOut(s,expectedRows,expectedKeys);
  expectedRows=this.numRows / 2;
  expectedKeys=this.colsPerRow;
  f=new ValueFilter(CompareOp.LESS,new BinaryComparator(Bytes.toBytes("testValueTwo")));
  s=new Scan();
  s.setFilter(f);
  verifyScanNoEarlyOut(s,expectedRows,expectedKeys);
  expectedRows=this.numRows;
  expectedKeys=this.colsPerRow;
  f=new ValueFilter(CompareOp.LESS_OR_EQUAL,new BinaryComparator(Bytes.toBytes("testValueTwo")));
  s=new Scan();
  s.setFilter(f);
  verifyScanNoEarlyOut(s,expectedRows,expectedKeys);
  expectedRows=this.numRows / 2;
  expectedKeys=this.colsPerRow;
  f=new ValueFilter(CompareOp.LESS_OR_EQUAL,new BinaryComparator(Bytes.toBytes("testValueOne")));
  s=new Scan();
  s.setFilter(f);
  verifyScanNoEarlyOut(s,expectedRows,expectedKeys);
  expectedRows=this.numRows / 2;
  expectedKeys=this.colsPerRow;
  f=new ValueFilter(CompareOp.NOT_EQUAL,new BinaryComparator(Bytes.toBytes("testValueOne")));
  s=new Scan();
  s.setFilter(f);
  verifyScanNoEarlyOut(s,expectedRows,expectedKeys);
  expectedRows=this.numRows;
  expectedKeys=this.colsPerRow;
  f=new ValueFilter(CompareOp.GREATER_OR_EQUAL,new BinaryComparator(Bytes.toBytes("testValueOne")));
  s=new Scan();
  s.setFilter(f);
  verifyScanNoEarlyOut(s,expectedRows,expectedKeys);
  expectedRows=this.numRows / 2;
  expectedKeys=this.colsPerRow;
  f=new ValueFilter(CompareOp.GREATER,new BinaryComparator(Bytes.toBytes("testValueOne")));
  s=new Scan();
  s.setFilter(f);
  verifyScanNoEarlyOut(s,expectedRows,expectedKeys);
  f=new ValueFilter(CompareOp.NOT_EQUAL,new BinaryComparator(Bytes.toBytes("testValueOne")));
  s=new Scan();
  s.setFilter(f);
  KeyValue[] kvs={new KeyValue(ROWS_TWO[0],FAMILIES[0],QUALIFIERS_TWO[0],VALUES[1]),new KeyValue(ROWS_TWO[0],FAMILIES[0],QUALIFIERS_TWO[2],VALUES[1]),new KeyValue(ROWS_TWO[0],FAMILIES[0],QUALIFIERS_TWO[3],VALUES[1]),new KeyValue(ROWS_TWO[0],FAMILIES[1],QUALIFIERS_TWO[0],VALUES[1]),new KeyValue(ROWS_TWO[0],FAMILIES[1],QUALIFIERS_TWO[2],VALUES[1]),new KeyValue(ROWS_TWO[0],FAMILIES[1],QUALIFIERS_TWO[3],VALUES[1]),new KeyValue(ROWS_TWO[2],FAMILIES[0],QUALIFIERS_TWO[0],VALUES[1]),new KeyValue(ROWS_TWO[2],FAMILIES[0],QUALIFIERS_TWO[2],VALUES[1]),new KeyValue(ROWS_TWO[2],FAMILIES[0],QUALIFIERS_TWO[3],VALUES[1]),new KeyValue(ROWS_TWO[2],FAMILIES[1],QUALIFIERS_TWO[0],VALUES[1]),new KeyValue(ROWS_TWO[2],FAMILIES[1],QUALIFIERS_TWO[2],VALUES[1]),new KeyValue(ROWS_TWO[2],FAMILIES[1],QUALIFIERS_TWO[3],VALUES[1]),new KeyValue(ROWS_TWO[3],FAMILIES[0],QUALIFIERS_TWO[0],VALUES[1]),new KeyValue(ROWS_TWO[3],FAMILIES[0],QUALIFIERS_TWO[2],VALUES[1]),new KeyValue(ROWS_TWO[3],FAMILIES[0],QUALIFIERS_TWO[3],VALUES[1]),new KeyValue(ROWS_TWO[3],FAMILIES[1],QUALIFIERS_TWO[0],VALUES[1]),new KeyValue(ROWS_TWO[3],FAMILIES[1],QUALIFIERS_TWO[2],VALUES[1]),new KeyValue(ROWS_TWO[3],FAMILIES[1],QUALIFIERS_TWO[3],VALUES[1])};
  verifyScanFull(s,kvs);
}

</code></pre>

<pre class="type-1 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test public void testFilterList() throws IOException {
  List<Filter> filters=new ArrayList<Filter>();
  filters.add(new RowFilter(CompareOp.EQUAL,new RegexStringComparator(".+-2")));
  filters.add(new QualifierFilter(CompareOp.EQUAL,new RegexStringComparator(".+-2")));
  filters.add(new ValueFilter(CompareOp.EQUAL,new SubstringComparator("One")));
  Filter f=new FilterList(Operator.MUST_PASS_ALL,filters);
  Scan s=new Scan();
  s.addFamily(FAMILIES[0]);
  s.setFilter(f);
  KeyValue[] kvs={new KeyValue(ROWS_ONE[2],FAMILIES[0],QUALIFIERS_ONE[2],VALUES[0])};
  verifyScanFull(s,kvs);
  filters.clear();
  filters.add(new RowFilter(CompareOp.EQUAL,new RegexStringComparator(".+Two.+")));
  filters.add(new QualifierFilter(CompareOp.EQUAL,new RegexStringComparator(".+-2")));
  filters.add(new ValueFilter(CompareOp.EQUAL,new SubstringComparator("One")));
  f=new FilterList(Operator.MUST_PASS_ONE,filters);
  s=new Scan();
  s.setFilter(f);
  verifyScanNoEarlyOut(s,this.numRows,this.colsPerRow);
}

</code></pre>

<pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies boolean conditions
"></span><br>
@Test public void testRegionScannerReseek() throws Exception {
  for (  byte[] ROW : ROWS_THREE) {
    Put p=new Put(ROW);
    p.setDurability(Durability.SKIP_WAL);
    for (    byte[] QUALIFIER : QUALIFIERS_THREE) {
      p.addColumn(FAMILIES[0],QUALIFIER,VALUES[0]);
    }
    this.region.put(p);
  }
  for (  byte[] ROW : ROWS_FOUR) {
    Put p=new Put(ROW);
    p.setDurability(Durability.SKIP_WAL);
    for (    byte[] QUALIFIER : QUALIFIERS_FOUR) {
      p.addColumn(FAMILIES[1],QUALIFIER,VALUES[1]);
    }
    this.region.put(p);
  }
  this.region.flush(true);
  for (  byte[] ROW : ROWS_THREE) {
    Put p=new Put(ROW);
    p.setDurability(Durability.SKIP_WAL);
    for (    byte[] QUALIFIER : QUALIFIERS_THREE) {
      p.addColumn(FAMILIES[1],QUALIFIER,VALUES[0]);
    }
    this.region.put(p);
  }
  for (  byte[] ROW : ROWS_FOUR) {
    Put p=new Put(ROW);
    p.setDurability(Durability.SKIP_WAL);
    for (    byte[] QUALIFIER : QUALIFIERS_FOUR) {
      p.addColumn(FAMILIES[0],QUALIFIER,VALUES[1]);
    }
    this.region.put(p);
  }
  Scan s=new Scan();
  s.setStartRow(ROWS_FOUR[1]);
  RegionScanner scanner=region.getScanner(s);
  scanner.reseek(ROWS_THREE[1]);
  List<Cell> results=new ArrayList<Cell>();
  scanner.next(results);
  for (  Cell keyValue : results) {
    assertTrue("The rows with ROWS_TWO as row key should be appearing.",CellUtil.matchingRow(keyValue,ROWS_THREE[1]));
  }
  scanner.reseek(ROWS_ONE[1]);
  results=new ArrayList<Cell>();
  scanner.next(results);
  for (  Cell keyValue : results) {
    assertFalse("Cannot rewind back to a value less than previous reseek.",Bytes.toString(CellUtil.cloneRow(keyValue)).contains("testRowOne"));
  }
}

</code></pre>

<pre class="type-1 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test public void testFirstKeyOnlyFilter() throws IOException {
  Scan s=new Scan();
  s.setFilter(new FirstKeyOnlyFilter());
  KeyValue[] kvs={new KeyValue(ROWS_ONE[0],FAMILIES[0],QUALIFIERS_ONE[0],VALUES[0]),new KeyValue(ROWS_ONE[2],FAMILIES[0],QUALIFIERS_ONE[0],VALUES[0]),new KeyValue(ROWS_ONE[3],FAMILIES[0],QUALIFIERS_ONE[0],VALUES[0]),new KeyValue(ROWS_TWO[0],FAMILIES[0],QUALIFIERS_TWO[0],VALUES[1]),new KeyValue(ROWS_TWO[2],FAMILIES[0],QUALIFIERS_TWO[0],VALUES[1]),new KeyValue(ROWS_TWO[3],FAMILIES[0],QUALIFIERS_TWO[0],VALUES[1])};
  verifyScanFull(s,kvs);
}

</code></pre>

<pre class="type-1 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test public void testQualifierFilter() throws IOException {
  long expectedRows=this.numRows / 2;
  long expectedKeys=2;
  Filter f=new QualifierFilter(CompareOp.EQUAL,new BinaryComparator(Bytes.toBytes("testQualifierOne-2")));
  Scan s=new Scan();
  s.setFilter(f);
  verifyScanNoEarlyOut(s,expectedRows,expectedKeys);
  expectedRows=this.numRows / 2;
  expectedKeys=2;
  f=new QualifierFilter(CompareOp.LESS,new BinaryComparator(Bytes.toBytes("testQualifierOne-2")));
  s=new Scan();
  s.setFilter(f);
  verifyScanNoEarlyOut(s,expectedRows,expectedKeys);
  expectedRows=this.numRows / 2;
  expectedKeys=4;
  f=new QualifierFilter(CompareOp.LESS_OR_EQUAL,new BinaryComparator(Bytes.toBytes("testQualifierOne-2")));
  s=new Scan();
  s.setFilter(f);
  verifyScanNoEarlyOut(s,expectedRows,expectedKeys);
  expectedRows=this.numRows / 2;
  expectedKeys=4;
  f=new QualifierFilter(CompareOp.NOT_EQUAL,new BinaryComparator(Bytes.toBytes("testQualifierOne-2")));
  s=new Scan(HConstants.EMPTY_START_ROW,Bytes.toBytes("testRowTwo"));
  s.setFilter(f);
  verifyScanNoEarlyOut(s,expectedRows,expectedKeys);
  expectedRows=this.numRows / 2;
  expectedKeys=4;
  f=new QualifierFilter(CompareOp.GREATER_OR_EQUAL,new BinaryComparator(Bytes.toBytes("testQualifierOne-2")));
  s=new Scan(HConstants.EMPTY_START_ROW,Bytes.toBytes("testRowTwo"));
  s.setFilter(f);
  verifyScanNoEarlyOut(s,expectedRows,expectedKeys);
  expectedRows=this.numRows / 2;
  expectedKeys=2;
  f=new QualifierFilter(CompareOp.GREATER,new BinaryComparator(Bytes.toBytes("testQualifierOne-2")));
  s=new Scan(HConstants.EMPTY_START_ROW,Bytes.toBytes("testRowTwo"));
  s.setFilter(f);
  verifyScanNoEarlyOut(s,expectedRows,expectedKeys);
  f=new QualifierFilter(CompareOp.NOT_EQUAL,new BinaryComparator(QUALIFIERS_ONE[2]));
  s=new Scan();
  s.setFilter(f);
  KeyValue[] kvs={new KeyValue(ROWS_ONE[0],FAMILIES[0],QUALIFIERS_ONE[0],VALUES[0]),new KeyValue(ROWS_ONE[0],FAMILIES[0],QUALIFIERS_ONE[3],VALUES[0]),new KeyValue(ROWS_ONE[0],FAMILIES[1],QUALIFIERS_ONE[0],VALUES[0]),new KeyValue(ROWS_ONE[0],FAMILIES[1],QUALIFIERS_ONE[3],VALUES[0]),new KeyValue(ROWS_ONE[2],FAMILIES[0],QUALIFIERS_ONE[0],VALUES[0]),new KeyValue(ROWS_ONE[2],FAMILIES[0],QUALIFIERS_ONE[3],VALUES[0]),new KeyValue(ROWS_ONE[2],FAMILIES[1],QUALIFIERS_ONE[0],VALUES[0]),new KeyValue(ROWS_ONE[2],FAMILIES[1],QUALIFIERS_ONE[3],VALUES[0]),new KeyValue(ROWS_ONE[3],FAMILIES[0],QUALIFIERS_ONE[0],VALUES[0]),new KeyValue(ROWS_ONE[3],FAMILIES[0],QUALIFIERS_ONE[3],VALUES[0]),new KeyValue(ROWS_ONE[3],FAMILIES[1],QUALIFIERS_ONE[0],VALUES[0]),new KeyValue(ROWS_ONE[3],FAMILIES[1],QUALIFIERS_ONE[3],VALUES[0]),new KeyValue(ROWS_TWO[0],FAMILIES[0],QUALIFIERS_TWO[0],VALUES[1]),new KeyValue(ROWS_TWO[0],FAMILIES[0],QUALIFIERS_TWO[2],VALUES[1]),new KeyValue(ROWS_TWO[0],FAMILIES[0],QUALIFIERS_TWO[3],VALUES[1]),new KeyValue(ROWS_TWO[0],FAMILIES[1],QUALIFIERS_TWO[0],VALUES[1]),new KeyValue(ROWS_TWO[0],FAMILIES[1],QUALIFIERS_TWO[2],VALUES[1]),new KeyValue(ROWS_TWO[0],FAMILIES[1],QUALIFIERS_TWO[3],VALUES[1]),new KeyValue(ROWS_TWO[2],FAMILIES[0],QUALIFIERS_TWO[0],VALUES[1]),new KeyValue(ROWS_TWO[2],FAMILIES[0],QUALIFIERS_TWO[2],VALUES[1]),new KeyValue(ROWS_TWO[2],FAMILIES[0],QUALIFIERS_TWO[3],VALUES[1]),new KeyValue(ROWS_TWO[2],FAMILIES[1],QUALIFIERS_TWO[0],VALUES[1]),new KeyValue(ROWS_TWO[2],FAMILIES[1],QUALIFIERS_TWO[2],VALUES[1]),new KeyValue(ROWS_TWO[2],FAMILIES[1],QUALIFIERS_TWO[3],VALUES[1]),new KeyValue(ROWS_TWO[3],FAMILIES[0],QUALIFIERS_TWO[0],VALUES[1]),new KeyValue(ROWS_TWO[3],FAMILIES[0],QUALIFIERS_TWO[2],VALUES[1]),new KeyValue(ROWS_TWO[3],FAMILIES[0],QUALIFIERS_TWO[3],VALUES[1]),new KeyValue(ROWS_TWO[3],FAMILIES[1],QUALIFIERS_TWO[0],VALUES[1]),new KeyValue(ROWS_TWO[3],FAMILIES[1],QUALIFIERS_TWO[2],VALUES[1]),new KeyValue(ROWS_TWO[3],FAMILIES[1],QUALIFIERS_TWO[3],VALUES[1])};
  verifyScanFull(s,kvs);
  f=new QualifierFilter(CompareOp.NOT_EQUAL,new RegexStringComparator("test.+-2"));
  s=new Scan();
  s.setFilter(f);
  kvs=new KeyValue[]{new KeyValue(ROWS_ONE[0],FAMILIES[0],QUALIFIERS_ONE[0],VALUES[0]),new KeyValue(ROWS_ONE[0],FAMILIES[0],QUALIFIERS_ONE[3],VALUES[0]),new KeyValue(ROWS_ONE[0],FAMILIES[1],QUALIFIERS_ONE[0],VALUES[0]),new KeyValue(ROWS_ONE[0],FAMILIES[1],QUALIFIERS_ONE[3],VALUES[0]),new KeyValue(ROWS_ONE[2],FAMILIES[0],QUALIFIERS_ONE[0],VALUES[0]),new KeyValue(ROWS_ONE[2],FAMILIES[0],QUALIFIERS_ONE[3],VALUES[0]),new KeyValue(ROWS_ONE[2],FAMILIES[1],QUALIFIERS_ONE[0],VALUES[0]),new KeyValue(ROWS_ONE[2],FAMILIES[1],QUALIFIERS_ONE[3],VALUES[0]),new KeyValue(ROWS_ONE[3],FAMILIES[0],QUALIFIERS_ONE[0],VALUES[0]),new KeyValue(ROWS_ONE[3],FAMILIES[0],QUALIFIERS_ONE[3],VALUES[0]),new KeyValue(ROWS_ONE[3],FAMILIES[1],QUALIFIERS_ONE[0],VALUES[0]),new KeyValue(ROWS_ONE[3],FAMILIES[1],QUALIFIERS_ONE[3],VALUES[0]),new KeyValue(ROWS_TWO[0],FAMILIES[0],QUALIFIERS_TWO[0],VALUES[1]),new KeyValue(ROWS_TWO[0],FAMILIES[0],QUALIFIERS_TWO[3],VALUES[1]),new KeyValue(ROWS_TWO[0],FAMILIES[1],QUALIFIERS_TWO[0],VALUES[1]),new KeyValue(ROWS_TWO[0],FAMILIES[1],QUALIFIERS_TWO[3],VALUES[1]),new KeyValue(ROWS_TWO[2],FAMILIES[0],QUALIFIERS_TWO[0],VALUES[1]),new KeyValue(ROWS_TWO[2],FAMILIES[0],QUALIFIERS_TWO[3],VALUES[1]),new KeyValue(ROWS_TWO[2],FAMILIES[1],QUALIFIERS_TWO[0],VALUES[1]),new KeyValue(ROWS_TWO[2],FAMILIES[1],QUALIFIERS_TWO[3],VALUES[1]),new KeyValue(ROWS_TWO[3],FAMILIES[0],QUALIFIERS_TWO[0],VALUES[1]),new KeyValue(ROWS_TWO[3],FAMILIES[0],QUALIFIERS_TWO[3],VALUES[1]),new KeyValue(ROWS_TWO[3],FAMILIES[1],QUALIFIERS_TWO[0],VALUES[1]),new KeyValue(ROWS_TWO[3],FAMILIES[1],QUALIFIERS_TWO[3],VALUES[1])};
  verifyScanFull(s,kvs);
}

</code></pre>

<pre class="type-1 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test public void testRowFilter() throws IOException {
  long expectedRows=1;
  long expectedKeys=this.colsPerRow;
  Filter f=new RowFilter(CompareOp.EQUAL,new BinaryComparator(Bytes.toBytes("testRowOne-2")));
  Scan s=new Scan();
  s.setFilter(f);
  verifyScanNoEarlyOut(s,expectedRows,expectedKeys);
  expectedRows=2;
  expectedKeys=this.colsPerRow;
  f=new RowFilter(CompareOp.EQUAL,new RegexStringComparator("testRow.+-2"));
  s=new Scan();
  s.setFilter(f);
  verifyScanNoEarlyOut(s,expectedRows,expectedKeys);
  expectedRows=1;
  expectedKeys=this.colsPerRow;
  f=new RowFilter(CompareOp.LESS,new BinaryComparator(Bytes.toBytes("testRowOne-2")));
  s=new Scan();
  s.setFilter(f);
  verifyScanNoEarlyOut(s,expectedRows,expectedKeys);
  expectedRows=2;
  expectedKeys=this.colsPerRow;
  f=new RowFilter(CompareOp.LESS_OR_EQUAL,new BinaryComparator(Bytes.toBytes("testRowOne-2")));
  s=new Scan();
  s.setFilter(f);
  verifyScanNoEarlyOut(s,expectedRows,expectedKeys);
  expectedRows=this.numRows - 1;
  expectedKeys=this.colsPerRow;
  f=new RowFilter(CompareOp.NOT_EQUAL,new BinaryComparator(Bytes.toBytes("testRowOne-2")));
  s=new Scan();
  s.setFilter(f);
  verifyScanNoEarlyOut(s,expectedRows,expectedKeys);
  expectedRows=this.numRows - 1;
  expectedKeys=this.colsPerRow;
  f=new RowFilter(CompareOp.GREATER_OR_EQUAL,new BinaryComparator(Bytes.toBytes("testRowOne-2")));
  s=new Scan();
  s.setFilter(f);
  verifyScanNoEarlyOut(s,expectedRows,expectedKeys);
  expectedRows=this.numRows - 2;
  expectedKeys=this.colsPerRow;
  f=new RowFilter(CompareOp.GREATER,new BinaryComparator(Bytes.toBytes("testRowOne-2")));
  s=new Scan();
  s.setFilter(f);
  verifyScanNoEarlyOut(s,expectedRows,expectedKeys);
  f=new RowFilter(CompareOp.NOT_EQUAL,new BinaryComparator(Bytes.toBytes("testRowOne-2")));
  s=new Scan();
  s.setFilter(f);
  KeyValue[] kvs={new KeyValue(ROWS_ONE[0],FAMILIES[0],QUALIFIERS_ONE[0],VALUES[0]),new KeyValue(ROWS_ONE[0],FAMILIES[0],QUALIFIERS_ONE[2],VALUES[0]),new KeyValue(ROWS_ONE[0],FAMILIES[0],QUALIFIERS_ONE[3],VALUES[0]),new KeyValue(ROWS_ONE[0],FAMILIES[1],QUALIFIERS_ONE[0],VALUES[0]),new KeyValue(ROWS_ONE[0],FAMILIES[1],QUALIFIERS_ONE[2],VALUES[0]),new KeyValue(ROWS_ONE[0],FAMILIES[1],QUALIFIERS_ONE[3],VALUES[0]),new KeyValue(ROWS_ONE[3],FAMILIES[0],QUALIFIERS_ONE[0],VALUES[0]),new KeyValue(ROWS_ONE[3],FAMILIES[0],QUALIFIERS_ONE[2],VALUES[0]),new KeyValue(ROWS_ONE[3],FAMILIES[0],QUALIFIERS_ONE[3],VALUES[0]),new KeyValue(ROWS_ONE[3],FAMILIES[1],QUALIFIERS_ONE[0],VALUES[0]),new KeyValue(ROWS_ONE[3],FAMILIES[1],QUALIFIERS_ONE[2],VALUES[0]),new KeyValue(ROWS_ONE[3],FAMILIES[1],QUALIFIERS_ONE[3],VALUES[0]),new KeyValue(ROWS_TWO[0],FAMILIES[0],QUALIFIERS_TWO[0],VALUES[1]),new KeyValue(ROWS_TWO[0],FAMILIES[0],QUALIFIERS_TWO[2],VALUES[1]),new KeyValue(ROWS_TWO[0],FAMILIES[0],QUALIFIERS_TWO[3],VALUES[1]),new KeyValue(ROWS_TWO[0],FAMILIES[1],QUALIFIERS_TWO[0],VALUES[1]),new KeyValue(ROWS_TWO[0],FAMILIES[1],QUALIFIERS_TWO[2],VALUES[1]),new KeyValue(ROWS_TWO[0],FAMILIES[1],QUALIFIERS_TWO[3],VALUES[1]),new KeyValue(ROWS_TWO[2],FAMILIES[0],QUALIFIERS_TWO[0],VALUES[1]),new KeyValue(ROWS_TWO[2],FAMILIES[0],QUALIFIERS_TWO[2],VALUES[1]),new KeyValue(ROWS_TWO[2],FAMILIES[0],QUALIFIERS_TWO[3],VALUES[1]),new KeyValue(ROWS_TWO[2],FAMILIES[1],QUALIFIERS_TWO[0],VALUES[1]),new KeyValue(ROWS_TWO[2],FAMILIES[1],QUALIFIERS_TWO[2],VALUES[1]),new KeyValue(ROWS_TWO[2],FAMILIES[1],QUALIFIERS_TWO[3],VALUES[1]),new KeyValue(ROWS_TWO[3],FAMILIES[0],QUALIFIERS_TWO[0],VALUES[1]),new KeyValue(ROWS_TWO[3],FAMILIES[0],QUALIFIERS_TWO[2],VALUES[1]),new KeyValue(ROWS_TWO[3],FAMILIES[0],QUALIFIERS_TWO[3],VALUES[1]),new KeyValue(ROWS_TWO[3],FAMILIES[1],QUALIFIERS_TWO[0],VALUES[1]),new KeyValue(ROWS_TWO[3],FAMILIES[1],QUALIFIERS_TWO[2],VALUES[1]),new KeyValue(ROWS_TWO[3],FAMILIES[1],QUALIFIERS_TWO[3],VALUES[1])};
  verifyScanFull(s,kvs);
  f=new RowFilter(CompareOp.EQUAL,new RegexStringComparator(".+-2"));
  s=new Scan();
  s.setFilter(f);
  kvs=new KeyValue[]{new KeyValue(ROWS_ONE[2],FAMILIES[0],QUALIFIERS_ONE[0],VALUES[0]),new KeyValue(ROWS_ONE[2],FAMILIES[0],QUALIFIERS_ONE[2],VALUES[0]),new KeyValue(ROWS_ONE[2],FAMILIES[0],QUALIFIERS_ONE[3],VALUES[0]),new KeyValue(ROWS_ONE[2],FAMILIES[1],QUALIFIERS_ONE[0],VALUES[0]),new KeyValue(ROWS_ONE[2],FAMILIES[1],QUALIFIERS_ONE[2],VALUES[0]),new KeyValue(ROWS_ONE[2],FAMILIES[1],QUALIFIERS_ONE[3],VALUES[0]),new KeyValue(ROWS_TWO[2],FAMILIES[0],QUALIFIERS_TWO[0],VALUES[1]),new KeyValue(ROWS_TWO[2],FAMILIES[0],QUALIFIERS_TWO[2],VALUES[1]),new KeyValue(ROWS_TWO[2],FAMILIES[0],QUALIFIERS_TWO[3],VALUES[1]),new KeyValue(ROWS_TWO[2],FAMILIES[1],QUALIFIERS_TWO[0],VALUES[1]),new KeyValue(ROWS_TWO[2],FAMILIES[1],QUALIFIERS_TWO[2],VALUES[1]),new KeyValue(ROWS_TWO[2],FAMILIES[1],QUALIFIERS_TWO[3],VALUES[1])};
  verifyScanFull(s,kvs);
}

</code></pre>

<pre class="type-1 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test public void testKeyOnlyFilter() throws Exception {
  KeyValue[] expectedKVs={new KeyValue(ROWS_ONE[0],FAMILIES[0],QUALIFIERS_ONE[0],VALUES[0]),new KeyValue(ROWS_ONE[0],FAMILIES[0],QUALIFIERS_ONE[2],VALUES[0]),new KeyValue(ROWS_ONE[0],FAMILIES[0],QUALIFIERS_ONE[3],VALUES[0]),new KeyValue(ROWS_ONE[0],FAMILIES[1],QUALIFIERS_ONE[0],VALUES[0]),new KeyValue(ROWS_ONE[0],FAMILIES[1],QUALIFIERS_ONE[2],VALUES[0]),new KeyValue(ROWS_ONE[0],FAMILIES[1],QUALIFIERS_ONE[3],VALUES[0]),new KeyValue(ROWS_ONE[2],FAMILIES[0],QUALIFIERS_ONE[0],VALUES[0]),new KeyValue(ROWS_ONE[2],FAMILIES[0],QUALIFIERS_ONE[2],VALUES[0]),new KeyValue(ROWS_ONE[2],FAMILIES[0],QUALIFIERS_ONE[3],VALUES[0]),new KeyValue(ROWS_ONE[2],FAMILIES[1],QUALIFIERS_ONE[0],VALUES[0]),new KeyValue(ROWS_ONE[2],FAMILIES[1],QUALIFIERS_ONE[2],VALUES[0]),new KeyValue(ROWS_ONE[2],FAMILIES[1],QUALIFIERS_ONE[3],VALUES[0]),new KeyValue(ROWS_ONE[3],FAMILIES[0],QUALIFIERS_ONE[0],VALUES[0]),new KeyValue(ROWS_ONE[3],FAMILIES[0],QUALIFIERS_ONE[2],VALUES[0]),new KeyValue(ROWS_ONE[3],FAMILIES[0],QUALIFIERS_ONE[3],VALUES[0]),new KeyValue(ROWS_ONE[3],FAMILIES[1],QUALIFIERS_ONE[0],VALUES[0]),new KeyValue(ROWS_ONE[3],FAMILIES[1],QUALIFIERS_ONE[2],VALUES[0]),new KeyValue(ROWS_ONE[3],FAMILIES[1],QUALIFIERS_ONE[3],VALUES[0]),new KeyValue(ROWS_TWO[0],FAMILIES[0],QUALIFIERS_TWO[0],VALUES[1]),new KeyValue(ROWS_TWO[0],FAMILIES[0],QUALIFIERS_TWO[2],VALUES[1]),new KeyValue(ROWS_TWO[0],FAMILIES[0],QUALIFIERS_TWO[3],VALUES[1]),new KeyValue(ROWS_TWO[0],FAMILIES[1],QUALIFIERS_TWO[0],VALUES[1]),new KeyValue(ROWS_TWO[0],FAMILIES[1],QUALIFIERS_TWO[2],VALUES[1]),new KeyValue(ROWS_TWO[0],FAMILIES[1],QUALIFIERS_TWO[3],VALUES[1]),new KeyValue(ROWS_TWO[2],FAMILIES[0],QUALIFIERS_TWO[0],VALUES[1]),new KeyValue(ROWS_TWO[2],FAMILIES[0],QUALIFIERS_TWO[2],VALUES[1]),new KeyValue(ROWS_TWO[2],FAMILIES[0],QUALIFIERS_TWO[3],VALUES[1]),new KeyValue(ROWS_TWO[2],FAMILIES[1],QUALIFIERS_TWO[0],VALUES[1]),new KeyValue(ROWS_TWO[2],FAMILIES[1],QUALIFIERS_TWO[2],VALUES[1]),new KeyValue(ROWS_TWO[2],FAMILIES[1],QUALIFIERS_TWO[3],VALUES[1]),new KeyValue(ROWS_TWO[3],FAMILIES[0],QUALIFIERS_TWO[0],VALUES[1]),new KeyValue(ROWS_TWO[3],FAMILIES[0],QUALIFIERS_TWO[2],VALUES[1]),new KeyValue(ROWS_TWO[3],FAMILIES[0],QUALIFIERS_TWO[3],VALUES[1]),new KeyValue(ROWS_TWO[3],FAMILIES[1],QUALIFIERS_TWO[0],VALUES[1]),new KeyValue(ROWS_TWO[3],FAMILIES[1],QUALIFIERS_TWO[2],VALUES[1]),new KeyValue(ROWS_TWO[3],FAMILIES[1],QUALIFIERS_TWO[3],VALUES[1])};
  long expectedRows=6;
  long expectedKeys=this.colsPerRow;
  for (  boolean useLen : new boolean[]{false,true}) {
    Scan s=new Scan();
    s.setFilter(new KeyOnlyFilter(useLen));
    verifyScan(s,expectedRows,expectedKeys);
    verifyScanFullNoValues(s,expectedKVs,useLen);
  }
}

</code></pre>

<pre class="type-1 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test public void testSkipFilter() throws IOException {
  Filter f=new SkipFilter(new QualifierFilter(CompareOp.NOT_EQUAL,new BinaryComparator(Bytes.toBytes("testQualifierOne-2"))));
  Scan s=new Scan();
  s.setFilter(f);
  KeyValue[] kvs={new KeyValue(ROWS_TWO[0],FAMILIES[0],QUALIFIERS_TWO[0],VALUES[1]),new KeyValue(ROWS_TWO[0],FAMILIES[0],QUALIFIERS_TWO[2],VALUES[1]),new KeyValue(ROWS_TWO[0],FAMILIES[0],QUALIFIERS_TWO[3],VALUES[1]),new KeyValue(ROWS_TWO[0],FAMILIES[1],QUALIFIERS_TWO[0],VALUES[1]),new KeyValue(ROWS_TWO[0],FAMILIES[1],QUALIFIERS_TWO[2],VALUES[1]),new KeyValue(ROWS_TWO[0],FAMILIES[1],QUALIFIERS_TWO[3],VALUES[1]),new KeyValue(ROWS_TWO[2],FAMILIES[0],QUALIFIERS_TWO[0],VALUES[1]),new KeyValue(ROWS_TWO[2],FAMILIES[0],QUALIFIERS_TWO[2],VALUES[1]),new KeyValue(ROWS_TWO[2],FAMILIES[0],QUALIFIERS_TWO[3],VALUES[1]),new KeyValue(ROWS_TWO[2],FAMILIES[1],QUALIFIERS_TWO[0],VALUES[1]),new KeyValue(ROWS_TWO[2],FAMILIES[1],QUALIFIERS_TWO[2],VALUES[1]),new KeyValue(ROWS_TWO[2],FAMILIES[1],QUALIFIERS_TWO[3],VALUES[1]),new KeyValue(ROWS_TWO[3],FAMILIES[0],QUALIFIERS_TWO[0],VALUES[1]),new KeyValue(ROWS_TWO[3],FAMILIES[0],QUALIFIERS_TWO[2],VALUES[1]),new KeyValue(ROWS_TWO[3],FAMILIES[0],QUALIFIERS_TWO[3],VALUES[1]),new KeyValue(ROWS_TWO[3],FAMILIES[1],QUALIFIERS_TWO[0],VALUES[1]),new KeyValue(ROWS_TWO[3],FAMILIES[1],QUALIFIERS_TWO[2],VALUES[1]),new KeyValue(ROWS_TWO[3],FAMILIES[1],QUALIFIERS_TWO[3],VALUES[1])};
  verifyScanFull(s,kvs);
}

</code></pre>

<pre class="type-4 type-9 type-8 type-5 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions in iterations
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testFilterListWithPrefixFilter() throws IOException {
  byte[] family=Bytes.toBytes("f1");
  byte[] qualifier=Bytes.toBytes("q1");
  HTableDescriptor htd=new HTableDescriptor(TableName.valueOf("TestFilter"));
  htd.addFamily(new HColumnDescriptor(family));
  HRegionInfo info=new HRegionInfo(htd.getTableName(),null,null,false);
  Region testRegion=HBaseTestingUtility.createRegionAndWAL(info,TEST_UTIL.getDataTestDir(),TEST_UTIL.getConfiguration(),htd);
  for (int i=0; i < 5; i++) {
    Put p=new Put(Bytes.toBytes((char)('a' + i) + "row"));
    p.setDurability(Durability.SKIP_WAL);
    p.addColumn(family,qualifier,Bytes.toBytes(String.valueOf(111 + i)));
    testRegion.put(p);
  }
  testRegion.flush(true);
  PrefixFilter pf=new PrefixFilter(new byte[]{'b'});
  SingleColumnValueFilter scvf=new SingleColumnValueFilter(family,qualifier,CompareOp.EQUAL,Bytes.toBytes("113"));
  FilterList filterList=new FilterList(Operator.MUST_PASS_ONE,pf,scvf);
  Scan s1=new Scan();
  s1.setFilter(filterList);
  InternalScanner scanner=testRegion.getScanner(s1);
  List<Cell> results=new ArrayList<Cell>();
  int resultCount=0;
  while (scanner.next(results)) {
    resultCount++;
    byte[] row=CellUtil.cloneRow(results.get(0));
    LOG.debug("Found row: " + Bytes.toStringBinary(row));
    assertTrue(Bytes.equals(row,Bytes.toBytes("brow")) || Bytes.equals(row,Bytes.toBytes("crow")));
    results.clear();
  }
  assertEquals(2,resultCount);
  scanner.close();
  WAL wal=((HRegion)testRegion).getWAL();
  ((HRegion)testRegion).close();
  wal.close();
}

</code></pre>

<pre class="type-1 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test public void testColumnPaginationFilter() throws Exception {
  Put p=new Put(ROWS_ONE[0]);
  p.setDurability(Durability.SKIP_WAL);
  p.addColumn(FAMILIES[0],QUALIFIERS_ONE[0],VALUES[0]);
  this.region.put(p);
  this.region.flush(true);
  KeyValue[] expectedKVs={new KeyValue(ROWS_ONE[0],FAMILIES[0],QUALIFIERS_ONE[0],VALUES[0]),new KeyValue(ROWS_ONE[2],FAMILIES[0],QUALIFIERS_ONE[0],VALUES[0]),new KeyValue(ROWS_ONE[3],FAMILIES[0],QUALIFIERS_ONE[0],VALUES[0]),new KeyValue(ROWS_TWO[0],FAMILIES[0],QUALIFIERS_TWO[0],VALUES[1]),new KeyValue(ROWS_TWO[2],FAMILIES[0],QUALIFIERS_TWO[0],VALUES[1]),new KeyValue(ROWS_TWO[3],FAMILIES[0],QUALIFIERS_TWO[0],VALUES[1])};
  KeyValue[] expectedKVs2={new KeyValue(ROWS_ONE[0],FAMILIES[0],QUALIFIERS_ONE[3],VALUES[0]),new KeyValue(ROWS_ONE[2],FAMILIES[0],QUALIFIERS_ONE[3],VALUES[0]),new KeyValue(ROWS_ONE[3],FAMILIES[0],QUALIFIERS_ONE[3],VALUES[0]),new KeyValue(ROWS_TWO[0],FAMILIES[0],QUALIFIERS_TWO[3],VALUES[1]),new KeyValue(ROWS_TWO[2],FAMILIES[0],QUALIFIERS_TWO[3],VALUES[1]),new KeyValue(ROWS_TWO[3],FAMILIES[0],QUALIFIERS_TWO[3],VALUES[1])};
  KeyValue[] expectedKVs3={new KeyValue(ROWS_ONE[0],FAMILIES[0],QUALIFIERS_ONE[3],VALUES[0]),new KeyValue(ROWS_ONE[0],FAMILIES[1],QUALIFIERS_ONE[0],VALUES[0]),new KeyValue(ROWS_ONE[2],FAMILIES[0],QUALIFIERS_ONE[3],VALUES[0]),new KeyValue(ROWS_ONE[2],FAMILIES[1],QUALIFIERS_ONE[0],VALUES[0]),new KeyValue(ROWS_ONE[3],FAMILIES[0],QUALIFIERS_ONE[3],VALUES[0]),new KeyValue(ROWS_ONE[3],FAMILIES[1],QUALIFIERS_ONE[0],VALUES[0]),new KeyValue(ROWS_TWO[0],FAMILIES[0],QUALIFIERS_TWO[3],VALUES[1]),new KeyValue(ROWS_TWO[0],FAMILIES[1],QUALIFIERS_TWO[0],VALUES[1]),new KeyValue(ROWS_TWO[2],FAMILIES[0],QUALIFIERS_TWO[3],VALUES[1]),new KeyValue(ROWS_TWO[2],FAMILIES[1],QUALIFIERS_TWO[0],VALUES[1]),new KeyValue(ROWS_TWO[3],FAMILIES[0],QUALIFIERS_TWO[3],VALUES[1]),new KeyValue(ROWS_TWO[3],FAMILIES[1],QUALIFIERS_TWO[0],VALUES[1])};
  KeyValue[] expectedKVs4={};
  long expectedRows=this.numRows;
  long expectedKeys=1;
  Scan s=new Scan();
  s.setFilter(new ColumnPaginationFilter(1,0));
  verifyScan(s,expectedRows,expectedKeys);
  this.verifyScanFull(s,expectedKVs);
  s.setFilter(new ColumnPaginationFilter(1,2));
  verifyScan(s,expectedRows,expectedKeys);
  this.verifyScanFull(s,expectedKVs2);
  s.setFilter(new ColumnPaginationFilter(2,2));
  expectedKeys=2;
  verifyScan(s,expectedRows,expectedKeys);
  this.verifyScanFull(s,expectedKVs3);
  s.setFilter(new ColumnPaginationFilter(20,140));
  expectedKeys=0;
  expectedRows=0;
  verifyScan(s,expectedRows,0);
  this.verifyScanFull(s,expectedKVs4);
}

</code></pre>

<pre class="type-1 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test public void testFilterListWithSingleColumnValueFilter() throws IOException {
  SingleColumnValueFilter f1=new SingleColumnValueFilter(FAMILIES[0],QUALIFIERS_ONE[0],CompareOp.EQUAL,VALUES[0]);
  f1.setFilterIfMissing(true);
  Scan s1=new Scan();
  s1.addFamily(FAMILIES[0]);
  s1.setFilter(f1);
  KeyValue[] kvs1={new KeyValue(ROWS_ONE[0],FAMILIES[0],QUALIFIERS_ONE[0],VALUES[0]),new KeyValue(ROWS_ONE[0],FAMILIES[0],QUALIFIERS_ONE[2],VALUES[0]),new KeyValue(ROWS_ONE[0],FAMILIES[0],QUALIFIERS_ONE[3],VALUES[0]),new KeyValue(ROWS_ONE[2],FAMILIES[0],QUALIFIERS_ONE[0],VALUES[0]),new KeyValue(ROWS_ONE[2],FAMILIES[0],QUALIFIERS_ONE[2],VALUES[0]),new KeyValue(ROWS_ONE[2],FAMILIES[0],QUALIFIERS_ONE[3],VALUES[0]),new KeyValue(ROWS_ONE[3],FAMILIES[0],QUALIFIERS_ONE[0],VALUES[0]),new KeyValue(ROWS_ONE[3],FAMILIES[0],QUALIFIERS_ONE[2],VALUES[0]),new KeyValue(ROWS_ONE[3],FAMILIES[0],QUALIFIERS_ONE[3],VALUES[0])};
  verifyScanNoEarlyOut(s1,3,3);
  verifyScanFull(s1,kvs1);
  SingleColumnValueFilter f2=new SingleColumnValueFilter(FAMILIES[0],QUALIFIERS_TWO[0],CompareOp.EQUAL,VALUES[1]);
  f2.setFilterIfMissing(true);
  Scan s2=new Scan();
  s2.addFamily(FAMILIES[0]);
  s2.setFilter(f2);
  KeyValue[] kvs2={new KeyValue(ROWS_TWO[0],FAMILIES[0],QUALIFIERS_TWO[0],VALUES[1]),new KeyValue(ROWS_TWO[0],FAMILIES[0],QUALIFIERS_TWO[2],VALUES[1]),new KeyValue(ROWS_TWO[0],FAMILIES[0],QUALIFIERS_TWO[3],VALUES[1]),new KeyValue(ROWS_TWO[2],FAMILIES[0],QUALIFIERS_TWO[0],VALUES[1]),new KeyValue(ROWS_TWO[2],FAMILIES[0],QUALIFIERS_TWO[2],VALUES[1]),new KeyValue(ROWS_TWO[2],FAMILIES[0],QUALIFIERS_TWO[3],VALUES[1]),new KeyValue(ROWS_TWO[3],FAMILIES[0],QUALIFIERS_TWO[0],VALUES[1]),new KeyValue(ROWS_TWO[3],FAMILIES[0],QUALIFIERS_TWO[2],VALUES[1]),new KeyValue(ROWS_TWO[3],FAMILIES[0],QUALIFIERS_TWO[3],VALUES[1])};
  verifyScanNoEarlyOut(s2,3,3);
  verifyScanFull(s2,kvs2);
  FilterList f=new FilterList(Operator.MUST_PASS_ONE);
  f.addFilter(f1);
  f.addFilter(f2);
  Scan s=new Scan();
  s.addFamily(FAMILIES[0]);
  s.setFilter(f);
  KeyValue[] kvs={new KeyValue(ROWS_ONE[0],FAMILIES[0],QUALIFIERS_ONE[0],VALUES[0]),new KeyValue(ROWS_ONE[0],FAMILIES[0],QUALIFIERS_ONE[2],VALUES[0]),new KeyValue(ROWS_ONE[0],FAMILIES[0],QUALIFIERS_ONE[3],VALUES[0]),new KeyValue(ROWS_ONE[2],FAMILIES[0],QUALIFIERS_ONE[0],VALUES[0]),new KeyValue(ROWS_ONE[2],FAMILIES[0],QUALIFIERS_ONE[2],VALUES[0]),new KeyValue(ROWS_ONE[2],FAMILIES[0],QUALIFIERS_ONE[3],VALUES[0]),new KeyValue(ROWS_ONE[3],FAMILIES[0],QUALIFIERS_ONE[0],VALUES[0]),new KeyValue(ROWS_ONE[3],FAMILIES[0],QUALIFIERS_ONE[2],VALUES[0]),new KeyValue(ROWS_ONE[3],FAMILIES[0],QUALIFIERS_ONE[3],VALUES[0]),new KeyValue(ROWS_TWO[0],FAMILIES[0],QUALIFIERS_TWO[0],VALUES[1]),new KeyValue(ROWS_TWO[0],FAMILIES[0],QUALIFIERS_TWO[2],VALUES[1]),new KeyValue(ROWS_TWO[0],FAMILIES[0],QUALIFIERS_TWO[3],VALUES[1]),new KeyValue(ROWS_TWO[2],FAMILIES[0],QUALIFIERS_TWO[0],VALUES[1]),new KeyValue(ROWS_TWO[2],FAMILIES[0],QUALIFIERS_TWO[2],VALUES[1]),new KeyValue(ROWS_TWO[2],FAMILIES[0],QUALIFIERS_TWO[3],VALUES[1]),new KeyValue(ROWS_TWO[3],FAMILIES[0],QUALIFIERS_TWO[0],VALUES[1]),new KeyValue(ROWS_TWO[3],FAMILIES[0],QUALIFIERS_TWO[2],VALUES[1]),new KeyValue(ROWS_TWO[3],FAMILIES[0],QUALIFIERS_TWO[3],VALUES[1])};
  verifyScanNoEarlyOut(s,6,3);
  verifyScanFull(s,kvs);
}

</code></pre>

<pre class="type-1 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test public void testFamilyFilter() throws IOException {
  long expectedRows=this.numRows;
  long expectedKeys=this.colsPerRow / 2;
  Filter f=new FamilyFilter(CompareOp.EQUAL,new BinaryComparator(Bytes.toBytes("testFamilyOne")));
  Scan s=new Scan();
  s.setFilter(f);
  verifyScanNoEarlyOut(s,expectedRows,expectedKeys);
  expectedRows=0;
  expectedKeys=0;
  f=new FamilyFilter(CompareOp.LESS,new BinaryComparator(Bytes.toBytes("testFamily")));
  s=new Scan();
  s.setFilter(f);
  verifyScanNoEarlyOut(s,expectedRows,expectedKeys);
  expectedRows=this.numRows;
  expectedKeys=this.colsPerRow / 2;
  f=new FamilyFilter(CompareOp.LESS_OR_EQUAL,new BinaryComparator(Bytes.toBytes("testFamilyOne")));
  s=new Scan();
  s.setFilter(f);
  verifyScanNoEarlyOut(s,expectedRows,expectedKeys);
  expectedRows=this.numRows / 2;
  expectedKeys=this.colsPerRow / 2;
  f=new FamilyFilter(CompareOp.NOT_EQUAL,new BinaryComparator(Bytes.toBytes("testFamilyOne")));
  s=new Scan(HConstants.EMPTY_START_ROW,Bytes.toBytes("testRowTwo"));
  s.setFilter(f);
  verifyScanNoEarlyOut(s,expectedRows,expectedKeys);
  expectedRows=this.numRows / 2;
  expectedKeys=this.colsPerRow;
  f=new FamilyFilter(CompareOp.GREATER_OR_EQUAL,new BinaryComparator(Bytes.toBytes("testFamilyOne")));
  s=new Scan(HConstants.EMPTY_START_ROW,Bytes.toBytes("testRowTwo"));
  s.setFilter(f);
  verifyScanNoEarlyOut(s,expectedRows,expectedKeys);
  expectedRows=this.numRows / 2;
  expectedKeys=this.colsPerRow / 2;
  f=new FamilyFilter(CompareOp.GREATER,new BinaryComparator(Bytes.toBytes("testFamilyOne")));
  s=new Scan(HConstants.EMPTY_START_ROW,Bytes.toBytes("testRowTwo"));
  s.setFilter(f);
  verifyScanNoEarlyOut(s,expectedRows,expectedKeys);
  f=new FamilyFilter(CompareOp.NOT_EQUAL,new BinaryComparator(FAMILIES[1]));
  s=new Scan();
  s.setFilter(f);
  KeyValue[] kvs={new KeyValue(ROWS_ONE[0],FAMILIES[0],QUALIFIERS_ONE[0],VALUES[0]),new KeyValue(ROWS_ONE[0],FAMILIES[0],QUALIFIERS_ONE[2],VALUES[0]),new KeyValue(ROWS_ONE[0],FAMILIES[0],QUALIFIERS_ONE[3],VALUES[0]),new KeyValue(ROWS_ONE[2],FAMILIES[0],QUALIFIERS_ONE[0],VALUES[0]),new KeyValue(ROWS_ONE[2],FAMILIES[0],QUALIFIERS_ONE[2],VALUES[0]),new KeyValue(ROWS_ONE[2],FAMILIES[0],QUALIFIERS_ONE[3],VALUES[0]),new KeyValue(ROWS_ONE[3],FAMILIES[0],QUALIFIERS_ONE[0],VALUES[0]),new KeyValue(ROWS_ONE[3],FAMILIES[0],QUALIFIERS_ONE[2],VALUES[0]),new KeyValue(ROWS_ONE[3],FAMILIES[0],QUALIFIERS_ONE[3],VALUES[0]),new KeyValue(ROWS_TWO[0],FAMILIES[0],QUALIFIERS_TWO[0],VALUES[1]),new KeyValue(ROWS_TWO[0],FAMILIES[0],QUALIFIERS_TWO[2],VALUES[1]),new KeyValue(ROWS_TWO[0],FAMILIES[0],QUALIFIERS_TWO[3],VALUES[1]),new KeyValue(ROWS_TWO[2],FAMILIES[0],QUALIFIERS_TWO[0],VALUES[1]),new KeyValue(ROWS_TWO[2],FAMILIES[0],QUALIFIERS_TWO[2],VALUES[1]),new KeyValue(ROWS_TWO[2],FAMILIES[0],QUALIFIERS_TWO[3],VALUES[1]),new KeyValue(ROWS_TWO[3],FAMILIES[0],QUALIFIERS_TWO[0],VALUES[1]),new KeyValue(ROWS_TWO[3],FAMILIES[0],QUALIFIERS_TWO[2],VALUES[1]),new KeyValue(ROWS_TWO[3],FAMILIES[0],QUALIFIERS_TWO[3],VALUES[1])};
  verifyScanFull(s,kvs);
  f=new FamilyFilter(CompareOp.NOT_EQUAL,new RegexStringComparator("test.*One"));
  s=new Scan();
  s.setFilter(f);
  kvs=new KeyValue[]{new KeyValue(ROWS_ONE[0],FAMILIES[1],QUALIFIERS_ONE[0],VALUES[0]),new KeyValue(ROWS_ONE[0],FAMILIES[1],QUALIFIERS_ONE[2],VALUES[0]),new KeyValue(ROWS_ONE[0],FAMILIES[1],QUALIFIERS_ONE[3],VALUES[0]),new KeyValue(ROWS_ONE[2],FAMILIES[1],QUALIFIERS_ONE[0],VALUES[0]),new KeyValue(ROWS_ONE[2],FAMILIES[1],QUALIFIERS_ONE[2],VALUES[0]),new KeyValue(ROWS_ONE[2],FAMILIES[1],QUALIFIERS_ONE[3],VALUES[0]),new KeyValue(ROWS_ONE[3],FAMILIES[1],QUALIFIERS_ONE[0],VALUES[0]),new KeyValue(ROWS_ONE[3],FAMILIES[1],QUALIFIERS_ONE[2],VALUES[0]),new KeyValue(ROWS_ONE[3],FAMILIES[1],QUALIFIERS_ONE[3],VALUES[0]),new KeyValue(ROWS_TWO[0],FAMILIES[1],QUALIFIERS_TWO[0],VALUES[1]),new KeyValue(ROWS_TWO[0],FAMILIES[1],QUALIFIERS_TWO[2],VALUES[1]),new KeyValue(ROWS_TWO[0],FAMILIES[1],QUALIFIERS_TWO[3],VALUES[1]),new KeyValue(ROWS_TWO[2],FAMILIES[1],QUALIFIERS_TWO[0],VALUES[1]),new KeyValue(ROWS_TWO[2],FAMILIES[1],QUALIFIERS_TWO[2],VALUES[1]),new KeyValue(ROWS_TWO[2],FAMILIES[1],QUALIFIERS_TWO[3],VALUES[1]),new KeyValue(ROWS_TWO[3],FAMILIES[1],QUALIFIERS_TWO[0],VALUES[1]),new KeyValue(ROWS_TWO[3],FAMILIES[1],QUALIFIERS_TWO[2],VALUES[1]),new KeyValue(ROWS_TWO[3],FAMILIES[1],QUALIFIERS_TWO[3],VALUES[1])};
  verifyScanFull(s,kvs);
}

</code></pre>

<pre class="type-1 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test public void testInclusiveStopFilter() throws IOException {
  long expectedRows=(this.numRows / 2) - 1;
  long expectedKeys=this.colsPerRow;
  Scan s=new Scan(Bytes.toBytes("testRowOne-0"),Bytes.toBytes("testRowOne-3"));
  verifyScan(s,expectedRows,expectedKeys);
  expectedRows=this.numRows / 2;
  s=new Scan(Bytes.toBytes("testRowOne-0"));
  s.setFilter(new InclusiveStopFilter(Bytes.toBytes("testRowOne-3")));
  verifyScan(s,expectedRows,expectedKeys);
  expectedRows=(this.numRows / 2) - 1;
  expectedKeys=this.colsPerRow;
  s=new Scan(Bytes.toBytes("testRowTwo-0"),Bytes.toBytes("testRowTwo-3"));
  verifyScan(s,expectedRows,expectedKeys);
  expectedRows=this.numRows / 2;
  s=new Scan(Bytes.toBytes("testRowTwo-0"));
  s.setFilter(new InclusiveStopFilter(Bytes.toBytes("testRowTwo-3")));
  verifyScan(s,expectedRows,expectedKeys);
}

</code></pre>

<pre class="type-9 type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies boolean conditions
"></span><br>
/** 
 * Tests the the {@link WhileMatchFilter} works in combination with a{@link Filter} that uses the {@link Filter#filterKeyValue(Cell)} method.
 * See HBASE-2258.
 * @throws Exception
 */
@Test public void testWhileMatchFilterWithFilterKeyValue() throws Exception {
  Scan s=new Scan();
  WhileMatchFilter filter=new WhileMatchFilter(new SingleColumnValueFilter(FAMILIES[0],QUALIFIERS_ONE[0],CompareOp.EQUAL,Bytes.toBytes("foo")));
  s.setFilter(filter);
  InternalScanner scanner=this.region.getScanner(s);
  while (true) {
    ArrayList<Cell> values=new ArrayList<Cell>();
    boolean isMoreResults=scanner.next(values);
    assertTrue("The WhileMatchFilter should now filter all remaining",filter.filterAllRemaining());
    if (!isMoreResults) {
      break;
    }
  }
}

</code></pre>

<pre class="type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Releases resources used by the test cases">TestCleaner</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Releases resources used by the test cases
"></span><br>
@After public void tearDown() throws Exception {
  HBaseTestingUtility.closeRegionAndWAL(region);
}

</code></pre>

<pre class="type-1 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test public void testPrefixFilter() throws Exception {
  long expectedRows=this.numRows / 2;
  long expectedKeys=this.colsPerRow;
  Scan s=new Scan();
  s.setFilter(new PrefixFilter(Bytes.toBytes("testRowOne")));
  verifyScan(s,expectedRows,expectedKeys);
}

</code></pre>

<pre class="type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies boolean conditions
"></span><br>
/** 
 * The following test is to ensure old(such as hbase0.94) filterRow() can be correctly fired in
 * 0.96+ code base.
 * See HBASE-10366
 * @throws Exception
 */
@Test public void tes94FilterRowCompatibility() throws Exception {
  Scan s=new Scan();
  OldTestFilter filter=new OldTestFilter();
  s.setFilter(filter);
  InternalScanner scanner=this.region.getScanner(s);
  ArrayList<Cell> values=new ArrayList<Cell>();
  scanner.next(values);
  assertTrue("All rows should be filtered out",values.isEmpty());
}

</code></pre>

<pre class="type-9 type-10 type-8 type-5 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies assertions inside branch conditions
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Tests the the {@link WhileMatchFilter} works in combination with a{@link Filter} that uses the{@link Filter#filterRow()} method.
 * See HBASE-2258.
 * @throws Exception
 */
@Test public void testWhileMatchFilterWithFilterRow() throws Exception {
  final int pageSize=4;
  Scan s=new Scan();
  WhileMatchFilter filter=new WhileMatchFilter(new PageFilter(pageSize));
  s.setFilter(filter);
  InternalScanner scanner=this.region.getScanner(s);
  int scannerCounter=0;
  while (true) {
    boolean isMoreResults=scanner.next(new ArrayList<Cell>());
    scannerCounter++;
    if (scannerCounter >= pageSize) {
      assertTrue("The WhileMatchFilter should now filter all remaining",filter.filterAllRemaining());
    }
    if (!isMoreResults) {
      break;
    }
  }
  assertEquals("The page filter returned more rows than expected",pageSize,scannerCounter);
}

</code></pre>

<pre class="type-1 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test public void testSingleColumnValueFilter() throws IOException {
  Put p=new Put(ROWS_ONE[2]);
  p.addColumn(FAMILIES[0],QUALIFIERS_ONE[2],VALUES[1]);
  this.region.put(p);
  List<Filter> filters=new ArrayList<Filter>();
  filters.add(new SingleColumnValueFilter(FAMILIES[0],QUALIFIERS_ONE[0],CompareOp.EQUAL,VALUES[0]));
  filters.add(new SingleColumnValueFilter(FAMILIES[0],QUALIFIERS_ONE[2],CompareOp.EQUAL,VALUES[1]));
  Filter f=new FilterList(Operator.MUST_PASS_ALL,filters);
  Scan s=new Scan(ROWS_ONE[0],ROWS_TWO[0]);
  s.addFamily(FAMILIES[0]);
  s.setFilter(f);
  KeyValue[] kvs={new KeyValue(ROWS_ONE[2],FAMILIES[0],QUALIFIERS_ONE[0],VALUES[0]),new KeyValue(ROWS_ONE[2],FAMILIES[0],QUALIFIERS_ONE[2],VALUES[1]),new KeyValue(ROWS_ONE[2],FAMILIES[0],QUALIFIERS_ONE[3],VALUES[0])};
  verifyScanNoEarlyOut(s,1,3);
  verifyScanFull(s,kvs);
  filters=new ArrayList<Filter>();
  filters.add(new SkipFilter(new SingleColumnValueFilter(FAMILIES[0],QUALIFIERS_ONE[0],CompareOp.EQUAL,VALUES[0])));
  filters.add(new SkipFilter(new SingleColumnValueFilter(FAMILIES[0],QUALIFIERS_ONE[2],CompareOp.EQUAL,VALUES[1])));
  f=new FilterList(Operator.MUST_PASS_ALL,filters);
  s=new Scan(ROWS_ONE[0],ROWS_TWO[0]);
  s.addFamily(FAMILIES[0]);
  s.setFilter(f);
  verifyScanNoEarlyOut(s,1,3);
  verifyScanFull(s,kvs);
  byte[][] ROWS_THREE={Bytes.toBytes("rowThree-0"),Bytes.toBytes("rowThree-1"),Bytes.toBytes("rowThree-2"),Bytes.toBytes("rowThree-3")};
  KeyValue[] srcKVs=new KeyValue[]{new KeyValue(ROWS_THREE[0],FAMILIES[0],QUALIFIERS_ONE[0],VALUES[0]),new KeyValue(ROWS_THREE[1],FAMILIES[0],QUALIFIERS_ONE[0],VALUES[1]),new KeyValue(ROWS_THREE[2],FAMILIES[0],QUALIFIERS_ONE[1],VALUES[0]),new KeyValue(ROWS_THREE[3],FAMILIES[0],QUALIFIERS_ONE[1],VALUES[1])};
  for (  KeyValue kv : srcKVs) {
    Put put=new Put(CellUtil.cloneRow(kv)).add(kv);
    put.setDurability(Durability.SKIP_WAL);
    this.region.put(put);
  }
  SingleColumnValueFilter scvf=new SingleColumnValueFilter(FAMILIES[0],QUALIFIERS_ONE[0],CompareOp.EQUAL,VALUES[0]);
  s=new Scan(ROWS_THREE[0],Bytes.toBytes("rowThree-4"));
  s.addFamily(FAMILIES[0]);
  s.setFilter(scvf);
  kvs=new KeyValue[]{srcKVs[0],srcKVs[2],srcKVs[3]};
  verifyScanFull(s,kvs);
  scvf=new SingleColumnValueFilter(FAMILIES[0],QUALIFIERS_ONE[0],CompareOp.EQUAL,VALUES[0]);
  scvf.setFilterIfMissing(true);
  s=new Scan(ROWS_THREE[0],Bytes.toBytes("rowThree-4"));
  s.addFamily(FAMILIES[0]);
  s.setFilter(scvf);
  kvs=new KeyValue[]{srcKVs[0]};
  verifyScanFull(s,kvs);
  scvf=new SingleColumnValueFilter(FAMILIES[0],QUALIFIERS_ONE[1],CompareOp.EQUAL,VALUES[1]);
  scvf.setFilterIfMissing(true);
  s=new Scan(ROWS_THREE[0],Bytes.toBytes("rowThree-4"));
  s.addFamily(FAMILIES[0]);
  s.setFilter(scvf);
  kvs=new KeyValue[]{srcKVs[3]};
  verifyScanFull(s,kvs);
  KeyValue kvA=new KeyValue(ROWS_THREE[0],FAMILIES[0],QUALIFIERS_ONE[1],VALUES[0]);
  this.region.put(new Put(CellUtil.cloneRow(kvA)).add(kvA));
  scvf=new SingleColumnValueFilter(FAMILIES[0],QUALIFIERS_ONE[1],CompareOp.EQUAL,VALUES[1]);
  scvf.setFilterIfMissing(true);
  s=new Scan(ROWS_THREE[0],Bytes.toBytes("rowThree-4"));
  s.addFamily(FAMILIES[0]);
  s.setFilter(scvf);
  kvs=new KeyValue[]{srcKVs[3]};
  verifyScanFull(s,kvs);
}

</code></pre>

<pre class="type-4 type-9 type-10 type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions in iterations
- Verifies assertions inside branch conditions
- Verifies boolean conditions
"></span><br>
/** 
 * Tests the the {@link WhileMatchFilter} works in combination with a{@link Filter} that uses the{@link Filter#filterRowKey(Cell)} method.
 * See HBASE-2258.
 * @throws Exception
 */
@Test public void testWhileMatchFilterWithFilterRowKey() throws Exception {
  Scan s=new Scan();
  String prefix="testRowOne";
  WhileMatchFilter filter=new WhileMatchFilter(new PrefixFilter(Bytes.toBytes(prefix)));
  s.setFilter(filter);
  InternalScanner scanner=this.region.getScanner(s);
  while (true) {
    ArrayList<Cell> values=new ArrayList<Cell>();
    boolean isMoreResults=scanner.next(values);
    if (!isMoreResults || !Bytes.toString(CellUtil.cloneRow(values.get(0))).startsWith(prefix)) {
      assertTrue("The WhileMatchFilter should now filter all remaining",filter.filterAllRemaining());
    }
    if (!isMoreResults) {
      break;
    }
  }
}

</code></pre>

<script>$(document).ready(function() {
  $('pre code').each(function(i, block) {
    hljs.highlightBlock(block);
  });
});</script>
