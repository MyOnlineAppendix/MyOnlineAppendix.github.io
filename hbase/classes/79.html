<h3 style="margin:0px">Class: org.apache.hadoop.hbase.client.TestFromClientSide (78 methods) </h3><br><pre style="padding:0"><code class="html"><div id="tags"><button id="7"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('7')" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls"><kbd id="tag-7"class="label-info"style="display: inline-block;font-size:7pt" >InternalCallVerifier&nbsp;(49)</kbd></button>&nbsp;<button id="5"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('5')" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value "><kbd id="tag-5"class="label-info"style="display: inline-block;font-size:7pt" >EqualityVerifier&nbsp;(41)</kbd></button>&nbsp;<button id="8"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('8')" data-toggle="tooltip" title="Verifies boolean conditions"><kbd id="tag-8"class="label-info"style="display: inline-block;font-size:7pt" >BooleanVerifier&nbsp;(31)</kbd></button>&nbsp;<button id="4"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('4')" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) "><kbd id="tag-4"class="label-info"style="display: inline-block;font-size:7pt" >APIUtilityVerifier&nbsp;(24)</kbd></button>&nbsp;<button id="6"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('6')" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes"><kbd id="tag-6"class="label-info"style="display: inline-block;font-size:7pt" >HybridVerifier&nbsp;(23)</kbd></button>&nbsp;<button id="1"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('1')" data-toggle="tooltip" title="Executes methods or other tests from the same test unit"><kbd id="tag-1"class="label-info"style="display: inline-block;font-size:7pt" >ExecutionTester&nbsp;(12)</kbd></button>&nbsp;<button id="9"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('9')" data-toggle="tooltip" title="Verifies assertions in iterations"><kbd id="tag-9"class="label-info"style="display: inline-block;font-size:7pt" >IterativeVerifier&nbsp;(7)</kbd></button>&nbsp;<button id="13"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('13')" data-toggle="tooltip" title="Verifies whether objects are null"><kbd id="tag-13"class="label-info"style="display: inline-block;font-size:7pt" >NullVerifier&nbsp;(7)</kbd></button>&nbsp;<button id="11"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('11')" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure"><kbd id="tag-11"class="label-info"style="display: inline-block;font-size:7pt" >UtilityVerifier&nbsp;(6)</kbd></button>&nbsp;<button id="14"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('14')" data-toggle="tooltip" title="Is an empty test case"><kbd id="tag-14"class="label-info"style="display: inline-block;font-size:7pt" >EmptyTester&nbsp;(5)</kbd></button>&nbsp;<button id="10"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('10')" data-toggle="tooltip" title="Verifies assertions inside branch conditions"><kbd id="tag-10"class="label-info"style="display: inline-block;font-size:7pt" >BranchVerifier&nbsp;(4)</kbd></button>&nbsp;<button id="18"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('18')" data-toggle="tooltip" title="Is not executed with the test suite"><kbd id="tag-18"class="label-info"style="display: inline-block;font-size:7pt" >IgnoredMethod&nbsp;(4)</kbd></button>&nbsp;<button id="12"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('12')" data-toggle="tooltip" title="Verifies values related to public fields."><kbd id="tag-12"class="label-info"style="display: inline-block;font-size:7pt" >PublicFieldVerifier&nbsp;(3)</kbd></button>&nbsp;<button id="3"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('3')" data-toggle="tooltip" title="Releases resources used by the test cases"><kbd id="tag-3"class="label-info"style="display: inline-block;font-size:7pt" >TestCleaner&nbsp;(2)</kbd></button>&nbsp;<button id="2"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('2')" data-toggle="tooltip" title="Allocates resources before the execution of the test cases"><kbd id="tag-2"class="label-info"style="display: inline-block;font-size:7pt" >TestInitializer&nbsp;(1)</kbd></button>&nbsp;<button id="16"style="border-width:0;padding:0;background:#282B2E"  onclick="filter('16')" data-toggle="tooltip" title="Verifies whether two objects/variables are the same"><kbd id="tag-16"class="label-info"style="display: inline-block;font-size:7pt" >IdentityVerifier&nbsp;(1)</kbd></button>&nbsp;</div></code></pre><center><button onclick="showBlocks()" style="margin:6px">Update filter <span class="glyphicon glyphicon-refresh" aria-hidden="true"></span> </button></center><br>
<pre class="type-8 type-5 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testSmallScan() throws Exception {
  TableName TABLE=TableName.valueOf("testSmallScan");
  Table table=TEST_UTIL.createTable(TABLE,FAMILY);
  int insertNum=10;
  for (int i=0; i < 10; i++) {
    Put put=new Put(Bytes.toBytes("row" + String.format("%03d",i)));
    put.addColumn(FAMILY,QUALIFIER,VALUE);
    table.put(put);
  }
  ResultScanner scanner=table.getScanner(new Scan());
  int count=0;
  for (  Result r : scanner) {
    assertTrue(!r.isEmpty());
    count++;
  }
  assertEquals(insertNum,count);
  Scan scan=new Scan(HConstants.EMPTY_START_ROW,HConstants.EMPTY_END_ROW);
  scan.setSmall(true);
  scan.setCaching(2);
  scanner=table.getScanner(scan);
  count=0;
  for (  Result r : scanner) {
    assertTrue(!r.isEmpty());
    count++;
  }
  assertEquals(insertNum,count);
}

</code></pre>

<pre class="type-7 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
"></span><br>
@Test public void testDeleteFamilyVersionWithOtherDeletes() throws Exception {
  TableName TABLE=TableName.valueOf("testDeleteFamilyVersionWithOtherDeletes");
  byte[][] QUALIFIERS=makeNAscii(QUALIFIER,5);
  byte[][] VALUES=makeN(VALUE,5);
  long[] ts={1000,2000,3000,4000,5000};
  Admin admin=TEST_UTIL.getHBaseAdmin();
  Table ht=TEST_UTIL.createTable(TABLE,FAMILY,5);
  Put put=null;
  Result result=null;
  Get get=null;
  Delete delete=null;
  put=new Put(ROW);
  for (int q=0; q < 5; q++)   for (int t=0; t < 5; t++)   put.addColumn(FAMILY,QUALIFIERS[q],ts[t],VALUES[t]);
  ht.put(put);
  admin.flush(TABLE);
  byte[] ROW2=Bytes.toBytes("myRowForTest");
  put=new Put(ROW2);
  for (int q=0; q < 5; q++)   for (int t=0; t < 5; t++)   put.addColumn(FAMILY,QUALIFIERS[q],ts[t],VALUES[t]);
  ht.put(put);
  admin.flush(TABLE);
  delete=new Delete(ROW);
  delete.addFamily(FAMILY,ts[1]);
  delete.addFamilyVersion(FAMILY,ts[3]);
  delete.addColumns(FAMILY,QUALIFIERS[0],ts[2]);
  delete.addColumns(FAMILY,QUALIFIERS[2],ts[4]);
  delete.addColumn(FAMILY,QUALIFIERS[4],ts[4]);
  ht.delete(delete);
  admin.flush(TABLE);
  delete=new Delete(ROW2);
  delete.addFamilyVersion(FAMILY,ts[1]);
  delete.addFamilyVersion(FAMILY,ts[3]);
  ht.delete(delete);
  admin.flush(TABLE);
  get=new Get(ROW);
  get.addColumn(FAMILY,QUALIFIERS[0]);
  get.setMaxVersions(Integer.MAX_VALUE);
  result=ht.get(get);
  assertNResult(result,ROW,FAMILY,QUALIFIERS[0],new long[]{ts[4]},new byte[][]{VALUES[4]},0,0);
  get=new Get(ROW);
  get.addColumn(FAMILY,QUALIFIERS[1]);
  get.setMaxVersions(Integer.MAX_VALUE);
  result=ht.get(get);
  assertNResult(result,ROW,FAMILY,QUALIFIERS[1],new long[]{ts[2],ts[4]},new byte[][]{VALUES[2],VALUES[4]},0,1);
  get=new Get(ROW);
  get.addColumn(FAMILY,QUALIFIERS[2]);
  get.setMaxVersions(Integer.MAX_VALUE);
  result=ht.get(get);
  assertEquals(0,result.size());
  get=new Get(ROW);
  get.addColumn(FAMILY,QUALIFIERS[3]);
  get.setMaxVersions(Integer.MAX_VALUE);
  result=ht.get(get);
  assertNResult(result,ROW,FAMILY,QUALIFIERS[3],new long[]{ts[2],ts[4]},new byte[][]{VALUES[2],VALUES[4]},0,1);
  get=new Get(ROW);
  get.addColumn(FAMILY,QUALIFIERS[4]);
  get.setMaxVersions(Integer.MAX_VALUE);
  result=ht.get(get);
  assertNResult(result,ROW,FAMILY,QUALIFIERS[4],new long[]{ts[2]},new byte[][]{VALUES[2]},0,0);
  for (int i=0; i < 5; i++) {
    get=new Get(ROW2);
    get.addColumn(FAMILY,QUALIFIERS[i]);
    get.setMaxVersions(Integer.MAX_VALUE);
    result=ht.get(get);
    assertNResult(result,ROW2,FAMILY,QUALIFIERS[i],new long[]{ts[0],ts[2],ts[4]},new byte[][]{VALUES[0],VALUES[2],VALUES[4]},0,2);
  }
  ht.close();
  admin.close();
}

</code></pre>

<pre class="type-7 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
"></span><br>
@Test public void testKeyOnlyFilterWithReverseScan() throws Exception {
  TableName TABLE=TableName.valueOf("testKeyOnlyFilterWithReverseScan");
  Table ht=TEST_UTIL.createTable(TABLE,FAMILY);
  byte[][] ROWS=makeN(ROW,10);
  byte[][] QUALIFIERS={Bytes.toBytes("col0-<d2v1>-<d3v2>"),Bytes.toBytes("col1-<d2v1>-<d3v2>"),Bytes.toBytes("col2-<d2v1>-<d3v2>"),Bytes.toBytes("col3-<d2v1>-<d3v2>"),Bytes.toBytes("col4-<d2v1>-<d3v2>"),Bytes.toBytes("col5-<d2v1>-<d3v2>"),Bytes.toBytes("col6-<d2v1>-<d3v2>"),Bytes.toBytes("col7-<d2v1>-<d3v2>"),Bytes.toBytes("col8-<d2v1>-<d3v2>"),Bytes.toBytes("col9-<d2v1>-<d3v2>")};
  for (int i=0; i < 10; i++) {
    Put put=new Put(ROWS[i]);
    put.addColumn(FAMILY,QUALIFIERS[i],VALUE);
    ht.put(put);
  }
  Scan scan=new Scan();
  scan.setReversed(true);
  scan.addFamily(FAMILY);
  Filter filter=new KeyOnlyFilter(true);
  scan.setFilter(filter);
  ResultScanner scanner=ht.getScanner(scan);
  int count=0;
  for (  Result result : ht.getScanner(scan)) {
    assertEquals(result.size(),1);
    assertEquals(result.rawCells()[0].getValueLength(),Bytes.SIZEOF_INT);
    assertEquals(Bytes.toInt(CellUtil.cloneValue(result.rawCells()[0])),VALUE.length);
    count++;
  }
  assertEquals(count,10);
  scanner.close();
  ht.close();
}

</code></pre>

<pre class="type-9 type-7 type-5 type-12 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values related to public fields.">PublicFieldVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Verifies values related to public fields.
"></span><br>
@Test public void testGetStartEndKeysWithRegionReplicas() throws IOException {
  HTableDescriptor htd=new HTableDescriptor(TableName.valueOf("testGetStartEndKeys"));
  HColumnDescriptor fam=new HColumnDescriptor(FAMILY);
  htd.addFamily(fam);
  byte[][] KEYS=HBaseTestingUtility.KEYS_FOR_HBA_CREATE_TABLE;
  Admin admin=TEST_UTIL.getHBaseAdmin();
  admin.createTable(htd,KEYS);
  List<HRegionInfo> regions=admin.getTableRegions(htd.getTableName());
  HRegionLocator locator=(HRegionLocator)admin.getConnection().getRegionLocator(htd.getTableName());
  for (int regionReplication=1; regionReplication < 4; regionReplication++) {
    List<RegionLocations> regionLocations=new ArrayList<RegionLocations>();
    for (    HRegionInfo region : regions) {
      HRegionLocation[] arr=new HRegionLocation[regionReplication];
      for (int i=0; i < arr.length; i++) {
        arr[i]=new HRegionLocation(RegionReplicaUtil.getRegionInfoForReplica(region,i),null);
      }
      regionLocations.add(new RegionLocations(arr));
    }
    Pair<byte[][],byte[][]> startEndKeys=locator.getStartEndKeys(regionLocations);
    assertEquals(KEYS.length + 1,startEndKeys.getFirst().length);
    for (int i=0; i < KEYS.length + 1; i++) {
      byte[] startKey=i == 0 ? HConstants.EMPTY_START_ROW : KEYS[i - 1];
      byte[] endKey=i == KEYS.length ? HConstants.EMPTY_END_ROW : KEYS[i];
      assertArrayEquals(startKey,startEndKeys.getFirst()[i]);
      assertArrayEquals(endKey,startEndKeys.getSecond()[i]);
    }
  }
}

</code></pre>

<pre class="type-1 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * HBASE-861
 * get with timestamp will return a value if there is a version with an
 * earlier timestamp
 */
@Test public void testJiraTest861() throws Exception {
  TableName TABLE=TableName.valueOf("testJiraTest861");
  byte[][] VALUES=makeNAscii(VALUE,7);
  long[] STAMPS=makeStamps(7);
  Table ht=TEST_UTIL.createTable(TABLE,FAMILY,10);
  Put put=new Put(ROW);
  put.addColumn(FAMILY,QUALIFIER,STAMPS[3],VALUES[3]);
  put.addColumn(FAMILY,QUALIFIER,STAMPS[2],VALUES[2]);
  put.addColumn(FAMILY,QUALIFIER,STAMPS[4],VALUES[4]);
  ht.put(put);
  getVersionAndVerify(ht,ROW,FAMILY,QUALIFIER,STAMPS[2],VALUES[2]);
  getVersionAndVerifyMissing(ht,ROW,FAMILY,QUALIFIER,STAMPS[1]);
  getVersionAndVerifyMissing(ht,ROW,FAMILY,QUALIFIER,STAMPS[5]);
  TEST_UTIL.flush();
  getVersionAndVerify(ht,ROW,FAMILY,QUALIFIER,STAMPS[2],VALUES[2]);
  getVersionAndVerifyMissing(ht,ROW,FAMILY,QUALIFIER,STAMPS[1]);
  getVersionAndVerifyMissing(ht,ROW,FAMILY,QUALIFIER,STAMPS[5]);
  put=new Put(ROW);
  put.addColumn(FAMILY,QUALIFIER,STAMPS[0],VALUES[0]);
  put.addColumn(FAMILY,QUALIFIER,STAMPS[6],VALUES[6]);
  ht.put(put);
  getVersionAndVerify(ht,ROW,FAMILY,QUALIFIER,STAMPS[0],VALUES[0]);
  getVersionAndVerifyMissing(ht,ROW,FAMILY,QUALIFIER,STAMPS[1]);
  getVersionAndVerify(ht,ROW,FAMILY,QUALIFIER,STAMPS[2],VALUES[2]);
  getVersionAndVerify(ht,ROW,FAMILY,QUALIFIER,STAMPS[3],VALUES[3]);
  getVersionAndVerify(ht,ROW,FAMILY,QUALIFIER,STAMPS[4],VALUES[4]);
  getVersionAndVerifyMissing(ht,ROW,FAMILY,QUALIFIER,STAMPS[5]);
  getVersionAndVerify(ht,ROW,FAMILY,QUALIFIER,STAMPS[6],VALUES[6]);
  TEST_UTIL.flush();
  getVersionAndVerify(ht,ROW,FAMILY,QUALIFIER,STAMPS[0],VALUES[0]);
  getVersionAndVerifyMissing(ht,ROW,FAMILY,QUALIFIER,STAMPS[1]);
  getVersionAndVerify(ht,ROW,FAMILY,QUALIFIER,STAMPS[2],VALUES[2]);
  getVersionAndVerify(ht,ROW,FAMILY,QUALIFIER,STAMPS[3],VALUES[3]);
  getVersionAndVerify(ht,ROW,FAMILY,QUALIFIER,STAMPS[4],VALUES[4]);
  getVersionAndVerifyMissing(ht,ROW,FAMILY,QUALIFIER,STAMPS[5]);
  getVersionAndVerify(ht,ROW,FAMILY,QUALIFIER,STAMPS[6],VALUES[6]);
}

</code></pre>

<pre class="type-1 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * HBASE-33
 * Add a HTable get/obtainScanner method that retrieves all versions of a
 * particular column and row between two timestamps
 */
@Test public void testJiraTest33() throws Exception {
  TableName TABLE=TableName.valueOf("testJiraTest33");
  byte[][] VALUES=makeNAscii(VALUE,7);
  long[] STAMPS=makeStamps(7);
  Table ht=TEST_UTIL.createTable(TABLE,FAMILY,10);
  Put put=new Put(ROW);
  put.addColumn(FAMILY,QUALIFIER,STAMPS[0],VALUES[0]);
  put.addColumn(FAMILY,QUALIFIER,STAMPS[1],VALUES[1]);
  put.addColumn(FAMILY,QUALIFIER,STAMPS[2],VALUES[2]);
  put.addColumn(FAMILY,QUALIFIER,STAMPS[3],VALUES[3]);
  put.addColumn(FAMILY,QUALIFIER,STAMPS[4],VALUES[4]);
  put.addColumn(FAMILY,QUALIFIER,STAMPS[5],VALUES[5]);
  ht.put(put);
  getVersionRangeAndVerify(ht,ROW,FAMILY,QUALIFIER,STAMPS,VALUES,0,5);
  getVersionRangeAndVerify(ht,ROW,FAMILY,QUALIFIER,STAMPS,VALUES,0,2);
  getVersionRangeAndVerify(ht,ROW,FAMILY,QUALIFIER,STAMPS,VALUES,4,5);
  getVersionRangeAndVerify(ht,ROW,FAMILY,QUALIFIER,STAMPS,VALUES,2,3);
  scanVersionRangeAndVerify(ht,ROW,FAMILY,QUALIFIER,STAMPS,VALUES,0,5);
  scanVersionRangeAndVerify(ht,ROW,FAMILY,QUALIFIER,STAMPS,VALUES,0,2);
  scanVersionRangeAndVerify(ht,ROW,FAMILY,QUALIFIER,STAMPS,VALUES,4,5);
  scanVersionRangeAndVerify(ht,ROW,FAMILY,QUALIFIER,STAMPS,VALUES,2,3);
  TEST_UTIL.flush();
  getVersionRangeAndVerify(ht,ROW,FAMILY,QUALIFIER,STAMPS,VALUES,0,5);
  getVersionRangeAndVerify(ht,ROW,FAMILY,QUALIFIER,STAMPS,VALUES,0,2);
  getVersionRangeAndVerify(ht,ROW,FAMILY,QUALIFIER,STAMPS,VALUES,4,5);
  getVersionRangeAndVerify(ht,ROW,FAMILY,QUALIFIER,STAMPS,VALUES,2,3);
  scanVersionRangeAndVerify(ht,ROW,FAMILY,QUALIFIER,STAMPS,VALUES,0,5);
  scanVersionRangeAndVerify(ht,ROW,FAMILY,QUALIFIER,STAMPS,VALUES,0,2);
  scanVersionRangeAndVerify(ht,ROW,FAMILY,QUALIFIER,STAMPS,VALUES,4,5);
  scanVersionRangeAndVerify(ht,ROW,FAMILY,QUALIFIER,STAMPS,VALUES,2,3);
}

</code></pre>

<pre class="type-7 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
"></span><br>
@Test public void testGet_NullQualifier() throws IOException {
  Table table=TEST_UTIL.createTable(TableName.valueOf("testGet_NullQualifier"),FAMILY);
  Put put=new Put(ROW);
  put.addColumn(FAMILY,QUALIFIER,VALUE);
  table.put(put);
  put=new Put(ROW);
  put.addColumn(FAMILY,null,VALUE);
  table.put(put);
  LOG.info("Row put");
  Get get=new Get(ROW);
  get.addColumn(FAMILY,null);
  Result r=table.get(get);
  assertEquals(1,r.size());
  get=new Get(ROW);
  get.addFamily(FAMILY);
  r=table.get(get);
  assertEquals(2,r.size());
}

</code></pre>

<pre class="type-14 type-18 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Is an empty test case">EmptyTester</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Is not executed with the test suite">IgnoredMethod</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Is an empty test case
- Is not executed with the test suite
"></span><br>
@Ignore @Test public void testMultipleRegionsAndBatchPuts() throws Exception {
}

</code></pre>

<pre class="type-7 type-8 type-5 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testMiscHTableStuff() throws IOException {
  final TableName tableAname=TableName.valueOf("testMiscHTableStuffA");
  final TableName tableBname=TableName.valueOf("testMiscHTableStuffB");
  final byte[] attrName=Bytes.toBytes("TESTATTR");
  final byte[] attrValue=Bytes.toBytes("somevalue");
  byte[] value=Bytes.toBytes("value");
  Table a=TEST_UTIL.createTable(tableAname,HConstants.CATALOG_FAMILY);
  Table b=TEST_UTIL.createTable(tableBname,HConstants.CATALOG_FAMILY);
  Put put=new Put(ROW);
  put.addColumn(HConstants.CATALOG_FAMILY,null,value);
  a.put(put);
  Table newA=TEST_UTIL.getConnection().getTable(tableAname);
  Scan scan=new Scan();
  scan.addFamily(HConstants.CATALOG_FAMILY);
  ResultScanner s=newA.getScanner(scan);
  try {
    for (    Result r : s) {
      put=new Put(r.getRow());
      put.setDurability(Durability.SKIP_WAL);
      for (      Cell kv : r.rawCells()) {
        put.add(kv);
      }
      b.put(put);
    }
  }
  finally {
    s.close();
  }
  Table anotherA=TEST_UTIL.getConnection().getTable(tableAname);
  Get get=new Get(ROW);
  get.addFamily(HConstants.CATALOG_FAMILY);
  anotherA.get(get);
  Admin admin=TEST_UTIL.getHBaseAdmin();
  HTableDescriptor desc=new HTableDescriptor(a.getTableDescriptor());
  admin.disableTable(tableAname);
  desc.setValue(attrName,attrValue);
  for (  HColumnDescriptor c : desc.getFamilies())   c.setValue(attrName,attrValue);
  admin.modifyTable(tableAname,desc);
  admin.enableTable(tableAname);
  desc=a.getTableDescriptor();
  assertEquals("wrong table descriptor returned",desc.getTableName(),tableAname);
  value=desc.getValue(attrName);
  assertFalse("missing HTD attribute value",value == null);
  assertFalse("HTD attribute value is incorrect",Bytes.compareTo(value,attrValue) != 0);
  for (  HColumnDescriptor c : desc.getFamilies()) {
    value=c.getValue(attrName);
    assertFalse("missing HCD attribute value",value == null);
    assertFalse("HCD attribute value is incorrect",Bytes.compareTo(value,attrValue) != 0);
  }
}

</code></pre>

<pre class="type-1 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Test simple table and non-existent row cases.
 */
@Test public void testSimpleMissingWithReverseScan() throws Exception {
  TableName TABLE=TableName.valueOf("testSimpleMissingWithReverseScan");
  Table ht=TEST_UTIL.createTable(TABLE,FAMILY);
  byte[][] ROWS=makeN(ROW,4);
  Scan scan=new Scan();
  scan.setReversed(true);
  Result result=getSingleScanResult(ht,scan);
  assertNullResult(result);
  scan=new Scan(ROWS[0]);
  scan.setReversed(true);
  result=getSingleScanResult(ht,scan);
  assertNullResult(result);
  scan=new Scan(ROWS[0],ROWS[1]);
  scan.setReversed(true);
  result=getSingleScanResult(ht,scan);
  assertNullResult(result);
  scan=new Scan();
  scan.setReversed(true);
  scan.addFamily(FAMILY);
  result=getSingleScanResult(ht,scan);
  assertNullResult(result);
  scan=new Scan();
  scan.setReversed(true);
  scan.addColumn(FAMILY,QUALIFIER);
  result=getSingleScanResult(ht,scan);
  assertNullResult(result);
  Put put=new Put(ROWS[2]);
  put.addColumn(FAMILY,QUALIFIER,VALUE);
  ht.put(put);
  scan=new Scan();
  scan.setReversed(true);
  result=getSingleScanResult(ht,scan);
  assertSingleResult(result,ROWS[2],FAMILY,QUALIFIER,VALUE);
  scan=new Scan(ROWS[3],ROWS[0]);
  scan.setReversed(true);
  result=getSingleScanResult(ht,scan);
  assertSingleResult(result,ROWS[2],FAMILY,QUALIFIER,VALUE);
  scan=new Scan(ROWS[2],ROWS[1]);
  scan.setReversed(true);
  result=getSingleScanResult(ht,scan);
  assertSingleResult(result,ROWS[2],FAMILY,QUALIFIER,VALUE);
  scan=new Scan(ROWS[1]);
  scan.setReversed(true);
  result=getSingleScanResult(ht,scan);
  assertNullResult(result);
  ht.close();
}

</code></pre>

<pre class="type-3 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Releases resources used by the test cases">TestCleaner</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Releases resources used by the test cases
"></span><br>
/** 
 * @throws java.lang.Exception
 */
@AfterClass public static void tearDownAfterClass() throws Exception {
  TEST_UTIL.shutdownMiniCluster();
}

</code></pre>

<pre class="type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies whether objects/variable are equal to an expected value 
"></span><br>
@Test public void testAddKeyValue() throws IOException {
  final byte[] CONTENTS_FAMILY=Bytes.toBytes("contents");
  final byte[] value=Bytes.toBytes("abcd");
  final byte[] row1=Bytes.toBytes("row1");
  final byte[] row2=Bytes.toBytes("row2");
  byte[] qualifier=Bytes.toBytes("qf1");
  Put put=new Put(row1);
  KeyValue kv=new KeyValue(row1,CONTENTS_FAMILY,qualifier,value);
  boolean ok=true;
  try {
    put.add(kv);
  }
 catch (  IOException e) {
    ok=false;
  }
  assertEquals(true,ok);
  kv=new KeyValue(row2,CONTENTS_FAMILY,qualifier,value);
  ok=false;
  try {
    put.add(kv);
  }
 catch (  IOException e) {
    ok=true;
  }
  assertEquals(true,ok);
}

</code></pre>

<pre class="type-14 type-18 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Is an empty test case">EmptyTester</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Is not executed with the test suite">IgnoredMethod</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Is an empty test case
- Is not executed with the test suite
"></span><br>
@Ignore @Test public void testMultipleRowMultipleFamily() throws Exception {
}

</code></pre>

<pre class="type-4 type-7 type-8 type-5 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Basic client side validation of HBASE-4536
 */
@Test public void testKeepDeletedCells() throws Exception {
  final TableName TABLENAME=TableName.valueOf("testKeepDeletesCells");
  final byte[] FAMILY=Bytes.toBytes("family");
  final byte[] C0=Bytes.toBytes("c0");
  final byte[] T1=Bytes.toBytes("T1");
  final byte[] T2=Bytes.toBytes("T2");
  final byte[] T3=Bytes.toBytes("T3");
  HColumnDescriptor hcd=new HColumnDescriptor(FAMILY).setKeepDeletedCells(KeepDeletedCells.TRUE).setDataBlockEncoding(DataBlockEncoding.PREFIX_TREE).setMaxVersions(3);
  HTableDescriptor desc=new HTableDescriptor(TABLENAME);
  desc.addFamily(hcd);
  TEST_UTIL.getHBaseAdmin().createTable(desc);
  Table h=TEST_UTIL.getConnection().getTable(TABLENAME);
  long ts=System.currentTimeMillis();
  Put p=new Put(T1,ts);
  p.addColumn(FAMILY,C0,T1);
  h.put(p);
  p=new Put(T1,ts + 2);
  p.addColumn(FAMILY,C0,T2);
  h.put(p);
  p=new Put(T1,ts + 4);
  p.addColumn(FAMILY,C0,T3);
  h.put(p);
  Delete d=new Delete(T1,ts + 3);
  h.delete(d);
  d=new Delete(T1,ts + 3);
  d.addColumns(FAMILY,C0,ts + 3);
  h.delete(d);
  Get g=new Get(T1);
  g.setTimeRange(0,ts + 3);
  Result r=h.get(g);
  assertArrayEquals(T2,r.getValue(FAMILY,C0));
  Scan s=new Scan(T1);
  s.setTimeRange(0,ts + 3);
  s.setMaxVersions();
  ResultScanner scanner=h.getScanner(s);
  Cell[] kvs=scanner.next().rawCells();
  assertArrayEquals(T2,CellUtil.cloneValue(kvs[0]));
  assertArrayEquals(T1,CellUtil.cloneValue(kvs[1]));
  scanner.close();
  s=new Scan(T1);
  s.setRaw(true);
  s.setMaxVersions();
  scanner=h.getScanner(s);
  kvs=scanner.next().rawCells();
  assertTrue(CellUtil.isDeleteFamily(kvs[0]));
  assertArrayEquals(T3,CellUtil.cloneValue(kvs[1]));
  assertTrue(CellUtil.isDelete(kvs[2]));
  assertArrayEquals(T2,CellUtil.cloneValue(kvs[3]));
  assertArrayEquals(T1,CellUtil.cloneValue(kvs[4]));
  scanner.close();
  h.close();
}

</code></pre>

<pre class="type-4 type-10 type-7 type-8 type-5 type-12 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values related to public fields.">PublicFieldVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions inside branch conditions
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Verifies values related to public fields.
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Tests reversed scan under multi regions
 */
@Test public void testReversedScanUnderMultiRegions() throws Exception {
  TableName TABLE=TableName.valueOf("testReversedScanUnderMultiRegions");
  byte[] maxByteArray=ReversedClientScanner.MAX_BYTE_ARRAY;
  byte[][] splitRows=new byte[][]{Bytes.toBytes("005"),Bytes.add(Bytes.toBytes("005"),Bytes.multiple(maxByteArray,16)),Bytes.toBytes("006"),Bytes.add(Bytes.toBytes("006"),Bytes.multiple(maxByteArray,8)),Bytes.toBytes("007"),Bytes.add(Bytes.toBytes("007"),Bytes.multiple(maxByteArray,4)),Bytes.toBytes("008"),Bytes.multiple(maxByteArray,2)};
  Table table=TEST_UTIL.createTable(TABLE,FAMILY,splitRows);
  TEST_UTIL.waitUntilAllRegionsAssigned(table.getName());
  try (RegionLocator l=TEST_UTIL.getConnection().getRegionLocator(TABLE)){
    assertEquals(splitRows.length + 1,l.getAllRegionLocations().size());
  }
   int insertNum=splitRows.length;
  for (int i=0; i < insertNum; i++) {
    Put put=new Put(splitRows[i]);
    put.addColumn(FAMILY,QUALIFIER,VALUE);
    table.put(put);
  }
  ResultScanner scanner=table.getScanner(new Scan());
  int count=0;
  for (  Result r : scanner) {
    assertTrue(!r.isEmpty());
    count++;
  }
  assertEquals(insertNum,count);
  Scan scan=new Scan();
  scan.setReversed(true);
  scanner=table.getScanner(scan);
  count=0;
  byte[] lastRow=null;
  for (  Result r : scanner) {
    assertTrue(!r.isEmpty());
    count++;
    byte[] thisRow=r.getRow();
    if (lastRow != null) {
      assertTrue("Error scan order, last row= " + Bytes.toString(lastRow) + ",this row="+ Bytes.toString(thisRow),Bytes.compareTo(thisRow,lastRow) < 0);
    }
    lastRow=thisRow;
  }
  assertEquals(insertNum,count);
  table.close();
}

</code></pre>

<pre class="type-10 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions inside branch conditions
- Verifies whether objects/variable are equal to an expected value 
"></span><br>
@Test public void testRowsPutBufferedOneFlush() throws IOException {
  final byte[] CONTENTS_FAMILY=Bytes.toBytes("contents");
  final byte[] SMALL_FAMILY=Bytes.toBytes("smallfam");
  final byte[] value=Bytes.toBytes("abcd");
  final int NB_BATCH_ROWS=10;
  Table t=TEST_UTIL.createTable(TableName.valueOf("testRowsPutBufferedOneFlush"),new byte[][]{CONTENTS_FAMILY,SMALL_FAMILY});
  if (t instanceof HTableInterface) {
    HTable table=(HTable)t;
    table.setAutoFlushTo(false);
    ArrayList<Put> rowsUpdate=new ArrayList<Put>();
    for (int i=0; i < NB_BATCH_ROWS * 10; i++) {
      byte[] row=Bytes.toBytes("row" + i);
      Put put=new Put(row);
      put.setDurability(Durability.SKIP_WAL);
      put.addColumn(CONTENTS_FAMILY,null,value);
      rowsUpdate.add(put);
    }
    table.put(rowsUpdate);
    Scan scan=new Scan();
    scan.addFamily(CONTENTS_FAMILY);
    ResultScanner scanner=table.getScanner(scan);
    int nbRows=0;
    for (    @SuppressWarnings("unused") Result row : scanner)     nbRows++;
    assertEquals(0,nbRows);
    scanner.close();
    table.flushCommits();
    scan=new Scan();
    scan.addFamily(CONTENTS_FAMILY);
    scanner=table.getScanner(scan);
    nbRows=0;
    for (    @SuppressWarnings("unused") Result row : scanner)     nbRows++;
    assertEquals(NB_BATCH_ROWS * 10,nbRows);
    table.close();
  }
}

</code></pre>

<pre class="type-4 type-7 type-8 type-5 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testFilters() throws Exception {
  TableName TABLE=TableName.valueOf("testFilters");
  Table ht=TEST_UTIL.createTable(TABLE,FAMILY);
  byte[][] ROWS=makeN(ROW,10);
  byte[][] QUALIFIERS={Bytes.toBytes("col0-<d2v1>-<d3v2>"),Bytes.toBytes("col1-<d2v1>-<d3v2>"),Bytes.toBytes("col2-<d2v1>-<d3v2>"),Bytes.toBytes("col3-<d2v1>-<d3v2>"),Bytes.toBytes("col4-<d2v1>-<d3v2>"),Bytes.toBytes("col5-<d2v1>-<d3v2>"),Bytes.toBytes("col6-<d2v1>-<d3v2>"),Bytes.toBytes("col7-<d2v1>-<d3v2>"),Bytes.toBytes("col8-<d2v1>-<d3v2>"),Bytes.toBytes("col9-<d2v1>-<d3v2>")};
  for (int i=0; i < 10; i++) {
    Put put=new Put(ROWS[i]);
    put.setDurability(Durability.SKIP_WAL);
    put.addColumn(FAMILY,QUALIFIERS[i],VALUE);
    ht.put(put);
  }
  Scan scan=new Scan();
  scan.addFamily(FAMILY);
  Filter filter=new QualifierFilter(CompareOp.EQUAL,new RegexStringComparator("col[1-5]"));
  scan.setFilter(filter);
  ResultScanner scanner=ht.getScanner(scan);
  int expectedIndex=1;
  for (  Result result : ht.getScanner(scan)) {
    assertEquals(result.size(),1);
    assertTrue(Bytes.equals(CellUtil.cloneRow(result.rawCells()[0]),ROWS[expectedIndex]));
    assertTrue(Bytes.equals(CellUtil.cloneQualifier(result.rawCells()[0]),QUALIFIERS[expectedIndex]));
    expectedIndex++;
  }
  assertEquals(expectedIndex,6);
  scanner.close();
}

</code></pre>

<pre class="type-1 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test public void testNullWithReverseScan() throws Exception {
  TableName TABLE=TableName.valueOf("testNullWithReverseScan");
  Table ht=TEST_UTIL.createTable(TABLE,FAMILY);
  Put put=new Put(ROW);
  put.addColumn(FAMILY,null,VALUE);
  ht.put(put);
  scanTestNull(ht,ROW,FAMILY,VALUE,true);
  Delete delete=new Delete(ROW);
  delete.addColumns(FAMILY,null);
  ht.delete(delete);
  byte[] TABLE2=Bytes.toBytes("testNull2WithReverseScan");
  ht=TEST_UTIL.createTable(TableName.valueOf(TABLE2),FAMILY);
  put=new Put(ROW);
  put.addColumn(FAMILY,HConstants.EMPTY_BYTE_ARRAY,VALUE);
  ht.put(put);
  scanTestNull(ht,ROW,FAMILY,VALUE,true);
  TEST_UTIL.flush();
  scanTestNull(ht,ROW,FAMILY,VALUE,true);
  delete=new Delete(ROW);
  delete.addColumns(FAMILY,HConstants.EMPTY_BYTE_ARRAY);
  ht.delete(delete);
  put=new Put(ROW);
  put.addColumn(FAMILY,QUALIFIER,null);
  ht.put(put);
  Scan scan=new Scan();
  scan.setReversed(true);
  scan.addColumn(FAMILY,QUALIFIER);
  Result result=getSingleScanResult(ht,scan);
  assertSingleResult(result,ROW,FAMILY,QUALIFIER,null);
  ht.close();
}

</code></pre>

<pre class="type-4 type-7 type-8 type-5 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Tests that cache on write works all the way up from the client-side.
 * Performs inserts, flushes, and compactions, verifying changes in the block
 * cache along the way.
 * @throws Exception
 */
@Test public void testCacheOnWriteEvictOnClose() throws Exception {
  TableName tableName=TableName.valueOf("testCOWEOCfromClient");
  byte[] data=Bytes.toBytes("data");
  Table table=TEST_UTIL.createTable(tableName,FAMILY);
  try (RegionLocator locator=TEST_UTIL.getConnection().getRegionLocator(tableName)){
    String regionName=locator.getAllRegionLocations().get(0).getRegionInfo().getEncodedName();
    Region region=TEST_UTIL.getRSForFirstRegionInTable(tableName).getFromOnlineRegions(regionName);
    Store store=region.getStores().iterator().next();
    CacheConfig cacheConf=store.getCacheConfig();
    cacheConf.setCacheDataOnWrite(true);
    cacheConf.setEvictOnClose(true);
    BlockCache cache=cacheConf.getBlockCache();
    long startBlockCount=cache.getBlockCount();
    long startBlockHits=cache.getStats().getHitCount();
    long startBlockMiss=cache.getStats().getMissCount();
    for (int i=0; i < 5; i++) {
      Thread.sleep(100);
      if (startBlockCount != cache.getBlockCount() || startBlockHits != cache.getStats().getHitCount() || startBlockMiss != cache.getStats().getMissCount()) {
        startBlockCount=cache.getBlockCount();
        startBlockHits=cache.getStats().getHitCount();
        startBlockMiss=cache.getStats().getMissCount();
        i=-1;
      }
    }
    Put put=new Put(ROW);
    put.addColumn(FAMILY,QUALIFIER,data);
    table.put(put);
    assertTrue(Bytes.equals(table.get(new Get(ROW)).value(),data));
    assertEquals(startBlockCount,cache.getBlockCount());
    assertEquals(startBlockHits,cache.getStats().getHitCount());
    assertEquals(startBlockMiss,cache.getStats().getMissCount());
    System.out.println("Flushing cache");
    region.flush(true);
    long expectedBlockCount=startBlockCount + 1;
    long expectedBlockHits=startBlockHits;
    long expectedBlockMiss=startBlockMiss;
    assertEquals(expectedBlockCount,cache.getBlockCount());
    assertEquals(expectedBlockHits,cache.getStats().getHitCount());
    assertEquals(expectedBlockMiss,cache.getStats().getMissCount());
    assertTrue(Bytes.equals(table.get(new Get(ROW)).value(),data));
    assertEquals(expectedBlockCount,cache.getBlockCount());
    assertEquals(++expectedBlockHits,cache.getStats().getHitCount());
    assertEquals(expectedBlockMiss,cache.getStats().getMissCount());
    byte[] QUALIFIER2=Bytes.add(QUALIFIER,QUALIFIER);
    byte[] data2=Bytes.add(data,data);
    put=new Put(ROW);
    put.addColumn(FAMILY,QUALIFIER2,data2);
    table.put(put);
    Result r=table.get(new Get(ROW));
    assertTrue(Bytes.equals(r.getValue(FAMILY,QUALIFIER),data));
    assertTrue(Bytes.equals(r.getValue(FAMILY,QUALIFIER2),data2));
    assertEquals(expectedBlockCount,cache.getBlockCount());
    assertEquals(++expectedBlockHits,cache.getStats().getHitCount());
    assertEquals(expectedBlockMiss,cache.getStats().getMissCount());
    System.out.println("Flushing cache");
    region.flush(true);
    assertEquals(++expectedBlockCount,cache.getBlockCount());
    assertEquals(expectedBlockHits,cache.getStats().getHitCount());
    assertEquals(expectedBlockMiss,cache.getStats().getMissCount());
    System.out.println("Compacting");
    assertEquals(2,store.getStorefilesCount());
    store.triggerMajorCompaction();
    region.compact(true);
    waitForStoreFileCount(store,1,10000);
    assertEquals(1,store.getStorefilesCount());
    expectedBlockCount-=2;
    assertEquals(expectedBlockCount,cache.getBlockCount());
    expectedBlockHits+=2;
    assertEquals(expectedBlockMiss,cache.getStats().getMissCount());
    assertEquals(expectedBlockHits,cache.getStats().getHitCount());
    r=table.get(new Get(ROW));
    assertTrue(Bytes.equals(r.getValue(FAMILY,QUALIFIER),data));
    assertTrue(Bytes.equals(r.getValue(FAMILY,QUALIFIER2),data2));
    expectedBlockCount+=1;
    assertEquals(expectedBlockCount,cache.getBlockCount());
    assertEquals(expectedBlockHits,cache.getStats().getHitCount());
    assertEquals(++expectedBlockMiss,cache.getStats().getMissCount());
  }
 }

</code></pre>

<pre class="type-11 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testNull() throws Exception {
  TableName TABLE=TableName.valueOf("testNull");
  try {
    TEST_UTIL.createTable((TableName)null,FAMILY);
    fail("Creating a table with null name passed, should have failed");
  }
 catch (  Exception e) {
  }
  try {
    TEST_UTIL.createTable(TABLE,new byte[][]{(byte[])null});
    fail("Creating a table with a null family passed, should fail");
  }
 catch (  Exception e) {
  }
  Table ht=TEST_UTIL.createTable(TABLE,FAMILY);
  try {
    Put put=new Put((byte[])null);
    put.addColumn(FAMILY,QUALIFIER,VALUE);
    ht.put(put);
    fail("Inserting a null row worked, should throw exception");
  }
 catch (  Exception e) {
  }
{
    Put put=new Put(ROW);
    put.addColumn(FAMILY,null,VALUE);
    ht.put(put);
    getTestNull(ht,ROW,FAMILY,VALUE);
    scanTestNull(ht,ROW,FAMILY,VALUE);
    Delete delete=new Delete(ROW);
    delete.addColumns(FAMILY,null);
    ht.delete(delete);
    Get get=new Get(ROW);
    Result result=ht.get(get);
    assertEmptyResult(result);
  }
  byte[] TABLE2=Bytes.toBytes("testNull2");
  ht=TEST_UTIL.createTable(TableName.valueOf(TABLE2),FAMILY);
  try {
    Put put=new Put(ROW);
    put.addColumn(FAMILY,HConstants.EMPTY_BYTE_ARRAY,VALUE);
    ht.put(put);
    getTestNull(ht,ROW,FAMILY,VALUE);
    scanTestNull(ht,ROW,FAMILY,VALUE);
    TEST_UTIL.flush();
    getTestNull(ht,ROW,FAMILY,VALUE);
    scanTestNull(ht,ROW,FAMILY,VALUE);
    Delete delete=new Delete(ROW);
    delete.addColumns(FAMILY,HConstants.EMPTY_BYTE_ARRAY);
    ht.delete(delete);
    Get get=new Get(ROW);
    Result result=ht.get(get);
    assertEmptyResult(result);
  }
 catch (  Exception e) {
    throw new IOException("Using a row with null qualifier threw exception, should ");
  }
  try {
    Put put=new Put(ROW);
    put.addColumn(FAMILY,QUALIFIER,null);
    ht.put(put);
    Get get=new Get(ROW);
    get.addColumn(FAMILY,QUALIFIER);
    Result result=ht.get(get);
    assertSingleResult(result,ROW,FAMILY,QUALIFIER,null);
    Scan scan=new Scan();
    scan.addColumn(FAMILY,QUALIFIER);
    result=getSingleScanResult(ht,scan);
    assertSingleResult(result,ROW,FAMILY,QUALIFIER,null);
    Delete delete=new Delete(ROW);
    delete.addColumns(FAMILY,QUALIFIER);
    ht.delete(delete);
    get=new Get(ROW);
    result=ht.get(get);
    assertEmptyResult(result);
  }
 catch (  Exception e) {
    throw new IOException("Null values should be allowed, but threw exception");
  }
}

</code></pre>

<pre class="type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies whether objects/variable are equal to an expected value 
"></span><br>
@Test public void testRowsPut() throws IOException {
  final byte[] CONTENTS_FAMILY=Bytes.toBytes("contents");
  final byte[] SMALL_FAMILY=Bytes.toBytes("smallfam");
  final int NB_BATCH_ROWS=10;
  final byte[] value=Bytes.toBytes("abcd");
  Table table=TEST_UTIL.createTable(TableName.valueOf("testRowsPut"),new byte[][]{CONTENTS_FAMILY,SMALL_FAMILY});
  ArrayList<Put> rowsUpdate=new ArrayList<Put>();
  for (int i=0; i < NB_BATCH_ROWS; i++) {
    byte[] row=Bytes.toBytes("row" + i);
    Put put=new Put(row);
    put.setDurability(Durability.SKIP_WAL);
    put.addColumn(CONTENTS_FAMILY,null,value);
    rowsUpdate.add(put);
  }
  table.put(rowsUpdate);
  Scan scan=new Scan();
  scan.addFamily(CONTENTS_FAMILY);
  ResultScanner scanner=table.getScanner(scan);
  int nbRows=0;
  for (  @SuppressWarnings("unused") Result row : scanner)   nbRows++;
  assertEquals(NB_BATCH_ROWS,nbRows);
}

</code></pre>

<pre class="type-7 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
"></span><br>
@Test public void testJira6912() throws Exception {
  TableName TABLE=TableName.valueOf("testJira6912");
  Table foo=TEST_UTIL.createTable(TABLE,new byte[][]{FAMILY},10);
  List<Put> puts=new ArrayList<Put>();
  for (int i=0; i != 100; i++) {
    Put put=new Put(Bytes.toBytes(i));
    put.addColumn(FAMILY,FAMILY,Bytes.toBytes(i));
    puts.add(put);
  }
  foo.put(puts);
  TEST_UTIL.flush();
  Scan scan=new Scan();
  scan.setStartRow(Bytes.toBytes(1));
  scan.setStopRow(Bytes.toBytes(3));
  scan.addColumn(FAMILY,FAMILY);
  scan.setFilter(new RowFilter(CompareFilter.CompareOp.NOT_EQUAL,new BinaryComparator(Bytes.toBytes(1))));
  ResultScanner scanner=foo.getScanner(scan);
  Result[] bar=scanner.next(100);
  assertEquals(1,bar.length);
}

</code></pre>

<pre class="type-1 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * HBASE-52
 * Add a means of scanning over all versions
 */
@Test public void testJiraTest52() throws Exception {
  TableName TABLE=TableName.valueOf("testJiraTest52");
  byte[][] VALUES=makeNAscii(VALUE,7);
  long[] STAMPS=makeStamps(7);
  Table ht=TEST_UTIL.createTable(TABLE,FAMILY,10);
  Put put=new Put(ROW);
  put.addColumn(FAMILY,QUALIFIER,STAMPS[0],VALUES[0]);
  put.addColumn(FAMILY,QUALIFIER,STAMPS[1],VALUES[1]);
  put.addColumn(FAMILY,QUALIFIER,STAMPS[2],VALUES[2]);
  put.addColumn(FAMILY,QUALIFIER,STAMPS[3],VALUES[3]);
  put.addColumn(FAMILY,QUALIFIER,STAMPS[4],VALUES[4]);
  put.addColumn(FAMILY,QUALIFIER,STAMPS[5],VALUES[5]);
  ht.put(put);
  getAllVersionsAndVerify(ht,ROW,FAMILY,QUALIFIER,STAMPS,VALUES,0,5);
  scanAllVersionsAndVerify(ht,ROW,FAMILY,QUALIFIER,STAMPS,VALUES,0,5);
  TEST_UTIL.flush();
  getAllVersionsAndVerify(ht,ROW,FAMILY,QUALIFIER,STAMPS,VALUES,0,5);
  scanAllVersionsAndVerify(ht,ROW,FAMILY,QUALIFIER,STAMPS,VALUES,0,5);
}

</code></pre>

<pre class="type-4 type-9 type-7 type-8 type-5 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions in iterations
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testClientPoolRoundRobin() throws IOException {
  final TableName tableName=TableName.valueOf("testClientPoolRoundRobin");
  int poolSize=3;
  int numVersions=poolSize * 2;
  Configuration conf=TEST_UTIL.getConfiguration();
  conf.set(HConstants.HBASE_CLIENT_IPC_POOL_TYPE,"round-robin");
  conf.setInt(HConstants.HBASE_CLIENT_IPC_POOL_SIZE,poolSize);
  Table table=TEST_UTIL.createTable(tableName,new byte[][]{FAMILY},Integer.MAX_VALUE);
  final long ts=EnvironmentEdgeManager.currentTime();
  Get get=new Get(ROW);
  get.addColumn(FAMILY,QUALIFIER);
  get.setMaxVersions();
  for (int versions=1; versions <= numVersions; versions++) {
    Put put=new Put(ROW);
    put.addColumn(FAMILY,QUALIFIER,ts + versions,VALUE);
    table.put(put);
    Result result=table.get(get);
    NavigableMap<Long,byte[]> navigableMap=result.getMap().get(FAMILY).get(QUALIFIER);
    assertEquals("The number of versions of '" + FAMILY + ":"+ QUALIFIER+ " did not match "+ versions,versions,navigableMap.size());
    for (    Map.Entry<Long,byte[]> entry : navigableMap.entrySet()) {
      assertTrue("The value at time " + entry.getKey() + " did not match what was put",Bytes.equals(VALUE,entry.getValue()));
    }
  }
}

</code></pre>

<pre class="type-11 type-7 type-13 type-5 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testRowMutation() throws Exception {
  LOG.info("Starting testRowMutation");
  final TableName TABLENAME=TableName.valueOf("testRowMutation");
  Table t=TEST_UTIL.createTable(TABLENAME,FAMILY);
  byte[][] QUALIFIERS=new byte[][]{Bytes.toBytes("a"),Bytes.toBytes("b")};
  RowMutations arm=new RowMutations(ROW);
  Put p=new Put(ROW);
  p.addColumn(FAMILY,QUALIFIERS[0],VALUE);
  arm.add(p);
  t.mutateRow(arm);
  Get g=new Get(ROW);
  Result r=t.get(g);
  assertEquals(0,Bytes.compareTo(VALUE,r.getValue(FAMILY,QUALIFIERS[0])));
  arm=new RowMutations(ROW);
  p=new Put(ROW);
  p.addColumn(FAMILY,QUALIFIERS[1],VALUE);
  arm.add(p);
  Delete d=new Delete(ROW);
  d.addColumns(FAMILY,QUALIFIERS[0]);
  arm.add(d);
  t.mutateRow(arm);
  r=t.get(g);
  assertEquals(0,Bytes.compareTo(VALUE,r.getValue(FAMILY,QUALIFIERS[1])));
  assertNull(r.getValue(FAMILY,QUALIFIERS[0]));
  try {
    arm=new RowMutations(ROW);
    p=new Put(ROW);
    p.addColumn(new byte[]{'b','o','g','u','s'},QUALIFIERS[0],VALUE);
    arm.add(p);
    t.mutateRow(arm);
    fail("Expected NoSuchColumnFamilyException");
  }
 catch (  NoSuchColumnFamilyException e) {
  }
}

</code></pre>

<pre class="type-4 type-9 type-7 type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions in iterations
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
"></span><br>
/** 
 * HBASE-867
 * If millions of columns in a column family, hbase scanner won't come up
 * Test will create numRows rows, each with numColsPerRow columns
 * (1 version each), and attempt to scan them all.
 * To test at scale, up numColsPerRow to the millions
 * (have not gotten that to work running as junit though)
 */
@Test public void testJiraTest867() throws Exception {
  int numRows=10;
  int numColsPerRow=2000;
  TableName TABLE=TableName.valueOf("testJiraTest867");
  byte[][] ROWS=makeN(ROW,numRows);
  byte[][] QUALIFIERS=makeN(QUALIFIER,numColsPerRow);
  Table ht=TEST_UTIL.createTable(TABLE,FAMILY);
  for (int i=0; i < numRows; i++) {
    Put put=new Put(ROWS[i]);
    put.setDurability(Durability.SKIP_WAL);
    for (int j=0; j < numColsPerRow; j++) {
      put.addColumn(FAMILY,QUALIFIERS[j],QUALIFIERS[j]);
    }
    assertTrue("Put expected to contain " + numColsPerRow + " columns but "+ "only contains "+ put.size(),put.size() == numColsPerRow);
    ht.put(put);
  }
  Get get=new Get(ROWS[numRows - 1]);
  Result result=ht.get(get);
  assertNumKeys(result,numColsPerRow);
  Cell[] keys=result.rawCells();
  for (int i=0; i < result.size(); i++) {
    assertKey(keys[i],ROWS[numRows - 1],FAMILY,QUALIFIERS[i],QUALIFIERS[i]);
  }
  Scan scan=new Scan();
  ResultScanner scanner=ht.getScanner(scan);
  int rowCount=0;
  while ((result=scanner.next()) != null) {
    assertNumKeys(result,numColsPerRow);
    Cell[] kvs=result.rawCells();
    for (int i=0; i < numColsPerRow; i++) {
      assertKey(kvs[i],ROWS[rowCount],FAMILY,QUALIFIERS[i],QUALIFIERS[i]);
    }
    rowCount++;
  }
  scanner.close();
  assertTrue("Expected to scan " + numRows + " rows but actually scanned "+ rowCount+ " rows",rowCount == numRows);
  TEST_UTIL.flush();
  get=new Get(ROWS[numRows - 1]);
  result=ht.get(get);
  assertNumKeys(result,numColsPerRow);
  keys=result.rawCells();
  for (int i=0; i < result.size(); i++) {
    assertKey(keys[i],ROWS[numRows - 1],FAMILY,QUALIFIERS[i],QUALIFIERS[i]);
  }
  scan=new Scan();
  scanner=ht.getScanner(scan);
  rowCount=0;
  while ((result=scanner.next()) != null) {
    assertNumKeys(result,numColsPerRow);
    Cell[] kvs=result.rawCells();
    for (int i=0; i < numColsPerRow; i++) {
      assertKey(kvs[i],ROWS[rowCount],FAMILY,QUALIFIERS[i],QUALIFIERS[i]);
    }
    rowCount++;
  }
  scanner.close();
  assertTrue("Expected to scan " + numRows + " rows but actually scanned "+ rowCount+ " rows",rowCount == numRows);
}

</code></pre>

<pre class="type-7 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
"></span><br>
@Test public void testScan_NullQualifier() throws IOException {
  Table table=TEST_UTIL.createTable(TableName.valueOf("testScan_NullQualifier"),FAMILY);
  Put put=new Put(ROW);
  put.addColumn(FAMILY,QUALIFIER,VALUE);
  table.put(put);
  put=new Put(ROW);
  put.addColumn(FAMILY,null,VALUE);
  table.put(put);
  LOG.info("Row put");
  Scan scan=new Scan();
  scan.addColumn(FAMILY,null);
  ResultScanner scanner=table.getScanner(scan);
  Result[] bar=scanner.next(100);
  assertEquals(1,bar.length);
  assertEquals(1,bar[0].size());
  scan=new Scan();
  scan.addFamily(FAMILY);
  scanner=table.getScanner(scan);
  bar=scanner.next(100);
  assertEquals(1,bar.length);
  assertEquals(2,bar[0].size());
}

</code></pre>

<pre class="type-11 type-8 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testNegativeTimestamp() throws IOException {
  Table table=TEST_UTIL.createTable(TableName.valueOf("testNegativeTimestamp"),FAMILY);
  try {
    Put put=new Put(ROW,-1);
    put.addColumn(FAMILY,QUALIFIER,VALUE);
    table.put(put);
    fail("Negative timestamps should not have been allowed");
  }
 catch (  IllegalArgumentException ex) {
    assertTrue(ex.getMessage().contains("negative"));
  }
  try {
    Put put=new Put(ROW);
    long ts=-1;
    put.addColumn(FAMILY,QUALIFIER,ts,VALUE);
    table.put(put);
    fail("Negative timestamps should not have been allowed");
  }
 catch (  IllegalArgumentException ex) {
    assertTrue(ex.getMessage().contains("negative"));
  }
  try {
    Delete delete=new Delete(ROW,-1);
    table.delete(delete);
    fail("Negative timestamps should not have been allowed");
  }
 catch (  IllegalArgumentException ex) {
    assertTrue(ex.getMessage().contains("negative"));
  }
  try {
    Delete delete=new Delete(ROW);
    delete.addFamily(FAMILY,-1);
    table.delete(delete);
    fail("Negative timestamps should not have been allowed");
  }
 catch (  IllegalArgumentException ex) {
    assertTrue(ex.getMessage().contains("negative"));
  }
  try {
    Scan scan=new Scan();
    scan.setTimeRange(-1,1);
    table.getScanner(scan);
    fail("Negative timestamps should not have been allowed");
  }
 catch (  IllegalArgumentException ex) {
    assertTrue(ex.getMessage().contains("negative"));
  }
  try {
    new KeyValue(Bytes.toBytes(42),Bytes.toBytes(42),Bytes.toBytes(42),-1,Bytes.toBytes(42));
  }
 catch (  IllegalArgumentException ex) {
    fail("KeyValue SHOULD allow negative timestamps");
  }
  table.close();
}

</code></pre>

<pre class="type-4 type-7 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
"></span><br>
@Test public void testUpdates() throws Exception {
  TableName TABLE=TableName.valueOf("testUpdates");
  Table hTable=TEST_UTIL.createTable(TABLE,FAMILY,10);
  byte[] row=Bytes.toBytes("row1");
  byte[] qualifier=Bytes.toBytes("myCol");
  Put put=new Put(row);
  put.addColumn(FAMILY,qualifier,1L,Bytes.toBytes("AAA"));
  hTable.put(put);
  put=new Put(row);
  put.addColumn(FAMILY,qualifier,2L,Bytes.toBytes("BBB"));
  hTable.put(put);
  put=new Put(row);
  put.addColumn(FAMILY,qualifier,3L,Bytes.toBytes("EEE"));
  hTable.put(put);
  Get get=new Get(row);
  get.addColumn(FAMILY,qualifier);
  get.setMaxVersions();
  Result result=hTable.get(get);
  NavigableMap<Long,byte[]> navigableMap=result.getMap().get(FAMILY).get(qualifier);
  assertEquals("AAA",Bytes.toString(navigableMap.get(1L)));
  assertEquals("BBB",Bytes.toString(navigableMap.get(2L)));
  put=new Put(row);
  put.addColumn(FAMILY,qualifier,1L,Bytes.toBytes("CCC"));
  hTable.put(put);
  put=new Put(row);
  put.addColumn(FAMILY,qualifier,2L,Bytes.toBytes("DDD"));
  hTable.put(put);
  result=hTable.get(get);
  navigableMap=result.getMap().get(FAMILY).get(qualifier);
  assertEquals("CCC",Bytes.toString(navigableMap.get(1L)));
  assertEquals("DDD",Bytes.toString(navigableMap.get(2L)));
}

</code></pre>

<pre class="type-1 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test public void testDuplicateVersions() throws Exception {
  TableName TABLE=TableName.valueOf("testDuplicateVersions");
  long[] STAMPS=makeStamps(20);
  byte[][] VALUES=makeNAscii(VALUE,20);
  Table ht=TEST_UTIL.createTable(TABLE,FAMILY,10);
  Put put=new Put(ROW);
  put.addColumn(FAMILY,QUALIFIER,STAMPS[1],VALUES[1]);
  put.addColumn(FAMILY,QUALIFIER,STAMPS[2],VALUES[2]);
  put.addColumn(FAMILY,QUALIFIER,STAMPS[4],VALUES[4]);
  put.addColumn(FAMILY,QUALIFIER,STAMPS[5],VALUES[5]);
  ht.put(put);
  getVersionAndVerify(ht,ROW,FAMILY,QUALIFIER,STAMPS[1],VALUES[1]);
  getVersionAndVerify(ht,ROW,FAMILY,QUALIFIER,STAMPS[2],VALUES[2]);
  getVersionAndVerify(ht,ROW,FAMILY,QUALIFIER,STAMPS[4],VALUES[4]);
  getVersionAndVerify(ht,ROW,FAMILY,QUALIFIER,STAMPS[5],VALUES[5]);
  scanVersionAndVerify(ht,ROW,FAMILY,QUALIFIER,STAMPS[1],VALUES[1]);
  scanVersionAndVerify(ht,ROW,FAMILY,QUALIFIER,STAMPS[2],VALUES[2]);
  scanVersionAndVerify(ht,ROW,FAMILY,QUALIFIER,STAMPS[4],VALUES[4]);
  scanVersionAndVerify(ht,ROW,FAMILY,QUALIFIER,STAMPS[5],VALUES[5]);
  getVersionAndVerifyMissing(ht,ROW,FAMILY,QUALIFIER,STAMPS[0]);
  getVersionAndVerifyMissing(ht,ROW,FAMILY,QUALIFIER,STAMPS[3]);
  getVersionAndVerifyMissing(ht,ROW,FAMILY,QUALIFIER,STAMPS[6]);
  scanVersionAndVerifyMissing(ht,ROW,FAMILY,QUALIFIER,STAMPS[0]);
  scanVersionAndVerifyMissing(ht,ROW,FAMILY,QUALIFIER,STAMPS[3]);
  scanVersionAndVerifyMissing(ht,ROW,FAMILY,QUALIFIER,STAMPS[6]);
  Get get=new Get(ROW);
  get.addColumn(FAMILY,QUALIFIER);
  get.setMaxVersions(2);
  Result result=ht.get(get);
  assertNResult(result,ROW,FAMILY,QUALIFIER,new long[]{STAMPS[4],STAMPS[5]},new byte[][]{VALUES[4],VALUES[5]},0,1);
  Scan scan=new Scan(ROW);
  scan.addColumn(FAMILY,QUALIFIER);
  scan.setMaxVersions(2);
  result=getSingleScanResult(ht,scan);
  assertNResult(result,ROW,FAMILY,QUALIFIER,new long[]{STAMPS[4],STAMPS[5]},new byte[][]{VALUES[4],VALUES[5]},0,1);
  TEST_UTIL.flush();
  getVersionAndVerify(ht,ROW,FAMILY,QUALIFIER,STAMPS[1],VALUES[1]);
  getVersionAndVerify(ht,ROW,FAMILY,QUALIFIER,STAMPS[2],VALUES[2]);
  getVersionAndVerify(ht,ROW,FAMILY,QUALIFIER,STAMPS[4],VALUES[4]);
  getVersionAndVerify(ht,ROW,FAMILY,QUALIFIER,STAMPS[5],VALUES[5]);
  scanVersionAndVerify(ht,ROW,FAMILY,QUALIFIER,STAMPS[1],VALUES[1]);
  scanVersionAndVerify(ht,ROW,FAMILY,QUALIFIER,STAMPS[2],VALUES[2]);
  scanVersionAndVerify(ht,ROW,FAMILY,QUALIFIER,STAMPS[4],VALUES[4]);
  scanVersionAndVerify(ht,ROW,FAMILY,QUALIFIER,STAMPS[5],VALUES[5]);
  getVersionAndVerifyMissing(ht,ROW,FAMILY,QUALIFIER,STAMPS[0]);
  getVersionAndVerifyMissing(ht,ROW,FAMILY,QUALIFIER,STAMPS[3]);
  getVersionAndVerifyMissing(ht,ROW,FAMILY,QUALIFIER,STAMPS[6]);
  scanVersionAndVerifyMissing(ht,ROW,FAMILY,QUALIFIER,STAMPS[0]);
  scanVersionAndVerifyMissing(ht,ROW,FAMILY,QUALIFIER,STAMPS[3]);
  scanVersionAndVerifyMissing(ht,ROW,FAMILY,QUALIFIER,STAMPS[6]);
  get=new Get(ROW);
  get.addColumn(FAMILY,QUALIFIER);
  get.setMaxVersions(2);
  result=ht.get(get);
  assertNResult(result,ROW,FAMILY,QUALIFIER,new long[]{STAMPS[4],STAMPS[5]},new byte[][]{VALUES[4],VALUES[5]},0,1);
  scan=new Scan(ROW);
  scan.addColumn(FAMILY,QUALIFIER);
  scan.setMaxVersions(2);
  result=getSingleScanResult(ht,scan);
  assertNResult(result,ROW,FAMILY,QUALIFIER,new long[]{STAMPS[4],STAMPS[5]},new byte[][]{VALUES[4],VALUES[5]},0,1);
  put=new Put(ROW);
  put.addColumn(FAMILY,QUALIFIER,STAMPS[3],VALUES[3]);
  put.addColumn(FAMILY,QUALIFIER,STAMPS[4],VALUES[14]);
  put.addColumn(FAMILY,QUALIFIER,STAMPS[6],VALUES[6]);
  put.addColumn(FAMILY,QUALIFIER,STAMPS[7],VALUES[7]);
  put.addColumn(FAMILY,QUALIFIER,STAMPS[8],VALUES[8]);
  ht.put(put);
  get=new Get(ROW);
  get.addColumn(FAMILY,QUALIFIER);
  get.setMaxVersions(7);
  result=ht.get(get);
  assertNResult(result,ROW,FAMILY,QUALIFIER,new long[]{STAMPS[2],STAMPS[3],STAMPS[4],STAMPS[5],STAMPS[6],STAMPS[7],STAMPS[8]},new byte[][]{VALUES[2],VALUES[3],VALUES[14],VALUES[5],VALUES[6],VALUES[7],VALUES[8]},0,6);
  scan=new Scan(ROW);
  scan.addColumn(FAMILY,QUALIFIER);
  scan.setMaxVersions(7);
  result=getSingleScanResult(ht,scan);
  assertNResult(result,ROW,FAMILY,QUALIFIER,new long[]{STAMPS[2],STAMPS[3],STAMPS[4],STAMPS[5],STAMPS[6],STAMPS[7],STAMPS[8]},new byte[][]{VALUES[2],VALUES[3],VALUES[14],VALUES[5],VALUES[6],VALUES[7],VALUES[8]},0,6);
  get=new Get(ROW);
  get.setMaxVersions(7);
  result=ht.get(get);
  assertNResult(result,ROW,FAMILY,QUALIFIER,new long[]{STAMPS[2],STAMPS[3],STAMPS[4],STAMPS[5],STAMPS[6],STAMPS[7],STAMPS[8]},new byte[][]{VALUES[2],VALUES[3],VALUES[14],VALUES[5],VALUES[6],VALUES[7],VALUES[8]},0,6);
  scan=new Scan(ROW);
  scan.setMaxVersions(7);
  result=getSingleScanResult(ht,scan);
  assertNResult(result,ROW,FAMILY,QUALIFIER,new long[]{STAMPS[2],STAMPS[3],STAMPS[4],STAMPS[5],STAMPS[6],STAMPS[7],STAMPS[8]},new byte[][]{VALUES[2],VALUES[3],VALUES[14],VALUES[5],VALUES[6],VALUES[7],VALUES[8]},0,6);
  getVersionAndVerify(ht,ROW,FAMILY,QUALIFIER,STAMPS[1],VALUES[1]);
  getVersionAndVerify(ht,ROW,FAMILY,QUALIFIER,STAMPS[2],VALUES[2]);
  getVersionAndVerify(ht,ROW,FAMILY,QUALIFIER,STAMPS[4],VALUES[14]);
  getVersionAndVerify(ht,ROW,FAMILY,QUALIFIER,STAMPS[7],VALUES[7]);
  scanVersionAndVerify(ht,ROW,FAMILY,QUALIFIER,STAMPS[1],VALUES[1]);
  scanVersionAndVerify(ht,ROW,FAMILY,QUALIFIER,STAMPS[2],VALUES[2]);
  scanVersionAndVerify(ht,ROW,FAMILY,QUALIFIER,STAMPS[4],VALUES[14]);
  scanVersionAndVerify(ht,ROW,FAMILY,QUALIFIER,STAMPS[7],VALUES[7]);
  getVersionAndVerifyMissing(ht,ROW,FAMILY,QUALIFIER,STAMPS[0]);
  getVersionAndVerifyMissing(ht,ROW,FAMILY,QUALIFIER,STAMPS[9]);
  scanVersionAndVerifyMissing(ht,ROW,FAMILY,QUALIFIER,STAMPS[0]);
  scanVersionAndVerifyMissing(ht,ROW,FAMILY,QUALIFIER,STAMPS[9]);
  TEST_UTIL.flush();
  put=new Put(ROW);
  put.addColumn(FAMILY,QUALIFIER,STAMPS[9],VALUES[9]);
  put.addColumn(FAMILY,QUALIFIER,STAMPS[11],VALUES[11]);
  put.addColumn(FAMILY,QUALIFIER,STAMPS[13],VALUES[13]);
  put.addColumn(FAMILY,QUALIFIER,STAMPS[15],VALUES[15]);
  ht.put(put);
  get=new Get(ROW);
  get.addColumn(FAMILY,QUALIFIER);
  get.setMaxVersions(Integer.MAX_VALUE);
  result=ht.get(get);
  assertNResult(result,ROW,FAMILY,QUALIFIER,new long[]{STAMPS[3],STAMPS[4],STAMPS[5],STAMPS[6],STAMPS[7],STAMPS[8],STAMPS[9],STAMPS[11],STAMPS[13],STAMPS[15]},new byte[][]{VALUES[3],VALUES[14],VALUES[5],VALUES[6],VALUES[7],VALUES[8],VALUES[9],VALUES[11],VALUES[13],VALUES[15]},0,9);
  scan=new Scan(ROW);
  scan.addColumn(FAMILY,QUALIFIER);
  scan.setMaxVersions(Integer.MAX_VALUE);
  result=getSingleScanResult(ht,scan);
  assertNResult(result,ROW,FAMILY,QUALIFIER,new long[]{STAMPS[3],STAMPS[4],STAMPS[5],STAMPS[6],STAMPS[7],STAMPS[8],STAMPS[9],STAMPS[11],STAMPS[13],STAMPS[15]},new byte[][]{VALUES[3],VALUES[14],VALUES[5],VALUES[6],VALUES[7],VALUES[8],VALUES[9],VALUES[11],VALUES[13],VALUES[15]},0,9);
  Delete delete=new Delete(ROW);
  delete.addColumn(FAMILY,QUALIFIER,STAMPS[11]);
  delete.addColumn(FAMILY,QUALIFIER,STAMPS[7]);
  ht.delete(delete);
  get=new Get(ROW);
  get.addColumn(FAMILY,QUALIFIER);
  get.setMaxVersions(Integer.MAX_VALUE);
  result=ht.get(get);
  assertNResult(result,ROW,FAMILY,QUALIFIER,new long[]{STAMPS[1],STAMPS[2],STAMPS[3],STAMPS[4],STAMPS[5],STAMPS[6],STAMPS[8],STAMPS[9],STAMPS[13],STAMPS[15]},new byte[][]{VALUES[1],VALUES[2],VALUES[3],VALUES[14],VALUES[5],VALUES[6],VALUES[8],VALUES[9],VALUES[13],VALUES[15]},0,9);
  scan=new Scan(ROW);
  scan.addColumn(FAMILY,QUALIFIER);
  scan.setMaxVersions(Integer.MAX_VALUE);
  result=getSingleScanResult(ht,scan);
  assertNResult(result,ROW,FAMILY,QUALIFIER,new long[]{STAMPS[1],STAMPS[2],STAMPS[3],STAMPS[4],STAMPS[5],STAMPS[6],STAMPS[8],STAMPS[9],STAMPS[13],STAMPS[15]},new byte[][]{VALUES[1],VALUES[2],VALUES[3],VALUES[14],VALUES[5],VALUES[6],VALUES[8],VALUES[9],VALUES[13],VALUES[15]},0,9);
}

</code></pre>

<pre class="type-4 type-7 type-8 type-5 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test filters when multiple regions.  It does counts.  Needs eye-balling of
 * logs to ensure that we're not scanning more regions that we're supposed to.
 * Related to the TestFilterAcrossRegions over in the o.a.h.h.filter package.
 * @throws IOException
 * @throws InterruptedException
 */
@Test public void testFilterAcrossMultipleRegions() throws IOException, InterruptedException {
  TableName name=TableName.valueOf("testFilterAcrossMutlipleRegions");
  Table t=TEST_UTIL.createTable(name,FAMILY);
  int rowCount=TEST_UTIL.loadTable(t,FAMILY,false);
  assertRowCount(t,rowCount);
  List<HRegionLocation> regions=splitTable(t);
  assertRowCount(t,rowCount);
  byte[] endKey=regions.get(0).getRegionInfo().getEndKey();
  int endKeyCount=countRows(t,createScanWithRowFilter(endKey));
  assertTrue(endKeyCount < rowCount);
  byte[] key=new byte[]{endKey[0],endKey[1],(byte)(endKey[2] + 1)};
  int plusOneCount=countRows(t,createScanWithRowFilter(key));
  assertEquals(endKeyCount + 1,plusOneCount);
  key=new byte[]{endKey[0],endKey[1],(byte)(endKey[2] + 2)};
  int plusTwoCount=countRows(t,createScanWithRowFilter(key));
  assertEquals(endKeyCount + 2,plusTwoCount);
  key=new byte[]{endKey[0],endKey[1],(byte)(endKey[2] - 1)};
  int minusOneCount=countRows(t,createScanWithRowFilter(key));
  assertEquals(endKeyCount - 1,minusOneCount);
  key=new byte[]{'a','a','a'};
  int countBBB=countRows(t,createScanWithRowFilter(key,null,CompareFilter.CompareOp.EQUAL));
  assertEquals(1,countBBB);
  int countGreater=countRows(t,createScanWithRowFilter(endKey,null,CompareFilter.CompareOp.GREATER_OR_EQUAL));
  assertEquals(0,countGreater);
  countGreater=countRows(t,createScanWithRowFilter(endKey,endKey,CompareFilter.CompareOp.GREATER_OR_EQUAL));
  assertEquals(rowCount - endKeyCount,countGreater);
}

</code></pre>

<pre class="type-4 type-7 type-8 type-5 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testFiltersWithReverseScan() throws Exception {
  TableName TABLE=TableName.valueOf("testFiltersWithReverseScan");
  Table ht=TEST_UTIL.createTable(TABLE,FAMILY);
  byte[][] ROWS=makeN(ROW,10);
  byte[][] QUALIFIERS={Bytes.toBytes("col0-<d2v1>-<d3v2>"),Bytes.toBytes("col1-<d2v1>-<d3v2>"),Bytes.toBytes("col2-<d2v1>-<d3v2>"),Bytes.toBytes("col3-<d2v1>-<d3v2>"),Bytes.toBytes("col4-<d2v1>-<d3v2>"),Bytes.toBytes("col5-<d2v1>-<d3v2>"),Bytes.toBytes("col6-<d2v1>-<d3v2>"),Bytes.toBytes("col7-<d2v1>-<d3v2>"),Bytes.toBytes("col8-<d2v1>-<d3v2>"),Bytes.toBytes("col9-<d2v1>-<d3v2>")};
  for (int i=0; i < 10; i++) {
    Put put=new Put(ROWS[i]);
    put.addColumn(FAMILY,QUALIFIERS[i],VALUE);
    ht.put(put);
  }
  Scan scan=new Scan();
  scan.setReversed(true);
  scan.addFamily(FAMILY);
  Filter filter=new QualifierFilter(CompareOp.EQUAL,new RegexStringComparator("col[1-5]"));
  scan.setFilter(filter);
  ResultScanner scanner=ht.getScanner(scan);
  int expectedIndex=5;
  for (  Result result : scanner) {
    assertEquals(result.size(),1);
    Cell c=result.rawCells()[0];
    assertTrue(Bytes.equals(c.getRowArray(),c.getRowOffset(),c.getRowLength(),ROWS[expectedIndex],0,ROWS[expectedIndex].length));
    assertTrue(Bytes.equals(c.getQualifierArray(),c.getQualifierOffset(),c.getQualifierLength(),QUALIFIERS[expectedIndex],0,QUALIFIERS[expectedIndex].length));
    expectedIndex--;
  }
  assertEquals(expectedIndex,0);
  scanner.close();
  ht.close();
}

</code></pre>

<pre class="type-4 type-9 type-7 type-8 type-13 type-5 type-6 type-18 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Is not executed with the test suite">IgnoredMethod</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions in iterations
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects are null
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
- Is not executed with the test suite
"></span><br>
@Ignore("Flakey: HBASE-8989") @Test public void testClientPoolThreadLocal() throws IOException {
  final TableName tableName=TableName.valueOf("testClientPoolThreadLocal");
  int poolSize=Integer.MAX_VALUE;
  int numVersions=3;
  Configuration conf=TEST_UTIL.getConfiguration();
  conf.set(HConstants.HBASE_CLIENT_IPC_POOL_TYPE,"thread-local");
  conf.setInt(HConstants.HBASE_CLIENT_IPC_POOL_SIZE,poolSize);
  final Table table=TEST_UTIL.createTable(tableName,new byte[][]{FAMILY},3);
  final long ts=EnvironmentEdgeManager.currentTime();
  final Get get=new Get(ROW);
  get.addColumn(FAMILY,QUALIFIER);
  get.setMaxVersions();
  for (int versions=1; versions <= numVersions; versions++) {
    Put put=new Put(ROW);
    put.addColumn(FAMILY,QUALIFIER,ts + versions,VALUE);
    table.put(put);
    Result result=table.get(get);
    NavigableMap<Long,byte[]> navigableMap=result.getMap().get(FAMILY).get(QUALIFIER);
    assertEquals("The number of versions of '" + FAMILY + ":"+ QUALIFIER+ " did not match "+ versions+ "; "+ put.toString()+ ", "+ get.toString(),versions,navigableMap.size());
    for (    Map.Entry<Long,byte[]> entry : navigableMap.entrySet()) {
      assertTrue("The value at time " + entry.getKey() + " did not match what was put",Bytes.equals(VALUE,entry.getValue()));
    }
  }
  final Object waitLock=new Object();
  ExecutorService executorService=Executors.newFixedThreadPool(numVersions);
  final AtomicReference<AssertionError> error=new AtomicReference<AssertionError>(null);
  for (int versions=numVersions; versions < numVersions * 2; versions++) {
    final int versionsCopy=versions;
    executorService.submit(new Callable<Void>(){
      @Override public Void call(){
        try {
          Put put=new Put(ROW);
          put.addColumn(FAMILY,QUALIFIER,ts + versionsCopy,VALUE);
          table.put(put);
          Result result=table.get(get);
          NavigableMap<Long,byte[]> navigableMap=result.getMap().get(FAMILY).get(QUALIFIER);
          assertEquals("The number of versions of '" + Bytes.toString(FAMILY) + ":"+ Bytes.toString(QUALIFIER)+ " did not match "+ versionsCopy,versionsCopy,navigableMap.size());
          for (          Map.Entry<Long,byte[]> entry : navigableMap.entrySet()) {
            assertTrue("The value at time " + entry.getKey() + " did not match what was put",Bytes.equals(VALUE,entry.getValue()));
          }
synchronized (waitLock) {
            waitLock.wait();
          }
        }
 catch (        Exception e) {
        }
catch (        AssertionError e) {
          error.set(e);
          LOG.error(e);
        }
        return null;
      }
    }
);
  }
synchronized (waitLock) {
    waitLock.notifyAll();
  }
  executorService.shutdownNow();
  assertNull(error.get());
}

</code></pre>

<pre class="type-7 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
"></span><br>
@Test public void testKeyOnlyFilter() throws Exception {
  TableName TABLE=TableName.valueOf("testKeyOnlyFilter");
  Table ht=TEST_UTIL.createTable(TABLE,FAMILY);
  byte[][] ROWS=makeN(ROW,10);
  byte[][] QUALIFIERS={Bytes.toBytes("col0-<d2v1>-<d3v2>"),Bytes.toBytes("col1-<d2v1>-<d3v2>"),Bytes.toBytes("col2-<d2v1>-<d3v2>"),Bytes.toBytes("col3-<d2v1>-<d3v2>"),Bytes.toBytes("col4-<d2v1>-<d3v2>"),Bytes.toBytes("col5-<d2v1>-<d3v2>"),Bytes.toBytes("col6-<d2v1>-<d3v2>"),Bytes.toBytes("col7-<d2v1>-<d3v2>"),Bytes.toBytes("col8-<d2v1>-<d3v2>"),Bytes.toBytes("col9-<d2v1>-<d3v2>")};
  for (int i=0; i < 10; i++) {
    Put put=new Put(ROWS[i]);
    put.setDurability(Durability.SKIP_WAL);
    put.addColumn(FAMILY,QUALIFIERS[i],VALUE);
    ht.put(put);
  }
  Scan scan=new Scan();
  scan.addFamily(FAMILY);
  Filter filter=new KeyOnlyFilter(true);
  scan.setFilter(filter);
  ResultScanner scanner=ht.getScanner(scan);
  int count=0;
  for (  Result result : ht.getScanner(scan)) {
    assertEquals(result.size(),1);
    assertEquals(result.rawCells()[0].getValueLength(),Bytes.SIZEOF_INT);
    assertEquals(Bytes.toInt(CellUtil.cloneValue(result.rawCells()[0])),VALUE.length);
    count++;
  }
  assertEquals(count,10);
  scanner.close();
}

</code></pre>

<pre class="type-4 type-10 type-7 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions inside branch conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
"></span><br>
@Test public void testGetRegionsInRange() throws Exception {
  byte[] startKey=Bytes.toBytes("ddc");
  byte[] endKey=Bytes.toBytes("mmm");
  TableName TABLE=TableName.valueOf("testGetRegionsInRange");
  Table t=TEST_UTIL.createMultiRegionTable(TABLE,new byte[][]{FAMILY},10);
  if (t instanceof HTable) {
    HTable table=(HTable)t;
    int numOfRegions=-1;
    try (RegionLocator r=table.getRegionLocator()){
      numOfRegions=r.getStartKeys().length;
    }
     assertEquals(26,numOfRegions);
    List<HRegionLocation> regionsList=getRegionsInRange(TABLE,startKey,endKey);
    assertEquals(10,regionsList.size());
    startKey=Bytes.toBytes("fff");
    regionsList=getRegionsInRange(TABLE,startKey,endKey);
    assertEquals(7,regionsList.size());
    endKey=Bytes.toBytes("nnn");
    regionsList=getRegionsInRange(TABLE,startKey,endKey);
    assertEquals(8,regionsList.size());
    regionsList=getRegionsInRange(TABLE,HConstants.EMPTY_START_ROW,endKey);
    assertEquals(13,regionsList.size());
    regionsList=getRegionsInRange(TABLE,startKey,HConstants.EMPTY_END_ROW);
    assertEquals(21,regionsList.size());
    regionsList=getRegionsInRange(TABLE,HConstants.EMPTY_START_ROW,HConstants.EMPTY_END_ROW);
    assertEquals(26,regionsList.size());
    endKey=Bytes.toBytes("zzz1");
    regionsList=getRegionsInRange(TABLE,startKey,endKey);
    assertEquals(21,regionsList.size());
    startKey=Bytes.toBytes("aac");
    regionsList=getRegionsInRange(TABLE,startKey,endKey);
    assertEquals(26,regionsList.size());
    startKey=endKey=Bytes.toBytes("ccc");
    regionsList=getRegionsInRange(TABLE,startKey,endKey);
    assertEquals(1,regionsList.size());
  }
}

</code></pre>

<pre class="type-7 type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
"></span><br>
@Test public void testGet_NonExistentRow() throws IOException {
  Table table=TEST_UTIL.createTable(TableName.valueOf("testGet_NonExistentRow"),FAMILY);
  Put put=new Put(ROW);
  put.addColumn(FAMILY,QUALIFIER,VALUE);
  table.put(put);
  LOG.info("Row put");
  Get get=new Get(ROW);
  get.addFamily(FAMILY);
  Result r=table.get(get);
  assertFalse(r.isEmpty());
  System.out.println("Row retrieved successfully");
  byte[] missingrow=Bytes.toBytes("missingrow");
  get=new Get(missingrow);
  get.addFamily(FAMILY);
  r=table.get(get);
  assertTrue(r.isEmpty());
  LOG.info("Row missing as it should be");
}

</code></pre>

<pre class="type-4 type-7 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
"></span><br>
@Test public void testUpdatesWithMajorCompaction() throws Exception {
  TableName TABLE=TableName.valueOf("testUpdatesWithMajorCompaction");
  Table hTable=TEST_UTIL.createTable(TABLE,FAMILY,10);
  Admin admin=TEST_UTIL.getHBaseAdmin();
  byte[] row=Bytes.toBytes("row2");
  byte[] qualifier=Bytes.toBytes("myCol");
  Put put=new Put(row);
  put.addColumn(FAMILY,qualifier,1L,Bytes.toBytes("AAA"));
  hTable.put(put);
  put=new Put(row);
  put.addColumn(FAMILY,qualifier,2L,Bytes.toBytes("BBB"));
  hTable.put(put);
  put=new Put(row);
  put.addColumn(FAMILY,qualifier,3L,Bytes.toBytes("EEE"));
  hTable.put(put);
  Get get=new Get(row);
  get.addColumn(FAMILY,qualifier);
  get.setMaxVersions();
  Result result=hTable.get(get);
  NavigableMap<Long,byte[]> navigableMap=result.getMap().get(FAMILY).get(qualifier);
  assertEquals("AAA",Bytes.toString(navigableMap.get(1L)));
  assertEquals("BBB",Bytes.toString(navigableMap.get(2L)));
  admin.flush(TABLE);
  admin.majorCompact(TABLE);
  Thread.sleep(6000);
  put=new Put(row);
  put.addColumn(FAMILY,qualifier,1L,Bytes.toBytes("CCC"));
  hTable.put(put);
  put=new Put(row);
  put.addColumn(FAMILY,qualifier,2L,Bytes.toBytes("DDD"));
  hTable.put(put);
  admin.flush(TABLE);
  admin.majorCompact(TABLE);
  Thread.sleep(6000);
  result=hTable.get(get);
  navigableMap=result.getMap().get(FAMILY).get(qualifier);
  assertEquals("CCC",Bytes.toString(navigableMap.get(1L)));
  assertEquals("DDD",Bytes.toString(navigableMap.get(2L)));
}

</code></pre>

<pre class="type-4 type-7 type-8 type-5 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Tests reversed scan under multi regions
 */
@Test public void testSmallReversedScanUnderMultiRegions() throws Exception {
  TableName TABLE=TableName.valueOf("testSmallReversedScanUnderMultiRegions");
  byte[][] splitRows=new byte[][]{Bytes.toBytes("000"),Bytes.toBytes("002"),Bytes.toBytes("004"),Bytes.toBytes("006"),Bytes.toBytes("008"),Bytes.toBytes("010")};
  Table table=TEST_UTIL.createTable(TABLE,FAMILY,splitRows);
  TEST_UTIL.waitUntilAllRegionsAssigned(table.getName());
  try (RegionLocator l=TEST_UTIL.getConnection().getRegionLocator(TABLE)){
    assertEquals(splitRows.length + 1,l.getAllRegionLocations().size());
  }
   for (  byte[] splitRow : splitRows) {
    Put put=new Put(splitRow);
    put.addColumn(FAMILY,QUALIFIER,VALUE);
    table.put(put);
    byte[] nextRow=Bytes.copy(splitRow);
    nextRow[nextRow.length - 1]++;
    put=new Put(nextRow);
    put.addColumn(FAMILY,QUALIFIER,VALUE);
    table.put(put);
  }
  ResultScanner scanner=table.getScanner(new Scan());
  int count=0;
  for (  Result r : scanner) {
    assertTrue(!r.isEmpty());
    count++;
  }
  assertEquals(12,count);
  reverseScanTest(table,false);
  reverseScanTest(table,true);
  table.close();
}

</code></pre>

<pre class="type-4 type-7 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
"></span><br>
@Test public void testMajorCompactionBetweenTwoUpdates() throws Exception {
  TableName tableName=TableName.valueOf("testMajorCompactionBetweenTwoUpdates");
  Table hTable=TEST_UTIL.createTable(tableName,FAMILY,10);
  Admin admin=TEST_UTIL.getHBaseAdmin();
  byte[] row=Bytes.toBytes("row3");
  byte[] qualifier=Bytes.toBytes("myCol");
  Put put=new Put(row);
  put.addColumn(FAMILY,qualifier,1L,Bytes.toBytes("AAA"));
  hTable.put(put);
  put=new Put(row);
  put.addColumn(FAMILY,qualifier,2L,Bytes.toBytes("BBB"));
  hTable.put(put);
  put=new Put(row);
  put.addColumn(FAMILY,qualifier,3L,Bytes.toBytes("EEE"));
  hTable.put(put);
  Get get=new Get(row);
  get.addColumn(FAMILY,qualifier);
  get.setMaxVersions();
  Result result=hTable.get(get);
  NavigableMap<Long,byte[]> navigableMap=result.getMap().get(FAMILY).get(qualifier);
  assertEquals("AAA",Bytes.toString(navigableMap.get(1L)));
  assertEquals("BBB",Bytes.toString(navigableMap.get(2L)));
  admin.flush(tableName);
  admin.majorCompact(tableName);
  Thread.sleep(6000);
  put=new Put(row);
  put.addColumn(FAMILY,qualifier,1L,Bytes.toBytes("CCC"));
  hTable.put(put);
  admin.flush(tableName);
  admin.majorCompact(tableName);
  Thread.sleep(6000);
  put=new Put(row);
  put.addColumn(FAMILY,qualifier,2L,Bytes.toBytes("DDD"));
  hTable.put(put);
  admin.flush(tableName);
  admin.majorCompact(tableName);
  Thread.sleep(6000);
  result=hTable.get(get);
  navigableMap=result.getMap().get(FAMILY).get(qualifier);
  assertEquals("CCC",Bytes.toString(navigableMap.get(1L)));
  assertEquals("DDD",Bytes.toString(navigableMap.get(2L)));
}

</code></pre>

<pre class="type-4 type-7 type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
"></span><br>
@Test public void testVersionLimits() throws Exception {
  TableName TABLE=TableName.valueOf("testVersionLimits");
  byte[][] FAMILIES=makeNAscii(FAMILY,3);
  int[] LIMITS={1,3,5};
  long[] STAMPS=makeStamps(10);
  byte[][] VALUES=makeNAscii(VALUE,10);
  Table ht=TEST_UTIL.createTable(TABLE,FAMILIES,LIMITS);
  Put put=new Put(ROW);
  put.addColumn(FAMILIES[0],QUALIFIER,STAMPS[0],VALUES[0]);
  put.addColumn(FAMILIES[0],QUALIFIER,STAMPS[1],VALUES[1]);
  put.addColumn(FAMILIES[1],QUALIFIER,STAMPS[0],VALUES[0]);
  put.addColumn(FAMILIES[1],QUALIFIER,STAMPS[1],VALUES[1]);
  put.addColumn(FAMILIES[1],QUALIFIER,STAMPS[2],VALUES[2]);
  put.addColumn(FAMILIES[1],QUALIFIER,STAMPS[3],VALUES[3]);
  put.addColumn(FAMILIES[2],QUALIFIER,STAMPS[0],VALUES[0]);
  put.addColumn(FAMILIES[2],QUALIFIER,STAMPS[1],VALUES[1]);
  put.addColumn(FAMILIES[2],QUALIFIER,STAMPS[2],VALUES[2]);
  put.addColumn(FAMILIES[2],QUALIFIER,STAMPS[3],VALUES[3]);
  put.addColumn(FAMILIES[2],QUALIFIER,STAMPS[4],VALUES[4]);
  put.addColumn(FAMILIES[2],QUALIFIER,STAMPS[5],VALUES[5]);
  put.addColumn(FAMILIES[2],QUALIFIER,STAMPS[6],VALUES[6]);
  ht.put(put);
  Get get=new Get(ROW);
  get.addColumn(FAMILIES[0],QUALIFIER);
  get.setMaxVersions(Integer.MAX_VALUE);
  Result result=ht.get(get);
  assertNResult(result,ROW,FAMILIES[0],QUALIFIER,new long[]{STAMPS[1]},new byte[][]{VALUES[1]},0,0);
  get=new Get(ROW);
  get.addFamily(FAMILIES[0]);
  get.setMaxVersions(Integer.MAX_VALUE);
  result=ht.get(get);
  assertNResult(result,ROW,FAMILIES[0],QUALIFIER,new long[]{STAMPS[1]},new byte[][]{VALUES[1]},0,0);
  Scan scan=new Scan(ROW);
  scan.addColumn(FAMILIES[0],QUALIFIER);
  scan.setMaxVersions(Integer.MAX_VALUE);
  result=getSingleScanResult(ht,scan);
  assertNResult(result,ROW,FAMILIES[0],QUALIFIER,new long[]{STAMPS[1]},new byte[][]{VALUES[1]},0,0);
  scan=new Scan(ROW);
  scan.addFamily(FAMILIES[0]);
  scan.setMaxVersions(Integer.MAX_VALUE);
  result=getSingleScanResult(ht,scan);
  assertNResult(result,ROW,FAMILIES[0],QUALIFIER,new long[]{STAMPS[1]},new byte[][]{VALUES[1]},0,0);
  get=new Get(ROW);
  get.addColumn(FAMILIES[1],QUALIFIER);
  get.setMaxVersions(Integer.MAX_VALUE);
  result=ht.get(get);
  assertNResult(result,ROW,FAMILIES[1],QUALIFIER,new long[]{STAMPS[1],STAMPS[2],STAMPS[3]},new byte[][]{VALUES[1],VALUES[2],VALUES[3]},0,2);
  get=new Get(ROW);
  get.addFamily(FAMILIES[1]);
  get.setMaxVersions(Integer.MAX_VALUE);
  result=ht.get(get);
  assertNResult(result,ROW,FAMILIES[1],QUALIFIER,new long[]{STAMPS[1],STAMPS[2],STAMPS[3]},new byte[][]{VALUES[1],VALUES[2],VALUES[3]},0,2);
  scan=new Scan(ROW);
  scan.addColumn(FAMILIES[1],QUALIFIER);
  scan.setMaxVersions(Integer.MAX_VALUE);
  result=getSingleScanResult(ht,scan);
  assertNResult(result,ROW,FAMILIES[1],QUALIFIER,new long[]{STAMPS[1],STAMPS[2],STAMPS[3]},new byte[][]{VALUES[1],VALUES[2],VALUES[3]},0,2);
  scan=new Scan(ROW);
  scan.addFamily(FAMILIES[1]);
  scan.setMaxVersions(Integer.MAX_VALUE);
  result=getSingleScanResult(ht,scan);
  assertNResult(result,ROW,FAMILIES[1],QUALIFIER,new long[]{STAMPS[1],STAMPS[2],STAMPS[3]},new byte[][]{VALUES[1],VALUES[2],VALUES[3]},0,2);
  get=new Get(ROW);
  get.addColumn(FAMILIES[2],QUALIFIER);
  get.setMaxVersions(Integer.MAX_VALUE);
  result=ht.get(get);
  assertNResult(result,ROW,FAMILIES[2],QUALIFIER,new long[]{STAMPS[2],STAMPS[3],STAMPS[4],STAMPS[5],STAMPS[6]},new byte[][]{VALUES[2],VALUES[3],VALUES[4],VALUES[5],VALUES[6]},0,4);
  get=new Get(ROW);
  get.addFamily(FAMILIES[2]);
  get.setMaxVersions(Integer.MAX_VALUE);
  result=ht.get(get);
  assertNResult(result,ROW,FAMILIES[2],QUALIFIER,new long[]{STAMPS[2],STAMPS[3],STAMPS[4],STAMPS[5],STAMPS[6]},new byte[][]{VALUES[2],VALUES[3],VALUES[4],VALUES[5],VALUES[6]},0,4);
  scan=new Scan(ROW);
  scan.addColumn(FAMILIES[2],QUALIFIER);
  scan.setMaxVersions(Integer.MAX_VALUE);
  result=getSingleScanResult(ht,scan);
  assertNResult(result,ROW,FAMILIES[2],QUALIFIER,new long[]{STAMPS[2],STAMPS[3],STAMPS[4],STAMPS[5],STAMPS[6]},new byte[][]{VALUES[2],VALUES[3],VALUES[4],VALUES[5],VALUES[6]},0,4);
  scan=new Scan(ROW);
  scan.addFamily(FAMILIES[2]);
  scan.setMaxVersions(Integer.MAX_VALUE);
  result=getSingleScanResult(ht,scan);
  assertNResult(result,ROW,FAMILIES[2],QUALIFIER,new long[]{STAMPS[2],STAMPS[3],STAMPS[4],STAMPS[5],STAMPS[6]},new byte[][]{VALUES[2],VALUES[3],VALUES[4],VALUES[5],VALUES[6]},0,4);
  get=new Get(ROW);
  get.setMaxVersions(Integer.MAX_VALUE);
  result=ht.get(get);
  assertTrue("Expected 9 keys but received " + result.size(),result.size() == 9);
  get=new Get(ROW);
  get.addFamily(FAMILIES[0]);
  get.addFamily(FAMILIES[1]);
  get.addFamily(FAMILIES[2]);
  get.setMaxVersions(Integer.MAX_VALUE);
  result=ht.get(get);
  assertTrue("Expected 9 keys but received " + result.size(),result.size() == 9);
  get=new Get(ROW);
  get.addColumn(FAMILIES[0],QUALIFIER);
  get.addColumn(FAMILIES[1],QUALIFIER);
  get.addColumn(FAMILIES[2],QUALIFIER);
  get.setMaxVersions(Integer.MAX_VALUE);
  result=ht.get(get);
  assertTrue("Expected 9 keys but received " + result.size(),result.size() == 9);
  scan=new Scan(ROW);
  scan.setMaxVersions(Integer.MAX_VALUE);
  result=getSingleScanResult(ht,scan);
  assertTrue("Expected 9 keys but received " + result.size(),result.size() == 9);
  scan=new Scan(ROW);
  scan.setMaxVersions(Integer.MAX_VALUE);
  scan.addFamily(FAMILIES[0]);
  scan.addFamily(FAMILIES[1]);
  scan.addFamily(FAMILIES[2]);
  result=getSingleScanResult(ht,scan);
  assertTrue("Expected 9 keys but received " + result.size(),result.size() == 9);
  scan=new Scan(ROW);
  scan.setMaxVersions(Integer.MAX_VALUE);
  scan.addColumn(FAMILIES[0],QUALIFIER);
  scan.addColumn(FAMILIES[1],QUALIFIER);
  scan.addColumn(FAMILIES[2],QUALIFIER);
  result=getSingleScanResult(ht,scan);
  assertTrue("Expected 9 keys but received " + result.size(),result.size() == 9);
}

</code></pre>

<pre class="type-9 type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies boolean conditions
"></span><br>
/** 
 * test for HBASE-737
 * @throws IOException
 */
@Test public void testHBase737() throws IOException {
  final byte[] FAM1=Bytes.toBytes("fam1");
  final byte[] FAM2=Bytes.toBytes("fam2");
  Table table=TEST_UTIL.createTable(TableName.valueOf("testHBase737"),new byte[][]{FAM1,FAM2});
  Put put=new Put(ROW);
  put.addColumn(FAM1,Bytes.toBytes("letters"),Bytes.toBytes("abcdefg"));
  table.put(put);
  try {
    Thread.sleep(1000);
  }
 catch (  InterruptedException i) {
  }
  put=new Put(ROW);
  put.addColumn(FAM1,Bytes.toBytes("numbers"),Bytes.toBytes("123456"));
  table.put(put);
  try {
    Thread.sleep(1000);
  }
 catch (  InterruptedException i) {
  }
  put=new Put(ROW);
  put.addColumn(FAM2,Bytes.toBytes("letters"),Bytes.toBytes("hijklmnop"));
  table.put(put);
  long times[]=new long[3];
  Scan scan=new Scan();
  scan.addFamily(FAM1);
  scan.addFamily(FAM2);
  ResultScanner s=table.getScanner(scan);
  try {
    int index=0;
    Result r=null;
    while ((r=s.next()) != null) {
      for (      Cell key : r.rawCells()) {
        times[index++]=key.getTimestamp();
      }
    }
  }
  finally {
    s.close();
  }
  for (int i=0; i < times.length - 1; i++) {
    for (int j=i + 1; j < times.length; j++) {
      assertTrue(times[j] > times[i]);
    }
  }
  TEST_UTIL.flush();
  for (int i=0; i < times.length; i++) {
    times[i]=0;
  }
  try {
    Thread.sleep(1000);
  }
 catch (  InterruptedException i) {
  }
  scan=new Scan();
  scan.addFamily(FAM1);
  scan.addFamily(FAM2);
  s=table.getScanner(scan);
  try {
    int index=0;
    Result r=null;
    while ((r=s.next()) != null) {
      for (      Cell key : r.rawCells()) {
        times[index++]=key.getTimestamp();
      }
    }
  }
  finally {
    s.close();
  }
  for (int i=0; i < times.length - 1; i++) {
    for (int j=i + 1; j < times.length; j++) {
      assertTrue(times[j] > times[i]);
    }
  }
}

</code></pre>

<pre class="type-1 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test public void testVersions() throws Exception {
  TableName TABLE=TableName.valueOf("testVersions");
  long[] STAMPS=makeStamps(20);
  byte[][] VALUES=makeNAscii(VALUE,20);
  Table ht=TEST_UTIL.createTable(TABLE,FAMILY,10);
  Put put=new Put(ROW);
  put.addColumn(FAMILY,QUALIFIER,STAMPS[1],VALUES[1]);
  put.addColumn(FAMILY,QUALIFIER,STAMPS[2],VALUES[2]);
  put.addColumn(FAMILY,QUALIFIER,STAMPS[4],VALUES[4]);
  put.addColumn(FAMILY,QUALIFIER,STAMPS[5],VALUES[5]);
  ht.put(put);
  getVersionAndVerify(ht,ROW,FAMILY,QUALIFIER,STAMPS[1],VALUES[1]);
  getVersionAndVerify(ht,ROW,FAMILY,QUALIFIER,STAMPS[2],VALUES[2]);
  getVersionAndVerify(ht,ROW,FAMILY,QUALIFIER,STAMPS[4],VALUES[4]);
  getVersionAndVerify(ht,ROW,FAMILY,QUALIFIER,STAMPS[5],VALUES[5]);
  scanVersionAndVerify(ht,ROW,FAMILY,QUALIFIER,STAMPS[1],VALUES[1]);
  scanVersionAndVerify(ht,ROW,FAMILY,QUALIFIER,STAMPS[2],VALUES[2]);
  scanVersionAndVerify(ht,ROW,FAMILY,QUALIFIER,STAMPS[4],VALUES[4]);
  scanVersionAndVerify(ht,ROW,FAMILY,QUALIFIER,STAMPS[5],VALUES[5]);
  getVersionAndVerifyMissing(ht,ROW,FAMILY,QUALIFIER,STAMPS[0]);
  getVersionAndVerifyMissing(ht,ROW,FAMILY,QUALIFIER,STAMPS[3]);
  getVersionAndVerifyMissing(ht,ROW,FAMILY,QUALIFIER,STAMPS[6]);
  scanVersionAndVerifyMissing(ht,ROW,FAMILY,QUALIFIER,STAMPS[0]);
  scanVersionAndVerifyMissing(ht,ROW,FAMILY,QUALIFIER,STAMPS[3]);
  scanVersionAndVerifyMissing(ht,ROW,FAMILY,QUALIFIER,STAMPS[6]);
  Get get=new Get(ROW);
  get.addColumn(FAMILY,QUALIFIER);
  get.setMaxVersions(2);
  Result result=ht.get(get);
  assertNResult(result,ROW,FAMILY,QUALIFIER,new long[]{STAMPS[4],STAMPS[5]},new byte[][]{VALUES[4],VALUES[5]},0,1);
  Scan scan=new Scan(ROW);
  scan.addColumn(FAMILY,QUALIFIER);
  scan.setMaxVersions(2);
  result=getSingleScanResult(ht,scan);
  assertNResult(result,ROW,FAMILY,QUALIFIER,new long[]{STAMPS[4],STAMPS[5]},new byte[][]{VALUES[4],VALUES[5]},0,1);
  TEST_UTIL.flush();
  getVersionAndVerify(ht,ROW,FAMILY,QUALIFIER,STAMPS[1],VALUES[1]);
  getVersionAndVerify(ht,ROW,FAMILY,QUALIFIER,STAMPS[2],VALUES[2]);
  getVersionAndVerify(ht,ROW,FAMILY,QUALIFIER,STAMPS[4],VALUES[4]);
  getVersionAndVerify(ht,ROW,FAMILY,QUALIFIER,STAMPS[5],VALUES[5]);
  scanVersionAndVerify(ht,ROW,FAMILY,QUALIFIER,STAMPS[1],VALUES[1]);
  scanVersionAndVerify(ht,ROW,FAMILY,QUALIFIER,STAMPS[2],VALUES[2]);
  scanVersionAndVerify(ht,ROW,FAMILY,QUALIFIER,STAMPS[4],VALUES[4]);
  scanVersionAndVerify(ht,ROW,FAMILY,QUALIFIER,STAMPS[5],VALUES[5]);
  getVersionAndVerifyMissing(ht,ROW,FAMILY,QUALIFIER,STAMPS[0]);
  getVersionAndVerifyMissing(ht,ROW,FAMILY,QUALIFIER,STAMPS[3]);
  getVersionAndVerifyMissing(ht,ROW,FAMILY,QUALIFIER,STAMPS[6]);
  scanVersionAndVerifyMissing(ht,ROW,FAMILY,QUALIFIER,STAMPS[0]);
  scanVersionAndVerifyMissing(ht,ROW,FAMILY,QUALIFIER,STAMPS[3]);
  scanVersionAndVerifyMissing(ht,ROW,FAMILY,QUALIFIER,STAMPS[6]);
  get=new Get(ROW);
  get.addColumn(FAMILY,QUALIFIER);
  get.setMaxVersions(2);
  result=ht.get(get);
  assertNResult(result,ROW,FAMILY,QUALIFIER,new long[]{STAMPS[4],STAMPS[5]},new byte[][]{VALUES[4],VALUES[5]},0,1);
  scan=new Scan(ROW);
  scan.addColumn(FAMILY,QUALIFIER);
  scan.setMaxVersions(2);
  result=getSingleScanResult(ht,scan);
  assertNResult(result,ROW,FAMILY,QUALIFIER,new long[]{STAMPS[4],STAMPS[5]},new byte[][]{VALUES[4],VALUES[5]},0,1);
  put=new Put(ROW);
  put.addColumn(FAMILY,QUALIFIER,STAMPS[3],VALUES[3]);
  put.addColumn(FAMILY,QUALIFIER,STAMPS[6],VALUES[6]);
  put.addColumn(FAMILY,QUALIFIER,STAMPS[7],VALUES[7]);
  put.addColumn(FAMILY,QUALIFIER,STAMPS[8],VALUES[8]);
  ht.put(put);
  get=new Get(ROW);
  get.addColumn(FAMILY,QUALIFIER);
  get.setMaxVersions();
  result=ht.get(get);
  assertNResult(result,ROW,FAMILY,QUALIFIER,new long[]{STAMPS[1],STAMPS[2],STAMPS[3],STAMPS[4],STAMPS[5],STAMPS[6],STAMPS[7],STAMPS[8]},new byte[][]{VALUES[1],VALUES[2],VALUES[3],VALUES[4],VALUES[5],VALUES[6],VALUES[7],VALUES[8]},0,7);
  scan=new Scan(ROW);
  scan.addColumn(FAMILY,QUALIFIER);
  scan.setMaxVersions();
  result=getSingleScanResult(ht,scan);
  assertNResult(result,ROW,FAMILY,QUALIFIER,new long[]{STAMPS[1],STAMPS[2],STAMPS[3],STAMPS[4],STAMPS[5],STAMPS[6],STAMPS[7],STAMPS[8]},new byte[][]{VALUES[1],VALUES[2],VALUES[3],VALUES[4],VALUES[5],VALUES[6],VALUES[7],VALUES[8]},0,7);
  get=new Get(ROW);
  get.setMaxVersions();
  result=ht.get(get);
  assertNResult(result,ROW,FAMILY,QUALIFIER,new long[]{STAMPS[1],STAMPS[2],STAMPS[3],STAMPS[4],STAMPS[5],STAMPS[6],STAMPS[7],STAMPS[8]},new byte[][]{VALUES[1],VALUES[2],VALUES[3],VALUES[4],VALUES[5],VALUES[6],VALUES[7],VALUES[8]},0,7);
  scan=new Scan(ROW);
  scan.setMaxVersions();
  result=getSingleScanResult(ht,scan);
  assertNResult(result,ROW,FAMILY,QUALIFIER,new long[]{STAMPS[1],STAMPS[2],STAMPS[3],STAMPS[4],STAMPS[5],STAMPS[6],STAMPS[7],STAMPS[8]},new byte[][]{VALUES[1],VALUES[2],VALUES[3],VALUES[4],VALUES[5],VALUES[6],VALUES[7],VALUES[8]},0,7);
  getVersionAndVerify(ht,ROW,FAMILY,QUALIFIER,STAMPS[1],VALUES[1]);
  getVersionAndVerify(ht,ROW,FAMILY,QUALIFIER,STAMPS[2],VALUES[2]);
  getVersionAndVerify(ht,ROW,FAMILY,QUALIFIER,STAMPS[4],VALUES[4]);
  getVersionAndVerify(ht,ROW,FAMILY,QUALIFIER,STAMPS[7],VALUES[7]);
  scanVersionAndVerify(ht,ROW,FAMILY,QUALIFIER,STAMPS[1],VALUES[1]);
  scanVersionAndVerify(ht,ROW,FAMILY,QUALIFIER,STAMPS[2],VALUES[2]);
  scanVersionAndVerify(ht,ROW,FAMILY,QUALIFIER,STAMPS[4],VALUES[4]);
  scanVersionAndVerify(ht,ROW,FAMILY,QUALIFIER,STAMPS[7],VALUES[7]);
  getVersionAndVerifyMissing(ht,ROW,FAMILY,QUALIFIER,STAMPS[0]);
  getVersionAndVerifyMissing(ht,ROW,FAMILY,QUALIFIER,STAMPS[9]);
  scanVersionAndVerifyMissing(ht,ROW,FAMILY,QUALIFIER,STAMPS[0]);
  scanVersionAndVerifyMissing(ht,ROW,FAMILY,QUALIFIER,STAMPS[9]);
  TEST_UTIL.flush();
  put=new Put(ROW);
  put.addColumn(FAMILY,QUALIFIER,STAMPS[9],VALUES[9]);
  put.addColumn(FAMILY,QUALIFIER,STAMPS[11],VALUES[11]);
  put.addColumn(FAMILY,QUALIFIER,STAMPS[13],VALUES[13]);
  put.addColumn(FAMILY,QUALIFIER,STAMPS[15],VALUES[15]);
  ht.put(put);
  get=new Get(ROW);
  get.addColumn(FAMILY,QUALIFIER);
  get.setMaxVersions(Integer.MAX_VALUE);
  result=ht.get(get);
  assertNResult(result,ROW,FAMILY,QUALIFIER,new long[]{STAMPS[3],STAMPS[4],STAMPS[5],STAMPS[6],STAMPS[7],STAMPS[8],STAMPS[9],STAMPS[11],STAMPS[13],STAMPS[15]},new byte[][]{VALUES[3],VALUES[4],VALUES[5],VALUES[6],VALUES[7],VALUES[8],VALUES[9],VALUES[11],VALUES[13],VALUES[15]},0,9);
  scan=new Scan(ROW);
  scan.addColumn(FAMILY,QUALIFIER);
  scan.setMaxVersions(Integer.MAX_VALUE);
  result=getSingleScanResult(ht,scan);
  assertNResult(result,ROW,FAMILY,QUALIFIER,new long[]{STAMPS[3],STAMPS[4],STAMPS[5],STAMPS[6],STAMPS[7],STAMPS[8],STAMPS[9],STAMPS[11],STAMPS[13],STAMPS[15]},new byte[][]{VALUES[3],VALUES[4],VALUES[5],VALUES[6],VALUES[7],VALUES[8],VALUES[9],VALUES[11],VALUES[13],VALUES[15]},0,9);
  Delete delete=new Delete(ROW);
  delete.addColumn(FAMILY,QUALIFIER,STAMPS[11]);
  delete.addColumn(FAMILY,QUALIFIER,STAMPS[7]);
  ht.delete(delete);
  get=new Get(ROW);
  get.addColumn(FAMILY,QUALIFIER);
  get.setMaxVersions(Integer.MAX_VALUE);
  result=ht.get(get);
  assertNResult(result,ROW,FAMILY,QUALIFIER,new long[]{STAMPS[1],STAMPS[2],STAMPS[3],STAMPS[4],STAMPS[5],STAMPS[6],STAMPS[8],STAMPS[9],STAMPS[13],STAMPS[15]},new byte[][]{VALUES[1],VALUES[2],VALUES[3],VALUES[4],VALUES[5],VALUES[6],VALUES[8],VALUES[9],VALUES[13],VALUES[15]},0,9);
  scan=new Scan(ROW);
  scan.addColumn(FAMILY,QUALIFIER);
  scan.setMaxVersions(Integer.MAX_VALUE);
  result=getSingleScanResult(ht,scan);
  assertNResult(result,ROW,FAMILY,QUALIFIER,new long[]{STAMPS[1],STAMPS[2],STAMPS[3],STAMPS[4],STAMPS[5],STAMPS[6],STAMPS[8],STAMPS[9],STAMPS[13],STAMPS[15]},new byte[][]{VALUES[1],VALUES[2],VALUES[3],VALUES[4],VALUES[5],VALUES[6],VALUES[8],VALUES[9],VALUES[13],VALUES[15]},0,9);
}

</code></pre>

<pre class="type-2 type-14 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Allocates resources before the execution of the test cases">TestInitializer</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Is an empty test case">EmptyTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Allocates resources before the execution of the test cases
- Is an empty test case
"></span><br>
/** 
 * @throws java.lang.Exception
 */
@Before public void setUp() throws Exception {
}

</code></pre>

<pre class="type-7 type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
"></span><br>
@Test public void testGet_EmptyTable() throws IOException {
  Table table=TEST_UTIL.createTable(TableName.valueOf("testGet_EmptyTable"),FAMILY);
  Get get=new Get(ROW);
  get.addFamily(FAMILY);
  Result r=table.get(get);
  assertTrue(r.isEmpty());
}

</code></pre>

<pre class="type-4 type-11 type-8 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testIllegalTableDescriptor() throws Exception {
  HTableDescriptor htd=new HTableDescriptor(TableName.valueOf("testIllegalTableDescriptor"));
  HColumnDescriptor hcd=new HColumnDescriptor(FAMILY);
  checkTableIsIllegal(htd);
  htd.addFamily(hcd);
  checkTableIsLegal(htd);
  htd.setMaxFileSize(1024);
  checkTableIsIllegal(htd);
  htd.setMaxFileSize(0);
  checkTableIsIllegal(htd);
  htd.setMaxFileSize(1024 * 1024 * 1024);
  checkTableIsLegal(htd);
  htd.setMemStoreFlushSize(1024);
  checkTableIsIllegal(htd);
  htd.setMemStoreFlushSize(0);
  checkTableIsIllegal(htd);
  htd.setMemStoreFlushSize(128 * 1024 * 1024);
  checkTableIsLegal(htd);
  htd.setRegionSplitPolicyClassName("nonexisting.foo.class");
  checkTableIsIllegal(htd);
  htd.setRegionSplitPolicyClassName(null);
  checkTableIsLegal(htd);
  hcd.setBlocksize(0);
  checkTableIsIllegal(htd);
  hcd.setBlocksize(1024 * 1024 * 128);
  checkTableIsIllegal(htd);
  hcd.setBlocksize(1024);
  checkTableIsLegal(htd);
  hcd.setTimeToLive(0);
  checkTableIsIllegal(htd);
  hcd.setTimeToLive(-1);
  checkTableIsIllegal(htd);
  hcd.setTimeToLive(1);
  checkTableIsLegal(htd);
  hcd.setMinVersions(-1);
  checkTableIsIllegal(htd);
  hcd.setMinVersions(3);
  try {
    hcd.setMaxVersions(2);
    fail();
  }
 catch (  IllegalArgumentException ex) {
    hcd.setMaxVersions(10);
  }
  checkTableIsLegal(htd);
  hcd.setMaxVersions(4);
  hcd.setMinVersions(5);
  checkTableIsIllegal(htd);
  hcd.setMinVersions(3);
  hcd.setScope(-1);
  checkTableIsIllegal(htd);
  hcd.setScope(0);
  checkTableIsLegal(htd);
  try {
    hcd.setDFSReplication((short)-1);
    fail("Illegal value for setDFSReplication did not throw");
  }
 catch (  IllegalArgumentException e) {
  }
  hcd.setValue(HColumnDescriptor.DFS_REPLICATION,"-1");
  checkTableIsIllegal(htd);
  try {
    hcd.setDFSReplication((short)-1);
    fail("Should throw exception if an illegal value is explicitly being set");
  }
 catch (  IllegalArgumentException e) {
  }
  htd.setMemStoreFlushSize(0);
  ListAppender listAppender=new ListAppender();
  Logger log=Logger.getLogger(HMaster.class);
  log.addAppender(listAppender);
  log.setLevel(Level.WARN);
  htd.setConfiguration("hbase.table.sanity.checks",Boolean.FALSE.toString());
  checkTableIsLegal(htd);
  assertFalse(listAppender.getMessages().isEmpty());
  assertTrue(listAppender.getMessages().get(0).startsWith("MEMSTORE_FLUSHSIZE for table " + "descriptor or \"hbase.hregion.memstore.flush.size\" (0) is too small, which might " + "cause very frequent flushing."));
  log.removeAppender(listAppender);
}

</code></pre>

<pre class="type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies whether objects/variable are equal to an expected value 
"></span><br>
@Test public void testRawScanRespectsVersions() throws Exception {
  TableName TABLE=TableName.valueOf("testRawScan");
  Table table=TEST_UTIL.createTable(TABLE,FAMILY);
  byte[] row=Bytes.toBytes("row");
  Put p=new Put(row);
  p.addColumn(FAMILY,QUALIFIER,(long)10,VALUE);
  table.put(p);
  p=new Put(row);
  p.addColumn(FAMILY,QUALIFIER,(long)11,ArrayUtils.add(VALUE,(byte)2));
  table.put(p);
  p=new Put(row);
  p.addColumn(FAMILY,QUALIFIER,(long)12,ArrayUtils.add(VALUE,(byte)3));
  table.put(p);
  p=new Put(row);
  p.addColumn(FAMILY,QUALIFIER,(long)13,ArrayUtils.add(VALUE,(byte)4));
  table.put(p);
  int versions=4;
  Scan s=new Scan(row);
  s.setMaxVersions();
  s.setRaw(true);
  ResultScanner scanner=table.getScanner(s);
  int count=0;
  for (  Result r : scanner) {
    assertEquals("Found an unexpected number of results for the row!",versions,r.listCells().size());
    count++;
  }
  assertEquals("Found more than a single row when raw scanning the table with a single row!",1,count);
  scanner.close();
  versions=2;
  s.setMaxVersions(versions);
  scanner=table.getScanner(s);
  count=0;
  for (  Result r : scanner) {
    assertEquals("Found an unexpected number of results for the row!",versions,r.listCells().size());
    count++;
  }
  assertEquals("Found more than a single row when raw scanning the table with a single row!",1,count);
  scanner.close();
  versions=3;
  s.setMaxVersions(versions);
  scanner=table.getScanner(s);
  count=0;
  for (  Result r : scanner) {
    assertEquals("Found an unexpected number of results for the row!",versions,r.listCells().size());
    count++;
  }
  assertEquals("Found more than a single row when raw scanning the table with a single row!",1,count);
  scanner.close();
  table.close();
  TEST_UTIL.deleteTable(TABLE);
}

</code></pre>

<pre class="type-7 type-8 type-5 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testFilterWithLongCompartor() throws Exception {
  TableName TABLE=TableName.valueOf("testFilterWithLongCompartor");
  Table ht=TEST_UTIL.createTable(TABLE,FAMILY);
  byte[][] ROWS=makeN(ROW,10);
  byte[][] values=new byte[10][];
  for (int i=0; i < 10; i++) {
    values[i]=Bytes.toBytes(100L * i);
  }
  for (int i=0; i < 10; i++) {
    Put put=new Put(ROWS[i]);
    put.setDurability(Durability.SKIP_WAL);
    put.addColumn(FAMILY,QUALIFIER,values[i]);
    ht.put(put);
  }
  Scan scan=new Scan();
  scan.addFamily(FAMILY);
  Filter filter=new SingleColumnValueFilter(FAMILY,QUALIFIER,CompareOp.GREATER,new LongComparator(500));
  scan.setFilter(filter);
  ResultScanner scanner=ht.getScanner(scan);
  int expectedIndex=0;
  for (  Result result : ht.getScanner(scan)) {
    assertEquals(result.size(),1);
    assertTrue(Bytes.toLong(result.getValue(FAMILY,QUALIFIER)) > 500);
    expectedIndex++;
  }
  assertEquals(expectedIndex,4);
  scanner.close();
}

</code></pre>

<pre class="type-14 type-18 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Is an empty test case">EmptyTester</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Is not executed with the test suite">IgnoredMethod</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Is an empty test case
- Is not executed with the test suite
"></span><br>
@Ignore @Test public void testMillions() throws Exception {
}

</code></pre>

<pre class="type-4 type-7 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
"></span><br>
/** 
 * Test from client side of an involved filter against a multi family that
 * involves deletes.
 * @throws Exception
 */
@Test public void testWeirdCacheBehaviour() throws Exception {
  TableName TABLE=TableName.valueOf("testWeirdCacheBehaviour");
  byte[][] FAMILIES=new byte[][]{Bytes.toBytes("trans-blob"),Bytes.toBytes("trans-type"),Bytes.toBytes("trans-date"),Bytes.toBytes("trans-tags"),Bytes.toBytes("trans-group")};
  Table ht=TEST_UTIL.createTable(TABLE,FAMILIES);
  String value="this is the value";
  String value2="this is some other value";
  String keyPrefix1=UUID.randomUUID().toString();
  String keyPrefix2=UUID.randomUUID().toString();
  String keyPrefix3=UUID.randomUUID().toString();
  putRows(ht,3,value,keyPrefix1);
  putRows(ht,3,value,keyPrefix2);
  putRows(ht,3,value,keyPrefix3);
  putRows(ht,3,value2,keyPrefix1);
  putRows(ht,3,value2,keyPrefix2);
  putRows(ht,3,value2,keyPrefix3);
  Table table=TEST_UTIL.getConnection().getTable(TABLE);
  System.out.println("Checking values for key: " + keyPrefix1);
  assertEquals("Got back incorrect number of rows from scan",3,getNumberOfRows(keyPrefix1,value2,table));
  System.out.println("Checking values for key: " + keyPrefix2);
  assertEquals("Got back incorrect number of rows from scan",3,getNumberOfRows(keyPrefix2,value2,table));
  System.out.println("Checking values for key: " + keyPrefix3);
  assertEquals("Got back incorrect number of rows from scan",3,getNumberOfRows(keyPrefix3,value2,table));
  deleteColumns(ht,value2,keyPrefix1);
  deleteColumns(ht,value2,keyPrefix2);
  deleteColumns(ht,value2,keyPrefix3);
  System.out.println("Starting important checks.....");
  assertEquals("Got back incorrect number of rows from scan: " + keyPrefix1,0,getNumberOfRows(keyPrefix1,value2,table));
  assertEquals("Got back incorrect number of rows from scan: " + keyPrefix2,0,getNumberOfRows(keyPrefix2,value2,table));
  assertEquals("Got back incorrect number of rows from scan: " + keyPrefix3,0,getNumberOfRows(keyPrefix3,value2,table));
}

</code></pre>

<pre class="type-1 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * HBASE-1014
 * commit(BatchUpdate) method should return timestamp
 */
@Test public void testJiraTest1014() throws Exception {
  TableName TABLE=TableName.valueOf("testJiraTest1014");
  Table ht=TEST_UTIL.createTable(TABLE,FAMILY,10);
  long manualStamp=12345;
  Put put=new Put(ROW);
  put.addColumn(FAMILY,QUALIFIER,manualStamp,VALUE);
  ht.put(put);
  getVersionAndVerify(ht,ROW,FAMILY,QUALIFIER,manualStamp,VALUE);
  getVersionAndVerifyMissing(ht,ROW,FAMILY,QUALIFIER,manualStamp - 1);
  getVersionAndVerifyMissing(ht,ROW,FAMILY,QUALIFIER,manualStamp + 1);
}

</code></pre>

<pre class="type-3 type-14 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Releases resources used by the test cases">TestCleaner</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Is an empty test case">EmptyTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Releases resources used by the test cases
- Is an empty test case
"></span><br>
/** 
 * @throws java.lang.Exception
 */
@After public void tearDown() throws Exception {
}

</code></pre>

<pre class="type-7 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
"></span><br>
@Test public void testCheckAndDeleteWithCompareOp() throws IOException {
  final byte[] value1=Bytes.toBytes("aaaa");
  final byte[] value2=Bytes.toBytes("bbbb");
  final byte[] value3=Bytes.toBytes("cccc");
  final byte[] value4=Bytes.toBytes("dddd");
  Table table=TEST_UTIL.createTable(TableName.valueOf("testCheckAndDeleteWithCompareOp"),FAMILY);
  Put put2=new Put(ROW);
  put2.addColumn(FAMILY,QUALIFIER,value2);
  table.put(put2);
  Put put3=new Put(ROW);
  put3.addColumn(FAMILY,QUALIFIER,value3);
  Delete delete=new Delete(ROW);
  delete.addColumns(FAMILY,QUALIFIER);
  boolean ok=table.checkAndDelete(ROW,FAMILY,QUALIFIER,CompareOp.GREATER,value1,delete);
  assertEquals(ok,false);
  ok=table.checkAndDelete(ROW,FAMILY,QUALIFIER,CompareOp.EQUAL,value1,delete);
  assertEquals(ok,false);
  ok=table.checkAndDelete(ROW,FAMILY,QUALIFIER,CompareOp.GREATER_OR_EQUAL,value1,delete);
  assertEquals(ok,false);
  ok=table.checkAndDelete(ROW,FAMILY,QUALIFIER,CompareOp.LESS,value1,delete);
  assertEquals(ok,true);
  table.put(put2);
  ok=table.checkAndDelete(ROW,FAMILY,QUALIFIER,CompareOp.LESS_OR_EQUAL,value1,delete);
  assertEquals(ok,true);
  table.put(put2);
  ok=table.checkAndDelete(ROW,FAMILY,QUALIFIER,CompareOp.NOT_EQUAL,value1,delete);
  assertEquals(ok,true);
  table.put(put3);
  ok=table.checkAndDelete(ROW,FAMILY,QUALIFIER,CompareOp.LESS,value4,delete);
  assertEquals(ok,false);
  ok=table.checkAndDelete(ROW,FAMILY,QUALIFIER,CompareOp.LESS_OR_EQUAL,value4,delete);
  assertEquals(ok,false);
  ok=table.checkAndDelete(ROW,FAMILY,QUALIFIER,CompareOp.EQUAL,value4,delete);
  assertEquals(ok,false);
  ok=table.checkAndDelete(ROW,FAMILY,QUALIFIER,CompareOp.GREATER,value4,delete);
  assertEquals(ok,true);
  table.put(put3);
  ok=table.checkAndDelete(ROW,FAMILY,QUALIFIER,CompareOp.GREATER_OR_EQUAL,value4,delete);
  assertEquals(ok,true);
  table.put(put3);
  ok=table.checkAndDelete(ROW,FAMILY,QUALIFIER,CompareOp.NOT_EQUAL,value4,delete);
  assertEquals(ok,true);
  table.put(put2);
  ok=table.checkAndDelete(ROW,FAMILY,QUALIFIER,CompareOp.GREATER,value2,delete);
  assertEquals(ok,false);
  ok=table.checkAndDelete(ROW,FAMILY,QUALIFIER,CompareOp.NOT_EQUAL,value2,delete);
  assertEquals(ok,false);
  ok=table.checkAndDelete(ROW,FAMILY,QUALIFIER,CompareOp.LESS,value2,delete);
  assertEquals(ok,false);
  ok=table.checkAndDelete(ROW,FAMILY,QUALIFIER,CompareOp.GREATER_OR_EQUAL,value2,delete);
  assertEquals(ok,true);
  table.put(put2);
  ok=table.checkAndDelete(ROW,FAMILY,QUALIFIER,CompareOp.LESS_OR_EQUAL,value2,delete);
  assertEquals(ok,true);
  table.put(put2);
  ok=table.checkAndDelete(ROW,FAMILY,QUALIFIER,CompareOp.EQUAL,value2,delete);
  assertEquals(ok,true);
}

</code></pre>

<pre class="type-7 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
"></span><br>
@Test public void testMultiRowMutation() throws Exception {
  LOG.info("Starting testMultiRowMutation");
  final TableName TABLENAME=TableName.valueOf("testMultiRowMutation");
  final byte[] ROW1=Bytes.toBytes("testRow1");
  Table t=TEST_UTIL.createTable(TABLENAME,FAMILY);
  Put p=new Put(ROW);
  p.addColumn(FAMILY,QUALIFIER,VALUE);
  MutationProto m1=ProtobufUtil.toMutation(MutationType.PUT,p);
  p=new Put(ROW1);
  p.addColumn(FAMILY,QUALIFIER,VALUE);
  MutationProto m2=ProtobufUtil.toMutation(MutationType.PUT,p);
  MutateRowsRequest.Builder mrmBuilder=MutateRowsRequest.newBuilder();
  mrmBuilder.addMutationRequest(m1);
  mrmBuilder.addMutationRequest(m2);
  MutateRowsRequest mrm=mrmBuilder.build();
  CoprocessorRpcChannel channel=t.coprocessorService(ROW);
  MultiRowMutationService.BlockingInterface service=MultiRowMutationService.newBlockingStub(channel);
  service.mutateRows(null,mrm);
  Get g=new Get(ROW);
  Result r=t.get(g);
  assertEquals(0,Bytes.compareTo(VALUE,r.getValue(FAMILY,QUALIFIER)));
  g=new Get(ROW1);
  r=t.get(g);
  assertEquals(0,Bytes.compareTo(VALUE,r.getValue(FAMILY,QUALIFIER)));
}

</code></pre>

<pre class="type-7 type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
"></span><br>
/** 
 * simple test that just executes parts of the client
 * API that accept a pre-created HConnection instance
 * @throws IOException
 */
@Test public void testUnmanagedHConnection() throws IOException {
  final TableName tableName=TableName.valueOf("testUnmanagedHConnection");
  TEST_UTIL.createTable(tableName,HConstants.CATALOG_FAMILY);
  Connection conn=ConnectionFactory.createConnection(TEST_UTIL.getConfiguration());
  Table t=conn.getTable(tableName);
  Admin admin=conn.getAdmin();
  assertTrue(admin.tableExists(tableName));
  assertTrue(t.get(new Get(ROW)).isEmpty());
  admin.close();
}

</code></pre>

<pre class="type-7 type-13 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
"></span><br>
@Test public void testFilterAllRecords() throws IOException {
  Scan scan=new Scan();
  scan.setBatch(1);
  scan.setCaching(1);
  scan.setFilter(new FilterList(new FirstKeyOnlyFilter(),new InclusiveStopFilter(new byte[0])));
  try (Table table=TEST_UTIL.getConnection().getTable(TableName.NAMESPACE_TABLE_NAME)){
    try (ResultScanner s=table.getScanner(scan)){
      assertNull(s.next());
    }
   }
 }

</code></pre>

<pre class="type-1 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * HBASE-1182
 * Scan for columns > some timestamp
 */
@Test public void testJiraTest1182() throws Exception {
  TableName TABLE=TableName.valueOf("testJiraTest1182");
  byte[][] VALUES=makeNAscii(VALUE,7);
  long[] STAMPS=makeStamps(7);
  Table ht=TEST_UTIL.createTable(TABLE,FAMILY,10);
  Put put=new Put(ROW);
  put.addColumn(FAMILY,QUALIFIER,STAMPS[0],VALUES[0]);
  put.addColumn(FAMILY,QUALIFIER,STAMPS[1],VALUES[1]);
  put.addColumn(FAMILY,QUALIFIER,STAMPS[2],VALUES[2]);
  put.addColumn(FAMILY,QUALIFIER,STAMPS[3],VALUES[3]);
  put.addColumn(FAMILY,QUALIFIER,STAMPS[4],VALUES[4]);
  put.addColumn(FAMILY,QUALIFIER,STAMPS[5],VALUES[5]);
  ht.put(put);
  getVersionRangeAndVerifyGreaterThan(ht,ROW,FAMILY,QUALIFIER,STAMPS,VALUES,0,5);
  getVersionRangeAndVerifyGreaterThan(ht,ROW,FAMILY,QUALIFIER,STAMPS,VALUES,2,5);
  getVersionRangeAndVerifyGreaterThan(ht,ROW,FAMILY,QUALIFIER,STAMPS,VALUES,4,5);
  scanVersionRangeAndVerifyGreaterThan(ht,ROW,FAMILY,QUALIFIER,STAMPS,VALUES,0,5);
  scanVersionRangeAndVerifyGreaterThan(ht,ROW,FAMILY,QUALIFIER,STAMPS,VALUES,2,5);
  scanVersionRangeAndVerifyGreaterThan(ht,ROW,FAMILY,QUALIFIER,STAMPS,VALUES,4,5);
  TEST_UTIL.flush();
  getVersionRangeAndVerifyGreaterThan(ht,ROW,FAMILY,QUALIFIER,STAMPS,VALUES,0,5);
  getVersionRangeAndVerifyGreaterThan(ht,ROW,FAMILY,QUALIFIER,STAMPS,VALUES,2,5);
  getVersionRangeAndVerifyGreaterThan(ht,ROW,FAMILY,QUALIFIER,STAMPS,VALUES,4,5);
  scanVersionRangeAndVerifyGreaterThan(ht,ROW,FAMILY,QUALIFIER,STAMPS,VALUES,0,5);
  scanVersionRangeAndVerifyGreaterThan(ht,ROW,FAMILY,QUALIFIER,STAMPS,VALUES,2,5);
  scanVersionRangeAndVerifyGreaterThan(ht,ROW,FAMILY,QUALIFIER,STAMPS,VALUES,4,5);
}

</code></pre>

<pre class="type-7 type-16 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether two objects/variables are the same">IdentityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies whether two objects/variables are the same
"></span><br>
/** 
 * Verifies that getConfiguration returns the same Configuration object used
 * to create the HTable instance.
 */
@Test public void testGetConfiguration() throws Exception {
  TableName TABLE=TableName.valueOf("testGetConfiguration");
  byte[][] FAMILIES=new byte[][]{Bytes.toBytes("foo")};
  Configuration conf=TEST_UTIL.getConfiguration();
  Table table=TEST_UTIL.createTable(TABLE,FAMILIES);
  assertSame(conf,table.getConfiguration());
}

</code></pre>

<pre class="type-7 type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
"></span><br>
/** 
 * test of that unmanaged HConnections are able to reconnect
 * properly (see HBASE-5058)
 * @throws Exception
 */
@Test public void testUnmanagedHConnectionReconnect() throws Exception {
  final TableName tableName=TableName.valueOf("testUnmanagedHConnectionReconnect");
  TEST_UTIL.createTable(tableName,HConstants.CATALOG_FAMILY);
  Connection conn=ConnectionFactory.createConnection(TEST_UTIL.getConfiguration());
  Table t=conn.getTable(tableName);
  try (Admin admin=conn.getAdmin()){
    assertTrue(admin.tableExists(tableName));
    assertTrue(t.get(new Get(ROW)).isEmpty());
  }
   MiniHBaseCluster cluster=TEST_UTIL.getHBaseCluster();
  cluster.stopMaster(0,false);
  cluster.waitOnMaster(0);
  cluster.startMaster();
  assertTrue(cluster.waitForActiveAndReadyMaster());
  try (Admin admin=conn.getAdmin()){
    assertTrue(admin.tableExists(tableName));
    assertTrue(admin.getClusterStatus().getServersSize() == SLAVES + 1);
  }
 }

</code></pre>

<pre class="type-4 type-7 type-8 type-13 type-5 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects are null
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testNonCachedGetRegionLocation() throws Exception {
  TableName TABLE=TableName.valueOf("testNonCachedGetRegionLocation");
  byte[] family1=Bytes.toBytes("f1");
  byte[] family2=Bytes.toBytes("f2");
  try (Table table=TEST_UTIL.createTable(TABLE,new byte[][]{family1,family2},10);Admin admin=TEST_UTIL.getHBaseAdmin();RegionLocator locator=TEST_UTIL.getConnection().getRegionLocator(TABLE)){
    List<HRegionLocation> allRegionLocations=locator.getAllRegionLocations();
    assertEquals(1,allRegionLocations.size());
    HRegionInfo regionInfo=allRegionLocations.get(0).getRegionInfo();
    ServerName addrBefore=allRegionLocations.get(0).getServerName();
    HRegionLocation addrCache=locator.getRegionLocation(regionInfo.getStartKey(),false);
    HRegionLocation addrNoCache=locator.getRegionLocation(regionInfo.getStartKey(),true);
    assertEquals(addrBefore.getPort(),addrCache.getPort());
    assertEquals(addrBefore.getPort(),addrNoCache.getPort());
    ServerName addrAfter=null;
    for (int i=0; i < SLAVES; i++) {
      HRegionServer regionServer=TEST_UTIL.getHBaseCluster().getRegionServer(i);
      ServerName addr=regionServer.getServerName();
      if (addr.getPort() != addrBefore.getPort()) {
        admin.move(regionInfo.getEncodedNameAsBytes(),Bytes.toBytes(addr.toString()));
        Thread.sleep(5000);
        addrAfter=addr;
        break;
      }
    }
    addrCache=locator.getRegionLocation(regionInfo.getStartKey(),false);
    addrNoCache=locator.getRegionLocation(regionInfo.getStartKey(),true);
    assertNotNull(addrAfter);
    assertTrue(addrAfter.getPort() != addrCache.getPort());
    assertEquals(addrAfter.getPort(),addrNoCache.getPort());
  }
 }

</code></pre>

<pre class="type-4 type-7 type-8 type-5 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testPut() throws IOException {
  final byte[] CONTENTS_FAMILY=Bytes.toBytes("contents");
  final byte[] SMALL_FAMILY=Bytes.toBytes("smallfam");
  final byte[] row1=Bytes.toBytes("row1");
  final byte[] row2=Bytes.toBytes("row2");
  final byte[] value=Bytes.toBytes("abcd");
  Table table=TEST_UTIL.createTable(TableName.valueOf("testPut"),new byte[][]{CONTENTS_FAMILY,SMALL_FAMILY});
  Put put=new Put(row1);
  put.addColumn(CONTENTS_FAMILY,null,value);
  table.put(put);
  put=new Put(row2);
  put.addColumn(CONTENTS_FAMILY,null,value);
  assertEquals(put.size(),1);
  assertEquals(put.getFamilyCellMap().get(CONTENTS_FAMILY).size(),1);
  KeyValue kv=(KeyValue)put.getFamilyCellMap().get(CONTENTS_FAMILY).get(0);
  assertTrue(Bytes.equals(CellUtil.cloneFamily(kv),CONTENTS_FAMILY));
  assertTrue(Bytes.equals(CellUtil.cloneQualifier(kv),new byte[0]));
  assertTrue(Bytes.equals(CellUtil.cloneValue(kv),value));
  table.put(put);
  Scan scan=new Scan();
  scan.addColumn(CONTENTS_FAMILY,null);
  ResultScanner scanner=table.getScanner(scan);
  for (  Result r : scanner) {
    for (    Cell key : r.rawCells()) {
      System.out.println(Bytes.toString(r.getRow()) + ": " + key.toString());
    }
  }
}

</code></pre>

<pre class="type-1 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
@Test public void testDeleteFamilyVersion() throws Exception {
  Admin admin=TEST_UTIL.getHBaseAdmin();
  TableName TABLE=TableName.valueOf("testDeleteFamilyVersion");
  byte[][] QUALIFIERS=makeNAscii(QUALIFIER,1);
  byte[][] VALUES=makeN(VALUE,5);
  long[] ts={1000,2000,3000,4000,5000};
  Table ht=TEST_UTIL.createTable(TABLE,FAMILY,5);
  Put put=new Put(ROW);
  for (int q=0; q < 1; q++)   for (int t=0; t < 5; t++)   put.addColumn(FAMILY,QUALIFIERS[q],ts[t],VALUES[t]);
  ht.put(put);
  admin.flush(TABLE);
  Delete delete=new Delete(ROW);
  delete.addFamilyVersion(FAMILY,ts[1]);
  delete.addFamilyVersion(FAMILY,ts[3]);
  ht.delete(delete);
  admin.flush(TABLE);
  for (int i=0; i < 1; i++) {
    Get get=new Get(ROW);
    get.addColumn(FAMILY,QUALIFIERS[i]);
    get.setMaxVersions(Integer.MAX_VALUE);
    Result result=ht.get(get);
    assertNResult(result,ROW,FAMILY,QUALIFIERS[i],new long[]{ts[0],ts[2],ts[4]},new byte[][]{VALUES[0],VALUES[2],VALUES[4]},0,2);
  }
  ht.close();
  admin.close();
}

</code></pre>

<pre class="type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies whether objects/variable are equal to an expected value 
"></span><br>
@Test public void testRowsPutBufferedManyManyFlushes() throws IOException {
  final byte[] CONTENTS_FAMILY=Bytes.toBytes("contents");
  final byte[] SMALL_FAMILY=Bytes.toBytes("smallfam");
  final byte[] value=Bytes.toBytes("abcd");
  final int NB_BATCH_ROWS=10;
  Table table=TEST_UTIL.createTable(TableName.valueOf("testRowsPutBufferedManyManyFlushes"),new byte[][]{CONTENTS_FAMILY,SMALL_FAMILY});
  table.setWriteBufferSize(10);
  ArrayList<Put> rowsUpdate=new ArrayList<Put>();
  for (int i=0; i < NB_BATCH_ROWS * 10; i++) {
    byte[] row=Bytes.toBytes("row" + i);
    Put put=new Put(row);
    put.setDurability(Durability.SKIP_WAL);
    put.addColumn(CONTENTS_FAMILY,null,value);
    rowsUpdate.add(put);
  }
  table.put(rowsUpdate);
  Scan scan=new Scan();
  scan.addFamily(CONTENTS_FAMILY);
  ResultScanner scanner=table.getScanner(scan);
  int nbRows=0;
  for (  @SuppressWarnings("unused") Result row : scanner)   nbRows++;
  assertEquals(NB_BATCH_ROWS * 10,nbRows);
}

</code></pre>

<pre class="type-4 type-10 type-7 type-8 type-13 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions inside branch conditions
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testGetClosestRowBefore() throws IOException, InterruptedException {
  final TableName tableName=TableName.valueOf("testGetClosestRowBefore");
  final byte[] firstRow=Bytes.toBytes("row111");
  final byte[] secondRow=Bytes.toBytes("row222");
  final byte[] thirdRow=Bytes.toBytes("row333");
  final byte[] forthRow=Bytes.toBytes("row444");
  final byte[] beforeFirstRow=Bytes.toBytes("row");
  final byte[] beforeSecondRow=Bytes.toBytes("row22");
  final byte[] beforeThirdRow=Bytes.toBytes("row33");
  final byte[] beforeForthRow=Bytes.toBytes("row44");
  try (Table t=TEST_UTIL.createTable(tableName,new byte[][]{HConstants.CATALOG_FAMILY,Bytes.toBytes("info2")},1,1024);RegionLocator locator=TEST_UTIL.getConnection().getRegionLocator(tableName)){
    if (t instanceof HTableInterface) {
      HTableInterface table=(HTableInterface)t;
      String regionName=locator.getAllRegionLocations().get(0).getRegionInfo().getEncodedName();
      Region region=TEST_UTIL.getRSForFirstRegionInTable(tableName).getFromOnlineRegions(regionName);
      Put put1=new Put(firstRow);
      Put put2=new Put(secondRow);
      Put put3=new Put(thirdRow);
      Put put4=new Put(forthRow);
      byte[] one=new byte[]{1};
      byte[] two=new byte[]{2};
      byte[] three=new byte[]{3};
      byte[] four=new byte[]{4};
      put1.addColumn(HConstants.CATALOG_FAMILY,null,one);
      put2.addColumn(HConstants.CATALOG_FAMILY,null,two);
      put3.addColumn(HConstants.CATALOG_FAMILY,null,three);
      put4.addColumn(HConstants.CATALOG_FAMILY,null,four);
      table.put(put1);
      table.put(put2);
      table.put(put3);
      table.put(put4);
      region.flush(true);
      Result result;
      result=getReverseScanResult(table,beforeFirstRow,HConstants.CATALOG_FAMILY);
      assertNull(result);
      result=getReverseScanResult(table,firstRow,HConstants.CATALOG_FAMILY);
      assertTrue(result.containsColumn(HConstants.CATALOG_FAMILY,null));
      assertTrue(Bytes.equals(result.getRow(),firstRow));
      assertTrue(Bytes.equals(result.getValue(HConstants.CATALOG_FAMILY,null),one));
      result=getReverseScanResult(table,beforeSecondRow,HConstants.CATALOG_FAMILY);
      assertTrue(result.containsColumn(HConstants.CATALOG_FAMILY,null));
      assertTrue(Bytes.equals(result.getRow(),firstRow));
      assertTrue(Bytes.equals(result.getValue(HConstants.CATALOG_FAMILY,null),one));
      result=getReverseScanResult(table,secondRow,HConstants.CATALOG_FAMILY);
      assertTrue(result.containsColumn(HConstants.CATALOG_FAMILY,null));
      assertTrue(Bytes.equals(result.getRow(),secondRow));
      assertTrue(Bytes.equals(result.getValue(HConstants.CATALOG_FAMILY,null),two));
      result=getReverseScanResult(table,beforeThirdRow,HConstants.CATALOG_FAMILY);
      assertTrue(result.containsColumn(HConstants.CATALOG_FAMILY,null));
      assertTrue(Bytes.equals(result.getRow(),secondRow));
      assertTrue(Bytes.equals(result.getValue(HConstants.CATALOG_FAMILY,null),two));
      result=getReverseScanResult(table,thirdRow,HConstants.CATALOG_FAMILY);
      assertTrue(result.containsColumn(HConstants.CATALOG_FAMILY,null));
      assertTrue(Bytes.equals(result.getRow(),thirdRow));
      assertTrue(Bytes.equals(result.getValue(HConstants.CATALOG_FAMILY,null),three));
      result=getReverseScanResult(table,beforeForthRow,HConstants.CATALOG_FAMILY);
      assertTrue(result.containsColumn(HConstants.CATALOG_FAMILY,null));
      assertTrue(Bytes.equals(result.getRow(),thirdRow));
      assertTrue(Bytes.equals(result.getValue(HConstants.CATALOG_FAMILY,null),three));
      result=getReverseScanResult(table,forthRow,HConstants.CATALOG_FAMILY);
      assertTrue(result.containsColumn(HConstants.CATALOG_FAMILY,null));
      assertTrue(Bytes.equals(result.getRow(),forthRow));
      assertTrue(Bytes.equals(result.getValue(HConstants.CATALOG_FAMILY,null),four));
      result=getReverseScanResult(table,Bytes.add(forthRow,one),HConstants.CATALOG_FAMILY);
      assertTrue(result.containsColumn(HConstants.CATALOG_FAMILY,null));
      assertTrue(Bytes.equals(result.getRow(),forthRow));
      assertTrue(Bytes.equals(result.getValue(HConstants.CATALOG_FAMILY,null),four));
    }
  }
 }

</code></pre>

<pre class="type-4 type-9 type-7 type-8 type-5 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions in iterations
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testDeletes() throws Exception {
  TableName TABLE=TableName.valueOf("testDeletes");
  byte[][] ROWS=makeNAscii(ROW,6);
  byte[][] FAMILIES=makeNAscii(FAMILY,3);
  byte[][] VALUES=makeN(VALUE,5);
  long[] ts={1000,2000,3000,4000,5000};
  Table ht=TEST_UTIL.createTable(TABLE,FAMILIES,3);
  Put put=new Put(ROW);
  put.addColumn(FAMILIES[0],QUALIFIER,ts[0],VALUES[0]);
  put.addColumn(FAMILIES[0],QUALIFIER,ts[1],VALUES[1]);
  ht.put(put);
  Delete delete=new Delete(ROW);
  delete.addFamily(FAMILIES[0],ts[0]);
  ht.delete(delete);
  Get get=new Get(ROW);
  get.addFamily(FAMILIES[0]);
  get.setMaxVersions(Integer.MAX_VALUE);
  Result result=ht.get(get);
  assertNResult(result,ROW,FAMILIES[0],QUALIFIER,new long[]{ts[1]},new byte[][]{VALUES[1]},0,0);
  Scan scan=new Scan(ROW);
  scan.addFamily(FAMILIES[0]);
  scan.setMaxVersions(Integer.MAX_VALUE);
  result=getSingleScanResult(ht,scan);
  assertNResult(result,ROW,FAMILIES[0],QUALIFIER,new long[]{ts[1]},new byte[][]{VALUES[1]},0,0);
  put=new Put(ROW);
  put.addColumn(FAMILIES[0],QUALIFIER,ts[4],VALUES[4]);
  put.addColumn(FAMILIES[0],QUALIFIER,ts[2],VALUES[2]);
  put.addColumn(FAMILIES[0],QUALIFIER,ts[3],VALUES[3]);
  put.addColumn(FAMILIES[0],null,ts[4],VALUES[4]);
  put.addColumn(FAMILIES[0],null,ts[2],VALUES[2]);
  put.addColumn(FAMILIES[0],null,ts[3],VALUES[3]);
  ht.put(put);
  delete=new Delete(ROW);
  delete.addColumn(FAMILIES[0],QUALIFIER);
  ht.delete(delete);
  get=new Get(ROW);
  get.addColumn(FAMILIES[0],QUALIFIER);
  get.setMaxVersions(Integer.MAX_VALUE);
  result=ht.get(get);
  assertNResult(result,ROW,FAMILIES[0],QUALIFIER,new long[]{ts[1],ts[2],ts[3]},new byte[][]{VALUES[1],VALUES[2],VALUES[3]},0,2);
  scan=new Scan(ROW);
  scan.addColumn(FAMILIES[0],QUALIFIER);
  scan.setMaxVersions(Integer.MAX_VALUE);
  result=getSingleScanResult(ht,scan);
  assertNResult(result,ROW,FAMILIES[0],QUALIFIER,new long[]{ts[1],ts[2],ts[3]},new byte[][]{VALUES[1],VALUES[2],VALUES[3]},0,2);
  delete=new Delete(ROW);
  delete.addColumn(FAMILIES[0],null);
  ht.delete(delete);
  delete=new Delete(ROW);
  delete.addColumns(FAMILIES[0],null);
  ht.delete(delete);
  put=new Put(ROW);
  put.addColumn(FAMILIES[0],QUALIFIER,ts[0],VALUES[0]);
  put.addColumn(FAMILIES[0],QUALIFIER,ts[4],VALUES[4]);
  ht.put(put);
  get=new Get(ROW);
  get.addFamily(FAMILIES[0]);
  get.setMaxVersions(Integer.MAX_VALUE);
  result=ht.get(get);
  assertNResult(result,ROW,FAMILIES[0],QUALIFIER,new long[]{ts[1],ts[2],ts[3]},new byte[][]{VALUES[1],VALUES[2],VALUES[3]},0,2);
  scan=new Scan(ROW);
  scan.addFamily(FAMILIES[0]);
  scan.setMaxVersions(Integer.MAX_VALUE);
  result=getSingleScanResult(ht,scan);
  assertNResult(result,ROW,FAMILIES[0],QUALIFIER,new long[]{ts[1],ts[2],ts[3]},new byte[][]{VALUES[1],VALUES[2],VALUES[3]},0,2);
  put=new Put(ROWS[0]);
  put.addColumn(FAMILIES[1],QUALIFIER,ts[0],VALUES[0]);
  put.addColumn(FAMILIES[1],QUALIFIER,ts[1],VALUES[1]);
  put.addColumn(FAMILIES[2],QUALIFIER,ts[2],VALUES[2]);
  put.addColumn(FAMILIES[2],QUALIFIER,ts[3],VALUES[3]);
  ht.put(put);
  put=new Put(ROWS[1]);
  put.addColumn(FAMILIES[1],QUALIFIER,ts[0],VALUES[0]);
  put.addColumn(FAMILIES[1],QUALIFIER,ts[1],VALUES[1]);
  put.addColumn(FAMILIES[2],QUALIFIER,ts[2],VALUES[2]);
  put.addColumn(FAMILIES[2],QUALIFIER,ts[3],VALUES[3]);
  ht.put(put);
  put=new Put(ROWS[2]);
  put.addColumn(FAMILIES[1],QUALIFIER,ts[0],VALUES[0]);
  put.addColumn(FAMILIES[1],QUALIFIER,ts[1],VALUES[1]);
  put.addColumn(FAMILIES[2],QUALIFIER,ts[2],VALUES[2]);
  put.addColumn(FAMILIES[2],QUALIFIER,ts[3],VALUES[3]);
  ht.put(put);
  get=new Get(ROWS[2]);
  get.addFamily(FAMILIES[1]);
  get.addFamily(FAMILIES[2]);
  get.setMaxVersions(Integer.MAX_VALUE);
  result=ht.get(get);
  assertTrue("Expected 4 key but received " + result.size() + ": "+ result,result.size() == 4);
  delete=new Delete(ROWS[0]);
  delete.addFamily(FAMILIES[2]);
  ht.delete(delete);
  delete=new Delete(ROWS[1]);
  delete.addColumns(FAMILIES[1],QUALIFIER);
  ht.delete(delete);
  delete=new Delete(ROWS[2]);
  delete.addColumn(FAMILIES[1],QUALIFIER);
  delete.addColumn(FAMILIES[1],QUALIFIER);
  delete.addColumn(FAMILIES[2],QUALIFIER);
  ht.delete(delete);
  get=new Get(ROWS[0]);
  get.addFamily(FAMILIES[1]);
  get.addFamily(FAMILIES[2]);
  get.setMaxVersions(Integer.MAX_VALUE);
  result=ht.get(get);
  assertTrue("Expected 2 keys but received " + result.size(),result.size() == 2);
  assertNResult(result,ROWS[0],FAMILIES[1],QUALIFIER,new long[]{ts[0],ts[1]},new byte[][]{VALUES[0],VALUES[1]},0,1);
  scan=new Scan(ROWS[0]);
  scan.addFamily(FAMILIES[1]);
  scan.addFamily(FAMILIES[2]);
  scan.setMaxVersions(Integer.MAX_VALUE);
  result=getSingleScanResult(ht,scan);
  assertTrue("Expected 2 keys but received " + result.size(),result.size() == 2);
  assertNResult(result,ROWS[0],FAMILIES[1],QUALIFIER,new long[]{ts[0],ts[1]},new byte[][]{VALUES[0],VALUES[1]},0,1);
  get=new Get(ROWS[1]);
  get.addFamily(FAMILIES[1]);
  get.addFamily(FAMILIES[2]);
  get.setMaxVersions(Integer.MAX_VALUE);
  result=ht.get(get);
  assertTrue("Expected 2 keys but received " + result.size(),result.size() == 2);
  scan=new Scan(ROWS[1]);
  scan.addFamily(FAMILIES[1]);
  scan.addFamily(FAMILIES[2]);
  scan.setMaxVersions(Integer.MAX_VALUE);
  result=getSingleScanResult(ht,scan);
  assertTrue("Expected 2 keys but received " + result.size(),result.size() == 2);
  get=new Get(ROWS[2]);
  get.addFamily(FAMILIES[1]);
  get.addFamily(FAMILIES[2]);
  get.setMaxVersions(Integer.MAX_VALUE);
  result=ht.get(get);
  assertEquals(1,result.size());
  assertNResult(result,ROWS[2],FAMILIES[2],QUALIFIER,new long[]{ts[2]},new byte[][]{VALUES[2]},0,0);
  scan=new Scan(ROWS[2]);
  scan.addFamily(FAMILIES[1]);
  scan.addFamily(FAMILIES[2]);
  scan.setMaxVersions(Integer.MAX_VALUE);
  result=getSingleScanResult(ht,scan);
  assertEquals(1,result.size());
  assertNResult(result,ROWS[2],FAMILIES[2],QUALIFIER,new long[]{ts[2]},new byte[][]{VALUES[2]},0,0);
  delete=new Delete(ROWS[3]);
  delete.addFamily(FAMILIES[1]);
  ht.delete(delete);
  put=new Put(ROWS[3]);
  put.addColumn(FAMILIES[2],QUALIFIER,VALUES[0]);
  ht.put(put);
  put=new Put(ROWS[4]);
  put.addColumn(FAMILIES[1],QUALIFIER,VALUES[1]);
  put.addColumn(FAMILIES[2],QUALIFIER,VALUES[2]);
  ht.put(put);
  get=new Get(ROWS[3]);
  get.addFamily(FAMILIES[1]);
  get.addFamily(FAMILIES[2]);
  get.setMaxVersions(Integer.MAX_VALUE);
  result=ht.get(get);
  assertTrue("Expected 1 key but received " + result.size(),result.size() == 1);
  get=new Get(ROWS[4]);
  get.addFamily(FAMILIES[1]);
  get.addFamily(FAMILIES[2]);
  get.setMaxVersions(Integer.MAX_VALUE);
  result=ht.get(get);
  assertTrue("Expected 2 keys but received " + result.size(),result.size() == 2);
  scan=new Scan(ROWS[3]);
  scan.addFamily(FAMILIES[1]);
  scan.addFamily(FAMILIES[2]);
  scan.setMaxVersions(Integer.MAX_VALUE);
  ResultScanner scanner=ht.getScanner(scan);
  result=scanner.next();
  assertTrue("Expected 1 key but received " + result.size(),result.size() == 1);
  assertTrue(Bytes.equals(CellUtil.cloneRow(result.rawCells()[0]),ROWS[3]));
  assertTrue(Bytes.equals(CellUtil.cloneValue(result.rawCells()[0]),VALUES[0]));
  result=scanner.next();
  assertTrue("Expected 2 keys but received " + result.size(),result.size() == 2);
  assertTrue(Bytes.equals(CellUtil.cloneRow(result.rawCells()[0]),ROWS[4]));
  assertTrue(Bytes.equals(CellUtil.cloneRow(result.rawCells()[1]),ROWS[4]));
  assertTrue(Bytes.equals(CellUtil.cloneValue(result.rawCells()[0]),VALUES[1]));
  assertTrue(Bytes.equals(CellUtil.cloneValue(result.rawCells()[1]),VALUES[2]));
  scanner.close();
  for (int i=0; i < 10; i++) {
    byte[] bytes=Bytes.toBytes(i);
    put=new Put(bytes);
    put.setDurability(Durability.SKIP_WAL);
    put.addColumn(FAMILIES[0],QUALIFIER,bytes);
    ht.put(put);
  }
  for (int i=0; i < 10; i++) {
    byte[] bytes=Bytes.toBytes(i);
    get=new Get(bytes);
    get.addFamily(FAMILIES[0]);
    result=ht.get(get);
    assertTrue(result.size() == 1);
  }
  ArrayList<Delete> deletes=new ArrayList<Delete>();
  for (int i=0; i < 10; i++) {
    byte[] bytes=Bytes.toBytes(i);
    delete=new Delete(bytes);
    delete.addFamily(FAMILIES[0]);
    deletes.add(delete);
  }
  ht.delete(deletes);
  for (int i=0; i < 10; i++) {
    byte[] bytes=Bytes.toBytes(i);
    get=new Get(bytes);
    get.addFamily(FAMILIES[0]);
    result=ht.get(get);
    assertTrue(result.size() == 0);
  }
}

</code></pre>

<pre class="type-11 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testMaxKeyValueSize() throws Exception {
  TableName TABLE=TableName.valueOf("testMaxKeyValueSize");
  Configuration conf=TEST_UTIL.getConfiguration();
  String oldMaxSize=conf.get(TableConfiguration.MAX_KEYVALUE_SIZE_KEY);
  Table ht=TEST_UTIL.createTable(TABLE,FAMILY);
  byte[] value=new byte[4 * 1024 * 1024];
  Put put=new Put(ROW);
  put.addColumn(FAMILY,QUALIFIER,value);
  ht.put(put);
  try {
    TEST_UTIL.getConfiguration().setInt(TableConfiguration.MAX_KEYVALUE_SIZE_KEY,2 * 1024 * 1024);
    try (Connection connection=ConnectionFactory.createConnection(TEST_UTIL.getConfiguration())){
      try (Table t=connection.getTable(TableName.valueOf(FAMILY))){
        put=new Put(ROW);
        put.addColumn(FAMILY,QUALIFIER,value);
        t.put(put);
      }
     }
     fail("Inserting a too large KeyValue worked, should throw exception");
  }
 catch (  Exception e) {
  }
  conf.set(TableConfiguration.MAX_KEYVALUE_SIZE_KEY,oldMaxSize);
}

</code></pre>

<pre class="type-4 type-9 type-7 type-8 type-12 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values related to public fields.">PublicFieldVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies assertions in iterations
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies values related to public fields.
"></span><br>
@Test public void testListTables() throws IOException, InterruptedException {
  TableName t1=TableName.valueOf("testListTables1");
  TableName t2=TableName.valueOf("testListTables2");
  TableName t3=TableName.valueOf("testListTables3");
  TableName[] tables=new TableName[]{t1,t2,t3};
  for (int i=0; i < tables.length; i++) {
    TEST_UTIL.createTable(tables[i],FAMILY);
  }
  Admin admin=TEST_UTIL.getHBaseAdmin();
  HTableDescriptor[] ts=admin.listTables();
  HashSet<HTableDescriptor> result=new HashSet<HTableDescriptor>(ts.length);
  Collections.addAll(result,ts);
  int size=result.size();
  assertTrue(size >= tables.length);
  for (int i=0; i < tables.length && i < size; i++) {
    boolean found=false;
    for (int j=0; j < ts.length; j++) {
      if (ts[j].getTableName().equals(tables[i])) {
        found=true;
        break;
      }
    }
    assertTrue("Not found: " + tables[i],found);
  }
}

</code></pre>

<pre class="type-4 type-7 type-8 type-5 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testDeletesWithReverseScan() throws Exception {
  TableName TABLE=TableName.valueOf("testDeletesWithReverseScan");
  byte[][] ROWS=makeNAscii(ROW,6);
  byte[][] FAMILIES=makeNAscii(FAMILY,3);
  byte[][] VALUES=makeN(VALUE,5);
  long[] ts={1000,2000,3000,4000,5000};
  Table ht=TEST_UTIL.createTable(TABLE,FAMILIES,3);
  Put put=new Put(ROW);
  put.addColumn(FAMILIES[0],QUALIFIER,ts[0],VALUES[0]);
  put.addColumn(FAMILIES[0],QUALIFIER,ts[1],VALUES[1]);
  ht.put(put);
  Delete delete=new Delete(ROW);
  delete.addFamily(FAMILIES[0],ts[0]);
  ht.delete(delete);
  Scan scan=new Scan(ROW);
  scan.setReversed(true);
  scan.addFamily(FAMILIES[0]);
  scan.setMaxVersions(Integer.MAX_VALUE);
  Result result=getSingleScanResult(ht,scan);
  assertNResult(result,ROW,FAMILIES[0],QUALIFIER,new long[]{ts[1]},new byte[][]{VALUES[1]},0,0);
  put=new Put(ROW);
  put.addColumn(FAMILIES[0],QUALIFIER,ts[4],VALUES[4]);
  put.addColumn(FAMILIES[0],QUALIFIER,ts[2],VALUES[2]);
  put.addColumn(FAMILIES[0],QUALIFIER,ts[3],VALUES[3]);
  put.addColumn(FAMILIES[0],null,ts[4],VALUES[4]);
  put.addColumn(FAMILIES[0],null,ts[2],VALUES[2]);
  put.addColumn(FAMILIES[0],null,ts[3],VALUES[3]);
  ht.put(put);
  delete=new Delete(ROW);
  delete.addColumn(FAMILIES[0],QUALIFIER);
  ht.delete(delete);
  scan=new Scan(ROW);
  scan.setReversed(true);
  scan.addColumn(FAMILIES[0],QUALIFIER);
  scan.setMaxVersions(Integer.MAX_VALUE);
  result=getSingleScanResult(ht,scan);
  assertNResult(result,ROW,FAMILIES[0],QUALIFIER,new long[]{ts[1],ts[2],ts[3]},new byte[][]{VALUES[1],VALUES[2],VALUES[3]},0,2);
  delete=new Delete(ROW);
  delete.addColumn(FAMILIES[0],null);
  ht.delete(delete);
  delete=new Delete(ROW);
  delete.addColumns(FAMILIES[0],null);
  ht.delete(delete);
  put=new Put(ROW);
  put.addColumn(FAMILIES[0],QUALIFIER,ts[0],VALUES[0]);
  put.addColumn(FAMILIES[0],QUALIFIER,ts[4],VALUES[4]);
  ht.put(put);
  scan=new Scan(ROW);
  scan.setReversed(true);
  scan.addFamily(FAMILIES[0]);
  scan.setMaxVersions(Integer.MAX_VALUE);
  result=getSingleScanResult(ht,scan);
  assertNResult(result,ROW,FAMILIES[0],QUALIFIER,new long[]{ts[1],ts[2],ts[3]},new byte[][]{VALUES[1],VALUES[2],VALUES[3]},0,2);
  put=new Put(ROWS[0]);
  put.addColumn(FAMILIES[1],QUALIFIER,ts[0],VALUES[0]);
  put.addColumn(FAMILIES[1],QUALIFIER,ts[1],VALUES[1]);
  put.addColumn(FAMILIES[2],QUALIFIER,ts[2],VALUES[2]);
  put.addColumn(FAMILIES[2],QUALIFIER,ts[3],VALUES[3]);
  ht.put(put);
  put=new Put(ROWS[1]);
  put.addColumn(FAMILIES[1],QUALIFIER,ts[0],VALUES[0]);
  put.addColumn(FAMILIES[1],QUALIFIER,ts[1],VALUES[1]);
  put.addColumn(FAMILIES[2],QUALIFIER,ts[2],VALUES[2]);
  put.addColumn(FAMILIES[2],QUALIFIER,ts[3],VALUES[3]);
  ht.put(put);
  put=new Put(ROWS[2]);
  put.addColumn(FAMILIES[1],QUALIFIER,ts[0],VALUES[0]);
  put.addColumn(FAMILIES[1],QUALIFIER,ts[1],VALUES[1]);
  put.addColumn(FAMILIES[2],QUALIFIER,ts[2],VALUES[2]);
  put.addColumn(FAMILIES[2],QUALIFIER,ts[3],VALUES[3]);
  ht.put(put);
  delete=new Delete(ROWS[0]);
  delete.addFamily(FAMILIES[2]);
  ht.delete(delete);
  delete=new Delete(ROWS[1]);
  delete.addColumns(FAMILIES[1],QUALIFIER);
  ht.delete(delete);
  delete=new Delete(ROWS[2]);
  delete.addColumn(FAMILIES[1],QUALIFIER);
  delete.addColumn(FAMILIES[1],QUALIFIER);
  delete.addColumn(FAMILIES[2],QUALIFIER);
  ht.delete(delete);
  scan=new Scan(ROWS[0]);
  scan.setReversed(true);
  scan.addFamily(FAMILIES[1]);
  scan.addFamily(FAMILIES[2]);
  scan.setMaxVersions(Integer.MAX_VALUE);
  result=getSingleScanResult(ht,scan);
  assertTrue("Expected 2 keys but received " + result.size(),result.size() == 2);
  assertNResult(result,ROWS[0],FAMILIES[1],QUALIFIER,new long[]{ts[0],ts[1]},new byte[][]{VALUES[0],VALUES[1]},0,1);
  scan=new Scan(ROWS[1]);
  scan.setReversed(true);
  scan.addFamily(FAMILIES[1]);
  scan.addFamily(FAMILIES[2]);
  scan.setMaxVersions(Integer.MAX_VALUE);
  result=getSingleScanResult(ht,scan);
  assertTrue("Expected 2 keys but received " + result.size(),result.size() == 2);
  scan=new Scan(ROWS[2]);
  scan.setReversed(true);
  scan.addFamily(FAMILIES[1]);
  scan.addFamily(FAMILIES[2]);
  scan.setMaxVersions(Integer.MAX_VALUE);
  result=getSingleScanResult(ht,scan);
  assertEquals(1,result.size());
  assertNResult(result,ROWS[2],FAMILIES[2],QUALIFIER,new long[]{ts[2]},new byte[][]{VALUES[2]},0,0);
  delete=new Delete(ROWS[3]);
  delete.addFamily(FAMILIES[1]);
  ht.delete(delete);
  put=new Put(ROWS[3]);
  put.addColumn(FAMILIES[2],QUALIFIER,VALUES[0]);
  ht.put(put);
  put=new Put(ROWS[4]);
  put.addColumn(FAMILIES[1],QUALIFIER,VALUES[1]);
  put.addColumn(FAMILIES[2],QUALIFIER,VALUES[2]);
  ht.put(put);
  scan=new Scan(ROWS[4]);
  scan.setReversed(true);
  scan.addFamily(FAMILIES[1]);
  scan.addFamily(FAMILIES[2]);
  scan.setMaxVersions(Integer.MAX_VALUE);
  ResultScanner scanner=ht.getScanner(scan);
  result=scanner.next();
  assertTrue("Expected 2 keys but received " + result.size(),result.size() == 2);
  assertTrue(Bytes.equals(CellUtil.cloneRow(result.rawCells()[0]),ROWS[4]));
  assertTrue(Bytes.equals(CellUtil.cloneRow(result.rawCells()[1]),ROWS[4]));
  assertTrue(Bytes.equals(CellUtil.cloneValue(result.rawCells()[0]),VALUES[1]));
  assertTrue(Bytes.equals(CellUtil.cloneValue(result.rawCells()[1]),VALUES[2]));
  result=scanner.next();
  assertTrue("Expected 1 key but received " + result.size(),result.size() == 1);
  assertTrue(Bytes.equals(CellUtil.cloneRow(result.rawCells()[0]),ROWS[3]));
  assertTrue(Bytes.equals(CellUtil.cloneValue(result.rawCells()[0]),VALUES[0]));
  scanner.close();
  ht.close();
}

</code></pre>

<pre class="type-7 type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
"></span><br>
@Test public void testSuperSimpleWithReverseScan() throws Exception {
  TableName TABLE=TableName.valueOf("testSuperSimpleWithReverseScan");
  Table ht=TEST_UTIL.createTable(TABLE,FAMILY);
  Put put=new Put(Bytes.toBytes("0-b11111-0000000000000000000"));
  put.addColumn(FAMILY,QUALIFIER,VALUE);
  ht.put(put);
  put=new Put(Bytes.toBytes("0-b11111-0000000000000000002"));
  put.addColumn(FAMILY,QUALIFIER,VALUE);
  ht.put(put);
  put=new Put(Bytes.toBytes("0-b11111-0000000000000000004"));
  put.addColumn(FAMILY,QUALIFIER,VALUE);
  ht.put(put);
  put=new Put(Bytes.toBytes("0-b11111-0000000000000000006"));
  put.addColumn(FAMILY,QUALIFIER,VALUE);
  ht.put(put);
  put=new Put(Bytes.toBytes("0-b11111-0000000000000000008"));
  put.addColumn(FAMILY,QUALIFIER,VALUE);
  ht.put(put);
  put=new Put(Bytes.toBytes("0-b22222-0000000000000000001"));
  put.addColumn(FAMILY,QUALIFIER,VALUE);
  ht.put(put);
  put=new Put(Bytes.toBytes("0-b22222-0000000000000000003"));
  put.addColumn(FAMILY,QUALIFIER,VALUE);
  ht.put(put);
  put=new Put(Bytes.toBytes("0-b22222-0000000000000000005"));
  put.addColumn(FAMILY,QUALIFIER,VALUE);
  ht.put(put);
  put=new Put(Bytes.toBytes("0-b22222-0000000000000000007"));
  put.addColumn(FAMILY,QUALIFIER,VALUE);
  ht.put(put);
  put=new Put(Bytes.toBytes("0-b22222-0000000000000000009"));
  put.addColumn(FAMILY,QUALIFIER,VALUE);
  ht.put(put);
  Scan scan=new Scan(Bytes.toBytes("0-b11111-9223372036854775807"),Bytes.toBytes("0-b11111-0000000000000000000"));
  scan.setReversed(true);
  ResultScanner scanner=ht.getScanner(scan);
  Result result=scanner.next();
  assertTrue(Bytes.equals(result.getRow(),Bytes.toBytes("0-b11111-0000000000000000008")));
  scanner.close();
  ht.close();
}

</code></pre>

<pre class="type-4 type-7 type-13 type-5 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test ScanMetrics
 * @throws Exception
 */
@Test @SuppressWarnings("unused") public void testScanMetrics() throws Exception {
  TableName TABLENAME=TableName.valueOf("testScanMetrics");
  Table ht=TEST_UTIL.createMultiRegionTable(TABLENAME,FAMILY);
  int numOfRegions=-1;
  try (RegionLocator r=TEST_UTIL.getConnection().getRegionLocator(TABLENAME)){
    numOfRegions=r.getStartKeys().length;
  }
   Put put1=new Put(Bytes.toBytes("zzz1"));
  put1.addColumn(FAMILY,QUALIFIER,VALUE);
  Put put2=new Put(Bytes.toBytes("zzz2"));
  put2.addColumn(FAMILY,QUALIFIER,VALUE);
  Put put3=new Put(Bytes.toBytes("zzz3"));
  put3.addColumn(FAMILY,QUALIFIER,VALUE);
  ht.put(Arrays.asList(put1,put2,put3));
  Scan scan1=new Scan();
  int numRecords=0;
  ResultScanner scanner=ht.getScanner(scan1);
  for (  Result result : scanner) {
    numRecords++;
  }
  scanner.close();
  LOG.info("test data has " + numRecords + " records.");
  assertEquals(null,scan1.getScanMetrics());
  Scan scan2=new Scan();
  scan2.setScanMetricsEnabled(true);
  scan2.setCaching(numRecords + 1);
  scanner=ht.getScanner(scan2);
  for (  Result result : scanner.next(numRecords - 1)) {
  }
  scanner.close();
  assertNotNull(scan2.getScanMetrics());
  scan2=new Scan();
  scan2.setScanMetricsEnabled(true);
  scan2.setCaching(1);
  scanner=ht.getScanner(scan2);
  for (  Result result : scanner.next(numRecords - 1)) {
  }
  scanner.close();
  ScanMetrics scanMetrics=scan2.getScanMetrics();
  assertEquals("Did not access all the regions in the table",numOfRegions,scanMetrics.countOfRegions.get());
  scan2=new Scan();
  scan2.setScanMetricsEnabled(true);
  scan2.setCaching(1);
  scanner=ht.getScanner(scan2);
  int numBytes=0;
  for (  Result result : scanner.next(1)) {
    for (    Cell cell : result.listCells()) {
      numBytes+=CellUtil.estimatedSerializedSizeOf(cell);
    }
  }
  scanner.close();
  scanMetrics=scan2.getScanMetrics();
  assertEquals("Did not count the result bytes",numBytes,scanMetrics.countOfBytesInResults.get());
  scan2=new Scan();
  scan2.setScanMetricsEnabled(true);
  scan2.setCaching(1);
  scan2.setSmall(true);
  scanner=ht.getScanner(scan2);
  numBytes=0;
  for (  Result result : scanner.next(1)) {
    for (    Cell cell : result.listCells()) {
      numBytes+=CellUtil.estimatedSerializedSizeOf(cell);
    }
  }
  scanner.close();
  scanMetrics=scan2.getScanMetrics();
  assertEquals("Did not count the result bytes",numBytes,scanMetrics.countOfBytesInResults.get());
  Scan scanWithClose=new Scan();
  scanWithClose.setCaching(numRecords);
  scanWithClose.setScanMetricsEnabled(true);
  ResultScanner scannerWithClose=ht.getScanner(scanWithClose);
  for (  Result result : scannerWithClose.next(numRecords + 1)) {
  }
  scannerWithClose.close();
  ScanMetrics scanMetricsWithClose=getScanMetrics(scanWithClose);
  assertEquals("Did not access all the regions in the table",numOfRegions,scanMetricsWithClose.countOfRegions.get());
}

</code></pre>

<pre class="type-1 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Test simple table and non-existent row cases.
 */
@Test public void testSimpleMissing() throws Exception {
  TableName TABLE=TableName.valueOf("testSimpleMissing");
  Table ht=TEST_UTIL.createTable(TABLE,FAMILY);
  byte[][] ROWS=makeN(ROW,4);
  Get get=new Get(ROWS[0]);
  Result result=ht.get(get);
  assertEmptyResult(result);
  get=new Get(ROWS[0]);
  get.addFamily(FAMILY);
  result=ht.get(get);
  assertEmptyResult(result);
  get=new Get(ROWS[0]);
  get.addColumn(FAMILY,QUALIFIER);
  result=ht.get(get);
  assertEmptyResult(result);
  Scan scan=new Scan();
  result=getSingleScanResult(ht,scan);
  assertNullResult(result);
  scan=new Scan(ROWS[0]);
  result=getSingleScanResult(ht,scan);
  assertNullResult(result);
  scan=new Scan(ROWS[0],ROWS[1]);
  result=getSingleScanResult(ht,scan);
  assertNullResult(result);
  scan=new Scan();
  scan.addFamily(FAMILY);
  result=getSingleScanResult(ht,scan);
  assertNullResult(result);
  scan=new Scan();
  scan.addColumn(FAMILY,QUALIFIER);
  result=getSingleScanResult(ht,scan);
  assertNullResult(result);
  Put put=new Put(ROWS[2]);
  put.addColumn(FAMILY,QUALIFIER,VALUE);
  ht.put(put);
  get=new Get(ROWS[1]);
  result=ht.get(get);
  assertEmptyResult(result);
  get=new Get(ROWS[0]);
  get.addFamily(FAMILY);
  result=ht.get(get);
  assertEmptyResult(result);
  get=new Get(ROWS[3]);
  get.addColumn(FAMILY,QUALIFIER);
  result=ht.get(get);
  assertEmptyResult(result);
  scan=new Scan(ROWS[3]);
  result=getSingleScanResult(ht,scan);
  assertNullResult(result);
  scan=new Scan(ROWS[0],ROWS[2]);
  result=getSingleScanResult(ht,scan);
  assertNullResult(result);
  get=new Get(ROWS[2]);
  result=ht.get(get);
  assertSingleResult(result,ROWS[2],FAMILY,QUALIFIER,VALUE);
  get=new Get(ROWS[2]);
  get.addFamily(FAMILY);
  result=ht.get(get);
  assertSingleResult(result,ROWS[2],FAMILY,QUALIFIER,VALUE);
  get=new Get(ROWS[2]);
  get.addColumn(FAMILY,QUALIFIER);
  result=ht.get(get);
  assertSingleResult(result,ROWS[2],FAMILY,QUALIFIER,VALUE);
  scan=new Scan();
  result=getSingleScanResult(ht,scan);
  assertSingleResult(result,ROWS[2],FAMILY,QUALIFIER,VALUE);
  scan=new Scan(ROWS[0],ROWS[3]);
  result=getSingleScanResult(ht,scan);
  assertSingleResult(result,ROWS[2],FAMILY,QUALIFIER,VALUE);
  scan=new Scan(ROWS[2],ROWS[3]);
  result=getSingleScanResult(ht,scan);
  assertSingleResult(result,ROWS[2],FAMILY,QUALIFIER,VALUE);
}

</code></pre>

<pre class="type-11 type-7 type-5 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testCheckAndPut() throws IOException {
  final byte[] anotherrow=Bytes.toBytes("anotherrow");
  final byte[] value2=Bytes.toBytes("abcd");
  Table table=TEST_UTIL.createTable(TableName.valueOf("testCheckAndPut"),FAMILY);
  Put put1=new Put(ROW);
  put1.addColumn(FAMILY,QUALIFIER,VALUE);
  boolean ok=table.checkAndPut(ROW,FAMILY,QUALIFIER,VALUE,put1);
  assertEquals(ok,false);
  ok=table.checkAndPut(ROW,FAMILY,QUALIFIER,null,put1);
  assertEquals(ok,true);
  ok=table.checkAndPut(ROW,FAMILY,QUALIFIER,null,put1);
  assertEquals(ok,false);
  Put put2=new Put(ROW);
  put2.addColumn(FAMILY,QUALIFIER,value2);
  ok=table.checkAndPut(ROW,FAMILY,QUALIFIER,VALUE,put2);
  assertEquals(ok,true);
  Put put3=new Put(anotherrow);
  put3.addColumn(FAMILY,QUALIFIER,VALUE);
  try {
    ok=table.checkAndPut(ROW,FAMILY,QUALIFIER,value2,put3);
    fail("trying to check and modify different rows should have failed.");
  }
 catch (  Exception e) {
  }
}

</code></pre>

<pre class="type-7 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
"></span><br>
@Test public void testAppend() throws Exception {
  LOG.info("Starting testAppend");
  final TableName TABLENAME=TableName.valueOf("testAppend");
  Table t=TEST_UTIL.createTable(TABLENAME,FAMILY);
  byte[] v1=Bytes.toBytes("42");
  byte[] v2=Bytes.toBytes("23");
  byte[][] QUALIFIERS=new byte[][]{Bytes.toBytes("b"),Bytes.toBytes("a"),Bytes.toBytes("c")};
  Append a=new Append(ROW);
  a.add(FAMILY,QUALIFIERS[0],v1);
  a.add(FAMILY,QUALIFIERS[1],v2);
  a.setReturnResults(false);
  assertNullResult(t.append(a));
  a=new Append(ROW);
  a.add(FAMILY,QUALIFIERS[0],v2);
  a.add(FAMILY,QUALIFIERS[1],v1);
  a.add(FAMILY,QUALIFIERS[2],v2);
  Result r=t.append(a);
  assertEquals(0,Bytes.compareTo(Bytes.add(v1,v2),r.getValue(FAMILY,QUALIFIERS[0])));
  assertEquals(0,Bytes.compareTo(Bytes.add(v2,v1),r.getValue(FAMILY,QUALIFIERS[1])));
  assertEquals(0,Bytes.compareTo(v2,r.getValue(FAMILY,QUALIFIERS[2])));
  assertEquals(r.getColumnLatestCell(FAMILY,QUALIFIERS[0]).getTimestamp(),r.getColumnLatestCell(FAMILY,QUALIFIERS[2]).getTimestamp());
}

</code></pre>

<pre class="type-7 type-13 type-5 type-6 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
- Verifies whether objects/variable are equal to an expected value 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Basic client side validation of HBASE-10118
 */
@Test public void testPurgeFutureDeletes() throws Exception {
  final TableName TABLENAME=TableName.valueOf("testPurgeFutureDeletes");
  final byte[] ROW=Bytes.toBytes("row");
  final byte[] FAMILY=Bytes.toBytes("family");
  final byte[] COLUMN=Bytes.toBytes("column");
  final byte[] VALUE=Bytes.toBytes("value");
  Table table=TEST_UTIL.createTable(TABLENAME,FAMILY);
  long ts=System.currentTimeMillis() * 2;
  Put put=new Put(ROW,ts);
  put.addColumn(FAMILY,COLUMN,VALUE);
  table.put(put);
  Get get=new Get(ROW);
  Result result=table.get(get);
  assertArrayEquals(VALUE,result.getValue(FAMILY,COLUMN));
  Delete del=new Delete(ROW);
  del.addColumn(FAMILY,COLUMN,ts);
  table.delete(del);
  get=new Get(ROW);
  result=table.get(get);
  assertNull(result.getValue(FAMILY,COLUMN));
  TEST_UTIL.getHBaseAdmin().flush(TABLENAME);
  TEST_UTIL.getHBaseAdmin().majorCompact(TABLENAME);
  TEST_UTIL.waitFor(6000,new Waiter.Predicate<IOException>(){
    @Override public boolean evaluate() throws IOException {
      return TEST_UTIL.getHBaseAdmin().getCompactionState(TABLENAME) == AdminProtos.GetRegionInfoResponse.CompactionState.NONE;
    }
  }
);
  put=new Put(ROW,ts);
  put.addColumn(FAMILY,COLUMN,VALUE);
  table.put(put);
  get=new Get(ROW);
  result=table.get(get);
  assertArrayEquals(VALUE,result.getValue(FAMILY,COLUMN));
  table.close();
}

</code></pre>

<pre class="type-7 type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
"></span><br>
@Test public void testPutNoCF() throws IOException {
  final byte[] BAD_FAM=Bytes.toBytes("BAD_CF");
  final byte[] VAL=Bytes.toBytes(100);
  Table table=TEST_UTIL.createTable(TableName.valueOf("testPutNoCF"),FAMILY);
  boolean caughtNSCFE=false;
  try {
    Put p=new Put(ROW);
    p.addColumn(BAD_FAM,QUALIFIER,VAL);
    table.put(p);
  }
 catch (  RetriesExhaustedWithDetailsException e) {
    caughtNSCFE=e.getCause(0) instanceof NoSuchColumnFamilyException;
  }
  assertTrue("Should throw NoSuchColumnFamilyException",caughtNSCFE);
}

</code></pre>

<pre class="type-1 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Executes methods or other tests from the same test unit">ExecutionTester</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Executes methods or other tests from the same test unit
"></span><br>
/** 
 * Test basic puts, gets, scans, and deletes for a single row
 * in a multiple family table.
 */
@Test public void testSingleRowMultipleFamily() throws Exception {
  TableName TABLE=TableName.valueOf("testSingleRowMultipleFamily");
  byte[][] ROWS=makeN(ROW,3);
  byte[][] FAMILIES=makeNAscii(FAMILY,10);
  byte[][] QUALIFIERS=makeN(QUALIFIER,10);
  byte[][] VALUES=makeN(VALUE,10);
  Table ht=TEST_UTIL.createTable(TABLE,FAMILIES);
  Get get;
  Scan scan;
  Delete delete;
  Put put;
  Result result;
  put=new Put(ROWS[0]);
  put.addColumn(FAMILIES[4],QUALIFIERS[0],VALUES[0]);
  ht.put(put);
  getVerifySingleColumn(ht,ROWS,0,FAMILIES,4,QUALIFIERS,0,VALUES,0);
  scanVerifySingleColumn(ht,ROWS,0,FAMILIES,4,QUALIFIERS,0,VALUES,0);
  getVerifySingleEmpty(ht,ROWS,0,FAMILIES,4,QUALIFIERS,0);
  scanVerifySingleEmpty(ht,ROWS,0,FAMILIES,4,QUALIFIERS,0);
  TEST_UTIL.flush();
  getVerifySingleColumn(ht,ROWS,0,FAMILIES,4,QUALIFIERS,0,VALUES,0);
  scanVerifySingleColumn(ht,ROWS,0,FAMILIES,4,QUALIFIERS,0,VALUES,0);
  getVerifySingleEmpty(ht,ROWS,0,FAMILIES,4,QUALIFIERS,0);
  scanVerifySingleEmpty(ht,ROWS,0,FAMILIES,4,QUALIFIERS,0);
  put=new Put(ROWS[0]);
  put.addColumn(FAMILIES[2],QUALIFIERS[2],VALUES[2]);
  put.addColumn(FAMILIES[2],QUALIFIERS[4],VALUES[4]);
  put.addColumn(FAMILIES[4],QUALIFIERS[4],VALUES[4]);
  put.addColumn(FAMILIES[6],QUALIFIERS[6],VALUES[6]);
  put.addColumn(FAMILIES[6],QUALIFIERS[7],VALUES[7]);
  put.addColumn(FAMILIES[7],QUALIFIERS[7],VALUES[7]);
  put.addColumn(FAMILIES[9],QUALIFIERS[0],VALUES[0]);
  ht.put(put);
  singleRowGetTest(ht,ROWS,FAMILIES,QUALIFIERS,VALUES);
  singleRowScanTest(ht,ROWS,FAMILIES,QUALIFIERS,VALUES);
  TEST_UTIL.flush();
  singleRowGetTest(ht,ROWS,FAMILIES,QUALIFIERS,VALUES);
  singleRowScanTest(ht,ROWS,FAMILIES,QUALIFIERS,VALUES);
  put=new Put(ROWS[0]);
  put.addColumn(FAMILIES[6],QUALIFIERS[5],VALUES[5]);
  put.addColumn(FAMILIES[6],QUALIFIERS[8],VALUES[8]);
  put.addColumn(FAMILIES[6],QUALIFIERS[9],VALUES[9]);
  put.addColumn(FAMILIES[4],QUALIFIERS[3],VALUES[3]);
  ht.put(put);
  delete=new Delete(ROWS[0]);
  delete.addColumns(FAMILIES[6],QUALIFIERS[7]);
  ht.delete(delete);
  get=new Get(ROWS[0]);
  get.addColumn(FAMILIES[6],QUALIFIERS[7]);
  result=ht.get(get);
  assertEmptyResult(result);
  scan=new Scan();
  scan.addColumn(FAMILIES[6],QUALIFIERS[7]);
  result=getSingleScanResult(ht,scan);
  assertNullResult(result);
  get=new Get(ROWS[0]);
  get.addColumn(FAMILIES[6],QUALIFIERS[6]);
  result=ht.get(get);
  assertSingleResult(result,ROWS[0],FAMILIES[6],QUALIFIERS[6],VALUES[6]);
  get=new Get(ROWS[0]);
  get.addColumn(FAMILIES[6],QUALIFIERS[8]);
  result=ht.get(get);
  assertSingleResult(result,ROWS[0],FAMILIES[6],QUALIFIERS[8],VALUES[8]);
  scan=new Scan();
  scan.addColumn(FAMILIES[6],QUALIFIERS[6]);
  result=getSingleScanResult(ht,scan);
  assertSingleResult(result,ROWS[0],FAMILIES[6],QUALIFIERS[6],VALUES[6]);
  scan=new Scan();
  scan.addColumn(FAMILIES[6],QUALIFIERS[8]);
  result=getSingleScanResult(ht,scan);
  assertSingleResult(result,ROWS[0],FAMILIES[6],QUALIFIERS[8],VALUES[8]);
  delete=new Delete(ROWS[0]);
  delete.addColumns(FAMILIES[6],QUALIFIERS[8]);
  ht.delete(delete);
  get=new Get(ROWS[0]);
  get.addColumn(FAMILIES[6],QUALIFIERS[8]);
  result=ht.get(get);
  assertEmptyResult(result);
  scan=new Scan();
  scan.addColumn(FAMILIES[6],QUALIFIERS[8]);
  result=getSingleScanResult(ht,scan);
  assertNullResult(result);
  get=new Get(ROWS[0]);
  get.addColumn(FAMILIES[6],QUALIFIERS[6]);
  result=ht.get(get);
  assertSingleResult(result,ROWS[0],FAMILIES[6],QUALIFIERS[6],VALUES[6]);
  get=new Get(ROWS[0]);
  get.addColumn(FAMILIES[6],QUALIFIERS[9]);
  result=ht.get(get);
  assertSingleResult(result,ROWS[0],FAMILIES[6],QUALIFIERS[9],VALUES[9]);
  scan=new Scan();
  scan.addColumn(FAMILIES[6],QUALIFIERS[6]);
  result=getSingleScanResult(ht,scan);
  assertSingleResult(result,ROWS[0],FAMILIES[6],QUALIFIERS[6],VALUES[6]);
  scan=new Scan();
  scan.addColumn(FAMILIES[6],QUALIFIERS[9]);
  result=getSingleScanResult(ht,scan);
  assertSingleResult(result,ROWS[0],FAMILIES[6],QUALIFIERS[9],VALUES[9]);
  delete=new Delete(ROWS[0]);
  delete.addFamily(FAMILIES[4]);
  ht.delete(delete);
  get=new Get(ROWS[0]);
  get.addColumn(FAMILIES[4],QUALIFIERS[4]);
  result=ht.get(get);
  assertEmptyResult(result);
  get=new Get(ROWS[0]);
  get.addColumn(FAMILIES[4],QUALIFIERS[3]);
  result=ht.get(get);
  assertEmptyResult(result);
  get=new Get(ROWS[0]);
  get.addFamily(FAMILIES[4]);
  result=ht.get(get);
  assertEmptyResult(result);
  scan=new Scan();
  scan.addColumn(FAMILIES[4],QUALIFIERS[4]);
  result=getSingleScanResult(ht,scan);
  assertNullResult(result);
  scan=new Scan();
  scan.addColumn(FAMILIES[4],QUALIFIERS[3]);
  result=getSingleScanResult(ht,scan);
  assertNullResult(result);
  scan=new Scan();
  scan.addFamily(FAMILIES[4]);
  result=getSingleScanResult(ht,scan);
  assertNullResult(result);
  get=new Get(ROWS[0]);
  get.addColumn(FAMILIES[2],QUALIFIERS[2]);
  result=ht.get(get);
  assertSingleResult(result,ROWS[0],FAMILIES[2],QUALIFIERS[2],VALUES[2]);
  get=new Get(ROWS[0]);
  get.addColumn(FAMILIES[6],QUALIFIERS[9]);
  result=ht.get(get);
  assertSingleResult(result,ROWS[0],FAMILIES[6],QUALIFIERS[9],VALUES[9]);
  scan=new Scan();
  scan.addColumn(FAMILIES[6],QUALIFIERS[6]);
  result=getSingleScanResult(ht,scan);
  assertSingleResult(result,ROWS[0],FAMILIES[6],QUALIFIERS[6],VALUES[6]);
  scan=new Scan();
  scan.addColumn(FAMILIES[6],QUALIFIERS[9]);
  result=getSingleScanResult(ht,scan);
  assertSingleResult(result,ROWS[0],FAMILIES[6],QUALIFIERS[9],VALUES[9]);
  TEST_UTIL.flush();
  get=new Get(ROWS[0]);
  get.addColumn(FAMILIES[4],QUALIFIERS[4]);
  result=ht.get(get);
  assertEmptyResult(result);
  get=new Get(ROWS[0]);
  get.addColumn(FAMILIES[4],QUALIFIERS[3]);
  result=ht.get(get);
  assertEmptyResult(result);
  get=new Get(ROWS[0]);
  get.addFamily(FAMILIES[4]);
  result=ht.get(get);
  assertEmptyResult(result);
  scan=new Scan();
  scan.addColumn(FAMILIES[4],QUALIFIERS[4]);
  result=getSingleScanResult(ht,scan);
  assertNullResult(result);
  scan=new Scan();
  scan.addColumn(FAMILIES[4],QUALIFIERS[3]);
  result=getSingleScanResult(ht,scan);
  assertNullResult(result);
  scan=new Scan();
  scan.addFamily(FAMILIES[4]);
  result=getSingleScanResult(ht,scan);
  assertNullResult(result);
  get=new Get(ROWS[0]);
  get.addColumn(FAMILIES[2],QUALIFIERS[2]);
  result=ht.get(get);
  assertSingleResult(result,ROWS[0],FAMILIES[2],QUALIFIERS[2],VALUES[2]);
  get=new Get(ROWS[0]);
  get.addColumn(FAMILIES[6],QUALIFIERS[9]);
  result=ht.get(get);
  assertSingleResult(result,ROWS[0],FAMILIES[6],QUALIFIERS[9],VALUES[9]);
  scan=new Scan();
  scan.addColumn(FAMILIES[6],QUALIFIERS[6]);
  result=getSingleScanResult(ht,scan);
  assertSingleResult(result,ROWS[0],FAMILIES[6],QUALIFIERS[6],VALUES[6]);
  scan=new Scan();
  scan.addColumn(FAMILIES[6],QUALIFIERS[9]);
  result=getSingleScanResult(ht,scan);
  assertSingleResult(result,ROWS[0],FAMILIES[6],QUALIFIERS[9],VALUES[9]);
}

</code></pre>

<pre class="type-7 type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
"></span><br>
/** 
 * For HBASE-2156
 * @throws Exception
 */
@Test public void testScanVariableReuse() throws Exception {
  Scan scan=new Scan();
  scan.addFamily(FAMILY);
  scan.addColumn(FAMILY,ROW);
  assertTrue(scan.getFamilyMap().get(FAMILY).size() == 1);
  scan=new Scan();
  scan.addFamily(FAMILY);
  assertTrue(scan.getFamilyMap().get(FAMILY) == null);
  assertTrue(scan.getFamilyMap().containsKey(FAMILY));
}

</code></pre>

<pre class="type-7 type-5 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects/variable are equal to an expected value ">EqualityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects/variable are equal to an expected value 
"></span><br>
@Test public void testCheckAndPutWithCompareOp() throws IOException {
  final byte[] value1=Bytes.toBytes("aaaa");
  final byte[] value2=Bytes.toBytes("bbbb");
  final byte[] value3=Bytes.toBytes("cccc");
  final byte[] value4=Bytes.toBytes("dddd");
  Table table=TEST_UTIL.createTable(TableName.valueOf("testCheckAndPutWithCompareOp"),FAMILY);
  Put put2=new Put(ROW);
  put2.addColumn(FAMILY,QUALIFIER,value2);
  Put put3=new Put(ROW);
  put3.addColumn(FAMILY,QUALIFIER,value3);
  boolean ok=table.checkAndPut(ROW,FAMILY,QUALIFIER,null,put2);
  assertEquals(ok,true);
  ok=table.checkAndPut(ROW,FAMILY,QUALIFIER,CompareOp.GREATER,value1,put2);
  assertEquals(ok,false);
  ok=table.checkAndPut(ROW,FAMILY,QUALIFIER,CompareOp.EQUAL,value1,put2);
  assertEquals(ok,false);
  ok=table.checkAndPut(ROW,FAMILY,QUALIFIER,CompareOp.GREATER_OR_EQUAL,value1,put2);
  assertEquals(ok,false);
  ok=table.checkAndPut(ROW,FAMILY,QUALIFIER,CompareOp.LESS,value1,put2);
  assertEquals(ok,true);
  ok=table.checkAndPut(ROW,FAMILY,QUALIFIER,CompareOp.LESS_OR_EQUAL,value1,put2);
  assertEquals(ok,true);
  ok=table.checkAndPut(ROW,FAMILY,QUALIFIER,CompareOp.NOT_EQUAL,value1,put3);
  assertEquals(ok,true);
  ok=table.checkAndPut(ROW,FAMILY,QUALIFIER,CompareOp.LESS,value4,put3);
  assertEquals(ok,false);
  ok=table.checkAndPut(ROW,FAMILY,QUALIFIER,CompareOp.LESS_OR_EQUAL,value4,put3);
  assertEquals(ok,false);
  ok=table.checkAndPut(ROW,FAMILY,QUALIFIER,CompareOp.EQUAL,value4,put3);
  assertEquals(ok,false);
  ok=table.checkAndPut(ROW,FAMILY,QUALIFIER,CompareOp.GREATER,value4,put3);
  assertEquals(ok,true);
  ok=table.checkAndPut(ROW,FAMILY,QUALIFIER,CompareOp.GREATER_OR_EQUAL,value4,put3);
  assertEquals(ok,true);
  ok=table.checkAndPut(ROW,FAMILY,QUALIFIER,CompareOp.NOT_EQUAL,value4,put2);
  assertEquals(ok,true);
  ok=table.checkAndPut(ROW,FAMILY,QUALIFIER,CompareOp.GREATER,value2,put2);
  assertEquals(ok,false);
  ok=table.checkAndPut(ROW,FAMILY,QUALIFIER,CompareOp.NOT_EQUAL,value2,put2);
  assertEquals(ok,false);
  ok=table.checkAndPut(ROW,FAMILY,QUALIFIER,CompareOp.LESS,value2,put2);
  assertEquals(ok,false);
  ok=table.checkAndPut(ROW,FAMILY,QUALIFIER,CompareOp.GREATER_OR_EQUAL,value2,put2);
  assertEquals(ok,true);
  ok=table.checkAndPut(ROW,FAMILY,QUALIFIER,CompareOp.LESS_OR_EQUAL,value2,put2);
  assertEquals(ok,true);
  ok=table.checkAndPut(ROW,FAMILY,QUALIFIER,CompareOp.EQUAL,value2,put3);
  assertEquals(ok,true);
}

</code></pre>

<pre class="type-7 type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to AUT calls
- Verifies boolean conditions
"></span><br>
@Test public void testSuperSimple() throws Exception {
  TableName TABLE=TableName.valueOf("testSuperSimple");
  Table ht=TEST_UTIL.createTable(TABLE,FAMILY);
  Put put=new Put(ROW);
  put.addColumn(FAMILY,QUALIFIER,VALUE);
  ht.put(put);
  Scan scan=new Scan();
  scan.addColumn(FAMILY,TABLE.toBytes());
  ResultScanner scanner=ht.getScanner(scan);
  Result result=scanner.next();
  assertTrue("Expected null result",result == null);
  scanner.close();
}

</code></pre>

<script>$(document).ready(function() {
  $('pre code').each(function(i, block) {
    hljs.highlightBlock(block);
  });
});</script>
