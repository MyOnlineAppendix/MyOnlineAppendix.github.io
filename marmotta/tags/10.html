<h3><span class=" glyphicon glyphicon-tag"/>&nbspUtilityVerifier</h3><kbd>Verifies (un)successful execution of the test case by reporting explicitly a failure</kbd><br><br><br><h4 style="margin:0px">Class: org.apache.marmotta.client.test.ldpath.LDPathIT </h4><pre class="type-10 type-4 type-7 type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies logic rules using matcher-style statements">ConditionMatcher</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies logic rules using matcher-style statements
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testPath() throws Exception {
  LDPathClient client=new LDPathClient(config);
  try {
    List<RDFNode> result=client.evaluatePath("http://localhost:8080/Marmotta/resource/anna_schmidt","foaf:knows / foaf:name");
    Assert.assertThat(result,CoreMatchers.<RDFNode>hasItem(hasProperty("content",equalTo("Sepp Huber"))));
  }
 catch (  NotFoundException e) {
    Assert.fail(e.getMessage());
  }
}

</code></pre>

<br>
<pre class="type-10 type-4 type-7 type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies logic rules using matcher-style statements">ConditionMatcher</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies logic rules using matcher-style statements
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testProgram() throws Exception {
  LDPathClient client=new LDPathClient(config);
  try {
    Map<String,List<RDFNode>> result=client.evaluateProgram("http://localhost:8080/Marmotta/resource/hans_meier","friend = foaf:knows / foaf:name :: xsd:string; name = foaf:name :: xsd:string; interest   = foaf:interest / (rdfs:label[@en] | rdfs:label[@none] | <http://rdf.freebase.com/ns/type.object.name>[@en]) :: xsd:string;");
    Assert.assertThat(result,hasKey("interest"));
    Assert.assertThat(result.get("interest"),CoreMatchers.<RDFNode>hasItem(hasProperty("content",equalTo("GNU/Linux"))));
  }
 catch (  NotFoundException e) {
    Assert.fail(e.getMessage());
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.marmotta.client.test.sparql.SPARQLIT </h4><pre class="type-10 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testSparqlUpdateGraph() throws Exception {
  SPARQLClient client=new SPARQLClient(config);
  try {
    client.update("INSERT DATA { \n" + "  GRAPH <http://BookStore.com> {  \n" + "    <http://www.dajobe.org/foaf.rdf#i> <http://purl.org/dc/elements/1.1/date> \"1999-04-01T00:00:00\" . \n"+ "    <http://www.w3.org/People/Berners-Lee/card#i> <http://purl.org/dc/elements/1.1/date> \"1998-05-03T00:00:00\" .  \n"+ "    <http://www.w3.org/People/Connolly/#me> <http://purl.org/dc/elements/1.1/date> \"2001-02-08T00:00:00\"  \n"+ "  } \n"+ "}");
  }
 catch (  Exception e) {
    Assert.fail("Update query failed: " + e.getMessage());
  }
}

</code></pre>

<br>
<pre class="type-10 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
"></span><br>
@Test public void testSparqlUpdate() throws Exception {
  SPARQLClient client=new SPARQLClient(config);
  try {
    client.update("INSERT DATA { \n" + "    <http://www.dajobe.org/foaf.rdf#i> <http://purl.org/dc/elements/1.1/date> \"1999-04-01T00:00:00\" . \n" + "    <http://www.w3.org/People/Berners-Lee/card#i> <http://purl.org/dc/elements/1.1/date> \"1998-05-03T00:00:00\" .  \n"+ "    <http://www.w3.org/People/Connolly/#me> <http://purl.org/dc/elements/1.1/date> \"2001-02-08T00:00:00\"  \n"+ "}");
  }
 catch (  Exception e) {
    Assert.fail("Update query failed: " + e.getMessage());
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.marmotta.commons.sesame.rio.ical.TestICalParser </h4><pre class="type-11 type-10 type-9 type-4 type-12 type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Sets implicit assumptions ">AssumptionSetter</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Sets implicit assumptions 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void runTest() throws Exception {
  log.info("running test {} ...",fileName);
  InputStream ical=this.getClass().getResourceAsStream(fileName + ".ics");
  InputStream sparql=this.getClass().getResourceAsStream(fileName + ".sparql");
  assumeThat("Could not load testfiles",asList(ical,sparql),everyItem(notNullValue(InputStream.class)));
  Repository repository=new SailRepository(new MemoryStore());
  repository.initialize();
  RepositoryConnection connection=repository.getConnection();
  try {
    connection.add(ical,"http://localhost/ical/",ICalFormat.FORMAT);
    connection.commit();
  }
 catch (  Exception ex) {
    ex.printStackTrace();
    fail("parsing " + fileName + " failed!");
  }
  assertTrue(connection.size() > 0);
  int count=Iterations.asList(connection.getStatements(null,null,null,false)).size();
  assertTrue(count > 0);
  BooleanQuery sparqlQuery=(BooleanQuery)connection.prepareQuery(QueryLanguage.SPARQL,IOUtils.toString(sparql));
  assertTrue("SPARQL query evaluation for " + fileName + " failed",sparqlQuery.evaluate());
  connection.close();
  repository.shutDown();
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.marmotta.commons.sesame.rio.rss.TestAtomParser </h4><pre class="type-11 type-10 type-9 type-4 type-12 type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Sets implicit assumptions ">AssumptionSetter</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Sets implicit assumptions 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void runTest() throws Exception {
  log.info("running test {} ...",fileName);
  InputStream atom=this.getClass().getResourceAsStream(fileName + ".atom");
  InputStream sparql=this.getClass().getResourceAsStream(fileName + ".sparql");
  assumeThat("Could not load testfiles",asList(atom,sparql),everyItem(notNullValue(InputStream.class)));
  Repository repository=new SailRepository(new MemoryStore());
  repository.initialize();
  RepositoryConnection connection=repository.getConnection();
  try {
    connection.add(atom,"http://localhost/atom/",AtomFormat.FORMAT);
    connection.commit();
  }
 catch (  Exception ex) {
    ex.printStackTrace();
    fail("parsing " + fileName + " failed!");
  }
  assertTrue(connection.size() > 0);
  int count=Iterations.asList(connection.getStatements(null,null,null,false)).size();
  assertTrue(count > 0);
  BooleanQuery sparqlQuery=(BooleanQuery)connection.prepareQuery(QueryLanguage.SPARQL,IOUtils.toString(sparql).replaceAll("http://rdfa.digitalbazaar.com/test-suite/test-cases/xhtml1/rdfa1.1/","http://localhost/rdfa/"));
  assertTrue("SPARQL query evaluation for " + fileName + " failed",sparqlQuery.evaluate());
  connection.close();
  repository.shutDown();
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.marmotta.commons.sesame.rio.rss.TestRSSParser </h4><pre class="type-11 type-10 type-9 type-4 type-12 type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Sets implicit assumptions ">AssumptionSetter</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Sets implicit assumptions 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void runTest() throws Exception {
  log.info("running test {} ...",fileName);
  InputStream rss=this.getClass().getResourceAsStream(fileName + ".rss");
  InputStream sparql=this.getClass().getResourceAsStream(fileName + ".sparql");
  assumeThat("Could not load testfiles",asList(rss,sparql),everyItem(notNullValue(InputStream.class)));
  Repository repository=new SailRepository(new MemoryStore());
  repository.initialize();
  RepositoryConnection connection=repository.getConnection();
  try {
    connection.add(rss,"http://localhost/rss/",RSSFormat.FORMAT);
    connection.commit();
  }
 catch (  Exception ex) {
    ex.printStackTrace();
    fail("parsing " + fileName + " failed!");
  }
  assertTrue(connection.size() > 0);
  int count=Iterations.asList(connection.getStatements(null,null,null,false)).size();
  assertTrue(count > 0);
  BooleanQuery sparqlQuery=(BooleanQuery)connection.prepareQuery(QueryLanguage.SPARQL,IOUtils.toString(sparql).replaceAll("http://rdfa.digitalbazaar.com/test-suite/test-cases/xhtml1/rdfa1.1/","http://localhost/rdfa/"));
  assertTrue("SPARQL query evaluation for " + fileName + " failed",sparqlQuery.evaluate());
  connection.close();
  repository.shutDown();
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.marmotta.commons.sesame.rio.vcard.TestVCardParser </h4><pre class="type-11 type-10 type-9 type-4 type-12 type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Sets implicit assumptions ">AssumptionSetter</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Sets implicit assumptions 
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void runTest() throws Exception {
  log.info("running test {} ...",fileName);
  InputStream vcard=this.getClass().getResourceAsStream(fileName + ".vcf");
  InputStream sparql=this.getClass().getResourceAsStream(fileName + ".sparql");
  assumeThat("Could not load testfiles",asList(vcard,sparql),everyItem(notNullValue(InputStream.class)));
  Repository repository=new SailRepository(new MemoryStore());
  repository.initialize();
  RepositoryConnection connection=repository.getConnection();
  try {
    connection.add(vcard,"http://localhost/vcard/",VCardFormat.FORMAT);
    connection.commit();
  }
 catch (  Exception ex) {
    ex.printStackTrace();
    fail("parsing " + fileName + " failed!");
  }
  assertTrue(connection.size() > 0);
  int count=Iterations.asList(connection.getStatements(null,null,null,false)).size();
  assertTrue(count > 0);
  BooleanQuery sparqlQuery=(BooleanQuery)connection.prepareQuery(QueryLanguage.SPARQL,IOUtils.toString(sparql).replaceAll("http://rdfa.digitalbazaar.com/test-suite/test-cases/xhtml1/rdfa1.1/","http://localhost/rdfa/"));
  assertTrue("SPARQL query evaluation for " + fileName + " failed",sparqlQuery.evaluate());
  connection.close();
  repository.shutDown();
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.marmotta.kiwi.reasoner.test.engine.ReasoningEngineTest </h4><pre class="type-14 type-15 type-10 type-9 type-4 type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions in iterations">IterativeVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies assertions inside branch conditions">BranchVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies assertions in iterations
- Verifies assertions inside branch conditions
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Contains more than 2 JUnit-based stereotypes
"></span><br>
/** 
 * Test running a full reasoning over the triple store based on the simple program and the simple.ttl data file.
 * Test if the expected triples are present. Since we are only evaluating a single reasoning round, we cannot
 * expect more complicated triples that involve chaining.
 * @throws Exception
 */
@Test public void testFullReasoning() throws Exception {
  RepositoryConnection con=repository.getConnection();
  KiWiReasoningConnection rcon=rpersistence.getConnection();
  try {
    con.begin();
    Resource a=con.getValueFactory().createURI(NS + "a");
    Resource b=con.getValueFactory().createURI(NS + "b");
    Resource c=con.getValueFactory().createURI(NS + "c");
    Resource d=con.getValueFactory().createURI(NS + "d");
    URI t=con.getValueFactory().createURI(NS + "transitive");
    URI s=con.getValueFactory().createURI(NS + "symmetric");
    con.add(this.getClass().getResourceAsStream("simple.ttl"),"http://localhost/resource/",RDFFormat.TURTLE);
    con.commit();
    engine.reRunPrograms();
    while (engine.isRunning()) {
      log.debug("sleeping for 100ms to let engine finish processing ... ");
      Thread.sleep(100);
    }
    con.begin();
    Assert.assertTrue("expected inferred triple not found",con.hasStatement(a,t,c,true));
    Assert.assertTrue("expected inferred triple not found",con.hasStatement(b,t,d,true));
    Assert.assertTrue("expected inferred triple not found",con.hasStatement(b,s,a,true));
    Resource[][] patterns=new Resource[][]{new Resource[]{a,t,c},new Resource[]{b,t,d},new Resource[]{b,s,a}};
    RepositoryResult<Statement> result=con.getStatements(null,null,null,true,con.getValueFactory().createURI(store.getInferredContext()));
    if (result.hasNext()) {
      while (result.hasNext()) {
        Statement stmt1=result.next();
        CloseableIteration<Justification,SQLException> justs1=rcon.listJustificationsForTriple((KiWiTriple)stmt1);
        Assert.assertTrue(justs1.hasNext());
      }
    }
 else {
      fail("no inferred statements found");
    }
    con.commit();
  }
  finally {
    con.close();
    rcon.close();
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.marmotta.ldclient.test.TestLDClientTest </h4><pre class="type-10 type-18 type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies that exceptions are thrown during the test case execution">ExceptionVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies that exceptions are thrown during the test case execution
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(expected=DataRetrievalException.class) public void testLocalhostInvalidPort() throws Exception {
  client.retrieveResource("http://127.1.2.3:66000/");
  Assert.fail();
}

</code></pre>

<br>
<pre class="type-10 type-18 type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies that exceptions are thrown during the test case execution">ExceptionVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies that exceptions are thrown during the test case execution
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(expected=UnsupportedOperationException.class) public void testMissingProvider() throws Exception {
  client.retrieveResource("ftp://no.provider.for/this/url");
  Assert.fail();
}

</code></pre>

<br>
<pre class="type-10 type-18 type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies that exceptions are thrown during the test case execution">ExceptionVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies that exceptions are thrown during the test case execution
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(expected=UnsupportedOperationException.class) public void testConnectionRefused() throws Exception {
  client.retrieveResource("http://no.host.for/this/url");
  Assert.fail();
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.marmotta.ldpath.model.functions.xml.XmlTextFunctionTest </h4><pre class="type-13 type-10 type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Allocates resources before the execution of the test cases">TestInitializer</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Allocates resources before the execution of the test cases
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Before public void setUp(){
  try {
    final SailRepositoryConnection conn=repository.getConnection();
    try {
      conn.begin();
      resource=createURI("foo","Start");
      prop=createURI("ex","text");
      conn.add(resource,prop,conn.getValueFactory().createLiteral(XML_TEXT));
      conn.commit();
    }
 catch (    final Throwable t) {
      conn.rollback();
      fail(t.getMessage());
    }
 finally {
      conn.close();
    }
  }
 catch (  RepositoryException e) {
    fail("Could not create test-data");
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.marmotta.ldpath.parser.ParserTest </h4><pre class="type-10 type-4 type-6 type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testParseTest() throws IOException {
  LdPathParser<String> parser=createParser("test.ldpath");
  try {
    NodeTest<String> test=parser.parseTest(NAMESPACES);
    assertNotNull(test);
    assertNotNull(test.getPathExpression(backend));
  }
 catch (  ParseException e) {
    fail(e.getMessage());
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.marmotta.ldpath.parser.SelectorsTest </h4><pre class="type-11 type-10 type-7 type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies logic rules using matcher-style statements">ConditionMatcher</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies logic rules using matcher-style statements
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testParseSelector(){
  final String className="org.apache.marmotta.ldpath.model.selectors." + name + "Selector";
  try {
    final Class<?> cls=Class.forName(className);
    Assert.assertThat(selector,CoreMatchers.instanceOf(cls));
  }
 catch (  ClassNotFoundException e) {
    Assert.fail("Could not load class: " + className);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.marmotta.ldpath.parser.TestsTest </h4><pre class="type-11 type-10 type-7 type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to API calls (Java or TPL) ">APIUtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies logic rules using matcher-style statements">ConditionMatcher</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies values of objects/variables related to API calls (Java or TPL) 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies logic rules using matcher-style statements
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testParseSelector(){
  final String className="org.apache.marmotta.ldpath.model.tests." + name + "Test";
  try {
    final Class<?> cls=Class.forName(className);
    Assert.assertThat(test,CoreMatchers.instanceOf(cls));
  }
 catch (  ClassNotFoundException e) {
    Assert.fail("Could not load class: " + className);
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.marmotta.platform.core.test.user.UserServiceTest </h4><pre class="type-10 type-9 type-4 type-6 type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies boolean conditions">BooleanVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies values of objects/variables related to AUT calls">InternalCallVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies whether objects are null">NullVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies boolean conditions
- Verifies values of objects/variables related to AUT calls
- Verifies whether objects are null
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test public void testCreateUser(){
  String login=RandomStringUtils.randomAlphabetic(8);
  try {
    URI user=userService.createUser(login);
    Assert.assertNotNull(user);
    Assert.assertFalse(userService.isAnonymous(user));
    Assert.assertTrue(user.stringValue().endsWith(login));
    Assert.assertTrue(userService.userExists(login));
    Assert.assertNotNull(userService.getUser(login));
  }
 catch (  UserExistsException ex) {
    Assert.fail(ex.getMessage());
  }
}

</code></pre>

<br>
<h4 style="margin:0px">Class: org.apache.marmotta.platform.ldp.patch.RdfPatchUtilTest </h4><pre class="type-10 type-18 type-8 "><code><span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies (un)successful execution of the test case by reporting explicitly a failure">UtilityVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Verifies that exceptions are thrown during the test case execution">ExceptionVerifier</span>&nbsp;<span class="label label-info" style="display: inline-block;" data-toggle="tooltip" title="Contains more than 2 JUnit-based stereotypes">HybridVerifier</span>&nbsp;<span class=" glyphicon glyphicon-comment" aria-hidden="true" label-info" data-toggle="tooltip" title="This method/test case: 
- Verifies (un)successful execution of the test case by reporting explicitly a failure
- Verifies that exceptions are thrown during the test case execution
- Contains more than 2 JUnit-based stereotypes
"></span><br>
@Test(expected=InvalidPatchDocumentException.class) public void testInvalidPatchDocumentException() throws RepositoryException, ParseException, InvalidPatchDocumentException {
  RepositoryConnection con=repository.getConnection();
  try {
    final String invalidPatch="A <http://example/foo> R <http://example/bar> .";
    RdfPatchUtil.applyPatch(con,invalidPatch);
    Assert.fail("applyPatch should throw an InvalidPatchDocumentException");
  }
 catch (  final Throwable t) {
    con.rollback();
    throw t;
  }
 finally {
    con.close();
  }
}

</code></pre>

<br>
<script>$(document).ready(function() {
  $('pre code').each(function(i, block) {
    hljs.highlightBlock(block);
  });
});</script>
